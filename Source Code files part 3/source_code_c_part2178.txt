C hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ __RPC__in ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMApp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMApp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    ( (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev) ) 

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    ( (This)->lpVtbl -> CreateContext(This,phIMC) ) 

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    ( (This)->lpVtbl -> DestroyContext(This,hIME) ) 

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    ( (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate) ) 

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    ( (This)->lpVtbl -> GetContext(This,hWnd,phIMC) ) 

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    ( (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence) ) 

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    ( (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd) ) 

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    ( (This)->lpVtbl -> GetOpenStatus(This,hIMC) ) 

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty) ) 

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    ( (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey) ) 

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMApp_IsIME(This,hKL)	\
    ( (This)->lpVtbl -> IsIME(This,hKL) ) 

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    ( (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC) ) 

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    ( (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate) ) 

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    ( (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence) ) 

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    ( (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen) ) 

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    ( (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID) ) 

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    ( (This)->lpVtbl -> Activate(This,fRestoreLayout) ) 

#define IActiveIMMApp_Deactivate(This)	\
    ( (This)->lpVtbl -> Deactivate(This) ) 

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult) ) 

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    ( (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize) ) 

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage) ) 

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,hKL,plid) ) 

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    ( (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags) ) 

#define IActiveIMMApp_DisableIME(This,idThread)	\
    ( (This)->lpVtbl -> DisableIME(This,idThread) ) 

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    ( (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__deref_out_opt INPUTCONTEXT **ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ __RPC__out UINT *puModifiers,
            /* [out] */ __RPC__out UINT *puVKey,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ __RPC__in HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ __RPC__deref_out_opt HWND *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ __RPC__in HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ __RPC__in HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMIME * This,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMessage )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__deref_out_opt INPUTCONTEXT **ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *ReSizeIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCSize )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ __RPC__out UINT *puModifiers,
            /* [out] */ __RPC__out UINT *puVKey,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ UINT uType,
            /* [in] */ __RPC__in HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ __RPC__deref_out_opt HWND *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *KeybdEvent )( 
            IActiveIMMIME * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCA )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCW )( 
            IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsSleeping )( 
            IActiveIMMIME * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMIME_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMIME_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    ( (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev) ) 

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    ( (This)->lpVtbl -> CreateContext(This,phIMC) ) 

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    ( (This)->lpVtbl -> DestroyContext(This,hIME) ) 

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    ( (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate) ) 

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    ( (This)->lpVtbl -> GetContext(This,hWnd,phIMC) ) 

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    ( (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence) ) 

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    ( (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd) ) 

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    ( (This)->lpVtbl -> GetOpenStatus(This,hIMC) ) 

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty) ) 

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    ( (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey) ) 

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMIME_IsIME(This,hKL)	\
    ( (This)->lpVtbl -> IsIME(This,hKL) ) 

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    ( (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC) ) 

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    ( (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate) ) 

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    ( (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence) ) 

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    ( (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen) ) 

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    ( (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID) ) 

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    ( (This)->lpVtbl -> GenerateMessage(This,hIMC) ) 

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    ( (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC) ) 

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    ( (This)->lpVtbl -> UnlockIMC(This,hIMC) ) 

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    ( (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount) ) 

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    ( (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC) ) 

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    ( (This)->lpVtbl -> DestroyIMCC(This,hIMCC) ) 

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    ( (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv) ) 

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    ( (This)->lpVtbl -> UnlockIMCC(This,hIMCC) ) 

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    ( (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC) ) 

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    ( (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize) ) 

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    ( (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount) ) 

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    ( (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL) ) 

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    ( (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL) ) 

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    ( (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd) ) 

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    ( (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd) ) 

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    ( (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow) ) 

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage) ) 

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,hKL,plid) ) 

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    ( (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo) ) 

#define IActiveIMMIME_LockModal(This)	\
    ( (This)->lpVtbl -> LockModal(This) ) 

#define IActiveIMMIME_UnlockModal(This)	\
    ( (This)->lpVtbl -> UnlockModal(This) ) 

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    ( (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags) ) 

#define IActiveIMMIME_DisableIME(This,idThread)	\
    ( (This)->lpVtbl -> DisableIME(This,idThread) ) 

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    ( (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum) ) 

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult) ) 

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult) ) 

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult) ) 

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult) ) 

#define IActiveIMMIME_IsSleeping(This)	\
    ( (This)->lpVtbl -> IsSleeping(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME * This,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME * This,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME * This,
            /* [out] */ __RPC__out LANGID *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIME_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIME_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    ( (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate) ) 

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    ( (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied) ) 

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    ( (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord) ) 

#define IActiveIME_Destroy(This,uReserved)	\
    ( (This)->lpVtbl -> Destroy(This,uReserved) ) 

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult) ) 

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    ( (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag) ) 

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    ( (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState) ) 

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIME_Select(This,hIMC,fSelect)	\
    ( (This)->lpVtbl -> Select(This,hIMC,fSelect) ) 

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    ( (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize) ) 

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    ( (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize) ) 

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum) ) 

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,uCodePage) ) 

#define IActiveIME_GetLangId(This,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,plid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME2 * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME2 * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME2 * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME2 * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME2 * This,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME2 * This,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME2 * This,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unsleep )( 
            IActiveIME2 * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIME2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIME2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    ( (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate) ) 

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    ( (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied) ) 

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    ( (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord) ) 

#define IActiveIME2_Destroy(This,uReserved)	\
    ( (This)->lpVtbl -> Destroy(This,uReserved) ) 

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult) ) 

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    ( (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag) ) 

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    ( (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState) ) 

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    ( (This)->lpVtbl -> Select(This,hIMC,fSelect) ) 

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    ( (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize) ) 

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    ( (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize) ) 

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum) ) 

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,uCodePage) ) 

#define IActiveIME2_GetLangId(This,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,plid) ) 


#define IActiveIME2_Sleep(This)	\
    ( (This)->lpVtbl -> Sleep(This) ) 

#define IActiveIME2_Unsleep(This,fDead)	\
    ( (This)->lpVtbl -> Unsleep(This,fDead) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dispatch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dispatch.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should #include oleauto.h instead of dispatch.h")
#endif /* !RC_INVOKED */

#include <oleauto.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dinput.h ===
/****************************************************************************
 *
 *  Copyright (C) 1996-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinput.h
 *  Content:    DirectInput include file
 *
 ****************************************************************************/

#ifndef __DINPUT_INCLUDED__
#define __DINPUT_INCLUDED__

#ifndef DIJ_RINGZERO

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#endif /* DIJ_RINGZERO */

#ifdef __cplusplus
extern "C" {
#endif





/*
 *  To build applications for older versions of DirectInput
 *
 *  #define DIRECTINPUT_VERSION [ 0x0300 | 0x0500 | 0x0700 ]
 *
 *  before #include <dinput.h>.  By default, #include <dinput.h>
 *  will produce a DirectX 8-compatible header file.
 *
 */

#define DIRECTINPUT_HEADER_VERSION  0x0800
#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         DIRECTINPUT_HEADER_VERSION
#pragma message(__FILE__ ": DIRECTINPUT_VERSION undefined. Defaulting to version 0x0800")
#endif

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      Class IDs
 *
 ****************************************************************************/

DEFINE_GUID(CLSID_DirectInput,       0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice, 0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(CLSID_DirectInput8,      0x25E609E4,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice8,0x25E609E5,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput7A,    0x9A4CB684,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInput7W,    0x9A4CB685,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInput8A,    0xBF798030,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
DEFINE_GUID(IID_IDirectInput8W,    0xBF798031,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice7A,0x57D7C6BC,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInputDevice7W,0x57D7C6BD,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInputDevice8A,0x54D41080,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
DEFINE_GUID(IID_IDirectInputDevice8W,0x54D41081,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

/****************************************************************************
 *
 *      Predefined object types
 *
 ****************************************************************************/

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined product GUIDs
 *
 ****************************************************************************/

DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm, 0x6F1D2B80,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm2,0x6F1D2B81,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm, 0x6F1D2B82,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm2,0x6F1D2B83,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined force feedback effects
 *
 ****************************************************************************/

DEFINE_GUID(GUID_ConstantForce, 0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,     0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,        0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,          0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,      0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,    0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown,  0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,        0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,        0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,       0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,      0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,   0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Interfaces and Structures...
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0500)

/****************************************************************************
 *
 *      IDirectInputEffect
 *
 ****************************************************************************/

#define DIEFT_ALL                   0x00000000

#define DIEFT_CONSTANTFORCE         0x00000001
#define DIEFT_RAMPFORCE             0x00000002
#define DIEFT_PERIODIC              0x00000003
#define DIEFT_CONDITION             0x00000004
#define DIEFT_CUSTOMFORCE           0x00000005
#define DIEFT_HARDWARE              0x000000FF
#define DIEFT_FFATTACK              0x00000200
#define DIEFT_FFFADE                0x00000400
#define DIEFT_SATURATION            0x00000800
#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
#define DIEFT_POSNEGSATURATION      0x00002000
#define DIEFT_DEADBAND              0x00004000
#define DIEFT_STARTDELAY            0x00008000
#define DIEFT_GETTYPE(n)            LOBYTE(n)

#define DI_DEGREES                  100
#define DI_FFNOMINALMAX             10000
#define DI_SECONDS                  1000000

typedef struct DICONSTANTFORCE {
    LONG  lMagnitude;
} DICONSTANTFORCE, *LPDICONSTANTFORCE;
typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;

typedef struct DIRAMPFORCE {
    LONG  lStart;
    LONG  lEnd;
} DIRAMPFORCE, *LPDIRAMPFORCE;
typedef const DIRAMPFORCE *LPCDIRAMPFORCE;

typedef struct DIPERIODIC {
    DWORD dwMagnitude;
    LONG  lOffset;
    DWORD dwPhase;
    DWORD dwPeriod;
} DIPERIODIC, *LPDIPERIODIC;
typedef const DIPERIODIC *LPCDIPERIODIC;

typedef struct DICONDITION {
    LONG  lOffset;
    LONG  lPositiveCoefficient;
    LONG  lNegativeCoefficient;
    DWORD dwPositiveSaturation;
    DWORD dwNegativeSaturation;
    LONG  lDeadBand;
} DICONDITION, *LPDICONDITION;
typedef const DICONDITION *LPCDICONDITION;

typedef struct DICUSTOMFORCE {
    DWORD cChannels;
    DWORD dwSamplePeriod;
    DWORD cSamples;
    LPLONG rglForceData;
} DICUSTOMFORCE, *LPDICUSTOMFORCE;
typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;


typedef struct DIENVELOPE {
    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
    DWORD dwAttackLevel;
    DWORD dwAttackTime;             /* Microseconds         */
    DWORD dwFadeLevel;
    DWORD dwFadeTime;               /* Microseconds         */
} DIENVELOPE, *LPDIENVELOPE;
typedef const DIENVELOPE *LPCDIENVELOPE;


/* This structure is defined for DirectX 5.0 compatibility */
typedef struct DIEFFECT_DX5 {
    DWORD dwSize;                   /* sizeof(DIEFFECT_DX5) */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
} DIEFFECT_DX5, *LPDIEFFECT_DX5;
typedef const DIEFFECT_DX5 *LPCDIEFFECT_DX5;

typedef struct DIEFFECT {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
#if(DIRECTINPUT_VERSION >= 0x0600)
    DWORD  dwStartDelay;            /* Microseconds         */
#endif /* DIRECTINPUT_VERSION >= 0x0600 */
} DIEFFECT, *LPDIEFFECT;
typedef DIEFFECT DIEFFECT_DX6;
typedef LPDIEFFECT LPDIEFFECT_DX6;
typedef const DIEFFECT *LPCDIEFFECT;


#if(DIRECTINPUT_VERSION >= 0x0700)
#ifndef DIJ_RINGZERO
typedef struct DIFILEEFFECT{
    DWORD       dwSize;
    GUID        GuidEffect;
    LPCDIEFFECT lpDiEffect;
    CHAR        szFriendlyName[MAX_PATH];
}DIFILEEFFECT, *LPDIFILEEFFECT;
typedef const DIFILEEFFECT *LPCDIFILEEFFECT;
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSINFILECALLBACK)(LPCDIFILEEFFECT , LPVOID);
#endif /* DIJ_RINGZERO */
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#define DIEFF_OBJECTIDS             0x00000001
#define DIEFF_OBJECTOFFSETS         0x00000002
#define DIEFF_CARTESIAN             0x00000010
#define DIEFF_POLAR                 0x00000020
#define DIEFF_SPHERICAL             0x00000040

#define DIEP_DURATION               0x00000001
#define DIEP_SAMPLEPERIOD           0x00000002
#define DIEP_GAIN                   0x00000004
#define DIEP_TRIGGERBUTTON          0x00000008
#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
#define DIEP_AXES                   0x00000020
#define DIEP_DIRECTION              0x00000040
#define DIEP_ENVELOPE               0x00000080
#define DIEP_TYPESPECIFICPARAMS     0x00000100
#if(DIRECTINPUT_VERSION >= 0x0600)
#define DIEP_STARTDELAY             0x00000200
#define DIEP_ALLPARAMS_DX5          0x000001FF
#define DIEP_ALLPARAMS              0x000003FF
#else /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_ALLPARAMS              0x000001FF
#endif /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_START                  0x20000000
#define DIEP_NORESTART              0x40000000
#define DIEP_NODOWNLOAD             0x80000000
#define DIEB_NOTRIGGER              0xFFFFFFFF

#define DIES_SOLO                   0x00000001
#define DIES_NODOWNLOAD             0x80000000

#define DIEGES_PLAYING              0x00000001
#define DIEGES_EMULATED             0x00000002

typedef struct DIEFFESCAPE {
    DWORD   dwSize;
    DWORD   dwCommand;
    LPVOID  lpvInBuffer;
    DWORD   cbInBuffer;
    LPVOID  lpvOutBuffer;
    DWORD   cbOutBuffer;
} DIEFFESCAPE, *LPDIEFFESCAPE;

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputEffect

DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffect methods ***/
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(Download)(THIS) PURE;
    STDMETHOD(Unload)(THIS) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
};

typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#else
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffect_AddRef(p) (p)->AddRef()
#define IDirectInputEffect_Release(p) (p)->Release()
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
#define IDirectInputEffect_Stop(p) (p)->Stop()
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
#define IDirectInputEffect_Download(p) (p)->Download()
#define IDirectInputEffect_Unload(p) (p)->Unload()
#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      IDirectInputDevice
 *
 ****************************************************************************/

#if DIRECTINPUT_VERSION <= 0x700
#define DIDEVTYPE_DEVICE        1
#define DIDEVTYPE_MOUSE         2
#define DIDEVTYPE_KEYBOARD      3
#define DIDEVTYPE_JOYSTICK      4

#else
#define DI8DEVCLASS_ALL             0
#define DI8DEVCLASS_DEVICE          1
#define DI8DEVCLASS_POINTER         2
#define DI8DEVCLASS_KEYBOARD        3
#define DI8DEVCLASS_GAMECTRL        4

#define DI8DEVTYPE_DEVICE           0x11
#define DI8DEVTYPE_MOUSE            0x12
#define DI8DEVTYPE_KEYBOARD         0x13
#define DI8DEVTYPE_JOYSTICK         0x14
#define DI8DEVTYPE_GAMEPAD          0x15
#define DI8DEVTYPE_DRIVING          0x16
#define DI8DEVTYPE_FLIGHT           0x17
#define DI8DEVTYPE_1STPERSON        0x18
#define DI8DEVTYPE_DEVICECTRL       0x19
#define DI8DEVTYPE_SCREENPOINTER    0x1A
#define DI8DEVTYPE_REMOTE           0x1B
#define DI8DEVTYPE_SUPPLEMENTAL     0x1C
#endif /* DIRECTINPUT_VERSION <= 0x700 */

#define DIDEVTYPE_HID           0x00010000

#if DIRECTINPUT_VERSION <= 0x700
#define DIDEVTYPEMOUSE_UNKNOWN          1
#define DIDEVTYPEMOUSE_TRADITIONAL      2
#define DIDEVTYPEMOUSE_FINGERSTICK      3
#define DIDEVTYPEMOUSE_TOUCHPAD         4
#define DIDEVTYPEMOUSE_TRACKBALL        5

#define DIDEVTYPEKEYBOARD_UNKNOWN       0
#define DIDEVTYPEKEYBOARD_PCXT          1
#define DIDEVTYPEKEYBOARD_OLIVETTI      2
#define DIDEVTYPEKEYBOARD_PCAT          3
#define DIDEVTYPEKEYBOARD_PCENH         4
#define DIDEVTYPEKEYBOARD_NOKIA1050     5
#define DIDEVTYPEKEYBOARD_NOKIA9140     6
#define DIDEVTYPEKEYBOARD_NEC98         7
#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
#define DIDEVTYPEKEYBOARD_NEC98106      9
#define DIDEVTYPEKEYBOARD_JAPAN106     10
#define DIDEVTYPEKEYBOARD_JAPANAX      11
#define DIDEVTYPEKEYBOARD_J3100        12

#define DIDEVTYPEJOYSTICK_UNKNOWN       1
#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
#define DIDEVTYPEJOYSTICK_GAMEPAD       4
#define DIDEVTYPEJOYSTICK_RUDDER        5
#define DIDEVTYPEJOYSTICK_WHEEL         6
#define DIDEVTYPEJOYSTICK_HEADTRACKER   7

#else
#define DI8DEVTYPEMOUSE_UNKNOWN                     1
#define DI8DEVTYPEMOUSE_TRADITIONAL                 2
#define DI8DEVTYPEMOUSE_FINGERSTICK                 3
#define DI8DEVTYPEMOUSE_TOUCHPAD                    4
#define DI8DEVTYPEMOUSE_TRACKBALL                   5
#define DI8DEVTYPEMOUSE_ABSOLUTE                    6

#define DI8DEVTYPEKEYBOARD_UNKNOWN                  0
#define DI8DEVTYPEKEYBOARD_PCXT                     1
#define DI8DEVTYPEKEYBOARD_OLIVETTI                 2
#define DI8DEVTYPEKEYBOARD_PCAT                     3
#define DI8DEVTYPEKEYBOARD_PCENH                    4
#define DI8DEVTYPEKEYBOARD_NOKIA1050                5
#define DI8DEVTYPEKEYBOARD_NOKIA9140                6
#define DI8DEVTYPEKEYBOARD_NEC98                    7
#define DI8DEVTYPEKEYBOARD_NEC98LAPTOP              8
#define DI8DEVTYPEKEYBOARD_NEC98106                 9
#define DI8DEVTYPEKEYBOARD_JAPAN106                10
#define DI8DEVTYPEKEYBOARD_JAPANAX                 11
#define DI8DEVTYPEKEYBOARD_J3100                   12

#define DI8DEVTYPE_LIMITEDGAMESUBTYPE               1

#define DI8DEVTYPEJOYSTICK_LIMITED                  DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEJOYSTICK_STANDARD                 2

#define DI8DEVTYPEGAMEPAD_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEGAMEPAD_STANDARD                  2
#define DI8DEVTYPEGAMEPAD_TILT                      3

#define DI8DEVTYPEDRIVING_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEDRIVING_COMBINEDPEDALS            2
#define DI8DEVTYPEDRIVING_DUALPEDALS                3
#define DI8DEVTYPEDRIVING_THREEPEDALS               4
#define DI8DEVTYPEDRIVING_HANDHELD                  5

#define DI8DEVTYPEFLIGHT_LIMITED                    DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEFLIGHT_STICK                      2
#define DI8DEVTYPEFLIGHT_YOKE                       3
#define DI8DEVTYPEFLIGHT_RC                         4

#define DI8DEVTYPE1STPERSON_LIMITED                 DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPE1STPERSON_UNKNOWN                 2
#define DI8DEVTYPE1STPERSON_SIXDOF                  3
#define DI8DEVTYPE1STPERSON_SHOOTER                 4

#define DI8DEVTYPESCREENPTR_UNKNOWN                 2
#define DI8DEVTYPESCREENPTR_LIGHTGUN                3
#define DI8DEVTYPESCREENPTR_LIGHTPEN                4
#define DI8DEVTYPESCREENPTR_TOUCH                   5

#define DI8DEVTYPEREMOTE_UNKNOWN                    2

#define DI8DEVTYPEDEVICECTRL_UNKNOWN                2
#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION         3
#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED 4

#define DI8DEVTYPESUPPLEMENTAL_UNKNOWN              2
#define DI8DEVTYPESUPPLEMENTAL_2NDHANDCONTROLLER    3
#define DI8DEVTYPESUPPLEMENTAL_HEADTRACKER          4
#define DI8DEVTYPESUPPLEMENTAL_HANDTRACKER          5
#define DI8DEVTYPESUPPLEMENTAL_SHIFTSTICKGATE       6
#define DI8DEVTYPESUPPLEMENTAL_SHIFTER              7
#define DI8DEVTYPESUPPLEMENTAL_THROTTLE             8
#define DI8DEVTYPESUPPLEMENTAL_SPLITTHROTTLE        9
#define DI8DEVTYPESUPPLEMENTAL_COMBINEDPEDALS      10
#define DI8DEVTYPESUPPLEMENTAL_DUALPEDALS          11
#define DI8DEVTYPESUPPLEMENTAL_THREEPEDALS         12
#define DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS        13
#endif /* DIRECTINPUT_VERSION <= 0x700 */

#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)

#if(DIRECTINPUT_VERSION >= 0x0500)
/* This structure is defined for DirectX 3.0 compatibility */
typedef struct DIDEVCAPS_DX3 {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVCAPS {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVCAPS, *LPDIDEVCAPS;

#define DIDC_ATTACHED           0x00000001
#define DIDC_POLLEDDEVICE       0x00000002
#define DIDC_EMULATED           0x00000004
#define DIDC_POLLEDDATAFORMAT   0x00000008
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDC_FORCEFEEDBACK      0x00000100
#define DIDC_FFATTACK           0x00000200
#define DIDC_FFFADE             0x00000400
#define DIDC_SATURATION         0x00000800
#define DIDC_POSNEGCOEFFICIENTS 0x00001000
#define DIDC_POSNEGSATURATION   0x00002000
#define DIDC_DEADBAND           0x00004000
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#define DIDC_STARTDELAY         0x00008000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDC_ALIAS              0x00010000
#define DIDC_PHANTOM            0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */
#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIDC_HIDDEN             0x00040000
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define DIDFT_ALL           0x00000000

#define DIDFT_RELAXIS       0x00000001
#define DIDFT_ABSAXIS       0x00000002
#define DIDFT_AXIS          0x00000003

#define DIDFT_PSHBUTTON     0x00000004
#define DIDFT_TGLBUTTON     0x00000008
#define DIDFT_BUTTON        0x0000000C

#define DIDFT_POV           0x00000010
#define DIDFT_COLLECTION    0x00000040
#define DIDFT_NODATA        0x00000080

#define DIDFT_ANYINSTANCE   0x00FFFF00
#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
#define DIDFT_GETTYPE(n)     LOBYTE(n)
#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
#define DIDFT_FFACTUATOR        0x01000000
#define DIDFT_FFEFFECTTRIGGER   0x02000000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDFT_OUTPUT            0x10000000
#define DIDFT_VENDORDEFINED     0x04000000
#define DIDFT_ALIAS             0x08000000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
#define DIDFT_NOCOLLECTION      0x00FFFF00

#ifndef DIJ_RINGZERO

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIDATAFORMAT {
    DWORD   dwSize;
    DWORD   dwObjSize;
    DWORD   dwFlags;
    DWORD   dwDataSize;
    DWORD   dwNumObjs;
    LPDIOBJECTDATAFORMAT rgodf;
} DIDATAFORMAT, *LPDIDATAFORMAT;
typedef const DIDATAFORMAT *LPCDIDATAFORMAT;

#define DIDF_ABSAXIS            0x00000001
#define DIDF_RELAXIS            0x00000002

#ifdef __cplusplus
extern "C" {
#endif
extern const DIDATAFORMAT c_dfDIMouse;

#if(DIRECTINPUT_VERSION >= 0x0700)
extern const DIDATAFORMAT c_dfDIMouse2;
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

extern const DIDATAFORMAT c_dfDIKeyboard;

#if(DIRECTINPUT_VERSION >= 0x0500)
extern const DIDATAFORMAT c_dfDIJoystick;
extern const DIDATAFORMAT c_dfDIJoystick2;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#ifdef __cplusplus
};
#endif


#if DIRECTINPUT_VERSION > 0x0700

typedef struct _DIACTIONA {
                UINT_PTR    uAppData;
                DWORD       dwSemantic;
    OPTIONAL    DWORD       dwFlags;
    OPTIONAL    union {
                    LPCSTR      lptszActionName;
                    UINT        uResIdString;
                };
    OPTIONAL    GUID        guidInstance;
    OPTIONAL    DWORD       dwObjID;
    OPTIONAL    DWORD       dwHow;
} DIACTIONA, *LPDIACTIONA ;
typedef struct _DIACTIONW {
                UINT_PTR    uAppData;
                DWORD       dwSemantic;
    OPTIONAL    DWORD       dwFlags;
    OPTIONAL    union {
                    LPCWSTR     lptszActionName;
                    UINT        uResIdString;
                };
    OPTIONAL    GUID        guidInstance;
    OPTIONAL    DWORD       dwObjID;
    OPTIONAL    DWORD       dwHow;
} DIACTIONW, *LPDIACTIONW ;
#ifdef UNICODE
typedef DIACTIONW DIACTION;
typedef LPDIACTIONW LPDIACTION;
#else
typedef DIACTIONA DIACTION;
typedef LPDIACTIONA LPDIACTION;
#endif // UNICODE

typedef const DIACTIONA *LPCDIACTIONA;
typedef const DIACTIONW *LPCDIACTIONW;
#ifdef UNICODE
typedef DIACTIONW DIACTION;
typedef LPCDIACTIONW LPCDIACTION;
#else
typedef DIACTIONA DIACTION;
typedef LPCDIACTIONA LPCDIACTION;
#endif // UNICODE
typedef const DIACTION *LPCDIACTION;


#define DIA_FORCEFEEDBACK       0x00000001
#define DIA_APPMAPPED           0x00000002
#define DIA_APPNOMAP            0x00000004
#define DIA_NORANGE             0x00000008
#define DIA_APPFIXED            0x00000010

#define DIAH_UNMAPPED           0x00000000
#define DIAH_USERCONFIG         0x00000001
#define DIAH_APPREQUESTED       0x00000002
#define DIAH_HWAPP              0x00000004
#define DIAH_HWDEFAULT          0x00000008
#define DIAH_DEFAULT            0x00000020
#define DIAH_ERROR              0x80000000

typedef struct _DIACTIONFORMATA {
                DWORD       dwSize;
                DWORD       dwActionSize;
                DWORD       dwDataSize;
                DWORD       dwNumActions;
                LPDIACTIONA rgoAction;
                GUID        guidActionMap;
                DWORD       dwGenre;
                DWORD       dwBufferSize;
    OPTIONAL    LONG        lAxisMin;
    OPTIONAL    LONG        lAxisMax;
    OPTIONAL    HINSTANCE   hInstString;
                FILETIME    ftTimeStamp;
                DWORD       dwCRC;
                CHAR        tszActionMap[MAX_PATH];
} DIACTIONFORMATA, *LPDIACTIONFORMATA;
typedef struct _DIACTIONFORMATW {
                DWORD       dwSize;
                DWORD       dwActionSize;
                DWORD       dwDataSize;
                DWORD       dwNumActions;
                LPDIACTIONW rgoAction;
                GUID        guidActionMap;
                DWORD       dwGenre;
                DWORD       dwBufferSize;
    OPTIONAL    LONG        lAxisMin;
    OPTIONAL    LONG        lAxisMax;
    OPTIONAL    HINSTANCE   hInstString;
                FILETIME    ftTimeStamp;
                DWORD       dwCRC;
                WCHAR       tszActionMap[MAX_PATH];
} DIACTIONFORMATW, *LPDIACTIONFORMATW;
#ifdef UNICODE
typedef DIACTIONFORMATW DIACTIONFORMAT;
typedef LPDIACTIONFORMATW LPDIACTIONFORMAT;
#else
typedef DIACTIONFORMATA DIACTIONFORMAT;
typedef LPDIACTIONFORMATA LPDIACTIONFORMAT;
#endif // UNICODE
typedef const DIACTIONFORMATA *LPCDIACTIONFORMATA;
typedef const DIACTIONFORMATW *LPCDIACTIONFORMATW;
#ifdef UNICODE
typedef DIACTIONFORMATW DIACTIONFORMAT;
typedef LPCDIACTIONFORMATW LPCDIACTIONFORMAT;
#else
typedef DIACTIONFORMATA DIACTIONFORMAT;
typedef LPCDIACTIONFORMATA LPCDIACTIONFORMAT;
#endif // UNICODE
typedef const DIACTIONFORMAT *LPCDIACTIONFORMAT;

#define DIAFTS_NEWDEVICELOW     0xFFFFFFFF
#define DIAFTS_NEWDEVICEHIGH    0xFFFFFFFF
#define DIAFTS_UNUSEDDEVICELOW  0x00000000
#define DIAFTS_UNUSEDDEVICEHIGH 0x00000000

#define DIDBAM_DEFAULT          0x00000000
#define DIDBAM_PRESERVE         0x00000001
#define DIDBAM_INITIALIZE       0x00000002
#define DIDBAM_HWDEFAULTS       0x00000004

#define DIDSAM_DEFAULT          0x00000000
#define DIDSAM_NOUSER           0x00000001
#define DIDSAM_FORCESAVE        0x00000002

#define DICD_DEFAULT            0x00000000
#define DICD_EDIT               0x00000001

/*
 * The following definition is normally defined in d3dtypes.h
 */
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

typedef struct _DICOLORSET{
    DWORD dwSize;
    D3DCOLOR cTextFore;
    D3DCOLOR cTextHighlight;
    D3DCOLOR cCalloutLine;
    D3DCOLOR cCalloutHighlight;
    D3DCOLOR cBorder;
    D3DCOLOR cControlFill;
    D3DCOLOR cHighlightFill;
    D3DCOLOR cAreaFill;
} DICOLORSET, *LPDICOLORSET;
typedef const DICOLORSET *LPCDICOLORSET;


typedef struct _DICONFIGUREDEVICESPARAMSA{
     DWORD             dwSize;
     DWORD             dwcUsers;
     LPSTR             lptszUserNames;
     DWORD             dwcFormats;
     LPDIACTIONFORMATA lprgFormats;
     HWND              hwnd;
     DICOLORSET        dics;
     IUnknown FAR *    lpUnkDDSTarget;
} DICONFIGUREDEVICESPARAMSA, *LPDICONFIGUREDEVICESPARAMSA;
typedef struct _DICONFIGUREDEVICESPARAMSW{
     DWORD             dwSize;
     DWORD             dwcUsers;
     LPWSTR            lptszUserNames;
     DWORD             dwcFormats;
     LPDIACTIONFORMATW lprgFormats;
     HWND              hwnd;
     DICOLORSET        dics;
     IUnknown FAR *    lpUnkDDSTarget;
} DICONFIGUREDEVICESPARAMSW, *LPDICONFIGUREDEVICESPARAMSW;
#ifdef UNICODE
typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
typedef LPDICONFIGUREDEVICESPARAMSW LPDICONFIGUREDEVICESPARAMS;
#else
typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
typedef LPDICONFIGUREDEVICESPARAMSA LPDICONFIGUREDEVICESPARAMS;
#endif // UNICODE
typedef const DICONFIGUREDEVICESPARAMSA *LPCDICONFIGUREDEVICESPARAMSA;
typedef const DICONFIGUREDEVICESPARAMSW *LPCDICONFIGUREDEVICESPARAMSW;
#ifdef UNICODE
typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
typedef LPCDICONFIGUREDEVICESPARAMSW LPCDICONFIGUREDEVICESPARAMS;
#else
typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
typedef LPCDICONFIGUREDEVICESPARAMSA LPCDICONFIGUREDEVICESPARAMS;
#endif // UNICODE
typedef const DICONFIGUREDEVICESPARAMS *LPCDICONFIGUREDEVICESPARAMS;


#define DIDIFT_CONFIGURATION    0x00000001
#define DIDIFT_OVERLAY          0x00000002

#define DIDAL_CENTERED      0x00000000
#define DIDAL_LEFTALIGNED   0x00000001
#define DIDAL_RIGHTALIGNED  0x00000002
#define DIDAL_MIDDLE        0x00000000
#define DIDAL_TOPALIGNED    0x00000004
#define DIDAL_BOTTOMALIGNED 0x00000008

typedef struct _DIDEVICEIMAGEINFOA {
    CHAR        tszImagePath[MAX_PATH];
    DWORD       dwFlags; 
    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
    DWORD       dwViewID;      
    RECT        rcOverlay;             
    DWORD       dwObjID;
    DWORD       dwcValidPts;
    POINT       rgptCalloutLine[5];  
    RECT        rcCalloutRect;  
    DWORD       dwTextAlign;     
} DIDEVICEIMAGEINFOA, *LPDIDEVICEIMAGEINFOA;
typedef struct _DIDEVICEIMAGEINFOW {
    WCHAR       tszImagePath[MAX_PATH];
    DWORD       dwFlags; 
    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
    DWORD       dwViewID;      
    RECT        rcOverlay;             
    DWORD       dwObjID;
    DWORD       dwcValidPts;
    POINT       rgptCalloutLine[5];  
    RECT        rcCalloutRect;  
    DWORD       dwTextAlign;     
} DIDEVICEIMAGEINFOW, *LPDIDEVICEIMAGEINFOW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
typedef LPDIDEVICEIMAGEINFOW LPDIDEVICEIMAGEINFO;
#else
typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
typedef LPDIDEVICEIMAGEINFOA LPDIDEVICEIMAGEINFO;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOA *LPCDIDEVICEIMAGEINFOA;
typedef const DIDEVICEIMAGEINFOW *LPCDIDEVICEIMAGEINFOW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
typedef LPCDIDEVICEIMAGEINFOW LPCDIDEVICEIMAGEINFO;
#else
typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
typedef LPCDIDEVICEIMAGEINFOA LPCDIDEVICEIMAGEINFO;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFO *LPCDIDEVICEIMAGEINFO;

typedef struct _DIDEVICEIMAGEINFOHEADERA {
    DWORD       dwSize;
    DWORD       dwSizeImageInfo;
    DWORD       dwcViews;
    DWORD       dwcButtons;
    DWORD       dwcAxes;
    DWORD       dwcPOVs;
    DWORD       dwBufferSize;
    DWORD       dwBufferUsed;
    LPDIDEVICEIMAGEINFOA lprgImageInfoArray;
} DIDEVICEIMAGEINFOHEADERA, *LPDIDEVICEIMAGEINFOHEADERA;
typedef struct _DIDEVICEIMAGEINFOHEADERW {
    DWORD       dwSize;
    DWORD       dwSizeImageInfo;
    DWORD       dwcViews;
    DWORD       dwcButtons;
    DWORD       dwcAxes;
    DWORD       dwcPOVs;
    DWORD       dwBufferSize;
    DWORD       dwBufferUsed;
    LPDIDEVICEIMAGEINFOW lprgImageInfoArray;
} DIDEVICEIMAGEINFOHEADERW, *LPDIDEVICEIMAGEINFOHEADERW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
typedef LPDIDEVICEIMAGEINFOHEADERW LPDIDEVICEIMAGEINFOHEADER;
#else
typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
typedef LPDIDEVICEIMAGEINFOHEADERA LPDIDEVICEIMAGEINFOHEADER;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOHEADERA *LPCDIDEVICEIMAGEINFOHEADERA;
typedef const DIDEVICEIMAGEINFOHEADERW *LPCDIDEVICEIMAGEINFOHEADERW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
typedef LPCDIDEVICEIMAGEINFOHEADERW LPCDIDEVICEIMAGEINFOHEADER;
#else
typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
typedef LPCDIDEVICEIMAGEINFOHEADERA LPCDIDEVICEIMAGEINFOHEADER;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOHEADER *LPCDIDEVICEIMAGEINFOHEADER;

#endif /* DIRECTINPUT_VERSION > 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
#else
typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEOBJECTINSTANCEA {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
typedef struct DIDEVICEOBJECTINSTANCEW {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
#else
typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;

typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
#else
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
#endif // !UNICODE

#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDOI_FFACTUATOR        0x00000001
#define DIDOI_FFEFFECTTRIGGER   0x00000002
#define DIDOI_POLLED            0x00008000
#define DIDOI_ASPECTPOSITION    0x00000100
#define DIDOI_ASPECTVELOCITY    0x00000200
#define DIDOI_ASPECTACCEL       0x00000300
#define DIDOI_ASPECTFORCE       0x00000400
#define DIDOI_ASPECTMASK        0x00000F00
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDOI_GUIDISUSAGE       0x00010000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPHEADER {
    DWORD   dwSize;
    DWORD   dwHeaderSize;
    DWORD   dwObj;
    DWORD   dwHow;
} DIPROPHEADER, *LPDIPROPHEADER;
typedef const DIPROPHEADER *LPCDIPROPHEADER;

#define DIPH_DEVICE             0
#define DIPH_BYOFFSET           1
#define DIPH_BYID               2
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPH_BYUSAGE            3
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIMAKEUSAGEDWORD(UsagePage, Usage) \
                                (DWORD)MAKELONG(Usage, UsagePage)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPDWORD {
    DIPROPHEADER diph;
    DWORD   dwData;
} DIPROPDWORD, *LPDIPROPDWORD;
typedef const DIPROPDWORD *LPCDIPROPDWORD;

#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPPOINTER {
    DIPROPHEADER diph;
    UINT_PTR uData;
} DIPROPPOINTER, *LPDIPROPPOINTER;
typedef const DIPROPPOINTER *LPCDIPROPPOINTER;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

typedef struct DIPROPRANGE {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lMax;
} DIPROPRANGE, *LPDIPROPRANGE;
typedef const DIPROPRANGE *LPCDIPROPRANGE;

#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)

#if(DIRECTINPUT_VERSION >= 0x050a)
typedef struct DIPROPCAL {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIPROPCAL, *LPDIPROPCAL;
typedef const DIPROPCAL *LPCDIPROPCAL;

typedef struct DIPROPCALPOV {
    DIPROPHEADER diph;
    LONG   lMin[5];
    LONG   lMax[5];
} DIPROPCALPOV, *LPDIPROPCALPOV;
typedef const DIPROPCALPOV *LPCDIPROPCALPOV;

typedef struct DIPROPGUIDANDPATH {
    DIPROPHEADER diph;
    GUID    guidClass;
    WCHAR   wszPath[MAX_PATH];
} DIPROPGUIDANDPATH, *LPDIPROPGUIDANDPATH;
typedef const DIPROPGUIDANDPATH *LPCDIPROPGUIDANDPATH;

typedef struct DIPROPSTRING {
    DIPROPHEADER diph;
    WCHAR   wsz[MAX_PATH];
} DIPROPSTRING, *LPDIPROPSTRING;
typedef const DIPROPSTRING *LPCDIPROPSTRING;

#endif /* DIRECTINPUT_VERSION >= 0x050a */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define MAXCPOINTSNUM          8

typedef struct _CPOINT
{
    LONG  lP;     // raw value
    DWORD dwLog;  // logical_value / max_logical_value * 10000
} CPOINT, *PCPOINT;

typedef struct DIPROPCPOINTS {
    DIPROPHEADER diph;
    DWORD  dwCPointsNum;
    CPOINT cp[MAXCPOINTSNUM];
} DIPROPCPOINTS, *LPDIPROPCPOINTS;
typedef const DIPROPCPOINTS *LPCDIPROPCPOINTS;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


#ifdef __cplusplus
#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
#else
#define MAKEDIPROP(prop)    ((REFGUID)(prop))
#endif

#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)

#define DIPROP_AXISMODE         MAKEDIPROP(2)

#define DIPROPAXISMODE_ABS      0
#define DIPROPAXISMODE_REL      1

#define DIPROP_GRANULARITY      MAKEDIPROP(3)

#define DIPROP_RANGE            MAKEDIPROP(4)

#define DIPROP_DEADZONE         MAKEDIPROP(5)

#define DIPROP_SATURATION       MAKEDIPROP(6)

#define DIPROP_FFGAIN           MAKEDIPROP(7)

#define DIPROP_FFLOAD           MAKEDIPROP(8)

#define DIPROP_AUTOCENTER       MAKEDIPROP(9)

#define DIPROPAUTOCENTER_OFF    0
#define DIPROPAUTOCENTER_ON     1

#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)

#define DIPROPCALIBRATIONMODE_COOKED    0
#define DIPROPCALIBRATIONMODE_RAW       1

#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPROP_CALIBRATION      MAKEDIPROP(11)

#define DIPROP_GUIDANDPATH      MAKEDIPROP(12)

#define DIPROP_INSTANCENAME     MAKEDIPROP(13)

#define DIPROP_PRODUCTNAME      MAKEDIPROP(14)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#if(DIRECTINPUT_VERSION >= 0x05b2)
#define DIPROP_JOYSTICKID       MAKEDIPROP(15)

#define DIPROP_GETPORTDISPLAYNAME       MAKEDIPROP(16)

#endif /* DIRECTINPUT_VERSION >= 0x05b2 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIPROP_PHYSICALRANGE            MAKEDIPROP(18)

#define DIPROP_LOGICALRANGE             MAKEDIPROP(19)
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIPROP_KEYNAME                     MAKEDIPROP(20)

#define DIPROP_CPOINTS                 MAKEDIPROP(21)

#define DIPROP_APPDATA       MAKEDIPROP(22)

#define DIPROP_SCANCODE      MAKEDIPROP(23)

#define DIPROP_VIDPID           MAKEDIPROP(24)

#define DIPROP_USERNAME         MAKEDIPROP(25)

#define DIPROP_TYPENAME         MAKEDIPROP(26)
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


typedef struct DIDEVICEOBJECTDATA_DX3 {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
} DIDEVICEOBJECTDATA_DX3, *LPDIDEVICEOBJECTDATA_DX3;
typedef const DIDEVICEOBJECTDATA_DX3 *LPCDIDEVICEOBJECTDATA_DX;

typedef struct DIDEVICEOBJECTDATA {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
#if(DIRECTINPUT_VERSION >= 0x0800)
    UINT_PTR    uAppData;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

#define DIGDD_PEEK          0x00000001

#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
#define DISCL_EXCLUSIVE     0x00000001
#define DISCL_NONEXCLUSIVE  0x00000002
#define DISCL_FOREGROUND    0x00000004
#define DISCL_BACKGROUND    0x00000008
#define DISCL_NOWINKEY      0x00000010

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
typedef struct DIDEVICEINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
#else
typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEINSTANCEA {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
typedef struct DIDEVICEINSTANCEW {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
#endif // UNICODE

typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCEW LPCDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCEA LPCDIDEVICEINSTANCE;
#endif // UNICODE
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceW

DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceA

DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;

#ifdef UNICODE
#define IID_IDirectInputDevice IID_IDirectInputDeviceW
#define IDirectInputDevice IDirectInputDeviceW
#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
#else
#define IID_IDirectInputDevice IID_IDirectInputDeviceA
#define IDirectInputDevice IDirectInputDeviceA
#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
#endif
typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#else
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice_AddRef(p) (p)->AddRef()
#define IDirectInputDevice_Release(p) (p)->Release()
#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice_Acquire(p) (p)->Acquire()
#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#endif

#endif /* DIJ_RINGZERO */


#if(DIRECTINPUT_VERSION >= 0x0500)

#define DISFFC_RESET            0x00000001
#define DISFFC_STOPALL          0x00000002
#define DISFFC_PAUSE            0x00000004
#define DISFFC_CONTINUE         0x00000008
#define DISFFC_SETACTUATORSON   0x00000010
#define DISFFC_SETACTUATORSOFF  0x00000020

#define DIGFFS_EMPTY            0x00000001
#define DIGFFS_STOPPED          0x00000002
#define DIGFFS_PAUSED           0x00000004
#define DIGFFS_ACTUATORSON      0x00000010
#define DIGFFS_ACTUATORSOFF     0x00000020
#define DIGFFS_POWERON          0x00000040
#define DIGFFS_POWEROFF         0x00000080
#define DIGFFS_SAFETYSWITCHON   0x00000100
#define DIGFFS_SAFETYSWITCHOFF  0x00000200
#define DIGFFS_USERFFSWITCHON   0x00000400
#define DIGFFS_USERFFSWITCHOFF  0x00000800
#define DIGFFS_DEVICELOST       0x80000000

#ifndef DIJ_RINGZERO

typedef struct DIEFFECTINFOA {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    CHAR    tszName[MAX_PATH];
} DIEFFECTINFOA, *LPDIEFFECTINFOA;
typedef struct DIEFFECTINFOW {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    WCHAR   tszName[MAX_PATH];
} DIEFFECTINFOW, *LPDIEFFECTINFOW;
#ifdef UNICODE
typedef DIEFFECTINFOW DIEFFECTINFO;
typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
#else
typedef DIEFFECTINFOA DIEFFECTINFO;
typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
#endif // UNICODE
typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;

#define DISDD_CONTINUE          0x00000001

typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
#ifdef UNICODE
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
#else
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);

#undef INTERFACE
#define INTERFACE IDirectInputDevice2W

DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice2A

DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;

#ifdef UNICODE
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
#define IDirectInputDevice2 IDirectInputDevice2W
#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
#else
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
#define IDirectInputDevice2 IDirectInputDevice2A
#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
#endif
typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#else
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
#define IDirectInputDevice2_Release(p) (p)->Release()
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice2_Poll(p) (p)->Poll()
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIFEF_DEFAULT               0x00000000
#define DIFEF_INCLUDENONSTANDARD    0x00000001
#define DIFEF_MODIFYIFNEEDED            0x00000010

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice7W

DECLARE_INTERFACE_(IDirectInputDevice7W, IDirectInputDevice2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7W methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7W *LPDIRECTINPUTDEVICE7W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice7A

DECLARE_INTERFACE_(IDirectInputDevice7A, IDirectInputDevice2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7A methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7A *LPDIRECTINPUTDEVICE7A;

#ifdef UNICODE
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7W
#define IDirectInputDevice7 IDirectInputDevice7W
#define IDirectInputDevice7Vtbl IDirectInputDevice7WVtbl
#else
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7A
#define IDirectInputDevice7 IDirectInputDevice7A
#define IDirectInputDevice7Vtbl IDirectInputDevice7AVtbl
#endif
typedef struct IDirectInputDevice7 *LPDIRECTINPUTDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice7_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice7_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice7_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#else
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice7_AddRef(p) (p)->AddRef()
#define IDirectInputDevice7_Release(p) (p)->Release()
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice7_Acquire(p) (p)->Acquire()
#define IDirectInputDevice7_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice7_Poll(p) (p)->Poll()
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0800)

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice8W

DECLARE_INTERFACE_(IDirectInputDevice8W, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice8W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERW) PURE;
};

typedef struct IDirectInputDevice8W *LPDIRECTINPUTDEVICE8W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice8A

DECLARE_INTERFACE_(IDirectInputDevice8A, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice8A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERA) PURE;
};

typedef struct IDirectInputDevice8A *LPDIRECTINPUTDEVICE8A;

#ifdef UNICODE
#define IID_IDirectInputDevice8 IID_IDirectInputDevice8W
#define IDirectInputDevice8 IDirectInputDevice8W
#define IDirectInputDevice8Vtbl IDirectInputDevice8WVtbl
#else
#define IID_IDirectInputDevice8 IID_IDirectInputDevice8A
#define IDirectInputDevice8 IDirectInputDevice8A
#define IDirectInputDevice8Vtbl IDirectInputDevice8AVtbl
#endif
typedef struct IDirectInputDevice8 *LPDIRECTINPUTDEVICE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice8_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice8_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice8_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice8_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice8_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice8_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice8_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice8_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->lpVtbl->BuildActionMap(p,a,b,c)
#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->lpVtbl->SetActionMap(p,a,b,c)
#define IDirectInputDevice8_GetImageInfo(p,a) (p)->lpVtbl->GetImageInfo(p,a)
#else
#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice8_AddRef(p) (p)->AddRef()
#define IDirectInputDevice8_Release(p) (p)->Release()
#define IDirectInputDevice8_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice8_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice8_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice8_Acquire(p) (p)->Acquire()
#define IDirectInputDevice8_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice8_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice8_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice8_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice8_Poll(p) (p)->Poll()
#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->BuildActionMap(a,b,c)
#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->SetActionMap(a,b,c)
#define IDirectInputDevice8_GetImageInfo(p,a) (p)->GetImageInfo(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

/****************************************************************************
 *
 *      Mouse
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct _DIMOUSESTATE {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;

#if DIRECTINPUT_VERSION >= 0x0700
typedef struct _DIMOUSESTATE2 {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[8];
} DIMOUSESTATE2, *LPDIMOUSESTATE2;
#endif


#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
#if (DIRECTINPUT_VERSION >= 0x0700)
#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
#endif
#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Keyboard
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      DirectInput keyboard scan codes
 *
 ****************************************************************************/
#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_OEM_102         0x56    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
#define DIK_F11             0x57
#define DIK_F12             0x58
#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */
#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_ABNT_C1         0x73    /* /? on Brazilian keyboard */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_ABNT_C2         0x7E    /* Numpad . on Brazilian keyboard */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NEXTTRACK       0x99    /* Next Track */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_MUTE            0xA0    /* Mute */
#define DIK_CALCULATOR      0xA1    /* Calculator */
#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
#define DIK_MEDIASTOP       0xA4    /* Media Stop */
#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
#define DIK_VOLUMEUP        0xB0    /* Volume + */
#define DIK_WEBHOME         0xB2    /* Web home */
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */
#define DIK_POWER           0xDE    /* System Power */
#define DIK_SLEEP           0xDF    /* System Sleep */
#define DIK_WAKE            0xE3    /* System Wake */
#define DIK_WEBSEARCH       0xE5    /* Web Search */
#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
#define DIK_WEBSTOP         0xE8    /* Web Stop */
#define DIK_WEBFORWARD      0xE9    /* Web Forward */
#define DIK_WEBBACK         0xEA    /* Web Back */
#define DIK_MYCOMPUTER      0xEB    /* My Computer */
#define DIK_MAIL            0xEC    /* Mail */
#define DIK_MEDIASELECT     0xED    /* Media Select */

/*
 *  Alternate names for keys, to facilitate transition from DOS.
 */
#define DIK_BACKSPACE       DIK_BACK            /* backspace */
#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
#define DIK_LALT            DIK_LMENU           /* left Alt */
#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
#define DIK_RALT            DIK_RMENU           /* right Alt */
#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */

/*
 *  Alternate names for keys originally not used on US keyboards.
 */
#define DIK_CIRCUMFLEX      DIK_PREVTRACK       /* Japanese keyboard */

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Joystick
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct DIJOYSTATE {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[32];         /* 32 buttons                   */
} DIJOYSTATE, *LPDIJOYSTATE;

typedef struct DIJOYSTATE2 {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[128];        /* 128 buttons                  */
    LONG    lVX;                    /* x-axis velocity              */
    LONG    lVY;                    /* y-axis velocity              */
    LONG    lVZ;                    /* z-axis velocity              */
    LONG    lVRx;                   /* x-axis angular velocity      */
    LONG    lVRy;                   /* y-axis angular velocity      */
    LONG    lVRz;                   /* z-axis angular velocity      */
    LONG    rglVSlider[2];          /* extra axes velocities        */
    LONG    lAX;                    /* x-axis acceleration          */
    LONG    lAY;                    /* y-axis acceleration          */
    LONG    lAZ;                    /* z-axis acceleration          */
    LONG    lARx;                   /* x-axis angular acceleration  */
    LONG    lARy;                   /* y-axis angular acceleration  */
    LONG    lARz;                   /* z-axis angular acceleration  */
    LONG    rglASlider[2];          /* extra axes accelerations     */
    LONG    lFX;                    /* x-axis force                 */
    LONG    lFY;                    /* y-axis force                 */
    LONG    lFZ;                    /* z-axis force                 */
    LONG    lFRx;                   /* x-axis torque                */
    LONG    lFRy;                   /* y-axis torque                */
    LONG    lFRz;                   /* z-axis torque                */
    LONG    rglFSlider[2];          /* extra axes forces            */
} DIJOYSTATE2, *LPDIJOYSTATE2;

#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
                                                        (n) * sizeof(LONG))
#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
                                                        (n) * sizeof(DWORD))
#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  IDirectInput
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#define DIENUM_STOP             0
#define DIENUM_CONTINUE         1

typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
#else
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDICONFIGUREDEVICESCALLBACK)(IUnknown FAR *, LPVOID);

#define DIEDFL_ALLDEVICES       0x00000000
#define DIEDFL_ATTACHEDONLY     0x00000001
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIEDFL_FORCEFEEDBACK    0x00000100
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIEDFL_INCLUDEALIASES   0x00010000
#define DIEDFL_INCLUDEPHANTOMS  0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */
#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDFL_INCLUDEHIDDEN    0x00040000
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


#if(DIRECTINPUT_VERSION >= 0x0800)
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBA)(LPCDIDEVICEINSTANCEA, LPDIRECTINPUTDEVICE8A, DWORD, DWORD, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBW)(LPCDIDEVICEINSTANCEW, LPDIRECTINPUTDEVICE8W, DWORD, DWORD, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBW
#else
#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBA
#endif // !UNICODE
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDBS_MAPPEDPRI1         0x00000001
#define DIEDBS_MAPPEDPRI2         0x00000002
#define DIEDBS_RECENTDEVICE       0x00000010
#define DIEDBS_NEWDEVICE          0x00000020
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDBSFL_ATTACHEDONLY       0x00000000
#define DIEDBSFL_THISUSER           0x00000010
#define DIEDBSFL_FORCEFEEDBACK      DIEDFL_FORCEFEEDBACK
#define DIEDBSFL_AVAILABLEDEVICES   0x00001000
#define DIEDBSFL_MULTIMICEKEYBOARDS 0x00002000
#define DIEDBSFL_NONGAMINGDEVICES   0x00004000
#define DIEDBSFL_VALID              0x00007110
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#undef INTERFACE
#define INTERFACE IDirectInputW

DECLARE_INTERFACE_(IDirectInputW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputW *LPDIRECTINPUTW;

#undef INTERFACE
#define INTERFACE IDirectInputA

DECLARE_INTERFACE_(IDirectInputA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputA *LPDIRECTINPUTA;

#ifdef UNICODE
#define IID_IDirectInput IID_IDirectInputW
#define IDirectInput IDirectInputW
#define IDirectInputVtbl IDirectInputWVtbl
#else
#define IID_IDirectInput IID_IDirectInputA
#define IDirectInput IDirectInputA
#define IDirectInputVtbl IDirectInputAVtbl
#endif
typedef struct IDirectInput *LPDIRECTINPUT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#else
#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput_AddRef(p) (p)->AddRef()
#define IDirectInput_Release(p) (p)->Release()
#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirectInput2W

DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
};

typedef struct IDirectInput2W *LPDIRECTINPUT2W;

#undef INTERFACE
#define INTERFACE IDirectInput2A

DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
};

typedef struct IDirectInput2A *LPDIRECTINPUT2A;

#ifdef UNICODE
#define IID_IDirectInput2 IID_IDirectInput2W
#define IDirectInput2 IDirectInput2W
#define IDirectInput2Vtbl IDirectInput2WVtbl
#else
#define IID_IDirectInput2 IID_IDirectInput2A
#define IDirectInput2 IDirectInput2A
#define IDirectInput2Vtbl IDirectInput2AVtbl
#endif
typedef struct IDirectInput2 *LPDIRECTINPUT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#else
#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput2_AddRef(p) (p)->AddRef()
#define IDirectInput2_Release(p) (p)->Release()
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#endif


#undef INTERFACE
#define INTERFACE IDirectInput7W

DECLARE_INTERFACE_(IDirectInput7W, IDirectInput2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;

    /*** IDirectInput7W methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7W *LPDIRECTINPUT7W;

#undef INTERFACE
#define INTERFACE IDirectInput7A

DECLARE_INTERFACE_(IDirectInput7A, IDirectInput2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;

    /*** IDirectInput7A methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7A *LPDIRECTINPUT7A;

#ifdef UNICODE
#define IID_IDirectInput7 IID_IDirectInput7W
#define IDirectInput7 IDirectInput7W
#define IDirectInput7Vtbl IDirectInput7WVtbl
#else
#define IID_IDirectInput7 IID_IDirectInput7A
#define IDirectInput7 IDirectInput7A
#define IDirectInput7Vtbl IDirectInput7AVtbl
#endif
typedef struct IDirectInput7 *LPDIRECTINPUT7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->lpVtbl->CreateDeviceEx(p,a,b,c,d)
#else
#define IDirectInput7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput7_AddRef(p) (p)->AddRef()
#define IDirectInput7_Release(p) (p)->Release()
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->CreateDeviceEx(a,b,c,d)
#endif

#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInput8W

DECLARE_INTERFACE_(IDirectInput8W, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput8W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8W *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCWSTR,LPDIACTIONFORMATW,LPDIENUMDEVICESBYSEMANTICSCBW,LPVOID,DWORD) PURE;
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSW,DWORD,LPVOID) PURE;
};

typedef struct IDirectInput8W *LPDIRECTINPUT8W;

#undef INTERFACE
#define INTERFACE IDirectInput8A

DECLARE_INTERFACE_(IDirectInput8A, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput8A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8A *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCSTR,LPDIACTIONFORMATA,LPDIENUMDEVICESBYSEMANTICSCBA,LPVOID,DWORD) PURE;
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSA,DWORD,LPVOID) PURE;
};

typedef struct IDirectInput8A *LPDIRECTINPUT8A;

#ifdef UNICODE
#define IID_IDirectInput8 IID_IDirectInput8W
#define IDirectInput8 IDirectInput8W
#define IDirectInput8Vtbl IDirectInput8WVtbl
#else
#define IID_IDirectInput8 IID_IDirectInput8A
#define IDirectInput8 IDirectInput8A
#define IDirectInput8Vtbl IDirectInput8AVtbl
#endif
typedef struct IDirectInput8 *LPDIRECTINPUT8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput8_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput8_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput8_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput8_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->lpVtbl->EnumDevicesBySemantics(p,a,b,c,d,e)
#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->lpVtbl->ConfigureDevices(p,a,b,c,d)
#else
#define IDirectInput8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput8_AddRef(p) (p)->AddRef()
#define IDirectInput8_Release(p) (p)->Release()
#define IDirectInput8_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput8_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput8_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput8_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->EnumDevicesBySemantics(a,b,c,d,e)
#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->ConfigureDevices(a,b,c,d)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if DIRECTINPUT_VERSION > 0x0700

extern HRESULT WINAPI DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);

#else
extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
#ifdef UNICODE
#define DirectInputCreate  DirectInputCreateW
#else
#define DirectInputCreate  DirectInputCreateA
#endif // !UNICODE

extern HRESULT WINAPI DirectInputCreateEx(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);

#endif /* DIRECTINPUT_VERSION > 0x700 */

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

/*
 *  The operation completed successfully.
 */
#define DI_OK                           S_OK

/*
 *  The device exists but is not currently attached.
 */
#define DI_NOTATTACHED                  S_FALSE

/*
 *  The device buffer overflowed.  Some input was lost.
 */
#define DI_BUFFEROVERFLOW               S_FALSE

/*
 *  The change in device properties had no effect.
 */
#define DI_PROPNOEFFECT                 S_FALSE

/*
 *  The operation had no effect.
 */
#define DI_NOEFFECT                     S_FALSE

/*
 *  The device is a polled device.  As a result, device buffering
 *  will not collect any data and event notifications will not be
 *  signalled until GetDeviceState is called.
 */
#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but the effect was not
 *  downloaded because the device is not exclusively acquired
 *  or because the DIEP_NODOWNLOAD flag was passed.
 */
#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but in order to change
 *  the parameters, the effect needed to be restarted.
 */
#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but some of them were
 *  beyond the capabilities of the device and were truncated.
 */
#define DI_TRUNCATED                    ((HRESULT)0x00000008L)

/*
 *  The settings have been successfully applied but could not be 
 *  persisted. 
 */
#define DI_SETTINGSNOTSAVED				((HRESULT)0x0000000BL)

/*
 *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
 */
#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)

/*
 *  A SUCCESS code indicating that settings cannot be modified.
 */
#define DI_WRITEPROTECT                 ((HRESULT)0x00000013L)

/*
 *  The application requires a newer version of DirectInput.
 */
#define DIERR_OLDDIRECTINPUTVERSION     \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)

/*
 *  The application was written for an unsupported prerelease version
 *  of DirectInput.
 */
#define DIERR_BETADIRECTINPUTVERSION    \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)

/*
 *  The object could not be created due to an incompatible driver version
 *  or mismatched or incomplete driver components.
 */
#define DIERR_BADDRIVERVER              \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)

/*
 * The device or device instance or effect is not registered with DirectInput.
 */
#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG

/*
 * The requested object does not exist.
 */
#define DIERR_NOTFOUND                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * The requested object does not exist.
 */
#define DIERR_OBJECTNOTFOUND            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * An invalid parameter was passed to the returning function,
 * or the object was not in a state that admitted the function
 * to be called.
 */
#define DIERR_INVALIDPARAM              E_INVALIDARG

/*
 * The specified interface is not supported by the object
 */
#define DIERR_NOINTERFACE               E_NOINTERFACE

/*
 * An undetermined error occured inside the DInput subsystem
 */
#define DIERR_GENERIC                   E_FAIL

/*
 * The DInput subsystem couldn't allocate sufficient memory to complete the
 * caller's request.
 */
#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY

/*
 * The function called is not supported at this time
 */
#define DIERR_UNSUPPORTED               E_NOTIMPL

/*
 * This object has not been initialized
 */
#define DIERR_NOTINITIALIZED            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)

/*
 * This object is already initialized
 */
#define DIERR_ALREADYINITIALIZED        \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)

/*
 * This object does not support aggregation
 */
#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

/*
 * Another app has a higher priority level, preventing this call from
 * succeeding.
 */
#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED

/*
 * Access to the device has been lost.  It must be re-acquired.
 */
#define DIERR_INPUTLOST                 \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)

/*
 * The operation cannot be performed while the device is acquired.
 */
#define DIERR_ACQUIRED                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)

/*
 * The operation cannot be performed unless the device is acquired.
 */
#define DIERR_NOTACQUIRED               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)

/*
 * The specified property cannot be changed.
 */
#define DIERR_READONLY                  E_ACCESSDENIED

/*
 * The device already has an event notification associated with it.
 */
#define DIERR_HANDLEEXISTS              E_ACCESSDENIED

/*
 * Data is not yet available.
 */
#ifndef E_PENDING
#define E_PENDING                       0x8000000AL
#endif

/*
 * Unable to IDirectInputJoyConfig_Acquire because the user
 * does not have sufficient privileges to change the joystick
 * configuration.
 */
#define DIERR_INSUFFICIENTPRIVS         0x80040200L

/*
 * The device is full.
 */
#define DIERR_DEVICEFULL                0x80040201L

/*
 * Not all the requested information fit into the buffer.
 */
#define DIERR_MOREDATA                  0x80040202L

/*
 * The effect is not downloaded.
 */
#define DIERR_NOTDOWNLOADED             0x80040203L

/*
 *  The device cannot be reinitialized because there are still effects
 *  attached to it.
 */
#define DIERR_HASEFFECTS                0x80040204L

/*
 *  The operation cannot be performed unless the device is acquired
 *  in DISCL_EXCLUSIVE mode.
 */
#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L

/*
 *  The effect could not be downloaded because essential information
 *  is missing.  For example, no axes have been associated with the
 *  effect, or no type-specific information has been created.
 */
#define DIERR_INCOMPLETEEFFECT          0x80040206L

/*
 *  Attempted to read buffered device data from a device that is
 *  not buffered.
 */
#define DIERR_NOTBUFFERED               0x80040207L

/*
 *  An attempt was made to modify parameters of an effect while it is
 *  playing.  Not all hardware devices support altering the parameters
 *  of an effect while it is playing.
 */
#define DIERR_EFFECTPLAYING             0x80040208L

/*
 *  The operation could not be completed because the device is not
 *  plugged in.
 */
#define DIERR_UNPLUGGED                 0x80040209L

/*
 *  SendDeviceData failed because more information was requested
 *  to be sent than can be sent to the device.  Some devices have
 *  restrictions on how much data can be sent to them.  (For example,
 *  there might be a limit on the number of buttons that can be
 *  pressed at once.)
 */
#define DIERR_REPORTFULL                0x8004020AL


/*
 *  A mapper file function failed because reading or writing the user or IHV 
 *  settings file failed.
 */
#define DIERR_MAPFILEFAIL               0x8004020BL


/*--- DINPUT Mapper Definitions: New for Dx8         ---*/


/*--- Keyboard
      Physical Keyboard Device       ---*/

#define DIKEYBOARD_ESCAPE                       0x81000401
#define DIKEYBOARD_1                            0x81000402
#define DIKEYBOARD_2                            0x81000403
#define DIKEYBOARD_3                            0x81000404
#define DIKEYBOARD_4                            0x81000405
#define DIKEYBOARD_5                            0x81000406
#define DIKEYBOARD_6                            0x81000407
#define DIKEYBOARD_7                            0x81000408
#define DIKEYBOARD_8                            0x81000409
#define DIKEYBOARD_9                            0x8100040A
#define DIKEYBOARD_0                            0x8100040B
#define DIKEYBOARD_MINUS                        0x8100040C    /* - on main keyboard */
#define DIKEYBOARD_EQUALS                       0x8100040D
#define DIKEYBOARD_BACK                         0x8100040E    /* backspace */
#define DIKEYBOARD_TAB                          0x8100040F
#define DIKEYBOARD_Q                            0x81000410
#define DIKEYBOARD_W                            0x81000411
#define DIKEYBOARD_E                            0x81000412
#define DIKEYBOARD_R                            0x81000413
#define DIKEYBOARD_T                            0x81000414
#define DIKEYBOARD_Y                            0x81000415
#define DIKEYBOARD_U                            0x81000416
#define DIKEYBOARD_I                            0x81000417
#define DIKEYBOARD_O                            0x81000418
#define DIKEYBOARD_P                            0x81000419
#define DIKEYBOARD_LBRACKET                     0x8100041A
#define DIKEYBOARD_RBRACKET                     0x8100041B
#define DIKEYBOARD_RETURN                       0x8100041C    /* Enter on main keyboard */
#define DIKEYBOARD_LCONTROL                     0x8100041D
#define DIKEYBOARD_A                            0x8100041E
#define DIKEYBOARD_S                            0x8100041F
#define DIKEYBOARD_D                            0x81000420
#define DIKEYBOARD_F                            0x81000421
#define DIKEYBOARD_G                            0x81000422
#define DIKEYBOARD_H                            0x81000423
#define DIKEYBOARD_J                            0x81000424
#define DIKEYBOARD_K                            0x81000425
#define DIKEYBOARD_L                            0x81000426
#define DIKEYBOARD_SEMICOLON                    0x81000427
#define DIKEYBOARD_APOSTROPHE                   0x81000428
#define DIKEYBOARD_GRAVE                        0x81000429    /* accent grave */
#define DIKEYBOARD_LSHIFT                       0x8100042A
#define DIKEYBOARD_BACKSLASH                    0x8100042B
#define DIKEYBOARD_Z                            0x8100042C
#define DIKEYBOARD_X                            0x8100042D
#define DIKEYBOARD_C                            0x8100042E
#define DIKEYBOARD_V                            0x8100042F
#define DIKEYBOARD_B                            0x81000430
#define DIKEYBOARD_N                            0x81000431
#define DIKEYBOARD_M                            0x81000432
#define DIKEYBOARD_COMMA                        0x81000433
#define DIKEYBOARD_PERIOD                       0x81000434    /* . on main keyboard */
#define DIKEYBOARD_SLASH                        0x81000435    /* / on main keyboard */
#define DIKEYBOARD_RSHIFT                       0x81000436
#define DIKEYBOARD_MULTIPLY                     0x81000437    /* * on numeric keypad */
#define DIKEYBOARD_LMENU                        0x81000438    /* left Alt */
#define DIKEYBOARD_SPACE                        0x81000439
#define DIKEYBOARD_CAPITAL                      0x8100043A
#define DIKEYBOARD_F1                           0x8100043B
#define DIKEYBOARD_F2                           0x8100043C
#define DIKEYBOARD_F3                           0x8100043D
#define DIKEYBOARD_F4                           0x8100043E
#define DIKEYBOARD_F5                           0x8100043F
#define DIKEYBOARD_F6                           0x81000440
#define DIKEYBOARD_F7                           0x81000441
#define DIKEYBOARD_F8                           0x81000442
#define DIKEYBOARD_F9                           0x81000443
#define DIKEYBOARD_F10                          0x81000444
#define DIKEYBOARD_NUMLOCK                      0x81000445
#define DIKEYBOARD_SCROLL                       0x81000446    /* Scroll Lock */
#define DIKEYBOARD_NUMPAD7                      0x81000447
#define DIKEYBOARD_NUMPAD8                      0x81000448
#define DIKEYBOARD_NUMPAD9                      0x81000449
#define DIKEYBOARD_SUBTRACT                     0x8100044A    /* - on numeric keypad */
#define DIKEYBOARD_NUMPAD4                      0x8100044B
#define DIKEYBOARD_NUMPAD5                      0x8100044C
#define DIKEYBOARD_NUMPAD6                      0x8100044D
#define DIKEYBOARD_ADD                          0x8100044E    /* + on numeric keypad */
#define DIKEYBOARD_NUMPAD1                      0x8100044F
#define DIKEYBOARD_NUMPAD2                      0x81000450
#define DIKEYBOARD_NUMPAD3                      0x81000451
#define DIKEYBOARD_NUMPAD0                      0x81000452
#define DIKEYBOARD_DECIMAL                      0x81000453    /* . on numeric keypad */
#define DIKEYBOARD_OEM_102                      0x81000456    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
#define DIKEYBOARD_F11                          0x81000457
#define DIKEYBOARD_F12                          0x81000458
#define DIKEYBOARD_F13                          0x81000464    /*                     (NEC PC98) */
#define DIKEYBOARD_F14                          0x81000465    /*                     (NEC PC98) */
#define DIKEYBOARD_F15                          0x81000466    /*                     (NEC PC98) */
#define DIKEYBOARD_KANA                         0x81000470    /* (Japanese keyboard)            */
#define DIKEYBOARD_ABNT_C1                      0x81000473    /* /? on Brazilian keyboard */
#define DIKEYBOARD_CONVERT                      0x81000479    /* (Japanese keyboard)            */
#define DIKEYBOARD_NOCONVERT                    0x8100047B    /* (Japanese keyboard)            */
#define DIKEYBOARD_YEN                          0x8100047D    /* (Japanese keyboard)            */
#define DIKEYBOARD_ABNT_C2                      0x8100047E    /* Numpad . on Brazilian keyboard */
#define DIKEYBOARD_NUMPADEQUALS                 0x8100048D    /* = on numeric keypad (NEC PC98) */
#define DIKEYBOARD_PREVTRACK                    0x81000490    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIKEYBOARD_AT                           0x81000491    /*                     (NEC PC98) */
#define DIKEYBOARD_COLON                        0x81000492    /*                     (NEC PC98) */
#define DIKEYBOARD_UNDERLINE                    0x81000493    /*                     (NEC PC98) */
#define DIKEYBOARD_KANJI                        0x81000494    /* (Japanese keyboard)            */
#define DIKEYBOARD_STOP                         0x81000495    /*                     (NEC PC98) */
#define DIKEYBOARD_AX                           0x81000496    /*                     (Japan AX) */
#define DIKEYBOARD_UNLABELED                    0x81000497    /*                        (J3100) */
#define DIKEYBOARD_NEXTTRACK                    0x81000499    /* Next Track */
#define DIKEYBOARD_NUMPADENTER                  0x8100049C    /* Enter on numeric keypad */
#define DIKEYBOARD_RCONTROL                     0x8100049D
#define DIKEYBOARD_MUTE                         0x810004A0    /* Mute */
#define DIKEYBOARD_CALCULATOR                   0x810004A1    /* Calculator */
#define DIKEYBOARD_PLAYPAUSE                    0x810004A2    /* Play / Pause */
#define DIKEYBOARD_MEDIASTOP                    0x810004A4    /* Media Stop */
#define DIKEYBOARD_VOLUMEDOWN                   0x810004AE    /* Volume - */
#define DIKEYBOARD_VOLUMEUP                     0x810004B0    /* Volume + */
#define DIKEYBOARD_WEBHOME                      0x810004B2    /* Web home */
#define DIKEYBOARD_NUMPADCOMMA                  0x810004B3    /* , on numeric keypad (NEC PC98) */
#define DIKEYBOARD_DIVIDE                       0x810004B5    /* / on numeric keypad */
#define DIKEYBOARD_SYSRQ                        0x810004B7
#define DIKEYBOARD_RMENU                        0x810004B8    /* right Alt */
#define DIKEYBOARD_PAUSE                        0x810004C5    /* Pause */
#define DIKEYBOARD_HOME                         0x810004C7    /* Home on arrow keypad */
#define DIKEYBOARD_UP                           0x810004C8    /* UpArrow on arrow keypad */
#define DIKEYBOARD_PRIOR                        0x810004C9    /* PgUp on arrow keypad */
#define DIKEYBOARD_LEFT                         0x810004CB    /* LeftArrow on arrow keypad */
#define DIKEYBOARD_RIGHT                        0x810004CD    /* RightArrow on arrow keypad */
#define DIKEYBOARD_END                          0x810004CF    /* End on arrow keypad */
#define DIKEYBOARD_DOWN                         0x810004D0    /* DownArrow on arrow keypad */
#define DIKEYBOARD_NEXT                         0x810004D1    /* PgDn on arrow keypad */
#define DIKEYBOARD_INSERT                       0x810004D2    /* Insert on arrow keypad */
#define DIKEYBOARD_DELETE                       0x810004D3    /* Delete on arrow keypad */
#define DIKEYBOARD_LWIN                         0x810004DB    /* Left Windows key */
#define DIKEYBOARD_RWIN                         0x810004DC    /* Right Windows key */
#define DIKEYBOARD_APPS                         0x810004DD    /* AppMenu key */
#define DIKEYBOARD_POWER                        0x810004DE    /* System Power */
#define DIKEYBOARD_SLEEP                        0x810004DF    /* System Sleep */
#define DIKEYBOARD_WAKE                         0x810004E3    /* System Wake */
#define DIKEYBOARD_WEBSEARCH                    0x810004E5    /* Web Search */
#define DIKEYBOARD_WEBFAVORITES                 0x810004E6    /* Web Favorites */
#define DIKEYBOARD_WEBREFRESH                   0x810004E7    /* Web Refresh */
#define DIKEYBOARD_WEBSTOP                      0x810004E8    /* Web Stop */
#define DIKEYBOARD_WEBFORWARD                   0x810004E9    /* Web Forward */
#define DIKEYBOARD_WEBBACK                      0x810004EA    /* Web Back */
#define DIKEYBOARD_MYCOMPUTER                   0x810004EB    /* My Computer */
#define DIKEYBOARD_MAIL                         0x810004EC    /* Mail */
#define DIKEYBOARD_MEDIASELECT                  0x810004ED    /* Media Select */
  

/*--- MOUSE
      Physical Mouse Device             ---*/

#define DIMOUSE_XAXISAB                         (0x82000200 |DIMOFS_X ) /* X Axis-absolute: Some mice natively report absolute coordinates  */ 
#define DIMOUSE_YAXISAB                         (0x82000200 |DIMOFS_Y ) /* Y Axis-absolute: Some mice natively report absolute coordinates */
#define DIMOUSE_XAXIS                           (0x82000300 |DIMOFS_X ) /* X Axis */
#define DIMOUSE_YAXIS                           (0x82000300 |DIMOFS_Y ) /* Y Axis */
#define DIMOUSE_WHEEL                           (0x82000300 |DIMOFS_Z ) /* Z Axis */
#define DIMOUSE_BUTTON0                         (0x82000400 |DIMOFS_BUTTON0) /* Button 0 */
#define DIMOUSE_BUTTON1                         (0x82000400 |DIMOFS_BUTTON1) /* Button 1 */
#define DIMOUSE_BUTTON2                         (0x82000400 |DIMOFS_BUTTON2) /* Button 2 */
#define DIMOUSE_BUTTON3                         (0x82000400 |DIMOFS_BUTTON3) /* Button 3 */
#define DIMOUSE_BUTTON4                         (0x82000400 |DIMOFS_BUTTON4) /* Button 4 */
#define DIMOUSE_BUTTON5                         (0x82000400 |DIMOFS_BUTTON5) /* Button 5 */
#define DIMOUSE_BUTTON6                         (0x82000400 |DIMOFS_BUTTON6) /* Button 6 */
#define DIMOUSE_BUTTON7                         (0x82000400 |DIMOFS_BUTTON7) /* Button 7 */


/*--- VOICE
      Physical Dplay Voice Device       ---*/

#define DIVOICE_CHANNEL1                        0x83000401
#define DIVOICE_CHANNEL2                        0x83000402
#define DIVOICE_CHANNEL3                        0x83000403
#define DIVOICE_CHANNEL4                        0x83000404
#define DIVOICE_CHANNEL5                        0x83000405
#define DIVOICE_CHANNEL6                        0x83000406
#define DIVOICE_CHANNEL7                        0x83000407
#define DIVOICE_CHANNEL8                        0x83000408
#define DIVOICE_TEAM                            0x83000409
#define DIVOICE_ALL                             0x8300040A
#define DIVOICE_RECORDMUTE                      0x8300040B
#define DIVOICE_PLAYBACKMUTE                    0x8300040C
#define DIVOICE_TRANSMIT                        0x8300040D

#define DIVOICE_VOICECOMMAND                    0x83000410


/*--- Driving Simulator - Racing
      Vehicle control is primary objective  ---*/
#define DIVIRTUAL_DRIVING_RACE                  0x01000000
#define DIAXIS_DRIVINGR_STEER                   0x01008A01 /* Steering */
#define DIAXIS_DRIVINGR_ACCELERATE              0x01039202 /* Accelerate */
#define DIAXIS_DRIVINGR_BRAKE                   0x01041203 /* Brake-Axis */
#define DIBUTTON_DRIVINGR_SHIFTUP               0x01000C01 /* Shift to next higher gear */
#define DIBUTTON_DRIVINGR_SHIFTDOWN             0x01000C02 /* Shift to next lower gear */
#define DIBUTTON_DRIVINGR_VIEW                  0x01001C03 /* Cycle through view options */
#define DIBUTTON_DRIVINGR_MENU                  0x010004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_DRIVINGR_ACCEL_AND_BRAKE         0x01014A04 /* Some devices combine accelerate and brake in a single axis */
#define DIHATSWITCH_DRIVINGR_GLANCE             0x01004601 /* Look around */
#define DIBUTTON_DRIVINGR_BRAKE                 0x01004C04 /* Brake-button */
#define DIBUTTON_DRIVINGR_DASHBOARD             0x01004405 /* Select next dashboard option */
#define DIBUTTON_DRIVINGR_AIDS                  0x01004406 /* Driver correction aids */
#define DIBUTTON_DRIVINGR_MAP                   0x01004407 /* Display Driving Map */
#define DIBUTTON_DRIVINGR_BOOST                 0x01004408 /* Turbo Boost */
#define DIBUTTON_DRIVINGR_PIT                   0x01004409 /* Pit stop notification */
#define DIBUTTON_DRIVINGR_ACCELERATE_LINK       0x0103D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGR_STEER_LEFT_LINK       0x0100CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGR_STEER_RIGHT_LINK      0x0100CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGR_GLANCE_LEFT_LINK      0x0107C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGR_GLANCE_RIGHT_LINK     0x0107C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGR_DEVICE                0x010044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGR_PAUSE                 0x010044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Combat
      Combat from within a vehicle is primary objective  ---*/
#define DIVIRTUAL_DRIVING_COMBAT                0x02000000
#define DIAXIS_DRIVINGC_STEER                   0x02008A01 /* Steering  */
#define DIAXIS_DRIVINGC_ACCELERATE              0x02039202 /* Accelerate */
#define DIAXIS_DRIVINGC_BRAKE                   0x02041203 /* Brake-axis */
#define DIBUTTON_DRIVINGC_FIRE                  0x02000C01 /* Fire */
#define DIBUTTON_DRIVINGC_WEAPONS               0x02000C02 /* Select next weapon */
#define DIBUTTON_DRIVINGC_TARGET                0x02000C03 /* Select next available target */
#define DIBUTTON_DRIVINGC_MENU                  0x020004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_DRIVINGC_ACCEL_AND_BRAKE         0x02014A04 /* Some devices combine accelerate and brake in a single axis */
#define DIHATSWITCH_DRIVINGC_GLANCE             0x02004601 /* Look around */
#define DIBUTTON_DRIVINGC_SHIFTUP               0x02004C04 /* Shift to next higher gear */
#define DIBUTTON_DRIVINGC_SHIFTDOWN             0x02004C05 /* Shift to next lower gear */
#define DIBUTTON_DRIVINGC_DASHBOARD             0x02004406 /* Select next dashboard option */
#define DIBUTTON_DRIVINGC_AIDS                  0x02004407 /* Driver correction aids */
#define DIBUTTON_DRIVINGC_BRAKE                 0x02004C08 /* Brake-button */
#define DIBUTTON_DRIVINGC_FIRESECONDARY         0x02004C09 /* Alternative fire button */
#define DIBUTTON_DRIVINGC_ACCELERATE_LINK       0x0203D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGC_STEER_LEFT_LINK       0x0200CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGC_STEER_RIGHT_LINK      0x0200CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGC_GLANCE_LEFT_LINK      0x0207C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGC_GLANCE_RIGHT_LINK     0x0207C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGC_DEVICE                0x020044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGC_PAUSE                 0x020044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Tank
      Combat from withing a tank is primary objective  ---*/
#define DIVIRTUAL_DRIVING_TANK                  0x03000000
#define DIAXIS_DRIVINGT_STEER                   0x03008A01 /* Turn tank left / right */
#define DIAXIS_DRIVINGT_BARREL                  0x03010202 /* Raise / lower barrel */
#define DIAXIS_DRIVINGT_ACCELERATE              0x03039203 /* Accelerate */
#define DIAXIS_DRIVINGT_ROTATE                  0x03020204 /* Turn barrel left / right */
#define DIBUTTON_DRIVINGT_FIRE                  0x03000C01 /* Fire */
#define DIBUTTON_DRIVINGT_WEAPONS               0x03000C02 /* Select next weapon */
#define DIBUTTON_DRIVINGT_TARGET                0x03000C03 /* Selects next available target */
#define DIBUTTON_DRIVINGT_MENU                  0x030004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_DRIVINGT_GLANCE             0x03004601 /* Look around */
#define DIAXIS_DRIVINGT_BRAKE                   0x03045205 /* Brake-axis */
#define DIAXIS_DRIVINGT_ACCEL_AND_BRAKE         0x03014A06 /* Some devices combine accelerate and brake in a single axis */
#define DIBUTTON_DRIVINGT_VIEW                  0x03005C04 /* Cycle through view options */
#define DIBUTTON_DRIVINGT_DASHBOARD             0x03005C05 /* Select next dashboard option */
#define DIBUTTON_DRIVINGT_BRAKE                 0x03004C06 /* Brake-button */
#define DIBUTTON_DRIVINGT_FIRESECONDARY         0x03004C07 /* Alternative fire button */
#define DIBUTTON_DRIVINGT_ACCELERATE_LINK       0x0303D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGT_STEER_LEFT_LINK       0x0300CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGT_STEER_RIGHT_LINK      0x0300CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGT_BARREL_UP_LINK        0x030144E0 /* Fallback Barrel up button */
#define DIBUTTON_DRIVINGT_BARREL_DOWN_LINK      0x030144E8 /* Fallback Barrel down button */
#define DIBUTTON_DRIVINGT_ROTATE_LEFT_LINK      0x030244E4 /* Fallback Rotate left button */
#define DIBUTTON_DRIVINGT_ROTATE_RIGHT_LINK     0x030244EC /* Fallback Rotate right button */
#define DIBUTTON_DRIVINGT_GLANCE_LEFT_LINK      0x0307C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGT_GLANCE_RIGHT_LINK     0x0307C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGT_DEVICE                0x030044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGT_PAUSE                 0x030044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Civilian 
      Plane control is the primary objective  ---*/
#define DIVIRTUAL_FLYING_CIVILIAN               0x04000000
#define DIAXIS_FLYINGC_BANK                     0x04008A01 /* Roll ship left / right */
#define DIAXIS_FLYINGC_PITCH                    0x04010A02 /* Nose up / down */
#define DIAXIS_FLYINGC_THROTTLE                 0x04039203 /* Throttle */
#define DIBUTTON_FLYINGC_VIEW                   0x04002401 /* Cycle through view options */
#define DIBUTTON_FLYINGC_DISPLAY                0x04002402 /* Select next dashboard / heads up display option */
#define DIBUTTON_FLYINGC_GEAR                   0x04002C03 /* Gear up / down */
#define DIBUTTON_FLYINGC_MENU                   0x040004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGC_GLANCE              0x04004601 /* Look around */
#define DIAXIS_FLYINGC_BRAKE                    0x04046A04 /* Apply Brake */
#define DIAXIS_FLYINGC_RUDDER                   0x04025205 /* Yaw ship left/right */
#define DIAXIS_FLYINGC_FLAPS                    0x04055A06 /* Flaps */
#define DIBUTTON_FLYINGC_FLAPSUP                0x04006404 /* Increment stepping up until fully retracted */
#define DIBUTTON_FLYINGC_FLAPSDOWN              0x04006405 /* Decrement stepping down until fully extended */
#define DIBUTTON_FLYINGC_BRAKE_LINK             0x04046CE0 /* Fallback brake button */
#define DIBUTTON_FLYINGC_FASTER_LINK            0x0403D4E0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGC_SLOWER_LINK            0x0403D4E8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGC_GLANCE_LEFT_LINK       0x0407C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGC_GLANCE_RIGHT_LINK      0x0407C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGC_GLANCE_UP_LINK         0x0407C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGC_GLANCE_DOWN_LINK       0x0407C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGC_DEVICE                 0x040044FE /* Show input device and controls */
#define DIBUTTON_FLYINGC_PAUSE                  0x040044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Military 
      Aerial combat is the primary objective  ---*/
#define DIVIRTUAL_FLYING_MILITARY               0x05000000
#define DIAXIS_FLYINGM_BANK                     0x05008A01 /* Bank - Roll ship left / right */
#define DIAXIS_FLYINGM_PITCH                    0x05010A02 /* Pitch - Nose up / down */
#define DIAXIS_FLYINGM_THROTTLE                 0x05039203 /* Throttle - faster / slower */
#define DIBUTTON_FLYINGM_FIRE                   0x05000C01 /* Fire */
#define DIBUTTON_FLYINGM_WEAPONS                0x05000C02 /* Select next weapon */
#define DIBUTTON_FLYINGM_TARGET                 0x05000C03 /* Selects next available target */
#define DIBUTTON_FLYINGM_MENU                   0x050004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGM_GLANCE              0x05004601 /* Look around */
#define DIBUTTON_FLYINGM_COUNTER                0x05005C04 /* Activate counter measures */
#define DIAXIS_FLYINGM_RUDDER                   0x05024A04 /* Rudder - Yaw ship left/right */
#define DIAXIS_FLYINGM_BRAKE                    0x05046205 /* Brake-axis */
#define DIBUTTON_FLYINGM_VIEW                   0x05006405 /* Cycle through view options */
#define DIBUTTON_FLYINGM_DISPLAY                0x05006406 /* Select next dashboard option */
#define DIAXIS_FLYINGM_FLAPS                    0x05055206 /* Flaps */
#define DIBUTTON_FLYINGM_FLAPSUP                0x05005407 /* Increment stepping up until fully retracted */
#define DIBUTTON_FLYINGM_FLAPSDOWN              0x05005408 /* Decrement stepping down until fully extended */
#define DIBUTTON_FLYINGM_FIRESECONDARY          0x05004C09 /* Alternative fire button */
#define DIBUTTON_FLYINGM_GEAR                   0x0500640A /* Gear up / down */
#define DIBUTTON_FLYINGM_BRAKE_LINK             0x050464E0 /* Fallback brake button */
#define DIBUTTON_FLYINGM_FASTER_LINK            0x0503D4E0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGM_SLOWER_LINK            0x0503D4E8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGM_GLANCE_LEFT_LINK       0x0507C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGM_GLANCE_RIGHT_LINK      0x0507C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGM_GLANCE_UP_LINK         0x0507C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGM_GLANCE_DOWN_LINK       0x0507C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGM_DEVICE                 0x050044FE /* Show input device and controls */
#define DIBUTTON_FLYINGM_PAUSE                  0x050044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Combat Helicopter
      Combat from helicopter is primary objective  ---*/
#define DIVIRTUAL_FLYING_HELICOPTER             0x06000000
#define DIAXIS_FLYINGH_BANK                     0x06008A01 /* Bank - Roll ship left / right */
#define DIAXIS_FLYINGH_PITCH                    0x06010A02 /* Pitch - Nose up / down */
#define DIAXIS_FLYINGH_COLLECTIVE               0x06018A03 /* Collective - Blade pitch/power */
#define DIBUTTON_FLYINGH_FIRE                   0x06001401 /* Fire */
#define DIBUTTON_FLYINGH_WEAPONS                0x06001402 /* Select next weapon */
#define DIBUTTON_FLYINGH_TARGET                 0x06001403 /* Selects next available target */
#define DIBUTTON_FLYINGH_MENU                   0x060004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGH_GLANCE              0x06004601 /* Look around */
#define DIAXIS_FLYINGH_TORQUE                   0x06025A04 /* Torque - Rotate ship around left / right axis */
#define DIAXIS_FLYINGH_THROTTLE                 0x0603DA05 /* Throttle */
#define DIBUTTON_FLYINGH_COUNTER                0x06005404 /* Activate counter measures */
#define DIBUTTON_FLYINGH_VIEW                   0x06006405 /* Cycle through view options */
#define DIBUTTON_FLYINGH_GEAR                   0x06006406 /* Gear up / down */
#define DIBUTTON_FLYINGH_FIRESECONDARY          0x06004C07 /* Alternative fire button */
#define DIBUTTON_FLYINGH_FASTER_LINK            0x0603DCE0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGH_SLOWER_LINK            0x0603DCE8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGH_GLANCE_LEFT_LINK       0x0607C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGH_GLANCE_RIGHT_LINK      0x0607C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGH_GLANCE_UP_LINK         0x0607C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGH_GLANCE_DOWN_LINK       0x0607C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGH_DEVICE                 0x060044FE /* Show input device and controls */
#define DIBUTTON_FLYINGH_PAUSE                  0x060044FC /* Start / Pause / Restart game */

/*--- Space Simulator - Combat
      Space Simulator with weapons  ---*/
#define DIVIRTUAL_SPACESIM                      0x07000000
#define DIAXIS_SPACESIM_LATERAL                 0x07008201 /* Move ship left / right */
#define DIAXIS_SPACESIM_MOVE                    0x07010202 /* Move ship forward/backward */
#define DIAXIS_SPACESIM_THROTTLE                0x07038203 /* Throttle - Engine speed */
#define DIBUTTON_SPACESIM_FIRE                  0x07000401 /* Fire */
#define DIBUTTON_SPACESIM_WEAPONS               0x07000402 /* Select next weapon */
#define DIBUTTON_SPACESIM_TARGET                0x07000403 /* Selects next available target */
#define DIBUTTON_SPACESIM_MENU                  0x070004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SPACESIM_GLANCE             0x07004601 /* Look around */
#define DIAXIS_SPACESIM_CLIMB                   0x0701C204 /* Climb - Pitch ship up/down */
#define DIAXIS_SPACESIM_ROTATE                  0x07024205 /* Rotate - Turn ship left/right */
#define DIBUTTON_SPACESIM_VIEW                  0x07004404 /* Cycle through view options */
#define DIBUTTON_SPACESIM_DISPLAY               0x07004405 /* Select next dashboard / heads up display option */
#define DIBUTTON_SPACESIM_RAISE                 0x07004406 /* Raise ship while maintaining current pitch */
#define DIBUTTON_SPACESIM_LOWER                 0x07004407 /* Lower ship while maintaining current pitch */
#define DIBUTTON_SPACESIM_GEAR                  0x07004408 /* Gear up / down */
#define DIBUTTON_SPACESIM_FIRESECONDARY         0x07004409 /* Alternative fire button */
#define DIBUTTON_SPACESIM_LEFT_LINK             0x0700C4E4 /* Fallback move left button */
#define DIBUTTON_SPACESIM_RIGHT_LINK            0x0700C4EC /* Fallback move right button */
#define DIBUTTON_SPACESIM_FORWARD_LINK          0x070144E0 /* Fallback move forward button */
#define DIBUTTON_SPACESIM_BACKWARD_LINK         0x070144E8 /* Fallback move backwards button */
#define DIBUTTON_SPACESIM_FASTER_LINK           0x0703C4E0 /* Fallback throttle up button */
#define DIBUTTON_SPACESIM_SLOWER_LINK           0x0703C4E8 /* Fallback throttle down button */
#define DIBUTTON_SPACESIM_TURN_LEFT_LINK        0x070244E4 /* Fallback turn left button */
#define DIBUTTON_SPACESIM_TURN_RIGHT_LINK       0x070244EC /* Fallback turn right button */
#define DIBUTTON_SPACESIM_GLANCE_LEFT_LINK      0x0707C4E4 /* Fallback Glance Left button */
#define DIBUTTON_SPACESIM_GLANCE_RIGHT_LINK     0x0707C4EC /* Fallback Glance Right button */
#define DIBUTTON_SPACESIM_GLANCE_UP_LINK        0x0707C4E0 /* Fallback Glance Up button */
#define DIBUTTON_SPACESIM_GLANCE_DOWN_LINK      0x0707C4E8 /* Fallback Glance Down button */
#define DIBUTTON_SPACESIM_DEVICE                0x070044FE /* Show input device and controls */
#define DIBUTTON_SPACESIM_PAUSE                 0x070044FC /* Start / Pause / Restart game */

/*--- Fighting - First Person 
      Hand to Hand combat is primary objective  ---*/
#define DIVIRTUAL_FIGHTING_HAND2HAND            0x08000000
#define DIAXIS_FIGHTINGH_LATERAL                0x08008201 /* Sidestep left/right */
#define DIAXIS_FIGHTINGH_MOVE                   0x08010202 /* Move forward/backward */
#define DIBUTTON_FIGHTINGH_PUNCH                0x08000401 /* Punch */
#define DIBUTTON_FIGHTINGH_KICK                 0x08000402 /* Kick */
#define DIBUTTON_FIGHTINGH_BLOCK                0x08000403 /* Block */
#define DIBUTTON_FIGHTINGH_CROUCH               0x08000404 /* Crouch */
#define DIBUTTON_FIGHTINGH_JUMP                 0x08000405 /* Jump */
#define DIBUTTON_FIGHTINGH_SPECIAL1             0x08000406 /* Apply first special move */
#define DIBUTTON_FIGHTINGH_SPECIAL2             0x08000407 /* Apply second special move */
#define DIBUTTON_FIGHTINGH_MENU                 0x080004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FIGHTINGH_SELECT               0x08004408 /* Select special move */
#define DIHATSWITCH_FIGHTINGH_SLIDE             0x08004601 /* Look around */
#define DIBUTTON_FIGHTINGH_DISPLAY              0x08004409 /* Shows next on-screen display option */
#define DIAXIS_FIGHTINGH_ROTATE                 0x08024203 /* Rotate - Turn body left/right */
#define DIBUTTON_FIGHTINGH_DODGE                0x0800440A /* Dodge */
#define DIBUTTON_FIGHTINGH_LEFT_LINK            0x0800C4E4 /* Fallback left sidestep button */
#define DIBUTTON_FIGHTINGH_RIGHT_LINK           0x0800C4EC /* Fallback right sidestep button */
#define DIBUTTON_FIGHTINGH_FORWARD_LINK         0x080144E0 /* Fallback forward button */
#define DIBUTTON_FIGHTINGH_BACKWARD_LINK        0x080144E8 /* Fallback backward button */
#define DIBUTTON_FIGHTINGH_DEVICE               0x080044FE /* Show input device and controls */
#define DIBUTTON_FIGHTINGH_PAUSE                0x080044FC /* Start / Pause / Restart game */

/*--- Fighting - First Person Shooting
      Navigation and combat are primary objectives  ---*/
#define DIVIRTUAL_FIGHTING_FPS                  0x09000000
#define DIAXIS_FPS_ROTATE                       0x09008201 /* Rotate character left/right */
#define DIAXIS_FPS_MOVE                         0x09010202 /* Move forward/backward */
#define DIBUTTON_FPS_FIRE                       0x09000401 /* Fire */
#define DIBUTTON_FPS_WEAPONS                    0x09000402 /* Select next weapon */
#define DIBUTTON_FPS_APPLY                      0x09000403 /* Use item */
#define DIBUTTON_FPS_SELECT                     0x09000404 /* Select next inventory item */
#define DIBUTTON_FPS_CROUCH                     0x09000405 /* Crouch/ climb down/ swim down */
#define DIBUTTON_FPS_JUMP                       0x09000406 /* Jump/ climb up/ swim up */
#define DIAXIS_FPS_LOOKUPDOWN                   0x09018203 /* Look up / down  */
#define DIBUTTON_FPS_STRAFE                     0x09000407 /* Enable strafing while active */
#define DIBUTTON_FPS_MENU                       0x090004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FPS_GLANCE                  0x09004601 /* Look around */
#define DIBUTTON_FPS_DISPLAY                    0x09004408 /* Shows next on-screen display option/ map */
#define DIAXIS_FPS_SIDESTEP                     0x09024204 /* Sidestep */
#define DIBUTTON_FPS_DODGE                      0x09004409 /* Dodge */
#define DIBUTTON_FPS_GLANCEL                    0x0900440A /* Glance Left */
#define DIBUTTON_FPS_GLANCER                    0x0900440B /* Glance Right */
#define DIBUTTON_FPS_FIRESECONDARY              0x0900440C /* Alternative fire button */
#define DIBUTTON_FPS_ROTATE_LEFT_LINK           0x0900C4E4 /* Fallback rotate left button */
#define DIBUTTON_FPS_ROTATE_RIGHT_LINK          0x0900C4EC /* Fallback rotate right button */
#define DIBUTTON_FPS_FORWARD_LINK               0x090144E0 /* Fallback forward button */
#define DIBUTTON_FPS_BACKWARD_LINK              0x090144E8 /* Fallback backward button */
#define DIBUTTON_FPS_GLANCE_UP_LINK             0x0901C4E0 /* Fallback look up button */
#define DIBUTTON_FPS_GLANCE_DOWN_LINK           0x0901C4E8 /* Fallback look down button */
#define DIBUTTON_FPS_STEP_LEFT_LINK             0x090244E4 /* Fallback step left button */
#define DIBUTTON_FPS_STEP_RIGHT_LINK            0x090244EC /* Fallback step right button */
#define DIBUTTON_FPS_DEVICE                     0x090044FE /* Show input device and controls */
#define DIBUTTON_FPS_PAUSE                      0x090044FC /* Start / Pause / Restart game */

/*--- Fighting - Third Person action
      Perspective of camera is behind the main character  ---*/
#define DIVIRTUAL_FIGHTING_THIRDPERSON          0x0A000000
#define DIAXIS_TPS_TURN                         0x0A020201 /* Turn left/right */
#define DIAXIS_TPS_MOVE                         0x0A010202 /* Move forward/backward */
#define DIBUTTON_TPS_RUN                        0x0A000401 /* Run or walk toggle switch */
#define DIBUTTON_TPS_ACTION                     0x0A000402 /* Action Button */
#define DIBUTTON_TPS_SELECT                     0x0A000403 /* Select next weapon */
#define DIBUTTON_TPS_USE                        0x0A000404 /* Use inventory item currently selected */
#define DIBUTTON_TPS_JUMP                       0x0A000405 /* Character Jumps */
#define DIBUTTON_TPS_MENU                       0x0A0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_TPS_GLANCE                  0x0A004601 /* Look around */
#define DIBUTTON_TPS_VIEW                       0x0A004406 /* Select camera view */
#define DIBUTTON_TPS_STEPLEFT                   0x0A004407 /* Character takes a left step */
#define DIBUTTON_TPS_STEPRIGHT                  0x0A004408 /* Character takes a right step */
#define DIAXIS_TPS_STEP                         0x0A00C203 /* Character steps left/right */
#define DIBUTTON_TPS_DODGE                      0x0A004409 /* Character dodges or ducks */
#define DIBUTTON_TPS_INVENTORY                  0x0A00440A /* Cycle through inventory */
#define DIBUTTON_TPS_TURN_LEFT_LINK             0x0A0244E4 /* Fallback turn left button */
#define DIBUTTON_TPS_TURN_RIGHT_LINK            0x0A0244EC /* Fallback turn right button */
#define DIBUTTON_TPS_FORWARD_LINK               0x0A0144E0 /* Fallback forward button */
#define DIBUTTON_TPS_BACKWARD_LINK              0x0A0144E8 /* Fallback backward button */
#define DIBUTTON_TPS_GLANCE_UP_LINK             0x0A07C4E0 /* Fallback look up button */
#define DIBUTTON_TPS_GLANCE_DOWN_LINK           0x0A07C4E8 /* Fallback look down button */
#define DIBUTTON_TPS_GLANCE_LEFT_LINK           0x0A07C4E4 /* Fallback glance up button */
#define DIBUTTON_TPS_GLANCE_RIGHT_LINK          0x0A07C4EC /* Fallback glance right button */
#define DIBUTTON_TPS_DEVICE                     0x0A0044FE /* Show input device and controls */
#define DIBUTTON_TPS_PAUSE                      0x0A0044FC /* Start / Pause / Restart game */

/*--- Strategy - Role Playing
      Navigation and problem solving are primary actions  ---*/
#define DIVIRTUAL_STRATEGY_ROLEPLAYING          0x0B000000
#define DIAXIS_STRATEGYR_LATERAL                0x0B008201 /* sidestep - left/right */
#define DIAXIS_STRATEGYR_MOVE                   0x0B010202 /* move forward/backward */
#define DIBUTTON_STRATEGYR_GET                  0x0B000401 /* Acquire item */
#define DIBUTTON_STRATEGYR_APPLY                0x0B000402 /* Use selected item */
#define DIBUTTON_STRATEGYR_SELECT               0x0B000403 /* Select nextitem */
#define DIBUTTON_STRATEGYR_ATTACK               0x0B000404 /* Attack */
#define DIBUTTON_STRATEGYR_CAST                 0x0B000405 /* Cast Spell */
#define DIBUTTON_STRATEGYR_CROUCH               0x0B000406 /* Crouch */
#define DIBUTTON_STRATEGYR_JUMP                 0x0B000407 /* Jump */
#define DIBUTTON_STRATEGYR_MENU                 0x0B0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_STRATEGYR_GLANCE            0x0B004601 /* Look around */
#define DIBUTTON_STRATEGYR_MAP                  0x0B004408 /* Cycle through map options */
#define DIBUTTON_STRATEGYR_DISPLAY              0x0B004409 /* Shows next on-screen display option */
#define DIAXIS_STRATEGYR_ROTATE                 0x0B024203 /* Turn body left/right */
#define DIBUTTON_STRATEGYR_LEFT_LINK            0x0B00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_STRATEGYR_RIGHT_LINK           0x0B00C4EC /* Fallback sidestep right button */
#define DIBUTTON_STRATEGYR_FORWARD_LINK         0x0B0144E0 /* Fallback move forward button */
#define DIBUTTON_STRATEGYR_BACK_LINK            0x0B0144E8 /* Fallback move backward button */
#define DIBUTTON_STRATEGYR_ROTATE_LEFT_LINK     0x0B0244E4 /* Fallback turn body left button */
#define DIBUTTON_STRATEGYR_ROTATE_RIGHT_LINK    0x0B0244EC /* Fallback turn body right button */
#define DIBUTTON_STRATEGYR_DEVICE               0x0B0044FE /* Show input device and controls */
#define DIBUTTON_STRATEGYR_PAUSE                0x0B0044FC /* Start / Pause / Restart game */

/*--- Strategy - Turn based
      Navigation and problem solving are primary actions  ---*/
#define DIVIRTUAL_STRATEGY_TURN                 0x0C000000
#define DIAXIS_STRATEGYT_LATERAL                0x0C008201 /* Sidestep left/right */
#define DIAXIS_STRATEGYT_MOVE                   0x0C010202 /* Move forward/backwards */
#define DIBUTTON_STRATEGYT_SELECT               0x0C000401 /* Select unit or object */
#define DIBUTTON_STRATEGYT_INSTRUCT             0x0C000402 /* Cycle through instructions */
#define DIBUTTON_STRATEGYT_APPLY                0x0C000403 /* Apply selected instruction */
#define DIBUTTON_STRATEGYT_TEAM                 0x0C000404 /* Select next team / cycle through all */
#define DIBUTTON_STRATEGYT_TURN                 0x0C000405 /* Indicate turn over */
#define DIBUTTON_STRATEGYT_MENU                 0x0C0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_STRATEGYT_ZOOM                 0x0C004406 /* Zoom - in / out */
#define DIBUTTON_STRATEGYT_MAP                  0x0C004407 /* cycle through map options */
#define DIBUTTON_STRATEGYT_DISPLAY              0x0C004408 /* shows next on-screen display options */
#define DIBUTTON_STRATEGYT_LEFT_LINK            0x0C00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_STRATEGYT_RIGHT_LINK           0x0C00C4EC /* Fallback sidestep right button */
#define DIBUTTON_STRATEGYT_FORWARD_LINK         0x0C0144E0 /* Fallback move forward button */
#define DIBUTTON_STRATEGYT_BACK_LINK            0x0C0144E8 /* Fallback move back button */
#define DIBUTTON_STRATEGYT_DEVICE               0x0C0044FE /* Show input device and controls */
#define DIBUTTON_STRATEGYT_PAUSE                0x0C0044FC /* Start / Pause / Restart game */

/*--- Sports - Hunting
      Hunting                ---*/
#define DIVIRTUAL_SPORTS_HUNTING                0x0D000000
#define DIAXIS_HUNTING_LATERAL                  0x0D008201 /* sidestep left/right */
#define DIAXIS_HUNTING_MOVE                     0x0D010202 /* move forward/backwards */
#define DIBUTTON_HUNTING_FIRE                   0x0D000401 /* Fire selected weapon */
#define DIBUTTON_HUNTING_AIM                    0x0D000402 /* Select aim/move */
#define DIBUTTON_HUNTING_WEAPON                 0x0D000403 /* Select next weapon */
#define DIBUTTON_HUNTING_BINOCULAR              0x0D000404 /* Look through Binoculars */
#define DIBUTTON_HUNTING_CALL                   0x0D000405 /* Make animal call */
#define DIBUTTON_HUNTING_MAP                    0x0D000406 /* View Map */
#define DIBUTTON_HUNTING_SPECIAL                0x0D000407 /* Special game operation */
#define DIBUTTON_HUNTING_MENU                   0x0D0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HUNTING_GLANCE              0x0D004601 /* Look around */
#define DIBUTTON_HUNTING_DISPLAY                0x0D004408 /* show next on-screen display option */
#define DIAXIS_HUNTING_ROTATE                   0x0D024203 /* Turn body left/right */
#define DIBUTTON_HUNTING_CROUCH                 0x0D004409 /* Crouch/ Climb / Swim down */
#define DIBUTTON_HUNTING_JUMP                   0x0D00440A /* Jump/ Climb up / Swim up */
#define DIBUTTON_HUNTING_FIRESECONDARY          0x0D00440B /* Alternative fire button */
#define DIBUTTON_HUNTING_LEFT_LINK              0x0D00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HUNTING_RIGHT_LINK             0x0D00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HUNTING_FORWARD_LINK           0x0D0144E0 /* Fallback move forward button */
#define DIBUTTON_HUNTING_BACK_LINK              0x0D0144E8 /* Fallback move back button */
#define DIBUTTON_HUNTING_ROTATE_LEFT_LINK       0x0D0244E4 /* Fallback turn body left button */
#define DIBUTTON_HUNTING_ROTATE_RIGHT_LINK      0x0D0244EC /* Fallback turn body right button */
#define DIBUTTON_HUNTING_DEVICE                 0x0D0044FE /* Show input device and controls */
#define DIBUTTON_HUNTING_PAUSE                  0x0D0044FC /* Start / Pause / Restart game */

/*--- Sports - Fishing
      Catching Fish is primary objective   ---*/
#define DIVIRTUAL_SPORTS_FISHING                0x0E000000
#define DIAXIS_FISHING_LATERAL                  0x0E008201 /* sidestep left/right */
#define DIAXIS_FISHING_MOVE                     0x0E010202 /* move forward/backwards */
#define DIBUTTON_FISHING_CAST                   0x0E000401 /* Cast line */
#define DIBUTTON_FISHING_TYPE                   0x0E000402 /* Select cast type */
#define DIBUTTON_FISHING_BINOCULAR              0x0E000403 /* Look through Binocular */
#define DIBUTTON_FISHING_BAIT                   0x0E000404 /* Select type of Bait */
#define DIBUTTON_FISHING_MAP                    0x0E000405 /* View Map */
#define DIBUTTON_FISHING_MENU                   0x0E0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FISHING_GLANCE              0x0E004601 /* Look around */
#define DIBUTTON_FISHING_DISPLAY                0x0E004406 /* Show next on-screen display option */
#define DIAXIS_FISHING_ROTATE                   0x0E024203 /* Turn character left / right */
#define DIBUTTON_FISHING_CROUCH                 0x0E004407 /* Crouch/ Climb / Swim down */
#define DIBUTTON_FISHING_JUMP                   0x0E004408 /* Jump/ Climb up / Swim up */
#define DIBUTTON_FISHING_LEFT_LINK              0x0E00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FISHING_RIGHT_LINK             0x0E00C4EC /* Fallback sidestep right button */
#define DIBUTTON_FISHING_FORWARD_LINK           0x0E0144E0 /* Fallback move forward button */
#define DIBUTTON_FISHING_BACK_LINK              0x0E0144E8 /* Fallback move back button */
#define DIBUTTON_FISHING_ROTATE_LEFT_LINK       0x0E0244E4 /* Fallback turn body left button */
#define DIBUTTON_FISHING_ROTATE_RIGHT_LINK      0x0E0244EC /* Fallback turn body right button */
#define DIBUTTON_FISHING_DEVICE                 0x0E0044FE /* Show input device and controls */
#define DIBUTTON_FISHING_PAUSE                  0x0E0044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Batting
      Batter control is primary objective  ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_BAT           0x0F000000
#define DIAXIS_BASEBALLB_LATERAL                0x0F008201 /* Aim left / right */
#define DIAXIS_BASEBALLB_MOVE                   0x0F010202 /* Aim up / down */
#define DIBUTTON_BASEBALLB_SELECT               0x0F000401 /* cycle through swing options */
#define DIBUTTON_BASEBALLB_NORMAL               0x0F000402 /* normal swing */
#define DIBUTTON_BASEBALLB_POWER                0x0F000403 /* swing for the fence */
#define DIBUTTON_BASEBALLB_BUNT                 0x0F000404 /* bunt */
#define DIBUTTON_BASEBALLB_STEAL                0x0F000405 /* Base runner attempts to steal a base */
#define DIBUTTON_BASEBALLB_BURST                0x0F000406 /* Base runner invokes burst of speed */
#define DIBUTTON_BASEBALLB_SLIDE                0x0F000407 /* Base runner slides into base */
#define DIBUTTON_BASEBALLB_CONTACT              0x0F000408 /* Contact swing */
#define DIBUTTON_BASEBALLB_MENU                 0x0F0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLB_NOSTEAL              0x0F004409 /* Base runner goes back to a base */
#define DIBUTTON_BASEBALLB_BOX                  0x0F00440A /* Enter or exit batting box */
#define DIBUTTON_BASEBALLB_LEFT_LINK            0x0F00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BASEBALLB_RIGHT_LINK           0x0F00C4EC /* Fallback sidestep right button */
#define DIBUTTON_BASEBALLB_FORWARD_LINK         0x0F0144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLB_BACK_LINK            0x0F0144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLB_DEVICE               0x0F0044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLB_PAUSE                0x0F0044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Pitching
      Pitcher control is primary objective   ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_PITCH         0x10000000
#define DIAXIS_BASEBALLP_LATERAL                0x10008201 /* Aim left / right */
#define DIAXIS_BASEBALLP_MOVE                   0x10010202 /* Aim up / down */
#define DIBUTTON_BASEBALLP_SELECT               0x10000401 /* cycle through pitch selections */
#define DIBUTTON_BASEBALLP_PITCH                0x10000402 /* throw pitch */
#define DIBUTTON_BASEBALLP_BASE                 0x10000403 /* select base to throw to */
#define DIBUTTON_BASEBALLP_THROW                0x10000404 /* throw to base */
#define DIBUTTON_BASEBALLP_FAKE                 0x10000405 /* Fake a throw to a base */
#define DIBUTTON_BASEBALLP_MENU                 0x100004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLP_WALK                 0x10004406 /* Throw intentional walk / pitch out */
#define DIBUTTON_BASEBALLP_LOOK                 0x10004407 /* Look at runners on bases */
#define DIBUTTON_BASEBALLP_LEFT_LINK            0x1000C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BASEBALLP_RIGHT_LINK           0x1000C4EC /* Fallback sidestep right button */
#define DIBUTTON_BASEBALLP_FORWARD_LINK         0x100144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLP_BACK_LINK            0x100144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLP_DEVICE               0x100044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLP_PAUSE                0x100044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Fielding
      Fielder control is primary objective  ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_FIELD         0x11000000
#define DIAXIS_BASEBALLF_LATERAL                0x11008201 /* Aim left / right */
#define DIAXIS_BASEBALLF_MOVE                   0x11010202 /* Aim up / down */
#define DIBUTTON_BASEBALLF_NEAREST              0x11000401 /* Switch to fielder nearest to the ball */
#define DIBUTTON_BASEBALLF_THROW1               0x11000402 /* Make conservative throw */
#define DIBUTTON_BASEBALLF_THROW2               0x11000403 /* Make aggressive throw */
#define DIBUTTON_BASEBALLF_BURST                0x11000404 /* Invoke burst of speed */
#define DIBUTTON_BASEBALLF_JUMP                 0x11000405 /* Jump to catch ball */
#define DIBUTTON_BASEBALLF_DIVE                 0x11000406 /* Dive to catch ball */
#define DIBUTTON_BASEBALLF_MENU                 0x110004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLF_SHIFTIN              0x11004407 /* Shift the infield positioning */
#define DIBUTTON_BASEBALLF_SHIFTOUT             0x11004408 /* Shift the outfield positioning */
#define DIBUTTON_BASEBALLF_AIM_LEFT_LINK        0x1100C4E4 /* Fallback aim left button */
#define DIBUTTON_BASEBALLF_AIM_RIGHT_LINK       0x1100C4EC /* Fallback aim right button */
#define DIBUTTON_BASEBALLF_FORWARD_LINK         0x110144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLF_BACK_LINK            0x110144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLF_DEVICE               0x110044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLF_PAUSE                0x110044FC /* Start / Pause / Restart game */

/*--- Sports - Basketball - Offense
      Offense  ---*/
#define DIVIRTUAL_SPORTS_BASKETBALL_OFFENSE     0x12000000
#define DIAXIS_BBALLO_LATERAL                   0x12008201 /* left / right */
#define DIAXIS_BBALLO_MOVE                      0x12010202 /* up / down */
#define DIBUTTON_BBALLO_SHOOT                   0x12000401 /* shoot basket */
#define DIBUTTON_BBALLO_DUNK                    0x12000402 /* dunk basket */
#define DIBUTTON_BBALLO_PASS                    0x12000403 /* throw pass */
#define DIBUTTON_BBALLO_FAKE                    0x12000404 /* fake shot or pass */
#define DIBUTTON_BBALLO_SPECIAL                 0x12000405 /* apply special move */
#define DIBUTTON_BBALLO_PLAYER                  0x12000406 /* select next player */
#define DIBUTTON_BBALLO_BURST                   0x12000407 /* invoke burst */
#define DIBUTTON_BBALLO_CALL                    0x12000408 /* call for ball / pass to me */
#define DIBUTTON_BBALLO_MENU                    0x120004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BBALLO_GLANCE               0x12004601 /* scroll view */
#define DIBUTTON_BBALLO_SCREEN                  0x12004409 /* Call for screen */
#define DIBUTTON_BBALLO_PLAY                    0x1200440A /* Call for specific offensive play */
#define DIBUTTON_BBALLO_JAB                     0x1200440B /* Initiate fake drive to basket */
#define DIBUTTON_BBALLO_POST                    0x1200440C /* Perform post move */
#define DIBUTTON_BBALLO_TIMEOUT                 0x1200440D /* Time Out */
#define DIBUTTON_BBALLO_SUBSTITUTE              0x1200440E /* substitute one player for another */
#define DIBUTTON_BBALLO_LEFT_LINK               0x1200C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BBALLO_RIGHT_LINK              0x1200C4EC /* Fallback sidestep right button */
#define DIBUTTON_BBALLO_FORWARD_LINK            0x120144E0 /* Fallback move forward button */
#define DIBUTTON_BBALLO_BACK_LINK               0x120144E8 /* Fallback move back button */
#define DIBUTTON_BBALLO_DEVICE                  0x120044FE /* Show input device and controls */
#define DIBUTTON_BBALLO_PAUSE                   0x120044FC /* Start / Pause / Restart game */

/*--- Sports - Basketball - Defense
      Defense  ---*/
#define DIVIRTUAL_SPORTS_BASKETBALL_DEFENSE     0x13000000
#define DIAXIS_BBALLD_LATERAL                   0x13008201 /* left / right */
#define DIAXIS_BBALLD_MOVE                      0x13010202 /* up / down */
#define DIBUTTON_BBALLD_JUMP                    0x13000401 /* jump to block shot */
#define DIBUTTON_BBALLD_STEAL                   0x13000402 /* attempt to steal ball */
#define DIBUTTON_BBALLD_FAKE                    0x13000403 /* fake block or steal */
#define DIBUTTON_BBALLD_SPECIAL                 0x13000404 /* apply special move */
#define DIBUTTON_BBALLD_PLAYER                  0x13000405 /* select next player */
#define DIBUTTON_BBALLD_BURST                   0x13000406 /* invoke burst */
#define DIBUTTON_BBALLD_PLAY                    0x13000407 /* call for specific defensive play */
#define DIBUTTON_BBALLD_MENU                    0x130004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BBALLD_GLANCE               0x13004601 /* scroll view */
#define DIBUTTON_BBALLD_TIMEOUT                 0x13004408 /* Time Out */
#define DIBUTTON_BBALLD_SUBSTITUTE              0x13004409 /* substitute one player for another */
#define DIBUTTON_BBALLD_LEFT_LINK               0x1300C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BBALLD_RIGHT_LINK              0x1300C4EC /* Fallback sidestep right button */
#define DIBUTTON_BBALLD_FORWARD_LINK            0x130144E0 /* Fallback move forward button */
#define DIBUTTON_BBALLD_BACK_LINK               0x130144E8 /* Fallback move back button */
#define DIBUTTON_BBALLD_DEVICE                  0x130044FE /* Show input device and controls */
#define DIBUTTON_BBALLD_PAUSE                   0x130044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Play
      Play selection  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_FIELD         0x14000000
#define DIBUTTON_FOOTBALLP_PLAY                 0x14000401 /* cycle through available plays */
#define DIBUTTON_FOOTBALLP_SELECT               0x14000402 /* select play */
#define DIBUTTON_FOOTBALLP_HELP                 0x14000403 /* Bring up pop-up help */
#define DIBUTTON_FOOTBALLP_MENU                 0x140004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLP_DEVICE               0x140044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLP_PAUSE                0x140044FC /* Start / Pause / Restart game */

/*--- Sports - Football - QB
      Offense: Quarterback / Kicker  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_QBCK          0x15000000
#define DIAXIS_FOOTBALLQ_LATERAL                0x15008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLQ_MOVE                   0x15010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLQ_SELECT               0x15000401 /* Select */
#define DIBUTTON_FOOTBALLQ_SNAP                 0x15000402 /* snap ball - start play */
#define DIBUTTON_FOOTBALLQ_JUMP                 0x15000403 /* jump over defender */
#define DIBUTTON_FOOTBALLQ_SLIDE                0x15000404 /* Dive/Slide */
#define DIBUTTON_FOOTBALLQ_PASS                 0x15000405 /* throws pass to receiver */
#define DIBUTTON_FOOTBALLQ_FAKE                 0x15000406 /* pump fake pass or fake kick */
#define DIBUTTON_FOOTBALLQ_MENU                 0x150004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLQ_FAKESNAP             0x15004407 /* Fake snap  */
#define DIBUTTON_FOOTBALLQ_MOTION               0x15004408 /* Send receivers in motion */
#define DIBUTTON_FOOTBALLQ_AUDIBLE              0x15004409 /* Change offensive play at line of scrimmage */
#define DIBUTTON_FOOTBALLQ_LEFT_LINK            0x1500C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLQ_RIGHT_LINK           0x1500C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLQ_FORWARD_LINK         0x150144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLQ_BACK_LINK            0x150144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLQ_DEVICE               0x150044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLQ_PAUSE                0x150044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Offense
      Offense - Runner  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_OFFENSE       0x16000000
#define DIAXIS_FOOTBALLO_LATERAL                0x16008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLO_MOVE                   0x16010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLO_JUMP                 0x16000401 /* jump or hurdle over defender */
#define DIBUTTON_FOOTBALLO_LEFTARM              0x16000402 /* holds out left arm */
#define DIBUTTON_FOOTBALLO_RIGHTARM             0x16000403 /* holds out right arm */
#define DIBUTTON_FOOTBALLO_THROW                0x16000404 /* throw pass or lateral ball to another runner */
#define DIBUTTON_FOOTBALLO_SPIN                 0x16000405 /* Spin to avoid defenders */
#define DIBUTTON_FOOTBALLO_MENU                 0x160004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLO_JUKE                 0x16004406 /* Use special move to avoid defenders */
#define DIBUTTON_FOOTBALLO_SHOULDER             0x16004407 /* Lower shoulder to run over defenders */
#define DIBUTTON_FOOTBALLO_TURBO                0x16004408 /* Speed burst past defenders */
#define DIBUTTON_FOOTBALLO_DIVE                 0x16004409 /* Dive over defenders */
#define DIBUTTON_FOOTBALLO_ZOOM                 0x1600440A /* Zoom view in / out */
#define DIBUTTON_FOOTBALLO_SUBSTITUTE           0x1600440B /* substitute one player for another */
#define DIBUTTON_FOOTBALLO_LEFT_LINK            0x1600C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLO_RIGHT_LINK           0x1600C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLO_FORWARD_LINK         0x160144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLO_BACK_LINK            0x160144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLO_DEVICE               0x160044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLO_PAUSE                0x160044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Defense
      Defense     ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_DEFENSE       0x17000000
#define DIAXIS_FOOTBALLD_LATERAL                0x17008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLD_MOVE                   0x17010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLD_PLAY                 0x17000401 /* cycle through available plays */
#define DIBUTTON_FOOTBALLD_SELECT               0x17000402 /* select player closest to the ball */
#define DIBUTTON_FOOTBALLD_JUMP                 0x17000403 /* jump to intercept or block */
#define DIBUTTON_FOOTBALLD_TACKLE               0x17000404 /* tackler runner */
#define DIBUTTON_FOOTBALLD_FAKE                 0x17000405 /* hold down to fake tackle or intercept */
#define DIBUTTON_FOOTBALLD_SUPERTACKLE          0x17000406 /* Initiate special tackle */
#define DIBUTTON_FOOTBALLD_MENU                 0x170004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLD_SPIN                 0x17004407 /* Spin to beat offensive line */
#define DIBUTTON_FOOTBALLD_SWIM                 0x17004408 /* Swim to beat the offensive line */
#define DIBUTTON_FOOTBALLD_BULLRUSH             0x17004409 /* Bull rush the offensive line */
#define DIBUTTON_FOOTBALLD_RIP                  0x1700440A /* Rip the offensive line */
#define DIBUTTON_FOOTBALLD_AUDIBLE              0x1700440B /* Change defensive play at the line of scrimmage */
#define DIBUTTON_FOOTBALLD_ZOOM                 0x1700440C /* Zoom view in / out */
#define DIBUTTON_FOOTBALLD_SUBSTITUTE           0x1700440D /* substitute one player for another */
#define DIBUTTON_FOOTBALLD_LEFT_LINK            0x1700C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLD_RIGHT_LINK           0x1700C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLD_FORWARD_LINK         0x170144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLD_BACK_LINK            0x170144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLD_DEVICE               0x170044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLD_PAUSE                0x170044FC /* Start / Pause / Restart game */

/*--- Sports - Golf
                                ---*/
#define DIVIRTUAL_SPORTS_GOLF                   0x18000000
#define DIAXIS_GOLF_LATERAL                     0x18008201 /* Move / Aim: left / right */
#define DIAXIS_GOLF_MOVE                        0x18010202 /* Move / Aim: up / down */
#define DIBUTTON_GOLF_SWING                     0x18000401 /* swing club */
#define DIBUTTON_GOLF_SELECT                    0x18000402 /* cycle between: club / swing strength / ball arc / ball spin */
#define DIBUTTON_GOLF_UP                        0x18000403 /* increase selection */
#define DIBUTTON_GOLF_DOWN                      0x18000404 /* decrease selection */
#define DIBUTTON_GOLF_TERRAIN                   0x18000405 /* shows terrain detail */
#define DIBUTTON_GOLF_FLYBY                     0x18000406 /* view the hole via a flyby */
#define DIBUTTON_GOLF_MENU                      0x180004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_GOLF_SCROLL                 0x18004601 /* scroll view */
#define DIBUTTON_GOLF_ZOOM                      0x18004407 /* Zoom view in / out */
#define DIBUTTON_GOLF_TIMEOUT                   0x18004408 /* Call for time out */
#define DIBUTTON_GOLF_SUBSTITUTE                0x18004409 /* substitute one player for another */
#define DIBUTTON_GOLF_LEFT_LINK                 0x1800C4E4 /* Fallback sidestep left button */
#define DIBUTTON_GOLF_RIGHT_LINK                0x1800C4EC /* Fallback sidestep right button */
#define DIBUTTON_GOLF_FORWARD_LINK              0x180144E0 /* Fallback move forward button */
#define DIBUTTON_GOLF_BACK_LINK                 0x180144E8 /* Fallback move back button */
#define DIBUTTON_GOLF_DEVICE                    0x180044FE /* Show input device and controls */
#define DIBUTTON_GOLF_PAUSE                     0x180044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Offense
      Offense       ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_OFFENSE         0x19000000
#define DIAXIS_HOCKEYO_LATERAL                  0x19008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYO_MOVE                     0x19010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYO_SHOOT                  0x19000401 /* Shoot */
#define DIBUTTON_HOCKEYO_PASS                   0x19000402 /* pass the puck */
#define DIBUTTON_HOCKEYO_BURST                  0x19000403 /* invoke speed burst */
#define DIBUTTON_HOCKEYO_SPECIAL                0x19000404 /* invoke special move */
#define DIBUTTON_HOCKEYO_FAKE                   0x19000405 /* hold down to fake pass or kick */
#define DIBUTTON_HOCKEYO_MENU                   0x190004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYO_SCROLL              0x19004601 /* scroll view */
#define DIBUTTON_HOCKEYO_ZOOM                   0x19004406 /* Zoom view in / out */
#define DIBUTTON_HOCKEYO_STRATEGY               0x19004407 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYO_TIMEOUT                0x19004408 /* Call for time out */
#define DIBUTTON_HOCKEYO_SUBSTITUTE             0x19004409 /* substitute one player for another */
#define DIBUTTON_HOCKEYO_LEFT_LINK              0x1900C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYO_RIGHT_LINK             0x1900C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYO_FORWARD_LINK           0x190144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYO_BACK_LINK              0x190144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYO_DEVICE                 0x190044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYO_PAUSE                  0x190044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Defense
      Defense       ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_DEFENSE         0x1A000000
#define DIAXIS_HOCKEYD_LATERAL                  0x1A008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYD_MOVE                     0x1A010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYD_PLAYER                 0x1A000401 /* control player closest to the puck */
#define DIBUTTON_HOCKEYD_STEAL                  0x1A000402 /* attempt steal */
#define DIBUTTON_HOCKEYD_BURST                  0x1A000403 /* speed burst or body check */
#define DIBUTTON_HOCKEYD_BLOCK                  0x1A000404 /* block puck */
#define DIBUTTON_HOCKEYD_FAKE                   0x1A000405 /* hold down to fake tackle or intercept */
#define DIBUTTON_HOCKEYD_MENU                   0x1A0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYD_SCROLL              0x1A004601 /* scroll view */
#define DIBUTTON_HOCKEYD_ZOOM                   0x1A004406 /* Zoom view in / out */
#define DIBUTTON_HOCKEYD_STRATEGY               0x1A004407 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYD_TIMEOUT                0x1A004408 /* Call for time out */
#define DIBUTTON_HOCKEYD_SUBSTITUTE             0x1A004409 /* substitute one player for another */
#define DIBUTTON_HOCKEYD_LEFT_LINK              0x1A00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYD_RIGHT_LINK             0x1A00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYD_FORWARD_LINK           0x1A0144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYD_BACK_LINK              0x1A0144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYD_DEVICE                 0x1A0044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYD_PAUSE                  0x1A0044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Goalie
      Goal tending  ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_GOALIE          0x1B000000
#define DIAXIS_HOCKEYG_LATERAL                  0x1B008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYG_MOVE                     0x1B010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYG_PASS                   0x1B000401 /* pass puck */
#define DIBUTTON_HOCKEYG_POKE                   0x1B000402 /* poke / check / hack */
#define DIBUTTON_HOCKEYG_STEAL                  0x1B000403 /* attempt steal */
#define DIBUTTON_HOCKEYG_BLOCK                  0x1B000404 /* block puck */
#define DIBUTTON_HOCKEYG_MENU                   0x1B0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYG_SCROLL              0x1B004601 /* scroll view */
#define DIBUTTON_HOCKEYG_ZOOM                   0x1B004405 /* Zoom view in / out */
#define DIBUTTON_HOCKEYG_STRATEGY               0x1B004406 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYG_TIMEOUT                0x1B004407 /* Call for time out */
#define DIBUTTON_HOCKEYG_SUBSTITUTE             0x1B004408 /* substitute one player for another */
#define DIBUTTON_HOCKEYG_LEFT_LINK              0x1B00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYG_RIGHT_LINK             0x1B00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYG_FORWARD_LINK           0x1B0144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYG_BACK_LINK              0x1B0144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYG_DEVICE                 0x1B0044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYG_PAUSE                  0x1B0044FC /* Start / Pause / Restart game */

/*--- Sports - Mountain Biking
                     ---*/
#define DIVIRTUAL_SPORTS_BIKING_MOUNTAIN        0x1C000000
#define DIAXIS_BIKINGM_TURN                     0x1C008201 /* left / right */
#define DIAXIS_BIKINGM_PEDAL                    0x1C010202 /* Pedal faster / slower / brake */
#define DIBUTTON_BIKINGM_JUMP                   0x1C000401 /* jump over obstacle */
#define DIBUTTON_BIKINGM_CAMERA                 0x1C000402 /* switch camera view */
#define DIBUTTON_BIKINGM_SPECIAL1               0x1C000403 /* perform first special move */
#define DIBUTTON_BIKINGM_SELECT                 0x1C000404 /* Select */
#define DIBUTTON_BIKINGM_SPECIAL2               0x1C000405 /* perform second special move */
#define DIBUTTON_BIKINGM_MENU                   0x1C0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BIKINGM_SCROLL              0x1C004601 /* scroll view */
#define DIBUTTON_BIKINGM_ZOOM                   0x1C004406 /* Zoom view in / out */
#define DIAXIS_BIKINGM_BRAKE                    0x1C044203 /* Brake axis  */
#define DIBUTTON_BIKINGM_LEFT_LINK              0x1C00C4E4 /* Fallback turn left button */
#define DIBUTTON_BIKINGM_RIGHT_LINK             0x1C00C4EC /* Fallback turn right button */
#define DIBUTTON_BIKINGM_FASTER_LINK            0x1C0144E0 /* Fallback pedal faster button */
#define DIBUTTON_BIKINGM_SLOWER_LINK            0x1C0144E8 /* Fallback pedal slower button */
#define DIBUTTON_BIKINGM_BRAKE_BUTTON_LINK      0x1C0444E8 /* Fallback brake button */
#define DIBUTTON_BIKINGM_DEVICE                 0x1C0044FE /* Show input device and controls */
#define DIBUTTON_BIKINGM_PAUSE                  0x1C0044FC /* Start / Pause / Restart game */

/*--- Sports: Skiing / Snowboarding / Skateboarding
        ---*/
#define DIVIRTUAL_SPORTS_SKIING                 0x1D000000
#define DIAXIS_SKIING_TURN                      0x1D008201 /* left / right */
#define DIAXIS_SKIING_SPEED                     0x1D010202 /* faster / slower */
#define DIBUTTON_SKIING_JUMP                    0x1D000401 /* Jump */
#define DIBUTTON_SKIING_CROUCH                  0x1D000402 /* crouch down */
#define DIBUTTON_SKIING_CAMERA                  0x1D000403 /* switch camera view */
#define DIBUTTON_SKIING_SPECIAL1                0x1D000404 /* perform first special move */
#define DIBUTTON_SKIING_SELECT                  0x1D000405 /* Select */
#define DIBUTTON_SKIING_SPECIAL2                0x1D000406 /* perform second special move */
#define DIBUTTON_SKIING_MENU                    0x1D0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SKIING_GLANCE               0x1D004601 /* scroll view */
#define DIBUTTON_SKIING_ZOOM                    0x1D004407 /* Zoom view in / out */
#define DIBUTTON_SKIING_LEFT_LINK               0x1D00C4E4 /* Fallback turn left button */
#define DIBUTTON_SKIING_RIGHT_LINK              0x1D00C4EC /* Fallback turn right button */
#define DIBUTTON_SKIING_FASTER_LINK             0x1D0144E0 /* Fallback increase speed button */
#define DIBUTTON_SKIING_SLOWER_LINK             0x1D0144E8 /* Fallback decrease speed button */
#define DIBUTTON_SKIING_DEVICE                  0x1D0044FE /* Show input device and controls */
#define DIBUTTON_SKIING_PAUSE                   0x1D0044FC /* Start / Pause / Restart game */

/*--- Sports - Soccer - Offense
      Offense       ---*/
#define DIVIRTUAL_SPORTS_SOCCER_OFFENSE         0x1E000000
#define DIAXIS_SOCCERO_LATERAL                  0x1E008201 /* Move / Aim: left / right */
#define DIAXIS_SOCCERO_MOVE                     0x1E010202 /* Move / Aim: up / down */
#define DIAXIS_SOCCERO_BEND                     0x1E018203 /* Bend to soccer shot/pass */
#define DIBUTTON_SOCCERO_SHOOT                  0x1E000401 /* Shoot the ball */
#define DIBUTTON_SOCCERO_PASS                   0x1E000402 /* Pass  */
#define DIBUTTON_SOCCERO_FAKE                   0x1E000403 /* Fake */
#define DIBUTTON_SOCCERO_PLAYER                 0x1E000404 /* Select next player */
#define DIBUTTON_SOCCERO_SPECIAL1               0x1E000405 /* Apply special move */
#define DIBUTTON_SOCCERO_SELECT                 0x1E000406 /* Select special move */
#define DIBUTTON_SOCCERO_MENU                   0x1E0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SOCCERO_GLANCE              0x1E004601 /* scroll view */
#define DIBUTTON_SOCCERO_SUBSTITUTE             0x1E004407 /* Substitute one player for another */
#define DIBUTTON_SOCCERO_SHOOTLOW               0x1E004408 /* Shoot the ball low */
#define DIBUTTON_SOCCERO_SHOOTHIGH              0x1E004409 /* Shoot the ball high */
#define DIBUTTON_SOCCERO_PASSTHRU               0x1E00440A /* Make a thru pass */
#define DIBUTTON_SOCCERO_SPRINT                 0x1E00440B /* Sprint / turbo boost */
#define DIBUTTON_SOCCERO_CONTROL                0x1E00440C /* Obtain control of the ball */
#define DIBUTTON_SOCCERO_HEAD                   0x1E00440D /* Attempt to head the ball */
#define DIBUTTON_SOCCERO_LEFT_LINK              0x1E00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_SOCCERO_RIGHT_LINK             0x1E00C4EC /* Fallback sidestep right button */
#define DIBUTTON_SOCCERO_FORWARD_LINK           0x1E0144E0 /* Fallback move forward button */
#define DIBUTTON_SOCCERO_BACK_LINK              0x1E0144E8 /* Fallback move back button */
#define DIBUTTON_SOCCERO_DEVICE                 0x1E0044FE /* Show input device and controls */
#define DIBUTTON_SOCCERO_PAUSE                  0x1E0044FC /* Start / Pause / Restart game */

/*--- Sports - Soccer - Defense
      Defense       ---*/
#define DIVIRTUAL_SPORTS_SOCCER_DEFENSE         0x1F000000
#define DIAXIS_SOCCERD_LATERAL                  0x1F008201 /* Move / Aim: left / right */
#define DIAXIS_SOCCERD_MOVE                     0x1F010202 /* Move / Aim: up / down */
#define DIBUTTON_SOCCERD_BLOCK                  0x1F000401 /* Attempt to block shot */
#define DIBUTTON_SOCCERD_STEAL                  0x1F000402 /* Attempt to steal ball */
#define DIBUTTON_SOCCERD_FAKE                   0x1F000403 /* Fake a block or a steal */
#define DIBUTTON_SOCCERD_PLAYER                 0x1F000404 /* Select next player */
#define DIBUTTON_SOCCERD_SPECIAL                0x1F000405 /* Apply special move */
#define DIBUTTON_SOCCERD_SELECT                 0x1F000406 /* Select special move */
#define DIBUTTON_SOCCERD_SLIDE                  0x1F000407 /* Attempt a slide tackle */
#define DIBUTTON_SOCCERD_MENU                   0x1F0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SOCCERD_GLANCE              0x1F004601 /* scroll view */
#define DIBUTTON_SOCCERD_FOUL                   0x1F004408 /* Initiate a foul / hard-foul */
#define DIBUTTON_SOCCERD_HEAD                   0x1F004409 /* Attempt a Header */
#define DIBUTTON_SOCCERD_CLEAR                  0x1F00440A /* Attempt to clear the ball down the field */
#define DIBUTTON_SOCCERD_GOALIECHARGE           0x1F00440B /* Make the goalie charge out of the box */
#define DIBUTTON_SOCCERD_SUBSTITUTE             0x1F00440C /* Substitute one player for another */
#define DIBUTTON_SOCCERD_LEFT_LINK              0x1F00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_SOCCERD_RIGHT_LINK             0x1F00C4EC /* Fallback sidestep right button */
#define DIBUTTON_SOCCERD_FORWARD_LINK           0x1F0144E0 /* Fallback move forward button */
#define DIBUTTON_SOCCERD_BACK_LINK              0x1F0144E8 /* Fallback move back button */
#define DIBUTTON_SOCCERD_DEVICE                 0x1F0044FE /* Show input device and controls */
#define DIBUTTON_SOCCERD_PAUSE                  0x1F0044FC /* Start / Pause / Restart game */

/*--- Sports - Racquet
      Tennis - Table-Tennis - Squash   ---*/
#define DIVIRTUAL_SPORTS_RACQUET                0x20000000
#define DIAXIS_RACQUET_LATERAL                  0x20008201 /* Move / Aim: left / right */
#define DIAXIS_RACQUET_MOVE                     0x20010202 /* Move / Aim: up / down */
#define DIBUTTON_RACQUET_SWING                  0x20000401 /* Swing racquet */
#define DIBUTTON_RACQUET_BACKSWING              0x20000402 /* Swing backhand */
#define DIBUTTON_RACQUET_SMASH                  0x20000403 /* Smash shot */
#define DIBUTTON_RACQUET_SPECIAL                0x20000404 /* Special shot */
#define DIBUTTON_RACQUET_SELECT                 0x20000405 /* Select special shot */
#define DIBUTTON_RACQUET_MENU                   0x200004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_RACQUET_GLANCE              0x20004601 /* scroll view */
#define DIBUTTON_RACQUET_TIMEOUT                0x20004406 /* Call for time out */
#define DIBUTTON_RACQUET_SUBSTITUTE             0x20004407 /* Substitute one player for another */
#define DIBUTTON_RACQUET_LEFT_LINK              0x2000C4E4 /* Fallback sidestep left button */
#define DIBUTTON_RACQUET_RIGHT_LINK             0x2000C4EC /* Fallback sidestep right button */
#define DIBUTTON_RACQUET_FORWARD_LINK           0x200144E0 /* Fallback move forward button */
#define DIBUTTON_RACQUET_BACK_LINK              0x200144E8 /* Fallback move back button */
#define DIBUTTON_RACQUET_DEVICE                 0x200044FE /* Show input device and controls */
#define DIBUTTON_RACQUET_PAUSE                  0x200044FC /* Start / Pause / Restart game */

/*--- Arcade- 2D
      Side to Side movement        ---*/
#define DIVIRTUAL_ARCADE_SIDE2SIDE              0x21000000
#define DIAXIS_ARCADES_LATERAL                  0x21008201 /* left / right */
#define DIAXIS_ARCADES_MOVE                     0x21010202 /* up / down */
#define DIBUTTON_ARCADES_THROW                  0x21000401 /* throw object */
#define DIBUTTON_ARCADES_CARRY                  0x21000402 /* carry object */
#define DIBUTTON_ARCADES_ATTACK                 0x21000403 /* attack */
#define DIBUTTON_ARCADES_SPECIAL                0x21000404 /* apply special move */
#define DIBUTTON_ARCADES_SELECT                 0x21000405 /* select special move */
#define DIBUTTON_ARCADES_MENU                   0x210004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_ARCADES_VIEW                0x21004601 /* scroll view left / right / up / down */
#define DIBUTTON_ARCADES_LEFT_LINK              0x2100C4E4 /* Fallback sidestep left button */
#define DIBUTTON_ARCADES_RIGHT_LINK             0x2100C4EC /* Fallback sidestep right button */
#define DIBUTTON_ARCADES_FORWARD_LINK           0x210144E0 /* Fallback move forward button */
#define DIBUTTON_ARCADES_BACK_LINK              0x210144E8 /* Fallback move back button */
#define DIBUTTON_ARCADES_VIEW_UP_LINK           0x2107C4E0 /* Fallback scroll view up button */
#define DIBUTTON_ARCADES_VIEW_DOWN_LINK         0x2107C4E8 /* Fallback scroll view down button */
#define DIBUTTON_ARCADES_VIEW_LEFT_LINK         0x2107C4E4 /* Fallback scroll view left button */
#define DIBUTTON_ARCADES_VIEW_RIGHT_LINK        0x2107C4EC /* Fallback scroll view right button */
#define DIBUTTON_ARCADES_DEVICE                 0x210044FE /* Show input device and controls */
#define DIBUTTON_ARCADES_PAUSE                  0x210044FC /* Start / Pause / Restart game */

/*--- Arcade - Platform Game
      Character moves around on screen  ---*/
#define DIVIRTUAL_ARCADE_PLATFORM               0x22000000
#define DIAXIS_ARCADEP_LATERAL                  0x22008201 /* Left / right */
#define DIAXIS_ARCADEP_MOVE                     0x22010202 /* Up / down */
#define DIBUTTON_ARCADEP_JUMP                   0x22000401 /* Jump */
#define DIBUTTON_ARCADEP_FIRE                   0x22000402 /* Fire */
#define DIBUTTON_ARCADEP_CROUCH                 0x22000403 /* Crouch */
#define DIBUTTON_ARCADEP_SPECIAL                0x22000404 /* Apply special move */
#define DIBUTTON_ARCADEP_SELECT                 0x22000405 /* Select special move */
#define DIBUTTON_ARCADEP_MENU                   0x220004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_ARCADEP_VIEW                0x22004601 /* Scroll view */
#define DIBUTTON_ARCADEP_FIRESECONDARY          0x22004406 /* Alternative fire button */
#define DIBUTTON_ARCADEP_LEFT_LINK              0x2200C4E4 /* Fallback sidestep left button */
#define DIBUTTON_ARCADEP_RIGHT_LINK             0x2200C4EC /* Fallback sidestep right button */
#define DIBUTTON_ARCADEP_FORWARD_LINK           0x220144E0 /* Fallback move forward button */
#define DIBUTTON_ARCADEP_BACK_LINK              0x220144E8 /* Fallback move back button */
#define DIBUTTON_ARCADEP_VIEW_UP_LINK           0x2207C4E0 /* Fallback scroll view up button */
#define DIBUTTON_ARCADEP_VIEW_DOWN_LINK         0x2207C4E8 /* Fallback scroll view down button */
#define DIBUTTON_ARCADEP_VIEW_LEFT_LINK         0x2207C4E4 /* Fallback scroll view left button */
#define DIBUTTON_ARCADEP_VIEW_RIGHT_LINK        0x2207C4EC /* Fallback scroll view right button */
#define DIBUTTON_ARCADEP_DEVICE                 0x220044FE /* Show input device and controls */
#define DIBUTTON_ARCADEP_PAUSE                  0x220044FC /* Start / Pause / Restart game */

/*--- CAD - 2D Object Control
      Controls to select and move objects in 2D  ---*/
#define DIVIRTUAL_CAD_2DCONTROL                 0x23000000
#define DIAXIS_2DCONTROL_LATERAL                0x23008201 /* Move view left / right */
#define DIAXIS_2DCONTROL_MOVE                   0x23010202 /* Move view up / down */
#define DIAXIS_2DCONTROL_INOUT                  0x23018203 /* Zoom - in / out */
#define DIBUTTON_2DCONTROL_SELECT               0x23000401 /* Select Object */
#define DIBUTTON_2DCONTROL_SPECIAL1             0x23000402 /* Do first special operation */
#define DIBUTTON_2DCONTROL_SPECIAL              0x23000403 /* Select special operation */
#define DIBUTTON_2DCONTROL_SPECIAL2             0x23000404 /* Do second special operation */
#define DIBUTTON_2DCONTROL_MENU                 0x230004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_2DCONTROL_HATSWITCH         0x23004601 /* Hat switch */
#define DIAXIS_2DCONTROL_ROTATEZ                0x23024204 /* Rotate view clockwise / counterclockwise */
#define DIBUTTON_2DCONTROL_DISPLAY              0x23004405 /* Shows next on-screen display options */
#define DIBUTTON_2DCONTROL_DEVICE               0x230044FE /* Show input device and controls */
#define DIBUTTON_2DCONTROL_PAUSE                0x230044FC /* Start / Pause / Restart game */

/*--- CAD - 3D object control
      Controls to select and move objects within a 3D environment  ---*/
#define DIVIRTUAL_CAD_3DCONTROL                 0x24000000
#define DIAXIS_3DCONTROL_LATERAL                0x24008201 /* Move view left / right */
#define DIAXIS_3DCONTROL_MOVE                   0x24010202 /* Move view up / down */
#define DIAXIS_3DCONTROL_INOUT                  0x24018203 /* Zoom - in / out */
#define DIBUTTON_3DCONTROL_SELECT               0x24000401 /* Select Object */
#define DIBUTTON_3DCONTROL_SPECIAL1             0x24000402 /* Do first special operation */
#define DIBUTTON_3DCONTROL_SPECIAL              0x24000403 /* Select special operation */
#define DIBUTTON_3DCONTROL_SPECIAL2             0x24000404 /* Do second special operation */
#define DIBUTTON_3DCONTROL_MENU                 0x240004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_3DCONTROL_HATSWITCH         0x24004601 /* Hat switch */
#define DIAXIS_3DCONTROL_ROTATEX                0x24034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_3DCONTROL_ROTATEY                0x2402C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_3DCONTROL_ROTATEZ                0x24024206 /* Rotate view left / right */
#define DIBUTTON_3DCONTROL_DISPLAY              0x24004405 /* Show next on-screen display options */
#define DIBUTTON_3DCONTROL_DEVICE               0x240044FE /* Show input device and controls */
#define DIBUTTON_3DCONTROL_PAUSE                0x240044FC /* Start / Pause / Restart game */

/*--- CAD - 3D Navigation - Fly through
      Controls for 3D modeling  ---*/
#define DIVIRTUAL_CAD_FLYBY                     0x25000000
#define DIAXIS_CADF_LATERAL                     0x25008201 /* move view left / right */
#define DIAXIS_CADF_MOVE                        0x25010202 /* move view up / down */
#define DIAXIS_CADF_INOUT                       0x25018203 /* in / out */
#define DIBUTTON_CADF_SELECT                    0x25000401 /* Select Object */
#define DIBUTTON_CADF_SPECIAL1                  0x25000402 /* do first special operation */
#define DIBUTTON_CADF_SPECIAL                   0x25000403 /* Select special operation */
#define DIBUTTON_CADF_SPECIAL2                  0x25000404 /* do second special operation */
#define DIBUTTON_CADF_MENU                      0x250004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_CADF_HATSWITCH              0x25004601 /* Hat switch */
#define DIAXIS_CADF_ROTATEX                     0x25034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_CADF_ROTATEY                     0x2502C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_CADF_ROTATEZ                     0x25024206 /* Rotate view left / right */
#define DIBUTTON_CADF_DISPLAY                   0x25004405 /* shows next on-screen display options */
#define DIBUTTON_CADF_DEVICE                    0x250044FE /* Show input device and controls */
#define DIBUTTON_CADF_PAUSE                     0x250044FC /* Start / Pause / Restart game */

/*--- CAD - 3D Model Control
      Controls for 3D modeling  ---*/
#define DIVIRTUAL_CAD_MODEL                     0x26000000
#define DIAXIS_CADM_LATERAL                     0x26008201 /* move view left / right */
#define DIAXIS_CADM_MOVE                        0x26010202 /* move view up / down */
#define DIAXIS_CADM_INOUT                       0x26018203 /* in / out */
#define DIBUTTON_CADM_SELECT                    0x26000401 /* Select Object */
#define DIBUTTON_CADM_SPECIAL1                  0x26000402 /* do first special operation */
#define DIBUTTON_CADM_SPECIAL                   0x26000403 /* Select special operation */
#define DIBUTTON_CADM_SPECIAL2                  0x26000404 /* do second special operation */
#define DIBUTTON_CADM_MENU                      0x260004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_CADM_HATSWITCH              0x26004601 /* Hat switch */
#define DIAXIS_CADM_ROTATEX                     0x26034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_CADM_ROTATEY                     0x2602C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_CADM_ROTATEZ                     0x26024206 /* Rotate view left / right */
#define DIBUTTON_CADM_DISPLAY                   0x26004405 /* shows next on-screen display options */
#define DIBUTTON_CADM_DEVICE                    0x260044FE /* Show input device and controls */
#define DIBUTTON_CADM_PAUSE                     0x260044FC /* Start / Pause / Restart game */

/*--- Control - Media Equipment
      Remote        ---*/
#define DIVIRTUAL_REMOTE_CONTROL                0x27000000
#define DIAXIS_REMOTE_SLIDER                    0x27050201 /* Slider for adjustment: volume / color / bass / etc */
#define DIBUTTON_REMOTE_MUTE                    0x27000401 /* Set volume on current device to zero */
#define DIBUTTON_REMOTE_SELECT                  0x27000402 /* Next/previous: channel/ track / chapter / picture / station */
#define DIBUTTON_REMOTE_PLAY                    0x27002403 /* Start or pause entertainment on current device */
#define DIBUTTON_REMOTE_CUE                     0x27002404 /* Move through current media */
#define DIBUTTON_REMOTE_REVIEW                  0x27002405 /* Move through current media */
#define DIBUTTON_REMOTE_CHANGE                  0x27002406 /* Select next device */
#define DIBUTTON_REMOTE_RECORD                  0x27002407 /* Start recording the current media */
#define DIBUTTON_REMOTE_MENU                    0x270004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_REMOTE_SLIDER2                   0x27054202 /* Slider for adjustment: volume */
#define DIBUTTON_REMOTE_TV                      0x27005C08 /* Select TV */
#define DIBUTTON_REMOTE_CABLE                   0x27005C09 /* Select cable box */
#define DIBUTTON_REMOTE_CD                      0x27005C0A /* Select CD player */
#define DIBUTTON_REMOTE_VCR                     0x27005C0B /* Select VCR */
#define DIBUTTON_REMOTE_TUNER                   0x27005C0C /* Select tuner */
#define DIBUTTON_REMOTE_DVD                     0x27005C0D /* Select DVD player */
#define DIBUTTON_REMOTE_ADJUST                  0x27005C0E /* Enter device adjustment menu */
#define DIBUTTON_REMOTE_DIGIT0                  0x2700540F /* Digit 0 */
#define DIBUTTON_REMOTE_DIGIT1                  0x27005410 /* Digit 1 */
#define DIBUTTON_REMOTE_DIGIT2                  0x27005411 /* Digit 2 */
#define DIBUTTON_REMOTE_DIGIT3                  0x27005412 /* Digit 3 */
#define DIBUTTON_REMOTE_DIGIT4                  0x27005413 /* Digit 4 */
#define DIBUTTON_REMOTE_DIGIT5                  0x27005414 /* Digit 5 */
#define DIBUTTON_REMOTE_DIGIT6                  0x27005415 /* Digit 6 */
#define DIBUTTON_REMOTE_DIGIT7                  0x27005416 /* Digit 7 */
#define DIBUTTON_REMOTE_DIGIT8                  0x27005417 /* Digit 8 */
#define DIBUTTON_REMOTE_DIGIT9                  0x27005418 /* Digit 9 */
#define DIBUTTON_REMOTE_DEVICE                  0x270044FE /* Show input device and controls */
#define DIBUTTON_REMOTE_PAUSE                   0x270044FC /* Start / Pause / Restart game */

/*--- Control- Web
      Help or Browser            ---*/
#define DIVIRTUAL_BROWSER_CONTROL               0x28000000
#define DIAXIS_BROWSER_LATERAL                  0x28008201 /* Move on screen pointer */
#define DIAXIS_BROWSER_MOVE                     0x28010202 /* Move on screen pointer */
#define DIBUTTON_BROWSER_SELECT                 0x28000401 /* Select current item */
#define DIAXIS_BROWSER_VIEW                     0x28018203 /* Move view up/down */
#define DIBUTTON_BROWSER_REFRESH                0x28000402 /* Refresh */
#define DIBUTTON_BROWSER_MENU                   0x280004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BROWSER_SEARCH                 0x28004403 /* Use search tool */
#define DIBUTTON_BROWSER_STOP                   0x28004404 /* Cease current update */
#define DIBUTTON_BROWSER_HOME                   0x28004405 /* Go directly to "home" location */
#define DIBUTTON_BROWSER_FAVORITES              0x28004406 /* Mark current site as favorite */
#define DIBUTTON_BROWSER_NEXT                   0x28004407 /* Select Next page */
#define DIBUTTON_BROWSER_PREVIOUS               0x28004408 /* Select Previous page */
#define DIBUTTON_BROWSER_HISTORY                0x28004409 /* Show/Hide History */
#define DIBUTTON_BROWSER_PRINT                  0x2800440A /* Print current page */
#define DIBUTTON_BROWSER_DEVICE                 0x280044FE /* Show input device and controls */
#define DIBUTTON_BROWSER_PAUSE                  0x280044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Giant Walking Robot
      Walking tank with weapons  ---*/
#define DIVIRTUAL_DRIVING_MECHA                 0x29000000
#define DIAXIS_MECHA_STEER                      0x29008201 /* Turns mecha left/right */
#define DIAXIS_MECHA_TORSO                      0x29010202 /* Tilts torso forward/backward */
#define DIAXIS_MECHA_ROTATE                     0x29020203 /* Turns torso left/right */
#define DIAXIS_MECHA_THROTTLE                   0x29038204 /* Engine Speed */
#define DIBUTTON_MECHA_FIRE                     0x29000401 /* Fire */
#define DIBUTTON_MECHA_WEAPONS                  0x29000402 /* Select next weapon group */
#define DIBUTTON_MECHA_TARGET                   0x29000403 /* Select closest enemy available target */
#define DIBUTTON_MECHA_REVERSE                  0x29000404 /* Toggles throttle in/out of reverse */
#define DIBUTTON_MECHA_ZOOM                     0x29000405 /* Zoom in/out targeting reticule */
#define DIBUTTON_MECHA_JUMP                     0x29000406 /* Fires jump jets */
#define DIBUTTON_MECHA_MENU                     0x290004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_MECHA_CENTER                   0x29004407 /* Center torso to legs */
#define DIHATSWITCH_MECHA_GLANCE                0x29004601 /* Look around */
#define DIBUTTON_MECHA_VIEW                     0x29004408 /* Cycle through view options */
#define DIBUTTON_MECHA_FIRESECONDARY            0x29004409 /* Alternative fire button */
#define DIBUTTON_MECHA_LEFT_LINK                0x2900C4E4 /* Fallback steer left button */
#define DIBUTTON_MECHA_RIGHT_LINK               0x2900C4EC /* Fallback steer right button */
#define DIBUTTON_MECHA_FORWARD_LINK             0x290144E0 /* Fallback tilt torso forward button */
#define DIBUTTON_MECHA_BACK_LINK                0x290144E8 /* Fallback tilt toroso backward button */
#define DIBUTTON_MECHA_ROTATE_LEFT_LINK         0x290244E4 /* Fallback rotate toroso right button */
#define DIBUTTON_MECHA_ROTATE_RIGHT_LINK        0x290244EC /* Fallback rotate torso left button */
#define DIBUTTON_MECHA_FASTER_LINK              0x2903C4E0 /* Fallback increase engine speed */
#define DIBUTTON_MECHA_SLOWER_LINK              0x2903C4E8 /* Fallback decrease engine speed */
#define DIBUTTON_MECHA_DEVICE                   0x290044FE /* Show input device and controls */
#define DIBUTTON_MECHA_PAUSE                    0x290044FC /* Start / Pause / Restart game */

/*
 *  "ANY" semantics can be used as a last resort to get mappings for actions 
 *  that match nothing in the chosen virtual genre.  These semantics will be 
 *  mapped at a lower priority that virtual genre semantics.  Also, hardware 
 *  vendors will not be able to provide sensible mappings for these unless 
 *  they provide application specific mappings.
 */
#define DIAXIS_ANY_X_1                          0xFF00C201 
#define DIAXIS_ANY_X_2                          0xFF00C202 
#define DIAXIS_ANY_Y_1                          0xFF014201 
#define DIAXIS_ANY_Y_2                          0xFF014202 
#define DIAXIS_ANY_Z_1                          0xFF01C201 
#define DIAXIS_ANY_Z_2                          0xFF01C202 
#define DIAXIS_ANY_R_1                          0xFF024201 
#define DIAXIS_ANY_R_2                          0xFF024202 
#define DIAXIS_ANY_U_1                          0xFF02C201 
#define DIAXIS_ANY_U_2                          0xFF02C202 
#define DIAXIS_ANY_V_1                          0xFF034201 
#define DIAXIS_ANY_V_2                          0xFF034202 
#define DIAXIS_ANY_A_1                          0xFF03C201 
#define DIAXIS_ANY_A_2                          0xFF03C202 
#define DIAXIS_ANY_B_1                          0xFF044201 
#define DIAXIS_ANY_B_2                          0xFF044202 
#define DIAXIS_ANY_C_1                          0xFF04C201 
#define DIAXIS_ANY_C_2                          0xFF04C202 
#define DIAXIS_ANY_S_1                          0xFF054201 
#define DIAXIS_ANY_S_2                          0xFF054202 

#define DIAXIS_ANY_1                            0xFF004201 
#define DIAXIS_ANY_2                            0xFF004202 
#define DIAXIS_ANY_3                            0xFF004203 
#define DIAXIS_ANY_4                            0xFF004204 

#define DIPOV_ANY_1                             0xFF004601 
#define DIPOV_ANY_2                             0xFF004602 
#define DIPOV_ANY_3                             0xFF004603 
#define DIPOV_ANY_4                             0xFF004604 

#define DIBUTTON_ANY(instance)                  ( 0xFF004400 | instance )


#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );

#ifndef DIJ_RINGZERO
/*
 * Invoke the joystick control panel directly, using the passed window handle 
 * as the parent of the dialog.  This API is only supported for compatibility 
 * purposes; new applications should use the RunControlPanel method of a 
 * device interface for a game controller.
 * The API is called by using the function pointer returned by
 * GetProcAddress( hCPL, TEXT("ShowJoyCPL") ) where hCPL is a HMODULE returned 
 * by LoadLibrary( TEXT("joy.cpl") ).  The typedef is provided to allow 
 * declaration and casting of an appropriately typed variable.
 */
void WINAPI ShowJoyCPL( HWND hWnd );
typedef void (WINAPI* LPFNSHOWJOYCPL)( HWND hWnd );
#endif

/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l

/*
 * Hardware Setting indicating that VJoyD should not load this
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l


/*
 * Hardware Setting indicating that the device is a gameport bus
 */
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l

/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dhcpsapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpsapi.h

-*/

#ifndef _DHCPSAPI_
#define _DHCPSAPI_

#pragma once

#if defined(MIDL_PASS)
#define LPWSTR [string] wchar_t *
#endif

#if (_MSC_VER >= 800)
#define DHCP_API_FUNCTION    __stdcall
#else
#define DHCP_API_FUNCTION
#endif

#ifdef __cplusplus
#define DHCP_CONST   const
extern "C" {
#else
#define DHCP_CONST
#endif // __cplusplus

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_IP_MASK;
typedef DWORD DHCP_RESUME_HANDLE;

typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

typedef struct _DWORD_DWORD {
    DWORD DWord1;
    DWORD DWord2;
} DWORD_DWORD, *LPDWORD_DWORD;

typedef struct _DHCP_BINARY_DATA {
    DWORD DataLength;

#if defined(MIDL_PASS)
    [size_is(DataLength)]
#endif // MIDL_PASS
        BYTE *Data;

} DHCP_BINARY_DATA, *LPDHCP_BINARY_DATA;

typedef DHCP_BINARY_DATA DHCP_CLIENT_UID;



#define DHCP_ENDPOINT_FLAG_CANT_MODIFY 0x01

typedef struct _DHCP_BIND_ELEMENT {
    ULONG Flags;
    BOOL fBoundToDHCPServer;
    DHCP_IP_ADDRESS AdapterPrimaryAddress;
    DHCP_IP_ADDRESS AdapterSubnetAddress;
    LPWSTR IfDescription;
    ULONG IfIdSize;
#if defined (MIDL_PASS)
    [size_is(IfIdSize)]
#endif // MIDL_PASS
    LPBYTE IfId;    
} DHCP_BIND_ELEMENT, *LPDHCP_BIND_ELEMENT;

typedef struct _DHCP_BIND_ELEMENT_ARRAY {
    DWORD NumElements;
#if defined (MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_BIND_ELEMENT Elements; //array
} DHCP_BIND_ELEMENT_ARRAY, *LPDHCP_BIND_ELEMENT_ARRAY;


typedef enum _DHCP_CLIENT_SEARCH_TYPE {
    DhcpClientIpAddress,
    DhcpClientHardwareAddress,
    DhcpClientName
} DHCP_SEARCH_INFO_TYPE, *LPDHCP_SEARCH_INFO_TYPE;

typedef struct _DHCP_CLIENT_SEARCH_INFO {
    DHCP_SEARCH_INFO_TYPE SearchType;
#if defined(MIDL_PASS)
    [switch_is(SearchType), switch_type(DHCP_SEARCH_INFO_TYPE)]
    union _DHCP_CLIENT_SEARCH_UNION {
        [case(DhcpClientIpAddress)] DHCP_IP_ADDRESS ClientIpAddress;
        [case(DhcpClientHardwareAddress)] DHCP_CLIENT_UID ClientHardwareAddress;
        [case(DhcpClientName)] LPWSTR ClientName;
        [default] ;
    } SearchInfo;
#else
    union _DHCP_CLIENT_SEARCH_UNION {
        DHCP_IP_ADDRESS ClientIpAddress;
        DHCP_CLIENT_UID ClientHardwareAddress;
        LPWSTR ClientName;
    } SearchInfo;
#endif // MIDL_PASS
} DHCP_SEARCH_INFO, *LPDHCP_SEARCH_INFO;


typedef enum _DHCP_OPTION_SCOPE_TYPE {
    DhcpDefaultOptions,
    DhcpGlobalOptions,
    DhcpSubnetOptions,
    DhcpReservedOptions,
    DhcpMScopeOptions
} DHCP_OPTION_SCOPE_TYPE, *LPDHCP_OPTION_SCOPE_TYPE;

typedef struct _DHCP_RESERVED_SCOPE {
    DHCP_IP_ADDRESS ReservedIpAddress;
    DHCP_IP_ADDRESS ReservedIpSubnetAddress;
} DHCP_RESERVED_SCOPE, *LPDHCP_RESERVED_SCOPE;

typedef struct _DHCP_OPTION_SCOPE_INFO {
    DHCP_OPTION_SCOPE_TYPE ScopeType;
#if defined(MIDL_PASS)
    [switch_is(ScopeType), switch_type(DHCP_OPTION_SCOPE_TYPE)]
    union _DHCP_OPTION_SCOPE_UNION {
        [case(DhcpDefaultOptions)] ; // PVOID DefaultScopeInfo;
        [case(DhcpGlobalOptions)] ;  // PVOID GlobalScopeInfo;
        [case(DhcpSubnetOptions)] DHCP_IP_ADDRESS SubnetScopeInfo;
        [case(DhcpReservedOptions)] DHCP_RESERVED_SCOPE ReservedScopeInfo;
        [case(DhcpMScopeOptions)] LPWSTR MScopeInfo;
        [default] ;
    } ScopeInfo;
#else
    union _DHCP_OPTION_SCOPE_UNION {
        PVOID DefaultScopeInfo; // must be NULL
        PVOID GlobalScopeInfo;  // must be NULL
        DHCP_IP_ADDRESS SubnetScopeInfo;
        DHCP_RESERVED_SCOPE ReservedScopeInfo;
        LPWSTR  MScopeInfo;
    } ScopeInfo;
#endif // MIDL_PASS
} DHCP_OPTION_SCOPE_INFO, *LPDHCP_OPTION_SCOPE_INFO;


typedef struct _DHCP_HOST_INFO {
    DHCP_IP_ADDRESS IpAddress;      // minimum information always available
    LPWSTR NetBiosName;             // optional information
    LPWSTR HostName;                // optional information
} DHCP_HOST_INFO, *LPDHCP_HOST_INFO;


typedef struct _DHCP_CLIENT_INFO {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
} DHCP_CLIENT_INFO, *LPDHCP_CLIENT_INFO;

typedef struct _DHCP_CLIENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY, *LPDHCP_CLIENT_INFO_ARRAY;


typedef struct _DHCP_IP_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_IP_ADDRESS Elements; //array
} DHCP_IP_ARRAY, *LPDHCP_IP_ARRAY;


//
// Subnet State.
//
// Currently a Subnet scope can be Enabled or Disabled.
//
// If the state is Enabled State,
//  The server distributes address to the client, extends leases and
//  accepts releases.
//
// If the state is Disabled State,
//  The server does not distribute address to any new client, and does
//  extent (and sends NACK) old leases, but the servers accepts lease
//  releases.
//
// The idea behind this subnet state is, when the admin wants to stop
//  serving a subnet, he moves the state from Enbaled to Disabled so
//  that the clients from the subnets smoothly move to another servers
//  serving that subnet. When all or most of the clients move to
//  another server, the admin can delete the subnet without any force
//  if no client left in that subnet, otherwise the admin should use
//  full force to delete the subnet.
//

typedef enum _DHCP_SUBNET_STATE {
    DhcpSubnetEnabled = 0,
    DhcpSubnetDisabled,
    DhcpSubnetEnabledSwitched,    
    DhcpSubnetDisabledSwitched,
    DhcpSubnetInvalidState
} DHCP_SUBNET_STATE, *LPDHCP_SUBNET_STATE;

//
// Subnet related data structures.
//

typedef struct _DHCP_SUBNET_INFO {
    DHCP_IP_ADDRESS  SubnetAddress;
    DHCP_IP_MASK SubnetMask;
    LPWSTR SubnetName;
    LPWSTR SubnetComment;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE SubnetState;
} DHCP_SUBNET_INFO, *LPDHCP_SUBNET_INFO;

#define DHCP_SUBNET_INFO_VQ_FLAG_QUARANTINE    (1 << 0)        // Bit 0

typedef struct _DHCP_SUBNET_INFO_VQ{
    DHCP_IP_ADDRESS  SubnetAddress;
    DHCP_IP_MASK SubnetMask;
    LPWSTR SubnetName;
    LPWSTR SubnetComment;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE SubnetState;
    DWORD QuarantineOn;
    DWORD Reserved1;
    DWORD Reserved2;
    INT64 Reserved3;
    INT64 Reserved4;
} DHCP_SUBNET_INFO_VQ, *LPDHCP_SUBNET_INFO_VQ;


//
// DHCP Options related data structures.
//

typedef enum _DHCP_OPTION_DATA_TYPE {
    DhcpByteOption,
    DhcpWordOption,
    DhcpDWordOption,
    DhcpDWordDWordOption,
    DhcpIpAddressOption,
    DhcpStringDataOption,
    DhcpBinaryDataOption,
    DhcpEncapsulatedDataOption,
    DhcpIpv6AddressOption
} DHCP_OPTION_DATA_TYPE, *LPDHCP_OPTION_DATA_TYPE;


typedef struct _DHCP_OPTION_DATA_ELEMENT {
    DHCP_OPTION_DATA_TYPE    OptionType;
#if defined(MIDL_PASS)
    [switch_is(OptionType), switch_type(DHCP_OPTION_DATA_TYPE)]
    union _DHCP_OPTION_ELEMENT_UNION {
        [case(DhcpByteOption)] BYTE ByteOption;
        [case(DhcpWordOption)] WORD WordOption;
        [case(DhcpDWordOption)] DWORD DWordOption;
        [case(DhcpDWordDWordOption)] DWORD_DWORD DWordDWordOption;
        [case(DhcpIpAddressOption)] DHCP_IP_ADDRESS IpAddressOption;
        [case(DhcpStringDataOption)] LPWSTR StringDataOption;
        [case(DhcpBinaryDataOption)] DHCP_BINARY_DATA BinaryDataOption;
        [case(DhcpEncapsulatedDataOption)] DHCP_BINARY_DATA EncapsulatedDataOption;
        [case(DhcpIpv6AddressOption)] LPWSTR Ipv6AddressDataOption;		
        [default] ;
    } Element;
#else
    union _DHCP_OPTION_ELEMENT_UNION {
        BYTE ByteOption;
        WORD WordOption;
        DWORD DWordOption;
        DWORD_DWORD DWordDWordOption;
        DHCP_IP_ADDRESS IpAddressOption;
        LPWSTR StringDataOption;
        DHCP_BINARY_DATA BinaryDataOption;
        DHCP_BINARY_DATA EncapsulatedDataOption;
	 LPWSTR Ipv6AddressDataOption;	
                // for vendor specific information option.
    } Element;
#endif // MIDL_PASS
} DHCP_OPTION_DATA_ELEMENT, *LPDHCP_OPTION_DATA_ELEMENT;

typedef struct _DHCP_OPTION_DATA {
    DWORD NumElements; // number of option elements in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_DATA_ELEMENT Elements; //array
} DHCP_OPTION_DATA, *LPDHCP_OPTION_DATA;


typedef struct _DHCP_OPTION_VALUE {
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_DATA Value;
} DHCP_OPTION_VALUE, *LPDHCP_OPTION_VALUE;

typedef enum _DHCP_SUBNET_ELEMENT_TYPE_V5
{
	DhcpIpRanges, // The subnet element contains the range of DHCP-served IP addresses.
	DhcpSecondaryHosts, // The subnet element contains the IP addresses of secondary DHCP hosts available in the subnet.
	DhcpReservedIps, // The subnet element contains the individual reserved IP addresses for the subnet.,
	DhcpExcludedIpRanges, // The subnet element contains the IP addresses excluded from the range of DHCP-served addresses.,
	DhcpIpRangesDhcpOnly, // The subnet element contains the IP addresses served by DHCP to the subnet (as opposed to those served by other dynamic address services, such as BOOTP).,
	DhcpIpRangesDhcpBootp, // The subnet element contains the IP addresses served by both DHCP and BOOTP to the subnet.,
	DhcpIpRangesBootpOnly // The subnet element contains the IP addresses served by BOOTP to the subnet (specifically excluding DHCP-served addresses).
} DHCP_SUBNET_ELEMENT_TYPE,  *LPDHCP_SUBNET_ELEMENT_TYPE;

typedef struct _DHCP_BOOTP_IP_RANGE
{  
	DHCP_IP_ADDRESS StartAddress;
	DHCP_IP_ADDRESS EndAddress;
	ULONG BootpAllocated;
	ULONG MaxBootpAllowed;
} DHCP_BOOTP_IP_RANGE,  *LPDHCP_BOOT_IP_RANGE;

typedef struct _DHCP_IP_RESERVATION_V4
{
	DHCP_IP_ADDRESS ReservedIpAddress;
	DHCP_CLIENT_UID* ReservedForClient;
	BYTE bAllowedClientTypes;
} DHCP_IP_RESERVATION_V4,  *LPDHCP_IP_RESERVATION_V4;

typedef struct _DHCP_IP_RANGE
{
	DHCP_IP_ADDRESS StartAddress;
	DHCP_IP_ADDRESS EndAddress;
} DHCP_IP_RANGE,  *LPDHCP_IP_RANGE;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V5
{  
	DHCP_SUBNET_ELEMENT_TYPE ElementType;
	union
	{
		DHCP_BOOTP_IP_RANGE* IpRange;
		DHCP_HOST_INFO* SecondaryHost;
		DHCP_IP_RESERVATION_V4* ReservedIp;
		DHCP_IP_RANGE* ExcludeIpRange;
	} Element;
} DHCP_SUBNET_ELEMENT_DATA_V5,  *LPDHCP_SUBNET_ELEMENT_DATA_V5;

typedef enum _DHCP_FORCE_FLAG
{
  DhcpFullForce, // The operation deletes all client records affected by the element, and then deletes the element.,
  DhcpNoForce // The operation only deletes the subnet element, leaving intact any client records impacted by the change.
}DHCP_FORCE_FLAG,  *LPDHCP_FORCE_FLAG;

typedef struct _DHCP_IP_CLUSTER {
    DHCP_IP_ADDRESS ClusterAddress;
    DWORD ClusterMask;
} DHCP_IP_CLUSTER, *LPDHCP_IP_CLUSTER;

typedef DWORD DHCP_OPTION_ID;

typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;
typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 {
    DWORD NumElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V5 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5;

//################ Start of Structures specific to IPV6 ##########################

#if (WINVER >= 0x600)


typedef enum _DHCP_OPTION_TYPE {
    DhcpUnaryElementTypeOption,
    DhcpArrayTypeOption
} DHCP_OPTION_TYPE;

typedef struct _DHCP_OPTION {
    DHCP_OPTION_ID OptionID;
    LPWSTR OptionName;
    LPWSTR OptionComment;
    DHCP_OPTION_DATA DefaultValue;
    DHCP_OPTION_TYPE OptionType;
} DHCP_OPTION, *LPDHCP_OPTION;

typedef struct _DHCP_OPTION_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION Options;  // array
} DHCP_OPTION_ARRAY, *LPDHCP_OPTION_ARRAY;

//--

typedef     struct _DHCP_ALL_OPTIONS {
    DWORD Flags;         // must be zero -- not used..
    LPDHCP_OPTION_ARRAY NonVendorOptions;
    DWORD NumVendorOptions;

#if defined(MIDL_PASS)
    [size_is(NumVendorOptions)]
#endif
    struct                         /* anonymous */ {
        DHCP_OPTION Option;
        LPWSTR VendorName;
        LPWSTR ClassName;     // currently unused.
    }   *VendorOptions;
} DHCP_ALL_OPTIONS, *LPDHCP_ALL_OPTIONS;

typedef struct _DHCP_IPV6_ADDRESS {
	ULONGLONG HighOrderBits;
	ULONGLONG LowOrderBits;
} DHCP_IPV6_ADDRESS, *LPDHCP_IPV6_ADDRESS;

typedef struct _DHCP_RESERVED_SCOPE6 {
    DHCP_IPV6_ADDRESS ReservedIpAddress;
    DHCP_IPV6_ADDRESS ReservedIpSubnetAddress;
} DHCP_RESERVED_SCOPE6;

typedef enum _DHCP_OPTION_SCOPE_TYPE6 {
    DhcpDefaultOptions6,
    DhcpScopeOptions6,
    DhcpReservedOptions6,
    DhcpGlobalOptions6
} DHCP_OPTION_SCOPE_TYPE6;

typedef struct _DHCP_OPTION_SCOPE_INFO6 {
    DHCP_OPTION_SCOPE_TYPE6 ScopeType;
#if defined(MIDL_PASS)
    [switch_is(ScopeType), switch_type(DHCP_OPTION_SCOPE_TYPE6)]
    union _DHCP_OPTION_SCOPE_UNION6 {
        [case(DhcpDefaultOptions6)] ; // PVOID DefaultScopeInfo;
        [case(DhcpScopeOptions6)] DHCP_IPV6_ADDRESS SubnetScopeInfo;
        [case(DhcpReservedOptions6)] DHCP_RESERVED_SCOPE6 ReservedScopeInfo;
        [default] ;
    } ScopeInfo;
#else
    union _DHCP_OPTION_SCOPE_UNION6 {
        PVOID DefaultScopeInfo; // must be NULL
        DHCP_IPV6_ADDRESS SubnetScopeInfo;
        DHCP_RESERVED_SCOPE6 ReservedScopeInfo;
    } ScopeInfo;
#endif // MIDL_PASS
} DHCP_OPTION_SCOPE_INFO6, *LPDHCP_OPTION_SCOPE_INFO6;


typedef struct _DHCP_OPTION_VALUE_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_VALUE Values;  // array
} DHCP_OPTION_VALUE_ARRAY, *LPDHCP_OPTION_VALUE_ARRAY;


typedef     struct _DHCP_ALL_OPTION_VALUES {
    DWORD Flags;         // must be zero -- not used
    DWORD  NumElements;   // the # of elements in array of Options below..
#if     defined(MIDL_PASS)
    [size_is(NumElements)]
#endif  MIDL_PASS
    struct                         /* anonymous */ {
        LPWSTR ClassName;     // for each user class (NULL if none exists)
        LPWSTR  VendorName;    // for each vendor class (NULL if none exists)
        BOOL IsVendor;      // is this set of options vendor specific?
        LPDHCP_OPTION_VALUE_ARRAY  OptionsArray;  // list of options for the above pair: (vendor,user)
    }   *Options;       // for each vendor/user class pair, one element in this array..
} DHCP_ALL_OPTION_VALUES, *LPDHCP_ALL_OPTION_VALUES;

//--

typedef struct _DHCP_SUBNET_INFO_V6
{
    DHCP_IPV6_ADDRESS	SubnetAddress;
    ULONG	Prefix;
    USHORT	Preference;	
    LPWSTR	SubnetName;
    LPWSTR	SubnetComment;
    DWORD	State;
    DWORD	ScopeId;
} DHCP_SUBNET_INFO_V6,*LPDHCP_SUBNET_INFO_V6;

typedef struct _DHCPV6_IP_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_IPV6_ADDRESS Elements; //array
} DHCPV6_IP_ARRAY, *LPDHCPV6_IP_ARRAY;

//--

typedef enum _DHCP_SUBNET_ELEMENT_TYPE_V6 {
    Dhcpv6IpRanges,
    Dhcpv6ReservedIps,
    Dhcpv6ExcludedIpRanges
} DHCP_SUBNET_ELEMENT_TYPE_V6;

typedef struct _DHCP_IP_RANGE_V6 {
    DHCP_IPV6_ADDRESS StartAddress;
    DHCP_IPV6_ADDRESS EndAddress;
} DHCP_IP_RANGE_V6, *LPDHCP_IP_RANGE_V6;

typedef struct _DHCP_IP_RESERVATION_V6 {
    DHCP_IPV6_ADDRESS  ReservedIpAddress;
    DHCP_CLIENT_UID *ReservedForClient;
    DWORD InterfaceId;
} DHCP_IP_RESERVATION_V6, *LPDHCP_IP_RESERVATION_V6;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V6 {
    DHCP_SUBNET_ELEMENT_TYPE_V6 ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE_V6)]
    union _DHCP_SUBNET_ELEMENT_UNION_V6 {
        [case(Dhcpv6IpRanges)] DHCP_IP_RANGE_V6 *IpRange;
        [case(Dhcpv6ReservedIps)] DHCP_IP_RESERVATION_V6 *ReservedIp;
        [case(Dhcpv6ExcludedIpRanges)] DHCP_IP_RANGE_V6 *ExcludeIpRange;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION_V6 {
	DHCP_IP_RANGE_V6 *IpRange;
        DHCP_IP_RESERVATION_V6 *ReservedIp;
        DHCP_IP_RANGE_V6 *ExcludeIpRange;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA_V6, *LPDHCP_SUBNET_ELEMENT_DATA_V6;
    

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V6 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_SUBNET_ELEMENT_DATA_V6 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V6, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V6;

//--

typedef DHCP_IPV6_ADDRESS DHCP_RESUME_IPV6_HANDLE;

typedef struct _DHCP_HOST_INFO_V6 {
    DHCP_IPV6_ADDRESS IpAddress;      // minimum information always available
    LPWSTR NetBiosName;             // optional information
    LPWSTR HostName;                // optional information
} DHCP_HOST_INFO_V6, *LPDHCP_HOST_INFO_V6;

typedef struct _DHCP_CLIENT_INFO_V6 {
    DHCP_IPV6_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_CLIENT_UID ClientDUID; 
    DWORD AddressType;			// IANA or IATA
    DWORD IAID;				// IAID Associated with the address.
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientValidLeaseExpires;    // UTC time in FILE_TIME format.
    DATE_TIME ClientPrefLeaseExpires;     // UTC time in FILE_TIME format.
    DHCP_HOST_INFO_V6 OwnerHost;          // host that distributed this IP address.
} DHCP_CLIENT_INFO_V6, *LPDHCP_CLIENT_INFO_V6;

typedef struct _DHCP_CLIENT_INFO_ARRAY_V6 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_CLIENT_INFO_V6 *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY_V6, *LPDHCP_CLIENT_INFO_ARRAY_V6;

#endif
//################ End of Structures specific to IPV6   ##########################

#define ERROR_DHCP_OPTION_NOT_PRESENT         20010
#define ERROR_DHCP_SUBNET_EXISTS              20052
#define ERROR_DDS_SERVER_ALREADY_EXISTS       20079
#define ERROR_DDS_SERVER_DOES_NOT_EXIST       20080



DWORD DHCP_API_FUNCTION
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    );

DWORD DHCP_API_FUNCTION
DhcpSetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY BindElementInfo
);

DWORD DHCP_API_FUNCTION
DhcpGetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY *BindElementsInfo
);

DWORD DHCP_API_FUNCTION
DhcpCreateClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *SearchInfo,
    LPDHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClients(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );


DWORD DHCP_API_FUNCTION
DhcpEnumSubnets(
    DHCP_CONST WCHAR    *ServerIpAddress,
    DHCP_RESUME_HANDLE  *ResumeHandle,
    DWORD                PreferredMaximum,
    LPDHCP_IP_ARRAY     *EnumInfo,
    DWORD               *ElementsRead,
    DWORD               *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpGetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO * SubnetInfo
    );


DWORD DHCP_API_FUNCTION
DhcpGetOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO *ScopeInfo,
    LPDHCP_OPTION_VALUE *OptionValue
    );

VOID DHCP_API_FUNCTION
DhcpRpcFreeMemory(
    PVOID BufferPointer
    );

DWORD DHCP_API_FUNCTION
DhcpCreateSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );


DWORD DHCP_API_FUNCTION
DhcpDeleteSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpSetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );

//DOC DhcpDsInit must be called exactly once per process.. this initializes the
//DOC memory and other structures for this process.  This initializes some DS
//DOC object handles (memory), and hence is slow as this has to read from DS.
DWORD DHCP_API_FUNCTION
DhcpDsInit(
    VOID
);

//DOC DhcpDsCleanup undoes the effect of any DhcpDsInit.  This function should be
//DOC called exactly once for each process, and only at termination.  Note that
//DOC it is safe to call this function even if DhcpDsInit does not succeed.
VOID DHCP_API_FUNCTION
DhcpDsCleanup(
    VOID
);

//DOC DhcpAddServer tries to add a new server to the existing list of servers in
//DOC the DS. The function returns error if the Server already exists in the DS.
//DOC The function tries to upload the server configuration to the DS..
//DOC This is a SLOW call.  Currently, the DsLocation and DsLocType are not valid
//DOC fields in the NewServer and they'd be ignored. Version must be zero.
DWORD DHCP_API_FUNCTION
DhcpAddServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpDeleteServer tries to delete the server from DS. It is an error if the
//DOC server does not already exist.  This also deletes any objects related to
//DOC this server in the DS (like subnet, reservations etc.).
DWORD DHCP_API_FUNCTION
DhcpDeleteServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpEnumServers enumerates the list of servers found in the DS.  If the DS
//DOC is not accessible, it returns an error. The only currently used parameter
//DOC is the out parameter Servers.  This is a SLOW call.
DWORD DHCP_API_FUNCTION
DhcpEnumServers(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,    // output servers list
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

DWORD DHCP_API_FUNCTION                           // Status code
DhcpServerRedoAuthorization(                      // retry the rogue server stuff
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved     // reserved for future
);

DWORD DHCP_API_FUNCTION
DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;

DWORD DHCP_API_FUNCTION                           // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValueV5(                             // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;

DWORD DHCP_API_FUNCTION
DhcpGetSubnetInfoVQ(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO_VQ * SubnetInfo
    );


DWORD DHCP_API_FUNCTION
DhcpCreateSubnetVQ(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO_VQ * SubnetInfo
    );


DWORD DHCP_API_FUNCTION
DhcpSetSubnetInfoVQ(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO_VQ * SubnetInfo
    );

//################ Start of Functions specific to IPV6 ##########################

#if (WINVER >= 0x600)

// Option Functions

DWORD DHCP_API_FUNCTION
DhcpCreateOptionV6(
    IN	LPWSTR ServerIpAddress,
    IN	DWORD Flags,
    IN	DHCP_OPTION_ID OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN	LPWSTR ClassName,
    IN	LPWSTR VendorName,
    IN	LPDHCP_OPTION OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumOptionsV6(                                
    IN      LPWSTR ServerIpAddress,
    IN      DWORD Flags,
    IN      LPWSTR ClassName,
    IN      LPWSTR VendorName,
    IN OUT  DHCP_RESUME_HANDLE *ResumeHandle,   // must be zero intially and then never touched
    IN      DWORD PreferredMaximum, 		// max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY *Options,       // fill this option array
    OUT     DWORD *OptionsRead,   		// fill in the # of options read
    OUT     DWORD *OptionsTotal   		// fill in the total # here
);

DWORD DHCP_API_FUNCTION
DhcpRemoveOptionV6(                               
    IN	LPWSTR ServerIpAddress,
    IN	DWORD Flags,
    IN	DHCP_OPTION_ID OptionID,
    IN	LPWSTR ClassName,
    IN	LPWSTR VendorName
);


// All Option Functions 

DWORD DHCP_API_FUNCTION
DhcpGetAllOptionsV6(
    IN	LPWSTR ServerIpAddress,
    IN	DWORD Flags,         // what do we care about vendor/classid stuff?
    OUT	LPDHCP_ALL_OPTIONS *OptionStruct   // fill the fields of this structure
);

DWORD DHCP_API_FUNCTION
DhcpGetAllOptionValuesV6(
    LPWSTR ServerIpAddress,
    IN DWORD Flags,
    IN LPDHCP_OPTION_SCOPE_INFO6 ScopeInfo,
    OUT LPDHCP_ALL_OPTION_VALUES *Values
);

//Option Info Functions

DWORD DHCP_API_FUNCTION
DhcpGetOptionInfoV6(
    LPWSTR ServerIpAddress,
    IN DWORD Flags,
    IN DHCP_OPTION_ID OptionID,
    LPWSTR ClassName,
    LPWSTR  VendorName,
    OUT LPDHCP_OPTION *OptionInfo     // allocate memory using MIDL functions
);

DWORD DHCP_API_FUNCTION
DhcpSetOptionInfoV6(
    LPWSTR ServerIpAddress,
    DWORD Flags,
    DHCP_OPTION_ID OptionID,
    LPWSTR ClassName,
    LPWSTR VendorName,
    IN LPDHCP_OPTION OptionInfo
);

//Option Value Functions

DWORD DHCP_API_FUNCTION
DhcpSetOptionValueV6(                             
    LPWSTR ServerIpAddress,
    IN DWORD Flags,
    IN DHCP_OPTION_ID OptionId,
    LPWSTR ClassName,
    LPWSTR VendorName,
    IN LPDHCP_OPTION_SCOPE_INFO6 ScopeInfo,
    IN LPDHCP_OPTION_DATA OptionValue
);    

DWORD DHCP_API_FUNCTION
DhcpEnumOptionValuesV6(
    DHCP_CONST WCHAR *ServerIpAddress,
    DWORD Flags,
    LPWSTR ClassName,
    LPWSTR VendorName,
    LPDHCP_OPTION_SCOPE_INFO6 ScopeInfo,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveOptionValueV6(
    LPWSTR ServerIpAddress,
    IN DWORD Flags,
    IN  DHCP_OPTION_ID OptionID,
    LPWSTR ClassName,
    LPWSTR  VendorName,
    IN LPDHCP_OPTION_SCOPE_INFO6 ScopeInfo
);

//Subnet Functions

DWORD DHCP_API_FUNCTION 
DhcpCreateSubnetV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO_V6 SubnetInfo
    );

DWORD DHCP_API_FUNCTION 
DhcpDeleteSubnetV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
);

DWORD DHCP_API_FUNCTION 
DhcpEnumSubnetsV6(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCPV6_IP_ARRAY *EnumInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );


//Subnet Element Functions

DWORD DHCP_API_FUNCTION 
DhcpAddSubnetElementV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA_V6 AddElementInfo
    );

DWORD DHCP_API_FUNCTION 
DhcpRemoveSubnetElementV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA_V6 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );
    
DWORD DHCP_API_FUNCTION 
DhcpEnumSubnetElementsV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE_V6 EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V6 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

//Subnet Info Function

DWORD DHCP_API_FUNCTION
DhcpGetSubnetInfoV6(
    LPWSTR ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO_V6 *SubnetInfo
    );


#define SCOPE_STATE_ENABLED     DhcpSubnetEnabled
#define SCOPE_STATE_DISABLED    DhcpSubnetDisabled

//Subnet Client Function

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClientsV6(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IPV6_ADDRESS SubnetAddress,
    DHCP_RESUME_IPV6_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V6 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

#endif
//################ End of Functions specific to IPV6 ############################

#ifdef __cplusplus
}
#endif

#endif // _DHCPSAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DIFxAPI.h ===
#ifndef _INC_DIFXAPI_
#define _INC_DIFXAPI_
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Abstract:

    Public header file for Windows (Server 2000,XP,Server 2003, Longhorn) Setup and Device Installer Library.

--*/

#if _MSC_VER > 1000
#pragma once
#endif


//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_DIFXAPI_)
#define WINDIFXAPI DECLSPEC_IMPORT
#else
#define WINDIFXAPI
#endif

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _DIFXAPI_VERSION_
#define _DIFXAPI_VERSION_ 0x0200
#endif

//
// DIFX specific ERROR CODES
// We have bit 29 set, which is reserved for application-defined error codes and
// does not conflict with system error codes.
// 

#define ERROR_DEPENDENT_APPLICATIONS_EXIST  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x300)
#define ERROR_NO_DEVICE_ID                  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x301)

//
//  The driver package is not currently in the driver store
//
#define ERROR_DRIVER_PACKAGE_NOT_IN_STORE   (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x302)
#define ERROR_MISSING_FILE                  (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x303)

//
// Catalog referenced in the INF is invalid or could not be found
//
#define ERROR_INVALID_CATALOG_DATA          (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR|0x304)

//
// Other error codes
//
#ifndef ERROR_NO_SUCH_DEVINST
#define ERROR_NO_SUCH_DEVINST               0xE000020B
#endif

#ifndef ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH
#define ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH 0xE0000244
#endif


//
// Define the FLAGS
//

//
// Flag: DRIVER_PACKAGE_REPAIR
//
// Preinstall: if the driver store entry already exists, overwrite it.
// Install: overwrites existing driver store entry and reinstall driver 
//
#define DRIVER_PACKAGE_REPAIR                           0x00000001

//
// Flag: DRIVER_PACKAGE_SILENT 
//
// The system will not pop-up any UI to user, for example, signing UI. 
// Instead, in cases where a UI would be required to continue the install,
// the function will fail silently and return an appropriate error code.
//
#define DRIVER_PACKAGE_SILENT                           0x00000002

//
// Flag: DRIVER_PACKAGE_FORCE
//
// Install:  Forces an install even if the driver to be installed is not better 
//           than the current one.
// Uninstall: Forces an uninstall disregarding the App to driver reference count.
//
#define DRIVER_PACKAGE_FORCE                            0x00000004

//
// Flag: DRIVER_PACKAGE_ONLY_IF_DEVICE_PRESENT
//
// Preinstall/Install: only preinstalls/installs the driver package if there is 
//                     a device present. 
//
#define DRIVER_PACKAGE_ONLY_IF_DEVICE_PRESENT           0x00000008

//
// Flag: DRIVER_PACKAGE_LEGACY_MODE
//
// By default, DFXLIB requires all driver packages to be signed and that all files referenced
// in the INF for copying to be present. Driver Packages who need this flag to install won't install
// on the latest version of Windows. 
// Unsigned driver packages are accepted, but might be blocked by the OS itself or the unsigned 
// driver dialog might pop-up, depending on the policy settings of the given OS.
//
#define DRIVER_PACKAGE_LEGACY_MODE                      0x00000010

//
// Flag: DRIVER_PACKAGE_DELETE_FILES
//
// Uninstall: Makes a BEST EFFORT to delete all files that were copied during install
// as described by the INF file. Before deleting, the file will be binary compared to
// the file in the driver store. Still, this file could still be needed by another 
// program on the machine. If you decide to use this flag, make sure you understand
// how your files will be used.
//
#define DRIVER_PACKAGE_DELETE_FILES                   0x00000020

WINDIFXAPI
DWORD
WINAPI
DriverPackagePreinstallW(
    __in	PCWSTR DriverPackageInfPath,
    __in 	DWORD 	Flags
    );

WINDIFXAPI
DWORD
WINAPI
DriverPackagePreinstallA(
    __in	PCSTR DriverPackageInfPath,
    __in 	DWORD 	Flags
    );

#ifdef UNICODE
#define DriverPackagePreinstall DriverPackagePreinstallW
#else
#define DriverPackagePreinstall DriverPackagePreinstallA
#endif

//
// INSTALL Driver Package
//


//
// General info about the installer of the driver package
//
typedef struct
{
    PWSTR pApplicationId;
    PWSTR pDisplayName;
    PWSTR pProductName;
    PWSTR pMfgName;
} INSTALLERINFO_W, * PINSTALLERINFO_W;

typedef const PINSTALLERINFO_W PCINSTALLERINFO_W;

typedef struct
{
    PSTR pApplicationId;
    PSTR pDisplayName;
    PSTR pProductName;
    PSTR pMfgName;
} INSTALLERINFO_A, * PINSTALLERINFO_A;

typedef const PINSTALLERINFO_A PCINSTALLERINFO_A;

#ifdef UNICODE
	typedef INSTALLERINFO_W INSTALLERINFO;
	typedef PINSTALLERINFO_W PINSTALLERINFO;
	typedef PCINSTALLERINFO_W PCINSTALLERINFO;
#else
	typedef INSTALLERINFO_A INSTALLERINFO;
	typedef PINSTALLERINFO_A PINSTALLERINFO;
	typedef PCINSTALLERINFO_A PCINSTALLERINFO;
#endif

WINDIFXAPI
DWORD
WINAPI
DriverPackageInstallW( 
    __in PCWSTR DriverPackageInfPath, 
    __in DWORD Flags,
    __in_opt PCINSTALLERINFO_W pInstallerInfo,
    __out BOOL * pNeedReboot 
    );

WINDIFXAPI
DWORD
WINAPI
DriverPackageInstallA( 
    __in	PCSTR 		DriverPackageInfPath, 
    __in	DWORD 		Flags,
    __in_opt PCINSTALLERINFO_A	pInstallerInfo,
    __out	BOOL * 		pNeedReboot 
    );

#ifdef UNICODE
#define DriverPackageInstall DriverPackageInstallW
#else
#define DriverPackageInstall DriverPackageInstallA
#endif

//
// Uninstall Driver Package
//

WINDIFXAPI
DWORD
WINAPI
DriverPackageUninstallW(  
    __in    PCWSTR DriverPackageInfPath,
    __in    DWORD 	Flags,
    __in_opt  PCINSTALLERINFO_W pInstallerInfo,
    __out   BOOL * pNeedReboot    
    );

WINDIFXAPI
DWORD
WINAPI
DriverPackageUninstallA(
    __in    PCSTR DriverPackageInfPath,
    __in    DWORD 	Flags,
    __in_opt  PCINSTALLERINFO_A pInstallerInfo,
    __out   BOOL * pNeedReboot    
    );

#ifdef UNICODE
#define DriverPackageUninstall DriverPackageUninstallW
#else
#define DriverPackageUninstall DriverPackageUninstallA
#endif

//
// Get Driver Package path
//
WINDIFXAPI
DWORD 
WINAPI
DriverPackageGetPathW(
    __in PCWSTR DriverPackageInfPath,
    __out_ecount_opt(*pNumOfChars)	PWSTR pDestInfPath, 
    __inout DWORD * pNumOfChars
    );

WINDIFXAPI
DWORD
WINAPI
DriverPackageGetPathA(
    __in PCSTR DriverPackageInfPath,
    __out_ecount_opt(*pNumOfChars)	PSTR pDestInfPath, 
    __inout DWORD * pNumOfChars
    );

#ifdef UNICODE
#define DriverPackageGetPath DriverPackageGetPathW
#else
#define DriverPackageGetPath DriverPackageGetPathA
#endif

typedef enum
{
	DIFXAPI_SUCCESS = 0,    // Successes
	DIFXAPI_INFO = 1,		// Basic logging information that should always be shown
	DIFXAPI_WARNING = 2,	// Warnings
	DIFXAPI_ERROR = 3		// Errors
} DIFXAPI_LOG;


typedef void (WINAPI * DIFXLOGCALLBACK_W)( DIFXAPI_LOG Event, DWORD Error, PCWSTR EventDescription, PVOID CallbackContext);
typedef void (WINAPI * DIFXLOGCALLBACK_A)( DIFXAPI_LOG Event, DWORD Error, PCSTR EventDescription, PVOID CallbackContext);

VOID
WINAPI
SetDifxLogCallbackW( 
    __in DIFXLOGCALLBACK_W LogCallback,
    __in PVOID CallbackContext
    );

VOID
WINAPI
SetDifxLogCallbackA( 
    __in DIFXLOGCALLBACK_A LogCallback,
    __in PVOID CallbackContext
    );

#ifdef UNICODE
    #define DIFLOGCALLBACK DIFXLOGCALLBACK_W
    #define SetDifxLogCallback SetDifxLogCallbackW
#else
    #define DIFLOGCALLBACK DIFXLOGCALLBACK_A
    #define SetDifxLogCallback SetDifxLogCallbackA
#endif




typedef void ( __cdecl* DIFXAPILOGCALLBACK_W)( DIFXAPI_LOG Event, DWORD Error, PCWSTR EventDescription, PVOID CallbackContext);
typedef void ( __cdecl* DIFXAPILOGCALLBACK_A)( DIFXAPI_LOG Event, DWORD Error, PCSTR EventDescription, PVOID CallbackContext);

WINDIFXAPI
VOID
WINAPI
DIFXAPISetLogCallbackW( 
    __in_opt DIFXAPILOGCALLBACK_W LogCallback,
    __in_opt PVOID CallbackContext
    );

WINDIFXAPI
VOID
WINAPI
DIFXAPISetLogCallbackA( 
    __in_opt DIFXAPILOGCALLBACK_A LogCallback,
    __in_opt PVOID CallbackContext
    );

#ifdef UNICODE
    #define DIFXAPILOGCALLBACK DIFXAPILOGCALLBACK_W
    #define DIFXAPISetLogCallback DIFXAPISetLogCallbackW
#else
    #define DIFXAPILOGCALLBACK DIFXAPILOGCALLBACK_A
    #define DIFXAPISetLogCallback DIFXAPISetLogCallbackA
#endif

#ifdef  __cplusplus
}
#endif

#endif //_INC_DIFXAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DHtmled.h ===
/* Microsoft Corporation Copyright 1999 */
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Aug 06 10:08:26 1998
 */
/* Compiler settings for dhtmled.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dhtmled_h__
#define __dhtmled_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDEGetBlockFmtNamesParam_FWD_DEFINED__
#define __IDEGetBlockFmtNamesParam_FWD_DEFINED__
typedef interface IDEGetBlockFmtNamesParam IDEGetBlockFmtNamesParam;
#endif 	/* __IDEGetBlockFmtNamesParam_FWD_DEFINED__ */


#ifndef __IDHTMLSafe_FWD_DEFINED__
#define __IDHTMLSafe_FWD_DEFINED__
typedef interface IDHTMLSafe IDHTMLSafe;
#endif 	/* __IDHTMLSafe_FWD_DEFINED__ */


#ifndef __IDHTMLEdit_FWD_DEFINED__
#define __IDHTMLEdit_FWD_DEFINED__
typedef interface IDHTMLEdit IDHTMLEdit;
#endif 	/* __IDHTMLEdit_FWD_DEFINED__ */


#ifndef __IDEInsertTableParam_FWD_DEFINED__
#define __IDEInsertTableParam_FWD_DEFINED__
typedef interface IDEInsertTableParam IDEInsertTableParam;
#endif 	/* __IDEInsertTableParam_FWD_DEFINED__ */


#ifndef ___DHTMLSafeEvents_FWD_DEFINED__
#define ___DHTMLSafeEvents_FWD_DEFINED__
typedef interface _DHTMLSafeEvents _DHTMLSafeEvents;
#endif 	/* ___DHTMLSafeEvents_FWD_DEFINED__ */


#ifndef ___DHTMLEditEvents_FWD_DEFINED__
#define ___DHTMLEditEvents_FWD_DEFINED__
typedef interface _DHTMLEditEvents _DHTMLEditEvents;
#endif 	/* ___DHTMLEditEvents_FWD_DEFINED__ */


#ifndef __DHTMLEdit_FWD_DEFINED__
#define __DHTMLEdit_FWD_DEFINED__

#ifdef __cplusplus
typedef class DHTMLEdit DHTMLEdit;
#else
typedef struct DHTMLEdit DHTMLEdit;
#endif /* __cplusplus */

#endif 	/* __DHTMLEdit_FWD_DEFINED__ */


#ifndef __DHTMLSafe_FWD_DEFINED__
#define __DHTMLSafe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DHTMLSafe DHTMLSafe;
#else
typedef struct DHTMLSafe DHTMLSafe;
#endif /* __cplusplus */

#endif 	/* __DHTMLSafe_FWD_DEFINED__ */


#ifndef __DEInsertTableParam_FWD_DEFINED__
#define __DEInsertTableParam_FWD_DEFINED__

#ifdef __cplusplus
typedef class DEInsertTableParam DEInsertTableParam;
#else
typedef struct DEInsertTableParam DEInsertTableParam;
#endif /* __cplusplus */

#endif 	/* __DEInsertTableParam_FWD_DEFINED__ */


#ifndef __DEGetBlockFmtNamesParam_FWD_DEFINED__
#define __DEGetBlockFmtNamesParam_FWD_DEFINED__

#ifdef __cplusplus
typedef class DEGetBlockFmtNamesParam DEGetBlockFmtNamesParam;
#else
typedef struct DEGetBlockFmtNamesParam DEGetBlockFmtNamesParam;
#endif /* __cplusplus */

#endif 	/* __DEGetBlockFmtNamesParam_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "docobj.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dhtmled_0000
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



#define DE_E_INVALIDARG                E_INVALIDARG
#define DE_E_PATH_NOT_FOUND            HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)
#define DE_E_FILE_NOT_FOUND            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
#define DE_E_UNEXPECTED                E_UNEXPECTED
#define DE_E_DISK_FULL                 HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL)
#define DE_E_NOTSUPPORTED              OLECMDERR_E_NOTSUPPORTED
#define DE_E_ACCESS_DENIED             HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)

#define DE_E_URL_SYNTAX                MK_E_SYNTAX
#define DE_E_INVALID_URL               0x800C0002
#define DE_E_NO_SESSION                0x800C0003
#define DE_E_CANNOT_CONNECT            0x800C0004
#define DE_E_RESOURCE_NOT_FOUND        0x800C0005
#define DE_E_OBJECT_NOT_FOUND          0x800C0006
#define DE_E_DATA_NOT_AVAILABLE        0x800C0007
#define DE_E_DOWNLOAD_FAILURE          0x800C0008
#define DE_E_AUTHENTICATION_REQUIRED   0x800C0009
#define DE_E_NO_VALID_MEDIA            0x800C000A
#define DE_E_CONNECTION_TIMEOUT        0x800C000B
#define DE_E_INVALID_REQUEST           0x800C000C
#define DE_E_UNKNOWN_PROTOCOL          0x800C000D
#define DE_E_SECURITY_PROBLEM          0x800C000E
#define DE_E_CANNOT_LOAD_DATA          0x800C000F
#define DE_E_CANNOT_INSTANTIATE_OBJECT 0x800C0010
#define DE_E_REDIRECT_FAILED           0x800C0014
#define DE_E_REDIRECT_TO_DIR           0x800C0015
#define DE_E_CANNOT_LOCK_REQUEST       0x800C0016

#define DE_E_FILTER_FRAMESET           0x80100001
#define DE_E_FILTER_SERVERSCRIPT       0x80100002
#define DE_E_FILTER_MULTIPLETAGS       0x80100004
#define DE_E_FILTER_SCRIPTLISTING      0x80100008
#define DE_E_FILTER_SCRIPTLABEL        0x80100010
#define DE_E_FILTER_SCRIPTTEXTAREA     0x80100020
#define DE_E_FILTER_SCRIPTSELECT       0x80100040


extern RPC_IF_HANDLE __MIDL_itf_dhtmled_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dhtmled_0000_v0_0_s_ifspec;


#ifndef __DHTMLEDLib_LIBRARY_DEFINED__
#define __DHTMLEDLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DHTMLEDLib
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [helpstring][uuid] */ 
enum DHTMLEDITCMDID
    {	DECMD_BOLD	= 5000,
	DECMD_COPY	= 5002,
	DECMD_CUT	= DECMD_COPY + 1,
	DECMD_DELETE	= DECMD_CUT + 1,
	DECMD_DELETECELLS	= DECMD_DELETE + 1,
	DECMD_DELETECOLS	= DECMD_DELETECELLS + 1,
	DECMD_DELETEROWS	= DECMD_DELETECOLS + 1,
	DECMD_FINDTEXT	= DECMD_DELETEROWS + 1,
	DECMD_FONT	= DECMD_FINDTEXT + 1,
	DECMD_GETBACKCOLOR	= DECMD_FONT + 1,
	DECMD_GETBLOCKFMT	= DECMD_GETBACKCOLOR + 1,
	DECMD_GETBLOCKFMTNAMES	= DECMD_GETBLOCKFMT + 1,
	DECMD_GETFONTNAME	= DECMD_GETBLOCKFMTNAMES + 1,
	DECMD_GETFONTSIZE	= DECMD_GETFONTNAME + 1,
	DECMD_GETFORECOLOR	= DECMD_GETFONTSIZE + 1,
	DECMD_HYPERLINK	= DECMD_GETFORECOLOR + 1,
	DECMD_IMAGE	= DECMD_HYPERLINK + 1,
	DECMD_INDENT	= DECMD_IMAGE + 1,
	DECMD_INSERTCELL	= DECMD_INDENT + 1,
	DECMD_INSERTCOL	= DECMD_INSERTCELL + 1,
	DECMD_INSERTROW	= DECMD_INSERTCOL + 1,
	DECMD_INSERTTABLE	= DECMD_INSERTROW + 1,
	DECMD_ITALIC	= DECMD_INSERTTABLE + 1,
	DECMD_JUSTIFYCENTER	= DECMD_ITALIC + 1,
	DECMD_JUSTIFYLEFT	= DECMD_JUSTIFYCENTER + 1,
	DECMD_JUSTIFYRIGHT	= DECMD_JUSTIFYLEFT + 1,
	DECMD_LOCK_ELEMENT	= DECMD_JUSTIFYRIGHT + 1,
	DECMD_MAKE_ABSOLUTE	= DECMD_LOCK_ELEMENT + 1,
	DECMD_MERGECELLS	= DECMD_MAKE_ABSOLUTE + 1,
	DECMD_ORDERLIST	= DECMD_MERGECELLS + 1,
	DECMD_OUTDENT	= DECMD_ORDERLIST + 1,
	DECMD_PASTE	= DECMD_OUTDENT + 1,
	DECMD_REDO	= DECMD_PASTE + 1,
	DECMD_REMOVEFORMAT	= DECMD_REDO + 1,
	DECMD_SELECTALL	= DECMD_REMOVEFORMAT + 1,
	DECMD_SEND_BACKWARD	= DECMD_SELECTALL + 1,
	DECMD_BRING_FORWARD	= DECMD_SEND_BACKWARD + 1,
	DECMD_SEND_BELOW_TEXT	= DECMD_BRING_FORWARD + 1,
	DECMD_BRING_ABOVE_TEXT	= DECMD_SEND_BELOW_TEXT + 1,
	DECMD_SEND_TO_BACK	= DECMD_BRING_ABOVE_TEXT + 1,
	DECMD_BRING_TO_FRONT	= DECMD_SEND_TO_BACK + 1,
	DECMD_SETBACKCOLOR	= DECMD_BRING_TO_FRONT + 1,
	DECMD_SETBLOCKFMT	= DECMD_SETBACKCOLOR + 1,
	DECMD_SETFONTNAME	= DECMD_SETBLOCKFMT + 1,
	DECMD_SETFONTSIZE	= DECMD_SETFONTNAME + 1,
	DECMD_SETFORECOLOR	= DECMD_SETFONTSIZE + 1,
	DECMD_SPLITCELL	= DECMD_SETFORECOLOR + 1,
	DECMD_UNDERLINE	= DECMD_SPLITCELL + 1,
	DECMD_UNDO	= DECMD_UNDERLINE + 1,
	DECMD_UNLINK	= DECMD_UNDO + 1,
	DECMD_UNORDERLIST	= DECMD_UNLINK + 1,
	DECMD_PROPERTIES	= DECMD_UNORDERLIST + 1
    }	DHTMLEDITCMDID;

typedef /* [helpstring][uuid] */ 
enum DHTMLEDITCMDF
    {	DECMDF_NOTSUPPORTED	= 0,
	DECMDF_DISABLED	= 0x1,
	DECMDF_ENABLED	= 0x3,
	DECMDF_LATCHED	= 0x7,
	DECMDF_NINCHED	= 0xb
    }	DHTMLEDITCMDF;

typedef /* [helpstring][uuid] */ 
enum DHTMLEDITAPPEARANCE
    {	DEAPPEARANCE_FLAT	= 0,
	DEAPPEARANCE_3D	= 0x1
    }	DHTMLEDITAPPEARANCE;


EXTERN_C const IID LIBID_DHTMLEDLib;

#ifndef __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__
#define __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDEGetBlockFmtNamesParam
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDEGetBlockFmtNamesParam;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D91090D-B955-11D1-ADC5-006008A5848C")
    IDEGetBlockFmtNamesParam : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Names( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Names( 
            /* [in] */ VARIANT __RPC_FAR *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDEGetBlockFmtNamesParamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Names )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Names )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *newVal);
        
        END_INTERFACE
    } IDEGetBlockFmtNamesParamVtbl;

    interface IDEGetBlockFmtNamesParam
    {
        CONST_VTBL struct IDEGetBlockFmtNamesParamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDEGetBlockFmtNamesParam_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDEGetBlockFmtNamesParam_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDEGetBlockFmtNamesParam_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDEGetBlockFmtNamesParam_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDEGetBlockFmtNamesParam_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDEGetBlockFmtNamesParam_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDEGetBlockFmtNamesParam_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDEGetBlockFmtNamesParam_get_Names(This,pVal)	\
    (This)->lpVtbl -> get_Names(This,pVal)

#define IDEGetBlockFmtNamesParam_put_Names(This,newVal)	\
    (This)->lpVtbl -> put_Names(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEGetBlockFmtNamesParam_get_Names_Proxy( 
    IDEGetBlockFmtNamesParam __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDEGetBlockFmtNamesParam_get_Names_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEGetBlockFmtNamesParam_put_Names_Proxy( 
    IDEGetBlockFmtNamesParam __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *newVal);


void __RPC_STUB IDEGetBlockFmtNamesParam_put_Names_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__ */


#ifndef __IDHTMLSafe_INTERFACE_DEFINED__
#define __IDHTMLSafe_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDHTMLSafe
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDHTMLSafe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE04B590-2B1F-11d2-8D1E-00A0C959BC0A")
    IDHTMLSafe : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecCommand( 
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetContextMenu( 
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NewDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadURL( 
            /* [in] */ BSTR url) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FilterSourceCode( 
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DOM( 
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentHTML( 
            /* [retval][out] */ BSTR __RPC_FAR *docHTML) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DocumentHTML( 
            /* [in] */ BSTR docHTML) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateApplets( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateApplets( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateActiveXControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateActiveXControls( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateDTCs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateDTCs( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowDetails( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowDetails( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowBorders( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowBorders( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ DHTMLEDITAPPEARANCE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Scrollbars( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Scrollbars( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScrollbarAppearance( 
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScrollbarAppearance( 
            /* [in] */ DHTMLEDITAPPEARANCE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceCodePreservation( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceCodePreservation( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AbsoluteDropMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AbsoluteDropMode( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGridX( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGridX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGridY( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGridY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGrid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGrid( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDocumentPath( 
            /* [retval][out] */ BSTR __RPC_FAR *docPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *baseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR baseURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentTitle( 
            /* [retval][out] */ BSTR __RPC_FAR *docTitle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDivOnCarriageReturn( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDivOnCarriageReturn( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Busy( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDHTMLSafeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDHTMLSafe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDHTMLSafe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecCommand )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextMenu )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewDocument )( 
            IDHTMLSafe __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR url);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterSourceCode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IDHTMLSafe __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DOM )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentHTML )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docHTML);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocumentHTML )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR docHTML);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateApplets )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateApplets )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateActiveXControls )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateActiveXControls )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateDTCs )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateDTCs )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDetails )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDetails )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowBorders )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowBorders )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Appearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Appearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scrollbars )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Scrollbars )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScrollbarAppearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScrollbarAppearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceCodePreservation )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceCodePreservation )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsoluteDropMode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsoluteDropMode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridX )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridX )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridY )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridY )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGrid )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGrid )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentDocumentPath )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *baseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR baseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentTitle )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseDivOnCarriageReturn )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseDivOnCarriageReturn )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDHTMLSafeVtbl;

    interface IDHTMLSafe
    {
        CONST_VTBL struct IDHTMLSafeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDHTMLSafe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDHTMLSafe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDHTMLSafe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDHTMLSafe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDHTMLSafe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDHTMLSafe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDHTMLSafe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDHTMLSafe_ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)	\
    (This)->lpVtbl -> ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)

#define IDHTMLSafe_QueryStatus(This,cmdID,retval)	\
    (This)->lpVtbl -> QueryStatus(This,cmdID,retval)

#define IDHTMLSafe_SetContextMenu(This,menuStrings,menuStates)	\
    (This)->lpVtbl -> SetContextMenu(This,menuStrings,menuStates)

#define IDHTMLSafe_NewDocument(This)	\
    (This)->lpVtbl -> NewDocument(This)

#define IDHTMLSafe_LoadURL(This,url)	\
    (This)->lpVtbl -> LoadURL(This,url)

#define IDHTMLSafe_FilterSourceCode(This,sourceCodeIn,sourceCodeOut)	\
    (This)->lpVtbl -> FilterSourceCode(This,sourceCodeIn,sourceCodeOut)

#define IDHTMLSafe_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IDHTMLSafe_get_DOM(This,pVal)	\
    (This)->lpVtbl -> get_DOM(This,pVal)

#define IDHTMLSafe_get_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> get_DocumentHTML(This,docHTML)

#define IDHTMLSafe_put_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> put_DocumentHTML(This,docHTML)

#define IDHTMLSafe_get_ActivateApplets(This,pVal)	\
    (This)->lpVtbl -> get_ActivateApplets(This,pVal)

#define IDHTMLSafe_put_ActivateApplets(This,newVal)	\
    (This)->lpVtbl -> put_ActivateApplets(This,newVal)

#define IDHTMLSafe_get_ActivateActiveXControls(This,pVal)	\
    (This)->lpVtbl -> get_ActivateActiveXControls(This,pVal)

#define IDHTMLSafe_put_ActivateActiveXControls(This,newVal)	\
    (This)->lpVtbl -> put_ActivateActiveXControls(This,newVal)

#define IDHTMLSafe_get_ActivateDTCs(This,pVal)	\
    (This)->lpVtbl -> get_ActivateDTCs(This,pVal)

#define IDHTMLSafe_put_ActivateDTCs(This,newVal)	\
    (This)->lpVtbl -> put_ActivateDTCs(This,newVal)

#define IDHTMLSafe_get_ShowDetails(This,pVal)	\
    (This)->lpVtbl -> get_ShowDetails(This,pVal)

#define IDHTMLSafe_put_ShowDetails(This,newVal)	\
    (This)->lpVtbl -> put_ShowDetails(This,newVal)

#define IDHTMLSafe_get_ShowBorders(This,pVal)	\
    (This)->lpVtbl -> get_ShowBorders(This,pVal)

#define IDHTMLSafe_put_ShowBorders(This,newVal)	\
    (This)->lpVtbl -> put_ShowBorders(This,newVal)

#define IDHTMLSafe_get_Appearance(This,pVal)	\
    (This)->lpVtbl -> get_Appearance(This,pVal)

#define IDHTMLSafe_put_Appearance(This,newVal)	\
    (This)->lpVtbl -> put_Appearance(This,newVal)

#define IDHTMLSafe_get_Scrollbars(This,pVal)	\
    (This)->lpVtbl -> get_Scrollbars(This,pVal)

#define IDHTMLSafe_put_Scrollbars(This,newVal)	\
    (This)->lpVtbl -> put_Scrollbars(This,newVal)

#define IDHTMLSafe_get_ScrollbarAppearance(This,pVal)	\
    (This)->lpVtbl -> get_ScrollbarAppearance(This,pVal)

#define IDHTMLSafe_put_ScrollbarAppearance(This,newVal)	\
    (This)->lpVtbl -> put_ScrollbarAppearance(This,newVal)

#define IDHTMLSafe_get_SourceCodePreservation(This,pVal)	\
    (This)->lpVtbl -> get_SourceCodePreservation(This,pVal)

#define IDHTMLSafe_put_SourceCodePreservation(This,newVal)	\
    (This)->lpVtbl -> put_SourceCodePreservation(This,newVal)

#define IDHTMLSafe_get_AbsoluteDropMode(This,pVal)	\
    (This)->lpVtbl -> get_AbsoluteDropMode(This,pVal)

#define IDHTMLSafe_put_AbsoluteDropMode(This,newVal)	\
    (This)->lpVtbl -> put_AbsoluteDropMode(This,newVal)

#define IDHTMLSafe_get_SnapToGridX(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridX(This,pVal)

#define IDHTMLSafe_put_SnapToGridX(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridX(This,newVal)

#define IDHTMLSafe_get_SnapToGridY(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridY(This,pVal)

#define IDHTMLSafe_put_SnapToGridY(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridY(This,newVal)

#define IDHTMLSafe_get_SnapToGrid(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGrid(This,pVal)

#define IDHTMLSafe_put_SnapToGrid(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGrid(This,newVal)

#define IDHTMLSafe_get_IsDirty(This,pVal)	\
    (This)->lpVtbl -> get_IsDirty(This,pVal)

#define IDHTMLSafe_get_CurrentDocumentPath(This,docPath)	\
    (This)->lpVtbl -> get_CurrentDocumentPath(This,docPath)

#define IDHTMLSafe_get_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,baseURL)

#define IDHTMLSafe_put_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,baseURL)

#define IDHTMLSafe_get_DocumentTitle(This,docTitle)	\
    (This)->lpVtbl -> get_DocumentTitle(This,docTitle)

#define IDHTMLSafe_get_UseDivOnCarriageReturn(This,pVal)	\
    (This)->lpVtbl -> get_UseDivOnCarriageReturn(This,pVal)

#define IDHTMLSafe_put_UseDivOnCarriageReturn(This,newVal)	\
    (This)->lpVtbl -> put_UseDivOnCarriageReturn(This,newVal)

#define IDHTMLSafe_get_Busy(This,pVal)	\
    (This)->lpVtbl -> get_Busy(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_ExecCommand_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITCMDID cmdID,
    /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
    /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
    /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);


void __RPC_STUB IDHTMLSafe_ExecCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_QueryStatus_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITCMDID cmdID,
    /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);


void __RPC_STUB IDHTMLSafe_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_SetContextMenu_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *menuStrings,
    /* [in] */ VARIANT __RPC_FAR *menuStates);


void __RPC_STUB IDHTMLSafe_SetContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_NewDocument_Proxy( 
    IDHTMLSafe __RPC_FAR * This);


void __RPC_STUB IDHTMLSafe_NewDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_LoadURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR url);


void __RPC_STUB IDHTMLSafe_LoadURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_FilterSourceCode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR sourceCodeIn,
    /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);


void __RPC_STUB IDHTMLSafe_FilterSourceCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_Refresh_Proxy( 
    IDHTMLSafe __RPC_FAR * This);


void __RPC_STUB IDHTMLSafe_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DOM_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_DOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DocumentHTML_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docHTML);


void __RPC_STUB IDHTMLSafe_get_DocumentHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_DocumentHTML_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR docHTML);


void __RPC_STUB IDHTMLSafe_put_DocumentHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateApplets_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateApplets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateApplets_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateApplets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateActiveXControls_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateActiveXControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateActiveXControls_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateActiveXControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateDTCs_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateDTCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateDTCs_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateDTCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ShowDetails_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ShowDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ShowDetails_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ShowDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ShowBorders_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ShowBorders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ShowBorders_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ShowBorders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Appearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_Appearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITAPPEARANCE newVal);


void __RPC_STUB IDHTMLSafe_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Scrollbars_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Scrollbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_Scrollbars_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_Scrollbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ScrollbarAppearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ScrollbarAppearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ScrollbarAppearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITAPPEARANCE newVal);


void __RPC_STUB IDHTMLSafe_put_ScrollbarAppearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SourceCodePreservation_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SourceCodePreservation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SourceCodePreservation_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_SourceCodePreservation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_AbsoluteDropMode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_AbsoluteDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_AbsoluteDropMode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_AbsoluteDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGridX_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGridX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGridX_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGridX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGridY_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGridY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGridY_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGridY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGrid_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGrid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGrid_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGrid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_IsDirty_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_CurrentDocumentPath_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docPath);


void __RPC_STUB IDHTMLSafe_get_CurrentDocumentPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_BaseURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *baseURL);


void __RPC_STUB IDHTMLSafe_get_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_BaseURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR baseURL);


void __RPC_STUB IDHTMLSafe_put_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DocumentTitle_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docTitle);


void __RPC_STUB IDHTMLSafe_get_DocumentTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_UseDivOnCarriageReturn_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_UseDivOnCarriageReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_UseDivOnCarriageReturn_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_UseDivOnCarriageReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Busy_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Busy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDHTMLSafe_INTERFACE_DEFINED__ */


#ifndef __IDHTMLEdit_INTERFACE_DEFINED__
#define __IDHTMLEdit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDHTMLEdit
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][unique][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_IDHTMLEdit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE04B591-2B1F-11d2-8D1E-00A0C959BC0A")
    IDHTMLEdit : public IDHTMLSafe
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadDocument( 
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveDocument( 
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PrintDocument( 
            /* [optional][in] */ VARIANT __RPC_FAR *withUI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BrowseMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrowseMode( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDHTMLEditVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDHTMLEdit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDHTMLEdit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecCommand )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextMenu )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewDocument )( 
            IDHTMLEdit __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR url);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterSourceCode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IDHTMLEdit __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DOM )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentHTML )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docHTML);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocumentHTML )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR docHTML);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateApplets )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateApplets )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateActiveXControls )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateActiveXControls )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateDTCs )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateDTCs )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDetails )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDetails )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowBorders )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowBorders )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Appearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Appearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scrollbars )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Scrollbars )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScrollbarAppearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScrollbarAppearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceCodePreservation )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceCodePreservation )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsoluteDropMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsoluteDropMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridX )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridX )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridY )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridY )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGrid )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGrid )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentDocumentPath )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *baseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR baseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentTitle )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseDivOnCarriageReturn )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseDivOnCarriageReturn )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *withUI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrowseMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrowseMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDHTMLEditVtbl;

    interface IDHTMLEdit
    {
        CONST_VTBL struct IDHTMLEditVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDHTMLEdit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDHTMLEdit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDHTMLEdit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDHTMLEdit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDHTMLEdit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDHTMLEdit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDHTMLEdit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDHTMLEdit_ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)	\
    (This)->lpVtbl -> ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)

#define IDHTMLEdit_QueryStatus(This,cmdID,retval)	\
    (This)->lpVtbl -> QueryStatus(This,cmdID,retval)

#define IDHTMLEdit_SetContextMenu(This,menuStrings,menuStates)	\
    (This)->lpVtbl -> SetContextMenu(This,menuStrings,menuStates)

#define IDHTMLEdit_NewDocument(This)	\
    (This)->lpVtbl -> NewDocument(This)

#define IDHTMLEdit_LoadURL(This,url)	\
    (This)->lpVtbl -> LoadURL(This,url)

#define IDHTMLEdit_FilterSourceCode(This,sourceCodeIn,sourceCodeOut)	\
    (This)->lpVtbl -> FilterSourceCode(This,sourceCodeIn,sourceCodeOut)

#define IDHTMLEdit_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IDHTMLEdit_get_DOM(This,pVal)	\
    (This)->lpVtbl -> get_DOM(This,pVal)

#define IDHTMLEdit_get_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> get_DocumentHTML(This,docHTML)

#define IDHTMLEdit_put_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> put_DocumentHTML(This,docHTML)

#define IDHTMLEdit_get_ActivateApplets(This,pVal)	\
    (This)->lpVtbl -> get_ActivateApplets(This,pVal)

#define IDHTMLEdit_put_ActivateApplets(This,newVal)	\
    (This)->lpVtbl -> put_ActivateApplets(This,newVal)

#define IDHTMLEdit_get_ActivateActiveXControls(This,pVal)	\
    (This)->lpVtbl -> get_ActivateActiveXControls(This,pVal)

#define IDHTMLEdit_put_ActivateActiveXControls(This,newVal)	\
    (This)->lpVtbl -> put_ActivateActiveXControls(This,newVal)

#define IDHTMLEdit_get_ActivateDTCs(This,pVal)	\
    (This)->lpVtbl -> get_ActivateDTCs(This,pVal)

#define IDHTMLEdit_put_ActivateDTCs(This,newVal)	\
    (This)->lpVtbl -> put_ActivateDTCs(This,newVal)

#define IDHTMLEdit_get_ShowDetails(This,pVal)	\
    (This)->lpVtbl -> get_ShowDetails(This,pVal)

#define IDHTMLEdit_put_ShowDetails(This,newVal)	\
    (This)->lpVtbl -> put_ShowDetails(This,newVal)

#define IDHTMLEdit_get_ShowBorders(This,pVal)	\
    (This)->lpVtbl -> get_ShowBorders(This,pVal)

#define IDHTMLEdit_put_ShowBorders(This,newVal)	\
    (This)->lpVtbl -> put_ShowBorders(This,newVal)

#define IDHTMLEdit_get_Appearance(This,pVal)	\
    (This)->lpVtbl -> get_Appearance(This,pVal)

#define IDHTMLEdit_put_Appearance(This,newVal)	\
    (This)->lpVtbl -> put_Appearance(This,newVal)

#define IDHTMLEdit_get_Scrollbars(This,pVal)	\
    (This)->lpVtbl -> get_Scrollbars(This,pVal)

#define IDHTMLEdit_put_Scrollbars(This,newVal)	\
    (This)->lpVtbl -> put_Scrollbars(This,newVal)

#define IDHTMLEdit_get_ScrollbarAppearance(This,pVal)	\
    (This)->lpVtbl -> get_ScrollbarAppearance(This,pVal)

#define IDHTMLEdit_put_ScrollbarAppearance(This,newVal)	\
    (This)->lpVtbl -> put_ScrollbarAppearance(This,newVal)

#define IDHTMLEdit_get_SourceCodePreservation(This,pVal)	\
    (This)->lpVtbl -> get_SourceCodePreservation(This,pVal)

#define IDHTMLEdit_put_SourceCodePreservation(This,newVal)	\
    (This)->lpVtbl -> put_SourceCodePreservation(This,newVal)

#define IDHTMLEdit_get_AbsoluteDropMode(This,pVal)	\
    (This)->lpVtbl -> get_AbsoluteDropMode(This,pVal)

#define IDHTMLEdit_put_AbsoluteDropMode(This,newVal)	\
    (This)->lpVtbl -> put_AbsoluteDropMode(This,newVal)

#define IDHTMLEdit_get_SnapToGridX(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridX(This,pVal)

#define IDHTMLEdit_put_SnapToGridX(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridX(This,newVal)

#define IDHTMLEdit_get_SnapToGridY(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridY(This,pVal)

#define IDHTMLEdit_put_SnapToGridY(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridY(This,newVal)

#define IDHTMLEdit_get_SnapToGrid(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGrid(This,pVal)

#define IDHTMLEdit_put_SnapToGrid(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGrid(This,newVal)

#define IDHTMLEdit_get_IsDirty(This,pVal)	\
    (This)->lpVtbl -> get_IsDirty(This,pVal)

#define IDHTMLEdit_get_CurrentDocumentPath(This,docPath)	\
    (This)->lpVtbl -> get_CurrentDocumentPath(This,docPath)

#define IDHTMLEdit_get_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,baseURL)

#define IDHTMLEdit_put_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,baseURL)

#define IDHTMLEdit_get_DocumentTitle(This,docTitle)	\
    (This)->lpVtbl -> get_DocumentTitle(This,docTitle)

#define IDHTMLEdit_get_UseDivOnCarriageReturn(This,pVal)	\
    (This)->lpVtbl -> get_UseDivOnCarriageReturn(This,pVal)

#define IDHTMLEdit_put_UseDivOnCarriageReturn(This,newVal)	\
    (This)->lpVtbl -> put_UseDivOnCarriageReturn(This,newVal)

#define IDHTMLEdit_get_Busy(This,pVal)	\
    (This)->lpVtbl -> get_Busy(This,pVal)


#define IDHTMLEdit_LoadDocument(This,pathIn,promptUser)	\
    (This)->lpVtbl -> LoadDocument(This,pathIn,promptUser)

#define IDHTMLEdit_SaveDocument(This,pathIn,promptUser)	\
    (This)->lpVtbl -> SaveDocument(This,pathIn,promptUser)

#define IDHTMLEdit_PrintDocument(This,withUI)	\
    (This)->lpVtbl -> PrintDocument(This,withUI)

#define IDHTMLEdit_get_BrowseMode(This,pVal)	\
    (This)->lpVtbl -> get_BrowseMode(This,pVal)

#define IDHTMLEdit_put_BrowseMode(This,newVal)	\
    (This)->lpVtbl -> put_BrowseMode(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_LoadDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pathIn,
    /* [optional][in] */ VARIANT __RPC_FAR *promptUser);


void __RPC_STUB IDHTMLEdit_LoadDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_SaveDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pathIn,
    /* [optional][in] */ VARIANT __RPC_FAR *promptUser);


void __RPC_STUB IDHTMLEdit_SaveDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_PrintDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *withUI);


void __RPC_STUB IDHTMLEdit_PrintDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_get_BrowseMode_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLEdit_get_BrowseMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_put_BrowseMode_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLEdit_put_BrowseMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDHTMLEdit_INTERFACE_DEFINED__ */


#ifndef __IDEInsertTableParam_INTERFACE_DEFINED__
#define __IDEInsertTableParam_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDEInsertTableParam
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDEInsertTableParam;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47B0DFC6-B7A3-11D1-ADC5-006008A5848C")
    IDEInsertTableParam : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumRows( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumRows( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCols( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumCols( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TableAttrs( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TableAttrs( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CellAttrs( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CellAttrs( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDEInsertTableParamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDEInsertTableParam __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDEInsertTableParam __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumRows )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumRows )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumCols )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumCols )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TableAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TableAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CellAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CellAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Caption )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDEInsertTableParamVtbl;

    interface IDEInsertTableParam
    {
        CONST_VTBL struct IDEInsertTableParamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDEInsertTableParam_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDEInsertTableParam_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDEInsertTableParam_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDEInsertTableParam_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDEInsertTableParam_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDEInsertTableParam_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDEInsertTableParam_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDEInsertTableParam_get_NumRows(This,pVal)	\
    (This)->lpVtbl -> get_NumRows(This,pVal)

#define IDEInsertTableParam_put_NumRows(This,newVal)	\
    (This)->lpVtbl -> put_NumRows(This,newVal)

#define IDEInsertTableParam_get_NumCols(This,pVal)	\
    (This)->lpVtbl -> get_NumCols(This,pVal)

#define IDEInsertTableParam_put_NumCols(This,newVal)	\
    (This)->lpVtbl -> put_NumCols(This,newVal)

#define IDEInsertTableParam_get_TableAttrs(This,pVal)	\
    (This)->lpVtbl -> get_TableAttrs(This,pVal)

#define IDEInsertTableParam_put_TableAttrs(This,newVal)	\
    (This)->lpVtbl -> put_TableAttrs(This,newVal)

#define IDEInsertTableParam_get_CellAttrs(This,pVal)	\
    (This)->lpVtbl -> get_CellAttrs(This,pVal)

#define IDEInsertTableParam_put_CellAttrs(This,newVal)	\
    (This)->lpVtbl -> put_CellAttrs(This,newVal)

#define IDEInsertTableParam_get_Caption(This,pVal)	\
    (This)->lpVtbl -> get_Caption(This,pVal)

#define IDEInsertTableParam_put_Caption(This,newVal)	\
    (This)->lpVtbl -> put_Caption(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_NumRows_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_NumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_NumRows_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDEInsertTableParam_put_NumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_NumCols_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_NumCols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_NumCols_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDEInsertTableParam_put_NumCols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_TableAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_TableAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_TableAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_TableAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_CellAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_CellAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_CellAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_CellAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_Caption_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_Caption_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDEInsertTableParam_INTERFACE_DEFINED__ */


#ifndef ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__
#define ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DHTMLSafeEvents
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][uuid] */ 



EXTERN_C const IID DIID__DHTMLSafeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("D1FC78E8-B380-11d1-ADC5-006008A5848C")
    _DHTMLSafeEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DHTMLSafeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DHTMLSafeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DHTMLSafeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DHTMLSafeEventsVtbl;

    interface _DHTMLSafeEvents
    {
        CONST_VTBL struct _DHTMLSafeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DHTMLSafeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DHTMLSafeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DHTMLSafeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DHTMLSafeEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DHTMLSafeEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DHTMLSafeEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DHTMLSafeEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__ */


#ifndef ___DHTMLEditEvents_DISPINTERFACE_DEFINED__
#define ___DHTMLEditEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DHTMLEditEvents
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][uuid] */ 



EXTERN_C const IID DIID__DHTMLEditEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("588D5040-CF28-11d1-8CD3-00A0C959BC0A")
    _DHTMLEditEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DHTMLEditEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DHTMLEditEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DHTMLEditEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DHTMLEditEventsVtbl;

    interface _DHTMLEditEvents
    {
        CONST_VTBL struct _DHTMLEditEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DHTMLEditEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DHTMLEditEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DHTMLEditEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DHTMLEditEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DHTMLEditEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DHTMLEditEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DHTMLEditEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DHTMLEditEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DHTMLEdit;

#ifdef __cplusplus

class DECLSPEC_UUID("2D360200-FFF5-11d1-8D03-00A0C959BC0A")
DHTMLEdit;
#endif

EXTERN_C const CLSID CLSID_DHTMLSafe;

#ifdef __cplusplus

class DECLSPEC_UUID("2D360201-FFF5-11d1-8D03-00A0C959BC0A")
DHTMLSafe;
#endif

EXTERN_C const CLSID CLSID_DEInsertTableParam;

#ifdef __cplusplus

class DECLSPEC_UUID("47B0DFC7-B7A3-11D1-ADC5-006008A5848C")
DEInsertTableParam;
#endif

EXTERN_C const CLSID CLSID_DEGetBlockFmtNamesParam;

#ifdef __cplusplus

class DECLSPEC_UUID("8D91090E-B955-11D1-ADC5-006008A5848C")
DEGetBlockFmtNamesParam;
#endif
#endif /* __DHTMLEDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dinputd.h ===
/****************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputd.h
 *  Content:    DirectInput include file for device driver implementors
 *
 ****************************************************************************/
#ifndef __DINPUTD_INCLUDED__
#define __DINPUTD_INCLUDED__

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0800
#pragma message(__FILE__ ": DIRECTINPUT_VERSION undefined. Defaulting to version 0x0800")
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

DEFINE_GUID(IID_IDirectInputEffectDriver,   0x02538130,0x898F,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(IID_IDirectInputJoyConfig,      0x1DE12AB1,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputPIDDriver,      0xEEC6993A,0xB3FD,0x11D2,0xA9,0x16,0x00,0xC0,0x4F,0xB9,0x86,0x38);

DEFINE_GUID(IID_IDirectInputJoyConfig8,     0xeb0d7dfa,0x1990,0x4f27,0xb4,0xd6,0xed,0xf2,0xee,0xc4,0xa4,0x4c);

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputEffectDriver
 *
 ****************************************************************************/

typedef struct DIOBJECTATTRIBUTES {
    DWORD   dwFlags;
    WORD    wUsagePage;
    WORD    wUsage;
} DIOBJECTATTRIBUTES, *LPDIOBJECTATTRIBUTES;
typedef const DIOBJECTATTRIBUTES *LPCDIOBJECTATTRIBUTES;

typedef struct DIFFOBJECTATTRIBUTES {
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
} DIFFOBJECTATTRIBUTES, *LPDIFFOBJECTATTRIBUTES;
typedef const DIFFOBJECTATTRIBUTES *LPCDIFFOBJECTATTRIBUTES;

typedef struct DIOBJECTCALIBRATION {
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIOBJECTCALIBRATION, *LPDIOBJECTCALIBRATION;
typedef const DIOBJECTCALIBRATION *LPCDIOBJECTCALIBRATION;

typedef struct DIPOVCALIBRATION {
    LONG    lMin[5];
    LONG    lMax[5];
} DIPOVCALIBRATION, *LPDIPOVCALIBRATION;
typedef const DIPOVCALIBRATION *LPCDIPOVCALIBRATION;

typedef struct DIEFFECTATTRIBUTES {
    DWORD   dwEffectId;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    DWORD   dwCoords;
} DIEFFECTATTRIBUTES, *LPDIEFFECTATTRIBUTES;
typedef const DIEFFECTATTRIBUTES *LPCDIEFFECTATTRIBUTES;

typedef struct DIFFDEVICEATTRIBUTES {
    DWORD   dwFlags;
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
} DIFFDEVICEATTRIBUTES, *LPDIFFDEVICEATTRIBUTES;
typedef const DIFFDEVICEATTRIBUTES *LPCDIFFDEVICEATTRIBUTES;

typedef struct DIDRIVERVERSIONS {
    DWORD   dwSize;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
} DIDRIVERVERSIONS, *LPDIDRIVERVERSIONS;
typedef const DIDRIVERVERSIONS *LPCDIDRIVERVERSIONS;

typedef struct DIDEVICESTATE {
    DWORD   dwSize;
    DWORD   dwState;
    DWORD   dwLoad;
} DIDEVICESTATE, *LPDIDEVICESTATE;

#define DEV_STS_EFFECT_RUNNING  DIEGES_PLAYING

#ifndef DIJ_RINGZERO

typedef struct DIHIDFFINITINFO {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
} DIHIDFFINITINFO, *LPDIHIDFFINITINFO;

#undef INTERFACE
#define INTERFACE IDirectInputEffectDriver

DECLARE_INTERFACE_(IDirectInputEffectDriver, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE) PURE;
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE) PURE;
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD) PURE;
};

typedef struct IDirectInputEffectDriver *LPDIRECTINPUTEFFECTDRIVER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffectDriver_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->lpVtbl->DeviceID(p,a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->lpVtbl->Escape(p,a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->lpVtbl->SetGain(p,a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->lpVtbl->SendForceFeedbackCommand(p,a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->lpVtbl->GetForceFeedbackState(p,a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->lpVtbl->DownloadEffect(p,a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->lpVtbl->DestroyEffect(p,a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->lpVtbl->StartEffect(p,a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->lpVtbl->StopEffect(p,a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->lpVtbl->GetEffectStatus(p,a,b,c)
#else
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->AddRef()
#define IDirectInputEffectDriver_Release(p) (p)->Release()
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->DeviceID(a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->Escape(a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->SetGain(a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->SendForceFeedbackCommand(a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->GetForceFeedbackState(a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->DownloadEffect(a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->DestroyEffect(a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->StartEffect(a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->StopEffect(a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->GetEffectStatus(a,b,c)
#endif


#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputJoyConfig
 *
 ****************************************************************************/

/****************************************************************************
 *
 *      Definitions copied from the DDK
 *
 ****************************************************************************/

#ifndef JOY_HW_NONE

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_TWO_2A_2B_WITH_Y         12
#define JOY_HW_LASTENTRY                13


/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* reserved for future use -> as link to next possible dword */
#define JOY_US_RESERVED         0x80000000l     /* reserved */


/* Settings for TypeInfo Flags1 */
#define JOYTYPE_ZEROGAMEENUMOEMDATA     0x00000001l /* Zero GameEnum's OEM data field */
#define JOYTYPE_NOAUTODETECTGAMEPORT    0x00000002l /* Device does not support Autodetect gameport*/
#define JOYTYPE_NOHIDDIRECT             0x00000004l /* Do not use HID directly for this device */
#define JOYTYPE_ANALOGCOMPAT            0x00000008l /* Expose the analog compatible ID */
#define JOYTYPE_DEFAULTPROPSHEET        0x80000000l /* CPL overrides custom property sheet */

/* Settings for TypeInfo Flags2 */
#define JOYTYPE_DEVICEHIDE              0x00010000l /* Hide unclassified devices */
#define JOYTYPE_MOUSEHIDE               0x00020000l /* Hide mice */
#define JOYTYPE_KEYBHIDE                0x00040000l /* Hide keyboards */
#define JOYTYPE_GAMEHIDE                0x00080000l /* Hide game controllers */
#define JOYTYPE_HIDEACTIVE              0x00100000l /* Hide flags are active */
#define JOYTYPE_INFOMASK                0x00E00000l /* Mask for type specific info */
#define JOYTYPE_INFODEFAULT             0x00000000l /* Use default axis mappings */
#define JOYTYPE_INFOYYPEDALS            0x00200000l /* Use Y as a combined pedals axis */
#define JOYTYPE_INFOZYPEDALS            0x00400000l /* Use Z for accelerate, Y for brake */
#define JOYTYPE_INFOYRPEDALS            0x00600000l /* Use Y for accelerate, R for brake */
#define JOYTYPE_INFOZRPEDALS            0x00800000l /* Use Z for accelerate, R for brake */
#define JOYTYPE_INFOZISSLIDER           0x00200000l /* Use Z as a slider */
#define JOYTYPE_INFOZISZ                0x00400000l /* Use Z as Z axis */
#define JOYTYPE_ENABLEINPUTREPORT       0x01000000l /* Enable initial input reports */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

/*
 *  dwTimeout - value at which to timeout joystick polling
 *  jrvRanges - range of values app wants returned for axes
 *  jpDeadZone - area around center to be considered
 *               as "dead". specified as a percentage
 *               (0-100). Only X & Y handled by system driver
 */
typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;
    JOYRANGE    jrvRanges;
    JOYPOS      jpDeadZone;
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
/*
 *  jrvHardware - values returned by hardware
 *  dwPOVValues - POV values returned by hardware
 *  dwCalFlags  - what has been calibrated
 */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];
    DWORD       dwCalFlags;
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
/*
 *  hws             - hardware settings
 *  dwUsageSettings - usage settings
 *  hwv             - values returned by hardware
 *  dwType          - type of joystick
 *  dwReserved      - reserved for OEM drivers
 */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;
    DWORD               dwUsageSettings;
    JOYREGHWVALUES      hwv;
    DWORD               dwType;
    DWORD               dwReserved;
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

#endif

#ifndef DIJ_RINGZERO

#define MAX_JOYSTRING 256
typedef BOOL (FAR PASCAL * LPDIJOYTYPECALLBACK)(LPCWSTR, LPVOID);

#ifndef MAX_JOYSTICKOEMVXDNAME
#define MAX_JOYSTICKOEMVXDNAME 260
#endif

#define DITC_REGHWSETTINGS          0x00000001
#define DITC_CLSIDCONFIG            0x00000002
#define DITC_DISPLAYNAME            0x00000004
#define DITC_CALLOUT                0x00000008
#define DITC_HARDWAREID             0x00000010
#define DITC_FLAGS1                 0x00000020
#define DITC_FLAGS2                 0x00000040
#define DITC_MAPFILE                0x00000080



/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYTYPEINFO_DX5 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
} DIJOYTYPEINFO_DX5, *LPDIJOYTYPEINFO_DX5;
typedef const DIJOYTYPEINFO_DX5 *LPCDIJOYTYPEINFO_DX5;

/* This structure is defined for DirectX 6.1 compatibility */
typedef struct DIJOYTYPEINFO_DX6 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
} DIJOYTYPEINFO_DX6, *LPDIJOYTYPEINFO_DX6;
typedef const DIJOYTYPEINFO_DX6 *LPCDIJOYTYPEINFO_DX6;

typedef struct DIJOYTYPEINFO {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
#if(DIRECTINPUT_VERSION >= 0x0800)
    DWORD dwFlags2;
    WCHAR wszMapFile[MAX_JOYSTRING];
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
} DIJOYTYPEINFO, *LPDIJOYTYPEINFO;
typedef const DIJOYTYPEINFO *LPCDIJOYTYPEINFO;
#define DIJC_GUIDINSTANCE           0x00000001
#define DIJC_REGHWCONFIGTYPE        0x00000002
#define DIJC_GAIN                   0x00000004
#define DIJC_CALLOUT                0x00000008
#define DIJC_WDMGAMEPORT            0x00000010

/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYCONFIG_DX5 {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
} DIJOYCONFIG_DX5, *LPDIJOYCONFIG_DX5;
typedef const DIJOYCONFIG_DX5 *LPCDIJOYCONFIG_DX5;

typedef struct DIJOYCONFIG {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    GUID  guidGameport;
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
    } DIJOYCONFIG, *LPDIJOYCONFIG;
typedef const DIJOYCONFIG *LPCDIJOYCONFIG;


#define DIJU_USERVALUES             0x00000001
#define DIJU_GLOBALDRIVER           0x00000002
#define DIJU_GAMEPORTEMULATOR       0x00000004

typedef struct DIJOYUSERVALUES {
    DWORD dwSize;
    JOYREGUSERVALUES ruv;
    WCHAR wszGlobalDriver[MAX_JOYSTRING];
    WCHAR wszGameportEmulator[MAX_JOYSTRING];
} DIJOYUSERVALUES, *LPDIJOYUSERVALUES;
typedef const DIJOYUSERVALUES *LPCDIJOYUSERVALUES;

DEFINE_GUID(GUID_KeyboardClass, 0x4D36E96B,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MediaClass,    0x4D36E96C,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MouseClass,    0x4D36E96F,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_HIDClass,      0x745A17A0,0x74D3,0x11D0,0xB6,0xFE,0x00,0xA0,0xC9,0x0F,0x57,0xDA);

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig

DECLARE_INTERFACE_(IDirectInputJoyConfig, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenConfigKey)(THIS_ UINT,DWORD,PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig *LPDIRECTINPUTJOYCONFIG;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->lpVtbl->SetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->lpVtbl->OpenConfigKey(p,a,b,c)
#else
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig_Release(p) (p)->Release()
#define IDirectInputJoyConfig_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->SetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->OpenConfigKey(a,b,c)
#endif

#endif /* DIJ_RINGZERO */

#if(DIRECTINPUT_VERSION >= 0x0800)

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig8

DECLARE_INTERFACE_(IDirectInputJoyConfig8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig8 methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD,LPWSTR) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenAppStatusKey)(THIS_ PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig8 *LPDIRECTINPUTJOYCONFIG8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig8_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->lpVtbl->SetTypeInfo(p,a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->lpVtbl->OpenAppStatusKey(p,a)
#else
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig8_Release(p) (p)->Release()
#define IDirectInputJoyConfig8_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig8_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->SetTypeInfo(a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->OpenAppStatusKey(a)
#endif

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  Notification Messages
 *
 ****************************************************************************/

/* RegisterWindowMessage with this to get DirectInput notification messages */
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGA  "DIRECTINPUT_NOTIFICATION_MSGSTRING"
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGW  L"DIRECTINPUT_NOTIFICATION_MSGSTRING"

#ifdef UNICODE
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGW
#else
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGA
#endif

#define DIMSGWP_NEWAPPSTART         0x00000001
#define DIMSGWP_DX8APPSTART         0x00000002
#define DIMSGWP_DX8MAPPERAPPSTART   0x00000003

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define DIAPPIDFLAG_NOTIME         0x00000001
#define DIAPPIDFLAG_NOSIZE         0x00000002

#define DIRECTINPUT_REGSTR_VAL_APPIDFLAGA   "AppIdFlag"
#define DIRECTINPUT_REGSTR_KEY_LASTAPPA     "MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA  "MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONA     "Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEA        "Name"
#define DIRECTINPUT_REGSTR_VAL_IDA          "Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERA      "UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTA   "MostRecentStart"

#define DIRECTINPUT_REGSTR_VAL_APPIDFLAGW   L"AppIdFlag"
#define DIRECTINPUT_REGSTR_KEY_LASTAPPW     L"MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW  L"MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONW     L"Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEW        L"Name"
#define DIRECTINPUT_REGSTR_VAL_IDW          L"Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERW      L"UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTW   L"MostRecentStart"

#ifdef UNICODE
#define DIRECTINPUT_REGSTR_VAL_APPIDFLAG    DIRECTINPUT_REGSTR_VAL_APPIDFLAGW
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPW
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONW
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEW
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDW
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERW
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTW
#else
#define DIRECTINPUT_REGSTR_VAL_APPIDFLAG    DIRECTINPUT_REGSTR_VAL_APPIDFLAGA
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPA
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONA
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEA
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDA
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERA
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTA
#endif


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

#define DIERR_NOMOREITEMS               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NO_MORE_ITEMS)

/*
 *  Device driver-specific codes.
 */

#define DIERR_DRIVERFIRST               0x80040300L
#define DIERR_DRIVERLAST                0x800403FFL

/*
 *  Unless the specific driver has been precisely identified, no meaning 
 *  should be attributed to these values other than that the driver 
 *  originated the error.  However, to illustrate the types of error that 
 *  may be causing the failure, the PID force feedback driver distributed 
 *  with DirectX 7 could return the following errors:
 *
 *  DIERR_DRIVERFIRST + 1   
 *      The requested usage was not found.
 *  DIERR_DRIVERFIRST + 2   
 *      The parameter block couldn't be	downloaded to the device.
 *  DIERR_DRIVERFIRST + 3   
 *      PID initialization failed.
 *  DIERR_DRIVERFIRST + 4   
 *      The provided values couldn't be scaled.
 */


/*
 *  Device installer errors.
 */

/*
 *  Registry entry or DLL for class installer invalid
 *  or class installer not found.
 */
#define DIERR_INVALIDCLASSINSTALLER     0x80040400L

/*
 *  The user cancelled the install operation.
 */
#define DIERR_CANCELLED                 0x80040401L

/*
 *  The INF file for the selected device could not be
 *  found or is invalid or is damaged.
 */
#define DIERR_BADINF                    0x80040402L

/****************************************************************************
 *
 *  Map files
 *
 ****************************************************************************/

/*
 *  Delete particular data from default map file.
 */
#define DIDIFT_DELETE                   0x01000000

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUTD_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DispEx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dispex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dispex_h__
#define __dispex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDispatchEx_FWD_DEFINED__
#define __IDispatchEx_FWD_DEFINED__
typedef interface IDispatchEx IDispatchEx;
#endif 	/* __IDispatchEx_FWD_DEFINED__ */


#ifndef __IDispError_FWD_DEFINED__
#define __IDispError_FWD_DEFINED__
typedef interface IDispError IDispError;
#endif 	/* __IDispError_FWD_DEFINED__ */


#ifndef __IVariantChangeType_FWD_DEFINED__
#define __IVariantChangeType_FWD_DEFINED__
typedef interface IVariantChangeType IVariantChangeType;
#endif 	/* __IVariantChangeType_FWD_DEFINED__ */


#ifndef __IObjectIdentity_FWD_DEFINED__
#define __IObjectIdentity_FWD_DEFINED__
typedef interface IObjectIdentity IObjectIdentity;
#endif 	/* __IObjectIdentity_FWD_DEFINED__ */


#ifndef __IProvideRuntimeContext_FWD_DEFINED__
#define __IProvideRuntimeContext_FWD_DEFINED__
typedef interface IProvideRuntimeContext IProvideRuntimeContext;
#endif 	/* __IProvideRuntimeContext_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dispex_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DispEx.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IDispatchEx Interfaces.
//

#ifndef DISPEX_H_
#define DISPEX_H_





#include "servprov.h"

#ifndef _NO_DISPATCHEX_GUIDS

// {A6EF9860-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispatchEx, 0xa6ef9860, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9861-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispError, 0xa6ef9861, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9862-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IVariantChangeType, 0xa6ef9862, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {1F101481-BCCD-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_VariantConversion, 0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {4717CC40-BCB9-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_GetCaller, 0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {74A5040C-DD0C-48f0-AC85-194C3259180A}
DEFINE_GUID(SID_ProvideRuntimeContext, 0x74a5040c, 0xdd0c, 0x48f0, 0xac, 0x85, 0x19, 0x4c, 0x32, 0x59, 0x18, 0xa);

// {10E2414A-EC59-49d2-BC51-5ADD2C36FEBC}
DEFINE_GUID(IID_IProvideRuntimeContext, 0x10e2414a, 0xec59, 0x49d2, 0xbc, 0x51, 0x5a, 0xdd, 0x2c, 0x36, 0xfe, 0xbc);

// {CA04B7E6-0D21-11d1-8CC5-00C04FC2B085}
DEFINE_GUID(IID_IObjectIdentity, 0xca04b7e6, 0xd21, 0x11d1, 0x8c, 0xc5, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

#define SID_GetScriptSite IID_IActiveScriptSite

#endif // _NO_DISPATCHEX_GUIDS


#ifndef _NO_DISPATCHEX_CONSTS

// Input flags for GetDispID
#define fdexNameCaseSensitive       0x00000001L
#define fdexNameEnsure              0x00000002L
#define fdexNameImplicit            0x00000004L
#define fdexNameCaseInsensitive     0x00000008L
#define fdexNameInternal            0x00000010L
#define fdexNameNoDynamicProperties 0x00000020L

// Output flags for GetMemberProperties
#define fdexPropCanGet              0x00000001L
#define fdexPropCannotGet           0x00000002L
#define fdexPropCanPut              0x00000004L
#define fdexPropCannotPut           0x00000008L
#define fdexPropCanPutRef           0x00000010L
#define fdexPropCannotPutRef        0x00000020L
#define fdexPropNoSideEffects       0x00000040L
#define fdexPropDynamicType         0x00000080L
#define fdexPropCanCall             0x00000100L
#define fdexPropCannotCall          0x00000200L
#define fdexPropCanConstruct        0x00000400L
#define fdexPropCannotConstruct     0x00000800L
#define fdexPropCanSourceEvents     0x00001000L
#define fdexPropCannotSourceEvents  0x00002000L

#define grfdexPropCanAll \
       (fdexPropCanGet | fdexPropCanPut | fdexPropCanPutRef | \
        fdexPropCanCall | fdexPropCanConstruct | fdexPropCanSourceEvents)
#define grfdexPropCannotAll \
       (fdexPropCannotGet | fdexPropCannotPut | fdexPropCannotPutRef | \
        fdexPropCannotCall | fdexPropCannotConstruct | fdexPropCannotSourceEvents)
#define grfdexPropExtraAll \
       (fdexPropNoSideEffects | fdexPropDynamicType)
#define grfdexPropAll \
       (grfdexPropCanAll | grfdexPropCannotAll | grfdexPropExtraAll)

// Input flags for GetNextDispID
#define fdexEnumDefault             0x00000001L
#define fdexEnumAll                 0x00000002L

// Additional flags for Invoke - when object member is
// used as a constructor.
#define DISPATCH_CONSTRUCT 0x4000

// Standard DISPIDs
#define DISPID_THIS (-613)
#define DISPID_STARTENUM DISPID_UNKNOWN

#endif //_NO_DISPATCHEX_CONSTS



extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0000_v0_0_s_ifspec;

#ifndef __IDispatchEx_INTERFACE_DEFINED__
#define __IDispatchEx_INTERFACE_DEFINED__

/* interface IDispatchEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9860-C720-11d0-9337-00A0C90DCAA9")
    IDispatchEx : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ __RPC__out DISPID *pid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei,
            /* [unique][in] */ IServiceProvider *pspCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ __RPC__out DWORD *pgrfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__out DISPID *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDispatchEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDispatchEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDispatchEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDispatchEx * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDispatchEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDispatchEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispatchEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetDispID )( 
            IDispatchEx * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ __RPC__out DISPID *pid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *InvokeEx )( 
            IDispatchEx * This,
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei,
            /* [unique][in] */ IServiceProvider *pspCaller);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMemberByName )( 
            IDispatchEx * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMemberByDispID )( 
            IDispatchEx * This,
            /* [in] */ DISPID id);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemberProperties )( 
            IDispatchEx * This,
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ __RPC__out DWORD *pgrfdex);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemberName )( 
            IDispatchEx * This,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextDispID )( 
            IDispatchEx * This,
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__out DISPID *pid);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameSpaceParent )( 
            IDispatchEx * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        END_INTERFACE
    } IDispatchExVtbl;

    interface IDispatchEx
    {
        CONST_VTBL struct IDispatchExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatchEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispatchEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispatchEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispatchEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispatchEx_GetDispID(This,bstrName,grfdex,pid)	\
    ( (This)->lpVtbl -> GetDispID(This,bstrName,grfdex,pid) ) 

#define IDispatchEx_InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)	\
    ( (This)->lpVtbl -> InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller) ) 

#define IDispatchEx_DeleteMemberByName(This,bstrName,grfdex)	\
    ( (This)->lpVtbl -> DeleteMemberByName(This,bstrName,grfdex) ) 

#define IDispatchEx_DeleteMemberByDispID(This,id)	\
    ( (This)->lpVtbl -> DeleteMemberByDispID(This,id) ) 

#define IDispatchEx_GetMemberProperties(This,id,grfdexFetch,pgrfdex)	\
    ( (This)->lpVtbl -> GetMemberProperties(This,id,grfdexFetch,pgrfdex) ) 

#define IDispatchEx_GetMemberName(This,id,pbstrName)	\
    ( (This)->lpVtbl -> GetMemberName(This,id,pbstrName) ) 

#define IDispatchEx_GetNextDispID(This,grfdex,id,pid)	\
    ( (This)->lpVtbl -> GetNextDispID(This,grfdex,id,pid) ) 

#define IDispatchEx_GetNameSpaceParent(This,ppunk)	\
    ( (This)->lpVtbl -> GetNameSpaceParent(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_RemoteInvokeEx_Proxy( 
    IDispatchEx * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in DISPPARAMS *pdp,
    /* [out] */ __RPC__out VARIANT *pvarRes,
    /* [out] */ __RPC__out EXCEPINFO *pei,
    /* [unique][in] */ __RPC__in_opt IServiceProvider *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ __RPC__in_ecount_full(cvarRefArg) UINT *rgiRefArg,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(cvarRefArg) VARIANT *rgvarRefArg);


void __RPC_STUB IDispatchEx_RemoteInvokeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IDispError_INTERFACE_DEFINED__
#define __IDispError_INTERFACE_DEFINED__

/* interface IDispError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9861-C720-11d0-9337-00A0C90DCAA9")
    IDispError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryErrorInfo( 
            /* [in] */ GUID guidErrorType,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ __RPC__deref_out_opt IDispError **ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHresult( 
            /* [out] */ __RPC__out HRESULT *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName,
            /* [out] */ __RPC__out DWORD *pdwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDispError * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDispError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDispError * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryErrorInfo )( 
            IDispError * This,
            /* [in] */ GUID guidErrorType,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            IDispError * This,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde);
        
        HRESULT ( STDMETHODCALLTYPE *GetHresult )( 
            IDispError * This,
            /* [out] */ __RPC__out HRESULT *phr);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpInfo )( 
            IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName,
            /* [out] */ __RPC__out DWORD *pdwContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        END_INTERFACE
    } IDispErrorVtbl;

    interface IDispError
    {
        CONST_VTBL struct IDispErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispError_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispError_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispError_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispError_QueryErrorInfo(This,guidErrorType,ppde)	\
    ( (This)->lpVtbl -> QueryErrorInfo(This,guidErrorType,ppde) ) 

#define IDispError_GetNext(This,ppde)	\
    ( (This)->lpVtbl -> GetNext(This,ppde) ) 

#define IDispError_GetHresult(This,phr)	\
    ( (This)->lpVtbl -> GetHresult(This,phr) ) 

#define IDispError_GetSource(This,pbstrSource)	\
    ( (This)->lpVtbl -> GetSource(This,pbstrSource) ) 

#define IDispError_GetHelpInfo(This,pbstrFileName,pdwContext)	\
    ( (This)->lpVtbl -> GetHelpInfo(This,pbstrFileName,pdwContext) ) 

#define IDispError_GetDescription(This,pbstrDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pbstrDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispError_INTERFACE_DEFINED__ */


#ifndef __IVariantChangeType_INTERFACE_DEFINED__
#define __IVariantChangeType_INTERFACE_DEFINED__

/* interface IVariantChangeType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVariantChangeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9862-C720-11d0-9337-00A0C90DCAA9")
    IVariantChangeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvarDst,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantChangeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVariantChangeType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVariantChangeType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVariantChangeType * This);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeType )( 
            IVariantChangeType * This,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvarDst,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew);
        
        END_INTERFACE
    } IVariantChangeTypeVtbl;

    interface IVariantChangeType
    {
        CONST_VTBL struct IVariantChangeTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantChangeType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVariantChangeType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVariantChangeType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVariantChangeType_ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)	\
    ( (This)->lpVtbl -> ChangeType(This,pvarDst,pvarSrc,lcid,vtNew) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVariantChangeType_INTERFACE_DEFINED__ */


#ifndef __IObjectIdentity_INTERFACE_DEFINED__
#define __IObjectIdentity_INTERFACE_DEFINED__

/* interface IObjectIdentity */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA04B7E6-0D21-11d1-8CC5-00C04FC2B085")
    IObjectIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEqualObject( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectIdentity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualObject )( 
            IObjectIdentity * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IObjectIdentityVtbl;

    interface IObjectIdentity
    {
        CONST_VTBL struct IObjectIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectIdentity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectIdentity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectIdentity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectIdentity_IsEqualObject(This,punk)	\
    ( (This)->lpVtbl -> IsEqualObject(This,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectIdentity_INTERFACE_DEFINED__ */


#ifndef __IProvideRuntimeContext_INTERFACE_DEFINED__
#define __IProvideRuntimeContext_INTERFACE_DEFINED__

/* interface IProvideRuntimeContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvideRuntimeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10E2414A-EC59-49d2-BC51-5ADD2C36FEBC")
    IProvideRuntimeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourceContext( 
            /* [out] */ __RPC__out DWORD_PTR *pdwContext,
            /* [out] */ __RPC__out VARIANT_BOOL *pfExecutingGlobalCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideRuntimeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvideRuntimeContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvideRuntimeContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvideRuntimeContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSourceContext )( 
            IProvideRuntimeContext * This,
            /* [out] */ __RPC__out DWORD_PTR *pdwContext,
            /* [out] */ __RPC__out VARIANT_BOOL *pfExecutingGlobalCode);
        
        END_INTERFACE
    } IProvideRuntimeContextVtbl;

    interface IProvideRuntimeContext
    {
        CONST_VTBL struct IProvideRuntimeContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideRuntimeContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideRuntimeContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideRuntimeContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideRuntimeContext_GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode)	\
    ( (This)->lpVtbl -> GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideRuntimeContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dispex_0000_0005 */
/* [local] */ 

#endif //DISPEX_H_


extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0005_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy( 
    IDispatchEx * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS *pdp,
    /* [out] */ VARIANT *pvarRes,
    /* [out] */ EXCEPINFO *pei,
    /* [unique][in] */ IServiceProvider *pspCaller);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub( 
    IDispatchEx * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in DISPPARAMS *pdp,
    /* [out] */ __RPC__out VARIANT *pvarRes,
    /* [out] */ __RPC__out EXCEPINFO *pei,
    /* [unique][in] */ __RPC__in_opt IServiceProvider *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ __RPC__in_ecount_full(cvarRefArg) UINT *rgiRefArg,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(cvarRefArg) VARIANT *rgvarRefArg);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dlgs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/

#pragma once

#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD             1536
#define MULTIFILEOPENORD        1537
#define PRINTDLGORD             1538
#define PRNSETUPDLGORD          1539
#define FINDDLGORD              1540
#define REPLACEDLGORD           1541
#define FONTDLGORD              1542
#define FORMATDLGORD31          1543
#define FORMATDLGORD30          1544
#define RUNDLGORD               1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */

// 1581 - 1590
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NEWFILEOPENV3ORD        1553
#endif // NTDDI_VISTA


//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dls1.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    109444
//  $AgreementName:  public license
//  $AgreementType:  oss license
//  $ExternalOrigin: sonic foundry
//$ENDTAG

//$TAG ENGR 
//  $Owner:    duganp
//  $Module:   mm_published_directx
//
//$ENDTAG

/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
                   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\diskguid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    diskguid.h

Abstract:

    GPT disk GUIDs.

Revision History:

--*/

//
// GPT Partition Type GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntdddisk.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntdddisk.h> in that source file a second time to instantiate the GUIDs
//

#ifdef DEFINE_GUID

//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif


//
// Define the GPT partition guids known by disk drivers and volume managers.
//

DEFINE_GUID(PARTITION_ENTRY_UNUSED_GUID,   0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);    // Entry unused
DEFINE_GUID(PARTITION_SYSTEM_GUID,         0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B);    // EFI system partition
DEFINE_GUID(PARTITION_MSFT_RESERVED_GUID,  0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE);    // Microsoft reserved space                                        
DEFINE_GUID(PARTITION_BASIC_DATA_GUID,     0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7);    // Basic data partition
DEFINE_GUID(PARTITION_LDM_METADATA_GUID,   0x5808C8AAL, 0x7E8F, 0x42E0, 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3);    // Logical Disk Manager metadata partition
DEFINE_GUID(PARTITION_LDM_DATA_GUID,       0xAF9B60A0L, 0x1431, 0x4F62, 0xBC, 0x68, 0x33, 0x11, 0x71, 0x4A, 0x69, 0xAD);    // Logical Disk Manager data partition
DEFINE_GUID(PARTITION_MSFT_RECOVERY_GUID,  0xDE94BBA4L, 0x06D1, 0x4D40, 0xA1, 0x6A, 0xBF, 0xD5, 0x01, 0x79, 0xD6, 0xAC);    // Microsoft recovery partition
DEFINE_GUID(PARTITION_CLUSTER_GUID, 	   0xdb97dba9L, 0x0840, 0x4bae, 0x97, 0xf0, 0xff, 0xb9, 0xa3, 0x27, 0xc7, 0xe1);    // Cluster metadata partition
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Dispdib.h ===
/****************************************************************************/
/*                                                                          */
/*        DISPDIB.H - Include file for DisplayDib() function.               */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef __DISPDIB_H__
#define __DISPDIB_H__

// DisplayDib() error return codes
#define DISPLAYDIB_NOERROR          0x0000  // success
#define DISPLAYDIB_NOTSUPPORTED     0x0001  // function not supported
#define DISPLAYDIB_INVALIDDIB       0x0002  // null or invalid DIB header
#define DISPLAYDIB_INVALIDFORMAT    0x0003  // invalid DIB format
#define DISPLAYDIB_INVALIDTASK      0x0004  // not called from current task
#define DISPLAYDIB_STOP             0x0005  // stop requested
#define DISPLAYDIB_NOTACTIVE	    0x0006  // DisplayDibWindow not foreground
#define DISPLAYDIB_BADSIZE          0x0007  //

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_NOFLIP           0x0800  // dont page flip
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE             0x000F  // mask for display mode
#define DISPLAYDIB_MODE_DEFAULT     0x0000  // default display mode
#define DISPLAYDIB_MODE_320x200x8   0x0001  // 320-by-200
#define DISPLAYDIB_MODE_320x240x8   0x0005  // 320-by-240

//
// a Win32 app must use the window class the function
// versions are not available
//
#ifndef _WIN32

// function prototypes
UINT FAR PASCAL DisplayDib(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, WORD wFlags);
UINT FAR PASCAL DisplayDibEx(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, WORD wFlags);

#define DisplayDibBegin() DisplayDib(NULL, NULL, DISPLAYDIB_BEGIN|DISPDIB_NOWAIT)
#define DisplayDibEnd()   DisplayDib(NULL, NULL, DISPLAYDIB_END|DISPDIB_NOWAIT)

#endif

//
//  DisplayDibWindow class.
//
//  simple interface to DISPDIB as a window class.
//  draw images and create a fullscreen window in one easy step.
//
//  advantages over calling the APIs directly.
//
//      if you show the window it will handle enabling/disabling
//      fullscreen mode when it has a activation.
//
//      while in fullscreen mode, window will be sized to
//      cover entire display preventing other apps from getting
//      clicked on. (when visible)
//
//      if window looses activation, fullscreen mode will be disabled
//      DDM_DRAW will return DISPLAYDIB_NOTACTIVE if you try to draw
//
//      forwards all mouse and keyboard events to owner, easy way
//      to take over entire screen.
//
//      alows interop with a Win32 application (via WM_COPYDATA)
//      NOTE WM_COPYDATA does not actualy copy anything if the
//      window belongs to the calling thread.  it will do a copy
//      if the window is owned by another thread....
//
//  you can use a DisplayDibWindow in two ways.....
//
//      hidden window
//
//          if the window is hidden, you must use the
//          DDM_BEGIN and DDM_END message to enable/disable
//          fullscreen mode manualy when your app is activated deactivated.
//
//      visible toplevel window
//
//          if you show the window it will take over the entire screen
//          and forward all mouse/keyboard input to its owner.
//
//          it will enter fullscreen automaticly when it is shown.
//
//          it will leave fullscreen and hide it self it another app
//          grabs the focus.
//
//  class name:     "DisplayDibWindow"
//                  class is registered when DISPDIB.DLL is loaded.
//                  as a global class.
//
//  messages:
//
//      DDM_SETFMT  set new DIB format or program a new palette
//
//		    fullscreen mode, will use best mode
//                  for displaying the passed DIB format.
//		    defaul is 320x240x8 tripple buffered
//
//                  the palette will be programed with the color
//                  table of the passed BITMAPINFOHEADER.
//
//                  the format is a BITMAPINFOHEADER followed by a color table.
//
//                  you must set a format before doing a begin, end or draw
//                  you can set a 320x200 or a 320x24 mode by selecting
//                  a DIB of the format you want.
//
//                  if you do a setfmt while fullscreen mode is active only the
//                  the palette will be changed the new size (if any) wont
//                  happen until the next begin.
//
//	    wParam = 0
//          lParam = LPBITMAPINFOHEADER
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_DRAW    draws DIB data to fullscreen
//                  format is assumed the same as format passed to
//                  DDM_BEGIN or DDM_FMT
//
//          wParam = flags
//          lParam = bits pointer.
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_CLOSE   destroy window *and* free the DLL
//
//      DDM_BEGIN   enter DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_END     leave DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      WM_COPYDATA allows a Win32 app to send a DDM_ message, that requires
//      a pointer.
//
//          wParam = hwnd of sender
//          lParam = PCOPYDATASTRUCT
//                  dwData      - LOWORD: DDM_* message value.
//                  dwData      - HIWORD: wParam for message
//                  lpData      - lParam (pointer to a BITMAPINFOHEADER or bits)
//                  cbData      - size of data
//
//          returns   0 if success else DISPLAYDIB_* error code.
//

#define DISPLAYDIB_WINDOW_CLASS     "DisplayDibWindow"
#define DISPLAYDIB_DLL              "DISPDIB.DLL"

#define DDM_SETFMT      WM_USER+0
#define DDM_DRAW        WM_USER+1
#define DDM_CLOSE       WM_USER+2
#define DDM_BEGIN       WM_USER+3
#define DDM_END         WM_USER+4

//
// inline function to send a message to a DisplayDibWindow
//
__inline UINT DisplayDibWindowMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, DWORD cbSize)
{
#if defined(_WIN32) || defined(WIN32)
        COPYDATASTRUCT cds;
        cds.dwData = MAKELONG(msg, wParam);
        cds.cbData = lParam ? cbSize : 0;
        cds.lpData = (LPVOID)lParam;
        return (UINT)SendMessage(hwnd, WM_COPYDATA, (WPARAM)(HWND)NULL, (LPARAM)(LPVOID)&cds);
#else
        return (UINT)SendMessage(hwnd, msg, wParam, lParam);
#endif
}

//
// inline function to create a DisplayDibWindow
//
__inline HWND DisplayDibWindowCreateEx(HWND hwndParent, HINSTANCE hInstance, DWORD dwStyle)
{
#if defined(_WIN32) || defined(WIN32)
    DWORD show = 2;
    DWORD zero = 0;
    LPVOID params[4] = {NULL, &zero, &show, 0};

    if ((UINT)LoadModule(DISPLAYDIB_DLL, &params) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#else
    if ((UINT)LoadLibrary(DISPLAYDIB_DLL) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#endif

    return CreateWindow(DISPLAYDIB_WINDOW_CLASS,"",dwStyle,0, 0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN),
            hwndParent, NULL,
            (hInstance ? hInstance : GetWindowInstance(hwndParent)), NULL);
}

//
//  helper macros for a DisplayDibWindow
//
//  DisplayDibWindowCreate
//
//      used to create a toplevel WS_POPUP window.
//
//  DisplayDibWindowCreateEx
//
//      used to create a non-toplevel window, of a custom style.
//
//  DisplayDibWindowSetFmt
//
//      macro to send the DDM_SETFMT message.
//
//  DisplayDibWindowDraw
//
//      macro to send the DDM_DRAW message
//
//  DisplayDibWindowBegin
//
//      macro used to show the window
//
//  DisplayDibWindowEnd
//
//      macro used to hide the window
//
//  DisplayDibWindowBeginEx
//
//      macro used to send a DDM_BEGIN message, used with hidden windows
//
//  DisplayDibWindowEndEx
//
//      macro used to send a DDM_END message, used with hidden windows
//
//  DisplayDibWindowClose
//
//      macro used to send a DDM_CLOSE message
//      this will destroy the window and free the DLL.
//
//  NOTES
//      warning DisplayDibWindowBegin/End will show the DisplayDibWindow
//      this will steal actiation away from your app. all mouse keyboard
//      input will go to the dispdib window and it will forward it to
//      its owner (make sure you set the right owner on create)
//
//      this may cause a problem for your app, you can keep the window
//      hidden be using the DDM_BEGIN/END messages in this case.
//
#define DisplayDibWindowCreate(hwndP, hInstance)        DisplayDibWindowCreateEx(hwndP, hInstance, WS_POPUP)
#define DisplayDibWindowSetFmt(hwnd, lpbi)              DisplayDibWindowMessage(hwnd, DDM_SETFMT, 0, (LPARAM)(LPVOID)(lpbi), sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD))
#define DisplayDibWindowDraw(hwnd, flags, bits, size)   DisplayDibWindowMessage(hwnd, DDM_DRAW, (WPARAM)(UINT)(flags), (LPARAM)(LPVOID)(bits), (DWORD)(size))

#ifdef __cplusplus
#define DisplayDibWindowBegin(hwnd)                     ::ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ::ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd, f)                ::SendMessage(hwnd, DDM_BEGIN, (WPARAM)(UINT)(f), 0)
#define DisplayDibWindowEndEx(hwnd)                     ::SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     ::SendMessage(hwnd, DDM_CLOSE, 0, 0)
#else
#define DisplayDibWindowBegin(hwnd)                     ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd)                   SendMessage(hwnd, DDM_BEGIN, 0, 0)
#define DisplayDibWindowEndEx(hwnd)                     SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     SendMessage(hwnd, DDM_CLOSE, 0, 0)
#endif

#endif // _DISPDIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dls2.h ===
/*

 	dls2.h

 	Description:

 	Interface defines and structures for the DLS2 extensions of DLS.


     Written by Microsoft 1998.  Released for public use.

*/

#ifndef _INC_DLS2
#define _INC_DLS2

/*
     FOURCC's used in the DLS2 file, in addition to DLS1 chunks
*/

#define FOURCC_RGN2  mmioFOURCC('r','g','n','2')
#define FOURCC_LAR2  mmioFOURCC('l','a','r','2')
#define FOURCC_ART2  mmioFOURCC('a','r','t','2')
#define FOURCC_CDL   mmioFOURCC('c','d','l',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')

/*
     Articulation connection graph definitions. These are in addition to
     the definitions in the DLS1 header.
*/

/* Generic Sources (in addition to DLS1 sources. */
#define CONN_SRC_POLYPRESSURE		0x0007	/* Polyphonic Pressure */
#define CONN_SRC_CHANNELPRESSURE		0x0008	/* Channel Pressure */
#define CONN_SRC_VIBRATO			0x0009	/* Vibrato LFO */
#define CONN_SRC_MONOPRESSURE       	0x000a  /* MIDI Mono pressure */


/* Midi Controllers */
#define CONN_SRC_CC91			0x00db	/* Reverb Send */
#define CONN_SRC_CC93			0x00dd	/* Chorus Send */


/* Generic Destinations */
#define CONN_DST_GAIN			0x0001	/* Same as CONN_DST_ ATTENUATION, but more appropriate terminology. */
#define CONN_DST_KEYNUMBER 0x0005  /* Key Number Generator */

/* Audio Channel Output Destinations */
#define CONN_DST_LEFT			0x0010	/* Left Channel Send */
#define CONN_DST_RIGHT			0x0011	/* Right Channel Send */
#define CONN_DST_CENTER			0x0012	/* Center Channel Send */
#define CONN_DST_LEFTREAR			0x0013	/* Left Rear Channel Send */
#define CONN_DST_RIGHTREAR			0x0014	/* Right Rear Channel Send */
#define CONN_DST_LFE_CHANNEL		0x0015	/* LFE Channel Send */
#define CONN_DST_CHORUS			0x0080	/* Chorus Send */
#define CONN_DST_REVERB			0x0081	/* Reverb Send */

/* Vibrato LFO Destinations */
#define CONN_DST_VIB_FREQUENCY		0x0114	/* Vibrato Frequency */
#define CONN_DST_VIB_STARTDELAY		0x0115	/* Vibrato Start Delay */

/* EG1 Destinations */
#define CONN_DST_EG1_DELAYTIME		0x020B	/* EG1 Delay Time */
#define CONN_DST_EG1_HOLDTIME		0x020C	/* EG1 Hold Time */
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define CONN_DST_EG1_SHUTDOWNTIME	0x020D	/* EG1 Shutdown Time */
#endif

/* EG2 Destinations */
#define CONN_DST_EG2_DELAYTIME		0x030F	/* EG2 Delay Time */
#define CONN_DST_EG2_HOLDTIME		0x0310	/* EG2 Hold Time */


/* Filter Destinations */
#define CONN_DST_FILTER_CUTOFF		0x0500	/* Filter Cutoff Frequency */
#define CONN_DST_FILTER_Q			0x0501	/* Filter Resonance */


/* Transforms */
#define CONN_TRN_CONVEX			0x0002	/* Convex Transform */
#define CONN_TRN_SWITCH			0x0003	/* Switch Transform */


/*	Conditional chunk operators */
 #define DLS_CDL_AND			0x0001	/* X = X & Y */
 #define DLS_CDL_OR			0x0002	/* X = X | Y */
 #define DLS_CDL_XOR			0x0003	/* X = X ^ Y */
 #define DLS_CDL_ADD			0x0004	/* X = X + Y */
 #define DLS_CDL_SUBTRACT		0x0005	/* X = X - Y */
 #define DLS_CDL_MULTIPLY		0x0006	/* X = X * Y */
 #define DLS_CDL_DIVIDE		0x0007	/* X = X / Y */
 #define DLS_CDL_LOGICAL_AND	0x0008	/* X = X && Y */
 #define DLS_CDL_LOGICAL_OR		0x0009	/* X = X || Y */
 #define DLS_CDL_LT			0x000A	/* X = (X < Y) */
 #define DLS_CDL_LE			0x000B	/* X = (X <= Y) */
 #define DLS_CDL_GT			0x000C	/* X = (X > Y) */
 #define DLS_CDL_GE			0x000D	/* X = (X >= Y) */
 #define DLS_CDL_EQ			0x000E	/* X = (X == Y) */
 #define DLS_CDL_NOT			0x000F	/* X = !X */
 #define DLS_CDL_CONST		0x0010	/* 32-bit constant */
 #define DLS_CDL_QUERY		0x0011	/* 32-bit value returned from query */
 #define DLS_CDL_QUERYSUPPORTED	0x0012	/* Test to see if query is supported by synth */

/*
  Loop and release
*/

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 and SPs */
#define WLOOP_TYPE_RELEASE 2
#else
#define WLOOP_TYPE_RELEASE 1
#endif

/*
  WaveLink chunk <wlnk-ck>
*/

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define F_WAVELINK_MULTICHANNEL 0x0002
#endif

/*
  WaveLink chunk <wlnk-ck>
*/

#define F_WAVELINK_MULTICHANNEL 0x0002


/*
  DLSID queries for <cdl-ck>
*/

DEFINE_GUID(DLSID_GMInHardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_GSInHardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_XGInHardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS1, 0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS2, 0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(DLSID_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_ManufacturersID, 0xb03e1181, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_ProductID, 0xb03e1182, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

#endif /* _INC_DLS2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#ifndef MAKEFOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT        1
#define DMUS_DOWNLOADINFO_WAVE              2
#define DMUS_DOWNLOADINFO_INSTRUMENT2       3   /* New version for better DLS2 support. */

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* Support for oneshot and streaming wave data */
#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   /* Wave articulation data */
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   /* One chunk of a streaming */
#define DMUS_DOWNLOADINFO_ONESHOTWAVE       6

#endif

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */

#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE];
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef struct _DMUS_WAVEARTDL
{
    ULONG               ulDownloadIdIdx;    /* Download ID's of each buffer */
    ULONG               ulBus;              /* Playback bus */
    ULONG               ulBuffers;          /* Buffers */
    ULONG               ulMasterDLId;       /* Download ID of master voice of slave group */
    USHORT              usOptions;          /* Same as DLS2 region options */
}   DMUS_WAVEARTDL,
    *LPDMUS_WAVEARTDL;

typedef struct _DMUS_WAVEDL
{
    ULONG               cbWaveData;         /* Bytes of wave data */
}   DMUS_WAVEDL,
    *LPDMUS_WAVEDL;

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#endif /* _DMDLS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmoreg.h ===
//------------------------------------------------------------------------------
// File: DMOReg.h
//
// Desc: 
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMOREG_H__
#define __DMOREG_H__

#include "mediaobj.h"


// 57f2db8b-e6bb-4513-9d43-dcd2a6593125
DEFINE_GUID(DMOCATEGORY_AUDIO_DECODER, 0x57f2db8b,0xe6bb,0x4513,0x9d,0x43,0xdc,0xd2,0xa6,0x59,0x31,0x25);
// 33D9A761-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_AUDIO_ENCODER, 0x33D9A761,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// 4a69b442-28be-4991-969c-b500adf5d8a8
DEFINE_GUID(DMOCATEGORY_VIDEO_DECODER, 0x4a69b442,0x28be,0x4991,0x96,0x9c,0xb5,0x00,0xad,0xf5,0xd8,0xa8);
// 33D9A760-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_VIDEO_ENCODER, 0x33D9A760,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// f3602b3f-0592-48df-a4cd-674721e7ebeb
DEFINE_GUID(DMOCATEGORY_AUDIO_EFFECT, 0xf3602b3f,0x0592,0x48df,0xa4,0xcd,0x67,0x47,0x21,0xe7,0xeb,0xeb);
// d990ee14-776c-4723-be46-3da2f56f10b9
DEFINE_GUID(DMOCATEGORY_VIDEO_EFFECT, 0xd990ee14,0x776c,0x4723,0xbe,0x46,0x3d,0xa2,0xf5,0x6f,0x10,0xb9);
// f665aaba-3e09-4920-aa5f-219811148f09
DEFINE_GUID(DMOCATEGORY_AUDIO_CAPTURE_EFFECT, 0xf665aaba,0x3e09,0x4920,0xaa,0x5f,0x21,0x98,0x11,0x14,0x8f,0x09);

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(DMOCATEGORY_ACOUSTIC_ECHO_CANCEL, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_AUDIO_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(DMOCATEGORY_AUDIO_NOISE_SUPPRESS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(DMOCATEGORY_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

typedef struct _DMO_PARTIAL_MEDIATYPE {
   GUID type;
   GUID subtype;
} DMO_PARTIAL_MEDIATYPE, *PDMO_PARTIAL_MEDIATYPE;

enum DMO_REGISTER_FLAGS {
   DMO_REGISTERF_IS_KEYED = 0x00000001
};

enum DMO_ENUM_FLAGS {
   DMO_ENUMF_INCLUDE_KEYED = 0x00000001
};

STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   //
   // Register all mediatypes supported by the object.  This carries no
   // information about which combinations of input/output types would
   // actually work.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
);

STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory // optional - GUID_NULL means unregister from all
);

STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   //
   // Enumerate only objects that support at least one of the specified input types
   // and at least one of the specified output types.  If no input types are specified,
   // enumerate objects regardless of what input types they support.  Same for
   // output types.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes, // can be NULL only of ulOutTypes = 0
   //
   // Output parameter - this receives a pointer to the DMO CLSID enumerator
   //
   IEnumDMO **ppEnum
);

STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

STDAPI DMOGetName(
   REFCLSID clsidDMO,
   __out_ecount(80) WCHAR szName[80]
);
#endif //__DMOREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmort.h ===
//------------------------------------------------------------------------------
// File: DMORt.h
//
// Desc: Miscellaneous runtime support for DirectShow Media Objects
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMORT_H__
#define __DMORT_H__

//
// Mediatype helpers.  MoInitMediaType() goes with MoFreeMediaType(), and
// MoCreateMediaType() goes with MoDeleteMediaType().  Don't mix them!
//



//
// Takes a pointer to an already allocated DMO_MEDIA_TYPE structure, allocates
// a format block of cbFormat bytes, and sets appropriate members of
// DMO_MEDIA_TYPE to point to the newly allocated format block.  Also
// initializes the IUnknown pointer inside DMO_MEDIA_TYPE to NULL.
//
// The format block allocated by MoInitMediaType must be freed by calling
// MoFreeMediaType().
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, DWORD cbFormat);

//
// Frees the format block and releases any IUnknown, but does not free the
// DMO_MEDIA_TYPE structure itself.  Input parameter must point to an
// DMO_MEDIA_TYPE structure previously initialized by MoInitMediaType().
//
STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt);

//
// Copies the DMO_MEDIA_TYPE members.  Also duplicates the format block and
// the IUnknown pointer.  Both parameters must point to valid DMO_MEDIA_TYPE
// structures.  Target structure must be later freed using MoFreeMediaType().
//
STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, const DMO_MEDIA_TYPE *pmtSrc);



//
// Allocates a new DMO_MEDIA_TYPE structure and initializes it just like
// MoInitMediaType.  I.e., this function allocates both the format block
// and the DMO_MEDIA_TYPE structure itself.  Pointer to DMO_MEDIA_TYPE is
// returned as *ppmt.
//
// DMO_MEDIA_TYPE structures allocated by MoCreateMediaType() must be freed
// by calling MoDeleteMediaType().
//
STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, DWORD cbFormat);

//
// Frees any format block, releases any IUnknown, and deletes the
// DMO_MEDIA_TYPE structure itself.  The input parameter must point to an
// DMO_MEDIA_TYPE structure previously allocated by MoCreateMediaType().
//
STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt);

//
// Allocates a new DMO_MEDIA_TYPE structure and copies pmtSrc into it like
// MoCopyMediaType.  I.e., this function allocates a new DMO_MEDIA_TYPE struct
// as well as a new format block for the target mediatype.  Trager mediatype
// must later be freed using MoDeleteMediaType().
//
STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, const DMO_MEDIA_TYPE *pmtSrc);



#endif //__DMORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmodshow.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dmodshow.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dmodshow_h__
#define __dmodshow_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDMOWrapperFilter_FWD_DEFINED__
#define __IDMOWrapperFilter_FWD_DEFINED__
typedef interface IDMOWrapperFilter IDMOWrapperFilter;
#endif 	/* __IDMOWrapperFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "mediaobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dmodshow_0000_0000 */
/* [local] */ 

DEFINE_GUID(CLSID_DMOWrapperFilter, 0x94297043,0xbd82,0x4dfd,0xb0,0xde,0x81,0x77,0x73,0x9c,0x6d,0x20);
DEFINE_GUID(CLSID_DMOFilterCategory,0xbcd5796c,0xbd52,0x4d30,0xab,0x76,0x70,0xf9,0x75,0xb8,0x91,0x99);


extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_s_ifspec;

#ifndef __IDMOWrapperFilter_INTERFACE_DEFINED__
#define __IDMOWrapperFilter_INTERFACE_DEFINED__

/* interface IDMOWrapperFilter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOWrapperFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52d6f586-9f0f-4824-8fc8-e32ca04930c2")
    IDMOWrapperFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            __RPC__in REFCLSID clsidDMO,
            __RPC__in REFCLSID catDMO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOWrapperFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOWrapperFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOWrapperFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOWrapperFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDMOWrapperFilter * This,
            __RPC__in REFCLSID clsidDMO,
            __RPC__in REFCLSID catDMO);
        
        END_INTERFACE
    } IDMOWrapperFilterVtbl;

    interface IDMOWrapperFilter
    {
        CONST_VTBL struct IDMOWrapperFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOWrapperFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOWrapperFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOWrapperFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOWrapperFilter_Init(This,clsidDMO,catDMO)	\
    ( (This)->lpVtbl -> Init(This,clsidDMO,catDMO) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOWrapperFilter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmmdiag.h ===
/*++

Copyright (c) 2004-2006  Microsoft Corporation

Module Name:
    DmmDiag.hxx

Abstract:
    This modules contains the definition of DMM diagnosibility serialization format.

Author:

--*/

#ifndef _DMM_DIAG_H_
#define _DMM_DIAG_H_

#include <d3dkmdt.h>

#if defined(ASSERT)

    #define DMM_OPTIONAL_ASSERT(exp) ASSERT(exp)

#else

    #define DMM_OPTIONAL_ASSERT(exp)

#endif


// NOTE: Increment minor version each time format changes between builds.
//       Increment major version each time format is released publically.
//
// The first 4 bits is the major version, the remaining 12 bits are the minor version.
enum
{
    DMM_DIAG_INFO_VISTA_BETA2_VERSION = 0x1001,
    DMM_DIAG_INFO_VISTA_RC1_VERSION   = 0x1002,
    DMM_DIAG_INFO_VISTA_RTM_VERSION   = 0x1003,

    DMM_DIAG_INFO_VERSION             = DMM_DIAG_INFO_VISTA_RTM_VERSION
};


typedef struct _DMM_DIAG_INFO_INDEX
{
    // Version of diagnosibility info format (= DMM_DIAG_INFO_VERSION)
    USHORT  Version;

    // Size of entire DMM diagnosibility serialization
    ULONG  Size;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // video present target set of type DMM_VIDEOPRESENTSOURCESET_SERIALIZATION.
    ULONG  VideoPresentSourceSetSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // video present target set of type DMM_VIDEOPRESENTTARGETSET_SERIALIZATION.
    ULONG  VideoPresentTargetSetSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // active VidPN of type DMM_VIDPN_SERIALIZATION.
    ULONG  ActiveVidPnSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // recently committed VidPNs of type DMM_VIDPNSET_SERIALIZATION.
    ULONG  RecentlyCommittedVidPnsSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // connected monitors of type DMM_MONITORSET_SERIALIZATION.
    ULONG  ConnectedMonitorsSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // recently requested mode changes of type DMM_DISPMODECHANGEREQUEST_SERIALIZATION.
    ULONG  RecentlyRequestedDispModeChangesSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // recently recommended functional VidPNs of type DMM_VIDPNSET_SERIALIZATION.
    ULONG  RecentlyRecommendedFunctionalVidPnsSerializationOffset;

    // Offset (from base of this DMM_DIAG_INFO_INDEX instance) to serialization of
    // recent monitor presence events of type DMM_MONITORPRESENCEEVENTSET_SERIALIZATION.
    ULONG  RecentMonitorPresenceEventsSerializationOffset;
}
DMM_DIAG_INFO_INDEX;


typedef struct _DMM_VIDEOPRESENTSOURCE_SERIALIZATION
{
    // Video present source ID.
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  Id;

    // For keeping track of whether this source is attached to the desktop or not.
    BOOLEAN  IsAttachedToDesktop;

    // Predicate specifying whether corresponding video present source's primary is being presented.
    BOOLEAN  IsPrimaryVisible;
}
DMM_VIDEOPRESENTSOURCE_SERIALIZATION;


typedef struct _DMM_VIDEOPRESENTSOURCESET_SERIALIZATION
{
    // Number of video present targets.
    UCHAR  NumSources;

    // NOTE: Number of elements is specified by NumSources.
    //
    // Predicate array specifying whether corresponding video present source is presented.
    __field_ecount_full(NumSources) DMM_VIDEOPRESENTSOURCE_SERIALIZATION SourceSerialization[1];
}
DMM_VIDEOPRESENTSOURCESET_SERIALIZATION;


typedef struct _DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION
{
    // Path info.
    D3DKMDT_VIDPN_PRESENT_PATH  PathInfo;

    // Target mode info.
    D3DKMDT_VIDPN_TARGET_MODE  TargetMode;
}
DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION;


typedef struct _DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION
{
    // VidPN source mode serialization.
    D3DKMDT_VIDPN_SOURCE_MODE  SourceMode;

    // Number of paths originating from this source.
    UCHAR  NumPathsFromSource;

    // NOTE: Number of elements is specified by NumPathsFromSource.
    //
    // Serializations of each path originating from source in question and corresponding target mode.
    __field_ecount_full(NumPathsFromSource) DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION  PathAndTargetModeSerialization[1];
}
DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION;


// NOTE: Use GetPathsFromSourceSerialization() to access paths-from-source serializations.
typedef struct _DMM_VIDPN_SERIALIZATION
{
    // Size in bytes of this VidPN serialization.
    ULONG  Size;

    // Number of active sources in the serialized VidPN.
    UCHAR  NumActiveSources;

    // NOTE: Number of elements is specified by NumActiveSources.
    //
    // Offsets (from base of this DMM_VIDPN_SERIALIZATION instance) to serialization of
    // paths-from-source info of type DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION.
    __field_ecount_full(NumActiveSources) ULONG  PathsFromSourceSerializationOffsets[1];
}
DMM_VIDPN_SERIALIZATION;

typedef struct _DMM_VIDPNSET_SERIALIZATION
{
    // Number of VidPNs.
    UCHAR  NumVidPns;

    // Offset (from base of this DMM_VIDPNSET_SERIALIZATION instance) to serialization
    // of VidPN instance of type DMM_VIDPN_SERIALIZATION.
    __field_ecount_full(NumVidPns) ULONG  VidPnOffset[1];
}
DMM_VIDPNSET_SERIALIZATION;


__inline
DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION*
GetPathsFromSourceSerialization
(
  __in_bcount(sizeof(DMM_VIDPN_SERIALIZATION)) const DMM_VIDPN_SERIALIZATION* const  i_pVidPnSerialization,
  __in_range(0, i_pVidPnSerialization->NumActiveSources - 1) const UCHAR             i_ucActiveSourceIndex
)
{
    ULONG  ulPathsFromSourceSerializationOffset;

    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pVidPnSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_ucActiveSourceIndex < i_pVidPnSerialization->NumActiveSources );
    }

    ulPathsFromSourceSerializationOffset = i_pVidPnSerialization->PathsFromSourceSerializationOffsets[i_ucActiveSourceIndex];

    // State validation (checked-only).
    DMM_OPTIONAL_ASSERT( ulPathsFromSourceSerializationOffset != 0 );

    return (DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION*)((UCHAR*)i_pVidPnSerialization + ulPathsFromSourceSerializationOffset);
}

__inline
DMM_VIDPN_SERIALIZATION*
GetVidPnSerialization
(
  __in_bcount(sizeof(DMM_VIDPNSET_SERIALIZATION)) const DMM_VIDPNSET_SERIALIZATION *const  i_pVidPnSetSerialization,
  __in_range(0, i_pVidPnSetSerialization->NumVidPns - 1) const UCHAR                       i_ucVidPnIndex
)
{
    ULONG  ulVidPnOffset;

    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pVidPnSetSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_ucVidPnIndex < i_pVidPnSetSerialization->NumVidPns );
    }

    ulVidPnOffset = i_pVidPnSetSerialization->VidPnOffset[i_ucVidPnIndex];

    // State validation (checked-only).
    DMM_OPTIONAL_ASSERT( ulVidPnOffset != 0 );

    return (DMM_VIDPN_SERIALIZATION*)((UCHAR*)i_pVidPnSetSerialization + ulVidPnOffset);
}


typedef enum _DMM_VIDEO_PRESENT_TARGET_OWNERSHIP
{
    DMM_VPTO_UNINITIALIZED = 0,
    DMM_VPTO_SHARED        = 1,  // target is available for use by any DMM client
    DMM_VPTO_EXCLUSIVE     = 2   // target is owned by DxgPort
}
DMM_VIDEO_PRESENT_TARGET_OWNERSHIP;


typedef struct _DMM_VIDEOPRESENTTARGET_SERIALIZATION
{
    // Target info.
    D3DKMDT_VIDEO_PRESENT_TARGET  Info;

    // Type of ownership this target is under.
    DMM_VIDEO_PRESENT_TARGET_OWNERSHIP  Ownership;

} DMM_VIDEOPRESENTTARGET_SERIALIZATION;


typedef struct _DMM_VIDEOPRESENTTARGETSET_SERIALIZATION
{
    // Number of video present targets.
    UCHAR  NumTargets;

    // NOTE: Number of elements is specified by NumTargets.
    //
    // Serialization of each video present target
    __field_ecount_full(NumTargets) DMM_VIDEOPRESENTTARGET_SERIALIZATION  TargetSerialization[1];

} DMM_VIDEOPRESENTTARGETSET_SERIALIZATION;


typedef struct _DMM_MONITOR_SOURCE_MODE_SERIALIZATION
{
    // Mode info.
    D3DKMDT_MONITOR_SOURCE_MODE  Info;

    // Type of timings (e.g. established, standard, detailed, etc.).
    D3DKMDT_MONITOR_TIMING_TYPE  TimingType;
}
DMM_MONITOR_SOURCE_MODE_SERIALIZATION;


typedef struct _DMM_MONITORSOURCEMODESET_SERIALIZATION
{
    // Number of monitor source modes.
    UCHAR  NumModes;

    // NOTE: Number of elements is specified by NumModes.
    //
    // Serializations of each mode.
    __field_ecount_full(NumModes) DMM_MONITOR_SOURCE_MODE_SERIALIZATION  ModeSerialization[1];
}
DMM_MONITORSOURCEMODESET_SERIALIZATION;


typedef struct _DMM_MONITORFREQUENCYRANGESET_SERIALIZATION
{
    // Number of monitor frequency ranges.
    UCHAR  NumFrequencyRanges;

    // NOTE: Number of elements is specified by NumFrequencyRanges.
    //
    // Serializations of each frequency range.
    __field_ecount_full(NumFrequencyRanges) D3DKMDT_MONITOR_FREQUENCY_RANGE  FrequencyRangeSerialization[1];
}
DMM_MONITORFREQUENCYRANGESET_SERIALIZATION;


// LIMITATION: Only 128-byte descriptors are supported.
typedef struct _DMM_MONITORDESCRIPTOR_SERIALIZATION
{
    // Descriptor's ID.
    D3DKMDT_MONITOR_DESCRIPTOR_ID  Id;

    // Descriptor's type.
    D3DKMDT_MONITOR_DESCRIPTOR_TYPE  Type;

    // Origins of monitor descriptor data.
    D3DKMDT_MONITOR_CAPABILITIES_ORIGIN  Origin;

    // Descriptor data.
    UCHAR Data[128];
}
DMM_MONITORDESCRIPTOR_SERIALIZATION;


typedef struct _DMM_MONITORDESCRIPTORSET_SERIALIZATION
{
    // Number of monitor descriptors.
    UCHAR  NumDescriptors;

    // NOTE: Number of elements is specified by NumDescriptors.
    //
    // Serializations of each descriptor.
    __field_ecount_full(NumDescriptors) DMM_MONITORDESCRIPTOR_SERIALIZATION  DescriptorSerialization[1];
}
DMM_MONITORDESCRIPTORSET_SERIALIZATION;


typedef enum _DMM_MODE_PRUNING_ALGORITHM
{
    DMM_MPA_UNINITIALIZED   = 0,
    DMM_MPA_GDI             = 1,
    DMM_MPA_VISTA           = 2,
    DMM_MPA_GDI_VISTA_UNION = 3,
    DMM_MPA_MAXVALID        = 3
}
DMM_MODE_PRUNING_ALGORITHM;


typedef struct _DMM_MONITOR_SERIALIZATION
{
    // Size in bytes of this monitor serialization.
    ULONG  Size;

    // ID of the video present target to which this monitor is connected.
    D3DDDI_VIDEO_PRESENT_TARGET_ID  VideoPresentTargetId;

    // Monitor's orientation.
    D3DKMDT_MONITOR_ORIENTATION  Orientation;

    // Predicate specifying whether monitor is simulated.
    BOOLEAN  IsSimulatedMonitor;

    // Predicate specifying whether default monitor profile caps are assumed for this monitor.
    BOOLEAN  IsUsingDefaultProfile;

    // Mode pruning algorithm used for this monitor.
    DMM_MODE_PRUNING_ALGORITHM  ModePruningAlgorithm;

    // Monitor's device power state.
    DEVICE_POWER_STATE  MonitorPowerState;

    // Offset (from base of this MONITOR_SERIALIZATION instance) to serialization of
    // monitor source mode set of type DMM_MONITORSOURCEMODESET_SERIALIZATION.
    ULONG  SourceModeSetOffset;

    // Offset (from base of this MONITOR_SERIALIZATION instance) to serialization of
    // monitor source mode set of type DMM_MONITORFREQUENCYRANGESET_SERIALIZATION.
    ULONG  FrequencyRangeSetOffset;

    // Offset (from base of this MONITOR_SERIALIZATION instance) to serialization of
    // monitor source mode set of type DMM_MONITORDESCRIPTORSET_SERIALIZATION.
    ULONG  DescriptorSetOffset;
}
DMM_MONITOR_SERIALIZATION;


typedef struct _DMM_MONITORSET_SERIALIZATION
{
    // Number of monitors.
    UCHAR  NumMonitors;

    // Offset (from base of this DMM_MONITORSET_SERIALIZATION instance) to serialization
    // of monitor instance of type DMM_MONITOR_SERIALIZATION.
    __field_ecount_full(NumMonitors) ULONG  MonitorOffset[1];
}
DMM_MONITORSET_SERIALIZATION;


typedef enum _DMM_MONITOR_PRESENCE_EVENT_TYPE
{
    DMM_MPET_UNINITIALIZED         = 0,
    DMM_MPET_ADDMONITOR            = 1,
    DMM_MPET_REMOVEMONITOR         = 2,
    DMM_MPET_DRIVERARRIVAL         = 3,
    DMM_MPET_DRIVERQUERYREMOVE     = 4,
    DMM_MPET_DRIVERREMOVECANCELLED = 5,
    DMM_MPET_DRIVERREMOVECOMPLETE  = 6,
    DMM_MPET_MAXVALID = DMM_MPET_DRIVERREMOVECOMPLETE
}
DMM_MONITOR_PRESENCE_EVENT_TYPE;


typedef struct _DMM_MONITORPRESENCEEVENT_SERIALIZATION
{
    DMM_MONITOR_PRESENCE_EVENT_TYPE  EventType;

    // ID of the video present target on which the arrival/departure happened.
    D3DDDI_VIDEO_PRESENT_TARGET_ID  VideoPresentTargetId;

    // Unique sequential identifier of the event.
    ULONG Id;

    // Event processing status
    NTSTATUS Status;

    // Time since boot in 100-nanoseconds.
    ULONG64 TimeSinceBoot;
}
DMM_MONITORPRESENCEEVENT_SERIALIZATION;


typedef struct _DMM_MONITORPRESENCEEVENTSET_SERIALIZATION
{
    // Number of monitor descriptors.
    UCHAR  NumEvents;

    // NOTE: Number of elements is specified by NumEvents.
    //
    // Serializations of each descriptor.
    __field_ecount_full(NumEvents) DMM_MONITORPRESENCEEVENT_SERIALIZATION  EventSerialization[1];
}
DMM_MONITORPRESENCEEVENTSET_SERIALIZATION;


__inline
DMM_MONITORSOURCEMODESET_SERIALIZATION*
GetMonitorSourceModeSetSerialization
(
  __in_bcount(sizeof(DMM_MONITOR_SERIALIZATION)) const DMM_MONITOR_SERIALIZATION *const  i_pMonitorSerialization
)
{
    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization->SourceModeSetOffset != 0 );
    }

    return (DMM_MONITORSOURCEMODESET_SERIALIZATION*)((UCHAR*)i_pMonitorSerialization
                                                     +
                                                     i_pMonitorSerialization->SourceModeSetOffset);
}

__inline
DMM_MONITORFREQUENCYRANGESET_SERIALIZATION*
GetMonitorFrequencyRangeSetSerialization
(
  __in_bcount(sizeof(DMM_MONITOR_SERIALIZATION)) const DMM_MONITOR_SERIALIZATION *const  i_pMonitorSerialization
)
{
    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization->FrequencyRangeSetOffset != 0 );
    }

    return (DMM_MONITORFREQUENCYRANGESET_SERIALIZATION*)((UCHAR*)i_pMonitorSerialization
                                                         +
                                                         i_pMonitorSerialization->FrequencyRangeSetOffset);
}

__inline
DMM_MONITORDESCRIPTORSET_SERIALIZATION*
GetMonitorDescriptorSetSerialization
(
  __in_bcount(sizeof(DMM_MONITOR_SERIALIZATION)) const DMM_MONITOR_SERIALIZATION *const  i_pMonitorSerialization
)
{
    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_pMonitorSerialization->DescriptorSetOffset != 0 );
    }

    return (DMM_MONITORDESCRIPTORSET_SERIALIZATION*)((UCHAR*)i_pMonitorSerialization
                                                     +
                                                     i_pMonitorSerialization->DescriptorSetOffset);
}


typedef enum _DMM_CLIENT_TYPE
{
    DMM_CT_UNINITIALIZED  = 0,
    DMM_CT_CDD_NOPATHDATA = 1,  // legacy GDI mode change that does not contain VidPN path data
    DMM_CT_USERMODE       = 2,  // mode change initiated via the SetDisplayMode user-mode thunk                      (LDDM specific)
    DMM_CT_CDD_PATHDATA   = 3,  // kernel-mode initiated mode change that specifies VidPN path data                  (LDDM-specific)
    DMM_CT_DXGPORT        = 4   // mode change initiated by Port via Dmm{Add|Remove}PresentPath{To|From}ActiveVidPn  (LDDM-specific)
}
DMM_CLIENT_TYPE;


typedef enum _DMM_VIDPNCHANGE_TYPE
{
    DMM_CVR_UNINITIALIZED  = 0,
    DMM_CVR_UPDATEMODALITY = 1, // no topology changes - only path modality is updated on the affected source.
    DMM_CVR_ADDPATH        = 2, // a single path is added to affected source.
    DMM_CVR_ADDPATHS       = 3, // multiple paths are added to affected source.
    DMM_CVR_REMOVEPATH     = 4, // a single (could be the only) path is removed from the affected source.
    DMM_CVR_REMOVEALLPATHS = 5  // all paths are removed from affected source.
}
DMM_VIDPNCHANGE_TYPE;


typedef struct _DMM_COMMITVIDPNREQUEST_DIAGINFO
{
    // Type of the client that initiated the commit VidPN in question.
    DMM_CLIENT_TYPE  ClientType : 4;

    // Type of the change performed on the active VidPN.
    DMM_VIDPNCHANGE_TYPE  VidPnChange : 4;

    // Predicate specifying whether commit VidPN in question is to reclaim a cloned target.
    unsigned char  ReclaimClonedTarget : 1;

    // Predicate specifying whether commit VidPN in question is cleaning up after a failed attempt to commit another VidPN.
    unsigned char  CleanupAfterFailedCommitVidPn : 1;
}
DMM_COMMITVIDPNREQUEST_DIAGINFO;


typedef struct _DMM_COMMITVIDPNREQUEST_SERIALIZATION
{
    // ID of the source affected by the VidPN requested to be committed.
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  AffectedVidPnSourceId;

    // Type of the scenario for which client requested to commit the VidPN in question.
    DMM_COMMITVIDPNREQUEST_DIAGINFO  RequestDiagInfo;

    // Copy of the VidPN that was requested to be committed.
    DMM_VIDPN_SERIALIZATION  VidPnSerialization;
}
DMM_COMMITVIDPNREQUEST_SERIALIZATION;


typedef struct _DMM_COMMITVIDPNREQUESTSET_SERIALIZATION
{
    // Number of commit VidPN requests
    UCHAR  NumCommitVidPnRequests;

    // Offset (from base of this DMM_COMMITVIDPNREQUESTSET_SERIALIZATION instance) to serialization
    // of VidPN instance of type DMM_COMMITVIDPNREQUEST_SERIALIZATION.
    __field_ecount_full(NumCommitVidPnRequests) ULONG  CommitVidPnRequestOffset[1];
}
DMM_COMMITVIDPNREQUESTSET_SERIALIZATION;

__inline
DMM_COMMITVIDPNREQUEST_SERIALIZATION*
GetCommitVidPnRequestSerialization
(
  __in_bcount(sizeof(DMM_COMMITVIDPNREQUESTSET_SERIALIZATION)) const DMM_COMMITVIDPNREQUESTSET_SERIALIZATION *const  i_pCommitVidPnRequestSetSerialization,
  __in_range(0, i_pCommitVidPnRequestSetSerialization->NumCommitVidPnRequests- 1) const UCHAR                        i_ucCommitVidPnRequestIndex
)
{
    ULONG  ulVidPnOffset;

    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pCommitVidPnRequestSetSerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_ucCommitVidPnRequestIndex < i_pCommitVidPnRequestSetSerialization->NumCommitVidPnRequests);
    }

    ulVidPnOffset = i_pCommitVidPnRequestSetSerialization->CommitVidPnRequestOffset[i_ucCommitVidPnRequestIndex];

    // State validation (checked-only).
    DMM_OPTIONAL_ASSERT( ulVidPnOffset != 0 );

    return (DMM_COMMITVIDPNREQUEST_SERIALIZATION*)((UCHAR*)i_pCommitVidPnRequestSetSerialization + ulVidPnOffset);
}

#define DMM_DISPMODECHANGEREQUEST_PROCESS_NAME_SIZE 16

typedef struct _DMM_DISPMODECHANGEREQUEST_SERIALIZATION
{
    // ID of the video present source on which the mode change has been requested.
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VideoPresentSourceId;

    // Display mode info.
    D3DKMT_DISPLAYMODE  ModeInfo;

    // Type of DMM client that requested the mode change.
    DMM_CLIENT_TYPE  ClientType;

    // Status of mode change request execution.
    NTSTATUS  ModeChangeStatus;

    // Unique identifier of the mode change request.
    ULONG Id;

    // Time since boot in 100-nanoseconds.
    ULONG64 TimeSinceBoot;

    // Requestor process name
    UCHAR ProcessName[DMM_DISPMODECHANGEREQUEST_PROCESS_NAME_SIZE];
}
DMM_DISPMODECHANGEREQUEST_SERIALIZATION;


typedef struct _DMM_DISPMODECHANGEREQUESTSET_SERIALIZATION
{
    // Number of display mode change requests
    UCHAR  NumDispModeChangeRequests;

    // NOTE: Number of elements is specified by NumDispModeChangeRequests.
    //
    // Serializations of each display mode change request.
    __field_ecount_full(NumDispModeChangeRequests) DMM_DISPMODECHANGEREQUEST_SERIALIZATION  DispModeChangeRequestSerialization[1];
}
DMM_DISPMODECHANGEREQUESTSET_SERIALIZATION;


typedef struct _DMM_VIDPNSOURCEMODESET_SERIALIZATION
{
    // Number of VidPN source modes.
    UCHAR  NumModes;

    // NOTE: Number of elements is specified by NumModes.
    //
    // Serializations of each display mode change request.
    D3DKMDT_VIDPN_SOURCE_MODE  ModeSerialization[1];
}
DMM_VIDPNSOURCEMODESET_SERIALIZATION;


typedef struct _DMM_VIDPNTARGETMODESET_SERIALIZATION
{
    // Number of VidPN target modes.
    UCHAR  NumModes;

    // NOTE: Number of elements is specified by NumModes.
    //
    // Serializations of each display mode change request.
    D3DKMDT_VIDPN_TARGET_MODE  ModeSerialization[1];
}
DMM_VIDPNTARGETMODESET_SERIALIZATION;


typedef struct _DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION
{
    // Path info.
    D3DKMDT_VIDPN_PRESENT_PATH  PathInfo;

    // Target mode info.
    DMM_VIDPNTARGETMODESET_SERIALIZATION  TargetModeSet;
}
DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION;


typedef struct _DMM_COFUNCPATHSMODALITY_SERIALIZATION
{
    // Number of paths originating from this source.
    UCHAR  NumPathsFromSource;

    // NOTE: Number of elements is specified by NumPathsFromSource.
    //
    // Offsets (from base of this DMM_COFUNCPATHSMODALITY_SERIALIZATION instance) to serialization of
    // path-and-target-mode-set info of type DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION.
    __field_ecount_full(NumPathsFromSource) ULONG  PathAndTargetModeSetOffset[1];
}
DMM_COFUNCPATHSMODALITY_SERIALIZATION;


__inline
DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION*
GetCofuncModalityOfPathFromSourceSerialization
(
  __in_bcount(sizeof(DMM_COFUNCPATHSMODALITY_SERIALIZATION)) const DMM_COFUNCPATHSMODALITY_SERIALIZATION* const  i_pCofuncPathModalitySerialization,
  __in_range(0, i_pCofuncPathModalitySerialization->NumPathsFromSource - 1) const UCHAR                          i_ucPathFromSourceIndex
)
{
    ULONG  ulCofuncModalityOfPathsFromSourceSerializationOffset;

    // Parameter validation (checked-only).
    {
        DMM_OPTIONAL_ASSERT( i_pCofuncPathModalitySerialization != NULL );
        DMM_OPTIONAL_ASSERT( i_ucPathFromSourceIndex < i_pCofuncPathModalitySerialization->NumPathsFromSource );
    }

    ulCofuncModalityOfPathsFromSourceSerializationOffset = i_pCofuncPathModalitySerialization->PathAndTargetModeSetOffset[i_ucPathFromSourceIndex];

    // State validation (checked-only).
    DMM_OPTIONAL_ASSERT( ulCofuncModalityOfPathsFromSourceSerializationOffset != 0 );

    return (DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION*)((UCHAR*)i_pCofuncPathModalitySerialization + ulCofuncModalityOfPathsFromSourceSerializationOffset);
}

#endif // _DMM_DIAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

#define SURFACEALIGN_DISCARDABLE	0x00000001l /* Surface can be discarded to   */
                                                    /* make room for another surface */


typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

typedef struct _DD_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    VOID*                      GetHeapAlignment;   // Unused: Win95 compatibility
    HEAPALIGNMENT              Alignment;          // Filled in by driver.
} DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
    BOOL                bDiscardable;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
    BOOL                bDiscardable;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
#if (NTDDI_VERSION >= NTDDI_WINXP)
    BYTE*                       pAgpCommitMask;
    DWORD                       dwAgpCommitMaskSize;
#endif
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmo.h ===
//------------------------------------------------------------------------------
// File: DMO.h
//
// Desc: Headers needed by almost all DMOs.
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMO_H__
#define __DMO_H__


#include "mediaerr.h"

// When using ATL we get collisions on Lock, so in this case rename
// IMediaObject::Lock to IMediaObject::DMOLock

#ifdef FIX_LOCK_NAME
#define Lock DMOLock
#endif
#include "mediaobj.h"
#ifdef FIX_LOCK_NAME
#undef Lock
#endif
#include "dmoreg.h"
#include "dmort.h"

#endif //__DMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmoimpl.h ===
//------------------------------------------------------------------------------
// File: DMOImpl.h
//
// Desc: Classes to implement a DMO
//
// Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _dmoimpl_h_
#define _dmoimpl_h_

#ifdef _DEBUG
#include <crtdbg.h>
#endif

//  Class to implement a DMO
//
//
//       Assumes the number of input and output streams is fixed
//       (these are template parameters)
//
//       Provides following services:
//
//          Basic parameter checking and locking
//          Fully implements :
//                 GetStreamCount
//                 SetInputType
//                 SetOutputType
//                 GetCurrentInputType
//                 GetCurrentOutputType
//
//          Checks if all types are set before streaming
//          Automatically calls AllocateStreamingResources before streaming
//              if it's not been called already
//          Prevents streaming until the types on all non-optional streams
//              have been set
//
//
//  Derived class implements the following methods :
//

/*
   HRESULT InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalCheckOutputType(DWORD dwOutputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize,
                            DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
   HRESULT InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize,
                             DWORD *pcbAlignment);
   HRESULT InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency);
   HRESULT InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency);
   HRESULT InternalFlush();
   HRESULT InternalDiscontinuity(DWORD dwInputStreamIndex);
   HRESULT InternalAllocateStreamingResources();
   HRESULT InternalFreeStreamingResources();
   HRESULT InternalProcessInput(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer,
                               DWORD dwFlags, REFERENCE_TIME rtTimestamp,
                               REFERENCE_TIME rtTimelength);
   HRESULT InternalProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                               DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                           DWORD *pdwStatus);
   HRESULT InternalAcceptingInput(DWORD dwInputStreamIndex);
   void Lock();
   void Unlock();

   Notes:
       The derived class is meant to do most work to initialize streaming
       in AllocateStreamingResources rather than when types are set.

       This centralizes the work to one
       clear place based on the types set for all streams.

       The derived class implements locking.

       The derived class implements the IUnknown methods

   Usage example (1 input and 1 output) :
   class CMyDMO : public IMediaObjectImpl<CMyDmo, 1, 1>,
                  ...
*/


#define INTERNAL_CALL(_T_, _X_) \
    static_cast<_T_ *>(this)->Internal##_X_

template <class _DERIVED_, int NUMBEROFINPUTS, int NUMBEROFOUTPUTS>
class IMediaObjectImpl : public IMediaObject
{
private:
    // Member variables
    struct {
        DWORD   fTypeSet:1;
        DWORD   fIncomplete:1;
        DMO_MEDIA_TYPE CurrentMediaType;
    } m_InputInfo[NUMBEROFINPUTS], m_OutputInfo[NUMBEROFOUTPUTS];

    bool m_fTypesSet;
    bool m_fFlushed;
    bool m_fResourcesAllocated;

protected:

    //  Helpers
    bool InputTypeSet(DWORD ulInputStreamIndex) const
    {
        _ASSERTE(ulInputStreamIndex < NUMBEROFINPUTS);
        return 0 != m_InputInfo[ulInputStreamIndex].fTypeSet;
    }

    bool OutputTypeSet(DWORD ulOutputStreamIndex) const
    {
        _ASSERTE(ulOutputStreamIndex < NUMBEROFOUTPUTS);
        return 0 != m_OutputInfo[ulOutputStreamIndex].fTypeSet;
    }
    const DMO_MEDIA_TYPE *InputType(DWORD ulInputStreamIndex)
    {
        if (!InputTypeSet(ulInputStreamIndex)) {
            return NULL;
        }
        return &m_InputInfo[ulInputStreamIndex].CurrentMediaType;
    }
    const DMO_MEDIA_TYPE *OutputType(DWORD ulOutputStreamIndex)
    {
        if (!OutputTypeSet(ulOutputStreamIndex)) {
            return NULL;
        }
        return &m_OutputInfo[ulOutputStreamIndex].CurrentMediaType;
    }


    class LockIt
    {
    public:
        LockIt(_DERIVED_ *p) : m_p(p)
        {
            static_cast<_DERIVED_ *>(m_p)->Lock();
        }
        ~LockIt()
        {
            static_cast<_DERIVED_ *>(m_p)->Unlock();
        }
        _DERIVED_ *const m_p;
    };

    bool CheckTypesSet()
    {
        m_fTypesSet = false;
        DWORD dw;
        for (dw = 0; dw < NUMBEROFINPUTS; dw++) {
            if (!InputTypeSet(dw)) {
                return false;
            }
        }
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (!OutputTypeSet(dw)) {
                //  Check if it's optional
                DWORD dwFlags;
#ifdef _DEBUG
                dwFlags = 0xFFFFFFFF;
#endif
                INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(dw, &dwFlags);
                _ASSERTE(0 == (dwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                         DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                         DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                         DMO_OUTPUT_STREAMF_DISCARDABLE |
                                         DMO_OUTPUT_STREAMF_OPTIONAL)));
                if (!(dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)) {
                    return false;
                }
            }
        }
        m_fTypesSet = true;
        return true;
    }


    IMediaObjectImpl() :
        m_fTypesSet(false),
        m_fFlushed(true),
        m_fResourcesAllocated(false)
    {
        ZeroMemory(&m_InputInfo, sizeof(m_InputInfo));
        ZeroMemory(&m_OutputInfo, sizeof(m_OutputInfo));
    }

    virtual ~IMediaObjectImpl() {
        DWORD dwCurrentType;

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFINPUTS; dwCurrentType++) {
            if(InputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_InputInfo[dwCurrentType].CurrentMediaType);
            }
        }

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFOUTPUTS; dwCurrentType++) {
            if(OutputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_OutputInfo[dwCurrentType].CurrentMediaType);
            }
        }
    }


    // IMediaObject methods


    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams  = NUMBEROFINPUTS;
        *pulNumberOfOutputStreams = NUMBEROFOUTPUTS;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetInputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS)));
        return hr;
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_OUTPUT_STREAMF_DISCARDABLE |
                                   DMO_OUTPUT_STREAMF_OPTIONAL)));
        return hr;
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetInputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetOutputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (InputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_InputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (OutputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_OutputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment ||
            NULL == pcbMaxLookahead) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!InputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetInputSizeInfo)(ulStreamIndex, pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet || !OutputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetOutputSizeInfo)(ulStreamIndex, pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            m_InputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckInputType)(ulStreamIndex, pmt);
        if (FAILED(hr))
           return hr;

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (InputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_InputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_InputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }

    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            m_OutputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckOutputType)(ulStreamIndex, pmt);
        if (FAILED(hr)) {
           return hr;
        }

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (OutputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_OutputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_OutputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pdwStatus) {
            return E_POINTER;
        }
        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) == S_OK) {
           *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
        }
        return NOERROR;
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {

        if (prtLatency == NULL) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, GetInputMaxLatency)(ulStreamIndex, prtLatency);
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, SetInputMaxLatency)(ulStreamIndex, rtLatency);
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (S_OK != INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex)) {
            return DMO_E_NOTACCEPTING;
        }

        return INTERNAL_CALL(_DERIVED_, Discontinuity)(ulStreamIndex);
    }

    STDMETHODIMP Flush()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return S_OK;
        }
        if (m_fFlushed) {
            return S_OK;
        }
        HRESULT hr =  INTERNAL_CALL(_DERIVED_, Flush)();
        m_fFlushed = true;
        return hr;
    }

    STDMETHODIMP AllocateStreamingResources() {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }
        if (m_fResourcesAllocated) {
            return S_OK;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, AllocateStreamingResources)();
        if (SUCCEEDED(hr)) {
            m_fResourcesAllocated = true;
        }
        return hr;
    }
    STDMETHODIMP FreeStreamingResources()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (m_fResourcesAllocated) {
            m_fResourcesAllocated = false;
            INTERNAL_CALL(_DERIVED_, Flush)();
            return INTERNAL_CALL(_DERIVED_, FreeStreamingResources)();
        }
        return S_OK;
    }

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
        if (!pBuffer) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~(DMO_INPUT_DATA_BUFFERF_SYNCPOINT |
                        DMO_INPUT_DATA_BUFFERF_TIME |
                        DMO_INPUT_DATA_BUFFERF_TIMELENGTH)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        //  Make sure all streams have media types set and resources are allocated
        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }
        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) != S_OK) {
            return DMO_E_NOTACCEPTING;
        }

        m_fFlushed = false;

        return INTERNAL_CALL(_DERIVED_, ProcessInput)(
                                    ulStreamIndex,
                                    pBuffer,
                                    dwFlags,
                                    rtTimestamp,
                                    rtTimelength);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwFlags,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
        if (pdwStatus == NULL) {
            return E_POINTER;
        }


        if (ulOutputBufferCount != NUMBEROFOUTPUTS || (dwFlags & ~DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER)) {
           return E_INVALIDARG;
        }

        if (NUMBEROFOUTPUTS != 0 && pOutputBuffers == NULL) {
            return E_POINTER;
        }

        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }

        DWORD dw;
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            pOutputBuffers[dw].dwStatus = 0;
        }

        hr = INTERNAL_CALL(_DERIVED_, ProcessOutput)(
                           dwFlags,
                           ulOutputBufferCount,
                           pOutputBuffers,
                           pdwStatus);

        // remember the DMO's incomplete status
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (pOutputBuffers[dw].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                m_OutputInfo[dw].fIncomplete = TRUE;
            } else {
                m_OutputInfo[dw].fIncomplete = FALSE;
            }
        }

        return hr;
    }

    STDMETHODIMP DMOLock(LONG lLock)
    {
        if (lLock) {
            static_cast<_DERIVED_ *>(this)->Lock();
        } else {
            static_cast<_DERIVED_ *>(this)->Unlock();
        }
        return S_OK;
    }
};

#endif // _dmoimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error codes returned by DirectMusic API's              *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif

#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools. This can also happen
 * if some content is missing. For example, if a segment uses a DLS collection that
 * is not in the loader's current search directory.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * Return value from IDirectMusicBand::Download() which indicates that
 * some of the instruments safely downloaded, but others failed. This usually
 * occurs when some instruments are on PChannels not supported by the performance
 * or port.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that no note has been calculated because the music value has the note
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that the note conversion generated a note value that is below 0,
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127.
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that the note conversion generated a note value that is above 127,
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127.
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

#endif

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open.
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format.
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors.
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port.
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT
 *
 * The track does not support clock time playback or getparam.
 */
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   MAKE_DMHRESULTERROR(0x0167)

#endif

/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
/* misspelling in previous versions of DirectX preserved for backward compatibility */
#define DMUS_E_CONNOT_CONVERT           DMUS_E_CANNOT_CONVERT

/* DMUS_E_DESCEND_CHUNK_FAIL
 *
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)


#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_E_NOT_LOADED
 *
 * An attempt to use this object failed because it first needs to
 * be loaded.
 */
#define DMUS_E_NOT_LOADED               MAKE_DMHRESULTERROR(0x0211)

/* DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE
 *
 * The activeX scripting engine for the script's language is not compatible with
 * DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  MAKE_DMHRESULTERROR(0x0213)

/* DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE
 *
 * A varient was used that had a type that is not supported by DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    MAKE_DMHRESULTERROR(0x0214)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_CANTLOAD_OLEAUT32
 *
 * Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages
 * require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only
 * the DirectMusicScript language, which doesn't require oleaut32.dll can be used.
 */
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      MAKE_DMHRESULTERROR(0x0216)

/* DMUS_E_SCRIPT_LOADSCRIPT_ERROR
 *
 * An error occured while parsing a script loaded using LoadScript.  The script that
 * was loaded contains an error.
 */
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       MAKE_DMHRESULTERROR(0x0217)

/* DMUS_E_SCRIPT_INVALID_FILE
 *
 * The script file is invalid.
 */
#define DMUS_E_SCRIPT_INVALID_FILE           MAKE_DMHRESULTERROR(0x0218)

/* DMUS_E_INVALID_SCRIPTTRACK
 *
 * The file contains an invalid script track.
 */
#define DMUS_E_INVALID_SCRIPTTRACK           MAKE_DMHRESULTERROR(0x0219)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

/* DMUS_E_INVALID_SEGMENTTRIGGERTRACK
 *
 * The file contains an invalid segment trigger track.
 */
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   MAKE_DMHRESULTERROR(0x0220)

/* DMUS_E_INVALID_LYRICSTRACK
 *
 * The file contains an invalid lyrics track.
 */
#define DMUS_E_INVALID_LYRICSTRACK           MAKE_DMHRESULTERROR(0x0221)

/* DMUS_E_INVALID_PARAMCONTROLTRACK
 *
 * The file contains an invalid parameter control track.
 */
#define DMUS_E_INVALID_PARAMCONTROLTRACK     MAKE_DMHRESULTERROR(0x0222)

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_AUDIOPATHS_NOT_VALID
 *
 * The Performance has set up some PChannels using the AssignPChannel command, which
 * makes it not capable of supporting audio paths.
 */
#define DMUS_E_AUDIOPATHS_NOT_VALID     MAKE_DMHRESULTERROR(0x0226)

/* DMUS_E_AUDIOPATHS_IN_USE
 *
 * This is the inverse of the previous error.
 * The Performance has set up some audio paths, which makes is incompatible
 * with the calls to allocate pchannels, etc.
 */
#define DMUS_E_AUDIOPATHS_IN_USE     MAKE_DMHRESULTERROR(0x0227)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment was asked for its embedded audio path configuration,
 * but there isn't any.
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

/* DMUS_E_AUDIOPATH_INACTIVE
 *
 * An audiopath is inactive, perhaps because closedown was called.
 */
#define DMUS_E_AUDIOPATH_INACTIVE     MAKE_DMHRESULTERROR(0x0229)

/* DMUS_E_AUDIOPATH_NOBUFFER
 *
 * An audiopath failed to create because a requested buffer could not be created.
 */
#define DMUS_E_AUDIOPATH_NOBUFFER     MAKE_DMHRESULTERROR(0x022A)

/* DMUS_E_AUDIOPATH_NOPORT
 *
 * An audiopath could not be used for playback because it lacked port assignments.
 */
#define DMUS_E_AUDIOPATH_NOPORT     MAKE_DMHRESULTERROR(0x022B)

/* DMUS_E_NO_AUDIOPATH
 *
 * Attempt was made to play segment in audiopath mode and there was no audiopath.
 */
#define DMUS_E_NO_AUDIOPATH     MAKE_DMHRESULTERROR(0x022C)

/* DMUS_E_INVALIDCHUNK
 *
 * Invalid data was found in a RIFF file chunk.
 */
#define DMUS_E_INVALIDCHUNK     MAKE_DMHRESULTERROR(0x022D)

/* DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER
 *
 * Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.
 */
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     MAKE_DMHRESULTERROR(0x022E)

/* DMUS_E_INVALID_CONTAINER_OBJECT
 *
 * The file does not contain a valid container object.
 */
#define DMUS_E_INVALID_CONTAINER_OBJECT    MAKE_DMHRESULTERROR(0x022F)

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#endif /* _DMERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DomDid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __DOMDID_H__
#define __DOMDID_H__
//;end_internal

//#define DISPID_DOM_BASE                 0x80010500

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_NODE                        (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME               (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE              (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE               (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM           (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE             (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES             (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD             (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD              (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING        (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING            (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES             (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE           (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD           (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD            (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD            (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES          (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC               (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE              (DISPID_DOM_NODE + 18)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_DOM_NODE + 0x20)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS)
#define DISPID_DOM_DOCUMENTFRAGMENT_TOP        (DISPID_DOM_DOCUMENTFRAGMENT + 2)

#define DISPID_DOM_DOCUMENT                        (DISPID_DOM_DOCUMENTFRAGMENT + 0x20)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENT + 0x20)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT_TOP                     (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT + 0x20)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_TOP                    (DISPID_DOM_DATA + 7)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA + 0x20)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_GETVALUE          (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE_TOP               (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE + 0x20)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT_TOP            (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT + 0x20)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI_TOP       (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI + 0x20)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE_TOP        (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE + 0x20)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION_TOP            (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION + 0x20)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY_TOP              (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY + 0x20)
    
#define DISPID_DOM_NODELIST            (DISPID_DOM_W3CWRAPPERS_TOP + 0x20)
#define DISPID_DOM_NODELIST_ITEM       (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH     (DISPID_DOM_NODELIST + 2)

#define DISPID_DOM_NAMEDNODEMAP                    (DISPID_DOM_NODELIST + 0x20)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM    (DISPID_DOM_NAMEDNODEMAP + 5)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_NAMEDNODEMAP + 0x20)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)

#define DISPID_DOM_TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dot1x.h ===
#ifndef __DOT1X_H_
#define __DOT1X_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <l2cmn.h>

#if __midl
#define V1_ENUM [v1_enum]
#else
#define V1_ENUM
#endif

/*
    The identity that is being used by the 1X module. This is a function of the
    onex auth mode and system triggers (e.g. user logon/logoff)
    */  
typedef V1_ENUM enum _ONEX_AUTH_IDENTITY 
{
    OneXAuthIdentityNone,
    OneXAuthIdentityMachine,
    OneXAuthIdentityUser,
    OneXAuthIdentityExplicitUser,
    OneXAuthIdentityGuest,
    OneXAuthIdentityInvalid
} ONEX_AUTH_IDENTITY, *PONEX_AUTH_IDENTITY;

/*
    The 1X authentication status. Each of the auth status corresponds to one or
    more of the internal 1X states. 
    */
typedef V1_ENUM enum _ONEX_AUTH_STATUS
{
    OneXAuthNotStarted,
    OneXAuthInProgress,
    OneXAuthNoAuthenticatorFound,
    OneXAuthSuccess,
    OneXAuthFailure,
    OneXAuthInvalid
} ONEX_AUTH_STATUS, *PONEX_AUTH_STATUS;

/*
    1X specific reason codes
    */
typedef V1_ENUM enum _ONEX_REASON_CODE
{
    ONEX_REASON_CODE_SUCCESS = 0,
    ONEX_REASON_START = L2_REASON_CODE_ONEX_BASE,
    ONEX_UNABLE_TO_IDENTIFY_USER,
    ONEX_IDENTITY_NOT_FOUND,
    ONEX_UI_DISABLED,
    ONEX_UI_FAILURE,
    ONEX_EAP_FAILURE_RECEIVED,
    ONEX_AUTHENTICATOR_NO_LONGER_PRESENT,
    ONEX_NO_RESPONSE_TO_IDENTITY,
    ONEX_PROFILE_VERSION_NOT_SUPPORTED,
    ONEX_PROFILE_INVALID_LENGTH,
    ONEX_PROFILE_DISALLOWED_EAP_TYPE,
    ONEX_PROFILE_INVALID_EAP_TYPE_OR_FLAG,
    ONEX_PROFILE_INVALID_ONEX_FLAGS,
    ONEX_PROFILE_INVALID_TIMER_VALUE,
    ONEX_PROFILE_INVALID_SUPPLICANT_MODE,
    ONEX_PROFILE_INVALID_AUTH_MODE,
    ONEX_PROFILE_INVALID_EAP_CONNECTION_PROPERTIES,
} ONEX_REASON_CODE, *PONEX_REASON_CODE;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dontuse.h ===
/******************************************************************
*                                                                 *
*  dontuse.h -- This module deprecates Banned APIs                *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _DONTUSE_H_INCLUDED_
#define _DONTUSE_H_INCLUDED_
#pragma once


#ifdef DEPRECATE_SUPPORTED
// First all the names that are a/w variants (or shouldn't be #defined by now anyway).


//Windows
#pragma deprecated(lstrcpyA)
#pragma deprecated(lstrcpyW)
#pragma deprecated(lstrcpynA)
#pragma deprecated(lstrcpynW)
#pragma deprecated(lstrcatA)
#pragma deprecated(lstrcatW)
#pragma deprecated(lstrcatnA)
#pragma deprecated(lstrcatnW)
#pragma deprecated(wsprintfA)
#pragma deprecated(wsprintfW)
#pragma deprecated(wvsprintfA)
#pragma deprecated(wvsprintfW)

//shlwapi
#ifndef _STRSAFE_H_INCLUDED_
#pragma deprecated(StrCpyW)
#endif
#pragma deprecated(StrNCpyW)
#pragma deprecated(StrCpyNW)
#pragma deprecated(StrCatW)
#pragma deprecated(StrNCatW)
#pragma deprecated(StrCatNW)
#pragma deprecated(wnsprintf)
#ifndef _STRSAFE_H_INCLUDED_
#pragma deprecated(wnsprintfW)
#endif
#pragma deprecated(wvnsprintfW)
#pragma deprecated(StrCatBuffW)



//crt
#pragma deprecated(gets)
#pragma deprecated(_getws)
#pragma deprecated(strcpy)
#pragma deprecated(wcscpy)
#pragma deprecated(strncat)
#pragma deprecated(wcsncat)
#pragma deprecated(strcat)
#pragma deprecated(wcscat)
#pragma deprecated(strncpy)
#pragma deprecated(wcsncpy)
#pragma deprecated(_snprintf)
#pragma deprecated(_snwprintf)
#pragma deprecated(_vsnprintf)
#pragma deprecated(_vsnwprintf)
#pragma deprecated(vsprintf)
#pragma deprecated(vswprintf)
#pragma deprecated(sprintf)
#pragma deprecated(swprintf)
#pragma deprecated(_makepath)
#pragma deprecated(_wmakepath)
#pragma deprecated(_splitpath)
#pragma deprecated(_wsplitpath)

#pragma deprecated(sprintfA)
#pragma deprecated(sprintfW)
#pragma deprecated(strcatA)
#pragma deprecated(strcatW)
#pragma deprecated(strcpyA)
#pragma deprecated(strcpyW)
#pragma deprecated(nsprintf)
#pragma deprecated(IsBadCodePtr)
#pragma deprecated(IsBadHugeReadPtr)
#pragma deprecated(IsBadHugeWritePtr)
#pragma deprecated(IsBadReadPtr)
#pragma deprecated(IsBadStringPtr)
#pragma deprecated(IsBadWritePtr)
#pragma deprecated(_ftccat)
#pragma deprecated("_ftccpy")
#pragma deprecated(_tccat)
#pragma deprecated("_tccpy")
#pragma deprecated(makepath)
#pragma deprecated(StrCatChainW)
#pragma deprecated(ualstrcpyW)

#pragma deprecated(scanf)
#pragma deprecated(wscanf)
#pragma deprecated(sscanf)
#pragma deprecated(swscanf)
#pragma deprecated(_snscanf)
#pragma deprecated(_snwscanf)
#pragma deprecated(snscanf)
#pragma deprecated("swscanf")



// Then all the windows.h names - we need to undef and redef based on UNICODE setting
#undef lstrcat
#undef lstrcatn
#undef lstrcpy
#undef lstrcpyn
#undef wsprintf
#undef wvsprintf
#pragma deprecated(lstrcat)
#pragma deprecated(lstrcatn)
#pragma deprecated(lstrcpy)
#pragma deprecated(lstrcpyn)
#pragma deprecated(wsprintf)
#pragma deprecated(wvsprintf)
#ifdef UNICODE
#define lstrcat    lstrcatW
#define lstrcatn   lstrcatnW
#define lstrcpy    lstrcpyW
#define lstrcpyn   lstrcpynW
#define wsprintf   wsprintfW
#define wvsprintf  wvsprintfW
#else
#define lstrcat    lstrcatA
#define lstrcatn   lstrcatnA
#define lstrcpy    lstrcpyA
#define lstrcpyn   lstrcpynA
#define wsprintf   wsprintfA
#define wvsprintf  wvsprintfA
#endif



// Then the shlwapi names - they key off UNICODE also.

#undef StrCpyA
#undef StrCatA
#undef StrCpy
#undef StrCat
#undef StrNCat
#undef StrCatN
#undef StrCpyN
#undef StrCatNA
#undef StrCpyNA
#undef StrNCpy
#undef wvnsprintfA
#undef wvnsprintf
#undef wnsprintfA
#undef wnsprintf
#undef StrCatBuffA
#undef StrCatBuff
#pragma deprecated(StrCatNA)
#pragma deprecated(StrCpyNA)
#pragma deprecated(StrCpyA)
#pragma deprecated(StrCatA)
#pragma deprecated(StrCat)
#pragma deprecated(StrCpy)
#pragma deprecated(StrNCat)
#pragma deprecated(StrCatN)
#pragma deprecated(StrNCpy)
#pragma deprecated(StrCpyN)
#pragma deprecated(StrNCpyA)
#pragma deprecated(StrNCatA)
#pragma deprecated(wvnsprintfA)
#pragma deprecated(wvnsprintf)
#pragma deprecated(wnsprintfA)
#pragma deprecated("wnsprintf")
#pragma deprecated(StrCatBuffA)
#pragma deprecated(StrCatBuff)
#define StrCpyA     lstrcpyA
#define StrCatA     lstrcatA
#define StrCatN     StrNCat
#define StrCpyN	    StrNCpy
#define wvnsprintfA vsprintf
#define wnsprintfA  wsprintf
#define StrCatBuffA lstrcatA
#ifdef UNICODE
#define StrCat      StrCatW
#define StrNCat     StrNCatW
#define StrCpy      StrCpyW
#define StrNCpy     StrNCpyW
#define wvnsprintf  vswprintf
#define wnsprintf   wsprintf
#define StrCatBuff  StrCatW
#else
#define StrCat      lstrcatA
#define StrNCat     StrNCatA
#define StrCpy      lstrcpyA
#define StrNCpy	    StrNCpyA
#define wvnsprintf  vsprintf
#define wnsprintf   vsprintf
#define StrCatBuff  lstrcatA
#endif




// Then all the CRT names - we need to undef/redef based on _UNICODE value.

#undef _getts
#undef _tcscat
#undef _tcsncat
#undef _tcscpy
#undef _tcsncpy
#undef _stprintf
#undef _vsntprintf
#undef _vstprintf
#undef _ftcscpy
#undef _ftcscat
#undef _fstrcpy
#undef _fstrcat
#undef _fstrncat
#undef _fstrncpy
#undef _sntprintf
#undef _tmakepath
#undef _tsplitpath
#undef _tscanf
#undef _stscanf
#undef _sntscanf
#pragma deprecated(_getts)
#pragma deprecated(_tcscat)
#pragma deprecated(_tcsncat)
#pragma deprecated(_tcscpy)
#pragma deprecated(_tcsncpy)
#pragma deprecated(_stprintf)
#pragma deprecated(_vsntprintf)
#pragma deprecated(_vstprintf)
#pragma deprecated("_ftcscpy")
#pragma deprecated("_ftcscat")
#pragma deprecated(_fstrcpy)
#pragma deprecated(_fstrcat)
#pragma deprecated(_fstrncat)
#pragma deprecated(_fstrncpy)
#pragma deprecated(_sntprintf)
#pragma deprecated(_tmakepath)
#pragma deprecated(_tsplitpath)
#pragma deprecated(_tscanf)
#pragma deprecated(_stscanf)
#pragma deprecated(_sntscanf)
#ifdef _UNICODE
#define _getts      _getws
#define _tcscat	    wcscat
#define _tscncat    wcsncat
#define _tcscpy	    wcscpy
#define _tcsncpy    wcsncpy
#define _sntprintf  _snwprintf
#define _vsntprintf _vsnwprintf
#define _vstprintf  vswprintf
#define _ftcscpy    wcscpy
#define _ftcscat    wcscat
#define _fstrcpy    wcscpy
#define _fstrcat    wcscat
#define _fstrncpy   wcsncpy
#define _fstrncat   wcsncat
#define _fstrcpy    wcscpy
#define _stprintf   swprintf
#define _tmakepath  _wmakepath
#define _tsplitpath _wsplitpath
#define _tscanf	    wscanf
#define _stscanf    swscanf
#define _sntscanf   snwscanf
#else
#define _getts	    gets
#define _tcscat	    strcat
#define _tcsncat    strncat
#define _tcscpy     strcpy
#define _tcsncpy    strncpy
#define _sntprintf  _snprintf
#define _vsntprintf _vsnprintf
#define _vstprintf  vsprintf
#define _ftcscpy    strcpy
#define _ftcscat    strcat
#define _fstrcpy    strcpy
#define _fstrcat    strcat
#define _fstrncpy   strncpy
#define _fstrncat   strncat
#define _fstrcpy    strcpy
#define _stprintf   vsprintf
#define _tmakepath  _makepath
#define _tsplitpath _splitpath
#define _tscanf	    scanf
#define	_stscanf    sscanf
#define _sntscanf   snscanf
#endif


#else // DEPRECATE_SUPPORTED

// WINDOWS

#undef lstrcpy
#define lstrcpy           lstrcpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy
#undef lstrcpyA
#define lstrcpyA          lstrcpyA_instead_use_strcpy_s_or_StringCchCopyA_or_StringCbCopyA
#undef lstrcpyW
#define lstrcpyW          lstrcpyW_instead_use_wcscpy_s_or_StringCchCopyW_or_StringCbCopyW

#undef lstrcpyn
#define lstrcpyn          lstrcpyn_instead_use_strncpy_s_or_StringCchCopyN_or_StringCbCopyN
#undef lstrcpynA
#define lstrcpynA         lstrcpynA_instead_use_strncpy_s_or_StringCchCopyNA_or_StringCbCopyNA
#undef lstrcpynW
#define lstrcpynW         lstrcpynW_instead_use_wcsncpy_s_or_StringCchCopyNW_or_StringCbCopyNW

#undef lstrcat
#define lstrcat           lstrcat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef lstrcatA
#define lstrcatA          lstrcatA_instead_use_strcat_s_or_StringCchCatA_or_StringCbCatA
#undef lstrcatW
#define lstrcatW          lstrcatW_instead_use_wcscat_s_or_StringCchCatW_or_StringCbCatW

#undef lstrcatn
#define lstrcatn          lstrcatn_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN
#undef lstrcatnA
#define lstrcatnA         lstrcatnA_instead_use_strncat_s_or_StringCchCatNA_or_StringCbCatNA
#undef lstrcatnW
#define lstrcatnW         lstrcatnW_instead_use_wcsncat_s_or_StringCchCatNW_or_StringCbCatNW

#undef wsprintf
#define wsprintf          wsprintf_instead_use_sprintf_s_or_StringCchPrintf_or_StringCbPrintf
#undef wsprintfA
#define wsprintfA         wsprintfA_instead_use_sprintf_s_or_StringCchPrintfA_or_StringCbPrintfA
#undef wsprintfW
#define wsprintfW         wsprintfW_instead_use_sprintf_s_or_StringCchPrintfW_or_StringCbPrintfW

#undef wvsprintf
#define wvsprintf         wvsprintf_instead_use_vsprintf_s_or_StringCchVPrintf_or_StringCbVPrintf
#undef wvsprintfA
#define wvsprintfA        wvsprintfA_instead_use_vsprintf_s_or_StringCchVPrintfA_or_StringCbVPrintfA
#undef wvsprintfW
#define wvsprintfW        wvsprintfW_instead_use_swprintf_s_or_StringCchVPrintfW_or_StringCbVPrintfW



// SHLWAPI

#undef StrCpy
#define StrCpy            StrCpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy
#undef StrCpyA
#define StrCpyA           StrCpyA_instead_use_strcpy_s_or_StringCchCopyA_or_StringCbCopyA
#undef StrCpyW
#define StrCpyW           StrCpyW_instead_use_wcscpy_s_or_StringCchCopyW_or_StringCbCopyW

#undef StrNCpy
#define StrNCpy           StrNCpy_instead_use_strncpy_s_or_StringCchCopyN_or_StringCbCopyN
#undef StrNCpyA
#define StrNCpyA          StrNCpyA_instead_use_strncpy_s_or_StringCchCopyNA_or_StringCbCopyNA
#undef StrNCpyW
#define StrNCpyW          StrNCpyW_instead_use_wcsncpy_s_or_StringCchCopyNW_or_StringCbCopyNW

#undef StrCpyN
#define StrCpyN           StrCpyN_instead_use_strncpy_s_or_StringCchCopyN_or_StringCbCopyN
#undef StrCpyNA
#define StrCpyNA          StrCpyNA_instead_use_strncpy_s_or_StringCchCopyNA_or_StringCbCopyNA
#undef StrCpyNW
#define StrCpyNW          StrCpyNW_instead_use_wcsncpy_s_or_StringCchCopyNW_or_StringCbCopyNW

#undef StrCat
#define StrCat            StrCat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef StrCatA
#define StrCatA           StrCatA_instead_use_strcat_s_or_StringCchCatA_or_StringCbCatA
#undef StrCatW
#define StrCatW           StrCatW_instead_use_wcscat_s_or_StringCchCatW_or_StringCbCatW

#undef StrNCat
#define StrNCat           StrNCat_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN
#undef StrNCatA
#define StrNCatA          StrNCatA_instead_use_strncat_s_or_StringCchCatNA_or_StringCbCatNA
#undef StrNCatW
#define StrNCatW          StrNCatW_instead_use_wcsncat_s_or_StringCchCatNW_or_StringCbCatNW

#undef StrCatN
#define StrCatN           StrCatN_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN
#undef StrCatNA
#define StrCatNA          StrCatNA_instead_use_strncat_s_or_StringCchCatNA_or_StringCbCatNA
#undef StrCatNW
#define StrCatNW          StrCatNW_instead_use_wcsncat_s_or_StringCchCatNW_or_StringCbCatNW

#undef wnsprintf
#define wnsprintf         wnsprintf_instead_use_vsprintf_s_or_StringCchPrintf_or_StringCbPrintf
#undef wnsprintfA
#define wnsprintfA        wnsprintfA_instead_use_vsprintf_s_or_StringCchPrintfA_or_StringCbPrintfA
#undef wnsprintfW
#define wnsprintfW        wnsprintfW_instead_use_vswprintf_s_or_StringCchPrintfW_or_StringCbPrintfW

#undef wvnsprintf
#define wvnsprintf        wvnsprintf_instead_use_vsprintf_s_or_StringCchVPrintf_or_StringCbVPrintf
#undef wvnsprintfA
#define wvnsprintfA       wvnsprintfA_instead_use_vsprintf_s_or_StringCchVPrintfA_or_StringCbVPrintfA
#undef wvnsprintfW
#define wvnsprintfW       wvnsprintfW_instead_use_vswprintf_s_or_StringCchVPrintfW_or_StringCbVPrintfW

#undef StrCatBuff
#define StrCatBuff        StrCatBuff_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef StrCatBuffA
#define StrCatBuffA       StrCatBuffA_instead_use_strcat_s_or_StringCchCatA_or_StringCbCatA
#undef StrCatBuffW
#define StrCatBuffW       StrCatBuffW_instead_use_strcat_s_or_StringCchCatW_or_StringCbCatW


// CRT

#undef gets
#define gets              _gets_instead_use__gets_or_StringCchGets_or_StringCbGets
#undef _getws
#define _getws            _getws_instead_use__getWs_or_StringCchGetsW_or_StringCbGetsW
#undef _getts
#define _getts            _getts_instead_use__gets_or_StringCchGets_or_StringCbGets

#undef strcpy
#define strcpy            strcpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy
#undef wcscpy
#define wcscpy            wcscpy_instead_use_wcscpy_s_or_StringCchCopyW_or_StringCbCopyW
#undef _tcscpy
#define _tcscpy           _tcscpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy

#undef strcat
#define strcat            strcat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef wcscat
#define wcscat            wcscat_instead_use_wcscat_s_or_StringCchCatW_or_StringCbCatW
#undef _tcscat
#define _tcscat           _tcscat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat

#undef strncat
#define strncat           strncat_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN
#undef wcsncat
#define wcsncat           wcsncat_instead_use_wcsncat_s_or_StringCchCatNW_or_StringCbCatNW
#undef _tcsncat
#define _tcsncat          _tcsncat_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN

#undef strncpy
#define strncpy           strncpy_instead_use_strncpy_s_or_StringCchCpyN_or_StringCbCpyN
#undef wcsncpy
#define wcsncpy           wcsncpy_instead_use_wcsncpy_s_or_StringCchCpyNW_or_StringCbCpyNW
#undef _tcsncpy
#define _tcsncpy          _tcsncpy_instead_use_strncpy_s_or_StringCchCpyN_or_StringCbCpyN

#undef _snprintf
#define _snprintf         _snprintf_instead_use_snprintf_s_or_StringCchPrintf_or_StringCbPrintf
#undef _snwprintf
#define _snwprintf        _snwprintf_instead_use_snwprintf_s_or_StringCchPrintfW_or_StringCbPrintfW
#undef _sntprintf
#define _sntprintf        _sntprintf_instead_use_sprintf_s_or_StringCchPrintf_or_StringCbPrintf

#undef _vsnprintf
#define _vsnprintf        _vsnprintf_instead_use_vsnprintf_s_or_StringCchVPrintf_or_StringCbVPrintf
#undef _vsnwprintf
#define _vsnwprintf       _vsnwprintf_instead_use_vsnwprintf_s_or_StringCchVPrintfW_or_StringCbVPrintfW
#undef _vsntprintf
#define _vsntprintf       _vsntprintf_instead_use_vsprintf_s_or_StringCchVPrintf_or_StringCbVPrintf

#undef vsprintf
#define vsprintf          vsprintf_instead_use_vsprintf_s_or_StringCchVPrintf_or_StringCbVPrintf
#undef vswprintf
#define vswprintf         vswprintf_instead_use_vswprintf_s_or_StringCchVPrintfW_or_StringCbVPrintfW
#undef _vstprintf
#define _vstprintf        _vstprintf_instead_use_vsprintf_s_or_StringCchVPrintf_or_StringCbVPrintf

#undef sprintf
#define sprintf           sprintf_instead_use_sprintf_s_or_StringCchPrintf_or_StringCbPrintf
#undef swprintf
#define swprintf          swprintf_instead_use_swprintf_s_or_StringCchPrintfW_or_StringCbPrintfW
#undef _stprintf
#define _stprintf         _stprintf_instead_use_vsprintf_s_or_StringCchPrintf_or_StringCbPrintf

#undef _makepath
#define _makepath         _makepath_instead_use_makepath_s
#undef _wmakepath
#define _wmakepath        _wmakepath_instead_use_wmakepath_s
#undef _tmakepath
#define _tmakepath        _tmakepath_instead_use_tmakepath_s

#undef _splitpath
#define _splitpath        _splitpath_instead_use_splitpath_s
#undef _wsplitpath
#define _wsplitpath       _wsplitpath_instead_use_wsplitpath_s
#undef _tsplitpath
#define _tsplitpath       _tsplitpath_instead_use_tsplitpath_s

#undef scanf
#define scanf             scanf_instead_use_scanf_S
#undef wscanf
#define wscanf            wscanf_instead_use_wscanf_S
#undef _tscanf
#define _tscanf           _tscanf_instead_use_scanf_S

#undef sscanf
#define sscanf            sscanf_instead_use_sscanf_S
#undef swscanf
#define swscanf           swscanf_instead_use_swscanf_s
#undef _stscanf
#define _stscanf          _stscanf_instead_use_sscanf_S

#undef _snscanf
#define _snscanf          _snscanf_instead_use__snscanf_s
#undef _snwscanf
#define _snwscanf         _snwscanf_instead_use__snwscanf_s
#undef snscanf
#define snscanf           snscanf_instead_use__snscanf_s
#undef swscanf
#define swscanf           swscanf_instead_use__snwscanf_s
#undef _sntscanf
#define _sntscanf         _sntscanf_instead_use__snscanf_s

#undef _ftcscat
#define _ftcscat          _ftcscat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef _ftcscpy
#define _ftcscpy          _ftcscpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy
#undef _fstrcat
#define _fstrcat          _fstrcat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat
#undef _fstrcpy
#define _fstrcpy          _fstrcpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy
#undef _fstrncat
#define _fstrncat         _fstrncat_instead_use_strncat_s_or_StringCchCatN_or_StringCbCatN
#undef _fstrncpy
#define _fstrncpy         _fstrncpy_instead_use_strncpy_s_or_StringCchCpyN_or_StringCbCpyN



// MISC

#undef sprintfA
#define sprintfA          sprintfA_instead_use_sprintf_s_or_StringCchPrintfA_or_StringCbPrintfA
#undef sprintfW
#define sprintfW          sprintfW_instead_use_swprintf_s_or_StringCchPrintfW_or_StringCbPrintfW

#undef strcpyA
#define strcpyA           strcpyA_instead_use_strcpy_s_or_StringCchCopyA_or_StringCbCopyA
#undef strcpyW
#define strcpyW           strcpyW_instead_use_wcscpy_s_or_StringCchCopyW_or_StringCbCopyW

#undef strcatA
#define strcatA           strcatA_instead_use_strcat_s_or_StringCchCatA_or_StringCbCatA
#undef strcatW
#define strcatW           strcatW_instead_use_wcscat_s_or_StringCchCatW_or_StringCbCatW

#undef nsprintf
#define nsprintf          nsprintf_instead_use_vsprintf_s_or_StringCchPrintf_or_StringCbPrintf

#undef IsBadCodePtr
#define IsBadCodePtr      IsBadCodePtr_is_no_longer_supported

#undef IsBadHugeReadPtr
#define IsBadHugeReadPtr  IsBadHugeReadPtr_is_no_longer_supported
	
#undef IsBadHugeWritePtr
#define IsBadHugeWritePtr IsBadHugeWritePtr_is_no_longer_supported

#undef IsBadReadPtr
#define IsBadReadPtr      IsBadReadPtr_is_no_longer_supported

#undef IsBadStringPtr
#define IsBadStringPtr    IsBadStringPtr_is_no_longer_supported

#undef IsBadWritePtr
#define IsBadWritePtr     IsBadWritePtr_is_no_longer_supported

#undef _ftccat
#define _ftccat           _ftccat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat

#undef _ftccpy
#define _ftccpy           _ftccpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy

#undef _tccat
#define _tccat            _tccat_instead_use_strcat_s_or_StringCchCat_or_StringCbCat

#undef _tccpy
#define _tccpy            _tccpy_instead_use_strcpy_s_or_StringCchCopy_or_StringCbCopy

#undef makepath
#define makepath          makepath_instead_use_makepath_s_or_wmakepath_s

#undef StrCatChainW	
#define StrCatChainW      StrCatChainW_is_no_longer_supported

#undef ualstrcpyW
#define ualstrcpyW        ualstrcpyW_is_no_longer_supported


#endif  // !DEPRECATE_SUPPORTED

#endif  // _DONTUSE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef ULONGLONG    SAMPLE_TIME;
typedef ULONGLONG    SAMPLE_POSITION;
typedef SAMPLE_TIME *LPSAMPLE_TIME;
#endif

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_EFFECT_DELAY            0x00000004
#endif

/* For DMUS_PORTCAPS dwClass
 */
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)   /* Supports DLS downloading and DLS level 1. */
#define DMUS_PC_EXTERNAL         (0x00000002)   /* External MIDI module. */
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)   /* Software synthesizer. */
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)   /* Memory size is fixed. */
#define DMUS_PC_GMINHARDWARE     (0x00000010)   /* GM sound set is built in, no need to download. */
#define DMUS_PC_GSINHARDWARE     (0x00000020)   /* GS sound set is built in. */
#define DMUS_PC_XGINHARDWARE     (0x00000040)   /* XG sound set is built in. */
#define DMUS_PC_DIRECTSOUND      (0x00000080)   /* Connects to DirectSound via a DSound buffer. */
#define DMUS_PC_SHAREABLE        (0x00000100)   /* Synth can be actively shared by multiple apps at once. */
#define DMUS_PC_DLS2             (0x00000200)   /* Supports DLS2 instruments. */
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_PC_AUDIOPATH        (0x00000400)   /* Multiple outputs can be connected to DirectSound for audiopaths. */
#define DMUS_PC_WAVE             (0x00000800)   /* Supports streaming and one shot waves. */
#endif

#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)   /* Sample memory is system memory. */


typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef DMUS_PORTCAPS *LPDMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_PORTPARAMS_FEATURES         0x00000080     /* DirectX 8.0 and above */
#endif

typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS7;

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */

typedef DMUS_PORTPARAMS7 DMUS_PORTPARAMS;

#else /* NTDDI_VERSION < NTDDI_WINXP */

typedef struct _DMUS_PORTPARAMS8
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
    DWORD   dwFeatures;
} DMUS_PORTPARAMS8;

#define DMUS_PORT_FEATURE_AUDIOPATH     0x00000001	/* Supports audiopath connection to DSound buffers. */
#define DMUS_PORT_FEATURE_STREAMING     0x00000002	/* Supports streaming waves through the synth. */

typedef DMUS_PORTPARAMS8 DMUS_PORTPARAMS;

#endif /* NTDDI_VERSION < NTDDI_WINXP */

typedef DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef struct _DMUS_SYNTHSTATS8 *LPDMUS_SYNTHSTATS8;
typedef struct _DMUS_SYNTHSTATS8
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
    DWORD   dwSynthMemUse;		/* Memory used by synth wave data */
} DMUS_SYNTHSTATS8;

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time.
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time)
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

#define DMUS_CLOCKF_GLOBAL              0x00000001

typedef struct _DMUS_CLOCKINFO7 *LPDMUS_CLOCKINFO7;
typedef struct _DMUS_CLOCKINFO7
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO7;

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */

typedef DMUS_CLOCKINFO7 DMUS_CLOCKINFO;

#else /* NTDDI_VERSION < NTDDI_WINXP */

typedef struct _DMUS_CLOCKINFO8 *LPDMUS_CLOCKINFO8;
typedef struct _DMUS_CLOCKINFO8
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
    DWORD           dwFlags;
} DMUS_CLOCKINFO8;

typedef DMUS_CLOCKINFO8 DMUS_CLOCKINFO;

#endif /* NTDDI_VERSION < NTDDI_WINXP */

typedef DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* Default bus identifiers
 *
 * The first 17 are direct mappings to the destinations defined in both
 * the MMA DLS Level 2 specification and the Microsoft Multi-Channel audio
 * specification.
 */
#define DSBUSID_FIRST_SPKR_LOC              0
#define DSBUSID_FRONT_LEFT                  0
#define DSBUSID_LEFT                        0   /* Front left is also just left */
#define DSBUSID_FRONT_RIGHT                 1
#define DSBUSID_RIGHT                       1   /* Ditto front right */
#define DSBUSID_FRONT_CENTER                2
#define DSBUSID_LOW_FREQUENCY               3
#define DSBUSID_BACK_LEFT                   4
#define DSBUSID_BACK_RIGHT                  5
#define DSBUSID_FRONT_LEFT_OF_CENTER        6
#define DSBUSID_FRONT_RIGHT_OF_CENTER       7
#define DSBUSID_BACK_CENTER                 8
#define DSBUSID_SIDE_LEFT                   9
#define DSBUSID_SIDE_RIGHT                 10
#define DSBUSID_TOP_CENTER                 11
#define DSBUSID_TOP_FRONT_LEFT             12
#define DSBUSID_TOP_FRONT_CENTER           13
#define DSBUSID_TOP_FRONT_RIGHT            14
#define DSBUSID_TOP_BACK_LEFT              15
#define DSBUSID_TOP_BACK_CENTER            16
#define DSBUSID_TOP_BACK_RIGHT             17
#define DSBUSID_LAST_SPKR_LOC              17

#define DSBUSID_IS_SPKR_LOC(id) ( ((id) >= DSBUSID_FIRST_SPKR_LOC) && ((id) <= DSBUSID_LAST_SPKR_LOC) )

/* These bus identifiers are for the standard DLS effect sends
 */
#define DSBUSID_REVERB_SEND                64
#define DSBUSID_CHORUS_SEND                65

/* Dynamic bus identifiers start here. See the documentation for how
 * synthesizers map the output of voices to static and dynamic
 * bus identifiers.
 */
#define DSBUSID_DYNAMIC_0                 512

/* Null bus, used to identify busses that have no function mapping.
*/
#define DSBUSID_NULL			   0xFFFFFFFF

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

interface IDirectMusic;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
interface IDirectMusic8;
#endif
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus

typedef interface IDirectMusic IDirectMusic;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef interface IDirectMusic8 IDirectMusic8;
#endif
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;

#endif  /* C++ */

typedef IDirectMusic *LPDIRECTMUSIC;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef IDirectMusic8 *LPDIRECTMUSIC8;
#endif
typedef IDirectMusicPort *LPDIRECTMUSICPORT;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex,
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc,
                                           LPDIRECTMUSICBUFFER *ppBuffer,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort,
                                           LPDMUS_PORTPARAMS pPortParams,
                                           LPDIRECTMUSICPORT *ppPort,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex,
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock,
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#undef  INTERFACE
#define INTERFACE  IDirectMusic8
DECLARE_INTERFACE_(IDirectMusic8, IDirectMusic)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex,
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc,
                                           LPDIRECTMUSICBUFFER *ppBuffer,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort,
                                           LPDMUS_PORTPARAMS pPortParams,
                                           LPDIRECTMUSICPORT *ppPort,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex,
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock,
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    /*  IDirectMusic8 */
    STDMETHOD(SetExternalMasterClock)
                                    (THIS_ IReferenceClock *pClock) PURE;
};

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;

    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;

    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;

    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicBuffer IDirectMusicBuffer8;
typedef IDirectMusicBuffer8 *LPDIRECTMUSICBUFFER8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicInstrument IDirectMusicInstrument8;
typedef IDirectMusicInstrument8 *LPDIRECTMUSICINSTRUMENT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument8;
typedef IDirectMusicDownloadedInstrument8 *LPDIRECTMUSICDOWNLOADEDINSTRUMENT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch,
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex,
                                               DWORD* pdwPatch,
                                               LPWSTR pwszName,
                                               DWORD dwNameLen) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicCollection IDirectMusicCollection8;
typedef IDirectMusicCollection8 *LPDIRECTMUSICCOLLECTION8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer,
                                           DWORD* pdwSize) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicDownload IDirectMusicDownload8;
typedef IDirectMusicDownload8 *LPDIRECTMUSICDOWNLOAD8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId,
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize,
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId,
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicPortDownload IDirectMusicPortDownload8;
typedef IDirectMusicPortDownload8 *LPDIRECTMUSICPORTDOWNLOAD8;

#endif

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000)

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)


#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument,
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode,
                                           LPVOID lpInBuffer,
                                           DWORD nInBufferSize,
                                           LPVOID lpOutBuffer,
                                           DWORD nOutBufferSize,
                                           LPDWORD lpBytesReturned,
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicPort IDirectMusicPort8;
typedef IDirectMusicPort8 *LPDIRECTMUSICPORT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicThru
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup,
                                           DWORD dwSourceChannel,
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicThru IDirectMusicThru8;
typedef IDirectMusicThru8 *LPDIRECTMUSICTHRU8;

#endif

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */

    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

DEFINE_GUID(IID_IDirectMusic8,0x2d3629f7,0x813d,0x4939,0x85,0x08,0xf0,0x5c,0x6b,0x75,0xfd,0x97);

#define IID_IDirectMusicThru8 IID_IDirectMusicThru
#define IID_IDirectMusicPortDownload8 IID_IDirectMusicPortDownload
#define IID_IDirectMusicDownload8 IID_IDirectMusicDownload
#define IID_IDirectMusicCollection8 IID_IDirectMusicCollection
#define IID_IDirectMusicInstrument8 IID_IDirectMusicInstrument
#define IID_IDirectMusicDownloadedInstrument8 IID_IDirectMusicDownloadedInstrument
#define IID_IDirectMusicPort8 IID_IDirectMusicPort

#endif

/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags.
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE
 * DMUS_EFFECT_REVERB
 * DMUS_EFFECT_CHORUS
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dpnathlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnathlp.h
 *
 *  Content:	Header for using DirectPlayNATHelp interface.
 *
 *
 *  NOTE: This interface is deprecated and should no longer be used.
 *
 *
 ***************************************************************************/



#ifndef __DPNATHLP_H__
#define __DPNATHLP_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT



#ifndef DPNATHLP_EXPORTS
#define DPNATHLPAPI DECLSPEC_IMPORT
#else
#define DPNATHLPAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DirectPlay NAT Helper object class IDs
 *
 ****************************************************************************/

// {B9C2E9C4-68C1-4d42-A7A1-E76A26982AD6}
DEFINE_GUID(CLSID_DirectPlayNATHelpUPnP,
0xb9c2e9c4, 0x68c1, 0x4d42, 0xa7, 0xa1, 0xe7, 0x6a, 0x26, 0x98, 0x2a, 0xd6);

// {963AB779-16A1-477c-A36D-CB5E711938F7}
DEFINE_GUID(CLSID_DirectPlayNATHelpPAST,
0x963ab779, 0x16a1, 0x477c, 0xa3, 0x6d, 0xcb, 0x5e, 0x71, 0x19, 0x38, 0xf7);


/****************************************************************************
 *
 * DirectPlay NAT Helper interface ID
 *
 ****************************************************************************/

// {3b743591-791b-4864-9ee3-55e889409781}
DEFINE_GUID(IID_IDirectPlayNATHelp, 
0x3b743591, 0x791b, 0x4864, 0x9e, 0xe3, 0x55, 0xe8, 0x89, 0x40, 0x97, 0x81);

/****************************************************************************
 *
 * DirectPlay NAT Helper interface pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlayNATHelp     *PDIRECTPLAYNATHELP;




/****************************************************************************
 *
 * DirectPlay NAT Helper data types
 *
 ****************************************************************************/

//
// Handles used to identify specific port binding groups.  If multiple ports
// are registered at the same time, the DPNHHANDLE refers to all ports.
//
typedef DWORD_PTR	DPNHHANDLE,	* PDPNHHANDLE;




/****************************************************************************
 *
 * DirectPlay NAT Helper constants
 *
 ****************************************************************************/

#define DPNH_MAX_SIMULTANEOUS_PORTS		16	// up to 16 ports may be specified in a single RegisterPorts call




/****************************************************************************
 *
 * DirectPlay NAT Helper API flags
 *
 ****************************************************************************/

//
// Flags that can be passed to Initialize
//
#define DPNHINITIALIZE_DISABLEGATEWAYSUPPORT				0x01	// disables Internet gateway traversal support (cannot be specified with DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
#define DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT			0x02	// disables local firewall traversal support (cannot be specified with DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)

//
// Flags that can be passed to GetCaps.
//
#define DPNHGETCAPS_UPDATESERVERSTATUS						0x01	// automatically extend expiring leases and detect changes in server status

//
// Flags that can be passed to RegisterPorts.
//
#define DPNHREGISTERPORTS_TCP								0x01	// request TCP ports instead of UDP
#define DPNHREGISTERPORTS_FIXEDPORTS						0x02	// asks the server to use the same port numbers on the public interface
#define DPNHREGISTERPORTS_SHAREDPORTS						0x04	// requests that the server allow the UDP fixed ports to be shared with other clients (must be specified with DPNHREGISTERPORTS_FIXEDPORTS and cannot be specified with DPNHREGISTERPORTS_TCP)

//
// Flags that can be passed to GetRegisteredAddresses.
//
#define DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY	0x01	// retrieve the public address for the local firewall only, even if mapped on remote Internet gateway

//
// Flags that can be passed to QueryAddress.
//
#define DPNHQUERYADDRESS_TCP								0x01	// request a TCP port instead of UDP
#define DPNHQUERYADDRESS_CACHEFOUND							0x02	// cache the discovered address if found
#define DPNHQUERYADDRESS_CACHENOTFOUND						0x04	// cache the fact that no address was found, if that is the case
#define DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED			0x08	// determine if the address is behind the same Internet gateway, but not mapped on that Internet gateway

/****************************************************************************
 *
 * DirectPlay NAT Helper structure flags
 *
 ****************************************************************************/

//
// DPNHCAPS flags
//
#define DPNHCAPSFLAG_LOCALFIREWALLPRESENT		0x01	// at least one network connection has a local firewall present
#define DPNHCAPSFLAG_GATEWAYPRESENT				0x02	// at least one network connection has an Internet gateway present
#define DPNHCAPSFLAG_GATEWAYISLOCAL				0x04	// a detected Internet gateway is local (i.e. the public address is another network interface on the same machine)
#define DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE		0x08	// at least one server has a valid public address for registered mappings
#define DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY	0x10	// at least one available server does not support an active-notification mechanisms and must be polled



/****************************************************************************
 *
 * DirectPlay NAT Helper structures
 *
 ****************************************************************************/
 
typedef struct _DPNHCAPS
{
	DWORD	dwSize;							// size of this structure, must be filled in prior to calling GetCaps
	DWORD	dwFlags;						// flags indicating capabilities of Internet gateway server(s)
	DWORD	dwNumRegisteredPorts;			// number of ports currently registered, including multiple ports registered at the same time (so this may not be equal to the number of DPNHHANDLEs given out)
	DWORD	dwMinLeaseTimeRemaining;		// approximate time remaining, in milliseconds, for the lease that will expire soonest
	DWORD	dwRecommendedGetCapsInterval;	// recommended time, in milliseconds, after which GetCaps should be called again (with DPNHGETCAPS_UPDATESERVERSTATUS flag)
} DPNHCAPS, * PDPNHCAPS;



/****************************************************************************
 *
 * Address type flags (returned by GetRegisteredAddresses)
 *
 ****************************************************************************/

#define DPNHADDRESSTYPE_TCP				0x01	// the mappings are for TCP ports instead of UDP
#define DPNHADDRESSTYPE_FIXEDPORTS		0x02	// the mappings are for ports which are the same on the Internet gateway 
#define DPNHADDRESSTYPE_SHAREDPORTS		0x04	// the mappings are for shared UDP fixed ports
#define DPNHADDRESSTYPE_LOCALFIREWALL	0x08	// the addresses are opened on a local firewall
#define DPNHADDRESSTYPE_GATEWAY			0x10	// the addresses are registered with an Internet gateway
#define DPNHADDRESSTYPE_GATEWAYISLOCAL	0x20	// the Internet gateway is local (i.e. the public address is another network interface on the same machine)




/****************************************************************************
 *
 * DirectPlay NAT Helper DLL exported functions
 *
 ****************************************************************************/

typedef HRESULT (WINAPI * PFN_DIRECTPLAYNATHELPCREATE)(const GUID * pIID, void ** ppvInterface);





/****************************************************************************
 *
 * DirectPlay NAT Helper application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayNATHelp
DECLARE_INTERFACE_(IDirectPlayNATHelp, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDirectPlayNATHelp methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)						(THIS_ DPNHCAPS * const dpnhcaps, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterPorts)				(THIS_ const SOCKADDR * const aLocalAddresses, const DWORD dwAddressesSize, const DWORD dwNumAddresses, const DWORD dwLeaseTime, DPNHHANDLE * const phRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(GetRegisteredAddresses)		(THIS_ const DPNHHANDLE hRegisteredPorts, SOCKADDR * const paPublicAddresses, DWORD * const pdwPublicAddressesSize, DWORD * const pdwAddressTypeFlags, DWORD * const pdwLeaseTimeRemaining, const DWORD dwFlags) PURE;
	STDMETHOD(DeregisterPorts)				(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(QueryAddress)					(THIS_ const SOCKADDR * const pSourceAddress, const SOCKADDR * const pQueryAddress, SOCKADDR * const pResponseAddress, const int iAddressesSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertEvent)				(THIS_ const HANDLE hEvent, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertIOCompletionPort)		(THIS_ const HANDLE hIOCompletionPort, const DWORD dwCompletionKey, const DWORD dwNumConcurrentThreads, const DWORD dwFlags) PURE;
	STDMETHOD(ExtendRegisteredPortsLease)	(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwLeaseTime, const DWORD dwFlags) PURE;
};


/****************************************************************************
 *
 * DirectPlay NAT Helper application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlayNATHelp_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->lpVtbl->Initialize(p,a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->lpVtbl->RegisterPorts(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->lpVtbl->GetRegisteredAddresses(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->lpVtbl->DeregisterPorts(p,a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->lpVtbl->QueryAddress(p,a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->lpVtbl->SetAlertEvent(p,a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->lpVtbl->SetAlertIOCompletionPort(p,a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->lpVtbl->ExtendRegisteredPortsLease(p,a,b,c)


#else // C++

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->AddRef()
#define	IDirectPlayNATHelp_Release(p)								(p)->Release()
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->Initialize(a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->Close(a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->RegisterPorts(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->GetRegisteredAddresses(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->DeregisterPorts(a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->QueryAddress(a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->SetAlertEvent(a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->SetAlertIOCompletionPort(a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->ExtendRegisteredPortsLease(a,b,c)


#endif



/****************************************************************************
 *
 * DirectPlay NAT Helper return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPNH_FACILITY_CODE					0x015
#define _DPNH_HRESULT_BASE					0xF000

#define MAKE_DPNHSUCCESS(code)				MAKE_HRESULT(0, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))
#define MAKE_DPNHFAILURE(code)				MAKE_HRESULT(1, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))



#define DPNH_OK								S_OK

#define DPNHSUCCESS_ADDRESSESCHANGED		MAKE_DPNHSUCCESS(0x10)

#define DPNHERR_ALREADYINITIALIZED			MAKE_DPNHFAILURE(0x10)
#define DPNHERR_BUFFERTOOSMALL				MAKE_DPNHFAILURE(0x20)
#define DPNHERR_GENERIC						E_FAIL
#define DPNHERR_INVALIDFLAGS				MAKE_DPNHFAILURE(0x30)
#define DPNHERR_INVALIDOBJECT				MAKE_DPNHFAILURE(0x40)
#define DPNHERR_INVALIDPARAM				E_INVALIDARG
#define DPNHERR_INVALIDPOINTER				E_POINTER
#define DPNHERR_NOMAPPING					MAKE_DPNHFAILURE(0x50)
#define DPNHERR_NOMAPPINGBUTPRIVATE			MAKE_DPNHFAILURE(0x60)
#define DPNHERR_NOTINITIALIZED				MAKE_DPNHFAILURE(0x70)
#define DPNHERR_OUTOFMEMORY					E_OUTOFMEMORY
#define DPNHERR_PORTALREADYREGISTERED		MAKE_DPNHFAILURE(0x80)
#define DPNHERR_PORTUNAVAILABLE				MAKE_DPNHFAILURE(0x90)
#define DPNHERR_REENTRANT					MAKE_DPNHFAILURE(0x95)
#define DPNHERR_SERVERNOTAVAILABLE			MAKE_DPNHFAILURE(0xA0)
#define DPNHERR_UPDATESERVERSTATUS			MAKE_DPNHFAILURE(0xC0)

#ifdef __cplusplus
}
#endif

#endif // __DPNATHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dpfilter.h ===
//
// Component name filter id enumeration and levels.
//

#define DPFLTR_ERROR_LEVEL 0
#define DPFLTR_WARNING_LEVEL 1
#define DPFLTR_TRACE_LEVEL 2
#define DPFLTR_INFO_LEVEL 3
#define DPFLTR_MASK 0x80000000

typedef enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_RPCPROXY_ID = 42,
    DPFLTR_AUTOCHK_ID = 43,
    DPFLTR_DCOMSS_ID = 44,
    DPFLTR_UNIMODEM_ID = 45,
    DPFLTR_SIS_ID = 46,
    DPFLTR_FLTMGR_ID = 47,
    DPFLTR_WMICORE_ID = 48,
    DPFLTR_BURNENG_ID = 49,
    DPFLTR_IMAPI_ID = 50,
    DPFLTR_SXS_ID = 51,
    DPFLTR_FUSION_ID = 52,
    DPFLTR_IDLETASK_ID = 53,
    DPFLTR_SOFTPCI_ID = 54,
    DPFLTR_TAPE_ID = 55,
    DPFLTR_MCHGR_ID = 56,
    DPFLTR_IDEP_ID = 57,
    DPFLTR_PCIIDE_ID = 58,
    DPFLTR_FLOPPY_ID = 59,
    DPFLTR_FDC_ID = 60,
    DPFLTR_TERMSRV_ID = 61,
    DPFLTR_W32TIME_ID = 62,
    DPFLTR_PREFETCHER_ID = 63,
    DPFLTR_RSFILTER_ID = 64,
    DPFLTR_FCPORT_ID = 65,
    DPFLTR_PCI_ID = 66,
    DPFLTR_DMIO_ID = 67,
    DPFLTR_DMCONFIG_ID = 68,
    DPFLTR_DMADMIN_ID = 69,
    DPFLTR_WSOCKTRANSPORT_ID = 70,
    DPFLTR_VSS_ID = 71,
    DPFLTR_PNPMEM_ID = 72,
    DPFLTR_PROCESSOR_ID = 73,
    DPFLTR_DMSERVER_ID = 74,
    DPFLTR_SR_ID = 75,
    DPFLTR_INFINIBAND_ID = 76,
    DPFLTR_IHVDRIVER_ID = 77,
    DPFLTR_IHVVIDEO_ID = 78,
    DPFLTR_IHVAUDIO_ID = 79,
    DPFLTR_IHVNETWORK_ID = 80,
    DPFLTR_IHVSTREAMING_ID = 81,
    DPFLTR_IHVBUS_ID = 82,
    DPFLTR_HPS_ID = 83,
    DPFLTR_RTLTHREADPOOL_ID = 84,
    DPFLTR_LDR_ID = 85,
    DPFLTR_TCPIP6_ID = 86,
    DPFLTR_ISAPNP_ID = 87,
    DPFLTR_SHPC_ID = 88,
    DPFLTR_STORPORT_ID = 89,
    DPFLTR_STORMINIPORT_ID = 90,
    DPFLTR_PRINTSPOOLER_ID = 91,
    DPFLTR_VSSDYNDISK_ID = 92,
    DPFLTR_VERIFIER_ID = 93,
    DPFLTR_VDS_ID = 94,
    DPFLTR_VDSBAS_ID = 95,
    DPFLTR_VDSDYN_ID = 96,
    DPFLTR_VDSDYNDR_ID = 97,
    DPFLTR_VDSLDR_ID = 98,
    DPFLTR_VDSUTIL_ID = 99,
    DPFLTR_DFRGIFC_ID = 100,
    DPFLTR_DEFAULT_ID = 101,
    DPFLTR_MM_ID = 102,
    DPFLTR_DFSC_ID = 103,
    DPFLTR_WOW64_ID = 104,
    DPFLTR_ALPC_ID = 105,
    DPFLTR_WDI_ID = 106,
    DPFLTR_PERFLIB_ID = 107,
    DPFLTR_KTM_ID = 108,
    DPFLTR_IOSTRESS_ID = 109,
    DPFLTR_HEAP_ID = 110,
    DPFLTR_WHEA_ID = 111,
    DPFLTR_USERGDI_ID = 112,
    DPFLTR_MMCSS_ID = 113,
    DPFLTR_TPM_ID = 114,
    DPFLTR_THREADORDER_ID = 115,
    DPFLTR_ENVIRON_ID = 116,
    DPFLTR_EMS_ID = 117,
    DPFLTR_WDT_ID = 118,
    DPFLTR_FVEVOL_ID = 119,
    DPFLTR_NDIS_ID = 120,
    DPFLTR_NVCTRACE_ID = 121,
    DPFLTR_LUAFV_ID = 122,
    DPFLTR_APPCOMPAT_ID = 123,
    DPFLTR_USBSTOR_ID = 124,
    DPFLTR_SBP2PORT_ID = 125,
    DPFLTR_COVERAGE_ID = 126,
    DPFLTR_CACHEMGR_ID = 127,
    DPFLTR_MOUNTMGR_ID = 128,
    DPFLTR_CFR_ID = 129,
    DPFLTR_TXF_ID = 130,
    DPFLTR_KSECDD_ID = 131,
    DPFLTR_FLTREGRESS_ID = 132,
    DPFLTR_MPIO_ID = 133,
    DPFLTR_MSDSM_ID = 134,
    DPFLTR_UDFS_ID = 135,
    DPFLTR_PSHED_ID = 136,
    DPFLTR_STORVSP_ID = 137,
    DPFLTR_EXFAT_ID = 138,
    DPFLTR_ENDOFTABLE_ID
} DPFLTR_TYPE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DSAdmin.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       dsadmin.h
//
//  Contents:   DS Admin Object Creation public header
//
//---------------------------------------------------------------------------


//
// CoClass for the Object creation dialog object
//
// {E301A009-F901-11d2-82B9-00C04F68928B}
DEFINE_GUID(CLSID_DsAdminCreateObj, 
    0xe301a009, 0xf901, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


//
// Interface GUIDs
//


// {53554A38-F902-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminCreateObj, 
    0x53554a38, 0xf902, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {F2573587-E6FC-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObj, 
    0xf2573587, 0xe6fc, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {BE2B487E-F904-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjPrimarySite, 
0xbe2b487e, 0xf904, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {6088EAE2-E7BF-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjExt, 
    0x6088eae2, 0xe7bf, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {E4A2B8B3-5A18-11d2-97C1-00A0C9A06D2D}
DEFINE_GUID(IID_IDsAdminNotifyHandler, 
    0xe4a2b8b3, 0x5a18, 0x11d2, 0x97, 0xc1, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d);


#ifndef _DSADMIN_H
#define _DSADMIN_H


// ----------------------------------------------------------------------------
// 
// Interface: IDsAdminCreateObj
//  
// Implemented by the object (implemented by the system) CLSID_DsAdminCreateObj
//
// Used by: any client needing to invoke the creation UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsAdminCreateObj

DECLARE_INTERFACE_(IDsAdminCreateObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminCreateObj methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName) PURE;
  STDMETHOD(CreateModal)(THIS_ /*IN*/ HWND hwndParent, 
                               /*OUT*/ IADs** ppADsObj) PURE;
};






//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObj
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (both primary and regular)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObj

DECLARE_INTERFACE_(IDsAdminNewObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminNewObj methods ***
  STDMETHOD(SetButtons)(THIS_ /*IN*/ ULONG nCurrIndex, /*IN*/ BOOL bValid) PURE; 
  STDMETHOD(GetPageCounts)(THIS_ /*OUT*/ LONG* pnTotal,
                                 /*OUT*/ LONG* pnStartIndex) PURE; 
};





//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjPrimarySite
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (primary only)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjPrimarySite

DECLARE_INTERFACE_(IDsAdminNewObjPrimarySite, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjPrimarySite methods ***
  STDMETHOD(CreateNew)(THIS_ /*IN*/ LPCWSTR pszName) PURE;
  STDMETHOD(Commit)(THIS_ ) PURE;
};



//
// struct passed to IDsAdminNewObjExt::Initialize()
//
// it contains information regarding UI look
//

typedef struct
{
    DWORD   dwSize;                     // size of struct, for versioning
    HICON   hObjClassIcon;              // class icon for the object to be created
    LPWSTR  lpszWizTitle;               // title of the wizard
    LPWSTR  lpszContDisplayName;        // container display name (canonical name)
} DSA_NEWOBJ_DISPINFO, * LPDSA_NEWOBJ_DISPINFO;




//
// context flags passed to IDsAdminNewObjExt::OnError() and to IDsAdminNewObjExt::WriteData()
//

#define DSA_NEWOBJ_CTX_PRECOMMIT      0x00000001  // before SetInfo()
#define DSA_NEWOBJ_CTX_COMMIT         0x00000002  // SetInfo(), commit phase
#define DSA_NEWOBJ_CTX_POSTCOMMIT     0x00000003  // after SetInfo()
#define DSA_NEWOBJ_CTX_CLEANUP        0x00000004  // on post commit fail



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjExt
// 
// Implemented by: creation extension in proc server (both primary and regular)
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjExt

DECLARE_INTERFACE_(IDsAdminNewObjExt, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjExt methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName,
                              /*IN*/ IDsAdminNewObj* pDsAdminNewObj,
                              /*IN*/ LPDSA_NEWOBJ_DISPINFO pDispInfo) PURE;

  STDMETHOD(AddPages)(THIS_ /*IN*/ LPFNADDPROPSHEETPAGE lpfnAddPage, 
                            /*IN*/ LPARAM lParam) PURE;

  STDMETHOD(SetObject)(THIS_ /*IN*/ IADs* pADsObj) PURE;

  STDMETHOD(WriteData)(THIS_ /*IN*/ HWND hWnd, 
                             /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(OnError)(THIS_ /*IN*/ HWND hWnd, 
                           /*IN*/ HRESULT hr,
                              /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(GetSummaryInfo)(THIS_ /*OUT*/BSTR* pBstrText) PURE;
};


//
// Notification opcodes for IDsAdminNotifyHandler
//

#define DSA_NOTIFY_DEL      0x00000001  // delete
#define DSA_NOTIFY_REN      0x00000002  // rename
#define DSA_NOTIFY_MOV      0x00000004  // move
#define DSA_NOTIFY_PROP     0x00000008  // property change

#define DSA_NOTIFY_ALL      (DSA_NOTIFY_DEL|DSA_NOTIFY_REN|DSA_NOTIFY_MOV|DSA_NOTIFY_PROP)

//
// TODO: add explaination
//
// flags to handle additional data
//

#define DSA_NOTIFY_FLAG_ADDITIONAL_DATA        0x00000002   //process additional extension data?
#define DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA  0x00000001   //operation forced



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNotifyHandler
// 
// Implemented by: notification handler in proc server
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNotifyHandler


DECLARE_INTERFACE_(IDsAdminNotifyHandler, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // IDsAdminNotifyHandler methods
  STDMETHOD(Initialize)(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                              /*OUT*/ ULONG* puEventFlags) PURE;
  STDMETHOD(Begin)(THIS_ /*IN*/ ULONG uEvent,
                         /*IN*/ IDataObject* pArg1,
                         /*IN*/ IDataObject* pArg2,
                         /*OUT*/ ULONG* puFlags,
                         /*OUT*/ BSTR* pBstr) PURE;

  STDMETHOD(Notify)(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags) PURE; 

  STDMETHOD(End)(THIS_) PURE; 
};



#endif // _DSADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dpx.h ===
// Copyright Microsoft Corporation.  All rights reserved.

#pragma once

#include <dpx1.h>

//
//  DpxNewJob and DpxRestoreJob require a TargetPath which is the local file
//  system directory under which extracted files should be created.  If the
//  directory does not exist, DpxNewJob or DpxRestoreJob will fail.  Files
//  created under TargetPath directory may include relative subdirectory names
//  or even stream names.  Files and subdirectories will be created with
//  inherited ACL from TargetPath and owner from the thread calling
//  IDpxJob::ProvideRequestedData.  During the course of extraction, additional
//  temporary files might be created in the TargetPath directory but will be
//  deleted when the job completes.  If the job is cancelled or destroyed
//  before completing, these temporary files may not be automatically deleted.
//  To move partially completed extraction job to different TargetPath, caller
//  may Suspend and SaveJobState, then tree-copy entire existing TargetPath
//  contents to new location, create a new IDpxJob instance, then DpxRestoreJob
//  using the new TargetPath location.
//

EXTERN_C HRESULT WINAPI DpxNewJob( __in LPCWSTR TargetPath, __deref_out IDpxJob ** ppJob );

EXTERN_C HRESULT WINAPI DpxRestoreJob( __in LPCWSTR TargetPath, __deref_out IDpxJob ** ppJob );

EXTERN_C VOID    WINAPI DpxFreeMemory( __in void* Allocation );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DocObj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for docobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __docobj_h__
#define __docobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IOleDocument_FWD_DEFINED__
#define __IOleDocument_FWD_DEFINED__
typedef interface IOleDocument IOleDocument;
#endif 	/* __IOleDocument_FWD_DEFINED__ */


#ifndef __IOleDocumentSite_FWD_DEFINED__
#define __IOleDocumentSite_FWD_DEFINED__
typedef interface IOleDocumentSite IOleDocumentSite;
#endif 	/* __IOleDocumentSite_FWD_DEFINED__ */


#ifndef __IOleDocumentView_FWD_DEFINED__
#define __IOleDocumentView_FWD_DEFINED__
typedef interface IOleDocumentView IOleDocumentView;
#endif 	/* __IOleDocumentView_FWD_DEFINED__ */


#ifndef __IEnumOleDocumentViews_FWD_DEFINED__
#define __IEnumOleDocumentViews_FWD_DEFINED__
typedef interface IEnumOleDocumentViews IEnumOleDocumentViews;
#endif 	/* __IEnumOleDocumentViews_FWD_DEFINED__ */


#ifndef __IContinueCallback_FWD_DEFINED__
#define __IContinueCallback_FWD_DEFINED__
typedef interface IContinueCallback IContinueCallback;
#endif 	/* __IContinueCallback_FWD_DEFINED__ */


#ifndef __IPrint_FWD_DEFINED__
#define __IPrint_FWD_DEFINED__
typedef interface IPrint IPrint;
#endif 	/* __IPrint_FWD_DEFINED__ */


#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef interface IOleCommandTarget IOleCommandTarget;
#endif 	/* __IOleCommandTarget_FWD_DEFINED__ */


#ifndef __IZoomEvents_FWD_DEFINED__
#define __IZoomEvents_FWD_DEFINED__
typedef interface IZoomEvents IZoomEvents;
#endif 	/* __IZoomEvents_FWD_DEFINED__ */


#ifndef __IProtectFocus_FWD_DEFINED__
#define __IProtectFocus_FWD_DEFINED__
typedef interface IProtectFocus IProtectFocus;
#endif 	/* __IProtectFocus_FWD_DEFINED__ */


#ifndef __IProtectedModeMenuServices_FWD_DEFINED__
#define __IProtectedModeMenuServices_FWD_DEFINED__
typedef interface IProtectedModeMenuServices IProtectedModeMenuServices;
#endif 	/* __IProtectedModeMenuServices_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_docobj_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DocObj.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Document Object Interfaces.









////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPOLEDOCUMENT_DEFINED
#define _LPOLEDOCUMENT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0000_v0_0_s_ifspec;

#ifndef __IOleDocument_INTERFACE_DEFINED__
#define __IOleDocument_INTERFACE_DEFINED__

/* interface IOleDocument */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocument *LPOLEDOCUMENT;

typedef /* [public] */ 
enum __MIDL_IOleDocument_0001
    {	DOCMISC_CANCREATEMULTIPLEVIEWS	= 1,
	DOCMISC_SUPPORTCOMPLEXRECTANGLES	= 2,
	DOCMISC_CANTOPENEDIT	= 4,
	DOCMISC_NOFILESUPPORT	= 8
    } 	DOCMISC;


EXTERN_C const IID IID_IOleDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc5-4e68-101b-a2bc-00aa00404770")
    IOleDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateView( 
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite,
            /* [unique][in] */ __RPC__in_opt IStream *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOleDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOleDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOleDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateView )( 
            IOleDocument * This,
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite,
            /* [unique][in] */ __RPC__in_opt IStream *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocMiscStatus )( 
            IOleDocument * This,
            /* [out] */ __RPC__out DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            IOleDocument * This,
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView);
        
        END_INTERFACE
    } IOleDocumentVtbl;

    interface IOleDocument
    {
        CONST_VTBL struct IOleDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocument_CreateView(This,pIPSite,pstm,dwReserved,ppView)	\
    ( (This)->lpVtbl -> CreateView(This,pIPSite,pstm,dwReserved,ppView) ) 

#define IOleDocument_GetDocMiscStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetDocMiscStatus(This,pdwStatus) ) 

#define IOleDocument_EnumViews(This,ppEnum,ppView)	\
    ( (This)->lpVtbl -> EnumViews(This,ppEnum,ppView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocument_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTSITE_DEFINED
#define _LPOLEDOCUMENTSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0001_v0_0_s_ifspec;

#ifndef __IOleDocumentSite_INTERFACE_DEFINED__
#define __IOleDocumentSite_INTERFACE_DEFINED__

/* interface IOleDocumentSite */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocumentSite *LPOLEDOCUMENTSITE;


EXTERN_C const IID IID_IOleDocumentSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc7-4e68-101b-a2bc-00aa00404770")
    IOleDocumentSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ActivateMe( 
            /* [in] */ __RPC__in_opt IOleDocumentView *pViewToActivate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOleDocumentSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOleDocumentSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOleDocumentSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateMe )( 
            IOleDocumentSite * This,
            /* [in] */ __RPC__in_opt IOleDocumentView *pViewToActivate);
        
        END_INTERFACE
    } IOleDocumentSiteVtbl;

    interface IOleDocumentSite
    {
        CONST_VTBL struct IOleDocumentSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocumentSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocumentSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocumentSite_ActivateMe(This,pViewToActivate)	\
    ( (This)->lpVtbl -> ActivateMe(This,pViewToActivate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocumentSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTVIEW_DEFINED
#define _LPOLEDOCUMENTVIEW_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0002_v0_0_s_ifspec;

#ifndef __IOleDocumentView_INTERFACE_DEFINED__
#define __IOleDocumentView_INTERFACE_DEFINED__

/* interface IOleDocumentView */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocumentView *LPOLEDOCUMENTVIEW;


EXTERN_C const IID IID_IOleDocumentView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc6-4e68-101b-a2bc-00aa00404770")
    IOleDocumentView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite( 
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite( 
            /* [out] */ __RPC__deref_out_opt IOleInPlaceSite **ppIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ __RPC__in LPRECT prcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRect( 
            /* [out] */ __RPC__out LPRECT prcView) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRectComplex( 
            /* [unique][in] */ __RPC__in_opt LPRECT prcView,
            /* [unique][in] */ __RPC__in_opt LPRECT prcHScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcVScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcSizeBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ BOOL fUIActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseView( 
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( 
            /* [in] */ __RPC__in_opt LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyViewState( 
            /* [in] */ __RPC__in_opt LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ __RPC__in_opt IOleInPlaceSite *pIPSiteNew,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppViewNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOleDocumentView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOleDocumentView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOleDocumentView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPlaceSite )( 
            IOleDocumentView * This,
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetInPlaceSite )( 
            IOleDocumentView * This,
            /* [out] */ __RPC__deref_out_opt IOleInPlaceSite **ppIPSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IOleDocumentView * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IOleDocumentView * This,
            /* [in] */ __RPC__in LPRECT prcView);
        
        HRESULT ( STDMETHODCALLTYPE *GetRect )( 
            IOleDocumentView * This,
            /* [out] */ __RPC__out LPRECT prcView);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *SetRectComplex )( 
            IOleDocumentView * This,
            /* [unique][in] */ __RPC__in_opt LPRECT prcView,
            /* [unique][in] */ __RPC__in_opt LPRECT prcHScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcVScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcSizeBox);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            IOleDocumentView * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            IOleDocumentView * This,
            /* [in] */ BOOL fUIActivate);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IOleDocumentView * This);
        
        HRESULT ( STDMETHODCALLTYPE *CloseView )( 
            IOleDocumentView * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            IOleDocumentView * This,
            /* [in] */ __RPC__in_opt LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyViewState )( 
            IOleDocumentView * This,
            /* [in] */ __RPC__in_opt LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IOleDocumentView * This,
            /* [in] */ __RPC__in_opt IOleInPlaceSite *pIPSiteNew,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppViewNew);
        
        END_INTERFACE
    } IOleDocumentViewVtbl;

    interface IOleDocumentView
    {
        CONST_VTBL struct IOleDocumentViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocumentView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocumentView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocumentView_SetInPlaceSite(This,pIPSite)	\
    ( (This)->lpVtbl -> SetInPlaceSite(This,pIPSite) ) 

#define IOleDocumentView_GetInPlaceSite(This,ppIPSite)	\
    ( (This)->lpVtbl -> GetInPlaceSite(This,ppIPSite) ) 

#define IOleDocumentView_GetDocument(This,ppunk)	\
    ( (This)->lpVtbl -> GetDocument(This,ppunk) ) 

#define IOleDocumentView_SetRect(This,prcView)	\
    ( (This)->lpVtbl -> SetRect(This,prcView) ) 

#define IOleDocumentView_GetRect(This,prcView)	\
    ( (This)->lpVtbl -> GetRect(This,prcView) ) 

#define IOleDocumentView_SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)	\
    ( (This)->lpVtbl -> SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox) ) 

#define IOleDocumentView_Show(This,fShow)	\
    ( (This)->lpVtbl -> Show(This,fShow) ) 

#define IOleDocumentView_UIActivate(This,fUIActivate)	\
    ( (This)->lpVtbl -> UIActivate(This,fUIActivate) ) 

#define IOleDocumentView_Open(This)	\
    ( (This)->lpVtbl -> Open(This) ) 

#define IOleDocumentView_CloseView(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseView(This,dwReserved) ) 

#define IOleDocumentView_SaveViewState(This,pstm)	\
    ( (This)->lpVtbl -> SaveViewState(This,pstm) ) 

#define IOleDocumentView_ApplyViewState(This,pstm)	\
    ( (This)->lpVtbl -> ApplyViewState(This,pstm) ) 

#define IOleDocumentView_Clone(This,pIPSiteNew,ppViewNew)	\
    ( (This)->lpVtbl -> Clone(This,pIPSiteNew,ppViewNew) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocumentView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPENUMOLEDOCUMENTVIEWS_DEFINED
#define _LPENUMOLEDOCUMENTVIEWS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0003_v0_0_s_ifspec;

#ifndef __IEnumOleDocumentViews_INTERFACE_DEFINED__
#define __IEnumOleDocumentViews_INTERFACE_DEFINED__

/* interface IEnumOleDocumentViews */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumOleDocumentViews *LPENUMOLEDOCUMENTVIEWS;


EXTERN_C const IID IID_IEnumOleDocumentViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc8-4e68-101b-a2bc-00aa00404770")
    IEnumOleDocumentViews : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView **rgpView,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cViews) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOleDocumentViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumOleDocumentViews * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumOleDocumentViews * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumOleDocumentViews * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumOleDocumentViews * This,
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView **rgpView,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumOleDocumentViews * This,
            /* [in] */ ULONG cViews);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumOleDocumentViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumOleDocumentViews * This,
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum);
        
        END_INTERFACE
    } IEnumOleDocumentViewsVtbl;

    interface IEnumOleDocumentViews
    {
        CONST_VTBL struct IEnumOleDocumentViewsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleDocumentViews_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumOleDocumentViews_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumOleDocumentViews_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumOleDocumentViews_Next(This,cViews,rgpView,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cViews,rgpView,pcFetched) ) 

#define IEnumOleDocumentViews_Skip(This,cViews)	\
    ( (This)->lpVtbl -> Skip(This,cViews) ) 

#define IEnumOleDocumentViews_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumOleDocumentViews_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_RemoteNext_Proxy( 
    IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cViews, *pcFetched) IOleDocumentView **rgpView,
    /* [out] */ __RPC__out ULONG *pcFetched);


void __RPC_STUB IEnumOleDocumentViews_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumOleDocumentViews_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPCONTINUECALLBACK_DEFINED
#define _LPCONTINUECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0004_v0_0_s_ifspec;

#ifndef __IContinueCallback_INTERFACE_DEFINED__
#define __IContinueCallback_INTERFACE_DEFINED__

/* interface IContinueCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IContinueCallback *LPCONTINUECALLBACK;


EXTERN_C const IID IID_IContinueCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcca-4e68-101b-a2bc-00aa00404770")
    IContinueCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FContinue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FContinuePrinting( 
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ __RPC__in_opt wchar_t *pwszPrintStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContinueCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContinueCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContinueCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContinueCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *FContinue )( 
            IContinueCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *FContinuePrinting )( 
            IContinueCallback * This,
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ __RPC__in_opt wchar_t *pwszPrintStatus);
        
        END_INTERFACE
    } IContinueCallbackVtbl;

    interface IContinueCallback
    {
        CONST_VTBL struct IContinueCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContinueCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContinueCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContinueCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContinueCallback_FContinue(This)	\
    ( (This)->lpVtbl -> FContinue(This) ) 

#define IContinueCallback_FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)	\
    ( (This)->lpVtbl -> FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContinueCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPPRINT_DEFINED
#define _LPPRINT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0005_v0_0_s_ifspec;

#ifndef __IPrint_INTERFACE_DEFINED__
#define __IPrint_INTERFACE_DEFINED__

/* interface IPrint */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPrint *LPPRINT;

typedef /* [public] */ 
enum __MIDL_IPrint_0001
    {	PRINTFLAG_MAYBOTHERUSER	= 1,
	PRINTFLAG_PROMPTUSER	= 2,
	PRINTFLAG_USERMAYCHANGEPRINTER	= 4,
	PRINTFLAG_RECOMPOSETODEVICE	= 8,
	PRINTFLAG_DONTACTUALLYPRINT	= 16,
	PRINTFLAG_FORCEPROPERTIES	= 32,
	PRINTFLAG_PRINTTOFILE	= 64
    } 	PRINTFLAG;

typedef struct tagPAGERANGE
    {
    LONG nFromPage;
    LONG nToPage;
    } 	PAGERANGE;

typedef struct tagPAGESET
    {
    ULONG cbStruct;
    BOOL fOddPages;
    BOOL fEvenPages;
    ULONG cPageRange;
    PAGERANGE rgPages[ 1 ];
    } 	PAGESET;

#define PAGESET_TOLASTPAGE   ((WORD)(-1L))

EXTERN_C const IID IID_IPrint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc9-4e68-101b-a2bc-00aa00404770")
    IPrint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialPageNum( 
            /* [in] */ LONG nFirstPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageInfo( 
            /* [out] */ __RPC__out LONG *pnFirstPage,
            /* [out] */ __RPC__out LONG *pcPages) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Print( 
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE **pptd,
            /* [out][in] */ PAGESET **ppPageSet,
            /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
            /* [in] */ IContinueCallback *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG *pcPagesPrinted,
            /* [out] */ LONG *pnLastPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrint * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitialPageNum )( 
            IPrint * This,
            /* [in] */ LONG nFirstPage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageInfo )( 
            IPrint * This,
            /* [out] */ __RPC__out LONG *pnFirstPage,
            /* [out] */ __RPC__out LONG *pcPages);
        
        /* [local] */ HRESULT ( __stdcall *Print )( 
            IPrint * This,
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE **pptd,
            /* [out][in] */ PAGESET **ppPageSet,
            /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
            /* [in] */ IContinueCallback *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG *pcPagesPrinted,
            /* [out] */ LONG *pnLastPage);
        
        END_INTERFACE
    } IPrintVtbl;

    interface IPrint
    {
        CONST_VTBL struct IPrintVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrint_SetInitialPageNum(This,nFirstPage)	\
    ( (This)->lpVtbl -> SetInitialPageNum(This,nFirstPage) ) 

#define IPrint_GetPageInfo(This,pnFirstPage,pcPages)	\
    ( (This)->lpVtbl -> GetPageInfo(This,pnFirstPage,pcPages) ) 

#define IPrint_Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)	\
    ( (This)->lpVtbl -> Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IPrint_RemotePrint_Proxy( 
    IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ __RPC__deref_inout_opt DVTARGETDEVICE **pptd,
    /* [out][in] */ __RPC__deref_inout_opt PAGESET **pppageset,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmOptions,
    /* [in] */ __RPC__in_opt IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ __RPC__out LONG *pcPagesPrinted,
    /* [out] */ __RPC__out LONG *pnLastPage);


void __RPC_STUB IPrint_RemotePrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPOLECOMMANDTARGET_DEFINED
#define _LPOLECOMMANDTARGET_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0006_v0_0_s_ifspec;

#ifndef __IOleCommandTarget_INTERFACE_DEFINED__
#define __IOleCommandTarget_INTERFACE_DEFINED__

/* interface IOleCommandTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleCommandTarget *LPOLECOMMANDTARGET;

typedef 
enum OLECMDF
    {	OLECMDF_SUPPORTED	= 0x1,
	OLECMDF_ENABLED	= 0x2,
	OLECMDF_LATCHED	= 0x4,
	OLECMDF_NINCHED	= 0x8,
	OLECMDF_INVISIBLE	= 0x10,
	OLECMDF_DEFHIDEONCTXTMENU	= 0x20
    } 	OLECMDF;

typedef struct _tagOLECMD
    {
    ULONG cmdID;
    DWORD cmdf;
    } 	OLECMD;

typedef struct _tagOLECMDTEXT
    {
    DWORD cmdtextf;
    ULONG cwActual;
    ULONG cwBuf;
    wchar_t rgwz[ 1 ];
    } 	OLECMDTEXT;

typedef 
enum OLECMDTEXTF
    {	OLECMDTEXTF_NONE	= 0,
	OLECMDTEXTF_NAME	= 1,
	OLECMDTEXTF_STATUS	= 2
    } 	OLECMDTEXTF;

typedef 
enum OLECMDEXECOPT
    {	OLECMDEXECOPT_DODEFAULT	= 0,
	OLECMDEXECOPT_PROMPTUSER	= 1,
	OLECMDEXECOPT_DONTPROMPTUSER	= 2,
	OLECMDEXECOPT_SHOWHELP	= 3
    } 	OLECMDEXECOPT;

/* OLECMDID_STOPDOWNLOAD and OLECMDID_ALLOWUILESSSAVEAS are supported for QueryStatus Only */
typedef 
enum OLECMDID
    {	OLECMDID_OPEN	= 1,
	OLECMDID_NEW	= 2,
	OLECMDID_SAVE	= 3,
	OLECMDID_SAVEAS	= 4,
	OLECMDID_SAVECOPYAS	= 5,
	OLECMDID_PRINT	= 6,
	OLECMDID_PRINTPREVIEW	= 7,
	OLECMDID_PAGESETUP	= 8,
	OLECMDID_SPELL	= 9,
	OLECMDID_PROPERTIES	= 10,
	OLECMDID_CUT	= 11,
	OLECMDID_COPY	= 12,
	OLECMDID_PASTE	= 13,
	OLECMDID_PASTESPECIAL	= 14,
	OLECMDID_UNDO	= 15,
	OLECMDID_REDO	= 16,
	OLECMDID_SELECTALL	= 17,
	OLECMDID_CLEARSELECTION	= 18,
	OLECMDID_ZOOM	= 19,
	OLECMDID_GETZOOMRANGE	= 20,
	OLECMDID_UPDATECOMMANDS	= 21,
	OLECMDID_REFRESH	= 22,
	OLECMDID_STOP	= 23,
	OLECMDID_HIDETOOLBARS	= 24,
	OLECMDID_SETPROGRESSMAX	= 25,
	OLECMDID_SETPROGRESSPOS	= 26,
	OLECMDID_SETPROGRESSTEXT	= 27,
	OLECMDID_SETTITLE	= 28,
	OLECMDID_SETDOWNLOADSTATE	= 29,
	OLECMDID_STOPDOWNLOAD	= 30,
	OLECMDID_ONTOOLBARACTIVATED	= 31,
	OLECMDID_FIND	= 32,
	OLECMDID_DELETE	= 33,
	OLECMDID_HTTPEQUIV	= 34,
	OLECMDID_HTTPEQUIV_DONE	= 35,
	OLECMDID_ENABLE_INTERACTION	= 36,
	OLECMDID_ONUNLOAD	= 37,
	OLECMDID_PROPERTYBAG2	= 38,
	OLECMDID_PREREFRESH	= 39,
	OLECMDID_SHOWSCRIPTERROR	= 40,
	OLECMDID_SHOWMESSAGE	= 41,
	OLECMDID_SHOWFIND	= 42,
	OLECMDID_SHOWPAGESETUP	= 43,
	OLECMDID_SHOWPRINT	= 44,
	OLECMDID_CLOSE	= 45,
	OLECMDID_ALLOWUILESSSAVEAS	= 46,
	OLECMDID_DONTDOWNLOADCSS	= 47,
	OLECMDID_UPDATEPAGESTATUS	= 48,
	OLECMDID_PRINT2	= 49,
	OLECMDID_PRINTPREVIEW2	= 50,
	OLECMDID_SETPRINTTEMPLATE	= 51,
	OLECMDID_GETPRINTTEMPLATE	= 52,
	OLECMDID_PAGEACTIONBLOCKED	= 55,
	OLECMDID_PAGEACTIONUIQUERY	= 56,
	OLECMDID_FOCUSVIEWCONTROLS	= 57,
	OLECMDID_FOCUSVIEWCONTROLSQUERY	= 58,
	OLECMDID_SHOWPAGEACTIONMENU	= 59,
	OLECMDID_ADDTRAVELENTRY	= 60,
	OLECMDID_UPDATETRAVELENTRY	= 61,
	OLECMDID_UPDATEBACKFORWARDSTATE	= 62,
	OLECMDID_OPTICAL_ZOOM	= 63,
	OLECMDID_OPTICAL_GETZOOMRANGE	= 64,
	OLECMDID_WINDOWSTATECHANGED	= 65
    } 	OLECMDID;

#define OLECMDERR_E_FIRST            (OLE_E_LAST+1)
#define OLECMDERR_E_NOTSUPPORTED     (OLECMDERR_E_FIRST)
#define OLECMDERR_E_DISABLED         (OLECMDERR_E_FIRST+1)
#define OLECMDERR_E_NOHELP           (OLECMDERR_E_FIRST+2)
#define OLECMDERR_E_CANCELED         (OLECMDERR_E_FIRST+3)
#define OLECMDERR_E_UNKNOWNGROUP     (OLECMDERR_E_FIRST+4)
#define MSOCMDERR_E_FIRST            OLECMDERR_E_FIRST
#define MSOCMDERR_E_NOTSUPPORTED     OLECMDERR_E_NOTSUPPORTED
#define MSOCMDERR_E_DISABLED         OLECMDERR_E_DISABLED
#define MSOCMDERR_E_NOHELP           OLECMDERR_E_NOHELP
#define MSOCMDERR_E_CANCELED         OLECMDERR_E_CANCELED
#define MSOCMDERR_E_UNKNOWNGROUP     OLECMDERR_E_UNKNOWNGROUP
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_HWND     0
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_X        1
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_Y        2
#define OLECMDARGINDEX_ACTIVEXINSTALL_PUBLISHER    0
#define OLECMDARGINDEX_ACTIVEXINSTALL_DISPLAYNAME  1
typedef 
enum IGNOREMIME
    {	IGNOREMIME_PROMPT	= 0x1,
	IGNOREMIME_TEXT	= 0x2
    } 	IGNOREMIME;

typedef 
enum WPCSETTING
    {	WPCSETTING_LOGGING_ENABLED	= 0x1,
	WPCSETTING_FILEDOWNLOAD_BLOCKED	= 0x2
    } 	WPCSETTING;

#endif

EXTERN_C const IID IID_IOleCommandTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bccb-4e68-101b-a2bc-00aa00404770")
    IOleCommandTarget : public IUnknown
    {
    public:
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCommandTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOleCommandTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOleCommandTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOleCommandTarget * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IOleCommandTarget * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IOleCommandTarget * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut);
        
        END_INTERFACE
    } IOleCommandTargetVtbl;

    interface IOleCommandTarget
    {
        CONST_VTBL struct IOleCommandTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCommandTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleCommandTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleCommandTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleCommandTarget_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)	\
    ( (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText) ) 

#define IOleCommandTarget_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)	\
    ( (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleCommandTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0007 */
/* [local] */ 

#endif
typedef enum
{
      OLECMDIDF_REFRESH_NORMAL          = 0,
      OLECMDIDF_REFRESH_IFEXPIRED       = 1,
      OLECMDIDF_REFRESH_CONTINUE        = 2,
      OLECMDIDF_REFRESH_COMPLETELY      = 3,
      OLECMDIDF_REFRESH_NO_CACHE        = 4,
      OLECMDIDF_REFRESH_RELOAD          = 5,
      OLECMDIDF_REFRESH_LEVELMASK       = 0x00FF,
      OLECMDIDF_REFRESH_CLEARUSERINPUT  = 0x1000,
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000,
      OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL = 0x00010000,
      OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD   = 0x00020000,
      OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE   = 0x00040000,
      OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW    = 0x00080000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE  = 0x00100000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED       = 0x00200000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET      = 0x00400000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET      = 0x00800000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED    = 0x01000000,
#elif(NTDDI_VERSION >= NTDDI_WINXP)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000
#else
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000
#endif
      OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT              = 0x02000000,
      OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT              = 0x04000000,
} OLECMDID_REFRESHFLAG;
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
typedef enum
{
      OLECMDIDF_PAGEACTION_FILEDOWNLOAD                       = 0x00000001,
      OLECMDIDF_PAGEACTION_ACTIVEXINSTALL                     = 0x00000002,
      OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL                   = 0x00000004,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE                 = 0x00000008,
      OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW                    = 0x00000010,
      OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE                      = 0x00000020,
      OLECMDIDF_PAGEACTION_POPUPWINDOW                        = 0x00000040,
      OLECMDIDF_PAGEACTION_LOCALMACHINE                       = 0x00000080,
      OLECMDIDF_PAGEACTION_MIMETEXTPLAIN                      = 0x00000100,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE                     = 0x00000200,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL      = 0x00000200,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE           = 0x00000400,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED                = 0x00000800,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET               = 0x00001000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET               = 0x00002000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED             = 0x00004000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY                   = 0x00008000,
      OLECMDIDF_PAGEACTION_POPUPALLOWED                       = 0x00010000,
      OLECMDIDF_PAGEACTION_SCRIPTPROMPT                       = 0x00020000,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL                = 0x00040000,
      OLECMDIDF_PAGEACTION_MIXEDCONTENT                       = 0x00080000,
      OLECMDIDF_PAGEACTION_INVALID_CERT                       = 0x00100000,
      OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST                = 0x00200000,
      OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST                   = 0x00800000,
      OLECMDIDF_PAGEACTION_LOWRIGHTSIE                        = 0x01000000,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 0x02000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED                         = 0x04000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX                 = 0x08000000,
      OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED           = 0x10000000,
      OLECMDIDF_PAGEACTION_NORESETACTIVEX                     = 0x20000000,
      OLECMDIDF_PAGEACTION_GENERIC_STATE                      = 0x40000000,
      OLECMDIDF_PAGEACTION_RESET                              = (int) 0x80000000,
} OLECMDID_PAGEACTIONFLAG;
typedef enum
{
      OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF                      = 0x00000001,
      OLECMDIDF_BROWSERSTATE_IESECURITY                         = 0x00000002,
      OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF                  = 0x00000004,
      OLECMDIDF_BROWSERSTATE_RESET                              = 0x00000008,
} OLECMDID_BROWSERSTATEFLAG;
typedef enum
{
    PAGEACTION_UI_DEFAULT     = 0,
    PAGEACTION_UI_MODAL       = 1,
    PAGEACTION_UI_MODELESS    = 2,
    PAGEACTION_UI_SILENT      = 3,
} PAGEACTION_UI;
#endif
typedef enum
{
    OLECMDIDF_WINDOWSTATE_USERVISIBLE        = 0x00000001,
    OLECMDIDF_WINDOWSTATE_ENABLED            = 0x00000002,
    OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID  = 0x00010000,
    OLECMDIDF_WINDOWSTATE_ENABLED_VALID      = 0x00020000,
} OLECMDID_WINDOWSTATE_FLAG;

////////////////////////////////////////////////////////////////////////////
//  Aliases to original office-compatible names
#define IMsoDocument             IOleDocument
#define IMsoDocumentSite         IOleDocumentSite
#define IMsoView                 IOleDocumentView
#define IEnumMsoView             IEnumOleDocumentViews
#define IMsoCommandTarget        IOleCommandTarget
#define LPMSODOCUMENT            LPOLEDOCUMENT
#define LPMSODOCUMENTSITE        LPOLEDOCUMENTSITE
#define LPMSOVIEW                LPOLEDOCUMENTVIEW
#define LPENUMMSOVIEW            LPENUMOLEDOCUMENTVIEWS
#define LPMSOCOMMANDTARGET       LPOLECOMMANDTARGET
#define MSOCMD                   OLECMD
#define MSOCMDTEXT               OLECMDTEXT
#define IID_IMsoDocument         IID_IOleDocument
#define IID_IMsoDocumentSite     IID_IOleDocumentSite
#define IID_IMsoView             IID_IOleDocumentView
#define IID_IEnumMsoView         IID_IEnumOleDocumentViews
#define IID_IMsoCommandTarget    IID_IOleCommandTarget
#define MSOCMDF_SUPPORTED OLECMDF_SUPPORTED
#define MSOCMDF_ENABLED OLECMDF_ENABLED
#define MSOCMDF_LATCHED OLECMDF_LATCHED
#define MSOCMDF_NINCHED OLECMDF_NINCHED
#define MSOCMDTEXTF_NONE OLECMDTEXTF_NONE
#define MSOCMDTEXTF_NAME OLECMDTEXTF_NAME
#define MSOCMDTEXTF_STATUS OLECMDTEXTF_STATUS
#define MSOCMDEXECOPT_DODEFAULT OLECMDEXECOPT_DODEFAULT
#define MSOCMDEXECOPT_PROMPTUSER OLECMDEXECOPT_PROMPTUSER
#define MSOCMDEXECOPT_DONTPROMPTUSER OLECMDEXECOPT_DONTPROMPTUSER
#define MSOCMDEXECOPT_SHOWHELP OLECMDEXECOPT_SHOWHELP
#define MSOCMDID_OPEN OLECMDID_OPEN
#define MSOCMDID_NEW OLECMDID_NEW
#define MSOCMDID_SAVE OLECMDID_SAVE
#define MSOCMDID_SAVEAS OLECMDID_SAVEAS
#define MSOCMDID_SAVECOPYAS OLECMDID_SAVECOPYAS
#define MSOCMDID_PRINT OLECMDID_PRINT
#define MSOCMDID_PRINTPREVIEW OLECMDID_PRINTPREVIEW
#define MSOCMDID_PAGESETUP OLECMDID_PAGESETUP
#define MSOCMDID_SPELL OLECMDID_SPELL
#define MSOCMDID_PROPERTIES OLECMDID_PROPERTIES
#define MSOCMDID_CUT OLECMDID_CUT
#define MSOCMDID_COPY OLECMDID_COPY
#define MSOCMDID_PASTE OLECMDID_PASTE
#define MSOCMDID_PASTESPECIAL OLECMDID_PASTESPECIAL
#define MSOCMDID_UNDO OLECMDID_UNDO
#define MSOCMDID_REDO OLECMDID_REDO
#define MSOCMDID_SELECTALL OLECMDID_SELECTALL
#define MSOCMDID_CLEARSELECTION OLECMDID_CLEARSELECTION
#define MSOCMDID_ZOOM OLECMDID_ZOOM
#define MSOCMDID_GETZOOMRANGE OLECMDID_GETZOOMRANGE
EXTERN_C const GUID SID_SContainerDispatch;


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0007_v0_0_s_ifspec;

#ifndef __IZoomEvents_INTERFACE_DEFINED__
#define __IZoomEvents_INTERFACE_DEFINED__

/* interface IZoomEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IZoomEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41B68150-904C-4e17-A0BA-A438182E359D")
    IZoomEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnZoomPercentChanged( 
            /* [in] */ ULONG ulZoomPercent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoomEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IZoomEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IZoomEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IZoomEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnZoomPercentChanged )( 
            IZoomEvents * This,
            /* [in] */ ULONG ulZoomPercent);
        
        END_INTERFACE
    } IZoomEventsVtbl;

    interface IZoomEvents
    {
        CONST_VTBL struct IZoomEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoomEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IZoomEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IZoomEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IZoomEvents_OnZoomPercentChanged(This,ulZoomPercent)	\
    ( (This)->lpVtbl -> OnZoomPercentChanged(This,ulZoomPercent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IZoomEvents_INTERFACE_DEFINED__ */


#ifndef __IProtectFocus_INTERFACE_DEFINED__
#define __IProtectFocus_INTERFACE_DEFINED__

/* interface IProtectFocus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectFocus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d81f90a3-8156-44f7-ad28-5abb87003274")
    IProtectFocus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllowFocusChange( 
            /* [out] */ __RPC__out BOOL *pfAllow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProtectFocusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProtectFocus * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProtectFocus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProtectFocus * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllowFocusChange )( 
            IProtectFocus * This,
            /* [out] */ __RPC__out BOOL *pfAllow);
        
        END_INTERFACE
    } IProtectFocusVtbl;

    interface IProtectFocus
    {
        CONST_VTBL struct IProtectFocusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectFocus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProtectFocus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProtectFocus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProtectFocus_AllowFocusChange(This,pfAllow)	\
    ( (This)->lpVtbl -> AllowFocusChange(This,pfAllow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProtectFocus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0009 */
/* [local] */ 

#define SID_SProtectFocus  IID_IProtectFocus
#ifndef _LPPROTECTEDMODEMENUSERVICES_DEFINED
#define _LPPROTECTEDMODEMENUSERVICES_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0009_v0_0_s_ifspec;

#ifndef __IProtectedModeMenuServices_INTERFACE_DEFINED__
#define __IProtectedModeMenuServices_INTERFACE_DEFINED__

/* interface IProtectedModeMenuServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectedModeMenuServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73c105ee-9dff-4a07-b83c-7eff290c266e")
    IProtectedModeMenuServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMenu( 
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenu( 
            /* [string][in] */ __RPC__in LPCWSTR pszModuleName,
            /* [string][in] */ __RPC__in LPCWSTR pszMenuName,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenuID( 
            /* [string][in] */ __RPC__in LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProtectedModeMenuServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProtectedModeMenuServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProtectedModeMenuServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProtectedModeMenuServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMenu )( 
            IProtectedModeMenuServices * This,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE *LoadMenu )( 
            IProtectedModeMenuServices * This,
            /* [string][in] */ __RPC__in LPCWSTR pszModuleName,
            /* [string][in] */ __RPC__in LPCWSTR pszMenuName,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE *LoadMenuID )( 
            IProtectedModeMenuServices * This,
            /* [string][in] */ __RPC__in LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        END_INTERFACE
    } IProtectedModeMenuServicesVtbl;

    interface IProtectedModeMenuServices
    {
        CONST_VTBL struct IProtectedModeMenuServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectedModeMenuServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProtectedModeMenuServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProtectedModeMenuServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProtectedModeMenuServices_CreateMenu(This,phMenu)	\
    ( (This)->lpVtbl -> CreateMenu(This,phMenu) ) 

#define IProtectedModeMenuServices_LoadMenu(This,pszModuleName,pszMenuName,phMenu)	\
    ( (This)->lpVtbl -> LoadMenu(This,pszModuleName,pszMenuName,phMenu) ) 

#define IProtectedModeMenuServices_LoadMenuID(This,pszModuleName,wResourceID,phMenu)	\
    ( (This)->lpVtbl -> LoadMenuID(This,pszModuleName,wResourceID,phMenu) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProtectedModeMenuServices_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0010 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  HMENU_UserSize64(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal64(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal64(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree64(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy( 
    IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView **rgpView,
    /* [out] */ ULONG *pcFetched);


/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub( 
    IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cViews, *pcFetched) IOleDocumentView **rgpView,
    /* [out] */ __RPC__out ULONG *pcFetched);

/* [local] */ HRESULT __stdcall IPrint_Print_Proxy( 
    IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE **pptd,
    /* [out][in] */ PAGESET **ppPageSet,
    /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
    /* [in] */ IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG *pcPagesPrinted,
    /* [out] */ LONG *pnLastPage);


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub( 
    IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ __RPC__deref_inout_opt DVTARGETDEVICE **pptd,
    /* [out][in] */ __RPC__deref_inout_opt PAGESET **pppageset,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmOptions,
    /* [in] */ __RPC__in_opt IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ __RPC__out LONG *pcPagesPrinted,
    /* [out] */ __RPC__out LONG *pnLastPage);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DShow.h ===
//------------------------------------------------------------------------------
// File: DShow.h
//
// Desc: DirectShow top-level include file
//
// Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __DSHOW_INCLUDED__
#define __DSHOW_INCLUDED__

///////////////////////////////////////////////////////////////////////////
// Set up constants & pragmas for the compiler
///////////////////////////////////////////////////////////////////////////
#ifdef  _MSC_VER
// disable some level-4 warnings, use #pragma warning(default:###) to re-enable
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4511) // warning C4511: copy constructor could not be generated
#pragma warning(disable:4512) // warning C4512: assignment operator could not be generated
#pragma warning(disable:4514) // warning C4514: "unreferenced inline function has been removed"

#if _MSC_VER>=1100
#define AM_NOVTABLE __declspec(novtable)
#else
#define AM_NOVTABLE
#endif
#endif  // MSC_VER

///////////////////////////////////////////////////////////////////////////
// Include standard Windows files
///////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include <olectl.h>
#include <ddraw.h>
#include <mmsystem.h>

#ifndef NO_DSHOW_STRSAFE
#define NO_SHLWAPI_STRFCNS
#include <strsafe.h>  
#endif

#ifndef NUMELMS
   #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

///////////////////////////////////////////////////////////////////////////
// Include DirectShow include files
///////////////////////////////////////////////////////////////////////////
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <amvideo.h>    // ActiveMovie video interfaces and definitions

#ifdef DSHOW_USE_AMAUDIO
#include <amaudio.h>    // ActiveMovie audio interfaces and definitions
#endif

#include <control.h>    // generated from control.odl
#include <evcode.h>     // event code definitions
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <errors.h>     // HRESULT status and error definitions
#include <edevdefs.h>   // External device control interface defines
#include <audevcod.h>   // audio filter device error event codes
#include <dvdevcod.h>   // DVD error event codes

///////////////////////////////////////////////////////////////////////////
// Define OLE Automation constants
///////////////////////////////////////////////////////////////////////////
#ifndef OATRUE
#define OATRUE (-1)
#endif // OATRUE
#ifndef OAFALSE
#define OAFALSE (0)
#endif // OAFALSE

///////////////////////////////////////////////////////////////////////////
// Define Win64 interfaces if not already defined
///////////////////////////////////////////////////////////////////////////

// InterlockedExchangePointer
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))
#endif 


#endif // __DSHOW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dpx1.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dpx1.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dpx1_h__
#define __dpx1_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDpxJob_FWD_DEFINED__
#define __IDpxJob_FWD_DEFINED__
typedef interface IDpxJob IDpxJob;
#endif 	/* __IDpxJob_FWD_DEFINED__ */


#ifndef __IDpxContainer_FWD_DEFINED__
#define __IDpxContainer_FWD_DEFINED__
typedef interface IDpxContainer IDpxContainer;
#endif 	/* __IDpxContainer_FWD_DEFINED__ */


#ifndef __IDpxFile_FWD_DEFINED__
#define __IDpxFile_FWD_DEFINED__
typedef interface IDpxFile IDpxFile;
#endif 	/* __IDpxFile_FWD_DEFINED__ */


#ifndef __IDpxContainerDirectoryEntry_FWD_DEFINED__
#define __IDpxContainerDirectoryEntry_FWD_DEFINED__
typedef interface IDpxContainerDirectoryEntry IDpxContainerDirectoryEntry;
#endif 	/* __IDpxContainerDirectoryEntry_FWD_DEFINED__ */


#ifndef __IDpxDownloadProvider_FWD_DEFINED__
#define __IDpxDownloadProvider_FWD_DEFINED__
typedef interface IDpxDownloadProvider IDpxDownloadProvider;
#endif 	/* __IDpxDownloadProvider_FWD_DEFINED__ */


#ifndef __IDpxDownloadCallback_FWD_DEFINED__
#define __IDpxDownloadCallback_FWD_DEFINED__
typedef interface IDpxDownloadCallback IDpxDownloadCallback;
#endif 	/* __IDpxDownloadCallback_FWD_DEFINED__ */


#ifndef __IEnumDpxContainers_FWD_DEFINED__
#define __IEnumDpxContainers_FWD_DEFINED__
typedef interface IEnumDpxContainers IEnumDpxContainers;
#endif 	/* __IEnumDpxContainers_FWD_DEFINED__ */


#ifndef __IEnumDpxFiles_FWD_DEFINED__
#define __IEnumDpxFiles_FWD_DEFINED__
typedef interface IEnumDpxFiles IEnumDpxFiles;
#endif 	/* __IEnumDpxFiles_FWD_DEFINED__ */


#ifndef __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__
#define __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__
typedef interface IEnumDpxContainerDirectoryEntries IEnumDpxContainerDirectoryEntries;
#endif 	/* __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dpx1_0000_0000 */
/* [local] */ 

// Copyright (c) Microsoft Corporation.  All rights reserved.

#include <SpecStrings.h>
typedef unsigned int ALG_ID;










typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_dpx1_0000_0000_0001
    {	DPX_RESUME_AND_DOWNLOAD	= 0,
	DPX_RESUME_UNTIL_DOWNLOAD	= 0x1,
	DPX_RESUME_AND_DOWNLOAD_FALLBACK	= 0x2
    } 	DPX_RESUME_TYPE;

#define DPX_MAX_HASH_SIZE 64
typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0002
    {
    ALG_ID AlgorithmId;
    UINT HashSize;
    BYTE HashData[ 64 ];
    } 	DPX_HASH;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0003
    {
    UINT64 Offset;
    UINT64 Length;
    } 	DPX_BYTE_RANGE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_dpx1_0000_0000_0004
    {	DPX_PHASE_JOB_IDLE	= 0,
	DPX_PHASE_DOWNLOAD_INDEX	= 0x10,
	DPX_PHASE_INVENTORY	= 0x20,
	DPX_PHASE_DOWNLOAD_FILES	= 0x30,
	DPX_PHASE_EXPAND_FILES	= 0x40,
	DPX_PHASE_JOB_INPROGRESS	= 0x50,
	DPX_PHASE_JOB_COMPLETE	= 0x7f00,
	DPX_PHASE_JOB_CANCELLED	= 0xfffe,
	DPX_PHASE_JOB_FAILURE	= 0xffff
    } 	DPX_PROGRESS_PHASE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0005
    {
    UINT64 Completed;
    UINT64 Remaining;
    } 	DPX_PROGRESS_REMAIN;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0006
    {
    DPX_PROGRESS_REMAIN Inventory;
    DPX_PROGRESS_REMAIN Download;
    DPX_PROGRESS_REMAIN Expansion;
    DPX_PROGRESS_REMAIN Files;
    DPX_PROGRESS_REMAIN Overall;
    DPX_PROGRESS_PHASE ePhase;
    } 	DPX_PROGRESS;



extern RPC_IF_HANDLE __MIDL_itf_dpx1_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dpx1_0000_0000_v0_0_s_ifspec;

#ifndef __IDpxJob_INTERFACE_DEFINED__
#define __IDpxJob_INTERFACE_DEFINED__

/* interface IDpxJob */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b711-0e55-452f-838e-d1505b866e2b")
    IDpxJob : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetPath( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *TargetPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddContainer( 
            /* [in] */ __RPC__in LPCWSTR ContainerPath,
            /* [out] */ __RPC__deref_out_opt IDpxContainer **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContainers( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnumContainers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDownloadProvider( 
            /* [unique][in] */ __RPC__in_opt IDpxDownloadProvider *pDownloadProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProvider( 
            /* [out] */ __RPC__deref_out_opt IDpxDownloadProvider **ppDownloadProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            DPX_RESUME_TYPE eResumeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ __RPC__out DPX_PROGRESS *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveJobState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptionValue( 
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR OptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionValue( 
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pOptionValue) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetPath )( 
            IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *TargetPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddContainer )( 
            IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR ContainerPath,
            /* [out] */ __RPC__deref_out_opt IDpxContainer **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContainers )( 
            IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnumContainers);
        
        HRESULT ( STDMETHODCALLTYPE *SetDownloadProvider )( 
            IDpxJob * This,
            /* [unique][in] */ __RPC__in_opt IDpxDownloadProvider *pDownloadProvider);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadProvider )( 
            IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt IDpxDownloadProvider **ppDownloadProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDpxJob * This,
            DPX_RESUME_TYPE eResumeType);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IDpxJob * This,
            /* [out] */ __RPC__out DPX_PROGRESS *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE *SaveJobState )( 
            IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            IDpxJob * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            IDpxJob * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptionValue )( 
            IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR OptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptionValue )( 
            IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pOptionValue);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxJob * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxJobVtbl;

    interface IDpxJob
    {
        CONST_VTBL struct IDpxJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxJob_GetTargetPath(This,TargetPath)	\
    ( (This)->lpVtbl -> GetTargetPath(This,TargetPath) ) 

#define IDpxJob_AddContainer(This,ContainerPath,ppContainer)	\
    ( (This)->lpVtbl -> AddContainer(This,ContainerPath,ppContainer) ) 

#define IDpxJob_EnumContainers(This,ppEnumContainers)	\
    ( (This)->lpVtbl -> EnumContainers(This,ppEnumContainers) ) 

#define IDpxJob_SetDownloadProvider(This,pDownloadProvider)	\
    ( (This)->lpVtbl -> SetDownloadProvider(This,pDownloadProvider) ) 

#define IDpxJob_GetDownloadProvider(This,ppDownloadProvider)	\
    ( (This)->lpVtbl -> GetDownloadProvider(This,ppDownloadProvider) ) 

#define IDpxJob_Resume(This,eResumeType)	\
    ( (This)->lpVtbl -> Resume(This,eResumeType) ) 

#define IDpxJob_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IDpxJob_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDpxJob_GetProgress(This,pProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,pProgress) ) 

#define IDpxJob_SaveJobState(This)	\
    ( (This)->lpVtbl -> SaveJobState(This) ) 

#define IDpxJob_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxJob_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxJob_SetOptionValue(This,OptionName,OptionValue)	\
    ( (This)->lpVtbl -> SetOptionValue(This,OptionName,OptionValue) ) 

#define IDpxJob_GetOptionValue(This,OptionName,pOptionValue)	\
    ( (This)->lpVtbl -> GetOptionValue(This,OptionName,pOptionValue) ) 

#define IDpxJob_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxJob_INTERFACE_DEFINED__ */


#ifndef __IDpxContainer_INTERFACE_DEFINED__
#define __IDpxContainer_INTERFACE_DEFINED__

/* interface IDpxContainer */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b712-0e55-452f-838e-d1505b866e2b")
    IDpxContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContainerPath( 
            /* [in] */ __RPC__in LPCWSTR ContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerPath( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFileToExtract( 
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [unique][in] */ __RPC__in_opt DPX_HASH *TargetFileHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFileToExtract2( 
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [out] */ __RPC__deref_out_opt IDpxFile **ppFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExtractAllFiles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilesToExtract( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnumFiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpectedContainerIndexHash( 
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedContainerIndexHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideContainerIndex( 
            /* [in] */ UINT IndexSize,
            /* [size_is][in] */ __RPC__in_ecount_full(IndexSize) BYTE IndexData[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideContainerIndexByFile( 
            /* [in] */ __RPC__in LPCWSTR IndexFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDirectoryEntries( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnumEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetContainerPath )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR ContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerPath )( 
            IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileToExtract )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [unique][in] */ __RPC__in_opt DPX_HASH *TargetFileHash);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileToExtract2 )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [out] */ __RPC__deref_out_opt IDpxFile **ppFile);
        
        HRESULT ( STDMETHODCALLTYPE *ExtractAllFiles )( 
            IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilesToExtract )( 
            IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnumFiles);
        
        HRESULT ( STDMETHODCALLTYPE *SetExpectedContainerIndexHash )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpectedContainerIndexHash )( 
            IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideContainerIndex )( 
            IDpxContainer * This,
            /* [in] */ UINT IndexSize,
            /* [size_is][in] */ __RPC__in_ecount_full(IndexSize) BYTE IndexData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideContainerIndexByFile )( 
            IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR IndexFileName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDirectoryEntries )( 
            IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnumEntries);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            IDpxContainer * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            IDpxContainer * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxContainer * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxContainerVtbl;

    interface IDpxContainer
    {
        CONST_VTBL struct IDpxContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxContainer_SetContainerPath(This,ContainerPath)	\
    ( (This)->lpVtbl -> SetContainerPath(This,ContainerPath) ) 

#define IDpxContainer_GetContainerPath(This,pContainerPath)	\
    ( (This)->lpVtbl -> GetContainerPath(This,pContainerPath) ) 

#define IDpxContainer_AddFileToExtract(This,SourceFileName,TargetFileName,TargetFileHash)	\
    ( (This)->lpVtbl -> AddFileToExtract(This,SourceFileName,TargetFileName,TargetFileHash) ) 

#define IDpxContainer_AddFileToExtract2(This,SourceFileName,TargetFileName,ppFile)	\
    ( (This)->lpVtbl -> AddFileToExtract2(This,SourceFileName,TargetFileName,ppFile) ) 

#define IDpxContainer_ExtractAllFiles(This)	\
    ( (This)->lpVtbl -> ExtractAllFiles(This) ) 

#define IDpxContainer_EnumFilesToExtract(This,ppEnumFiles)	\
    ( (This)->lpVtbl -> EnumFilesToExtract(This,ppEnumFiles) ) 

#define IDpxContainer_SetExpectedContainerIndexHash(This,pExpectedHash)	\
    ( (This)->lpVtbl -> SetExpectedContainerIndexHash(This,pExpectedHash) ) 

#define IDpxContainer_GetExpectedContainerIndexHash(This,ppExpectedHash)	\
    ( (This)->lpVtbl -> GetExpectedContainerIndexHash(This,ppExpectedHash) ) 

#define IDpxContainer_ProvideContainerIndex(This,IndexSize,IndexData)	\
    ( (This)->lpVtbl -> ProvideContainerIndex(This,IndexSize,IndexData) ) 

#define IDpxContainer_ProvideContainerIndexByFile(This,IndexFileName)	\
    ( (This)->lpVtbl -> ProvideContainerIndexByFile(This,IndexFileName) ) 

#define IDpxContainer_EnumDirectoryEntries(This,ppEnumEntries)	\
    ( (This)->lpVtbl -> EnumDirectoryEntries(This,ppEnumEntries) ) 

#define IDpxContainer_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#define IDpxContainer_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxContainer_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxContainer_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxContainer_INTERFACE_DEFINED__ */


#ifndef __IDpxFile_INTERFACE_DEFINED__
#define __IDpxFile_INTERFACE_DEFINED__

/* interface IDpxFile */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b713-0e55-452f-838e-d1505b866e2b")
    IDpxFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourceFileName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pSourceFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetFileName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pTargetFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpectedHash( 
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out HRESULT *pStatus) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxFile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceFileName )( 
            IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pSourceFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFileName )( 
            IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pTargetFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetExpectedHash )( 
            IDpxFile * This,
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpectedHash )( 
            IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IDpxFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            IDpxFile * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            IDpxFile * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IDpxFile * This,
            /* [out] */ __RPC__out HRESULT *pStatus);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxFile * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxFileVtbl;

    interface IDpxFile
    {
        CONST_VTBL struct IDpxFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxFile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxFile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxFile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxFile_GetSourceFileName(This,pSourceFileName)	\
    ( (This)->lpVtbl -> GetSourceFileName(This,pSourceFileName) ) 

#define IDpxFile_GetTargetFileName(This,pTargetFileName)	\
    ( (This)->lpVtbl -> GetTargetFileName(This,pTargetFileName) ) 

#define IDpxFile_SetExpectedHash(This,pExpectedHash)	\
    ( (This)->lpVtbl -> SetExpectedHash(This,pExpectedHash) ) 

#define IDpxFile_GetExpectedHash(This,ppExpectedHash)	\
    ( (This)->lpVtbl -> GetExpectedHash(This,ppExpectedHash) ) 

#define IDpxFile_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#define IDpxFile_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxFile_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxFile_GetStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pStatus) ) 

#define IDpxFile_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxFile_INTERFACE_DEFINED__ */


#ifndef __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__
#define __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__

/* interface IDpxContainerDirectoryEntry */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxContainerDirectoryEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b715-0e55-452f-838e-d1505b866e2b")
    IDpxContainerDirectoryEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pDirEntryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **pDirEntryHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out UINT64 *pDirEntrySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ __RPC__out FILETIME *pDirEntryTime) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxContainerDirectoryEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxContainerDirectoryEntry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxContainerDirectoryEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxContainerDirectoryEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pDirEntryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHash )( 
            IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **pDirEntryHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__out UINT64 *pDirEntrySize);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__out FILETIME *pDirEntryTime);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxContainerDirectoryEntry * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxContainerDirectoryEntryVtbl;

    interface IDpxContainerDirectoryEntry
    {
        CONST_VTBL struct IDpxContainerDirectoryEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxContainerDirectoryEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxContainerDirectoryEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxContainerDirectoryEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxContainerDirectoryEntry_GetName(This,pDirEntryName)	\
    ( (This)->lpVtbl -> GetName(This,pDirEntryName) ) 

#define IDpxContainerDirectoryEntry_GetHash(This,pDirEntryHash)	\
    ( (This)->lpVtbl -> GetHash(This,pDirEntryHash) ) 

#define IDpxContainerDirectoryEntry_GetSize(This,pDirEntrySize)	\
    ( (This)->lpVtbl -> GetSize(This,pDirEntrySize) ) 

#define IDpxContainerDirectoryEntry_GetTime(This,pDirEntryTime)	\
    ( (This)->lpVtbl -> GetTime(This,pDirEntryTime) ) 

#define IDpxContainerDirectoryEntry_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__ */


#ifndef __IDpxDownloadProvider_INTERFACE_DEFINED__
#define __IDpxDownloadProvider_INTERFACE_DEFINED__

/* interface IDpxDownloadProvider */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxDownloadProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b716-0e55-452f-838e-d1505b866e2b")
    IDpxDownloadProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProvideDataCallback( 
            /* [in] */ __RPC__in_opt IDpxDownloadCallback *pProvideData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProvideDataCallback( 
            /* [out] */ __RPC__deref_out_opt IDpxDownloadCallback **ppProvideData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddContainer( 
            /* [in] */ __RPC__in LPCWSTR ContainerFilePath,
            /* [in] */ UINT64 ContainerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRanges( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainers( 
            /* [out] */ __RPC__out UINT *ContainerCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*ContainerCount) UINT64 **ppContainerIdArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerPath( 
            /* [in] */ UINT64 ContainerId,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRanges( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ BOOL IncludeCompletedRanges,
            /* [out] */ __RPC__out UINT *RangeCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*RangeCount) DPX_BYTE_RANGE **ppRangeArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ DWORD TimeoutMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ __RPC__out DPX_PROGRESS_REMAIN *pDownloadProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRequest( void) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxDownloadProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxDownloadProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxDownloadProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProvideDataCallback )( 
            IDpxDownloadProvider * This,
            /* [in] */ __RPC__in_opt IDpxDownloadCallback *pProvideData);
        
        HRESULT ( STDMETHODCALLTYPE *GetProvideDataCallback )( 
            IDpxDownloadProvider * This,
            /* [out] */ __RPC__deref_out_opt IDpxDownloadCallback **ppProvideData);
        
        HRESULT ( STDMETHODCALLTYPE *AddContainer )( 
            IDpxDownloadProvider * This,
            /* [in] */ __RPC__in LPCWSTR ContainerFilePath,
            /* [in] */ UINT64 ContainerId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRanges )( 
            IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainers )( 
            IDpxDownloadProvider * This,
            /* [out] */ __RPC__out UINT *ContainerCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*ContainerCount) UINT64 **ppContainerIdArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerPath )( 
            IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetRanges )( 
            IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ BOOL IncludeCompletedRanges,
            /* [out] */ __RPC__out UINT *RangeCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*RangeCount) DPX_BYTE_RANGE **ppRangeArray);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IDpxDownloadProvider * This,
            /* [in] */ DWORD TimeoutMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IDpxDownloadProvider * This,
            /* [out] */ __RPC__out DPX_PROGRESS_REMAIN *pDownloadProgress);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRequest )( 
            IDpxDownloadProvider * This);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxDownloadProvider * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxDownloadProviderVtbl;

    interface IDpxDownloadProvider
    {
        CONST_VTBL struct IDpxDownloadProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxDownloadProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxDownloadProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxDownloadProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxDownloadProvider_SetProvideDataCallback(This,pProvideData)	\
    ( (This)->lpVtbl -> SetProvideDataCallback(This,pProvideData) ) 

#define IDpxDownloadProvider_GetProvideDataCallback(This,ppProvideData)	\
    ( (This)->lpVtbl -> GetProvideDataCallback(This,ppProvideData) ) 

#define IDpxDownloadProvider_AddContainer(This,ContainerFilePath,ContainerId)	\
    ( (This)->lpVtbl -> AddContainer(This,ContainerFilePath,ContainerId) ) 

#define IDpxDownloadProvider_AddRanges(This,ContainerId,RangeCount,RangeList)	\
    ( (This)->lpVtbl -> AddRanges(This,ContainerId,RangeCount,RangeList) ) 

#define IDpxDownloadProvider_GetContainers(This,ContainerCount,ppContainerIdArray)	\
    ( (This)->lpVtbl -> GetContainers(This,ContainerCount,ppContainerIdArray) ) 

#define IDpxDownloadProvider_GetContainerPath(This,ContainerId,ContainerPath)	\
    ( (This)->lpVtbl -> GetContainerPath(This,ContainerId,ContainerPath) ) 

#define IDpxDownloadProvider_GetRanges(This,ContainerId,IncludeCompletedRanges,RangeCount,ppRangeArray)	\
    ( (This)->lpVtbl -> GetRanges(This,ContainerId,IncludeCompletedRanges,RangeCount,ppRangeArray) ) 

#define IDpxDownloadProvider_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDpxDownloadProvider_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IDpxDownloadProvider_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDpxDownloadProvider_WaitForCompletion(This,TimeoutMilliseconds)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,TimeoutMilliseconds) ) 

#define IDpxDownloadProvider_GetProgress(This,pDownloadProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,pDownloadProgress) ) 

#define IDpxDownloadProvider_ClearRequest(This)	\
    ( (This)->lpVtbl -> ClearRequest(This) ) 

#define IDpxDownloadProvider_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxDownloadProvider_INTERFACE_DEFINED__ */


#ifndef __IDpxDownloadCallback_INTERFACE_DEFINED__
#define __IDpxDownloadCallback_INTERFACE_DEFINED__

/* interface IDpxDownloadCallback */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxDownloadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b717-0e55-452f-838e-d1505b866e2b")
    IDpxDownloadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedData( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) const BYTE *RangeData[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedDataByFile( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeArray[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) UINT64 OffsetInResponseFile[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedDataByPackedRangeFile( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxDownloadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDpxDownloadCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDpxDownloadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDpxDownloadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedData )( 
            IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) const BYTE *RangeData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedDataByFile )( 
            IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeArray[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) UINT64 OffsetInResponseFile[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedDataByPackedRangeFile )( 
            IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath);
        
        END_INTERFACE
    } IDpxDownloadCallbackVtbl;

    interface IDpxDownloadCallback
    {
        CONST_VTBL struct IDpxDownloadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxDownloadCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxDownloadCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxDownloadCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxDownloadCallback_ProvideRequestedData(This,ContainerId,RangeCount,RangeList,RangeData)	\
    ( (This)->lpVtbl -> ProvideRequestedData(This,ContainerId,RangeCount,RangeList,RangeData) ) 

#define IDpxDownloadCallback_ProvideRequestedDataByFile(This,ContainerId,ResponseFilePath,RangeCount,RangeArray,OffsetInResponseFile)	\
    ( (This)->lpVtbl -> ProvideRequestedDataByFile(This,ContainerId,ResponseFilePath,RangeCount,RangeArray,OffsetInResponseFile) ) 

#define IDpxDownloadCallback_ProvideRequestedDataByPackedRangeFile(This,ContainerId,ResponseFilePath)	\
    ( (This)->lpVtbl -> ProvideRequestedDataByPackedRangeFile(This,ContainerId,ResponseFilePath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxDownloadCallback_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxContainers_INTERFACE_DEFINED__
#define __IEnumDpxContainers_INTERFACE_DEFINED__

/* interface IEnumDpxContainers */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxContainers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b722-0e55-452f-838e-d1505b866e2b")
    IEnumDpxContainers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainer **ppContainers,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxContainersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDpxContainers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDpxContainers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDpxContainers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDpxContainers * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainer **ppContainers,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDpxContainers * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDpxContainers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDpxContainers * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDpxContainers * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxContainersVtbl;

    interface IEnumDpxContainers
    {
        CONST_VTBL struct IEnumDpxContainersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxContainers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxContainers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxContainers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxContainers_Next(This,ItemCount,ppContainers,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppContainers,pFetchedCount) ) 

#define IEnumDpxContainers_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxContainers_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxContainers_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxContainers_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxContainers_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxFiles_INTERFACE_DEFINED__
#define __IEnumDpxFiles_INTERFACE_DEFINED__

/* interface IEnumDpxFiles */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b723-0e55-452f-838e-d1505b866e2b")
    IEnumDpxFiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxFile **ppFiles,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDpxFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDpxFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDpxFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDpxFiles * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxFile **ppFiles,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDpxFiles * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDpxFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDpxFiles * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDpxFiles * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxFilesVtbl;

    interface IEnumDpxFiles
    {
        CONST_VTBL struct IEnumDpxFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxFiles_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxFiles_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxFiles_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxFiles_Next(This,ItemCount,ppFiles,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppFiles,pFetchedCount) ) 

#define IEnumDpxFiles_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxFiles_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxFiles_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxFiles_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxFiles_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__
#define __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__

/* interface IEnumDpxContainerDirectoryEntries */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxContainerDirectoryEntries;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b725-0e55-452f-838e-d1505b866e2b")
    IEnumDpxContainerDirectoryEntries : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainerDirectoryEntry **ppDirectoryEntries,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxContainerDirectoryEntriesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDpxContainerDirectoryEntries * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDpxContainerDirectoryEntries * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainerDirectoryEntry **ppDirectoryEntries,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDpxContainerDirectoryEntries * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDpxContainerDirectoryEntries * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDpxContainerDirectoryEntries * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxContainerDirectoryEntriesVtbl;

    interface IEnumDpxContainerDirectoryEntries
    {
        CONST_VTBL struct IEnumDpxContainerDirectoryEntriesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxContainerDirectoryEntries_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxContainerDirectoryEntries_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxContainerDirectoryEntries_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxContainerDirectoryEntries_Next(This,ItemCount,ppDirectoryEntries,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppDirectoryEntries,pFetchedCount) ) 

#define IEnumDpxContainerDirectoryEntries_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxContainerDirectoryEntries_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxContainerDirectoryEntries_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxContainerDirectoryEntries_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\drmexternals.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for drmexternals.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __drmexternals_h__
#define __drmexternals_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wmdrmsdk.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_drmexternals_0000_0000 */
/* [local] */ 

static const WCHAR *g_wszWMDRM_IsDRM                             = L"IsDRM";
static const WCHAR *g_wszWMDRM_IsDRMCached                       = L"IsDRMCached";
static const WCHAR *g_wszWMDRM_BaseLicenseAcqURL                 = L"BaseLAURL";
static const WCHAR *g_wszWMDRM_Rights                            = L"Rights";
static const WCHAR *g_wszWMDRM_LicenseID                         = L"LID";
static const WCHAR *g_wszWMDRM_DRMHeader                         = L"DRMHeader.";
static const WCHAR *g_wszWMDRM_DRMHeader_KeyID                   = L"DRMHeader.KID";
static const WCHAR *g_wszWMDRM_DRMHeader_LicenseAcqURL           = L"DRMHeader.LAINFO";
static const WCHAR *g_wszWMDRM_DRMHeader_ContentID               = L"DRMHeader.CID";
static const WCHAR *g_wszWMDRM_DRMHeader_IndividualizedVersion   = L"DRMHeader.SECURITYVERSION";
static const WCHAR *g_wszWMDRM_DRMHeader_ContentDistributor      = L"DRMHeader.ContentDistributor";
static const WCHAR *g_wszWMDRM_DRMHeader_SubscriptionContentID   = L"DRMHeader.SubscriptionContentID";
#ifndef DRM_PLAYLIST_TYPES_DEFINED
#define DRM_PLAYLIST_TYPES_DEFINED 1
#define DRM_PLAYLIST_DATA_V2_VALID         ((DWORD) 0x00000001)
#define DRM_PLAYLIST_DATA_V1_VALID         ((DWORD) 0x00000002)
#define DRM_PLAYLIST_DATA_OTHER_VALID      ((DWORD) 0x00000004)
#define DRM_CANCEL_PLAYLIST_BURN          ((DWORD) 0x00000001)
#define DRM_COMMIT_PLAYLIST_BURN          ((DWORD) 0x00000002)
typedef struct __tagDRM_PLAYLIST_CONTENT_ID
    {
    LPCWSTR lpcwszV2Header;
    LPCSTR lpcszV1KID;
    BYTE *pbOtherData;
    DWORD cbOtherData;
    DWORD dwUniqueIDForSession;
    DWORD dwValidFields;
    } 	DRM_PLAYLIST_CONTENT_ID;

#endif // DRM_PLAYLIST_TYPES_DEFINED
typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SAVE_STREAM_PROTECTED	= 0x40,
	WMT_RIGHT_COPY	= 0x80,
	WMT_RIGHT_COLLABORATIVE_PLAY	= 0x100,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    } 	WMT_RIGHTS;

#define DRM_DEVICE_REGISTER_TYPE_STREAMING      ((DWORD) 0x00000001)
#define DRM_DEVICE_REGISTER_TYPE_STORAGE        ((DWORD) 0x00000002)
#ifndef DRM_PROTECTION_SCHEMES_DEFINED
#define DRM_PROTECTION_SCHEMES_DEFINED 1
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_ACP,                      0xc3fd11c6, 0xf8b7, 0x4d20, 0xB0, 0x08, 0x1d, 0xb1, 0x7d, 0x61, 0xf2, 0xda );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION,       0xd783a191, 0xe083, 0x4baf, 0xb2, 0xda, 0xe6, 0x9f, 0x91, 0x0b, 0x37, 0x72 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION, 0x811c5110, 0x46c8, 0x4c6e, 0x81, 0x63, 0xc0, 0x48, 0x2a, 0x15, 0xd4, 0x7e );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_DOWNSAMPLE_REQUIRED,      0x8f81a453, 0x998c, 0x4596, 0xb1, 0x50, 0xf8, 0x48, 0x6d, 0xf6, 0xf2, 0xe6 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_1,         0xd9619433, 0xec9f, 0x489e, 0x9e, 0x07, 0x77, 0x0d, 0xed, 0xd8, 0xbd, 0x04 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_2,         0xa24f0a24, 0x5c92, 0x4737, 0x9b, 0x21, 0xa2, 0x3e, 0x4f, 0xed, 0x32, 0x2e );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_3,         0xc4db4310, 0xa1ae, 0x422e, 0xb7, 0xa7, 0x21, 0xbc, 0x34, 0x73, 0xda, 0x77 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_4,         0xe84e4d21, 0x3b1c, 0x44bc, 0xa2, 0xec, 0xc4, 0x81, 0x08, 0x58, 0x7c, 0xad );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_1,         0xec3a1c03, 0xdd4e, 0x47f7, 0xbf, 0xe5, 0xae, 0xe7, 0x53, 0x48, 0x66, 0x71 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_2,         0x327803ca, 0xd914, 0x4da3, 0x97, 0x28, 0xe1, 0x9e, 0x82, 0xbe, 0x8c, 0x25 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_3,         0x36d9c83f, 0xaf07, 0x4727, 0xab, 0x74, 0xca, 0x69, 0x31, 0xba, 0x69, 0xf3 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_4,         0x9443d876, 0x1d46, 0x40cb, 0xbd, 0xe5, 0x9c, 0xc1, 0x46, 0x4c, 0x9b, 0xaf );
#endif // DRM_PROTECTION_SCHEMES_DEFINED
#ifndef DRM_WM_GET_LIC_DATA_DEFINED
#define DRM_WM_GET_LIC_DATA_DEFINED 1
typedef struct _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    BSTR wszURL;
    WCHAR *wszLocalFilename;
    BYTE *pbPostData;
    DWORD dwPostDataSize;
    } 	WM_GET_LICENSE_DATA;

#endif // DRM_WM_GET_LIC_DATA_DEFINED
#define WMDRM_KEYTYPE_RC4       0
#define WMDRM_KEYTYPE_COCKTAIL  1
#ifndef WMDRM_IMPORT_SESSION_KEY_DEFINED
#define WMDRM_IMPORT_SESSION_KEY_DEFINED 1
typedef struct __tagWMDRM_IMPORT_SESSION_KEY
    {
    DWORD dwKeyType;
    DWORD cbKey;
    BYTE rgbKey[ 1 ];
    } 	WMDRM_IMPORT_SESSION_KEY;

#endif // WMDRM_IMPORT_SESSION_KEY_DEFINED
#ifndef WMDRM_IMPORT_CONTENT_KEY_DEFINED
#define WMDRM_IMPORT_CONTENT_KEY_DEFINED 1
typedef struct __tagWMDRM_IMPORT_CONTENT_KEY
    {
    DWORD dwVersion;
    DWORD cbStructSize;
    DWORD dwIVKeyType;
    DWORD cbIVKey;
    DWORD dwContentKeyType;
    DWORD cbContentKey;
    BYTE rgbKeyData[ 1 ];
    } 	WMDRM_IMPORT_CONTENT_KEY;

#endif // WMDRM_IMPORT_CONTENT_KEY_DEFINED
#ifndef WMDRM_IMPORT_INIT_STRUCT_DEFINED
#define WMDRM_IMPORT_INIT_STRUCT_DEFINED 1
typedef struct WMDRM_IMPORT_INIT_STRUCT
    {
    DWORD dwVersion;
    DWORD cbEncryptedSessionKeyMessage;
    BYTE *pbEncryptedSessionKeyMessage;
    DWORD cbEncryptedKeyMessage;
    BYTE *pbEncryptedKeyMessage;
    } 	WMDRM_IMPORT_INIT_STRUCT;

#endif // WMDRM_IMPORT_INIT_STRUCT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DSQuery.h ===
#ifndef __dsquery_h
#define __dsquery_h

//
// query handler ID for dsquery.
//

DEFINE_GUID(CLSID_DsQuery, 0x8a23e65e, 0x31c2, 0x11d0, 0x89, 0x1c, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// standard forms shipped in dsquery.dll
//

DEFINE_GUID(CLSID_DsFindObjects, 0x83ee3fe1, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPeople, 0x83ee3fe2, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPrinter, 0xb577f070, 0x7ee2, 0x11d0, 0x91, 0x3f, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindComputer, 0x16006700, 0x87ad, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindVolume, 0xc1b3cbf1, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindContainer, 0xc1b3cbf2, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindAdvanced, 0x83ee3fe3, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// admin forms
//

DEFINE_GUID(CLSID_DsFindDomainController, 0x538c7b7e, 0xd25e, 0x11d0, 0x97, 0x42, 0x0, 0xa0, 0xc9, 0x6, 0xaf, 0x45);
DEFINE_GUID(CLSID_DsFindWriteableDomainController, 0x7cbef079, 0xaa84, 0x444b, 0xbc, 0x70, 0x68, 0xe4, 0x12, 0x83, 0xea, 0xbc);
DEFINE_GUID(CLSID_DsFindFrsMembers, 0x94ce4b18, 0xb3d3, 0x11d1, 0xb9, 0xb4, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);


#ifndef GUID_DEFS_ONLY

//
// DSQUERYINITPARAMS
// -----------------
//  This structured is used when creating a new query view.
//

#define DSQPF_NOSAVE                 0x00000001 // = 1 => remove save verb
#define DSQPF_SAVELOCATION           0x00000002 // = 1 => pSaveLocation contains directory to save queries into
#define DSQPF_SHOWHIDDENOBJECTS      0x00000004 // = 1 => show objects marked as "hidden" in results
#define DSQPF_ENABLEADMINFEATURES    0x00000008 // = 1 => show admin verbs, property pages etc
#define DSQPF_ENABLEADVANCEDFEATURES 0x00000010 // = 1 => set the advanced flag for the property pages
#define DSQPF_HASCREDENTIALS         0x00000020 // = 1 => pServer, pUserName & pPassword are valid
#define DSQPF_NOCHOOSECOLUMNS        0x00000040 // = 1 => remove choose columns from view

typedef struct
{
    DWORD  cbStruct;
    DWORD  dwFlags;
    LPWSTR pDefaultScope;           // -> Active Directory path to use as scope / == NULL for none
    LPWSTR pDefaultSaveLocation;    // -> Directory to save queries into / == NULL default location
    LPWSTR pUserName;               // -> user name to authenticate with
    LPWSTR pPassword;               // -> password for authentication
    LPWSTR pServer;                 // -> server to use for obtaining trusts etc
} DSQUERYINITPARAMS, * LPDSQUERYINITPARAMS;


//
// DSQUERYPARAMS
// -------------
//  The DS query handle takes a packed structure which contains the
//  columns and query to be issued.
//

#define CFSTR_DSQUERYPARAMS         TEXT("DsQueryParameters")

#define DSCOLUMNPROP_ADSPATH        ((LONG)(-1))
#define DSCOLUMNPROP_OBJECTCLASS    ((LONG)(-2))

typedef struct
{
    DWORD dwFlags;                  // flags for this column
    INT   fmt;                      // list view form information
    INT   cx;                       // default column width
    INT   idsName;                  // resource ID for the column dispaly name
    LONG  offsetProperty;           // offset to BSTR defining column ADs property name
    DWORD dwReserved;               // reserved field
} DSCOLUMN, * LPDSCOLUMN;

typedef struct
{
    DWORD     cbStruct;
    DWORD     dwFlags;
    HINSTANCE hInstance;            // instance handle used for string extraction
    LONG      offsetQuery;          // offset to LDAP filter string
    LONG      iColumns;             // column count
    DWORD     dwReserved;           // reserved field for this query
    DSCOLUMN  aColumns[1];          // array of column descriptions
} DSQUERYPARAMS, * LPDSQUERYPARAMS;


//
// CF_DSQUERYSCOPE
// ---------------
//  A clipboard format the puts a string version of the scope into a
//  storage medium via GlobalAlloc.
//
#define CFSTR_DSQUERYSCOPE         TEXT("DsQueryScope")


//
// DSQPM_GETCLASSLIST
// ------------------
//  This page message is sent to the form pages to retrieve the list of classes
//  that the pages are going to query from.  This is used by the feild selector
//  and the property well to build its list of display classes.
//

typedef struct
{
    DWORD   cbStruct;
    LONG    cClasses;               // number of classes in array
    DWORD   offsetClass[1];         // offset to the class names (UNICODE)
} DSQUERYCLASSLIST, * LPDSQUERYCLASSLIST;


#define DSQPM_GETCLASSLIST          (CQPM_HANDLERSPECIFIC+0) // wParam == flags, lParam = LPLPDSQUERYCLASSLIST


//
// DSQPM_HELPTOPICS
// ----------------
//  This page message is sent to the form pages to allow them to handle the
//  "Help Topics" verb.
//

#define DSQPM_HELPTOPICS            (CQPM_HANDLERSPECIFIC+1) // wParam = 0, lParam = hWnd parent



#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DSRole.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dsrole.h

Abstract:

    This module contains the public interfaces to query the network roles of 
    workstations, servers, and DCs

--*/

#ifndef __DSROLE_H__
#define __DSROLE_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

//
// Domain information
//
typedef enum _DSROLE_MACHINE_ROLE {

    DsRole_RoleStandaloneWorkstation,
    DsRole_RoleMemberWorkstation,
    DsRole_RoleStandaloneServer,
    DsRole_RoleMemberServer,
    DsRole_RoleBackupDomainController,
    DsRole_RolePrimaryDomainController

} DSROLE_MACHINE_ROLE;

//
// Previous server state
//
typedef enum _DSROLE_SERVER_STATE {

    DsRoleServerUnknown = 0,
    DsRoleServerPrimary,
    DsRoleServerBackup

} DSROLE_SERVER_STATE, *PDSROLE_SERVER_STATE;

typedef enum _DSROLE_PRIMARY_DOMAIN_INFO_LEVEL {

    DsRolePrimaryDomainInfoBasic = 1,
    DsRoleUpgradeStatus,
    DsRoleOperationState

} DSROLE_PRIMARY_DOMAIN_INFO_LEVEL;

//
// Flags to be used with the PRIMARY_DOMAIN_INFO_LEVEL structures below
//
#define DSROLE_PRIMARY_DS_RUNNING           0x00000001
#define DSROLE_PRIMARY_DS_MIXED_MODE        0x00000002
#define DSROLE_UPGRADE_IN_PROGRESS          0x00000004
#define DSROLE_PRIMARY_DS_READONLY          0x00000008
#define DSROLE_PRIMARY_DOMAIN_GUID_PRESENT  0x01000000

//
// Structure that correspond to the DSROLE_PRIMARY_DOMAIN_INFO_LEVEL
//
typedef struct _DSROLE_PRIMARY_DOMAIN_INFO_BASIC {

    DSROLE_MACHINE_ROLE MachineRole;
    ULONG Flags;
    LPWSTR DomainNameFlat;
    LPWSTR DomainNameDns;
    LPWSTR DomainForestName;
    GUID DomainGuid;

} DSROLE_PRIMARY_DOMAIN_INFO_BASIC, *PDSROLE_PRIMARY_DOMAIN_INFO_BASIC;

typedef struct _DSROLE_UPGRADE_STATUS_INFO {

    ULONG OperationState;
    DSROLE_SERVER_STATE PreviousServerState;

} DSROLE_UPGRADE_STATUS_INFO, *PDSROLE_UPGRADE_STATUS_INFO;

typedef enum _DSROLE_OPERATION_STATE {

    DsRoleOperationIdle = 0,
    DsRoleOperationActive,
    DsRoleOperationNeedReboot

} DSROLE_OPERATION_STATE;

typedef struct _DSROLE_OPERATION_STATE_INFO {

    DSROLE_OPERATION_STATE OperationState;

} DSROLE_OPERATION_STATE_INFO, *PDSROLE_OPERATION_STATE_INFO;

DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer 
    );

VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    );


#ifdef __cplusplus
}
#endif

#endif // __DSROLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DsGetDC.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    dsgetdc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the DsGetDcName API.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _DSGETDC_
#define _DSGETDC_

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_DSGETDCAPI_)
#define DSGETDCAPI DECLSPEC_IMPORT
#else
#define DSGETDCAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure definitions
//

//
// Flags to passed to DsGetDcName
//

#define DS_FORCE_REDISCOVERY            0x00000001

#define DS_DIRECTORY_SERVICE_REQUIRED   0x00000010
#define DS_DIRECTORY_SERVICE_PREFERRED  0x00000020
#define DS_GC_SERVER_REQUIRED           0x00000040
#define DS_PDC_REQUIRED                 0x00000080
#define DS_BACKGROUND_ONLY              0x00000100
#define DS_IP_REQUIRED                  0x00000200
#define DS_KDC_REQUIRED                 0x00000400
#define DS_TIMESERV_REQUIRED            0x00000800
#define DS_WRITABLE_REQUIRED            0x00001000
#define DS_GOOD_TIMESERV_PREFERRED      0x00002000
#define DS_AVOID_SELF                   0x00004000
#define DS_ONLY_LDAP_NEEDED             0x00008000


#define DS_IS_FLAT_NAME                 0x00010000
#define DS_IS_DNS_NAME                  0x00020000

#define DS_TRY_NEXTCLOSEST_SITE         0x00040000

#define DS_DIRECTORY_SERVICE_6_REQUIRED 0x00080000

#define DS_RETURN_DNS_NAME              0x40000000
#define DS_RETURN_FLAT_NAME             0x80000000

#define DSGETDC_VALID_FLAGS ( \
            DS_FORCE_REDISCOVERY | \
            DS_DIRECTORY_SERVICE_REQUIRED | \
            DS_DIRECTORY_SERVICE_PREFERRED | \
            DS_GC_SERVER_REQUIRED | \
            DS_PDC_REQUIRED | \
            DS_BACKGROUND_ONLY | \
            DS_IP_REQUIRED | \
            DS_KDC_REQUIRED | \
            DS_TIMESERV_REQUIRED | \
            DS_WRITABLE_REQUIRED | \
            DS_GOOD_TIMESERV_PREFERRED | \
            DS_AVOID_SELF | \
            DS_ONLY_LDAP_NEEDED | \
            DS_IS_FLAT_NAME | \
            DS_IS_DNS_NAME | \
            DS_TRY_NEXTCLOSEST_SITE | \
            DS_DIRECTORY_SERVICE_6_REQUIRED | \
            DS_RETURN_FLAT_NAME  | \
            DS_RETURN_DNS_NAME )


//
// Structure returned from DsGetDcName
//

typedef struct _DOMAIN_CONTROLLER_INFOA {
    LPSTR DomainControllerName;
    LPSTR DomainControllerAddress;
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
    LPSTR DomainName;
    LPSTR DnsForestName;
    ULONG Flags;
    LPSTR DcSiteName;
    LPSTR ClientSiteName;
} DOMAIN_CONTROLLER_INFOA, *PDOMAIN_CONTROLLER_INFOA;

typedef struct _DOMAIN_CONTROLLER_INFOW {
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerName;
#else // MIDL_PASS
    LPWSTR DomainControllerName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerAddress;
#else // MIDL_PASS
    LPWSTR DomainControllerAddress;
#endif // MIDL_PASS
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainName;
#else // MIDL_PASS
    LPWSTR DomainName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DnsForestName;
#else // MIDL_PASS
    LPWSTR DnsForestName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DcSiteName;
#else // MIDL_PASS
    LPWSTR DcSiteName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *ClientSiteName;
#else // MIDL_PASS
    LPWSTR ClientSiteName;
#endif // MIDL_PASS
} DOMAIN_CONTROLLER_INFOW, *PDOMAIN_CONTROLLER_INFOW;

#ifdef UNICODE
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOW
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOW
#else
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOA
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOA
#endif // !UNICODE

//
// Values for DomainControllerAddressType
//

#define DS_INET_ADDRESS    1
#define DS_NETBIOS_ADDRESS 2

//
// Values for returned Flags
//

#define DS_PDC_FLAG            0x00000001    // DC is PDC of Domain
#define DS_GC_FLAG             0x00000004    // DC is a GC of forest
#define DS_LDAP_FLAG           0x00000008    // Server supports an LDAP server
#define DS_DS_FLAG             0x00000010    // DC supports a DS and is a Domain Controller
#define DS_KDC_FLAG            0x00000020    // DC is running KDC service
#define DS_TIMESERV_FLAG       0x00000040    // DC is running time service
#define DS_CLOSEST_FLAG        0x00000080    // DC is in closest site to client
#define DS_WRITABLE_FLAG       0x00000100    // DC has a writable DS
#define DS_GOOD_TIMESERV_FLAG  0x00000200    // DC is running time service (and has clock hardware)
#define DS_NDNC_FLAG           0x00000400    // DomainName is non-domain NC serviced by the LDAP server
#define DS_SELECT_SECRET_DOMAIN_6_FLAG  0x00000800  // DC has some secrets
#define DS_FULL_SECRET_DOMAIN_6_FLAG    0x00001000  // DC has all secrets
#define DS_PING_FLAGS          0x000FFFFF    // Flags returned on ping

#define DS_DNS_CONTROLLER_FLAG 0x20000000    // DomainControllerName is a DNS name
#define DS_DNS_DOMAIN_FLAG     0x40000000    // DomainName is a DNS name
#define DS_DNS_FOREST_FLAG     0x80000000    // DnsForestName is a DNS name


//
// Function Prototypes
//

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN __in_opt LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN __in_opt LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
);

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN __in_opt LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN __in_opt LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

#ifdef UNICODE
#define DsGetDcName DsGetDcNameW
#else
#define DsGetDcName DsGetDcNameA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    OUT __deref_out LPSTR *SiteName
);

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    OUT  __deref_out LPWSTR *SiteName
);

#ifdef UNICODE
#define DsGetSiteName DsGetSiteNameW
#else
#define DsGetSiteName DsGetSiteNameA
#endif // !UNICODE


DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameW(
    __in IN LPCWSTR SubnetName
);

DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameA(
    __in IN LPCSTR SubnetName
);

#ifdef UNICODE
#define DsValidateSubnetName DsValidateSubnetNameW
#else
#define DsValidateSubnetName DsValidateSubnetNameA
#endif // !UNICODE


//
// Only include if winsock2.h has been included
//
#ifdef _WINSOCK2API_
DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsAddressToSiteNames DsAddressToSiteNamesW
#else
#define DsAddressToSiteNames DsAddressToSiteNamesA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SiteNames,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SubnetNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPSTR **SiteNames,
    OUT __deref_out_ecount(EntryCount) LPSTR **SubnetNames
    );

#ifdef UNICODE
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExW
#else
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExA
#endif // !UNICODE
#endif // _WINSOCK2API_

//
// API to enumerate trusted domains
//

typedef struct _DS_DOMAIN_TRUSTSW {

    //
    // Name of the trusted domain.
    //
#ifdef MIDL_PASS
    [string] wchar_t * NetbiosDomainName;
    [string] wchar_t * DnsDomainName;
#else // MIDL_PASS
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
#endif // MIDL_PASS


    //
    // Flags defining attributes of the trust.
    //
    ULONG Flags;
#define DS_DOMAIN_IN_FOREST           0x0001  // Domain is a member of the forest
#define DS_DOMAIN_DIRECT_OUTBOUND     0x0002  // Domain is directly trusted
#define DS_DOMAIN_TREE_ROOT           0x0004  // Domain is root of a tree in the forest
#define DS_DOMAIN_PRIMARY             0x0008  // Domain is the primary domain of queried server
#define DS_DOMAIN_NATIVE_MODE         0x0010  // Primary domain is running in native mode
#define DS_DOMAIN_DIRECT_INBOUND      0x0020  // Domain is directly trusting
#define DS_DOMAIN_VALID_FLAGS (         \
            DS_DOMAIN_IN_FOREST       | \
            DS_DOMAIN_DIRECT_OUTBOUND | \
            DS_DOMAIN_TREE_ROOT       | \
            DS_DOMAIN_PRIMARY         | \
            DS_DOMAIN_NATIVE_MODE     | \
            DS_DOMAIN_DIRECT_INBOUND )

    //
    // Index to the domain that is the parent of this domain.
    //  Only defined if NETLOGON_DOMAIN_IN_FOREST is set and
    //      NETLOGON_DOMAIN_TREE_ROOT is not set.
    //
    ULONG ParentIndex;

    //
    // The trust type and attributes of this trust.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  these value are infered.
    //
    ULONG TrustType;
    ULONG TrustAttributes;

    //
    // The SID of the trusted domain.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  this value will be NULL.
    //
#if defined(MIDL_PASS)
    PISID DomainSid;
#else
    PSID DomainSid;
#endif

    //
    // The GUID of the trusted domain.
    //

    GUID DomainGuid;

} DS_DOMAIN_TRUSTSW, *PDS_DOMAIN_TRUSTSW;

//
// ANSI version of the above struct
//
typedef struct _DS_DOMAIN_TRUSTSA {
    LPSTR NetbiosDomainName;
    LPSTR DnsDomainName;
    ULONG Flags;
    ULONG ParentIndex;
    ULONG TrustType;
    ULONG TrustAttributes;
    PSID DomainSid;
    GUID DomainGuid;
} DS_DOMAIN_TRUSTSA, *PDS_DOMAIN_TRUSTSA;

#ifdef UNICODE
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSW
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSW
#else
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSA
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsW (
    __in_opt LPWSTR ServerName OPTIONAL,
    __in ULONG Flags,
    __deref_out_ecount(*DomainCount) PDS_DOMAIN_TRUSTSW *Domains,
    __out PULONG DomainCount
    );

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsA (
    __in_opt LPSTR ServerName OPTIONAL,
    __in ULONG Flags,
    __deref_out_ecount(*DomainCount) PDS_DOMAIN_TRUSTSA *Domains,
    __out PULONG DomainCount
    );

#ifdef UNICODE
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsW
#else
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsA
#endif // !UNICODE



//
// Only define this API if the caller has #included the pre-requisite 
// ntlsa.h or ntsecapi.h  
//

#if defined(_NTLSA_) || defined(_NTSECAPI_)

DSGETDCAPI
DWORD
WINAPI
DsGetForestTrustInformationW (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR TrustedDomainName OPTIONAL,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

#define DS_GFTI_UPDATE_TDO      0x1     // Update TDO with information returned
#define DS_GFTI_VALID_FLAGS     0x1     // All valid flags to DsGetForestTrustInformation

DSGETDCAPI
DWORD
WINAPI
DsMergeForestTrustInformationW(
    IN LPCWSTR DomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION OldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    );

#endif // _NTLSA_ || _NTSECAPI_

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN __in_opt LPCWSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT __deref_out_ecount(*EntryCount) LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageA(
    IN __in_opt LPCSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT __deref_out_ecount(*EntryCount) LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsGetDcSiteCoverage DsGetDcSiteCoverageW
#else
#define DsGetDcSiteCoverage DsGetDcSiteCoverageA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsW (
    __in_opt LPWSTR ServerName OPTIONAL,
    __in_opt LPWSTR DnsDomainName OPTIONAL,
    __in_opt GUID   *DomainGuid OPTIONAL,
    __in_opt GUID   *DsaGuid OPTIONAL,
    __in LPWSTR DnsHostName
    );

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsA (
    __in_opt LPSTR ServerName OPTIONAL,
    __in_opt LPSTR DnsDomainName OPTIONAL,
    __in_opt GUID  *DomainGuid OPTIONAL,
    __in_opt GUID  *DsaGuid OPTIONAL,
    __in LPSTR DnsHostName
    );

#ifdef UNICODE
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsW
#else
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsA
#endif // !UNICODE


#ifdef _WINSOCK2API_  // DsGetDcOpen/Next/Close depend on winsock2.h be included

//
// Option flags passed to DsGetDcOpen
//

#define DS_ONLY_DO_SITE_NAME         0x01   // Non-site specific names should be avoided.
#define DS_NOTIFY_AFTER_SITE_RECORDS 0x02   // Return ERROR_FILEMARK_DETECTED after all
                                            //  site specific records have been processed.

#define DS_OPEN_VALID_OPTION_FLAGS ( DS_ONLY_DO_SITE_NAME | DS_NOTIFY_AFTER_SITE_RECORDS )

//
// Valid DcFlags for DsGetDcOpen
//

#define DS_OPEN_VALID_FLAGS (       \
            DS_FORCE_REDISCOVERY  | \
            DS_ONLY_LDAP_NEEDED   | \
            DS_KDC_REQUIRED       | \
            DS_PDC_REQUIRED       | \
            DS_GC_SERVER_REQUIRED | \
            DS_WRITABLE_REQUIRED )

DSGETDCAPI
DWORD
WINAPI
DsGetDcOpenW(
    IN LPCWSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcOpenA(
    IN LPCSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    );

#ifdef UNICODE
#define DsGetDcOpen DsGetDcOpenW
#else
#define DsGetDcOpen DsGetDcOpenA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetDcNextW(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT __deref_opt_out LPWSTR *DnsHostName OPTIONAL
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcNextA(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT __deref_opt_out LPSTR *DnsHostName OPTIONAL
    );

#ifdef UNICODE
#define DsGetDcNext DsGetDcNextW
#else
#define DsGetDcNext DsGetDcNextA
#endif // !UNICODE

DSGETDCAPI
VOID
WINAPI
DsGetDcCloseW(
    IN HANDLE GetDcContextHandle
    );

#ifdef UNICODE
#define DsGetDcClose DsGetDcCloseW
#else
#define DsGetDcClose DsGetDcCloseW  // same for ANSI
#endif // !UNICODE

#endif // _WINSOCK2API_

#ifdef __cplusplus
}
#endif

#endif // _DSGETDC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dshowasf.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0416 */
/* Compiler settings for dshowasf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dshowasf_h__
#define __dshowasf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMWMBufferPass_FWD_DEFINED__
#define __IAMWMBufferPass_FWD_DEFINED__
typedef interface IAMWMBufferPass IAMWMBufferPass;
#endif 	/* __IAMWMBufferPass_FWD_DEFINED__ */


#ifndef __IAMWMBufferPassCallback_FWD_DEFINED__
#define __IAMWMBufferPassCallback_FWD_DEFINED__
typedef interface IAMWMBufferPassCallback IAMWMBufferPassCallback;
#endif 	/* __IAMWMBufferPassCallback_FWD_DEFINED__ */


#ifndef __IConfigAsfWriter_FWD_DEFINED__
#define __IConfigAsfWriter_FWD_DEFINED__
typedef interface IConfigAsfWriter IConfigAsfWriter;
#endif 	/* __IConfigAsfWriter_FWD_DEFINED__ */


#ifndef __IConfigAsfWriter2_FWD_DEFINED__
#define __IConfigAsfWriter2_FWD_DEFINED__
typedef interface IConfigAsfWriter2 IConfigAsfWriter2;
#endif 	/* __IConfigAsfWriter2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"
#include "wmsdkidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dshowasf_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================
EXTERN_GUID( IID_IConfigAsfWriter2,0x7989ccaa, 0x53f0, 0x44f0, 0x88, 0x4a, 0xf3, 0xb0, 0x3f, 0x6a, 0xe0, 0x66 );
EXTERN_GUID( IID_IConfigAsfWriter,0x45086030,0xF7E4,0x486a,0xB5,0x04,0x82,0x6B,0xB5,0x79,0x2A,0x3B );
EXTERN_GUID( IID_IAMWMBufferPass,0x6dd816d7, 0xe740, 0x4123, 0x9e, 0x24, 0x24, 0x44, 0x41, 0x26, 0x44, 0xd8 );
EXTERN_GUID( IID_IAMWMBufferPassCallback,0xb25b8372, 0xd2d2, 0x44b2, 0x86, 0x53, 0x1b, 0x8d, 0xae, 0x33, 0x24, 0x89 );
#ifndef EC_PREPROCESS_COMPLETE
#define EC_PREPROCESS_COMPLETE 0x56
#endif








extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_s_ifspec;

#ifndef __IAMWMBufferPass_INTERFACE_DEFINED__
#define __IAMWMBufferPass_INTERFACE_DEFINED__

/* interface IAMWMBufferPass */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMWMBufferPass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DD816D7-E740-4123-9E24-2444412644D8")
    IAMWMBufferPass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotify( 
            /* [in] */ IAMWMBufferPassCallback *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMWMBufferPassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMWMBufferPass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMWMBufferPass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMWMBufferPass * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotify )( 
            IAMWMBufferPass * This,
            /* [in] */ IAMWMBufferPassCallback *pCallback);
        
        END_INTERFACE
    } IAMWMBufferPassVtbl;

    interface IAMWMBufferPass
    {
        CONST_VTBL struct IAMWMBufferPassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMWMBufferPass_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMWMBufferPass_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMWMBufferPass_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMWMBufferPass_SetNotify(This,pCallback)	\
    ( (This)->lpVtbl -> SetNotify(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMWMBufferPass_SetNotify_Proxy( 
    IAMWMBufferPass * This,
    /* [in] */ IAMWMBufferPassCallback *pCallback);


void __RPC_STUB IAMWMBufferPass_SetNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMWMBufferPass_INTERFACE_DEFINED__ */


#ifndef __IAMWMBufferPassCallback_INTERFACE_DEFINED__
#define __IAMWMBufferPassCallback_INTERFACE_DEFINED__

/* interface IAMWMBufferPassCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMWMBufferPassCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B25B8372-D2D2-44b2-8653-1B8DAE332489")
    IAMWMBufferPassCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ INSSBuffer3 *pNSSBuffer3,
            /* [in] */ IPin *pPin,
            /* [in] */ REFERENCE_TIME *prtStart,
            /* [in] */ REFERENCE_TIME *prtEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMWMBufferPassCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMWMBufferPassCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMWMBufferPassCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMWMBufferPassCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IAMWMBufferPassCallback * This,
            /* [in] */ INSSBuffer3 *pNSSBuffer3,
            /* [in] */ IPin *pPin,
            /* [in] */ REFERENCE_TIME *prtStart,
            /* [in] */ REFERENCE_TIME *prtEnd);
        
        END_INTERFACE
    } IAMWMBufferPassCallbackVtbl;

    interface IAMWMBufferPassCallback
    {
        CONST_VTBL struct IAMWMBufferPassCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMWMBufferPassCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMWMBufferPassCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMWMBufferPassCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMWMBufferPassCallback_Notify(This,pNSSBuffer3,pPin,prtStart,prtEnd)	\
    ( (This)->lpVtbl -> Notify(This,pNSSBuffer3,pPin,prtStart,prtEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMWMBufferPassCallback_Notify_Proxy( 
    IAMWMBufferPassCallback * This,
    /* [in] */ INSSBuffer3 *pNSSBuffer3,
    /* [in] */ IPin *pPin,
    /* [in] */ REFERENCE_TIME *prtStart,
    /* [in] */ REFERENCE_TIME *prtEnd);


void __RPC_STUB IAMWMBufferPassCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMWMBufferPassCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dshowasf_0506 */
/* [local] */ 


enum _AM_ASFWRITERCONFIG_PARAM
    {	AM_CONFIGASFWRITER_PARAM_AUTOINDEX	= 1,
	AM_CONFIGASFWRITER_PARAM_MULTIPASS	= ( AM_CONFIGASFWRITER_PARAM_AUTOINDEX + 1 ) ,
	AM_CONFIGASFWRITER_PARAM_DONTCOMPRESS	= ( AM_CONFIGASFWRITER_PARAM_MULTIPASS + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0506_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0506_v0_0_s_ifspec;

#ifndef __IConfigAsfWriter_INTERFACE_DEFINED__
#define __IConfigAsfWriter_INTERFACE_DEFINED__

/* interface IConfigAsfWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAsfWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45086030-F7E4-486a-B504-826BB5792A3B")
    IConfigAsfWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileId( 
            /* [in] */ DWORD dwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileId( 
            /* [out] */ DWORD *pdwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileGuid( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileGuid( 
            /* [out] */ GUID *pProfileGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfile( 
            /* [in] */ IWMProfile *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfile( 
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexMode( 
            /* [in] */ BOOL bIndexFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexMode( 
            /* [out] */ BOOL *pbIndexFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAsfWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAsfWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAsfWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAsfWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileId )( 
            IConfigAsfWriter * This,
            /* [in] */ DWORD dwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileId )( 
            IConfigAsfWriter * This,
            /* [out] */ DWORD *pdwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileGuid )( 
            IConfigAsfWriter * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileGuid )( 
            IConfigAsfWriter * This,
            /* [out] */ GUID *pProfileGuid);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfile )( 
            IConfigAsfWriter * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfile )( 
            IConfigAsfWriter * This,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexMode )( 
            IConfigAsfWriter * This,
            /* [in] */ BOOL bIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexMode )( 
            IConfigAsfWriter * This,
            /* [out] */ BOOL *pbIndexFile);
        
        END_INTERFACE
    } IConfigAsfWriterVtbl;

    interface IConfigAsfWriter
    {
        CONST_VTBL struct IConfigAsfWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAsfWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigAsfWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigAsfWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigAsfWriter_ConfigureFilterUsingProfileId(This,dwProfileId)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileId(This,dwProfileId) ) 

#define IConfigAsfWriter_GetCurrentProfileId(This,pdwProfileId)	\
    ( (This)->lpVtbl -> GetCurrentProfileId(This,pdwProfileId) ) 

#define IConfigAsfWriter_ConfigureFilterUsingProfileGuid(This,guidProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileGuid(This,guidProfile) ) 

#define IConfigAsfWriter_GetCurrentProfileGuid(This,pProfileGuid)	\
    ( (This)->lpVtbl -> GetCurrentProfileGuid(This,pProfileGuid) ) 

#define IConfigAsfWriter_ConfigureFilterUsingProfile(This,pProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfile(This,pProfile) ) 

#define IConfigAsfWriter_GetCurrentProfile(This,ppProfile)	\
    ( (This)->lpVtbl -> GetCurrentProfile(This,ppProfile) ) 

#define IConfigAsfWriter_SetIndexMode(This,bIndexFile)	\
    ( (This)->lpVtbl -> SetIndexMode(This,bIndexFile) ) 

#define IConfigAsfWriter_GetIndexMode(This,pbIndexFile)	\
    ( (This)->lpVtbl -> GetIndexMode(This,pbIndexFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ DWORD dwProfileId);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ DWORD *pdwProfileId);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ GUID *pProfileGuid);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ IWMProfile *pProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_SetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ BOOL bIndexFile);


void __RPC_STUB IConfigAsfWriter_SetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ BOOL *pbIndexFile);


void __RPC_STUB IConfigAsfWriter_GetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAsfWriter_INTERFACE_DEFINED__ */


#ifndef __IConfigAsfWriter2_INTERFACE_DEFINED__
#define __IConfigAsfWriter2_INTERFACE_DEFINED__

/* interface IConfigAsfWriter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAsfWriter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7989CCAA-53F0-44f0-884A-F3B03F6AE066")
    IConfigAsfWriter2 : public IConfigAsfWriter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StreamNumFromPin( 
            /* [in] */ IPin *pPin,
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParam( 
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParam( 
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetMultiPassState( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAsfWriter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAsfWriter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAsfWriter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAsfWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileId )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileId )( 
            IConfigAsfWriter2 * This,
            /* [out] */ DWORD *pdwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileGuid )( 
            IConfigAsfWriter2 * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileGuid )( 
            IConfigAsfWriter2 * This,
            /* [out] */ GUID *pProfileGuid);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfile )( 
            IConfigAsfWriter2 * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfile )( 
            IConfigAsfWriter2 * This,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexMode )( 
            IConfigAsfWriter2 * This,
            /* [in] */ BOOL bIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexMode )( 
            IConfigAsfWriter2 * This,
            /* [out] */ BOOL *pbIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *StreamNumFromPin )( 
            IConfigAsfWriter2 * This,
            /* [in] */ IPin *pPin,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetParam )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE *GetParam )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2);
        
        HRESULT ( STDMETHODCALLTYPE *ResetMultiPassState )( 
            IConfigAsfWriter2 * This);
        
        END_INTERFACE
    } IConfigAsfWriter2Vtbl;

    interface IConfigAsfWriter2
    {
        CONST_VTBL struct IConfigAsfWriter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAsfWriter2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigAsfWriter2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigAsfWriter2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigAsfWriter2_ConfigureFilterUsingProfileId(This,dwProfileId)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileId(This,dwProfileId) ) 

#define IConfigAsfWriter2_GetCurrentProfileId(This,pdwProfileId)	\
    ( (This)->lpVtbl -> GetCurrentProfileId(This,pdwProfileId) ) 

#define IConfigAsfWriter2_ConfigureFilterUsingProfileGuid(This,guidProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileGuid(This,guidProfile) ) 

#define IConfigAsfWriter2_GetCurrentProfileGuid(This,pProfileGuid)	\
    ( (This)->lpVtbl -> GetCurrentProfileGuid(This,pProfileGuid) ) 

#define IConfigAsfWriter2_ConfigureFilterUsingProfile(This,pProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfile(This,pProfile) ) 

#define IConfigAsfWriter2_GetCurrentProfile(This,ppProfile)	\
    ( (This)->lpVtbl -> GetCurrentProfile(This,ppProfile) ) 

#define IConfigAsfWriter2_SetIndexMode(This,bIndexFile)	\
    ( (This)->lpVtbl -> SetIndexMode(This,bIndexFile) ) 

#define IConfigAsfWriter2_GetIndexMode(This,pbIndexFile)	\
    ( (This)->lpVtbl -> GetIndexMode(This,pbIndexFile) ) 


#define IConfigAsfWriter2_StreamNumFromPin(This,pPin,pwStreamNum)	\
    ( (This)->lpVtbl -> StreamNumFromPin(This,pPin,pwStreamNum) ) 

#define IConfigAsfWriter2_SetParam(This,dwParam,dwParam1,dwParam2)	\
    ( (This)->lpVtbl -> SetParam(This,dwParam,dwParam1,dwParam2) ) 

#define IConfigAsfWriter2_GetParam(This,dwParam,pdwParam1,pdwParam2)	\
    ( (This)->lpVtbl -> GetParam(This,dwParam,pdwParam1,pdwParam2) ) 

#define IConfigAsfWriter2_ResetMultiPassState(This)	\
    ( (This)->lpVtbl -> ResetMultiPassState(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_StreamNumFromPin_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ IPin *pPin,
    /* [out] */ WORD *pwStreamNum);


void __RPC_STUB IConfigAsfWriter2_StreamNumFromPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_SetParam_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IConfigAsfWriter2_SetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_GetParam_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD *pdwParam1,
    /* [out] */ DWORD *pdwParam2);


void __RPC_STUB IConfigAsfWriter2_GetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_ResetMultiPassState_Proxy( 
    IConfigAsfWriter2 * This);


void __RPC_STUB IConfigAsfWriter2_ResetMultiPassState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAsfWriter2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dshowasf_0508 */
/* [local] */ 

////////////////////////////////////////////////////////////////
//
// Windows Media Filters compatibility option flags
//
static DWORD EXCLUDE_SCRIPT_STREAM_DELIVERY_SYNCHRONIZATION = 0x00000001;

////////////////////////////////////////////////////////////////
//
// ATOM strings to match compatibility option flags above for certain applications that don't want to (or not allowed to) update registry entries
// These need to be setup by the application using the WM filters to enable the particular functionality
//
static const WCHAR* g_wszExcludeScriptStreamDeliverySynchronization = L"ExcludeScriptStreamDeliverySynchronization";



extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0508_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0508_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DskQuota.h ===
/**************************************************************************
*                                                                         *
*   dskquota.h --  public header for Windows 2000 disk quota interfaces.  *
*                                                                         *
*   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.         *
*                                                                         *
**************************************************************************/
#ifndef __DSKQUOTA_H
#define __DSKQUOTA_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINDOWS_
#include <windows.h>
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#endif

#ifndef _OLECTL_H_
#include <olectl.h>
#endif

#ifdef INITGUIDS
#include <initguid.h>
#endif


//
// Class IDs
//
// {7988B571-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(CLSID_DiskQuotaControl,
0x7988b571, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// Interface IDs
//
// {7988B572-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaControl,
0x7988b572, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B574-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUser,
0x7988b574, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B576-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUserBatch,
0x7988b576, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B577-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IEnumDiskQuotaUsers,
0x7988b577, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B579-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaEvents,
0x7988b579, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);


//
// Definitions for value and bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaState.
//
#define DISKQUOTA_STATE_DISABLED            0x00000000
#define DISKQUOTA_STATE_TRACK               0x00000001
#define DISKQUOTA_STATE_ENFORCE             0x00000002
#define DISKQUOTA_STATE_MASK                0x00000003
#define DISKQUOTA_FILESTATE_INCOMPLETE      0x00000100
#define DISKQUOTA_FILESTATE_REBUILDING      0x00000200
#define DISKQUOTA_FILESTATE_MASK            0x00000300

//
// Helper macros for setting and testing state value.
//
#define DISKQUOTA_SET_DISABLED(s) \
            ((s) &= ~DISKQUOTA_STATE_MASK)

#define DISKQUOTA_SET_TRACKED(s) \
            ((s) |= (DISKQUOTA_STATE_MASK & DISKQUOTA_STATE_TRACK))

#define DISKQUOTA_SET_ENFORCED(s) \
            ((s) |= (DISKQUOTA_STATE_ENFORCE & DISKQUOTA_STATE_ENFORCE))

#define DISKQUOTA_IS_DISABLED(s) \
            (DISKQUOTA_STATE_DISABLED == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_TRACKED(s) \
            (DISKQUOTA_STATE_TRACK == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_ENFORCED(s) \
            (DISKQUOTA_STATE_ENFORCE == ((s) & DISKQUOTA_STATE_MASK))
//
// These file state flags are read-only.
//
#define DISKQUOTA_FILE_INCOMPLETE(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_INCOMPLETE))

#define DISKQUOTA_FILE_REBUILDING(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_REBUILDING))


//
// Definitions for bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaLogFlags.
//
#define DISKQUOTA_LOGFLAG_USER_THRESHOLD    0x00000001
#define DISKQUOTA_LOGFLAG_USER_LIMIT        0x00000002

//
// Helper macros to interrogate a log flags DWORD.
//
#define DISKQUOTA_IS_LOGGED_USER_THRESHOLD(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_THRESHOLD))

#define DISKQUOTA_IS_LOGGED_USER_LIMIT(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_LIMIT))

//
// Helper macros to set/clear bits in a log flags DWORD.
//
#define DISKQUOTA_SET_LOG_USER_THRESHOLD(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_THRESHOLD) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_THRESHOLD : 0))

#define DISKQUOTA_SET_LOG_USER_LIMIT(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_LIMIT) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_LIMIT : 0))

//
// Per-user quota information.
//
typedef struct DiskQuotaUserInformation {
    LONGLONG QuotaUsed;
    LONGLONG QuotaThreshold;
    LONGLONG QuotaLimit;
} DISKQUOTA_USER_INFORMATION, *PDISKQUOTA_USER_INFORMATION;


//
// Values for fNameResolution argument to:
//
//      IDiskQuotaControl::AddUserSid
//      IDiskQuotaControl::AddUserName
//      IDiskQuotaControl::FindUserSid
//      IDiskQuotaControl::CreateEnumUsers
//
#define DISKQUOTA_USERNAME_RESOLVE_NONE     0
#define DISKQUOTA_USERNAME_RESOLVE_SYNC     1
#define DISKQUOTA_USERNAME_RESOLVE_ASYNC    2

//
// Values for status returned by IDiskQuotaUser::GetAccountStatus.
//
#define DISKQUOTA_USER_ACCOUNT_RESOLVED     0
#define DISKQUOTA_USER_ACCOUNT_UNAVAILABLE  1
#define DISKQUOTA_USER_ACCOUNT_DELETED      2
#define DISKQUOTA_USER_ACCOUNT_INVALID      3
#define DISKQUOTA_USER_ACCOUNT_UNKNOWN      4
#define DISKQUOTA_USER_ACCOUNT_UNRESOLVED   5


//
// IDiskQuotaUser represents a single user quota record on a particular
// NTFS volume.  Objects using this interface are instantiated 
// through several IDiskQuotaControl methods.
//
#undef  INTERFACE
#define INTERFACE IDiskQuotaUser
DECLARE_INTERFACE_IID_(IDiskQuotaUser, IUnknown, "7988B574-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(GetID)(THIS_
        ULONG *pulID) PURE;

    STDMETHOD(GetName)(THIS_
        LPWSTR pszAccountContainer,
        DWORD cchAccountContainer,
        LPWSTR pszLogonName,
        DWORD cchLogonName,
        LPWSTR pszDisplayName,
        DWORD cchDisplayName) PURE;

    STDMETHOD(GetSidLength)(THIS_
        LPDWORD pdwLength) PURE;

    STDMETHOD(GetSid)(THIS_
        LPBYTE pbSidBuffer,
        DWORD cbSidBuffer) PURE;

    STDMETHOD(GetQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaUsed)(THIS_
        PLONGLONG pllUsed) PURE;

    STDMETHOD(GetQuotaUsedText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaInformation)(THIS_
        LPVOID pbQuotaInfo,
        DWORD cbQuotaInfo) PURE;

    STDMETHOD(SetQuotaThreshold)(THIS_
        LONGLONG llThreshold,
        BOOL fWriteThrough) PURE;

    STDMETHOD(SetQuotaLimit)(THIS_
        LONGLONG llLimit,
        BOOL fWriteThrough) PURE;

    STDMETHOD(Invalidate)(THIS) PURE;

    STDMETHOD(GetAccountStatus)(THIS_
        LPDWORD pdwStatus) PURE;
};

typedef IDiskQuotaUser DISKQUOTA_USER, *PDISKQUOTA_USER;


//
// IEnumDiskQuotaUsers represents an enumerator created by 
// IDiskQuotaControl for the purpose of enumerating individual user quota
// records on a particular volume.  Each record is represented through
// the IDiskQuotaUser interface.
//
#undef  INTERFACE
#define INTERFACE IEnumDiskQuotaUsers
DECLARE_INTERFACE_IID_(IEnumDiskQuotaUsers, IUnknown, "7988B577-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Next)(THIS_
        DWORD cUsers,
        PDISKQUOTA_USER *rgUsers,
        LPDWORD pcUsersFetched) PURE;

    STDMETHOD(Skip)(THIS_
        DWORD cUsers) PURE;

    STDMETHOD(Reset)(THIS) PURE;

    STDMETHOD(Clone)(THIS_
        IEnumDiskQuotaUsers **ppEnum) PURE;
};

typedef IEnumDiskQuotaUsers ENUM_DISKQUOTA_USERS, *PENUM_DISKQUOTA_USERS;


//
// IDiskQuotaUserBatch represents a collection of IDiskQuotaUser 
// pointers for the purpose of grouping updates to quota information.
// 
#undef  INTERFACE
#define INTERFACE IDiskQuotaUserBatch
DECLARE_INTERFACE_IID_(IDiskQuotaUserBatch, IUnknown, "7988B576-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Add)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(Remove)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(RemoveAll)(THIS) PURE;

    STDMETHOD(FlushToDisk)(THIS) PURE;
};

typedef IDiskQuotaUserBatch DISKQUOTA_USER_BATCH, *PDISKQUOTA_USER_BATCH;


//
// IDiskQuotaControl represents a disk volume, providing query and 
// control of that volume's quota information.
//
#undef INTERFACE
#define INTERFACE IDiskQuotaControl
DECLARE_INTERFACE_IID_(IDiskQuotaControl, IConnectionPointContainer, "7988B572-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Initialize)(THIS_
        LPCWSTR pszPath,
        BOOL bReadWrite) PURE;

    STDMETHOD(SetQuotaState)(THIS_
        DWORD dwState) PURE;

    STDMETHOD(GetQuotaState)(THIS_
        LPDWORD pdwState) PURE;

    STDMETHOD(SetQuotaLogFlags)(THIS_
        DWORD dwFlags) PURE;

    STDMETHOD(GetQuotaLogFlags)(THIS_
        LPDWORD pdwFlags) PURE;

    STDMETHOD(SetDefaultQuotaThreshold)(THIS_
        LONGLONG llThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(SetDefaultQuotaLimit)(THIS_
        LONGLONG llLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(AddUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(AddUserName)(THIS_
        LPCWSTR pszLogonName,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(DeleteUser)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(FindUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(FindUserName)(THIS_
        LPCWSTR pszLogonName,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(CreateEnumUsers)(THIS_
        PSID *rgpUserSids,
        DWORD cpSids,
        DWORD fNameResolution,
        PENUM_DISKQUOTA_USERS *ppEnum) PURE;

    STDMETHOD(CreateUserBatch)(THIS_
        PDISKQUOTA_USER_BATCH *ppBatch) PURE;

    STDMETHOD(InvalidateSidNameCache)(THIS) PURE;

    STDMETHOD(GiveUserNameResolutionPriority)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(ShutdownNameResolution)(THIS_
        VOID) PURE;
};

typedef IDiskQuotaControl DISKQUOTA_CONTROL, *PDISKQUOTA_CONTROL;



#undef  INTERFACE
#define INTERFACE IDiskQuotaEvents
DECLARE_INTERFACE_IID_(IDiskQuotaEvents, IUnknown, "7988B579-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(OnUserNameChanged)(THIS_
        PDISKQUOTA_USER pUser) PURE;
};

typedef IDiskQuotaEvents DISKQUOTA_EVENTS, *PDISKQUOTA_EVENTS;



#endif // __DSKQUOTA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dssec.h ===
#ifndef _DSSEC_H_
#define _DSSEC_H_

#include <aclui.h>  // LPSECURITYINFO


//+---------------------------------------------------------------------------
//
//  Function:   PFNREADOBJECTSECURITY
//
//  Synopsis:   Reads the security descriptor of a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to read
//              [OUT PSECURITY_DESCRIPTOR*] --  Return SD here. Caller frees with LocalFree
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
//
//  Function:   PFNWRITEOBJECTSECURITY
//
//  Synopsis:   Writes a security descriptor to a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to write
//              [OUT PSECURITY_DESCRIPTOR]  --  Security descriptor to write
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFNREADOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR*, LPARAM);
typedef HRESULT (WINAPI *PFNWRITEOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, LPARAM);

#define DSSI_READ_ONLY          0x00000001
#define DSSI_NO_ACCESS_CHECK    0x00000002
#define DSSI_NO_EDIT_SACL       0x00000004
#define DSSI_NO_EDIT_OWNER      0x00000008
#define DSSI_IS_ROOT            0x00000010
#define DSSI_NO_FILTER          0x00000020
#define DSSI_NO_READONLY_MESSAGE          0x00000040


//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext);

typedef HRESULT (WINAPI *PFNDSCREATESECPAGE)(LPCWSTR,
                                             LPCWSTR,
                                             DWORD,
                                             HPROPSHEETPAGE*,
                                             PFNREADOBJECTSECURITY,
                                             PFNWRITEOBJECTSECURITY,
                                             LPARAM);


#endif  /* _DSSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dsattrib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dsattrib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dsattrib_h__
#define __dsattrib_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAttributeSet_FWD_DEFINED__
#define __IAttributeSet_FWD_DEFINED__
typedef interface IAttributeSet IAttributeSet;
#endif 	/* __IAttributeSet_FWD_DEFINED__ */


#ifndef __IAttributeGet_FWD_DEFINED__
#define __IAttributeGet_FWD_DEFINED__
typedef interface IAttributeGet IAttributeGet;
#endif 	/* __IAttributeGet_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dsattrib_0000_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0000_v0_0_s_ifspec;

#ifndef __IAttributeSet_INTERFACE_DEFINED__
#define __IAttributeSet_INTERFACE_DEFINED__

/* interface IAttributeSet */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAttributeSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("583ec3cc-4960-4857-982b-41a33ea0a006")
    IAttributeSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttrib( 
            /* [in] */ GUID guidAttribute,
            /* [in] */ __RPC__in BYTE *pbAttribute,
            /* [in] */ DWORD dwAttributeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttributeSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAttributeSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAttributeSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAttributeSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttrib )( 
            IAttributeSet * This,
            /* [in] */ GUID guidAttribute,
            /* [in] */ __RPC__in BYTE *pbAttribute,
            /* [in] */ DWORD dwAttributeLength);
        
        END_INTERFACE
    } IAttributeSetVtbl;

    interface IAttributeSet
    {
        CONST_VTBL struct IAttributeSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttributeSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttributeSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttributeSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttributeSet_SetAttrib(This,guidAttribute,pbAttribute,dwAttributeLength)	\
    ( (This)->lpVtbl -> SetAttrib(This,guidAttribute,pbAttribute,dwAttributeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttributeSet_INTERFACE_DEFINED__ */


#ifndef __IAttributeGet_INTERFACE_DEFINED__
#define __IAttributeGet_INTERFACE_DEFINED__

/* interface IAttributeGet */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAttributeGet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52dbd1ec-e48f-4528-9232-f442a68f0ae1")
    IAttributeGet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribIndexed( 
            /* [in] */ LONG lIndex,
            /* [out] */ __RPC__out GUID *pguidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttrib( 
            /* [in] */ GUID guidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttributeGetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAttributeGet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAttributeGet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAttributeGet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IAttributeGet * This,
            /* [out] */ __RPC__out LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribIndexed )( 
            IAttributeGet * This,
            /* [in] */ LONG lIndex,
            /* [out] */ __RPC__out GUID *pguidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttrib )( 
            IAttributeGet * This,
            /* [in] */ GUID guidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength);
        
        END_INTERFACE
    } IAttributeGetVtbl;

    interface IAttributeGet
    {
        CONST_VTBL struct IAttributeGetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttributeGet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttributeGet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttributeGet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttributeGet_GetCount(This,plCount)	\
    ( (This)->lpVtbl -> GetCount(This,plCount) ) 

#define IAttributeGet_GetAttribIndexed(This,lIndex,pguidAttribute,pbAttribute,pdwAttributeLength)	\
    ( (This)->lpVtbl -> GetAttribIndexed(This,lIndex,pguidAttribute,pbAttribute,pdwAttributeLength) ) 

#define IAttributeGet_GetAttrib(This,guidAttribute,pbAttribute,pdwAttributeLength)	\
    ( (This)->lpVtbl -> GetAttrib(This,guidAttribute,pbAttribute,pdwAttributeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttributeGet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dsattrib_0000_0002 */
/* [local] */ 

// ------------------------------------------------------
// GUID: DSATTRIB_UDCRTag
// ------------------------------------------------------
typedef struct _UDCR_TAG {
    BYTE        bVersion ;
    BYTE        KID [24 + 1] ;
    ULONGLONG   ullBaseCounter ;
    ULONGLONG   ullBaseCounterRange ;
    BOOL        fScrambled ;
    BYTE        bStreamMark ;
    DWORD       dwReserved1 ;
    DWORD       dwReserved2 ;
} UDCR_TAG ;
// ------------------------------------------------------
// GUID: DSATTRIB_PicSampleSeq
// ------------------------------------------------------
#define SAMPLE_SEQ_SEQUENCE_HEADER      1
#define SAMPLE_SEQ_GOP_HEADER           2
#define SAMPLE_SEQ_PICTURE_HEADER       3
#define SAMPLE_SEQ_CONTENT_UNKNOWN      0
#define SAMPLE_SEQ_CONTENT_I_FRAME      1
#define SAMPLE_SEQ_CONTENT_P_FRAME      2
#define SAMPLE_SEQ_CONTENT_B_FRAME      3
typedef struct _PIC_SEQ_SAMPLE {
    DWORD
      Content   : 3,    //  SAMPLE_CONTENT_*
      Start     : 1,    //  '1' if the sample is a PictureSampleSequence start
      FrameRate : 4,    //  see below (h.262, table 6-4)
      Reserved  : 20,   //  reserved; shall have value 0
      Version   : 4 ;   //  0
} PIC_SEQ_SAMPLE, *PPIC_SEQ_SAMPLE ;
//      Frame Rate
//          (see h.262, table 6-4)
//
//          0000    reserved (ignore field value)
//          0001    23.976
//          0010    24
//          0011    25
//          0100    29.97
//          0101    30
//          0110    50
//          0111    59.94
//          1000    60
typedef struct _SAMPLE_SEQ_OFFSET {
    DWORD
      Type      : 4,       //  SAMPLE_SEQ_*; 0 means not used
      Offset    : 20,      //  downstream byte offset; 0xfffff means > 2^20-1
      Reserved  : 8 ;      //  reserved; o
} SAMPLE_SEQ_OFFSET ;
#define OFFSET_MARKER_COUNT(attr_len)   \
    ((attr_len - sizeof (PIC_SEQ_SAMPLE)) / sizeof (SAMPLE_SEQ_OFFSET))
#define PIC_SEQ_SAMPLE_ATTR_LEN(cOffsets)   (sizeof (PIC_SEQ_SAMPLE) + (cOffsets) * sizeof (SAMPLE_SEQ_OFFSET))


extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dv.h ===
//------------------------------------------------------------------------------
// File: DV.h
//
// Desc: DV typedefs and defines.
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _DV_H_
#define _DV_H_

#define DV_DVSD_NTSC_FRAMESIZE	120000L
#define DV_DVSD_PAL_FRAMESIZE	144000L

#define DV_SMCHN	0x0000e000
#define DV_AUDIOMODE    0x00000f00
#define DV_AUDIOSMP	0x38000000

#define DV_AUDIOQU	0x07000000
#define DV_NTSCPAL	0x00200000
#define DV_STYPE	0x001f0000


//There are NTSC or PAL DV camcorders  
#define DV_NTSC		    0
#define DV_PAL		    1
//DV camcorder can output sd/hd/sl  
#define DV_SD		    0x00
#define DV_HD		    0x01
#define DV_SL		    0x02
//user can choice 12 bits or 16 bits audio from DV camcorder
#define DV_CAP_AUD16Bits    0x00
#define DV_CAP_AUD12Bits    0x01

#define SIZE_DVINFO	    0x20    

typedef struct Tag_DVAudInfo
{
	BYTE    bAudStyle[2];           
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//                 0x05: mon, audio in 2nd 5 DIF sequence
	//                 0x15: stereo, audio only in 2nd 5 DIF sequence
	//                 0x10: stereo, audio only in 1st 5/6 DIF sequence
	//                 0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//                 0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE    bAudQu[2];                      //qbits, only support 12, 16,           
		
	BYTE    bNumAudPin;                     //how many pin(language)
	WORD    wAvgSamplesPerPinPerFrm[2];     //samples size for one audio pin in one frame(which has 10 or 12 DIF sequence) 
	WORD    wBlkMode;                       //45 for NTSC, 54 for PAL
	WORD    wDIFMode;                       //5  for NTSC, 6 for PAL
	WORD    wBlkDiv;                        //15  for NTSC, 18 for PAL
} DVAudInfo;
	  
#endif // _DV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DSClient.h ===
#pragma once

//---------------------------------------------------------------------------//
// CLSIDs exposed for the dsclient.
//---------------------------------------------------------------------------//

// this CLSID is used to signal that the DSOBJECTNAMEs structure originated
// for the Microsoft DS.

DEFINE_GUID(CLSID_MicrosoftDS, 0xfe1290f0, 0xcfbd, 0x11cf, 0xa3, 0x30, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
#define CLSID_DsFolder CLSID_MicrosoftDS


// this is the CLSID used by clients to get the IShellExtInit, IPropSheetExt
// and IContextMenus exposed from dsuiext.dll.

DEFINE_GUID(CLSID_DsPropertyPages, 0xd45d530,  0x764b, 0x11d0, 0xa1, 0xca, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);

DEFINE_GUID(CLSID_DsDomainTreeBrowser, 0x1698790a, 0xe2b4, 0x11d0, 0xb0, 0xb1, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6);
DEFINE_GUID(IID_IDsBrowseDomainTree, 0x7cabcf1e, 0x78f5, 0x11d2, 0x96, 0xc, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

DEFINE_GUID(CLSID_DsDisplaySpecifier, 0x1ab4a8c0, 0x6a0b, 0x11d2, 0xad, 0x49, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#define IID_IDsDisplaySpecifier CLSID_DsDisplaySpecifier

DEFINE_GUID(CLSID_DsFolderProperties, 0x9e51e0d0, 0x6e0f, 0x11d2, 0x96, 0x1, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#define IID_IDsFolderProperties CLSID_DsFolderProperties

#ifndef GUID_DEFS_ONLY

#include "activeds.h"

//---------------------------------------------------------------------------//
// Clipboard formats used within DSUI
//---------------------------------------------------------------------------//

//
// CF_DSOBJECTS
// ------------
//  This clipboard format defines the seleciton for an DS IShellFolder to the
//  shell extensions.   All strings are stored as BSTR's, and an offset == 0 
//  is used to indicate that the string is not present.
// 

#define DSOBJECT_ISCONTAINER            0x00000001  // = 1 => object is a container
#define DSOBJECT_READONLYPAGES          0x80000000  // = 1 => read only pages

#define DSPROVIDER_UNUSED_0             0x00000001
#define DSPROVIDER_UNUSED_1             0x00000002
#define DSPROVIDER_UNUSED_2             0x00000004
#define DSPROVIDER_UNUSED_3             0x00000008
#define DSPROVIDER_ADVANCED             0x00000010  // = 1 => advanced mode 
#define DSPROVIDER_AD_LDS               0x00000020  // = 1 => talking to an AD LDS instance 

#define CFSTR_DSOBJECTNAMES TEXT("DsObjectNames")

typedef struct
{
    DWORD   dwFlags;                    // item flags
    DWORD   dwProviderFlags;            // flags for item provider
    DWORD   offsetName;                 // offset to ADS path of the object
    DWORD   offsetClass;                // offset to object class name / == 0 not known
} DSOBJECT, * LPDSOBJECT;

typedef struct
{
    CLSID    clsidNamespace;            // namespace identifier (indicates which namespace selection from)
    UINT     cItems;                    // number of objects
    DSOBJECT aObjects[1];               // array of objects
} DSOBJECTNAMES, * LPDSOBJECTNAMES;


//
// CF_DSDISPLAYSPECOPTIONS
// -----------------------
//  When invoking an object referenced by a display specifier (context menu, property
//  page, etc) we call the IShellExtInit interface passing a IDataObject.  This data
//  object supports the CF_DSDISPLAYSPECOPTIONS format to give out configuration
//  informaiton about admin/shell invocation.
//
//  When interacting with dsuiext.dll the interfaces uses this clipboard format
//  to determine which display specifier attributes to address (admin/shell)
//  and pick up the values accordingly.  If no format is suppoted then
//  dsuiext.dll defaults to shell.
// 

#define CFSTR_DS_DISPLAY_SPEC_OPTIONS TEXT("DsDisplaySpecOptions")
#define CFSTR_DSDISPLAYSPECOPTIONS CFSTR_DS_DISPLAY_SPEC_OPTIONS

typedef struct _DSDISPLAYSPECOPTIONS
{
    DWORD   dwSize;                             // size of struct, for versioning
    DWORD   dwFlags;                            // invocation flags
    DWORD   offsetAttribPrefix;                 // offset to attribute prefix string.

    DWORD   offsetUserName;                     // offset to UNICODE user name
    DWORD   offsetPassword;                     // offset to UNICODE password
    DWORD   offsetServer;
    DWORD   offsetServerConfigPath;

} DSDISPLAYSPECOPTIONS, * PDSDISPLAYSPECOPTIONS, * LPDSDISPLAYSPECOPTIONS;

#define DS_PROP_SHELL_PREFIX L"shell"
#define DS_PROP_ADMIN_PREFIX L"admin"

#define DSDSOF_HASUSERANDSERVERINFO     0x00000001      // = 1 => user name/password are valid
#define DSDSOF_SIMPLEAUTHENTICATE       0x00000002      // = 1 => don't use secure authentication to DS
#define DSDSOF_DONTSIGNSEAL             0x00000004      // = 1 => don't sign+seal when opening DS objects
#define DSDSOF_DSAVAILABLE              0x40000000      // = 1 => ignore DS available checks

//
// CF_DSPROPERTYPAGEINFO
// ---------------------
//  When the property pages for an object are being displayed the parsed
//  display specifier string is passed to the page object via the IDataObject
//  in the following clipboard format.
//
//  Within the display specifier for a property page, the format for a
//  Win32 extension is "n,{clsid}[,bla...]" we take the "bla" section and
//  pass it down.
// 

#define CFSTR_DSPROPERTYPAGEINFO TEXT("DsPropPageInfo")

typedef struct
{
    DWORD offsetString;                 // offset to UNICODE string
} DSPROPERTYPAGEINFO, * LPDSPROPERTYPAGEINFO;


// 
// To sync property pages and the admin tools this message is broadcast
//

#define DSPROP_ATTRCHANGED_MSG  TEXT("DsPropAttrChanged")

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsBrowseDomainTree
// ===================
//  This interface returns a list of the domains from a given computer name
//  (or the current computer name if none is specified).
//
//  NOTES:
//    1) The structure returned by ::GetDomains should be free'd using
//       FreeDomains.
//
//    2) ::BrowseTo allocates a string on exit, this is allocated using
//       CoTaskMemAlloc, and therefore should be free'd using CoTaskMemFree.
//
//---------------------------------------------------------------------------//

#define DBDTF_RETURNFQDN          0x00000001  // if not set, pszNCName will be blank
#define DBDTF_RETURNMIXEDDOMAINS  0x00000002  // set it if you want downlevel trust domains too
#define DBDTF_RETURNEXTERNAL      0x00000004  // set it if you want external trust domains too
#define DBDTF_RETURNINBOUND       0x00000008  // set it if you want trusting domains
#define DBDTF_RETURNINOUTBOUND    0x00000010  // set it if you want both trusted and trusting domains

typedef struct _DOMAINDESC
{       
  LPWSTR pszName;                       // domain name (if no dns, use netbios)
  LPWSTR pszPath;                       // set to blank
  LPWSTR pszNCName;                     // FQDN, e.g.,DC=mydomain,DC=microsoft,DC=com
  LPWSTR pszTrustParent;                // parent domain name (if no dns, use netbios)
  LPWSTR pszObjectClass;                // Object class of the domain object referenced
  ULONG  ulFlags;                       // Flags, from DS_TRUSTED_DOMAINS.Flags
  BOOL   fDownLevel;                    // == 1 if downlevel domain
  struct _DOMAINDESC *pdChildList;      // Children of this node
  struct _DOMAINDESC *pdNextSibling;    // Siblings of this node            
} DOMAIN_DESC, DOMAINDESC, * PDOMAIN_DESC, * LPDOMAINDESC;

typedef struct
{
  DWORD dsSize;
  DWORD dwCount;
  DOMAINDESC aDomains[1];
} DOMAIN_TREE, DOMAINTREE, * PDOMAIN_TREE, * LPDOMAINTREE;

#undef  INTERFACE
#define INTERFACE  IDsBrowseDomainTree

DECLARE_INTERFACE_IID_(IDsBrowseDomainTree, IUnknown, "7cabcf1e-78f5-11d2-960c-00c04fa31a86")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsBrowseDomainTree methods ***
    STDMETHOD(BrowseTo)(THIS_ HWND hwndParent, LPWSTR *ppszTargetPath, DWORD dwFlags) PURE;
    STDMETHOD(GetDomains)(THIS_ PDOMAIN_TREE *ppDomainTree, DWORD dwFlags) PURE;
    STDMETHOD(FreeDomains)(THIS_ PDOMAIN_TREE *ppDomainTree) PURE;
    STDMETHOD(FlushCachedDomains)(THIS) PURE;
    STDMETHOD(SetComputer)(THIS_ LPCWSTR pszComputerName, LPCWSTR pszUserName, LPCWSTR pszPassword) PURE;
};

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsDisplaySpecifier
// ===================
//  This interface gives client UI access to the display specifiers for 
//  specific attributes.
//
//---------------------------------------------------------------------------//

//
// IDsDisplaySpecifier::SetServer flags
//
#define DSSSF_SIMPLEAUTHENTICATE        0x00000001  // = 1 => don't use secure authentication to DS
#define DSSSF_DONTSIGNSEAL              0x00000002  // = 1 => don't use sign+seal when opening objects in the DS
#define DSSSF_DSAVAILABLE               0x80000000  // = 1 => ignore DS available checks

//
// Flags for IDsDisplaySpecifier::GetIcon / GetIconLocation
//
#define DSGIF_ISNORMAL                  0x0000000   // = icon is in normal state (default)
#define DSGIF_ISOPEN                    0x0000001   // = icon is in open state
#define DSGIF_ISDISABLED                0x0000002   // = icon is in a disabled state
#define DSGIF_ISMASK                    0x000000f
#define DSGIF_GETDEFAULTICON            0x0000010   // = 1 => if no icon then get default (from shell32.dll)
#define DSGIF_DEFAULTISCONTAINER        0x0000020   // = 1 => if returning default icon, return it as a container

//
// Flags for IDsDisplaySpecifier::IsClassContainer
//
#define DSICCF_IGNORETREATASLEAF        0x00000001  // = 1 => igore the "treatAsLeaf" and use only schema information

//
// Callback function used for IDsDisplaySpecifier::EnumClassAttributes
//

#define DSECAF_NOTLISTED               0x00000001  // = 1 => hide from the field drop down in the query UI

typedef HRESULT (CALLBACK *LPDSENUMATTRIBUTES)(LPARAM lParam, LPCWSTR pszAttributeName, LPCWSTR pszDisplayName, DWORD dwFlags);

//
// IDsDisplaySpecifier::GetClassCreationInfo information
//

#define DSCCIF_HASWIZARDDIALOG          0x00000001  // = 1 => return the wizard dialog CLSID
#define DSCCIF_HASWIZARDPRIMARYPAGE     0x00000002  // = 1 => returning a primary wizard dlg CLSID

typedef struct
{
    DWORD dwFlags;
    CLSID clsidWizardDialog;
    CLSID clsidWizardPrimaryPage;
    DWORD cWizardExtensions;            // how many extension CLSIDs?
    CLSID aWizardExtensions[1];
} DSCLASSCREATIONINFO, * LPDSCLASSCREATIONINFO;

//
// IDsDisplaySpecifier - a COM object for interacting with display specifiers
//

#undef  INTERFACE
#define INTERFACE IDsDisplaySpecifier

DECLARE_INTERFACE_IID_(IDsDisplaySpecifier, IUnknown, "1ab4a8c0-6a0b-11d2-ad49-00c04fa31a86")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsDisplaySpecifier methods ***
    STDMETHOD(SetServer)(THIS_ LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword, DWORD dwFlags) PURE;
    STDMETHOD(SetLanguageID)(THIS_ LANGID langid) PURE;
    STDMETHOD(GetDisplaySpecifier)(THIS_ LPCWSTR pszObjectClass, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetIconLocation)(THIS_ LPCWSTR pszObjectClass, DWORD dwFlags, LPWSTR pszBuffer, INT cchBuffer, INT *presid) PURE;
    STDMETHOD_(HICON, GetIcon)(THIS_ LPCWSTR pszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon) PURE;
    STDMETHOD(GetFriendlyClassName)(THIS_ LPCWSTR pszObjectClass, LPWSTR pszBuffer, INT cchBuffer) PURE;
    STDMETHOD(GetFriendlyAttributeName)(THIS_ LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, __out_ecount(cchBuffer) LPWSTR pszBuffer, UINT cchBuffer) PURE;
    STDMETHOD_(BOOL, IsClassContainer)(THIS_ LPCWSTR pszObjectClass, LPCWSTR pszADsPath, DWORD dwFlags) PURE;
    STDMETHOD(GetClassCreationInfo)(THIS_ LPCWSTR pszObjectClass, LPDSCLASSCREATIONINFO* ppdscci) PURE;
    STDMETHOD(EnumClassAttributes)(THIS_ LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam) PURE;
    STDMETHOD_(ADSTYPE, GetAttributeADsType)(THIS_ LPCWSTR pszAttributeName) PURE;
};


//---------------------------------------------------------------------------//
//
// DsBrowseForContainer
// --------------------
//  Provides a container browser similar to the SHBrowseForFolder, except
//  targetting the DS.
//
// In:
//  pInfo -> DSBROWSEINFO structure
//
// Out:
//  == IDOK/IDCANCEL depending on buttons, -1 if error
//
//---------------------------------------------------------------------------//

typedef struct
{
    DWORD           cbStruct;       // size of structure in bytes
    HWND            hwndOwner;      // dialog owner
    LPCWSTR         pszCaption;     // dialog caption text (can be NULL)
    LPCWSTR         pszTitle;       // displayed above the tree view control (can be NULL)
    LPCWSTR         pszRoot;        // ADS path to root (NULL == root of DS namespace)
    LPWSTR          pszPath;        // [in/out] initial selection & returned path (required)
    ULONG           cchPath;        // size of pszPath buffer in characters
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;    // callback function (see SHBrowseForFolder)
    LPARAM          lParam;         // passed to pfnCallback as lpUserData
    DWORD           dwReturnFormat; // ADS_FORMAT_* (default is ADS_FORMAT_X500_NO_SERVER)
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // UNICODE string for the object class
    ULONG           cchObjectClass;
} DSBROWSEINFOW, *PDSBROWSEINFOW;

typedef struct
{
    DWORD           cbStruct;
    HWND            hwndOwner;
    LPCSTR          pszCaption;
    LPCSTR          pszTitle;
    LPCWSTR         pszRoot;        // ADS paths are always UNICODE
    LPWSTR          pszPath;        // ditto
    ULONG           cchPath;
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;
    LPARAM          lParam;
    DWORD           dwReturnFormat;
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // object class of the selected object
    ULONG           cchObjectClass;
} DSBROWSEINFOA, *PDSBROWSEINFOA;

#ifdef UNICODE
#define DSBROWSEINFO   DSBROWSEINFOW
#define PDSBROWSEINFO  PDSBROWSEINFOW
#else
#define DSBROWSEINFO   DSBROWSEINFOA
#define PDSBROWSEINFO  PDSBROWSEINFOA
#endif

// DSBROWSEINFO flags
#define DSBI_NOBUTTONS          0x00000001  // NOT TVS_HASBUTTONS
#define DSBI_NOLINES            0x00000002  // NOT TVS_HASLINES
#define DSBI_NOLINESATROOT      0x00000004  // NOT TVS_LINESATROOT
#define DSBI_CHECKBOXES         0x00000100  // TVS_CHECKBOXES
#define DSBI_NOROOT             0x00010000  // don't include pszRoot in tree (its children become top level nodes)
#define DSBI_INCLUDEHIDDEN      0x00020000  // display hidden objects
#define DSBI_EXPANDONOPEN       0x00040000  // expand to the path specified in pszPath when opening the dialog
#define DSBI_ENTIREDIRECTORY    0x00090000  // browse the entire directory (defaults to having DSBI_NOROOT set)
#define DSBI_RETURN_FORMAT      0x00100000  // dwReturnFormat field is valid
#define DSBI_HASCREDENTIALS     0x00200000  // pUserName & pPassword are valid
#define DSBI_IGNORETREATASLEAF  0x00400000  // ignore the treat as leaf flag when calling IsClassContainer
#define DSBI_SIMPLEAUTHENTICATE 0x00800000  // don't use secure authentication to DS
#define DSBI_RETURNOBJECTCLASS  0x01000000  // return object class of selected object
#define DSBI_DONTSIGNSEAL       0x02000000  // don't sign+seal communication with DS

#define DSB_MAX_DISPLAYNAME_CHARS   64

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    WCHAR           szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    WCHAR           szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMW, *PDSBITEMW;

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    CHAR            szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    CHAR            szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMA, *PDSBITEMA;

#ifdef UNICODE
#define DSBITEM     DSBITEMW
#define PDSBITEM    PDSBITEMW
#else
#define DSBITEM     DSBITEMA
#define PDSBITEM    PDSBITEMA
#endif

// DSBITEM mask flags
#define DSBF_STATE              0x00000001
#define DSBF_ICONLOCATION       0x00000002
#define DSBF_DISPLAYNAME        0x00000004

// DSBITEM state flags
#define DSBS_CHECKED            0x00000001
#define DSBS_HIDDEN             0x00000002
#define DSBS_ROOT               0x00000004

//
// this message is sent to the callback to see if it wants to insert or modify 
// the item that is about to be inserted into the view.
//

#define DSBM_QUERYINSERTW       100 // lParam = PDSBITEMW (state, icon & name may be modified). Return TRUE if handled.
#define DSBM_QUERYINSERTA       101 // lParam = PDSBITEMA (state, icon & name may be modified). Return TRUE if handled.

#ifdef UNICODE
#define DSBM_QUERYINSERT DSBM_QUERYINSERTW
#else
#define DSBM_QUERYINSERT DSBM_QUERYINSERTA
#endif

//
// Called before we change the state of the icon (on tree collapse/expand)
//

#define DSBM_CHANGEIMAGESTATE   102 // lParam = adspath.  Return TRUE/FALSE top allow/disallow

//
// The dialog receives a WM_HELP
//

#define DSBM_HELP               103 // lParam == LPHELPINFO structure

//
// The dialog receives a WM_CONTEXTMENU, DSBID_xxx are the control ID's for this
// dialog so that you can display suitable help.
//

#define DSBM_CONTEXTMENU        104 // lParam == window handle to retrieve help for


//
// These are the control IDs for the controls in the dialog.   The callback can use
// these to modify the contents of the dialog as required.
//

#define DSBID_BANNER            256
#define DSBID_CONTAINERLIST     257

//
// API exported for browsing for containers.
//

STDAPI_(int) DsBrowseForContainerW(__inout PDSBROWSEINFOW pInfo);
STDAPI_(int) DsBrowseForContainerA(__inout PDSBROWSEINFOA pInfo);

#ifdef UNICODE
#define DsBrowseForContainer    DsBrowseForContainerW
#else
#define DsBrowseForContainer    DsBrowseForContainerA
#endif


// NOTE: these are here to keep old clients building - remove soon

STDAPI_(HICON) DsGetIcon(DWORD dwFlags, LPCWSTR pszObjectClass, INT cxImage, INT cyImage);
STDAPI DsGetFriendlyClassName(LPCWSTR pszObjectClass, __out_ecount(cchBuffer) LPWSTR pszBuffer, UINT cchBuffer);


#ifdef  __cplusplus
struct __declspec(uuid("1ab4a8c0-6a0b-11d2-ad49-00c04fa31a86")) IDsDisplaySpecifier;
#endif

#endif  // GUID_DEFS_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DvObj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dvobj.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should include ole2.h instead of dvobj.h")
#endif /* !RC_INVOKED */

#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */
#define DIRECTSOUND_VERSION 0x0700  /* Version 7.0 */
#elif (NTDDI_VERSION < NTDDI_WINXPSP2 || NTDDI_VERSION == NTDDI_WS03) /* Windows XP and SP1, or Windows Server 2003 */
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#else /* Windows XP SP2 and higher, Windows Server 2003 SP1 and higher, Longhorn, or higher */
#define DIRECTSOUND_VERSION 0x0900  /* Version 9.0 */
#endif

#endif // DIRECTSOUND_VERSION

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);


// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800

typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800

#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)

#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)

#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f

#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f

#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)

#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)

#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f

#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f

#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f

#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f

#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006  // obsolete 5.1 setting
#define DSSPEAKER_7POINT1           0x00000007  // obsolete 7.1 setting
#define DSSPEAKER_7POINT1_SURROUND  0x00000008  // correct 7.1 Home Theater setting
#define DSSPEAKER_5POINT1_SURROUND  0x00000009  // correct 5.1 setting
#define DSSPEAKER_7POINT1_WIDE      DSSPEAKER_7POINT1
#define DSSPEAKER_5POINT1_BACK      DSSPEAKER_5POINT1

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
#define DSBCAPS_TRUEPLAYPOSITION    0x00080000

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSBFREQUENCY_ORIGINAL       0
#define DSBFREQUENCY_MIN            100
#if DIRECTSOUND_VERSION >= 0x0900
#define DSBFREQUENCY_MAX            200000
#else
#define DSBFREQUENCY_MAX            100000
#endif

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DSBNOTIFICATIONS_MAX        100000UL

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
#define DSCCAPS_MULTIPLECAPTURE     0x00000001

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000
#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//
// Flags for the I3DL2 effects
//

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f

enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//


// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//


// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__



#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\DtcHelp.h ===
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

@doc

@module		DTCHelp.h	|

			contains helper API for loading the DTCHelper DLL

-------------------------------------------------------------------------------
@rev 	0 	| 8th -Sep-1995	|	GaganC		| Created
----------------------------------------------------------------------------- */
#ifndef __DTCHELP_H__
#define __DTCHELP_H__


//---------------------------------------------------------
//		ALL INCLUDE FILES GO HERE
//---------------------------------------------------------
#include <windows.h>


//---------------------------------------------------------
// constants / enums / typedefs / defines
//---------------------------------------------------------
#ifndef DEFINED_DTC_STATUS
typedef enum DTC_STATUS_
{
	DTC_STATUS_UNKNOWN = 0,			// Status not known
	DTC_STATUS_STARTING = 1,		// DTC is starting
	DTC_STATUS_STARTED = 2,			// DTC has started
	DTC_STATUS_PAUSING = 3,			// DTC is being paused
	DTC_STATUS_PAUSED = 4,			// DTC has been paused
	DTC_STATUS_CONTINUING = 5,		// DTC is being continued
	DTC_STATUS_STOPPING = 6,		// DTC is stopping
	DTC_STATUS_STOPPED = 7,			// DTC has stopped
	DTC_STATUS_E_CANTCONTROL = 8,	// DTC cannot be controlled in its present state
	DTC_STATUS_FAILED = 9			// DTC has failed.
} DTC_STATUS;
#define DEFINED_DTC_STATUS
#endif

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER)(
									/* in */ char * pszHost,
									/* in */ char * pszTmName,
									/* in */ REFIID rid,
									/* in */ DWORD	dwReserved1,
									/* in */ WORD	wcbReserved2,
									/* in */ void FAR * pvReserved2,
									/*out */ void** ppvObject )	;

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER_EX_A)(
									/* in */ char * i_pszHost,
									/* in */ char * i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER_EX_W)(
									/* in */ WCHAR * i_pwszHost,
									/* in */ WCHAR * i_pwszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);

typedef HRESULT	( * DTC_INSTALL_CLIENT ) ( 
									   LPTSTR i_pszRemoteTmHostName, 
									   DWORD i_dwProtocol,
									   DWORD i_dwOverwrite );

#ifndef UNICODE 

#define DTC_GET_TRANSACTION_MANAGER_EX		DTC_GET_TRANSACTION_MANAGER_EX_A
#define LoadDtcHelperEx						LoadDtcHelperExA
#define	GetDTCStatus						GetDTCStatusA
#define	StartDTC							StartDTCA
#define	StopDTC								StopDTCA

#else

#define DTC_GET_TRANSACTION_MANAGER_EX		DTC_GET_TRANSACTION_MANAGER_EX_W
#define LoadDtcHelperEx						LoadDtcHelperExW
#define	GetDTCStatus						GetDTCStatusW
#define	StartDTC							StartDTCW
#define	StopDTC								StopDTCW

#endif 



#define	DTCINSTALL_E_CLIENT_ALREADY_INSTALLED					0x0000180L

#define	DTCINSTALL_E_SERVER_ALREADY_INSTALLED					0x0000181L

//***** Install overwrite options
const	DWORD	DTC_INSTALL_OVERWRITE_CLIENT	=	0x00000001;
													// first bit from right, controls client overwrite
													// 1=Overwrite existing client install
													// 0=dont overwrite existing client install
const	DWORD	DTC_INSTALL_OVERWRITE_SERVER	=	0x00000002;
													//  second bit from right, controls server overwrite
													// 1=Overwrite existing server install
													// 0=dont overwrite existing server install

//---------------------------------------------------------
//			Function Prototypes
//---------------------------------------------------------
EXTERN_C
{
	DTC_GET_TRANSACTION_MANAGER			__cdecl LoadDtcHelper (void);
	DTC_GET_TRANSACTION_MANAGER_EX_A	__cdecl LoadDtcHelperExA (void);
	DTC_GET_TRANSACTION_MANAGER_EX_W	__cdecl LoadDtcHelperExW (void);
	void								__cdecl FreeDtcHelper (void);

	HMODULE __cdecl GetDtcLocaleResourceHandle(void);

	// Function:	Initialize
	// This function initialized all the function pointers needed to 
	// carry out other operations supported by this static library.
	// It is optional to make this call.
	// Returns - S_OK if all is fine, E_FAIL other wise.
	// Note: this function is not thread safe
	HRESULT __cdecl Initialize (void);

	// Function:	Uninitialize
	// This function unloads the dynamically loaded dlls.
	// Returns - S_OK if all is fine, E_FAIL other wise.
	// Note: this function is not thread safe
	HRESULT __cdecl Uninitialize (void);

	// Function:	GetDTCStatusW
	// Unicode version of GetDTCStatus - used to get the status of the DTC service.
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns - the appropriate status from the enum DTC_STATUS
	DTC_STATUS __cdecl GetDTCStatusW (__in LPWSTR wszHostName);

	// Function:	GetDTCStatusA
	// Ansi version of GetDTCStatus - used to get the status of the DTC service
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns - the appropriate status from the enum DTC_STATUS
	DTC_STATUS __cdecl GetDTCStatusA (__in LPSTR szHostName);

	// Function:	StartDTCW
	// Unicode version of StartDTC - used to start the DTC service.
	// If the service is already started then the following is a no-op
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StartDTCW (__in LPWSTR wszHostName);

	// Function:	StartDTCA
	// Ansi version of StartDTC - used to start the DTC service.
	// If the service is already started then the following is a no-op
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StartDTCA (__in LPSTR szHostName);

	// Function:	StopDTCW
	// Unicode version of StopDTC - used to stop the DTC service.
	// If the service is already stopped then the following is a no-op
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StopDTCW (__in LPWSTR wszHostName);

	// Function:	StopDTCA
	// Ansi version of StopDTC - used to stop the DTC service.
	// If the service is already stopped then the following is a no-op
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StopDTCA (__in LPSTR szHostName);


	//  Function:	DtcInstallClient
	//  Installs the client version of DTC.
	//  Parameters:	i_pszRemoteTmHostName	- the name of the host tm,
	//			i_szProt				- the protocol to use in string format
	//									0x00000001	TCP/IP  (1)
	//									0x00000004	NetBEUI	(4)
	//										
	//			i_dwOverwrite			- overwrite previous install or not?
	//			DTC_INSTALL_OVERWRITE_CLIENT	=	0x00000001;
													// 0=Overwrite existing client install
													// 1=dont overwrite existing client install
	//			DTC_INSTALL_OVERWRITE_SERVER	=	0x00000002;
													// 0=Overwrite existing server install
													// 1=dont overwrite existing server install
	//  Returns -	S_OK if all is ok
	//			E_FAIL if the operation failed for some reason
	//  E_UNEXPECTED if an unexpected error occured
	HRESULT __cdecl DtcInstallClient(__in LPTSTR i_pszRemoteTmHostName, DWORD i_dwProtocol, DWORD i_dwOverwrite);
}


//---------------------------------------------------------
//			ALL ERRORS GO HERE
//---------------------------------------------------------


#endif __DTCHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dvbsiparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dvbsiparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dvbsiparser_h__
#define __dvbsiparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDvbSiParser_FWD_DEFINED__
#define __IDvbSiParser_FWD_DEFINED__
typedef interface IDvbSiParser IDvbSiParser;
#endif 	/* __IDvbSiParser_FWD_DEFINED__ */


#ifndef __IDVB_NIT_FWD_DEFINED__
#define __IDVB_NIT_FWD_DEFINED__
typedef interface IDVB_NIT IDVB_NIT;
#endif 	/* __IDVB_NIT_FWD_DEFINED__ */


#ifndef __IDVB_SDT_FWD_DEFINED__
#define __IDVB_SDT_FWD_DEFINED__
typedef interface IDVB_SDT IDVB_SDT;
#endif 	/* __IDVB_SDT_FWD_DEFINED__ */


#ifndef __IDVB_EIT_FWD_DEFINED__
#define __IDVB_EIT_FWD_DEFINED__
typedef interface IDVB_EIT IDVB_EIT;
#endif 	/* __IDVB_EIT_FWD_DEFINED__ */


#ifndef __IDVB_BAT_FWD_DEFINED__
#define __IDVB_BAT_FWD_DEFINED__
typedef interface IDVB_BAT IDVB_BAT;
#endif 	/* __IDVB_BAT_FWD_DEFINED__ */


#ifndef __IDVB_RST_FWD_DEFINED__
#define __IDVB_RST_FWD_DEFINED__
typedef interface IDVB_RST IDVB_RST;
#endif 	/* __IDVB_RST_FWD_DEFINED__ */


#ifndef __IDVB_ST_FWD_DEFINED__
#define __IDVB_ST_FWD_DEFINED__
typedef interface IDVB_ST IDVB_ST;
#endif 	/* __IDVB_ST_FWD_DEFINED__ */


#ifndef __IDVB_TDT_FWD_DEFINED__
#define __IDVB_TDT_FWD_DEFINED__
typedef interface IDVB_TDT IDVB_TDT;
#endif 	/* __IDVB_TDT_FWD_DEFINED__ */


#ifndef __IDVB_TOT_FWD_DEFINED__
#define __IDVB_TOT_FWD_DEFINED__
typedef interface IDVB_TOT IDVB_TOT;
#endif 	/* __IDVB_TOT_FWD_DEFINED__ */


#ifndef __IDVB_DIT_FWD_DEFINED__
#define __IDVB_DIT_FWD_DEFINED__
typedef interface IDVB_DIT IDVB_DIT;
#endif 	/* __IDVB_DIT_FWD_DEFINED__ */


#ifndef __IDVB_SIT_FWD_DEFINED__
#define __IDVB_SIT_FWD_DEFINED__
typedef interface IDVB_SIT IDVB_SIT;
#endif 	/* __IDVB_SIT_FWD_DEFINED__ */


#ifndef __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbSatelliteDeliverySystemDescriptor IDvbSatelliteDeliverySystemDescriptor;
#endif 	/* __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbCableDeliverySystemDescriptor IDvbCableDeliverySystemDescriptor;
#endif 	/* __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbTerrestrialDeliverySystemDescriptor IDvbTerrestrialDeliverySystemDescriptor;
#endif 	/* __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbFrequencyListDescriptor_FWD_DEFINED__
#define __IDvbFrequencyListDescriptor_FWD_DEFINED__
typedef interface IDvbFrequencyListDescriptor IDvbFrequencyListDescriptor;
#endif 	/* __IDvbFrequencyListDescriptor_FWD_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor_FWD_DEFINED__
#define __IDvbLogicalChannelDescriptor_FWD_DEFINED__
typedef interface IDvbLogicalChannelDescriptor IDvbLogicalChannelDescriptor;
#endif 	/* __IDvbLogicalChannelDescriptor_FWD_DEFINED__ */


#ifndef __IDvbServiceDescriptor_FWD_DEFINED__
#define __IDvbServiceDescriptor_FWD_DEFINED__
typedef interface IDvbServiceDescriptor IDvbServiceDescriptor;
#endif 	/* __IDvbServiceDescriptor_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mpeg2structs.h"
#include "mpeg2data.h"
#include "mpeg2psiparser.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dvbsiparser_0000_0000 */
/* [local] */ 

















extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0000_v0_0_s_ifspec;

#ifndef __IDvbSiParser_INTERFACE_DEFINED__
#define __IDvbSiParser_INTERFACE_DEFINED__

/* interface IDvbSiParser */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbSiParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B758A7BD-14DC-449d-B828-35909ACB3B1E")
    IDvbSiParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IUnknown *punkMpeg2Data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPAT( 
            /* [out] */ __RPC__deref_out_opt IPAT **ppPAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt ICAT **ppCAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPMT( 
            /* [in] */ PID pid,
            /* [in] */ __RPC__in WORD *pwProgramNumber,
            /* [out] */ __RPC__deref_out_opt IPMT **ppPMT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTSDT( 
            /* [out] */ __RPC__deref_out_opt ITSDT **ppTSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNIT( 
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwNetworkId,
            /* [out] */ __RPC__deref_out_opt IDVB_NIT **ppNIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSDT( 
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwTransportStreamId,
            /* [out] */ __RPC__deref_out_opt IDVB_SDT **ppSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEIT( 
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwServiceId,
            /* [out] */ __RPC__deref_out_opt IDVB_EIT **ppEIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBAT( 
            /* [in] */ __RPC__in WORD *pwBouquetId,
            /* [out] */ __RPC__deref_out_opt IDVB_BAT **ppBAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRST( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_RST **ppRST) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetST( 
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_ST **ppST) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTDT( 
            /* [out] */ __RPC__deref_out_opt IDVB_TDT **ppTDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTOT( 
            /* [out] */ __RPC__deref_out_opt IDVB_TOT **ppTOT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDIT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_DIT **ppDIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSIT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_SIT **ppSIT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSiParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSiParser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSiParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSiParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDvbSiParser * This,
            /* [in] */ __RPC__in_opt IUnknown *punkMpeg2Data);
        
        HRESULT ( STDMETHODCALLTYPE *GetPAT )( 
            IDvbSiParser * This,
            /* [out] */ __RPC__deref_out_opt IPAT **ppPAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt ICAT **ppCAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetPMT )( 
            IDvbSiParser * This,
            /* [in] */ PID pid,
            /* [in] */ __RPC__in WORD *pwProgramNumber,
            /* [out] */ __RPC__deref_out_opt IPMT **ppPMT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSDT )( 
            IDvbSiParser * This,
            /* [out] */ __RPC__deref_out_opt ITSDT **ppTSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetNIT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwNetworkId,
            /* [out] */ __RPC__deref_out_opt IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwTransportStreamId,
            /* [out] */ __RPC__deref_out_opt IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [in] */ __RPC__in WORD *pwServiceId,
            /* [out] */ __RPC__deref_out_opt IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetBAT )( 
            IDvbSiParser * This,
            /* [in] */ __RPC__in WORD *pwBouquetId,
            /* [out] */ __RPC__deref_out_opt IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRST )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_RST **ppRST);
        
        HRESULT ( STDMETHODCALLTYPE *GetST )( 
            IDvbSiParser * This,
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_ST **ppST);
        
        HRESULT ( STDMETHODCALLTYPE *GetTDT )( 
            IDvbSiParser * This,
            /* [out] */ __RPC__deref_out_opt IDVB_TDT **ppTDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTOT )( 
            IDvbSiParser * This,
            /* [out] */ __RPC__deref_out_opt IDVB_TOT **ppTOT);
        
        HRESULT ( STDMETHODCALLTYPE *GetDIT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_DIT **ppDIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ __RPC__deref_out_opt IDVB_SIT **ppSIT);
        
        END_INTERFACE
    } IDvbSiParserVtbl;

    interface IDvbSiParser
    {
        CONST_VTBL struct IDvbSiParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSiParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSiParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSiParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSiParser_Initialize(This,punkMpeg2Data)	\
    ( (This)->lpVtbl -> Initialize(This,punkMpeg2Data) ) 

#define IDvbSiParser_GetPAT(This,ppPAT)	\
    ( (This)->lpVtbl -> GetPAT(This,ppPAT) ) 

#define IDvbSiParser_GetCAT(This,dwTimeout,ppCAT)	\
    ( (This)->lpVtbl -> GetCAT(This,dwTimeout,ppCAT) ) 

#define IDvbSiParser_GetPMT(This,pid,pwProgramNumber,ppPMT)	\
    ( (This)->lpVtbl -> GetPMT(This,pid,pwProgramNumber,ppPMT) ) 

#define IDvbSiParser_GetTSDT(This,ppTSDT)	\
    ( (This)->lpVtbl -> GetTSDT(This,ppTSDT) ) 

#define IDvbSiParser_GetNIT(This,tableId,pwNetworkId,ppNIT)	\
    ( (This)->lpVtbl -> GetNIT(This,tableId,pwNetworkId,ppNIT) ) 

#define IDvbSiParser_GetSDT(This,tableId,pwTransportStreamId,ppSDT)	\
    ( (This)->lpVtbl -> GetSDT(This,tableId,pwTransportStreamId,ppSDT) ) 

#define IDvbSiParser_GetEIT(This,tableId,pwServiceId,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT(This,tableId,pwServiceId,ppEIT) ) 

#define IDvbSiParser_GetBAT(This,pwBouquetId,ppBAT)	\
    ( (This)->lpVtbl -> GetBAT(This,pwBouquetId,ppBAT) ) 

#define IDvbSiParser_GetRST(This,dwTimeout,ppRST)	\
    ( (This)->lpVtbl -> GetRST(This,dwTimeout,ppRST) ) 

#define IDvbSiParser_GetST(This,pid,dwTimeout,ppST)	\
    ( (This)->lpVtbl -> GetST(This,pid,dwTimeout,ppST) ) 

#define IDvbSiParser_GetTDT(This,ppTDT)	\
    ( (This)->lpVtbl -> GetTDT(This,ppTDT) ) 

#define IDvbSiParser_GetTOT(This,ppTOT)	\
    ( (This)->lpVtbl -> GetTOT(This,ppTOT) ) 

#define IDvbSiParser_GetDIT(This,dwTimeout,ppDIT)	\
    ( (This)->lpVtbl -> GetDIT(This,dwTimeout,ppDIT) ) 

#define IDvbSiParser_GetSIT(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetSIT(This,dwTimeout,ppSIT) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSiParser_INTERFACE_DEFINED__ */


#ifndef __IDVB_NIT_INTERFACE_DEFINED__
#define __IDVB_NIT_INTERFACE_DEFINED__

/* interface IDVB_NIT */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDVB_NIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C64935F4-29E4-4e22-911A-63F7F55CB097")
    IDVB_NIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_NIT **ppNIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_NITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_NIT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_NIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_NIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_NIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_NIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkId )( 
            IDVB_NIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_NIT * This,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_NIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_NIT * This,
            /* [out] */ IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_NIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_NIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_NITVtbl;

    interface IDVB_NIT
    {
        CONST_VTBL struct IDVB_NITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_NIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_NIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_NIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_NIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_NIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_NIT_GetNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetNetworkId(This,pwVal) ) 

#define IDVB_NIT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_NIT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_NIT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_NIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_NIT_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_NIT_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_NIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_NIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_NIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_NIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_NIT_GetNextTable(This,ppNIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppNIT) ) 

#define IDVB_NIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_NIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_NIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_NIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_SDT_INTERFACE_DEFINED__
#define __IDVB_SDT_INTERFACE_DEFINED__

/* interface IDVB_SDT */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDVB_SDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02CAD8D3-FE43-48e2-90BD-450ED9A8A5FD")
    IDVB_SDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEITScheduleFlag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEITPresentFollowingFlag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordFreeCAMode( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_SDT **ppSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_SDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_SDT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_SDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_SDT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_SDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IDVB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IDVB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_SDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITScheduleFlag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITPresentFollowingFlag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_SDT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_SDT * This,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_SDT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_SDT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_SDTVtbl;

    interface IDVB_SDT
    {
        CONST_VTBL struct IDVB_SDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_SDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_SDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_SDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_SDT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_SDT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_SDT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IDVB_SDT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IDVB_SDT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_SDT_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_SDT_GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_SDT_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_SDT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_SDT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SDT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_SDT_GetNextTable(This,ppSDT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppSDT) ) 

#define IDVB_SDT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_SDT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_SDT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_SDT_INTERFACE_DEFINED__ */


#ifndef __IDVB_EIT_INTERFACE_DEFINED__
#define __IDVB_EIT_INTERFACE_DEFINED__

/* interface IDVB_EIT */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDVB_EIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("442DB029-02CB-4495-8B92-1C13375BCE99")
    IDVB_EIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentLastSectionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastTableId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEventId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordStartTime( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDuration( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordFreeCAMode( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_EIT **ppEIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_EITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_EIT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_EIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_EIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_EIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentLastSectionNumber )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastTableId )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_EIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordStartTime )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDuration )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_EIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_EIT * This,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_EIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_EIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_EIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_EITVtbl;

    interface IDVB_EIT
    {
        CONST_VTBL struct IDVB_EITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_EIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_EIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_EIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_EIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_EIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_EIT_GetServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,pwVal) ) 

#define IDVB_EIT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IDVB_EIT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IDVB_EIT_GetSegmentLastSectionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetSegmentLastSectionNumber(This,pbVal) ) 

#define IDVB_EIT_GetLastTableId(This,pbVal)	\
    ( (This)->lpVtbl -> GetLastTableId(This,pbVal) ) 

#define IDVB_EIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_EIT_GetRecordEventId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,pwVal) ) 

#define IDVB_EIT_GetRecordStartTime(This,dwRecordIndex,pmdtVal)	\
    ( (This)->lpVtbl -> GetRecordStartTime(This,dwRecordIndex,pmdtVal) ) 

#define IDVB_EIT_GetRecordDuration(This,dwRecordIndex,pmdVal)	\
    ( (This)->lpVtbl -> GetRecordDuration(This,dwRecordIndex,pmdVal) ) 

#define IDVB_EIT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_EIT_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IDVB_EIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_EIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_EIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_EIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_EIT_GetNextTable(This,ppEIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppEIT) ) 

#define IDVB_EIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_EIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_EIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_EIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_BAT_INTERFACE_DEFINED__
#define __IDVB_BAT_INTERFACE_DEFINED__

/* interface IDVB_BAT */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDVB_BAT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECE9BB0C-43B6-4558-A0EC-1812C34CD6CA")
    IDVB_BAT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBouquetId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_BAT **ppBAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_BATVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_BAT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_BAT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_BAT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_BAT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_BAT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBouquetId )( 
            IDVB_BAT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_BAT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_BAT * This,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_BAT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_BAT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_BAT * This,
            /* [out] */ IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_BAT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_BAT * This);
        
        END_INTERFACE
    } IDVB_BATVtbl;

    interface IDVB_BAT
    {
        CONST_VTBL struct IDVB_BATVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_BAT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_BAT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_BAT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_BAT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_BAT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_BAT_GetBouquetId(This,pwVal)	\
    ( (This)->lpVtbl -> GetBouquetId(This,pwVal) ) 

#define IDVB_BAT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_BAT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_BAT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_BAT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_BAT_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_BAT_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_BAT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_BAT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_BAT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_BAT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_BAT_GetNextTable(This,ppBAT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppBAT) ) 

#define IDVB_BAT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_BAT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_BAT_INTERFACE_DEFINED__ */


#ifndef __IDVB_RST_INTERFACE_DEFINED__
#define __IDVB_RST_INTERFACE_DEFINED__

/* interface IDVB_RST */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVB_RST;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F47DCD04-1E23-4fb7-9F96-B40EEAD10B2B")
    IDVB_RST : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEventId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_RSTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_RST * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_RST * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_RST * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_RST * This,
            /* [in] */ __RPC__in_opt ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_RST * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        END_INTERFACE
    } IDVB_RSTVtbl;

    interface IDVB_RST
    {
        CONST_VTBL struct IDVB_RSTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_RST_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_RST_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_RST_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_RST_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_RST_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_RST_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordEventId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_RST_INTERFACE_DEFINED__ */


#ifndef __IDVB_ST_INTERFACE_DEFINED__
#define __IDVB_ST_INTERFACE_DEFINED__

/* interface IDVB_ST */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVB_ST;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D5B9F23-2A02-45de-BCDA-5D5DBFBFBE62")
    IDVB_ST : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataLength( 
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ __RPC__deref_out_opt BYTE **ppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_STVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_ST * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_ST * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_ST * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_ST * This,
            /* [in] */ __RPC__in_opt ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataLength )( 
            IDVB_ST * This,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IDVB_ST * This,
            /* [out] */ __RPC__deref_out_opt BYTE **ppData);
        
        END_INTERFACE
    } IDVB_STVtbl;

    interface IDVB_ST
    {
        CONST_VTBL struct IDVB_STVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_ST_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_ST_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_ST_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_ST_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_ST_GetDataLength(This,pwVal)	\
    ( (This)->lpVtbl -> GetDataLength(This,pwVal) ) 

#define IDVB_ST_GetData(This,ppData)	\
    ( (This)->lpVtbl -> GetData(This,ppData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_ST_INTERFACE_DEFINED__ */


#ifndef __IDVB_TDT_INTERFACE_DEFINED__
#define __IDVB_TDT_INTERFACE_DEFINED__

/* interface IDVB_TDT */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVB_TDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0780DC7D-D55C-4aef-97E6-6B75906E2796")
    IDVB_TDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUTCTime( 
            /* [out] */ __RPC__out MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_TDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_TDT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_TDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_TDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_TDT * This,
            /* [in] */ __RPC__in_opt ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetUTCTime )( 
            IDVB_TDT * This,
            /* [out] */ __RPC__out MPEG_DATE_AND_TIME *pmdtVal);
        
        END_INTERFACE
    } IDVB_TDTVtbl;

    interface IDVB_TDT
    {
        CONST_VTBL struct IDVB_TDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_TDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_TDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_TDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_TDT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_TDT_GetUTCTime(This,pmdtVal)	\
    ( (This)->lpVtbl -> GetUTCTime(This,pmdtVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_TDT_INTERFACE_DEFINED__ */


#ifndef __IDVB_TOT_INTERFACE_DEFINED__
#define __IDVB_TOT_INTERFACE_DEFINED__

/* interface IDVB_TOT */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVB_TOT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83295D6A-FABA-4ee1-9B15-8067696910AE")
    IDVB_TOT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUTCTime( 
            /* [out] */ __RPC__out MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [out][in] */ __RPC__inout DWORD *pdwCookie,
            /* [out] */ __RPC__deref_out_opt IGenericDescriptor **ppDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_TOTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_TOT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_TOT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_TOT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_TOT * This,
            /* [in] */ __RPC__in_opt ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetUTCTime )( 
            IDVB_TOT * This,
            /* [out] */ __RPC__out MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_TOT * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_TOT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_TOT * This,
            /* [in] */ BYTE bTag,
            /* [out][in] */ __RPC__inout DWORD *pdwCookie,
            /* [out] */ __RPC__deref_out_opt IGenericDescriptor **ppDescriptor);
        
        END_INTERFACE
    } IDVB_TOTVtbl;

    interface IDVB_TOT
    {
        CONST_VTBL struct IDVB_TOTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_TOT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_TOT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_TOT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_TOT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_TOT_GetUTCTime(This,pmdtVal)	\
    ( (This)->lpVtbl -> GetUTCTime(This,pmdtVal) ) 

#define IDVB_TOT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_TOT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_TOT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_TOT_INTERFACE_DEFINED__ */


#ifndef __IDVB_DIT_INTERFACE_DEFINED__
#define __IDVB_DIT_INTERFACE_DEFINED__

/* interface IDVB_DIT */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVB_DIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91BFFDF9-9432-410f-86EF-1C228ED0AD70")
    IDVB_DIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransitionFlag( 
            /* [out] */ __RPC__out BOOL *pfVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_DITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_DIT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_DIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_DIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_DIT * This,
            /* [in] */ __RPC__in_opt ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransitionFlag )( 
            IDVB_DIT * This,
            /* [out] */ __RPC__out BOOL *pfVal);
        
        END_INTERFACE
    } IDVB_DITVtbl;

    interface IDVB_DIT
    {
        CONST_VTBL struct IDVB_DITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_DIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_DIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_DIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_DIT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_DIT_GetTransitionFlag(This,pfVal)	\
    ( (This)->lpVtbl -> GetTransitionFlag(This,pfVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_DIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_SIT_INTERFACE_DEFINED__
#define __IDVB_SIT_INTERFACE_DEFINED__

/* interface IDVB_SIT */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDVB_SIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68CDCE53-8BEA-45c2-9D9D-ACF575A089B5")
    IDVB_SIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_SITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_SIT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_SIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_SIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_SIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_SIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_SIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_SIT * This,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_SIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_SIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_SIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_SIT * This);
        
        END_INTERFACE
    } IDVB_SITVtbl;

    interface IDVB_SIT
    {
        CONST_VTBL struct IDVB_SITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_SIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_SIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_SIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_SIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_SIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_SIT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_SIT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_SIT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_SIT_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_SIT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_SIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_SIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_SIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_SIT_GetNextTable(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,dwTimeout,ppSIT) ) 

#define IDVB_SIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_SIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_SIT_INTERFACE_DEFINED__ */


#ifndef __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbSatelliteDeliverySystemDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbSatelliteDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02F2225A-805B-4ec5-A9A6-F9B5913CD470")
    IDvbSatelliteDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOrbitalPosition( 
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWestEastFlag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolarization( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulation( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolRate( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECInner( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSatelliteDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSatelliteDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSatelliteDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOrbitalPosition )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetWestEastFlag )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolarization )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulation )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolRate )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECInner )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        END_INTERFACE
    } IDvbSatelliteDeliverySystemDescriptorVtbl;

    interface IDvbSatelliteDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbSatelliteDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSatelliteDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSatelliteDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSatelliteDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSatelliteDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetFrequency(This,pdwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetOrbitalPosition(This,pwVal)	\
    ( (This)->lpVtbl -> GetOrbitalPosition(This,pwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetWestEastFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetWestEastFlag(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetPolarization(This,pbVal)	\
    ( (This)->lpVtbl -> GetPolarization(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetModulation(This,pbVal)	\
    ( (This)->lpVtbl -> GetModulation(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetSymbolRate(This,pdwVal)	\
    ( (This)->lpVtbl -> GetSymbolRate(This,pdwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetFECInner(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECInner(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbCableDeliverySystemDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbCableDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFB98E36-9E1A-4862-9946-993A4E59017B")
    IDvbCableDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECOuter( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulation( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolRate( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECInner( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbCableDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbCableDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbCableDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECOuter )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulation )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolRate )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECInner )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        END_INTERFACE
    } IDvbCableDeliverySystemDescriptorVtbl;

    interface IDvbCableDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbCableDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbCableDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbCableDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbCableDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbCableDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetFrequency(This,pdwVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFECOuter(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECOuter(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetModulation(This,pbVal)	\
    ( (This)->lpVtbl -> GetModulation(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetSymbolRate(This,pdwVal)	\
    ( (This)->lpVtbl -> GetSymbolRate(This,pdwVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFECInner(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECInner(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbTerrestrialDeliverySystemDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbTerrestrialDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED7E1B91-D12E-420c-B41D-A49D84FE1823")
    IDvbTerrestrialDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCentreFrequency( 
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConstellation( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHierarchyInformation( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeRateHPStream( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeRateLPStream( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuardInterval( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransmissionMode( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOtherFrequencyFlag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbTerrestrialDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbTerrestrialDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbTerrestrialDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCentreFrequency )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidth )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetConstellation )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetHierarchyInformation )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeRateHPStream )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeRateLPStream )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuardInterval )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransmissionMode )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOtherFrequencyFlag )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        END_INTERFACE
    } IDvbTerrestrialDeliverySystemDescriptorVtbl;

    interface IDvbTerrestrialDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbTerrestrialDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbTerrestrialDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbTerrestrialDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCentreFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCentreFrequency(This,pdwVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetBandwidth(This,pbVal)	\
    ( (This)->lpVtbl -> GetBandwidth(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetConstellation(This,pbVal)	\
    ( (This)->lpVtbl -> GetConstellation(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetHierarchyInformation(This,pbVal)	\
    ( (This)->lpVtbl -> GetHierarchyInformation(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateHPStream(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodeRateHPStream(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateLPStream(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodeRateLPStream(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetGuardInterval(This,pbVal)	\
    ( (This)->lpVtbl -> GetGuardInterval(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(This,pbVal)	\
    ( (This)->lpVtbl -> GetTransmissionMode(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetOtherFrequencyFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetOtherFrequencyFlag(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__
#define __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__

/* interface IDvbFrequencyListDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbFrequencyListDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CADB613-E1DD-4512-AFA8-BB7A007EF8B1")
    IDvbFrequencyListDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodingType( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCentreFrequency( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out DWORD *pdwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbFrequencyListDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbFrequencyListDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbFrequencyListDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbFrequencyListDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodingType )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCentreFrequency )( 
            IDvbFrequencyListDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out DWORD *pdwVal);
        
        END_INTERFACE
    } IDvbFrequencyListDescriptorVtbl;

    interface IDvbFrequencyListDescriptor
    {
        CONST_VTBL struct IDvbFrequencyListDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbFrequencyListDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbFrequencyListDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbFrequencyListDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbFrequencyListDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetCodingType(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodingType(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetRecordCentreFrequency(This,bRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCentreFrequency(This,bRecordIndex,pdwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__
#define __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__

/* interface IDvbLogicalChannelDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbLogicalChannelDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF1EDAFF-3FFD-4cf7-8201-35756ACBF85F")
    IDvbLogicalChannelDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLogicalChannelNumber( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbLogicalChannelDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbLogicalChannelDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbLogicalChannelDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelNumber )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ __RPC__out WORD *pwVal);
        
        END_INTERFACE
    } IDvbLogicalChannelDescriptorVtbl;

    interface IDvbLogicalChannelDescriptor
    {
        CONST_VTBL struct IDvbLogicalChannelDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbLogicalChannelDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbLogicalChannelDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbLogicalChannelDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbLogicalChannelDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannelDescriptor_GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbServiceDescriptor_INTERFACE_DEFINED__
#define __IDvbServiceDescriptor_INTERFACE_DEFINED__

/* interface IDvbServiceDescriptor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvbServiceDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9C7FBCF-E2D6-464d-B32D-2EF526E49290")
    IDvbServiceDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceType( 
            /* [out] */ __RPC__out BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProviderName( 
            /* [out] */ __RPC__deref_out_opt char **pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProviderNameW( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceName( 
            /* [out] */ __RPC__deref_out_opt char **pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessedServiceName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceNameEmphasized( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbServiceDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbServiceDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbServiceDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbServiceDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceType )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__out BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderName )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__deref_out_opt char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderNameW )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__deref_out_opt char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessedServiceName )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceNameEmphasized )( 
            IDvbServiceDescriptor * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        END_INTERFACE
    } IDvbServiceDescriptorVtbl;

    interface IDvbServiceDescriptor
    {
        CONST_VTBL struct IDvbServiceDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbServiceDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbServiceDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbServiceDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbServiceDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbServiceDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbServiceDescriptor_GetServiceType(This,pbVal)	\
    ( (This)->lpVtbl -> GetServiceType(This,pbVal) ) 

#define IDvbServiceDescriptor_GetServiceProviderName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceProviderName(This,pszName) ) 

#define IDvbServiceDescriptor_GetServiceProviderNameW(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceProviderNameW(This,pbstrName) ) 

#define IDvbServiceDescriptor_GetServiceName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceName(This,pszName) ) 

#define IDvbServiceDescriptor_GetProcessedServiceName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetProcessedServiceName(This,pbstrName) ) 

#define IDvbServiceDescriptor_GetServiceNameEmphasized(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceNameEmphasized(This,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbServiceDescriptor_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dvdevcod.h ===
//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __DVDEVCOD__
#define __DVDEVCOD__


#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by 
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8,
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
    DVD_ERROR_CopyProtectOutputFail=9,  // DVD copy protection failed due to output display
    DVD_ERROR_CopyProtectOutputNotSupported=10,  // DVD copy protection failed due to lack of driver
                                    // support for checking the output display
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
                                    //   lParam2 contains the stream type (see AM_DVD_STREAM_FLAGS)
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

typedef enum _tagDVD_PB_STOPPED {
    DVD_PB_STOPPED_Other=0,                 // The navigator stopped the playback (no reason available).
    DVD_PB_STOPPED_NoBranch=1,              // The nav completed the current pgc and there was no more video and
                                            // did not find any other branching instruction for subsequent playback.
    DVD_PB_STOPPED_NoFirstPlayDomain =2,    // The disc does not contain an initial startup program.
    DVD_PB_STOPPED_StopCommand = 3,         // The app issued a stop() command or a stop command was authored on the disc.
    DVD_PB_STOPPED_Reset=4,                 // The navigator was reset to the start of the disc (using ResetOnStop).
    DVD_PB_STOPPED_DiscEjected=5,           // The disc was ejected.
    DVD_PB_STOPPED_IllegalNavCommand = 6,   // An illegal nav command prevented playback from continuing.
    DVD_PB_STOPPED_PlayPeriodAutoStop = 7,  // PlayPeriod completed
    DVD_PB_STOPPED_PlayChapterAutoStop = 8, // PlayChapter completed
    DVD_PB_STOPPED_ParentalFailure = 9,     // A parental level failure prevented playback
    DVD_PB_STOPPED_RegionFailure = 10,      // A region failure prevented playback
    DVD_PB_STOPPED_MacrovisionFailure = 11, // A Macrovision failure prevented playback.
    DVD_PB_STOPPED_DiscReadError = 12,      // A read error prevented playback.
    DVD_PB_STOPPED_CopyProtectFailure = 13, // Copy protection failure.
    DVD_PB_STOPPED_CopyProtectOutputFailure = 14, // Copy protection failure due to non-compliant output device
    DVD_PB_STOPPED_CopyProtectOutputNotSupported = 15 // Copy protection failure due to missing driver support to check
                                            // output device
} DVD_PB_STOPPED;


#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is the new user subpicture stream number.
// lParam2 is the subpicture's on/off state (TRUE if on)
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, DWORD) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
// lParam2 contains more specific information about the warning (warning dependent)
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (DWORD, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//
//  The DWORD returns the reason for the completion of the playback.  See
//  The DVD_PB_STOPPED enumeration for details.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG ) 
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved ) 
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//
#endif // __DVDEVCOD__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dwmapi.h ===
/*=========================================================================*\

    Copyright (c) Microsoft Corporation.  All rights reserved.

    File: dwmapi.h

    Module Name: dwmapi

    Description: DWM API declarations

\*=========================================================================*/
#ifndef _DWMAPI_H_
#define _DWMAPI_H_


#ifndef DWMAPI
#if !defined(_DWMAPI_)
#define DWMAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define DWMAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define DWMAPI          STDAPI
#define DWMAPI_(type)   STDAPI_(type)
#endif /* _DWMAPI_ */
#endif /* DWMAPI */

#include <pshpack1.h>

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef MILCORE_KERNEL_COMPONENT
#include <wtypes.h>
#include <uxtheme.h>
#endif

// Blur behind data structures
#define DWM_BB_ENABLE                 0x00000001  // fEnable has been specified
#define DWM_BB_BLURREGION             0x00000002  // hRgnBlur has been specified
#define DWM_BB_TRANSITIONONMAXIMIZED  0x00000004  // fTransitionOnMaximized has been specified

typedef struct _DWM_BLURBEHIND
{
    DWORD dwFlags;
    BOOL fEnable;
    HRGN hRgnBlur;
    BOOL fTransitionOnMaximized;
} DWM_BLURBEHIND, *PDWM_BLURBEHIND;

// Window attributes
enum DWMWINDOWATTRIBUTE
{
    DWMWA_NCRENDERING_ENABLED = 1,      // [get] Is non-client rendering enabled/disabled
    DWMWA_NCRENDERING_POLICY,           // [set] Non-client rendering policy
    DWMWA_TRANSITIONS_FORCEDISABLED,    // [set] Potentially enable/forcibly disable transitions
    DWMWA_ALLOW_NCPAINT,                // [set] Allow contents rendered in the non-client area to be visible on the DWM-drawn frame.
    DWMWA_CAPTION_BUTTON_BOUNDS,        // [get] Bounds of the caption button area in window-relative space.
    DWMWA_NONCLIENT_RTL_LAYOUT,         // [set] Is non-client content RTL mirrored
    DWMWA_FORCE_ICONIC_REPRESENTATION,  // [set] Force this window to display iconic thumbnails.
    DWMWA_FLIP3D_POLICY,                // [set] Designates how Flip3D will treat the window.
    DWMWA_EXTENDED_FRAME_BOUNDS,        // [get] Gets the extended frame bounds rectangle in screen space
    DWMWA_LAST
};

// Non-client rendering policy attribute values
enum DWMNCRENDERINGPOLICY
{
    DWMNCRP_USEWINDOWSTYLE, // Enable/disable non-client rendering based on window style
    DWMNCRP_DISABLED,       // Disabled non-client rendering; window style is ignored
    DWMNCRP_ENABLED,        // Enabled non-client rendering; window style is ignored
    DWMNCRP_LAST
};

// Values designating how Flip3D treats a given window.
enum DWMFLIP3DWINDOWPOLICY
{
    DWMFLIP3D_DEFAULT,      // Hide or include the window in Flip3D based on window style and visibility.
    DWMFLIP3D_EXCLUDEBELOW, // Display the window under Flip3D and disabled.
    DWMFLIP3D_EXCLUDEABOVE, // Display the window above Flip3D and enabled.
    DWMFLIP3D_LAST
};


// Thumbnails
typedef HANDLE HTHUMBNAIL;
typedef HTHUMBNAIL* PHTHUMBNAIL;

#define DWM_TNP_RECTDESTINATION       0x00000001
#define DWM_TNP_RECTSOURCE            0x00000002
#define DWM_TNP_OPACITY               0x00000004
#define DWM_TNP_VISIBLE               0x00000008
#define DWM_TNP_SOURCECLIENTAREAONLY  0x00000010

typedef struct _DWM_THUMBNAIL_PROPERTIES
{
    DWORD dwFlags;
    RECT rcDestination;
    RECT rcSource;
    BYTE opacity;
    BOOL fVisible;
    BOOL fSourceClientAreaOnly;
} DWM_THUMBNAIL_PROPERTIES, *PDWM_THUMBNAIL_PROPERTIES;

// Video enabling apis

typedef ULONGLONG DWM_FRAME_COUNT;
typedef ULONGLONG QPC_TIME;

typedef  struct _UNSIGNED_RATIO
{
    UINT32 uiNumerator;
    UINT32 uiDenominator;
} UNSIGNED_RATIO;

typedef  struct _DWM_TIMING_INFO
{
    UINT32          cbSize;

    // Data on DWM composition overall
    
    // Monitor refresh rate
    UNSIGNED_RATIO  rateRefresh;

    // Actual period
    QPC_TIME        qpcRefreshPeriod;

    // composition rate     
    UNSIGNED_RATIO  rateCompose;

    // QPC time at a VSync interupt
    QPC_TIME        qpcVBlank;

    // DWM refresh count of the last vsync
    // DWM refresh count is a 64bit number where zero is
    // the first refresh the DWM woke up to process
    DWM_FRAME_COUNT cRefresh;

    // DX refresh count at the last Vsync Interupt
    // DX refresh count is a 32bit number with zero 
    // being the first refresh after the card was initialized
    // DX increments a counter when ever a VSync ISR is processed
    // It is possible for DX to miss VSyncs
    //
    // There is not a fixed mapping between DX and DWM refresh counts
    // because the DX will rollover and may miss VSync interupts
    UINT cDXRefresh;

    // QPC time at a compose time.  
    QPC_TIME        qpcCompose;

    // Frame number that was composed at qpcCompose
    DWM_FRAME_COUNT cFrame;

    // The present number DX uses to identify renderer frames
    UINT            cDXPresent;

    // Refresh count of the frame that was composed at qpcCompose
    DWM_FRAME_COUNT cRefreshFrame;


    // DWM frame number that was last submitted
    DWM_FRAME_COUNT cFrameSubmitted;

    // DX Present number that was last submitted
    UINT cDXPresentSubmitted;

    // DWM frame number that was last confirmed presented
    DWM_FRAME_COUNT cFrameConfirmed;

    // DX Present number that was last confirmed presented
    UINT cDXPresentConfirmed;

    // The target refresh count of the last
    // frame confirmed completed by the GPU
    DWM_FRAME_COUNT cRefreshConfirmed;

    // DX refresh count when the frame was confirmed presented
    UINT cDXRefreshConfirmed;

    // Number of frames the DWM presented late
    // AKA Glitches
    DWM_FRAME_COUNT          cFramesLate;
    
    // the number of composition frames that 
    // have been issued but not confirmed completed
    UINT          cFramesOutstanding;


    // Following fields are only relavent when an HWND is specified
    // Display frame


    // Last frame displayed
    DWM_FRAME_COUNT cFrameDisplayed;

    // QPC time of the composition pass when the frame was displayed
    QPC_TIME        qpcFrameDisplayed; 

    // Count of the VSync when the frame should have become visible
    DWM_FRAME_COUNT cRefreshFrameDisplayed;

    // Complete frames: DX has notified the DWM that the frame is done rendering

    // ID of the the last frame marked complete (starts at 0)
    DWM_FRAME_COUNT cFrameComplete;

    // QPC time when the last frame was marked complete
    QPC_TIME        qpcFrameComplete;

    // Pending frames:
    // The application has been submitted to DX but not completed by the GPU
 
    // ID of the the last frame marked pending (starts at 0)
    DWM_FRAME_COUNT cFramePending;

    // QPC time when the last frame was marked pending
    QPC_TIME        qpcFramePending;

    // number of unique frames displayed
    DWM_FRAME_COUNT cFramesDisplayed;

    // number of new completed frames that have been received
    DWM_FRAME_COUNT cFramesComplete;

     // number of new frames submitted to DX but not yet complete
    DWM_FRAME_COUNT cFramesPending;

    // number of frames available but not displayed, used or dropped
    DWM_FRAME_COUNT cFramesAvailable;

    // number of rendered frames that were never
    // displayed because composition occured too late
    DWM_FRAME_COUNT cFramesDropped;
    
    // number of times an old frame was composed 
    // when a new frame should have been used
    // but was not available
    DWM_FRAME_COUNT cFramesMissed;
    
    // the refresh at which the next frame is
    // scheduled to be displayed
    DWM_FRAME_COUNT cRefreshNextDisplayed;

    // the refresh at which the next DX present is 
    // scheduled to be displayed
    DWM_FRAME_COUNT cRefreshNextPresented;

    // The total number of refreshes worth of content
    // for this HWND that have been displayed by the DWM
    // since DwmSetPresentParameters was called
    DWM_FRAME_COUNT cRefreshesDisplayed;
	
    // The total number of refreshes worth of content
    // that have been presented by the application
    // since DwmSetPresentParameters was called
    DWM_FRAME_COUNT cRefreshesPresented;


    // The actual refresh # when content for this
    // window started to be displayed
    // it may be different than that requested
    // DwmSetPresentParameters
    DWM_FRAME_COUNT cRefreshStarted;

    // Total number of pixels DX redirected
    // to the DWM.
    // If Queueing is used the full buffer
    // is transfered on each present.
    // If not queuing it is possible only 
    // a dirty region is updated
    ULONGLONG  cPixelsReceived;

    // Total number of pixels drawn.
    // Does not take into account if
    // if the window is only partial drawn
    // do to clipping or dirty rect management 
    ULONGLONG  cPixelsDrawn;

    // The number of buffers in the flipchain
    // that are empty.   An application can 
    // present that number of times and guarantee 
    // it won't be blocked waiting for a buffer to 
    // become empty to present to
    DWM_FRAME_COUNT      cBuffersEmpty;

} DWM_TIMING_INFO;


typedef enum 
{
    // Use the first source frame that 
    // includes the first refresh of the output frame
    DWM_SOURCE_FRAME_SAMPLING_POINT,

    // use the source frame that includes the most 
    // refreshes of out the output frame
    // in case of multiple source frames with the 
    // same coverage the last will be used
    DWM_SOURCE_FRAME_SAMPLING_COVERAGE,

       // Sentinel value
    DWM_SOURCE_FRAME_SAMPLING_LAST
} DWM_SOURCE_FRAME_SAMPLING;

static const UINT c_DwmMaxQueuedBuffers = 8;
static const UINT c_DwmMaxMonitors = 16;
static const UINT c_DwmMaxAdapters = 16;

#pragma warning(push)
#pragma warning(disable:4201)
typedef struct _DWM_PRESENT_PARAMETERS
{
    UINT32          cbSize;
    BOOL            fQueue;
    DWM_FRAME_COUNT cRefreshStart;
    UINT            cBuffer;
    BOOL            fUseSourceRate;
    UNSIGNED_RATIO  rateSource;
    UINT            cRefreshesPerFrame;
    DWM_SOURCE_FRAME_SAMPLING  eSampling;
} DWM_PRESENT_PARAMETERS;
#pragma warning(pop)



#define DWM_FRAME_DURATION_DEFAULT -1

DWMAPI_(BOOL)
DwmDefWindowProc(
    __in HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    __out LRESULT *plResult
    );

DWMAPI 
DwmEnableBlurBehindWindow(
    HWND hWnd, 
    __in const DWM_BLURBEHIND* pBlurBehind
    );

#define DWM_EC_DISABLECOMPOSITION         0
#define DWM_EC_ENABLECOMPOSITION          1


DWMAPI 
DwmEnableComposition(
    UINT uCompositionAction
    );

DWMAPI  
DwmEnableMMCSS(
    BOOL fEnableMMCSS
    );

DWMAPI 
DwmExtendFrameIntoClientArea(
    HWND hWnd,
    __in const MARGINS* pMarInset
    );
    
DWMAPI
DwmGetColorizationColor(
    __out DWORD* pcrColorization,
    __out BOOL* pfOpaqueBlend
    );



DWMAPI
DwmGetCompositionTimingInfo(
    HWND hwnd,
    __out DWM_TIMING_INFO* pTimingInfo
    );


DWMAPI
DwmGetWindowAttribute(
    HWND hwnd,
    DWORD dwAttribute,
    __out_bcount(cbAttribute) PVOID pvAttribute, 
    DWORD cbAttribute
    );

DWMAPI 
DwmIsCompositionEnabled(
    __out BOOL* pfEnabled
    );

DWMAPI
DwmModifyPreviousDxFrameDuration(
    HWND hwnd, 
    INT cRefreshes,
    BOOL fRelative
    );

DWMAPI
DwmQueryThumbnailSourceSize(
    HTHUMBNAIL hThumbnail, 
    __out PSIZE pSize
    );

DWMAPI
DwmRegisterThumbnail(
    HWND hwndDestination, 
    HWND hwndSource, 
    __out PHTHUMBNAIL phThumbnailId
    );

DWMAPI
DwmSetDxFrameDuration(
    HWND hwnd, 
    INT cRefreshes
    );

DWMAPI
DwmSetPresentParameters(
    HWND hwnd,
   __inout DWM_PRESENT_PARAMETERS* pPresentParams
    );

DWMAPI
DwmSetWindowAttribute(
    HWND hwnd,
    DWORD dwAttribute,
    __in_bcount(cbAttribute) LPCVOID pvAttribute, 
    DWORD cbAttribute
    );

DWMAPI
DwmUnregisterThumbnail(
    HTHUMBNAIL hThumbnailId
    );

DWMAPI
DwmUpdateThumbnailProperties(
    HTHUMBNAIL hThumbnailId, 
    __in const DWM_THUMBNAIL_PROPERTIES* ptnProperties
    );

DWMAPI
DwmAttachMilContent(
    HWND hwnd
    );

DWMAPI
DwmDetachMilContent(
    HWND hwnd
    );

DWMAPI
DwmFlush();

#ifndef MILCORE_KERNEL_COMPONENT
#ifndef _MIL_MATRIX3X2D_DEFINED

typedef struct _MIL_MATRIX3X2D
{
    DOUBLE S_11;
    DOUBLE S_12;
    DOUBLE S_21;
    DOUBLE S_22;
    DOUBLE DX;
    DOUBLE DY;
} MIL_MATRIX3X2D;

#define _MIL_MATRIX3X2D_DEFINED

#endif // _MIL_MATRIX3X2D_DEFINED

DWMAPI
DwmGetGraphicsStreamTransformHint(
    UINT uIndex,
    __out MIL_MATRIX3X2D *pTransform
    );

DWMAPI
DwmGetGraphicsStreamClient(
    UINT uIndex,
    __out UUID *pClientUuid
    );
#endif // MILCORE_KERNEL_COMPONENT

DWMAPI
DwmGetTransportAttributes(
    __out_ecount(1) BOOL *pfIsRemoting,
    __out_ecount(1) BOOL *pfIsConnected,
    __out_ecount(1) DWORD *pDwGeneration
    );



#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif // _DWMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dx95type.h ===
/******************************Module*Header*******************************\
*
* Module Name: dx95type.h
*
* Portability module for NT kernel-mode DirectX components created from
* Win95 sources
*
* Copyright (c) Microsoft Corp. All Rights Reserved.
*
\**************************************************************************/

#ifndef __DX95TYPE_H__
#define __DX95TYPE_H__

// Basic includes
#ifndef NODXINCLUDES
#ifdef WINNT
#include <stddef.h>
// Includes ddrawint.h and d3dnthal.h
#include <winddi.h>
#else // WINNT
#include <ddrawi.h>
#include <d3dhal.h>
#endif // WINNT
#endif // NODXINCLUDES

// Simple memory allocation of N bytes
#ifndef NODXMALLOC
#ifdef WINNT
#define DXMALLOC(n) EngAllocMem(0, n, 'amxD')
#define DXMALLOCZ(n) EngAllocMem(FL_ZERO_MEMORY, n, 'amxD')
#define DXFREE(p) EngFreeMem(p)
#else // WINNT
#define DXMALLOC(n) HeapAlloc(GetProcessHeap(), 0, n)
#define DXMALLOCZ(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define DXFREE(n) HeapFree(GetProcessHeap(), 0, n)
#endif // WINNT
#endif // NODXMALLOC

// Surface and palette access macros
#ifndef NODXLCL
#ifdef WINNT
#define DDS_LCL(pdds) (pdds)
#define DDP_LCL(pddp) (pddp)
#else // WINNT
#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)(pdds))->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)(pddp))->lpLcl)
#endif // WINNT
#define DDS_LCL_OR_NULL(pdds) ((pdds) == NULL ? NULL : DDS_LCL(pdds))
#define DDP_LCL_OR_NULL(pddp) ((pddp) == NULL ? NULL : DDP_LCL(pddp))
#endif // NODXLCL

// Typedefs and defines to create a Win95-like compilation environment

#ifndef NODX95TYPES
#ifdef WINNT

typedef D3DNTHALDEVICEDESC_V1           D3DDEVICEDESC_V1;
typedef PDD_SURFACE_LOCAL               LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_MORE                LPDDRAWI_DDRAWSURFACE_MORE;
typedef PDD_SURFACE_GLOBAL              LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
typedef PDD_ATTACHLIST                  LPATTACHLIST;

typedef DDNTCORECAPS                    DDCORECAPS;
typedef PDDNTCORECAPS                   LPDDCORECAPS;
typedef DD_HALINFO                      DDHALINFO;
typedef PDD_HALINFO                     LPDDHALINFO;
typedef DD_MORECAPS                     DDMORECAPS;
typedef PDD_MORECAPS                    LPDDMORECAPS;

// DirectDraw HAL function data structures

typedef PDD_CREATEPALETTEDATA           LPDDHAL_CREATEPALETTEDATA;
typedef PDD_CREATESURFACEDATA           LPDDHAL_CREATESURFACEDATA;
typedef PDD_CREATESURFACEEXDATA         LPDDHAL_CREATESURFACEEXDATA;
typedef PDD_CANCREATESURFACEDATA        LPDDHAL_CANCREATESURFACEDATA;
typedef PDD_WAITFORVERTICALBLANKDATA    LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef PDD_DESTROYDRIVERDATA           LPDDHAL_DESTROYDRIVERDATA;
typedef PDD_SETMODEDATA                 LPDDHAL_SETMODEDATA;
typedef PDD_DRVSETCOLORKEYDATA          LPDDHAL_DRVSETCOLORKEYDATA;
typedef PDD_GETSCANLINEDATA             LPDDHAL_GETSCANLINEDATA;
typedef PDD_MAPMEMORYDATA               LPDDHAL_MAPMEMORYDATA;
typedef PDD_SETEXCLUSIVEMODEDATA        LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef PDD_FLIPTOGDISURFACEDATA        LPDDHAL_FLIPTOGDISURFACEDATA;
typedef PDD_UPDATENONLOCALHEAPDATA      LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef PDD_GETHEAPALIGNMENTDATA        LPDDHAL_GETHEAPALIGNMENTDATA;
typedef DD_CREATEPALETTEDATA            DDHAL_CREATEPALETTEDATA;
typedef DD_CREATESURFACEDATA            DDHAL_CREATESURFACEDATA;
typedef DD_CREATESURFACEEXDATA          DDHAL_CREATESURFACEEXDATA;
typedef DD_CANCREATESURFACEDATA         DDHAL_CANCREATESURFACEDATA;
typedef DD_WAITFORVERTICALBLANKDATA     DDHAL_WAITFORVERTICALBLANKDATA;
typedef DD_DRVSETCOLORKEYDATA           DDHAL_DRVSETCOLORKEYDATA;
typedef DD_GETSCANLINEDATA              DDHAL_GETSCANLINEDATA;
typedef DD_MAPMEMORYDATA                DDHAL_MAPMEMORYDATA;
typedef DD_SETEXCLUSIVEMODEDATA         DDHAL_SETEXCLUSIVEMODEDATA;
typedef DD_FLIPTOGDISURFACEDATA         DDHAL_FLIPTOGDISURFACEDATA;
typedef DD_UPDATENONLOCALHEAPDATA       DDHAL_UPDATENONLOCALHEAPDATA;

typedef PDD_DESTROYPALETTEDATA          LPDDHAL_DESTROYPALETTEDATA;
typedef PDD_SETENTRIESDATA              LPDDHAL_SETENTRIESDATA;
typedef DD_DESTROYPALETTEDATA           DDHAL_DESTROYPALETTEDATA;
typedef DD_SETENTRIESDATA               DDHAL_SETENTRIESDATA;

typedef PDD_BLTDATA                     LPDDHAL_BLTDATA;
typedef PDD_LOCKDATA                    LPDDHAL_LOCKDATA;
typedef PDD_UNLOCKDATA                  LPDDHAL_UNLOCKDATA;
typedef PDD_UPDATEOVERLAYDATA           LPDDHAL_UPDATEOVERLAYDATA;
typedef PDD_SETOVERLAYPOSITIONDATA      LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef PDD_SETPALETTEDATA              LPDDHAL_SETPALETTEDATA;
typedef PDD_FLIPDATA                    LPDDHAL_FLIPDATA;
typedef PDD_DESTROYSURFACEDATA          LPDDHAL_DESTROYSURFACEDATA;
typedef PDD_SETCLIPLISTDATA             LPDDHAL_SETCLIPLISTDATA;
typedef PDD_ADDATTACHEDSURFACEDATA      LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef PDD_SETCOLORKEYDATA             LPDDHAL_SETCOLORKEYDATA;
typedef PDD_GETBLTSTATUSDATA            LPDDHAL_GETBLTSTATUSDATA;
typedef PDD_GETFLIPSTATUSDATA           LPDDHAL_GETFLIPSTATUSDATA;
typedef PDD_GETAVAILDRIVERMEMORYDATA    LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_GETDRIVERSTATEDATA          LPDDHAL_GETDRIVERSTATEDATA;
typedef PDD_DESTROYDDLOCALDATA          LPDDHAL_DESTROYDDLOCALDATA;
typedef DD_BLTDATA                      DDHAL_BLTDATA;
typedef DD_LOCKDATA                     DDHAL_LOCKDATA;
typedef DD_UNLOCKDATA                   DDHAL_UNLOCKDATA;
typedef DD_UPDATEOVERLAYDATA            DDHAL_UPDATEOVERLAYDATA;
typedef DD_SETOVERLAYPOSITIONDATA       DDHAL_SETOVERLAYPOSITIONDATA;
typedef DD_SETPALETTEDATA               DDHAL_SETPALETTEDATA;
typedef DD_FLIPDATA                     DDHAL_FLIPDATA;
typedef DD_DESTROYSURFACEDATA           DDHAL_DESTROYSURFACEDATA;
typedef DD_SETCLIPLISTDATA              DDHAL_SETCLIPLISTDATA;
typedef DD_ADDATTACHEDSURFACEDATA       DDHAL_ADDATTACHEDSURFACEDATA;
typedef DD_SETCOLORKEYDATA              DDHAL_SETCOLORKEYDATA;
typedef DD_GETBLTSTATUSDATA             DDHAL_GETBLTSTATUSDATA;
typedef DD_GETFLIPSTATUSDATA            DDHAL_GETFLIPSTATUSDATA;
typedef DD_GETAVAILDRIVERMEMORYDATA     DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DD_GETDRIVERINFODATA            DDHAL_GETDRIVERINFODATA;
typedef DD_GETDRIVERSTATEDATA           DDHAL_GETDRIVERSTATEDATA;
typedef DD_DESTROYDDLOCALDATA           DDHAL_DESTROYDDLOCALDATA;

typedef PDD_CANCREATEVPORTDATA          LPDDHAL_CANCREATEVPORTDATA;
typedef PDD_CREATEVPORTDATA             LPDDHAL_CREATEVPORTDATA;
typedef PDD_FLIPVPORTDATA               LPDDHAL_FLIPVPORTDATA;
typedef PDD_GETVPORTCONNECTDATA         LPDDHAL_GETVPORTCONNECTDATA;
typedef PDD_GETVPORTBANDWIDTHDATA       LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef PDD_GETVPORTINPUTFORMATDATA     LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef PDD_GETVPORTOUTPUTFORMATDATA    LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef PDD_GETVPORTFIELDDATA           LPDDHAL_GETVPORTFIELDDATA;
typedef PDD_GETVPORTLINEDATA            LPDDHAL_GETVPORTLINEDATA;
typedef PDD_DESTROYVPORTDATA            LPDDHAL_DESTROYVPORTDATA;
typedef PDD_GETVPORTFLIPSTATUSDATA      LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef PDD_UPDATEVPORTDATA             LPDDHAL_UPDATEVPORTDATA;
typedef PDD_WAITFORVPORTSYNCDATA        LPDDHAL_WAITFORVPORTSYNCDATA;
typedef PDD_GETVPORTSIGNALDATA          LPDDHAL_GETVPORTSIGNALDATA;
typedef PDD_VPORTCOLORDATA              LPDDHAL_VPORTCOLORDATA;
typedef DD_CANCREATEVPORTDATA           DDHAL_CANCREATEVPORTDATA;
typedef DD_CREATEVPORTDATA              DDHAL_CREATEVPORTDATA;
typedef DD_FLIPVPORTDATA                DDHAL_FLIPVPORTDATA;
typedef DD_GETVPORTCONNECTDATA          DDHAL_GETVPORTCONNECTDATA;
typedef DD_GETVPORTBANDWIDTHDATA        DDHAL_GETVPORTBANDWIDTHDATA;
typedef DD_GETVPORTINPUTFORMATDATA      DDHAL_GETVPORTINPUTFORMATDATA;
typedef DD_GETVPORTOUTPUTFORMATDATA     DDHAL_GETVPORTOUTPUTFORMATDATA;
typedef DD_GETVPORTFIELDDATA            DDHAL_GETVPORTFIELDDATA;
typedef DD_GETVPORTLINEDATA             DDHAL_GETVPORTLINEDATA;
typedef DD_DESTROYVPORTDATA             DDHAL_DESTROYVPORTDATA;
typedef DD_GETVPORTFLIPSTATUSDATA       DDHAL_GETVPORTFLIPSTATUSDATA;
typedef DD_UPDATEVPORTDATA              DDHAL_UPDATEVPORTDATA;
typedef DD_WAITFORVPORTSYNCDATA         DDHAL_WAITFORVPORTSYNCDATA;
typedef DD_GETVPORTSIGNALDATA           DDHAL_GETVPORTSIGNALDATA;
typedef DD_VPORTCOLORDATA               DDHAL_VPORTCOLORDATA;

typedef PDD_COLORCONTROLDATA            LPDDHAL_COLORCONTROLDATA;
typedef DD_COLORCONTROLDATA             DDHAL_COLORCONTROLDATA;

typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef DD_SYNCSURFACEDATA              DDHAL_SYNCSURFACEDATA;
typedef DD_SYNCVIDEOPORTDATA            DDHAL_SYNCVIDEOPORTDATA;

typedef PDD_GETMOCOMPGUIDSDATA          LPDDHAL_GETMOCOMPGUIDSDATA;
typedef PDD_GETMOCOMPFORMATSDATA        LPDDHAL_GETMOCOMPFORMATSDATA;
typedef PDD_CREATEMOCOMPDATA            LPDDHAL_CREATEMOCOMPDATA;
typedef PDD_GETMOCOMPCOMPBUFFDATA       LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef PDD_GETINTERNALMOCOMPDATA       LPDDHAL_GETINTERNALMOCOMPDATA;
typedef PDD_BEGINMOCOMPFRAMEDATA        LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef PDD_ENDMOCOMPFRAMEDATA          LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef PDD_RENDERMOCOMPDATA            LPDDHAL_RENDERMOCOMPDATA;
typedef PDD_QUERYMOCOMPSTATUSDATA       LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef PDD_DESTROYMOCOMPDATA           LPDDHAL_DESTROYMOCOMPDATA;
typedef DD_GETMOCOMPGUIDSDATA           DDHAL_GETMOCOMPGUIDSDATA;
typedef DD_GETMOCOMPFORMATSDATA         DDHAL_GETMOCOMPFORMATSDATA;
typedef DD_CREATEMOCOMPDATA             DDHAL_CREATEMOCOMPDATA;
typedef DD_GETMOCOMPCOMPBUFFDATA        DDHAL_GETMOCOMPCOMPBUFFDATA;
typedef DD_GETINTERNALMOCOMPDATA        DDHAL_GETINTERNALMOCOMPDATA;
typedef DD_BEGINMOCOMPFRAMEDATA         DDHAL_BEGINMOCOMPFRAMEDATA;
typedef DD_ENDMOCOMPFRAMEDATA           DDHAL_ENDMOCOMPFRAMEDATA;
typedef DD_RENDERMOCOMPDATA             DDHAL_RENDERMOCOMPDATA;
typedef DD_QUERYMOCOMPSTATUSDATA        DDHAL_QUERYMOCOMPSTATUSDATA;
typedef DD_DESTROYMOCOMPDATA            DDHAL_DESTROYMOCOMPDATA;

// DirectDraw HAL call backs

typedef PDD_SETCOLORKEY                 LPDDHAL_SETCOLORKEY;
typedef PDD_CANCREATESURFACE            LPDDHAL_CANCREATESURFACE;
typedef PDD_WAITFORVERTICALBLANK        LPDDHAL_WAITFORVERTICALBLANK;
typedef PDD_CREATESURFACE               LPDDHAL_CREATESURFACE;
typedef PDD_DESTROYDRIVER               LPDDHAL_DESTROYDRIVER;
typedef PDD_SETMODE                     LPDDHAL_SETMODE;
typedef PDD_CREATEPALETTE               LPDDHAL_CREATEPALETTE;
typedef PDD_GETSCANLINE                 LPDDHAL_GETSCANLINE;
typedef PDD_MAPMEMORY                   LPDDHAL_MAPMEMORY;
typedef PDD_GETAVAILDRIVERMEMORY        LPDDHAL_GETAVAILDRIVERMEMORY;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef PDD_SETEXCLUSIVEMODE            LPDDHAL_SETEXCLUSIVEMODE;
typedef PDD_FLIPTOGDISURFACE            LPDDHAL_FLIPTOGDISURFACE;

typedef PDD_ALPHABLT                    LPDDHAL_ALPHABLT;
typedef PDD_CREATESURFACEEX             LPDDHAL_CREATESURFACEEX;
typedef PDD_GETDRIVERSTATE              LPDDHAL_GETDRIVERSTATE;

typedef PDD_PALCB_DESTROYPALETTE        LPDDHALPALCB_DESTROYPALETTE;
typedef PDD_PALCB_SETENTRIES            LPDDHALPALCB_SETENTRIES;

typedef PDD_SURFCB_LOCK                 LPDDHALSURFCB_LOCK;
typedef PDD_SURFCB_UNLOCK               LPDDHALSURFCB_UNLOCK;
typedef PDD_SURFCB_BLT                  LPDDHALSURFCB_BLT;
typedef PDD_SURFCB_UPDATEOVERLAY        LPDDHALSURFCB_UPDATEOVERLAY;
typedef PDD_SURFCB_SETOVERLAYPOSITION   LPDDHALSURFCB_SETOVERLAYPOSITION;
typedef PDD_SURFCB_SETPALETTE           LPDDHALSURFCB_SETPALETTE;
typedef PDD_SURFCB_FLIP                 LPDDHALSURFCB_FLIP;
typedef PDD_SURFCB_DESTROYSURFACE       LPDDHALSURFCB_DESTROYSURFACE;
typedef PDD_SURFCB_SETCLIPLIST          LPDDHALSURFCB_SETCLIPLIST;
typedef PDD_SURFCB_ADDATTACHEDSURFACE   LPDDHALSURFCB_ADDATTACHEDSURFACE;
typedef PDD_SURFCB_SETCOLORKEY          LPDDHALSURFCB_SETCOLORKEY;
typedef PDD_SURFCB_GETBLTSTATUS         LPDDHALSURFCB_GETBLTSTATUS;
typedef PDD_SURFCB_GETFLIPSTATUS        LPDDHALSURFCB_GETFLIPSTATUS;

typedef PDD_VPORTCB_CANCREATEVIDEOPORT  LPDDHALVPORTCB_CANCREATEVIDEOPORT;
typedef PDD_VPORTCB_CREATEVIDEOPORT     LPDDHALVPORTCB_CREATEVIDEOPORT;
typedef PDD_VPORTCB_FLIP                LPDDHALVPORTCB_FLIP;
typedef PDD_VPORTCB_GETBANDWIDTH        LPDDHALVPORTCB_GETBANDWIDTH;
typedef PDD_VPORTCB_GETINPUTFORMATS     LPDDHALVPORTCB_GETINPUTFORMATS;
typedef PDD_VPORTCB_GETOUTPUTFORMATS    LPDDHALVPORTCB_GETOUTPUTFORMATS;
typedef PDD_VPORTCB_GETFIELD            LPDDHALVPORTCB_GETFIELD;
typedef PDD_VPORTCB_GETLINE             LPDDHALVPORTCB_GETLINE;
typedef PDD_VPORTCB_GETVPORTCONNECT     LPDDHALVPORTCB_GETVPORTCONNECT;
typedef PDD_VPORTCB_DESTROYVPORT        LPDDHALVPORTCB_DESTROYVPORT;
typedef PDD_VPORTCB_GETFLIPSTATUS       LPDDHALVPORTCB_GETFLIPSTATUS;
typedef PDD_VPORTCB_UPDATE              LPDDHALVPORTCB_UPDATE;
typedef PDD_VPORTCB_WAITFORSYNC         LPDDHALVPORTCB_WAITFORSYNC;
typedef PDD_VPORTCB_GETSIGNALSTATUS     LPDDHALVPORTCB_GETSIGNALSTATUS;
typedef PDD_VPORTCB_COLORCONTROL        LPDDHALVPORTCB_COLORCONTROL;

typedef PDD_MOCOMPCB_GETGUIDS           LPDDHALMOCOMPCB_GETGUIDS;
typedef PDD_MOCOMPCB_GETFORMATS         LPDDHALMOCOMPCB_GETFORMATS;
typedef PDD_MOCOMPCB_CREATE             LPDDHALMOCOMPCB_CREATE;
typedef PDD_MOCOMPCB_GETCOMPBUFFINFO    LPDDHALMOCOMPCB_GETCOMPBUFFINFO;
typedef PDD_MOCOMPCB_GETINTERNALINFO    LPDDHALMOCOMPCB_GETINTERNALINFO;
typedef PDD_MOCOMPCB_BEGINFRAME         LPDDHALMOCOMPCB_BEGINFRAME;
typedef PDD_MOCOMPCB_ENDFRAME           LPDDHALMOCOMPCB_ENDFRAME;
typedef PDD_MOCOMPCB_RENDER             LPDDHALMOCOMPCB_RENDER;
typedef PDD_MOCOMPCB_QUERYSTATUS        LPDDHALMOCOMPCB_QUERYSTATUS;
typedef PDD_MOCOMPCB_DESTROY            LPDDHALMOCOMPCB_DESTROY;

typedef DD_CALLBACKS                    DDHAL_DDCALLBACKS;
typedef DD_PALETTECALLBACKS             DDHAL_DDPALETTECALLBACKS;
typedef DD_SURFACECALLBACKS             DDHAL_DDSURFACECALLBACKS;
typedef DD_VIDEOPORTCALLBACKS           DDHAL_DDVIDEOPORTCALLBACKS;
typedef DD_COLORCONTROLCALLBACKS        DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DD_KERNELCALLBACKS              DDHAL_DDKERNELCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS          DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DD_MISCELLANEOUS2CALLBACKS      DDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef DD_D3DBUFCALLBACKS              DDHAL_D3DBUFCALLBACKS;
typedef DD_NTCALLBACKS                  DDHAL_DDNTCALLBACKS;

typedef PDD_CALLBACKS                   LPDDHAL_DDCALLBACKS;
typedef PDD_PALETTECALLBACKS            LPDDHAL_DDPALETTECALLBACKS;
typedef PDD_SURFACECALLBACKS            LPDDHAL_DDSURFACECALLBACKS;
typedef PDD_VIDEOPORTCALLBACKS          LPDDHAL_DDVIDEOPORTCALLBACKS;
typedef PDD_COLORCONTROLCALLBACKS       LPDDHAL_DDCOLORCONTROLCALLBACKS;
typedef PDD_KERNELCALLBACKS             LPDDHAL_DDKERNELCALLBACKS;
typedef PDD_MOTIONCOMPCALLBACKS         LPDDHAL_DDMOTIONCOMPCALLBACKS;
typedef PDD_MISCELLANEOUS2CALLBACKS     LPDDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef PDD_D3DBUFCALLBACKS             LPDDHAL_D3DBUFCALLBACKS;
typedef PDD_NTCALLBACKS                 LPDDHAL_DDNTCALLBACKS;

// bit definition for dwFlags in dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

typedef D3DNTHAL_CALLBACKS              D3DHAL_CALLBACKS;
typedef D3DNTHAL_GLOBALDRIVERDATA       D3DHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA      D3DHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA     D3DHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA  D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_SCENECAPTUREDATA       D3DHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_TEXTURECREATEDATA      D3DHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA     D3DHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTURESWAPDATA        D3DHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA     D3DHAL_TEXTUREGETSURFDATA;

typedef D3DNTHAL_CALLBACKS2             D3DHAL_CALLBACKS2;
typedef D3DNTHAL_SETRENDERTARGETDATA    D3DHAL_SETRENDERTARGETDATA;

typedef D3DNTHAL_CALLBACKS3             D3DHAL_CALLBACKS3;
typedef D3DNTHAL_CLEAR2DATA             D3DHAL_CLEAR2DATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA   D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA    D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_D3DEXTENDEDCAPS        D3DHAL_D3DEXTENDEDCAPS;

typedef LPD3DNTHAL_CALLBACKS            LPD3DHAL_CALLBACKS;
typedef LPD3DNTHAL_GLOBALDRIVERDATA     LPD3DHAL_GLOBALDRIVERDATA;
typedef LPD3DNTHAL_CONTEXTCREATEDATA    LPD3DHAL_CONTEXTCREATEDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYDATA   LPD3DHAL_CONTEXTDESTROYDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYALLDATA LPD3DHAL_CONTEXTDESTROYALLDATA;
typedef LPD3DNTHAL_SCENECAPTUREDATA     LPD3DHAL_SCENECAPTUREDATA;
typedef LPD3DNTHAL_TEXTURECREATEDATA    LPD3DHAL_TEXTURECREATEDATA;
typedef LPD3DNTHAL_TEXTUREDESTROYDATA   LPD3DHAL_TEXTUREDESTROYDATA;
typedef LPD3DNTHAL_TEXTURESWAPDATA      LPD3DHAL_TEXTURESWAPDATA;
typedef LPD3DNTHAL_TEXTUREGETSURFDATA   LPD3DHAL_TEXTUREGETSURFDATA;

typedef LPD3DNTHAL_CALLBACKS2           LPD3DHAL_CALLBACKS2;
typedef LPD3DNTHAL_SETRENDERTARGETDATA  LPD3DHAL_SETRENDERTARGETDATA;

typedef LPD3DNTHAL_CALLBACKS3           LPD3DHAL_CALLBACKS3;
typedef LPD3DNTHAL_CLEAR2DATA           LPD3DHAL_CLEAR2DATA;
typedef LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef LPD3DNTHAL_DRAWPRIMITIVES2DATA  LPD3DHAL_DRAWPRIMITIVES2DATA;
typedef LPD3DNTHAL_D3DEXTENDEDCAPS      LPD3DHAL_D3DEXTENDEDCAPS;

#define D3DHAL2_CB32_SETRENDERTARGET          D3DNTHAL2_CB32_SETRENDERTARGET

#define D3DHAL_CONTEXT_BAD              D3DNTHAL_CONTEXT_BAD
#define D3DHAL_OUTOFCONTEXTS            D3DNTHAL_OUTOFCONTEXTS
#define D3DHALSTATE_GET_RENDER          D3DNTHALSTATE_GET_RENDER
#define D3DHAL_SCENE_CAPTURE_START      D3DNTHAL_SCENE_CAPTURE_START
#define D3DHAL_SCENE_CAPTURE_END        D3DNTHAL_SCENE_CAPTURE_END

#define D3DHAL3_CB32_CLEAR2                   D3DNTHAL3_CB32_CLEAR2
#define D3DHAL3_CB32_RESERVED                 D3DNTHAL3_CB32_RESERVED
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE
#define D3DHAL3_CB32_DRAWPRIMITIVES2          D3DNTHAL3_CB32_DRAWPRIMITIVES2

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------
typedef D3DNTHAL_DP2COMMAND D3DHAL_DP2COMMAND;
typedef LPDNT3DHAL_DP2COMMAND LPD3DHAL_DP2COMMAND;
typedef D3DNTHAL_DP2OPERATION D3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS D3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST D3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST D3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP D3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP D3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST D3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST D3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 D3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP D3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP D3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN D3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN D3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE D3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM D3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX D3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO D3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO D3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE      D3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE   D3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE          D3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL     D3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT        D3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE    D3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT     D3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM    D3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT             D3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT          D3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET        D3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY     D3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET D3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR           D3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD       D3DHAL_DP2SETTEXLOD;

#define D3DDP2OP_POINTS               D3DNTDP2OP_POINTS
#define D3DDP2OP_INDEXEDLINELIST      D3DNTDP2OP_INDEXEDLINELIST
#define D3DDP2OP_INDEXEDLINELIST2     D3DNTDP2OP_INDEXEDLINELIST2
#define D3DDP2OP_INDEXEDTRIANGLELIST  D3DNTDP2OP_INDEXEDTRIANGLELIST
#define D3DDP2OP_INDEXEDTRIANGLELIST2 D3DNTDP2OP_INDEXEDTRIANGLELIST2
#define D3DDP2OP_RENDERSTATE          D3DNTDP2OP_RENDERSTATE
#define D3DDP2OP_LINELIST             D3DNTDP2OP_LINELIST
#define D3DDP2OP_LINESTRIP            D3DNTDP2OP_LINESTRIP
#define D3DDP2OP_INDEXEDLINESTRIP     D3DNTDP2OP_INDEXEDLINESTRIP
#define D3DDP2OP_TRIANGLELIST         D3DNTDP2OP_TRIANGLELIST
#define D3DDP2OP_TRIANGLESTRIP        D3DNTDP2OP_TRIANGLESTRIP
#define D3DDP2OP_INDEXEDTRIANGLESTRIP D3DNTDP2OP_INDEXEDTRIANGLESTRIP
#define D3DDP2OP_TRIANGLEFAN          D3DNTDP2OP_TRIANGLEFAN
#define D3DDP2OP_INDEXEDTRIANGLEFAN   D3DNTDP2OP_INDEXEDTRIANGLEFAN
#define D3DDP2OP_TRIANGLEFAN_IMM      D3DNTDP2OP_TRIANGLEFAN_IMM
#define D3DDP2OP_LINELIST_IMM         D3DNTDP2OP_LINELIST_IMM
#define D3DDP2OP_TEXTURESTAGESTATE    D3DNTDP2OP_TEXTURESTAGESTATE
#define D3DDP2OP_VIEWPORTINFO         D3DNTDP2OP_VIEWPORTINFO
#define D3DDP2OP_WINFO                D3DNTDP2OP_WINFO
#define D3DDP2OP_SETPALETTE           D3DNTDP2OP_SETPALETTE
#define D3DDP2OP_UPDATEPALETTE        D3DNTDP2OP_UPDATEPALETTE

#define D3DDP2OP_ZRANGE               D3DNTDP2OP_ZRANGE
#define D3DDP2OP_SETMATERIAL          D3DNTDP2OP_SETMATERIAL
#define D3DDP2OP_SETLIGHT             D3DNTDP2OP_SETLIGHT
#define D3DDP2OP_CREATELIGHT          D3DNTDP2OP_CREATELIGHT
#define D3DDP2OP_SETTRANSFORM         D3DNTDP2OP_SETTRANSFORM
#define D3DDP2OP_TEXBLT               D3DNTDP2OP_TEXBLT
#define D3DDP2OP_STATESET             D3DNTDP2OP_STATESET
#define D3DDP2OP_SETPRIORITY          D3DNTDP2OP_SETPRIORITY
#define D3DDP2OP_SETRENDERTARGET      D3DNTDP2OP_SETRENDERTARGET
#define D3DDP2OP_CLEAR                D3DNTDP2OP_CLEAR
#define D3DDP2OP_SETTEXLOD            D3DNTDP2OP_SETTEXLOD
#define D3DDP2OP_SETCLIPPLANE         D3DNTDP2OP_SETCLIPPLANE

#define D3DERR_COMMAND_UNPARSED       D3DNTERR_COMMAND_UNPARSED
#define D3DHALDP2_USERMEMVERTICES     D3DNTHALDP2_USERMEMVERTICES
#define D3DHALDP2_EXECUTEBUFFER       D3DNTHALDP2_EXECUTEBUFFER
#define D3DHALDP2_SWAPVERTEXBUFFER    D3DNTHALDP2_SWAPVERTEXBUFFER
#define D3DHALDP2_SWAPCOMMANDBUFFER   D3DNTHALDP2_SWAPCOMMANDBUFFER
#define D3DHALDP2_REQVERTEXBUFSIZE    D3DNTHALDP2_REQVERTEXBUFSIZE
#define D3DHALDP2_REQCOMMANDBUFSIZE   D3DNTHALDP2_REQCOMMANDBUFSIZE
#define D3DHALDP2_VIDMEMVERTEXBUF     D3DNTHALDP2_VIDMEMVERTEXBUF
#define D3DHALDP2_VIDMEMCOMMANDBUF    D3DNTHALDP2_VIDMEMCOMMANDBUF


#define PFND3DPARSEUNKNOWNCOMMAND     PFND3DNTPARSEUNKNOWNCOMMAND

#if(DIRECT3D_VERSION >= 0x0800 )
#define D3DDP2OP_CREATEVERTEXSHADER    D3DNTDP2OP_CREATEVERTEXSHADER
#define D3DDP2OP_DELETEVERTEXSHADER    D3DNTDP2OP_DELETEVERTEXSHADER
#define D3DDP2OP_SETVERTEXSHADER       D3DNTDP2OP_SETVERTEXSHADER
#define D3DDP2OP_SETVERTEXSHADERCONST  D3DNTDP2OP_SETVERTEXSHADERCONST
#define D3DDP2OP_SETSTREAMSOURCE       D3DNTDP2OP_SETSTREAMSOURCE
#define D3DDP2OP_SETSTREAMSOURCEUM     D3DNTDP2OP_SETSTREAMSOURCEUM
#define D3DDP2OP_SETINDICES            D3DNTDP2OP_SETINDICES
#define D3DDP2OP_DRAWPRIMITIVE         D3DNTDP2OP_DRAWPRIMITIVE
#define D3DDP2OP_DRAWINDEXEDPRIMITIVE  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE
#define D3DDP2OP_CREATEPIXELSHADER     D3DNTDP2OP_CREATEPIXELSHADER
#define D3DDP2OP_DELETEPIXELSHADER     D3DNTDP2OP_DELETEPIXELSHADER
#define D3DDP2OP_SETPIXELSHADER        D3DNTDP2OP_SETPIXELSHADER
#define D3DDP2OP_SETPIXELSHADERCONST   D3DNTDP2OP_SETPIXELSHADERCONST
#define D3DDP2OP_CLIPPEDTRIANGLEFAN    D3DNTDP2OP_CLIPPEDTRIANGLEFAN
#define D3DDP2OP_DRAWPRIMITIVE2        D3DNTDP2OP_DRAWPRIMITIVE2
#define D3DDP2OP_DRAWINDEXEDPRIMITIVE2 D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
#define D3DDP2OP_DRAWRECTPATCH         D3DNTDP2OP_DRAWRECTPATCH
#define D3DDP2OP_DRAWTRIPATCH          D3DNTDP2OP_DRAWTRIPATCH
#define D3DDP2OP_VOLUMEBLT             D3DNTDP2OP_VOLUMEBLT
#define D3DDP2OP_BUFFERBLT             D3DNTDP2OP_BUFFERBLT
#define D3DDP2OP_MULTIPLYTRANSFORM     D3DNTDP2OP_MULTIPLYTRANSFORM
#define D3DDP2OP_ADDDIRTYRECT          D3DNTDP2OP_ADDDIRTYRECT         
#define D3DDP2OP_ADDDIRTYBOX           D3DNTDP2OP_ADDDIRTYBOX          

#if(DIRECT3D_VERSION >= 0x0900 )
#define D3DDP2OP_CREATEVERTEXSHADERDECL D3DNTDP2OP_CREATEVERTEXSHADERDECL
#define D3DDP2OP_DELETEVERTEXSHADERDECL D3DNTDP2OP_DELETEVERTEXSHADERDECL
#define D3DDP2OP_SETVERTEXSHADERDECL    D3DNTDP2OP_SETVERTEXSHADERDECL
#define D3DDP2OP_CREATEVERTEXSHADERFUNC D3DNTDP2OP_CREATEVERTEXSHADERFUNC
#define D3DDP2OP_DELETEVERTEXSHADERFUNC D3DNTDP2OP_DELETEVERTEXSHADERFUNC
#define D3DDP2OP_SETVERTEXSHADERFUNC    D3DNTDP2OP_SETVERTEXSHADERFUNC
#define D3DDP2OP_SETVERTEXSHADERCONSTI  D3DNTDP2OP_SETVERTEXSHADERCONSTI
#define D3DDP2OP_SETSCISSORRECT         D3DNTDP2OP_SETSCISSORRECT
#define D3DDP2OP_SETSTREAMSOURCE2       D3DNTDP2OP_SETSTREAMSOURCE2
#define D3DDP2OP_BLT                    D3DNTDP2OP_BLT
#define D3DDP2OP_COLORFILL              D3DNTDP2OP_COLORFILL
#define D3DDP2OP_SETVERTEXSHADERCONSTB  D3DNTDP2OP_SETVERTEXSHADERCONSTB
#define D3DDP2OP_CREATEQUERY            D3DNTDP2OP_CREATEQUERY
#define D3DDP2OP_DELETEQUERY            D3DNTDP2OP_DELETEQUERY
#define D3DDP2OP_ISSUEQUERY             D3DNTDP2OP_ISSUEQUERY
#define D3DDP2OP_SETRENDERTARGET2       D3DNTDP2OP_SETRENDERTARGET2
#define D3DDP2OP_SETDEPTHSTENCIL        D3DNTDP2OP_SETDEPTHSTENCIL
#define D3DDP2OP_RESPONSECONTINUE       D3DNTDP2OP_RESPONSECONTINUE
#define D3DDP2OP_RESPONSEQUERY          D3DNTDP2OP_RESPONSEQUERY
#define D3DDP2OP_GENERATEMIPSUBLEVELS   D3DNTDP2OP_GENERATEMIPSUBLEVELS
#define D3DDP2OP_SETPIXELSHADERCONSTI   D3DNTDP2OP_SETPIXELSHADERCONSTI
#define D3DDP2OP_SETPIXELSHADERCONSTB   D3DNTDP2OP_SETPIXELSHADERCONSTB
#define D3DDP2OP_SETSTREAMSOURCEFREQ    D3DNTDP2OP_SETSTREAMSOURCEFREQ
#define D3DDP2OP_SURFACEBLT             D3DNTDP2OP_SURFACEBLT
#endif // (DIRECT3D_VERSION >= 0x0900 )


#define D3DHAL_STATESETCREATE    D3DNTHAL_STATESETCREATE    
#define D3DCLEAR_COMPUTERECTS    D3DNTCLEAR_COMPUTERECTS  
   
typedef D3DNTHAL_DP2MULTIPLYTRANSFORM   D3DHAL_DP2MULTIPLYTRANSFORM;
typedef LPD3DNTHAL_DP2MULTIPLYTRANSFORM LPD3DHAL_DP2MULTIPLYTRANSFORM;
typedef D3DNTHAL_DP2VERTEXSHADER        D3DHAL_DP2VERTEXSHADER ;
typedef LPD3DNTHAL_DP2VERTEXSHADER      LPD3DHAL_DP2VERTEXSHADER;

typedef  D3DNTHAL_DP2CREATEVERTEXSHADER      D3DHAL_DP2CREATEVERTEXSHADER;
typedef  LPD3DNTHAL_DP2CREATEVERTEXSHADER    LPD3DHAL_DP2CREATEVERTEXSHADER;
typedef  D3DNTHAL_DP2SETVERTEXSHADERCONST    D3DHAL_DP2SETVERTEXSHADERCONST;
typedef  LPD3DNTHAL_DP2SETVERTEXSHADERCONST  LPD3DHAL_DP2SETVERTEXSHADERCONST;
typedef  D3DNTHAL_DP2SETSTREAMSOURCE         D3DHAL_DP2SETSTREAMSOURCE;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCE       LPD3DHAL_DP2SETSTREAMSOURCE;
typedef  D3DNTHAL_DP2SETSTREAMSOURCEUM       D3DHAL_DP2SETSTREAMSOURCEUM;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCEUM     LPD3DHAL_DP2SETSTREAMSOURCEUM;
typedef  D3DNTHAL_DP2SETINDICES              D3DHAL_DP2SETINDICES;
typedef  LPD3DNTHAL_DP2SETINDICES            LPD3DHAL_DP2SETINDICES;
typedef  D3DNTHAL_DP2DRAWPRIMITIVE           D3DHAL_DP2DRAWPRIMITIVE;
typedef  LPD3DNTHAL_DP2DRAWPRIMITIVE         LPD3DHAL_DP2DRAWPRIMITIVE;
typedef  D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE    D3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef  LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE  LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef  D3DNTHAL_CLIPPEDTRIANGLEFAN         D3DHAL_CLIPPEDTRIANGLEFAN;
typedef  LPD3DNTHAL_CLIPPEDTRIANGLEFAN       LPD3DHAL_CLIPPEDTRIANGLEFAN;
typedef  D3DNTHAL_DP2DRAWPRIMITIVE2          D3DHAL_DP2DRAWPRIMITIVE2;
typedef  LPD3DNTHAL_DP2DRAWPRIMITIVE2        LPD3DHAL_DP2DRAWPRIMITIVE2;
typedef  D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2   D3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef  LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2 LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef  D3DNTHAL_DP2PIXELSHADER             D3DHAL_DP2PIXELSHADER;
typedef  LPD3DNTHAL_DP2PIXELSHADER           LPD3DHAL_DP2PIXELSHADER;
typedef  D3DNTHAL_DP2CREATEPIXELSHADER       D3DHAL_DP2CREATEPIXELSHADER;
typedef  LPD3DNTHAL_DP2CREATEPIXELSHADER     LPD3DHAL_DP2CREATEPIXELSHADER;
typedef  D3DNTHAL_DP2SETPIXELSHADERCONST     D3DHAL_DP2SETPIXELSHADERCONST;
typedef  LPD3DNTHAL_DP2SETPIXELSHADERCONST   LPD3DHAL_DP2SETPIXELSHADERCONST;

#define RTPATCHFLAG_HASSEGS  _NT_RTPATCHFLAG_HASSEGS  
#define RTPATCHFLAG_HASINFO  _NT_RTPATCHFLAG_HASINFO  

typedef  D3DNTHAL_DP2DRAWRECTPATCH   D3DHAL_DP2DRAWRECTPATCH;
typedef  LPD3DNTHAL_DP2DRAWRECTPATCH LPD3DHAL_DP2DRAWRECTPATCH;
typedef  D3DNTHAL_DP2DRAWTRIPATCH    D3DHAL_DP2DRAWTRIPATCH;
typedef  LPD3DNTHAL_DP2DRAWTRIPATCH  LPD3DHAL_DP2DRAWTRIPATCH;
typedef  D3DNTHAL_DP2VOLUMEBLT       D3DHAL_DP2VOLUMEBLT;
typedef  LPD3DNTHAL_DP2VOLUMEBLT     LPD3DHAL_DP2VOLUMEBLT;
typedef  D3DNTHAL_DP2BUFFERBLT       D3DHAL_DP2BUFFERBLT;
typedef  LPD3DNTHAL_DP2BUFFERBLT     LPD3DHAL_DP2BUFFERBLT;
typedef  D3DNTHAL_DP2ADDDIRTYRECT    D3DHAL_DP2ADDDIRTYRECT;
typedef  LPD3DNTHAL_DP2ADDDIRTYRECT  LPD3DHAL_DP2ADDDIRTYRECT;
typedef  D3DNTHAL_DP2ADDDIRTYBOX     D3DHAL_DP2ADDDIRTYBOX;
typedef  LPD3DNTHAL_DP2ADDDIRTYBOX   LPD3DHAL_DP2ADDDIRTYBOX;

#if(DIRECT3D_VERSION >= 0x0900 )
typedef  D3DNTHAL_DP2CREATEVERTEXSHADERDECL     D3DHAL_DP2CREATEVERTEXSHADERDECL;
typedef  LPD3DNTHAL_DP2CREATEVERTEXSHADERDECL   LPD3DHAL_DP2CREATEVERTEXSHADERDECL;
typedef  D3DNTHAL_DP2CREATEVERTEXSHADERFUNC     D3DHAL_DP2CREATEVERTEXSHADERFUNC;
typedef  LPD3DNTHAL_DP2CREATEVERTEXSHADERFUNC   LPD3DHAL_DP2CREATEVERTEXSHADERFUNC;
typedef  D3DNTHAL_DP2SETSTREAMSOURCE2           D3DHAL_DP2SETSTREAMSOURCE2;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCE2         LPD3DHAL_DP2SETSTREAMSOURCE2;
typedef  D3DNTHAL_DP2SETSCISSORRECT             D3DHAL_DP2SETSCISSORRECT;
typedef  LPD3DNTHAL_DP2SETSCISSORRECT           LPD3DHAL_DP2SETSCISSORRECT;
typedef  D3DNTHAL_DP2BLT                        D3DHAL_DP2BLT;
typedef  LPD3DNTHAL_DP2BLT                      LPD3DHAL_DP2BLT;
typedef  D3DNTHAL_DP2COLORFILL                  D3DHAL_DP2COLORFILL;
typedef  LPD3DNTHAL_DP2COLORFILL                LPD3DHAL_DP2COLORFILL;
typedef  D3DNTHAL_DP2SETVERTEXSHADERCONSTB      D3DHAL_DP2SETVERTEXSHADERCONSTB;
typedef  LPD3DNTHAL_DP2SETVERTEXSHADERCONSTB    LPD3DHAL_DP2SETVERTEXSHADERCONSTB;
typedef  D3DNTHAL_DP2SETRENDERTARGET2           D3DHAL_DP2SETRENDERTARGET2;
typedef  LPD3DNTHAL_DP2SETRENDERTARGET2         LPD3DHAL_DP2SETRENDERTARGET2;
typedef  D3DNTHAL_DP2SETDEPTHSTENCIL            D3DHAL_DP2SETDEPTHSTENCIL;
typedef  LPD3DNTHAL_DP2SETDEPTHSTENCIL          LPD3DHAL_DP2SETDEPTHSTENCIL;
typedef  D3DNTHAL_DP2CREATEQUERY                D3DHAL_DP2CREATEQUERY;
typedef  LPD3DNTHAL_DP2CREATEQUERY              LPD3DHAL_DP2CREATEQUERY;
typedef  D3DNTHAL_DP2DELETEQUERY                D3DHAL_DP2DELETEQUERY;
typedef  LPD3DNTHAL_DP2DELETEQUERY              LPD3DHAL_DP2DELETEQUERY;
typedef  D3DNTHAL_DP2ISSUEQUERY                 D3DHAL_DP2ISSUEQUERY;
typedef  LPD3DNTHAL_DP2ISSUEQUERY               LPD3DHAL_DP2ISSUEQUERY;
typedef  D3DNTHAL_DP2GENERATEMIPSUBLEVELS       D3DHAL_DP2GENERATEMIPSUBLEVELS;
typedef  LPD3DNTHAL_DP2GENERATEMIPSUBLEVELS     LPD3DHAL_DP2GENERATEMIPSUBLEVELS;
typedef  D3DNTHAL_DP2RESPONSE                   D3DHAL_DP2RESPONSE;
typedef  LPD3DNTHAL_DP2RESPONSE                 LPD3DHAL_DP2RESPONSE;  
typedef  D3DNTHAL_DP2RESPONSEQUERY              D3DHAL_DP2RESPONSEQUERY;
typedef  LPD3DNTHAL_DP2RESPONSEQUERY            LPD3DHAL_DP2RESPONSEQUERY;  
typedef  D3DNTHAL_DP2SETVERTEXSHADERCONSTI      D3DHAL_DP2SETVERTEXSHADERCONSTI;
typedef  LPD3DNTHAL_DP2SETVERTEXSHADERCONSTI    LPD3DHAL_DP2SETVERTEXSHADERCONSTI;
typedef  D3DNTHAL_DP2SETPIXELSHADERCONSTI       D3DHAL_DP2SETPIXELSHADERCONSTI;
typedef  LPD3DNTHAL_DP2SETPIXELSHADERCONSTI     LPD3DHAL_DP2SETPIXELSHADERCONSTI;
typedef  D3DNTHAL_DP2SETPIXELSHADERCONSTB       D3DHAL_DP2SETPIXELSHADERCONSTB;
typedef  LPD3DNTHAL_DP2SETPIXELSHADERCONSTB     LPD3DHAL_DP2SETPIXELSHADERCONSTB;
typedef  D3DNTHAL_DP2SETSTREAMSOURCEFREQ        D3DHAL_DP2SETSTREAMSOURCEFREQ;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCEFREQ      LPD3DHAL_DP2SETSTREAMSOURCEFREQ;
typedef  D3DNTHAL_DP2SURFACEBLT                 D3DHAL_DP2SURFACEBLT;
typedef  LPD3DNTHAL_DP2SURFACEBLT               LPD3DHAL_DP2SURFACEBLT;
typedef  _NT_D3DLINEPATTERN                     D3DLINEPATTERN;
#endif // (DIRECT3D_VERSION >= 0x0900 )

#define D3DSI_GETREGTYPE      _NT_D3DSI_GETREGTYPE
#if(DIRECT3D_VERSION >= 0x0900 )
#define D3DSI_GETUSAGE        _NT_D3DSI_GETUSAGE      
#define D3DSI_GETUSAGEINDEX   _NT_D3DSI_GETUSAGEINDEX 
#define D3DSI_GETINSTLENGTH   _NT_D3DSI_GETINSTLENGTH 
#endif // (DIRECT3D_VERSION >= 0x0900 )
#define D3DSI_GETREGNUM       _NT_D3DSI_GETREGNUM
#define D3DSI_GETOPCODE       _NT_D3DSI_GETOPCODE
#define D3DSI_GETWRITEMASK    _NT_D3DSI_GETWRITEMASK
#define D3DVS_GETSWIZZLECOMP  _NT_D3DVS_GETSWIZZLECOMP
#define D3DVS_GETSWIZZLE      _NT_D3DVS_GETSWIZZLE
#define D3DVS_GETSRCMODIFIER  _NT_D3DVS_GETSRCMODIFIER
#define D3DVS_GETADDRESSMODE  _NT_D3DVS_GETADDRESSMODE

#define D3DRS_DELETERTPATCH       _NT_D3DRS_DELETERTPATCH       

typedef DDNT_GETDRIVERINFO2DATA   DD_GETDRIVERINFO2DATA;

#if(DIRECT3D_VERSION >= 0x0900)
typedef DDNT_GETD3DQUERYCOUNTDATA DD_GETD3DQUERYCOUNTDATA;
typedef DDNT_GETD3DQUERYDATA      DD_GETD3DQUERYDATA;
typedef DDNT_GETDDIVERSIONDATA    DD_GETDDIVERSIONDATA;
#endif // (DIRECT3D_VERSION >= 0x0900)

#define GUID_GetDriverInfo2 _NT_GUID_GetDriverInfo2 
#define D3DGDI2_MAGIC       _NT_D3DGDI2_MAGIC       

#define D3DGDI2_TYPE_GETD3DCAPS8          _NT_D3DGDI2_TYPE_GETD3DCAPS8
#define D3DGDI2_TYPE_GETFORMATCOUNT       _NT_D3DGDI2_TYPE_GETFORMATCOUNT
#define D3DGDI2_TYPE_GETFORMAT            _NT_D3DGDI2_TYPE_GETFORMAT
#define D3DGDI2_TYPE_DXVERSION            _NT_D3DGDI2_TYPE_DXVERSION
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE   _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP    _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP
#define D3DGDI2_TYPE_DEFER_AGP_FREES      _NT_D3DGDI2_TYPE_DEFER_AGP_FREES
#if(DIRECT3D_VERSION >= 0x0900)
#define D3DGDI2_TYPE_GETD3DCAPS9                    _NT_D3DGDI2_TYPE_GETD3DCAPS9
#define D3DGDI2_TYPE_GETEXTENDEDMODECOUNT           _NT_D3DGDI2_TYPE_GETEXTENDEDMODECOUNT
#define D3DGDI2_TYPE_GETEXTENDEDMODE                _NT_D3DGDI2_TYPE_GETEXTENDEDMODE
#define D3DGDI2_TYPE_GETADAPTERGROUP                _NT_D3DGDI2_TYPE_GETADAPTERGROUP
#define D3DGDI2_TYPE_GETMULTISAMPLEQUALITYLEVELS    _NT_D3DGDI2_TYPE_GETMULTISAMPLEQUALITYLEVELS
#define D3DGDI2_TYPE_GETD3DQUERYCOUNT               _NT_D3DGDI2_TYPE_GETD3DQUERYCOUNT     
#define D3DGDI2_TYPE_GETD3DQUERY                    _NT_D3DGDI2_TYPE_GETD3DQUERY
#define D3DGDI2_TYPE_GETDDIVERSION                  _NT_D3DGDI2_TYPE_GETDDIVERSION

#endif // (DIRECT3D_VERSION >= 0x0900)

typedef DDNT_GETFORMATCOUNTDATA       DD_GETFORMATCOUNTDATA;
typedef DDNT_GETFORMATDATA            DD_GETFORMATDATA;
typedef DDNT_DXVERSION                DD_DXVERSION;
typedef DDNT_DEFERRED_AGP_AWARE_DATA  DD_DEFERRED_AGP_AWARE_DATA;
typedef DDNT_FREE_DEFERRED_AGP_DATA   DD_FREE_DEFERRED_AGP_DATA;
#if(DIRECT3D_VERSION >= 0x0900)
typedef DDNT_GETEXTENDEDMODECOUNTDATA     DD_GETEXTENDEDMODECOUNTDATA;
typedef DDNT_GETEXTENDEDMODEDATA          DD_GETEXTENDEDMODEDATA;
typedef DDNT_GETADAPTERGROUPDATA          DD_GETADAPTERGROUPDATA;
typedef DDNT_MULTISAMPLEQUALITYLEVELSDATA DD_MULTISAMPLEQUALITYLEVELSDATA;
#endif // (DIRECT3D_VERSION >= 0x0900)

#define D3DDEVCAPS_HWVERTEXBUFFER       _NT_D3DDEVCAPS_HWVERTEXBUFFER       
#define D3DDEVCAPS_HWINDEXBUFFER        _NT_D3DDEVCAPS_HWINDEXBUFFER        
#define D3DDEVCAPS_SUBVOLUMELOCK        _NT_D3DDEVCAPS_SUBVOLUMELOCK

#define D3DPMISCCAPS_FOGINFVF           _NT_D3DPMISCCAPS_FOGINFVF
#define D3DFVF_FOG                      _NT_D3DFVF_FOG

#define D3DFMT_D32     _NT_D3DFMT_D32    
#define D3DFMT_S1D15   _NT_D3DFMT_S1D15  
#define D3DFMT_D15S1   _NT_D3DFMT_D15S1  
#define D3DFMT_S8D24   _NT_D3DFMT_S8D24  
#define D3DFMT_D24S8   _NT_D3DFMT_D24S8  
#define D3DFMT_X8D24   _NT_D3DFMT_X8D24  
#define D3DFMT_D24X8   _NT_D3DFMT_D24X8 
#define D3DFMT_X4S4D24 _NT_D3DFMT_X4S4D24 
#define D3DFMT_D24X4S4 _NT_D3DFMT_D24X4S4 

#define D3DVS_INPUTREG_MAX_V1_1         _NT_D3DVS_INPUTREG_MAX_V1_1         
#define D3DVS_TEMPREG_MAX_V1_1          _NT_D3DVS_TEMPREG_MAX_V1_1          
#define D3DVS_CONSTREG_MAX_V1_1         _NT_D3DVS_CONSTREG_MAX_V1_1         
#define D3DVS_TCRDOUTREG_MAX_V1_1       _NT_D3DVS_TCRDOUTREG_MAX_V1_1       
#define D3DVS_ADDRREG_MAX_V1_1          _NT_D3DVS_ADDRREG_MAX_V1_1          
#define D3DVS_ATTROUTREG_MAX_V1_1       _NT_D3DVS_ATTROUTREG_MAX_V1_1       
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_1  _NT_D3DVS_MAXINSTRUCTIONCOUNT_V1_1  

#define D3DPS_INPUTREG_MAX_DX8         _NT_D3DPS_INPUTREG_MAX_DX8         
#define D3DPS_TEMPREG_MAX_DX8          _NT_D3DPS_TEMPREG_MAX_DX8          
#define D3DPS_CONSTREG_MAX_DX8         _NT_D3DPS_CONSTREG_MAX_DX8         
#define D3DPS_TEXTUREREG_MAX_DX8       _NT_D3DPS_TEXTUREREG_MAX_DX8       

#endif // (DIRECT3D_VERSION >= 0x0800 )

#ifdef DX8DDK_DX7HAL_DEFINES 

// Some legacy (<=DX7) definitions that are in d3dhal.h

#define D3DHAL_TSS_MAXSTAGES           D3DNTHAL_TSS_MAXSTAGES
typedef PDD_DIRECTDRAW_LOCAL           LPDDRAWI_DIRECTDRAW_LCL;

typedef D3DNTHAL_DP2OPERATION            *LPD3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS               *LPD3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST             *LPD3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST      *LPD3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP            *LPD3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP     *LPD3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST         *LPD3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST  *LPD3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 *LPD3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP        *LPD3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP *LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN          *LPD3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN   *LPD3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE          *LPD3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE    *LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM      *LPD3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX          *LPD3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO         *LPD3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO                *LPD3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE           *LPD3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE        *LPD3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE               *LPD3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL          *LPD3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT             *LPD3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE         *LPD3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT          *LPD3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM         *LPD3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT                  *LPD3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT               *LPD3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET             *LPD3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY          *LPD3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET      *LPD3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR                *LPD3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD            *LPD3DHAL_DP2SETTEXLOD;

// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

#define D3DHAL_NUMCLIPVERTICES  20

#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)33) 

/*
 * If DX8 driver wants to support pre-DX8 applications, it should use these
 * definitions for pre-DX8 world matrices
*/
#define D3DTRANSFORMSTATE_WORLD_DX7  1
#define D3DTRANSFORMSTATE_WORLD1_DX7 4
#define D3DTRANSFORMSTATE_WORLD2_DX7 5
#define D3DTRANSFORMSTATE_WORLD3_DX7 6

/*
 * Generally needed maximum state structure sizes.  Note that the copy of
 * these in refrasti.hpp must be kept in sync with these.
 */

#define D3DHAL_MAX_RSTATES (D3DRENDERSTATE_WRAPBIAS + 128)
/* Last state offset for combined render state and texture stage array + 1 */
#define D3DHAL_MAX_RSTATES_AND_STAGES \
    (D3DHAL_TSS_RENDERSTATEBASE + \
     D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)
/* Last texture state ID */
#define D3DHAL_MAX_TEXTURESTATES (13)
/* Last texture state ID + 1 */
#define D3DHAL_TEXTURESTATEBUF_SIZE (D3DHAL_MAX_TEXTURESTATES+1)

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM   ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM    ((32 * 1024) / sizeof (D3DHVERTEX))

typedef D3DDEVICEDESC_V1 *LPD3DDEVICEDESC_V1;
#define D3DDEVICEDESCSIZE_V1 (sizeof(D3DDEVICEDESC_V1))

#define D3DHAL_GLOBALDRIVERDATASIZE (sizeof(D3DHAL_GLOBALDRIVERDATA))

#define D3DHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DEXTENDEDCAPS))

#endif // DX8DDK_DX7HAL_DEFINES 
 


#endif // WINNT
#endif // NODX95TYPES

#endif // __DX95TYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dvdmedia.h ===
//------------------------------------------------------------------------------
// File: DVDMedia.h
//
// Desc: Contains typedefs and defines necessary for user mode (ring 3) DVD
//       filters and applications.
//
//       This should be included in the DirectShow SDK for user mode filters.
//       The types defined here should be kept in synch with ksmedia.h WDM
//       DDK for kernel mode filters.
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DVDMEDIA_H__
#define __DVDMEDIA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// -----------------------------------------------------------------------
// AC-3 definition for the AM_KSPROPSETID_AC3 property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1,
    AM_PROPERTY_AC3_ALTERNATE_AUDIO = 2,
    AM_PROPERTY_AC3_DOWNMIX = 3,
    AM_PROPERTY_AC3_BIT_STREAM_MODE = 4,
    AM_PROPERTY_AC3_DIALOGUE_LEVEL = 5,
    AM_PROPERTY_AC3_LANGUAGE_CODE = 6,
    AM_PROPERTY_AC3_ROOM_TYPE = 7
} AM_PROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} AM_AC3_ERROR_CONCEALMENT, *PAM_AC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} AM_AC3_ALTERNATE_AUDIO, *PAM_AC3_ALTERNATE_AUDIO;

#define AM_AC3_ALTERNATE_AUDIO_1     1
#define AM_AC3_ALTERNATE_AUDIO_2     2
#define AM_AC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} AM_AC3_DOWNMIX, *PAM_AC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} AM_AC3_BIT_STREAM_MODE, *PAM_AC3_BIT_STREAM_MODE;

#define AM_AC3_SERVICE_MAIN_AUDIO            0
#define AM_AC3_SERVICE_NO_DIALOG             1
#define AM_AC3_SERVICE_VISUALLY_IMPAIRED     2
#define AM_AC3_SERVICE_HEARING_IMPAIRED      3
#define AM_AC3_SERVICE_DIALOG_ONLY           4
#define AM_AC3_SERVICE_COMMENTARY            5
#define AM_AC3_SERVICE_EMERGENCY_FLASH       6
#define AM_AC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} AM_AC3_DIALOGUE_LEVEL, *PAM_AC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} AM_AC3_ROOM_TYPE, *PAM_AC3_ROOM_TYPE;


// -----------------------------------------------------------------------
// subpicture definition for the AM_KSPROPSETID_DvdSubPic property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_DVDSUBPIC_PALETTE = 0,
    AM_PROPERTY_DVDSUBPIC_HLI = 1,
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 2  // TRUE for subpicture is displayed
} AM_PROPERTY_DVDSUBPIC;

typedef struct _AM_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   U;
    UCHAR   V;
} AM_DVD_YUV, *PAM_DVD_YUV;

typedef struct _AM_PROPERTY_SPPAL {
    AM_DVD_YUV sppal[16];
} AM_PROPERTY_SPPAL, *PAM_PROPERTY_SPPAL;

typedef struct _AM_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} AM_COLCON, *PAM_COLCON;

typedef struct _AM_PROPERTY_SPHLI {
    USHORT     HLISS;      //
    USHORT     Reserved;
    ULONG      StartPTM;   // start presentation time in x/90000
    ULONG      EndPTM;     // end PTM in x/90000
    USHORT     StartX;
    USHORT     StartY;
    USHORT     StopX;
    USHORT     StopY;
    AM_COLCON  ColCon;     // color contrast description (4 bytes as given in HLI)
} AM_PROPERTY_SPHLI, *PAM_PROPERTY_SPHLI;

typedef BOOL AM_PROPERTY_COMPOSIT_ON, *PAM_PROPERTY_COMPOSIT_ON;



// -----------------------------------------------------------------------
// copy protection definitions
// -----------------------------------------------------------------------

// AM_UseNewCSSKey for the dwTypeSpecificFlags in IMediaSample2 to indicate
// the exact point in a stream after which to start applying a new CSS key.
// This is typically sent on an empty media sample just before attempting
// to renegotiate a CSS key.
#define AM_UseNewCSSKey       0x1

#define AM_ReverseBlockStart  0x2
#define AM_ReverseBlockEnd    0x4


//
// AM_KSPROPSETID_CopyProt property set definitions
//
typedef enum {
    AM_PROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    AM_PROPERTY_DVDCOPY_DVD_KEY1 = 0x02,
    AM_PROPERTY_DVDCOPY_DEC_KEY2 = 0x03,
    AM_PROPERTY_DVDCOPY_TITLE_KEY = 0x04,
    AM_PROPERTY_COPY_MACROVISION = 0x05,
    AM_PROPERTY_DVDCOPY_REGION = 0x06,
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE = 0x07,
    AM_PROPERTY_COPY_ANALOG_COMPONENT = 0x08, // GetOnly property, return data is a BOOL
    AM_PROPERTY_DVDCOPY_DISC_KEY = 0x80
} AM_PROPERTY_DVDCOPYPROT;

typedef struct _AM_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} AM_DVDCOPY_CHLGKEY, *PAM_DVDCOPY_CHLGKEY;

typedef struct _AM_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} AM_DVDCOPY_BUSKEY, *PAM_DVDCOPY_BUSKEY;

typedef struct _AM_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} AM_DVDCOPY_DISCKEY, *PAM_DVDCOPY_DISCKEY;

typedef struct AM_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG Reserved1[2];
    UCHAR TitleKey[6];
    UCHAR Reserved2[2];
} AM_DVDCOPY_TITLEKEY, *PAM_DVDCOPY_TITLEKEY;

typedef struct _AM_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} AM_COPY_MACROVISION, *PAM_COPY_MACROVISION;

typedef struct AM_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} AM_DVDCOPY_SET_COPY_STATE, *PAM_DVDCOPY_SET_COPY_STATE;

typedef enum {
    AM_DVDCOPYSTATE_INITIALIZE = 0,
    AM_DVDCOPYSTATE_INITIALIZE_TITLE = 1,   // indicates we are starting a title
                                        // key copy protection sequence
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 2,
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = 3,
    AM_DVDCOPYSTATE_DONE = 4
} AM_DVDCOPYSTATE;

typedef enum {
    AM_MACROVISION_DISABLED = 0,
    AM_MACROVISION_LEVEL1 = 1,
    AM_MACROVISION_LEVEL2 = 2,
    AM_MACROVISION_LEVEL3 = 3
} AM_COPY_MACROVISION_LEVEL, *PAM_COPY_MACROVISION_LEVEL;


// CSS region stucture
typedef struct _DVD_REGION {
    UCHAR CopySystem;
    UCHAR RegionData;
    UCHAR SystemRegion;
    UCHAR Reserved;
} DVD_REGION, *PDVD_REGION;

//
// CGMS Copy Protection Flags
//

#define AM_DVD_CGMS_RESERVED_MASK      0x00000078

#define AM_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define AM_DVD_CGMS_COPY_PERMITTED     0x00000000
#define AM_DVD_CGMS_COPY_ONCE          0x00000010
#define AM_DVD_CGMS_NO_COPY            0x00000018

#define AM_DVD_COPYRIGHT_MASK          0x00000040
#define AM_DVD_NOT_COPYRIGHTED         0x00000000
#define AM_DVD_COPYRIGHTED             0x00000040

#define AM_DVD_SECTOR_PROTECT_MASK     0x00000020
#define AM_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define AM_DVD_SECTOR_PROTECTED        0x00000020


// -----------------------------------------------------------------------
// video format blocks
// -----------------------------------------------------------------------

enum AM_MPEG2Level {
    AM_MPEG2Level_Low = 1,
    AM_MPEG2Level_Main = 2,
    AM_MPEG2Level_High1440 = 3,
    AM_MPEG2Level_High = 4
};

enum AM_MPEG2Profile {
    AM_MPEG2Profile_Simple = 1,
    AM_MPEG2Profile_Main = 2,
    AM_MPEG2Profile_SNRScalable = 3,
    AM_MPEG2Profile_SpatiallyScalable = 4,
    AM_MPEG2Profile_High = 5
};

#define AMINTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define AMINTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define AMINTERLACE_UNUSED                  0x00000008  //
#define AMINTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define AMINTERLACE_FieldPatField1Only      0x00000000  // stream never contains a Field2
#define AMINTERLACE_FieldPatField2Only      0x00000010  // stream never contains a Field1
#define AMINTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define AMINTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define AMINTERLACE_DisplayModeMask         0x000000c0
#define AMINTERLACE_DisplayModeBobOnly      0x00000000
#define AMINTERLACE_DisplayModeWeaveOnly    0x00000040
#define AMINTERLACE_DisplayModeBobOrWeave   0x00000080

#define AMCOPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define AMMPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                        //  based on pan-scan vectors in picture_display_extension
                        //  and change the picture aspect ratio accordingly.
#define AMMPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                        //  pin for DVD style closed caption data found in GOP layer of field 1
#define AMMPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                        //  pin for DVD style closed caption data found in GOP layer of field 2
#define AMMPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                        //  and bottom of the video.
#define AMMPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                        //  indicates that "camera mode" was used.
#define AMMPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define AMMPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define AMMPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define AMMPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

#define AMMPEG2_WidescreenAnalogOut 0x00000200  //if set and this stream is sent to an analog output, it should
                        //  be in widescreen format (4x3 content should be centered on a 16x9 output).
                        //  Streams sent to VGA should be widescreened only by renderers.

// PRESENT in dwReserved1 field in VIDEOINFOHEADER2
#define AMCONTROL_USED              0x00000001 // Used to test if these flags are supported.  Set and test for AcceptMediaType.
                                                // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1)
#define AMCONTROL_PAD_TO_4x3        0x00000002 // if set means display the image in a 4x3 area
#define AMCONTROL_PAD_TO_16x9       0x00000004 // if set means display the image in a 16x9 area
#define AMCONTROL_COLORINFO_PRESENT 0x00000080 // if set, indicates DXVA color info is present in the upper (24) bits of the dwControlFlags

typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD dwControlFlags;               // use AMCONTROL_* defines, use this from now on
        DWORD dwReserved1;                  // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    };
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;

typedef struct tagMPEG2VIDEOINFO {
    VIDEOINFOHEADER2    hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwSequenceHeader[1];    // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} MPEG2VIDEOINFO;

#define SIZE_MPEG2VIDEOINFO(pv) (FIELD_OFFSET(MPEG2VIDEOINFO, dwSequenceHeader[0]) + (pv)->cbSequenceHeader)

// do not use
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

// use this macro instead, the previous only works for MPEG1VIDEOINFO structures
#define MPEG2_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->dwSequenceHeader)


//===================================================================================
// flags for dwTypeSpecificFlags in AM_SAMPLE2_PROPERTIES which define type specific
// data in IMediaSample2
//===================================================================================

#define AM_VIDEO_FLAG_FIELD_MASK        0x0003L // use this mask to check whether the sample is field1 or field2 or frame
#define AM_VIDEO_FLAG_INTERLEAVED_FRAME 0x0000L // the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1            0x0001L // the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD2            0x0002L // the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1FIRST       0x0004L // if set means display field1 first, else display field2 first.
                                                // this bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_WEAVE             0x0008L // if set use bob display mode else weave
#define AM_VIDEO_FLAG_IPB_MASK          0x0030L // use this mask to check whether the sample is I, P or B
#define AM_VIDEO_FLAG_I_SAMPLE          0x0000L // I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_P_SAMPLE          0x0010L // P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_B_SAMPLE          0x0020L // B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_REPEAT_FIELD      0x0040L // if set means display the field which has been displayed first again after displaying
                                                // both fields first. This bit is irrelavant for 1FieldPerSample mode

// -----------------------------------------------------------------------
// AM_KSPROPSETID_DvdKaraoke property set definitions
// -----------------------------------------------------------------------

typedef struct tagAM_DvdKaraokeData
{
    DWORD   dwDownmix;              // bitwise OR of AM_DvdKaraoke_Downmix flags
    DWORD   dwSpeakerAssignment;    // AM_DvdKaraoke_SpeakerAssignment
} AM_DvdKaraokeData;

typedef enum {
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0,  // BOOL
    AM_PROPERTY_DVDKARAOKE_DATA = 1,
} AM_PROPERTY_DVDKARAOKE;

// -----------------------------------------------------------------------
// AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------

typedef enum {
    AM_RATE_SimpleRateChange = 1,    // rw, use AM_SimpleRateChange
    AM_RATE_ExactRateChange  = 2,    // rw, use AM_ExactRateChange
    AM_RATE_MaxFullDataRate  = 3,    // r,  use AM_MaxFullDataRate
    AM_RATE_Step             = 4,    // w,  use AM_Step
    AM_RATE_UseRateVersion   = 5,       //  w, use WORD
    AM_RATE_QueryFullFrameRate =6,      //  r, use AM_QueryRate
    AM_RATE_QueryLastRateSegPTS =7,     //  r, use REFERENCE_TIME
    AM_RATE_CorrectTS        = 8,    // w,  use LONG
    AM_RATE_ReverseMaxFullDataRate = 9,    // r,  use AM_MaxFullDataRate
    AM_RATE_ResetOnTimeDisc = 10,    // rw, use DWORD - indicates supports new 'timeline reset on time discontinuity' sample
    AM_RATE_QueryMapping    = 11
} AM_PROPERTY_TS_RATE_CHANGE;

// -------------------------------------------------------------------
// AM_KSPROPSETID_DVD_RateChange property set definitions for new DVD
// rate change scheme.
// -------------------------------------------------------------------

typedef enum {
    AM_RATE_ChangeRate       = 1,    // w,  use AM_DVD_ChangeRate
    AM_RATE_FullDataRateMax  = 2,    // r,  use AM_MaxFullDataRate
    AM_RATE_ReverseDecode    = 3,    // r,  use LONG
    AM_RATE_DecoderPosition  = 4,    // r,  use AM_DVD_DecoderPosition
    AM_RATE_DecoderVersion   = 5     // r,  use LONG
} AM_PROPERTY_DVD_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_SimpleRateChange;

typedef struct {
    LONG    lMaxForwardFullFrame ;          //  rate * 10000
    LONG    lMaxReverseFullFrame ;          //  rate * 10000
} AM_QueryRate ;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_ExactRateChange;

typedef LONG AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD AM_Step; // number of frame to step

// New rate change property set, structs. enums etc.
typedef struct {
    REFERENCE_TIME  StartInTime;   // stream time (input) at which to start decoding at this rate
    REFERENCE_TIME  StartOutTime;  // reference time (output) at which to start showing at this rate
    LONG            Rate;          // new rate * 10000 (decimal)
} AM_DVD_ChangeRate ;

typedef LONGLONG  AM_DVD_DecoderPosition ;

typedef enum {
    DVD_DIR_FORWARD  = 0,
    DVD_DIR_BACKWARD = 1
} DVD_PLAY_DIRECTION ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __DVDMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dvp.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawVideoPortNotify,    0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88);



DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer            FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort             FAR *LPDIRECTDRAWVIDEOPORT;
typedef struct IDirectDrawVideoPortNotify       FAR *LPDIRECTDRAWVIDEOPORTNOTIFY;

typedef struct _DDVIDEOPORTCONNECT              FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS                 FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC                 FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO                 FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH            FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS               FAR *LPDDVIDEOPORTSTATUS;
typedef struct _DDVIDEOPORTNOTIFY               FAR *LPDDVIDEOPORTNOTIFY;

typedef struct IDDVideoPortContainerVtbl        DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl         DIRECTDRAWVIDEOPORTCALLBACKS;
typedef struct IDirectDrawVideoPortNotifyVtbl   DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, __inout LPDWORD pcInfo, __out_ecount_part_opt(*pcInfo, *pcInfo) LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD lpNumFormats, __out_ecount_part_opt(*lpNumFormats, *lpNumFormats) LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD lpNumFormats, __out_ecount_part_opt(*lpNumFormats, *lpNumFormats) LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif

/*
 * IDirectDrawVideoPort
 */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPortNotify
DECLARE_INTERFACE_( IDirectDrawVideoPortNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(AcquireNotification)(THIS_ HANDLE *, LPDDVIDEOPORTNOTIFY) PURE;
    STDMETHOD(ReleaseNotification)(THIS_ HANDLE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoPortNotify_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(p,a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(p,a)
#else
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->AddRef()
#define IVideoPortNotify_Release(p)                 (p)->Release()
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(a)
#endif

#endif
#endif

/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTNOTIFY
 */
typedef struct _DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;	// Timestamp in the event notification
    LONG lField;                        // 0 if even, 1 if odd, -1 if unknown
    UINT dwSurfaceIndex;                // Index in the surface chain of the surface that received the sample
    LONG lDone;                         // Call InterlockedIncrement on this when done with sample
} DDVIDEOPORTNOTIFY;


/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxgi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dxgi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxgi_h__
#define __dxgi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXGIObject_FWD_DEFINED__
#define __IDXGIObject_FWD_DEFINED__
typedef interface IDXGIObject IDXGIObject;
#endif 	/* __IDXGIObject_FWD_DEFINED__ */


#ifndef __IDXGIDeviceSubObject_FWD_DEFINED__
#define __IDXGIDeviceSubObject_FWD_DEFINED__
typedef interface IDXGIDeviceSubObject IDXGIDeviceSubObject;
#endif 	/* __IDXGIDeviceSubObject_FWD_DEFINED__ */


#ifndef __IDXGIResource_FWD_DEFINED__
#define __IDXGIResource_FWD_DEFINED__
typedef interface IDXGIResource IDXGIResource;
#endif 	/* __IDXGIResource_FWD_DEFINED__ */


#ifndef __IDXGISurface_FWD_DEFINED__
#define __IDXGISurface_FWD_DEFINED__
typedef interface IDXGISurface IDXGISurface;
#endif 	/* __IDXGISurface_FWD_DEFINED__ */


#ifndef __IDXGIAdapter_FWD_DEFINED__
#define __IDXGIAdapter_FWD_DEFINED__
typedef interface IDXGIAdapter IDXGIAdapter;
#endif 	/* __IDXGIAdapter_FWD_DEFINED__ */


#ifndef __IDXGIOutput_FWD_DEFINED__
#define __IDXGIOutput_FWD_DEFINED__
typedef interface IDXGIOutput IDXGIOutput;
#endif 	/* __IDXGIOutput_FWD_DEFINED__ */


#ifndef __IDXGISwapChain_FWD_DEFINED__
#define __IDXGISwapChain_FWD_DEFINED__
typedef interface IDXGISwapChain IDXGISwapChain;
#endif 	/* __IDXGISwapChain_FWD_DEFINED__ */


#ifndef __IDXGIFactory_FWD_DEFINED__
#define __IDXGIFactory_FWD_DEFINED__
typedef interface IDXGIFactory IDXGIFactory;
#endif 	/* __IDXGIFactory_FWD_DEFINED__ */


#ifndef __IDXGIDevice_FWD_DEFINED__
#define __IDXGIDevice_FWD_DEFINED__
typedef interface IDXGIDevice IDXGIDevice;
#endif 	/* __IDXGIDevice_FWD_DEFINED__ */


/* header files for imported files */
#include "dxgitype.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxgi_0000_0000 */
/* [local] */ 

#define DXGI_CPU_ACCESS_NONE    ( 0 )
#define DXGI_CPU_ACCESS_DYNAMIC    ( 1 )
#define DXGI_CPU_ACCESS_READ_WRITE    ( 2 )
#define DXGI_CPU_ACCESS_SCRATCH    ( 3 )
#define DXGI_CPU_ACCESS_FIELD        15
#define DXGI_USAGE_SHADER_INPUT             ( 1L << (0 + 4) )
#define DXGI_USAGE_RENDER_TARGET_OUTPUT     ( 1L << (1 + 4) )
#define DXGI_USAGE_BACK_BUFFER              ( 1L << (2 + 4) )
#define DXGI_USAGE_SHARED                   ( 1L << (3 + 4) )
#define DXGI_USAGE_READ_ONLY                ( 1L << (4 + 4) )
#define DXGI_USAGE_DISCARD_ON_PRESENT       ( 1L << (5 + 4) )
typedef UINT DXGI_USAGE;

typedef struct DXGI_FRAME_STATISTICS
    {
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
    } 	DXGI_FRAME_STATISTICS;

typedef struct DXGI_MAPPED_RECT
    {
    INT Pitch;
    BYTE *pBits;
    } 	DXGI_MAPPED_RECT;

#ifdef __midl
typedef struct _LUID
    {
    DWORD LowPart;
    LONG HighPart;
    } 	LUID;

typedef struct _LUID *PLUID;

#endif
typedef struct DXGI_ADAPTER_DESC
    {
    WCHAR Description[ 128 ];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    } 	DXGI_ADAPTER_DESC;

#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)
#define HMONITOR_DECLARED
#if 0
typedef HANDLE HMONITOR;

#endif
DECLARE_HANDLE(HMONITOR);
#endif
typedef struct DXGI_OUTPUT_DESC
    {
    WCHAR DeviceName[ 32 ];
    RECT DesktopCoordinates;
    BOOL AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    HMONITOR Monitor;
    } 	DXGI_OUTPUT_DESC;

typedef struct DXGI_SHARED_RESOURCE
    {
    HANDLE Handle;
    } 	DXGI_SHARED_RESOURCE;

#define	DXGI_RESOURCE_PRIORITY_MINIMUM	( 0x28000000 )

#define	DXGI_RESOURCE_PRIORITY_LOW	( 0x50000000 )

#define	DXGI_RESOURCE_PRIORITY_NORMAL	( 0x78000000 )

#define	DXGI_RESOURCE_PRIORITY_HIGH	( 0xa0000000 )

#define	DXGI_RESOURCE_PRIORITY_MAXIMUM	( 0xc8000000 )

typedef 
enum DXGI_RESIDENCY
    {	DXGI_RESIDENCY_FULLY_RESIDENT	= 1,
	DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY	= 2,
	DXGI_RESIDENCY_EVICTED_TO_DISK	= 3
    } 	DXGI_RESIDENCY;

typedef struct DXGI_SURFACE_DESC
    {
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
    } 	DXGI_SURFACE_DESC;

typedef 
enum DXGI_SWAP_EFFECT
    {	DXGI_SWAP_EFFECT_DISCARD	= 0,
	DXGI_SWAP_EFFECT_SEQUENTIAL	= 1
    } 	DXGI_SWAP_EFFECT;

typedef 
enum DXGI_SWAP_CHAIN_FLAG
    {	DXGI_SWAP_CHAIN_FLAG_NONPREROTATED	= 1,
	DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH	= 2
    } 	DXGI_SWAP_CHAIN_FLAG;

typedef struct DXGI_SWAP_CHAIN_DESC
    {
    DXGI_MODE_DESC BufferDesc;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    UINT BufferCount;
    HWND OutputWindow;
    BOOL Windowed;
    DXGI_SWAP_EFFECT SwapEffect;
    UINT Flags;
    } 	DXGI_SWAP_CHAIN_DESC;



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_s_ifspec;

#ifndef __IDXGIObject_INTERFACE_DEFINED__
#define __IDXGIObject_INTERFACE_DEFINED__

/* interface IDXGIObject */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aec22fb8-76f3-4639-9be0-28eb43a67a2e")
    IDXGIObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateDataInterface( 
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        END_INTERFACE
    } IDXGIObjectVtbl;

    interface IDXGIObject
    {
        CONST_VTBL struct IDXGIObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIObject_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIObject_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIObject_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIObject_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIObject_INTERFACE_DEFINED__ */


#ifndef __IDXGIDeviceSubObject_INTERFACE_DEFINED__
#define __IDXGIDeviceSubObject_INTERFACE_DEFINED__

/* interface IDXGIDeviceSubObject */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIDeviceSubObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d3e0379-f9de-4d58-bb6c-18d62992f1a6")
    IDXGIDeviceSubObject : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIDeviceSubObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIDeviceSubObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIDeviceSubObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        END_INTERFACE
    } IDXGIDeviceSubObjectVtbl;

    interface IDXGIDeviceSubObject
    {
        CONST_VTBL struct IDXGIDeviceSubObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIDeviceSubObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIDeviceSubObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIDeviceSubObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIDeviceSubObject_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIDeviceSubObject_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIDeviceSubObject_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIDeviceSubObject_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIDeviceSubObject_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIDeviceSubObject_INTERFACE_DEFINED__ */


#ifndef __IDXGIResource_INTERFACE_DEFINED__
#define __IDXGIResource_INTERFACE_DEFINED__

/* interface IDXGIResource */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("035f3ab4-482e-4e50-b41f-8a7f8bd8960b")
    IDXGIResource : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSharedHandle( 
            /* [out] */ HANDLE *pSharedHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUsage( 
            /* [out] */ DXGI_USAGE *pUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEvictionPriority( 
            /* [in] */ UINT EvictionPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvictionPriority( 
            /* [retval][out] */ UINT *pEvictionPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharedHandle )( 
            IDXGIResource * This,
            /* [out] */ HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetUsage )( 
            IDXGIResource * This,
            /* [out] */ DXGI_USAGE *pUsage);
        
        HRESULT ( STDMETHODCALLTYPE *SetEvictionPriority )( 
            IDXGIResource * This,
            /* [in] */ UINT EvictionPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvictionPriority )( 
            IDXGIResource * This,
            /* [retval][out] */ UINT *pEvictionPriority);
        
        END_INTERFACE
    } IDXGIResourceVtbl;

    interface IDXGIResource
    {
        CONST_VTBL struct IDXGIResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIResource_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIResource_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIResource_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIResource_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIResource_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGIResource_GetSharedHandle(This,pSharedHandle)	\
    ( (This)->lpVtbl -> GetSharedHandle(This,pSharedHandle) ) 

#define IDXGIResource_GetUsage(This,pUsage)	\
    ( (This)->lpVtbl -> GetUsage(This,pUsage) ) 

#define IDXGIResource_SetEvictionPriority(This,EvictionPriority)	\
    ( (This)->lpVtbl -> SetEvictionPriority(This,EvictionPriority) ) 

#define IDXGIResource_GetEvictionPriority(This,pEvictionPriority)	\
    ( (This)->lpVtbl -> GetEvictionPriority(This,pEvictionPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIResource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0003 */
/* [local] */ 

#define	DXGI_MAP_READ	( 1UL )

#define	DXGI_MAP_WRITE	( 2UL )

#define	DXGI_MAP_DISCARD	( 4UL )



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0003_v0_0_s_ifspec;

#ifndef __IDXGISurface_INTERFACE_DEFINED__
#define __IDXGISurface_INTERFACE_DEFINED__

/* interface IDXGISurface */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGISurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cafcb56c-6ac3-4889-bf47-9e23bbd260ec")
    IDXGISurface : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_SURFACE_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Map( 
            /* [out] */ DXGI_MAPPED_RECT *pLockedRect,
            /* [in] */ UINT MapFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unmap( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGISurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGISurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGISurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGISurface * This,
            /* [out] */ DXGI_SURFACE_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *Map )( 
            IDXGISurface * This,
            /* [out] */ DXGI_MAPPED_RECT *pLockedRect,
            /* [in] */ UINT MapFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unmap )( 
            IDXGISurface * This);
        
        END_INTERFACE
    } IDXGISurfaceVtbl;

    interface IDXGISurface
    {
        CONST_VTBL struct IDXGISurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGISurface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGISurface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGISurface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGISurface_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGISurface_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGISurface_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGISurface_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGISurface_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGISurface_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGISurface_Map(This,pLockedRect,MapFlags)	\
    ( (This)->lpVtbl -> Map(This,pLockedRect,MapFlags) ) 

#define IDXGISurface_Unmap(This)	\
    ( (This)->lpVtbl -> Unmap(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGISurface_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0004 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_s_ifspec;

#ifndef __IDXGIAdapter_INTERFACE_DEFINED__
#define __IDXGIAdapter_INTERFACE_DEFINED__

/* interface IDXGIAdapter */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2411e7e1-12ac-4ccf-bd14-9798e8534dc0")
    IDXGIAdapter : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumOutputs( 
            /* [in] */ UINT Output,
            /* [out][in] */ IDXGIOutput **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_ADAPTER_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckInterfaceSupport( 
            /* [in] */ REFGUID InterfaceName,
            /* [out] */ LARGE_INTEGER *pUMDVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIAdapter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIAdapter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIAdapter * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
            IDXGIAdapter * This,
            /* [in] */ UINT Output,
            /* [out][in] */ IDXGIOutput **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGIAdapter * This,
            /* [out] */ DXGI_ADAPTER_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID InterfaceName,
            /* [out] */ LARGE_INTEGER *pUMDVersion);
        
        END_INTERFACE
    } IDXGIAdapterVtbl;

    interface IDXGIAdapter
    {
        CONST_VTBL struct IDXGIAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIAdapter_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIAdapter_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIAdapter_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIAdapter_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIAdapter_EnumOutputs(This,Output,ppOutput)	\
    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 

#define IDXGIAdapter_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGIAdapter_CheckInterfaceSupport(This,InterfaceName,pUMDVersion)	\
    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIAdapter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0005 */
/* [local] */ 

#define	DXGI_ENUM_MODES_INTERLACED	( 1UL )

#define	DXGI_ENUM_MODES_SCALING	( 2UL )



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0005_v0_0_s_ifspec;

#ifndef __IDXGIOutput_INTERFACE_DEFINED__
#define __IDXGIOutput_INTERFACE_DEFINED__

/* interface IDXGIOutput */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae02eedb-c735-4690-8d52-5a8dc20213aa")
    IDXGIOutput : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_OUTPUT_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayModeList( 
            /* [in] */ DXGI_FORMAT EnumFormat,
            /* [in] */ UINT Flags,
            /* [out][in] */ UINT *pNumModes,
            /* [out] */ DXGI_MODE_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestMatchingMode( 
            /* [in] */ const DXGI_MODE_DESC *pModeToMatch,
            /* [out] */ DXGI_MODE_DESC *pClosestMatch,
            /* [in] */ IUnknown *pConcernedDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForVBlank( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TakeOwnership( 
            /* [in] */ IUnknown *pDevice,
            BOOL Exclusive) = 0;
        
        virtual void STDMETHODCALLTYPE ReleaseOwnership( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGammaControlCapabilities( 
            /* [out] */ DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGammaControl( 
            /* [in] */ const DXGI_GAMMA_CONTROL *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGammaControl( 
            /* [out] */ DXGI_GAMMA_CONTROL *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplaySurface( 
            /* [in] */ IDXGISurface *pScanoutSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData( 
            /* [in] */ IDXGISurface *pDestination) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
            /* [out] */ DXGI_FRAME_STATISTICS *pStats) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIOutput * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIOutput * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIOutput * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_OUTPUT_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayModeList )( 
            IDXGIOutput * This,
            /* [in] */ DXGI_FORMAT EnumFormat,
            /* [in] */ UINT Flags,
            /* [out][in] */ UINT *pNumModes,
            /* [out] */ DXGI_MODE_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestMatchingMode )( 
            IDXGIOutput * This,
            /* [in] */ const DXGI_MODE_DESC *pModeToMatch,
            /* [out] */ DXGI_MODE_DESC *pClosestMatch,
            /* [in] */ IUnknown *pConcernedDevice);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForVBlank )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnership )( 
            IDXGIOutput * This,
            /* [in] */ IUnknown *pDevice,
            BOOL Exclusive);
        
        void ( STDMETHODCALLTYPE *ReleaseOwnership )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGammaControlCapabilities )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps);
        
        HRESULT ( STDMETHODCALLTYPE *SetGammaControl )( 
            IDXGIOutput * This,
            /* [in] */ const DXGI_GAMMA_CONTROL *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetGammaControl )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_GAMMA_CONTROL *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplaySurface )( 
            IDXGIOutput * This,
            /* [in] */ IDXGISurface *pScanoutSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplaySurfaceData )( 
            IDXGIOutput * This,
            /* [in] */ IDXGISurface *pDestination);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_FRAME_STATISTICS *pStats);
        
        END_INTERFACE
    } IDXGIOutputVtbl;

    interface IDXGIOutput
    {
        CONST_VTBL struct IDXGIOutputVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIOutput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIOutput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIOutput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIOutput_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIOutput_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIOutput_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIOutput_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIOutput_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGIOutput_GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc)	\
    ( (This)->lpVtbl -> GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc) ) 

#define IDXGIOutput_FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice)	\
    ( (This)->lpVtbl -> FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice) ) 

#define IDXGIOutput_WaitForVBlank(This)	\
    ( (This)->lpVtbl -> WaitForVBlank(This) ) 

#define IDXGIOutput_TakeOwnership(This,pDevice,Exclusive)	\
    ( (This)->lpVtbl -> TakeOwnership(This,pDevice,Exclusive) ) 

#define IDXGIOutput_ReleaseOwnership(This)	\
    ( (This)->lpVtbl -> ReleaseOwnership(This) ) 

#define IDXGIOutput_GetGammaControlCapabilities(This,pGammaCaps)	\
    ( (This)->lpVtbl -> GetGammaControlCapabilities(This,pGammaCaps) ) 

#define IDXGIOutput_SetGammaControl(This,pArray)	\
    ( (This)->lpVtbl -> SetGammaControl(This,pArray) ) 

#define IDXGIOutput_GetGammaControl(This,pArray)	\
    ( (This)->lpVtbl -> GetGammaControl(This,pArray) ) 

#define IDXGIOutput_SetDisplaySurface(This,pScanoutSurface)	\
    ( (This)->lpVtbl -> SetDisplaySurface(This,pScanoutSurface) ) 

#define IDXGIOutput_GetDisplaySurfaceData(This,pDestination)	\
    ( (This)->lpVtbl -> GetDisplaySurfaceData(This,pDestination) ) 

#define IDXGIOutput_GetFrameStatistics(This,pStats)	\
    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIOutput_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0006 */
/* [local] */ 

#define DXGI_MAX_SWAP_CHAIN_BUFFERS        ( 16 )
#define DXGI_PRESENT_TEST               0x00000001UL
#define DXGI_PRESENT_DO_NOT_SEQUENCE    0x00000002UL
#define DXGI_PRESENT_RESTART            0x00000004UL


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_s_ifspec;

#ifndef __IDXGISwapChain_INTERFACE_DEFINED__
#define __IDXGISwapChain_INTERFACE_DEFINED__

/* interface IDXGISwapChain */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGISwapChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a")
    IDXGISwapChain : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Present( 
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ UINT Buffer,
            /* [in] */ REFIID riid,
            /* [out][in] */ void **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFullscreenState( 
            /* [in] */ BOOL Fullscreen,
            /* [in] */ IDXGIOutput *pTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullscreenState( 
            /* [out] */ BOOL *pFullscreen,
            /* [out] */ IDXGIOutput **ppTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_SWAP_CHAIN_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBuffers( 
            /* [in] */ UINT BufferCount,
            /* [in] */ UINT Width,
            /* [in] */ UINT Height,
            /* [in] */ DXGI_FORMAT NewFormat,
            /* [in] */ UINT SwapChainFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeTarget( 
            /* [in] */ const DXGI_MODE_DESC *pNewTargetParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainingOutput( 
            IDXGIOutput **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
            /* [out] */ DXGI_FRAME_STATISTICS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPresentCount( 
            /* [out] */ UINT *pLastPresentCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGISwapChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGISwapChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGISwapChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *Present )( 
            IDXGISwapChain * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IDXGISwapChain * This,
            /* [in] */ UINT Buffer,
            /* [in] */ REFIID riid,
            /* [out][in] */ void **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetFullscreenState )( 
            IDXGISwapChain * This,
            /* [in] */ BOOL Fullscreen,
            /* [in] */ IDXGIOutput *pTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullscreenState )( 
            IDXGISwapChain * This,
            /* [out] */ BOOL *pFullscreen,
            /* [out] */ IDXGIOutput **ppTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGISwapChain * This,
            /* [out] */ DXGI_SWAP_CHAIN_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBuffers )( 
            IDXGISwapChain * This,
            /* [in] */ UINT BufferCount,
            /* [in] */ UINT Width,
            /* [in] */ UINT Height,
            /* [in] */ DXGI_FORMAT NewFormat,
            /* [in] */ UINT SwapChainFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeTarget )( 
            IDXGISwapChain * This,
            /* [in] */ const DXGI_MODE_DESC *pNewTargetParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainingOutput )( 
            IDXGISwapChain * This,
            IDXGIOutput **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
            IDXGISwapChain * This,
            /* [out] */ DXGI_FRAME_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPresentCount )( 
            IDXGISwapChain * This,
            /* [out] */ UINT *pLastPresentCount);
        
        END_INTERFACE
    } IDXGISwapChainVtbl;

    interface IDXGISwapChain
    {
        CONST_VTBL struct IDXGISwapChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGISwapChain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGISwapChain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGISwapChain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGISwapChain_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGISwapChain_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGISwapChain_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGISwapChain_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGISwapChain_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGISwapChain_Present(This,SyncInterval,Flags)	\
    ( (This)->lpVtbl -> Present(This,SyncInterval,Flags) ) 

#define IDXGISwapChain_GetBuffer(This,Buffer,riid,ppSurface)	\
    ( (This)->lpVtbl -> GetBuffer(This,Buffer,riid,ppSurface) ) 

#define IDXGISwapChain_SetFullscreenState(This,Fullscreen,pTarget)	\
    ( (This)->lpVtbl -> SetFullscreenState(This,Fullscreen,pTarget) ) 

#define IDXGISwapChain_GetFullscreenState(This,pFullscreen,ppTarget)	\
    ( (This)->lpVtbl -> GetFullscreenState(This,pFullscreen,ppTarget) ) 

#define IDXGISwapChain_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGISwapChain_ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags)	\
    ( (This)->lpVtbl -> ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags) ) 

#define IDXGISwapChain_ResizeTarget(This,pNewTargetParameters)	\
    ( (This)->lpVtbl -> ResizeTarget(This,pNewTargetParameters) ) 

#define IDXGISwapChain_GetContainingOutput(This,ppOutput)	\
    ( (This)->lpVtbl -> GetContainingOutput(This,ppOutput) ) 

#define IDXGISwapChain_GetFrameStatistics(This,pStats)	\
    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 

#define IDXGISwapChain_GetLastPresentCount(This,pLastPresentCount)	\
    ( (This)->lpVtbl -> GetLastPresentCount(This,pLastPresentCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGISwapChain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0007 */
/* [local] */ 

#define DXGI_MWA_NO_WINDOW_CHANGES      ( 1 << 0 )
#define DXGI_MWA_NO_ALT_ENTER           ( 1 << 1 )
#define DXGI_MWA_NO_PRINT_SCREEN        ( 1 << 2 )
#define DXGI_MWA_VALID                  ( 0x7 )


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_s_ifspec;

#ifndef __IDXGIFactory_INTERFACE_DEFINED__
#define __IDXGIFactory_INTERFACE_DEFINED__

/* interface IDXGIFactory */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b7166ec-21c7-44ae-b21a-c9ae321ae369")
    IDXGIFactory : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumAdapters( 
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter **ppAdapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeWindowAssociation( 
            HWND WindowHandle,
            UINT Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowAssociation( 
            HWND *pWindowHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSwapChain( 
            IUnknown *pDevice,
            DXGI_SWAP_CHAIN_DESC *pDesc,
            IDXGISwapChain **ppSwapChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftwareAdapter( 
            /* [in] */ HMODULE Module,
            /* [out] */ IDXGIAdapter **ppAdapter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIFactory * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
            IDXGIFactory * This,
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
            IDXGIFactory * This,
            HWND WindowHandle,
            UINT Flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
            IDXGIFactory * This,
            HWND *pWindowHandle);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
            IDXGIFactory * This,
            IUnknown *pDevice,
            DXGI_SWAP_CHAIN_DESC *pDesc,
            IDXGISwapChain **ppSwapChain);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
            IDXGIFactory * This,
            /* [in] */ HMODULE Module,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        END_INTERFACE
    } IDXGIFactoryVtbl;

    interface IDXGIFactory
    {
        CONST_VTBL struct IDXGIFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIFactory_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIFactory_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIFactory_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIFactory_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIFactory_EnumAdapters(This,Adapter,ppAdapter)	\
    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 

#define IDXGIFactory_MakeWindowAssociation(This,WindowHandle,Flags)	\
    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 

#define IDXGIFactory_GetWindowAssociation(This,pWindowHandle)	\
    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 

#define IDXGIFactory_CreateSwapChain(This,pDevice,pDesc,ppSwapChain)	\
    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 

#define IDXGIFactory_CreateSoftwareAdapter(This,Module,ppAdapter)	\
    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0008 */
/* [local] */ 

HRESULT WINAPI CreateDXGIFactory(REFIID riid, void **ppFactory);


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_s_ifspec;

#ifndef __IDXGIDevice_INTERFACE_DEFINED__
#define __IDXGIDevice_INTERFACE_DEFINED__

/* interface IDXGIDevice */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54ec77fa-1377-44e6-8c32-88fd5f44c84c")
    IDXGIDevice : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapter( 
            /* [out] */ IDXGIAdapter **pAdapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ const DXGI_SURFACE_DESC *pDesc,
            /* [in] */ UINT NumSurfaces,
            /* [in] */ DXGI_USAGE Usage,
            /* [in] */ const DXGI_SHARED_RESOURCE *pSharedResource,
            /* [out] */ IDXGISurface **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryResourceResidency( 
            /* [size_is][in] */ IUnknown *const *ppResources,
            /* [size_is][out] */ DXGI_RESIDENCY *pResidencyStatus,
            /* [in] */ UINT NumResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGPUThreadPriority( 
            /* [in] */ INT Priority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGPUThreadPriority( 
            /* [retval][out] */ INT *pPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIDevice * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapter )( 
            IDXGIDevice * This,
            /* [out] */ IDXGIAdapter **pAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDXGIDevice * This,
            /* [in] */ const DXGI_SURFACE_DESC *pDesc,
            /* [in] */ UINT NumSurfaces,
            /* [in] */ DXGI_USAGE Usage,
            /* [in] */ const DXGI_SHARED_RESOURCE *pSharedResource,
            /* [out] */ IDXGISurface **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *QueryResourceResidency )( 
            IDXGIDevice * This,
            /* [size_is][in] */ IUnknown *const *ppResources,
            /* [size_is][out] */ DXGI_RESIDENCY *pResidencyStatus,
            /* [in] */ UINT NumResources);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPUThreadPriority )( 
            IDXGIDevice * This,
            /* [in] */ INT Priority);
        
        HRESULT ( STDMETHODCALLTYPE *GetGPUThreadPriority )( 
            IDXGIDevice * This,
            /* [retval][out] */ INT *pPriority);
        
        END_INTERFACE
    } IDXGIDeviceVtbl;

    interface IDXGIDevice
    {
        CONST_VTBL struct IDXGIDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIDevice_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIDevice_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIDevice_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIDevice_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIDevice_GetAdapter(This,pAdapter)	\
    ( (This)->lpVtbl -> GetAdapter(This,pAdapter) ) 

#define IDXGIDevice_CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface)	\
    ( (This)->lpVtbl -> CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) ) 

#define IDXGIDevice_QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources)	\
    ( (This)->lpVtbl -> QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) ) 

#define IDXGIDevice_SetGPUThreadPriority(This,Priority)	\
    ( (This)->lpVtbl -> SetGPUThreadPriority(This,Priority) ) 

#define IDXGIDevice_GetGPUThreadPriority(This,pPriority)	\
    ( (This)->lpVtbl -> GetGPUThreadPriority(This,pPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0009 */
/* [local] */ 

#ifdef __cplusplus
#endif /*__cplusplus*/
DEFINE_GUID(IID_IDXGIObject,0xaec22fb8,0x76f3,0x4639,0x9b,0xe0,0x28,0xeb,0x43,0xa6,0x7a,0x2e);
DEFINE_GUID(IID_IDXGIDeviceSubObject,0x3d3e0379,0xf9de,0x4d58,0xbb,0x6c,0x18,0xd6,0x29,0x92,0xf1,0xa6);
DEFINE_GUID(IID_IDXGIResource,0x035f3ab4,0x482e,0x4e50,0xb4,0x1f,0x8a,0x7f,0x8b,0xd8,0x96,0x0b);
DEFINE_GUID(IID_IDXGISurface,0xcafcb56c,0x6ac3,0x4889,0xbf,0x47,0x9e,0x23,0xbb,0xd2,0x60,0xec);
DEFINE_GUID(IID_IDXGIAdapter,0x2411e7e1,0x12ac,0x4ccf,0xbd,0x14,0x97,0x98,0xe8,0x53,0x4d,0xc0);
DEFINE_GUID(IID_IDXGIOutput,0xae02eedb,0xc735,0x4690,0x8d,0x52,0x5a,0x8d,0xc2,0x02,0x13,0xaa);
DEFINE_GUID(IID_IDXGISwapChain,0x310d36a0,0xd2e7,0x4c0a,0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a);
DEFINE_GUID(IID_IDXGIFactory,0x7b7166ec,0x21c7,0x44ae,0xb2,0x1a,0xc9,0xae,0x32,0x1a,0xe3,0x69);
DEFINE_GUID(IID_IDXGIDevice,0x54ec77fa,0x1377,0x44e6,0x8c,0x32,0x88,0xfd,0x5f,0x44,0xc8,0x4c);


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxva2swdev.h ===
//------------------------------------------------------------------------------
// File: dxva2SWDev.h
//
// Desc: DirectX Video Acceleration 2 header file for software video
// processing devices
//
// Copyright (c) 1999 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __inc_dxva2SWDev_h
#define __inc_dxva2SWDev_h

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _DXVA2_SampleFlags
{
    DXVA2_SampleFlag_Palette_Changed         = 0x00000001,
    DXVA2_SampleFlag_SrcRect_Changed         = 0x00000002,
    DXVA2_SampleFlag_DstRect_Changed         = 0x00000004,
    DXVA2_SampleFlag_ColorData_Changed       = 0x00000008,
    DXVA2_SampleFlag_PlanarAlpha_Changed     = 0x00000010,
    DXVA2_SampleFlag_RFF                     = 0x00010000,
    DXVA2_SampleFlag_TFF                     = 0x00020000,
    DXVA2_SampleFlag_RFF_TFF_Present         = 0x00040000,
    DXVA2_SampleFlagsMask                    = 0xFFFF001F
} DXVA2_SampleFlags;

typedef enum _DXVA2_DestinationFlags
{
    DXVA2_DestinationFlag_Background_Changed = 0x00000001,
    DXVA2_DestinationFlag_TargetRect_Changed = 0x00000002,
    DXVA2_DestinationFlag_ColorData_Changed  = 0x00000004,
    DXVA2_DestinationFlag_Alpha_Changed      = 0x00000008,
    DXVA2_DestinationFlag_RFF                = 0x00010000,
    DXVA2_DestinationFlag_TFF                = 0x00020000,
    DXVA2_DestinationFlag_RFF_TFF_Present    = 0x00040000,
    DXVA2_DestinationFlagMask                = 0xFFFF000F
} DXVA2_DestinationFlags;

typedef struct _DXVA2_VIDEOSAMPLE
{
    REFERENCE_TIME           Start;
    REFERENCE_TIME           End;
    DXVA2_ExtendedFormat     SampleFormat;
    UINT                     SampleFlags;
    VOID*                    SrcResource;
    RECT                     SrcRect;
    RECT                     DstRect;
    DXVA2_AYUVSample8        Pal[16];
    DXVA2_Fixed32            PlanarAlpha;
} DXVA2_VIDEOSAMPLE;

typedef struct _DXVA2_VIDEOPROCESSBLT
{
    REFERENCE_TIME           TargetFrame;
    RECT                     TargetRect;
    SIZE                     ConstrictionSize;
    UINT                     StreamingFlags;
    DXVA2_AYUVSample16       BackgroundColor;
    DXVA2_ExtendedFormat     DestFormat;
    UINT                     DestFlags;
    DXVA2_ProcAmpValues      ProcAmpValues;
    DXVA2_Fixed32            Alpha;
    DXVA2_FilterValues       NoiseFilterLuma;
    DXVA2_FilterValues       NoiseFilterChroma;
    DXVA2_FilterValues       DetailFilterLuma;
    DXVA2_FilterValues       DetailFilterChroma;
    DXVA2_VIDEOSAMPLE*       pSrcSurfaces;
    UINT                     NumSrcSurfaces;
} DXVA2_VIDEOPROCESSBLT;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __out UINT* pCount
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in UINT Count,
    __out_ecount(Count) D3DFORMAT* pFormats
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORCAPS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __out DXVA2_VideoProcessorCaps* pCaps
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __out UINT* pCount
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT Count,
    __out_ecount(Count) D3DFORMAT* pFormats
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETPROCAMPRANGE)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT ProcAmpCap,
    __out DXVA2_ValueRange* pRange
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETFILTERPROPERTYRANGE)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT FilterSetting,
    __out DXVA2_ValueRange* pRange
    );

typedef HRESULT (CALLBACK* PDXVA2SW_CREATEVIDEOPROCESSDEVICE)(
    __in IDirect3DDevice9* pD3DD9,
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT MaxSubStreams,
    __out HANDLE* phDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_DESTROYVIDEOPROCESSDEVICE)(
    __in HANDLE hDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSBEGINFRAME)(
    __in HANDLE hDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSENDFRAME)(
    __in HANDLE hDevice,
    __inout_opt HANDLE* pHandleComplete
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSSETRENDERTARGET)(
    __in HANDLE hDevice,
    __in IDirect3DSurface9* pRenderTarget
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSBLT)(
    __in HANDLE hDevice,
    __in const DXVA2_VIDEOPROCESSBLT* pBlt
    );

typedef struct _DXVA2SW_CALLBACKS
{
    UINT                                           Size;
    PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT    GetVideoProcessorRenderTargetCount;
    PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS        GetVideoProcessorRenderTargets;
    PDXVA2SW_GETVIDEOPROCESSORCAPS                 GetVideoProcessorCaps;
    PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT GetVideoProcessorSubStreamFormatCount;
    PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS     GetVideoProcessorSubStreamFormats;
    PDXVA2SW_GETPROCAMPRANGE                       GetProcAmpRange;
    PDXVA2SW_GETFILTERPROPERTYRANGE                GetFilterPropertyRange;
    PDXVA2SW_CREATEVIDEOPROCESSDEVICE              CreateVideoProcessDevice;
    PDXVA2SW_DESTROYVIDEOPROCESSDEVICE             DestroyVideoProcessDevice;
    PDXVA2SW_VIDEOPROCESSBEGINFRAME                VideoProcessBeginFrame;
    PDXVA2SW_VIDEOPROCESSENDFRAME                  VideoProcessEndFrame;
    PDXVA2SW_VIDEOPROCESSSETRENDERTARGET           VideoProcessSetRenderTarget;
    PDXVA2SW_VIDEOPROCESSBLT                       VideoProcessBlt;
} DXVA2SW_CALLBACKS, *PDXVA2SW_CALLBACKS;

#endif  // _D3D9_H_

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxgiddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  Content: DXGI Basic Device Driver Interface Definitions
 *
 ***************************************************************************/

#ifndef _DXGIDDI_H
#define _DXGIDDI_H


#include "dxgitype.h"


//--------------------------------------------------------------------------------------------------------
// DXGI error codes
//--------------------------------------------------------------------------------------------------------
#define _FACDXGI_DDI 0x87b
#define MAKE_DXGI_DDI_HRESULT( code )  MAKE_HRESULT( 1, _FACDXGI_DDI, code )
#define MAKE_DXGI_DDI_STATUS( code )   MAKE_HRESULT( 0, _FACDXGI_DDI, code )

#define DXGI_DDI_ERR_WASSTILLDRAWING MAKE_DXGI_DDI_HRESULT(1)
#define DXGI_DDI_ERR_UNSUPPORTED MAKE_DXGI_DDI_HRESULT(2)
#define DXGI_DDI_ERR_NONEXCLUSIVE MAKE_DXGI_DDI_HRESULT(3)

//========================================================================================================
// This is the standard DDI that any DXGI-enabled user-mode driver should support
//

//--------------------------------------------------------------------------------------------------------
typedef	UINT_PTR	DXGI_DDI_HDEVICE;
typedef	UINT_PTR	DXGI_DDI_HRESOURCE;

//--------------------------------------------------------------------------------------------------------
typedef enum DXGI_DDI_RESIDENCY
{
    DXGI_DDI_RESIDENCY_FULLY_RESIDENT = 1,
    DXGI_DDI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = 2,
    DXGI_DDI_RESIDENCY_EVICTED_TO_DISK = 3,
} DXGI_DDI_RESIDENCY;

//--------------------------------------------------------------------------------------------------------
typedef enum DXGI_DDI_FLIP_INTERVAL_TYPE
{
    DXGI_DDI_FLIP_INTERVAL_IMMEDIATE = 0,
    DXGI_DDI_FLIP_INTERVAL_ONE       = 1,
    DXGI_DDI_FLIP_INTERVAL_TWO       = 2,
    DXGI_DDI_FLIP_INTERVAL_THREE     = 3,
    DXGI_DDI_FLIP_INTERVAL_FOUR      = 4,
} DXGI_DDI_FLIP_INTERVAL_TYPE;

//--------------------------------------------------------------------------------------------------------
typedef struct DXGI_DDI_PRESENT_FLAGS
{
    union
    {
        struct
        {
            UINT    Blt                 : 1;        // 0x00000001
            UINT    Flip                : 1;        // 0x00000002
            UINT    Reserved            :30;        // 0xFFFFFFFC            
        };
        UINT    Value;
    };            
} DXGI_DDI_PRESENT_FLAGS;

//--------------------------------------------------------------------------------------------------------
typedef struct DXGI_DDI_ARG_PRESENT
{
    DXGI_DDI_HDEVICE            hDevice;             //in
    DXGI_DDI_HRESOURCE          hSurfaceToPresent;   //in
    UINT                        SrcSubResourceIndex; // Index of surface level
    DXGI_DDI_HRESOURCE          hDstResource;        // if non-zero, it's the destination of the present
    UINT                        DstSubResourceIndex; // Index of surface level
    void *                      pDXGIContext;        // opaque: Pass this to the Present callback
    DXGI_DDI_PRESENT_FLAGS      Flags;               // Presentation flags.
    DXGI_DDI_FLIP_INTERVAL_TYPE FlipInterval;        // Presentation interval (flip only)
}DXGI_DDI_ARG_PRESENT;

//--------------------------------------------------------------------------------------------------------
typedef struct DXGI_DDI_ARG_ROTATE_RESOURCE_IDENTITIES
{
    DXGI_DDI_HDEVICE hDevice; //in
    CONST DXGI_DDI_HRESOURCE* pResources; //in: Array of Resources to rotate identities; 0 <= 1, 1 <= 2, etc.
    UINT Resources;
} DXGI_DDI_ARG_ROTATE_RESOURCE_IDENTITIES;

typedef struct DXGI_DDI_ARG_GET_GAMMA_CONTROL_CAPS
{
    DXGI_DDI_HDEVICE		            hDevice;			//in
    DXGI_GAMMA_CONTROL_CAPABILITIES *   pGammaCapabilities; //in/out
} DXGI_DDI_ARG_GET_GAMMA_CONTROL_CAPS;

typedef struct DXGI_DDI_ARG_SET_GAMMA_CONTROL
{
    DXGI_DDI_HDEVICE		            hDevice;			//in
    DXGI_GAMMA_CONTROL                  GammaControl;       //in
} DXGI_DDI_ARG_SET_GAMMA_CONTROL;

typedef struct DXGI_DDI_ARG_SETDISPLAYMODE
{
    DXGI_DDI_HDEVICE		    hDevice;			    //in
    DXGI_DDI_HRESOURCE          hResource;              // Source surface
    UINT                        SubResourceIndex;       // Index of surface level
} DXGI_DDI_ARG_SETDISPLAYMODE;

typedef struct DXGI_DDI_ARG_SETRESOURCEPRIORITY
{
    DXGI_DDI_HDEVICE            hDevice;                //in
    DXGI_DDI_HRESOURCE          hResource;              //in
    UINT                        Priority;               //in
} DXGI_DDI_ARG_SETRESOURCEPRIORITY;

typedef struct DXGI_DDI_ARG_QUERYRESOURCERESIDENCY
{
    DXGI_DDI_HDEVICE            hDevice;                //in
    __ecount( Resources ) CONST DXGI_DDI_HRESOURCE *  pResources;             //in
    __ecount( Resources ) DXGI_DDI_RESIDENCY *        pStatus;                //out
    SIZE_T                      Resources;              //in
} DXGI_DDI_ARG_QUERYRESOURCERESIDENCY;

//--------------------------------------------------------------------------------------------------------
// Remarks: Fractional value used to represent vertical and horizontal frequencies of a video mode
//          (i.e. VSync and HSync). Vertical frequencies are stored in Hz. Horizontal frequencies
//          are stored in KHz.
//          The dynamic range of this encoding format, given 10^-7 resolution is {0..(2^32 - 1) / 10^7},
//          which translates to {0..428.4967296} [Hz] for vertical frequencies and {0..428.4967296} [KHz]
//          for horizontal frequencies. This sub-microseconds precision range should be acceptable even
//          for a pro-video application (error in one microsecond for video signal synchronization would
//          imply a time drift with a cycle of 10^7/(60*60*24) = 115.741 days.
//
//          If rational number with a finite fractional sequence, use denominator of form 10^(length of fractional sequence).
//          If rational number without a finite fractional sequence, or a sequence exceeding the precision allowed by the 
//          dynamic range of the denominator, or an irrational number, use an appropriate ratio of integers which best 
//          represents the value.
//          
typedef struct DXGI_DDI_RATIONAL
{
    UINT Numerator;
    UINT Denominator;
} DXGI_DDI_RATIONAL;

//--------------------------------------------------------------------------------------------------------
typedef enum DXGI_DDI_MODE_SCANLINE_ORDER
{
    DXGI_DDI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0,
    DXGI_DDI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1,
    DXGI_DDI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2,
    DXGI_DDI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3,
} DXGI_DDI_MODE_SCANLINE_ORDER;

typedef enum DXGI_DDI_MODE_SCALING
{
    DXGI_DDI_MODE_SCALING_UNSPECIFIED = 0,
    DXGI_DDI_MODE_SCALING_STRETCHED = 1,
    DXGI_DDI_MODE_SCALING_CENTERED = 2,
} DXGI_DDI_MODE_SCALING;

typedef enum DXGI_DDI_MODE_ROTATION
{
    DXGI_DDI_MODE_ROTATION_UNSPECIFIED = 0,
    DXGI_DDI_MODE_ROTATION_IDENTITY = 1,
    DXGI_DDI_MODE_ROTATION_ROTATE90 = 2,
    DXGI_DDI_MODE_ROTATION_ROTATE180 = 3,
    DXGI_DDI_MODE_ROTATION_ROTATE270 = 4,
} DXGI_DDI_MODE_ROTATION;

typedef struct DXGI_DDI_MODE_DESC
{
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    DXGI_DDI_RATIONAL RefreshRate;
    DXGI_DDI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_DDI_MODE_ROTATION Rotation;
    DXGI_DDI_MODE_SCALING Scaling;
} DXGI_DDI_MODE_DESC;

// Bit indicates that UMD has the option to prevent this Resource from ever being a Primary
// UMD can prevent the actual flip (from optional primary to regular primary) and use a copy
// operation, during Present. Thus, it's possible the UMD can opt out of this Resource being
// actually used as a primary.
#define DXGI_DDI_PRIMARY_OPTIONAL 0x1

// Bit indicates that the Primary really represents the IDENTITY rotation, eventhough it will
// be used with non-IDENTITY display modes, since the application will take on the burden of
// honoring the output orientation by rotating, say the viewport and projection matrix.
#define DXGI_DDI_PRIMARY_NONPREROTATED 0x2


// Bit indicates that the driver cannot tolerate setting any subresource of the specified
// resource as a primary. The UMD should set this bit at resource creation time if it
// chooses to implement presentation from this surface via a copy operation. The DXGI 
// runtime will not employ flip-style presentation if this bit is set
#define DXGI_DDI_PRIMARY_DRIVER_FLAG_NO_SCANOUT 0x1

typedef struct DXGI_DDI_PRIMARY_DESC
{
    UINT                           Flags;			// [in]
    D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;	// [in]
    DXGI_DDI_MODE_DESC             ModeDesc;		// [in]
    UINT						   DriverFlags;		// [out] Filled by the driver 
} DXGI_DDI_PRIMARY_DESC;

typedef struct DXGI_DDI_ARG_BLT_FLAGS
{
    union
    {
        struct
        {
            UINT    Resolve                : 1;     // 0x00000001
            UINT    Convert                : 1;     // 0x00000002
            UINT    Stretch                : 1;     // 0x00000004
            UINT    Present                : 1;     // 0x00000008
            UINT    Reserved               :28;
        };
        UINT Value;
    };
} DXGI_DDI_ARG_BLT_FLAGS;

typedef struct DXGI_DDI_ARG_BLT
{
    DXGI_DDI_HDEVICE            hDevice;                //in
    DXGI_DDI_HRESOURCE          hDstResource;           //in
    UINT                        DstSubresource;         //in
    UINT                        DstLeft;                //in
    UINT                        DstTop;                 //in
    UINT                        DstRight;               //in
    UINT                        DstBottom;              //in
    DXGI_DDI_HRESOURCE          hSrcResource;           //in
    UINT                        SrcSubresource;         //in
    DXGI_DDI_ARG_BLT_FLAGS      Flags;                  //in
    DXGI_DDI_MODE_ROTATION      Rotate;                 //in
} DXGI_DDI_ARG_BLT;

//--------------------------------------------------------------------------------------------------------
typedef struct DXGI_DDI_BASE_FUNCTIONS
{
    HRESULT ( __stdcall /*APIENTRY*/ * pfnPresent )               (DXGI_DDI_ARG_PRESENT*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnGetGammaCaps )          (DXGI_DDI_ARG_GET_GAMMA_CONTROL_CAPS*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnSetDisplayMode )        (DXGI_DDI_ARG_SETDISPLAYMODE*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnSetResourcePriority )   (DXGI_DDI_ARG_SETRESOURCEPRIORITY*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnQueryResourceResidency )(DXGI_DDI_ARG_QUERYRESOURCERESIDENCY*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnRotateResourceIdentities )(DXGI_DDI_ARG_ROTATE_RESOURCE_IDENTITIES*);
    HRESULT ( __stdcall /*APIENTRY*/ * pfnBlt                    )(DXGI_DDI_ARG_BLT*);
}DXGI_DDI_BASE_FUNCTIONS;



//========================================================================================================
// DXGI callback definitions.
//


//--------------------------------------------------------------------------------------------------------
typedef struct DXGIDDICB_PRESENT
{
    D3DKMT_HANDLE   hSrcAllocation;             // in: The allocation of which content will be presented
    D3DKMT_HANDLE   hDstAllocation;             // in: if non-zero, it's the destination allocation of the present
    void *          pDXGIContext;               // opaque: Fill this with the value in DXGI_DDI_ARG_PRESENT.pDXGIContext
    HANDLE          hContext;                   // in: Context being submitted to.
    UINT            BroadcastContextCount;      // in: Specifies the number of context 
                                                //     to broadcast this present operation to.
                                                //     Only supported for flip operation.
    HANDLE          BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT]; // in: Specifies the handle of the context to
                                                                    //     broadcast to.    
} DXGIDDICB_PRESENT;

typedef HRESULT (APIENTRY CALLBACK *PFNDDXGIDDI_PRESENTCB)(HANDLE hDevice, CONST DXGIDDICB_PRESENT*);

//--------------------------------------------------------------------------------------------------------
typedef struct DXGI_DDI_BASE_CALLBACKS
{
    PFNDDXGIDDI_PRESENTCB                pfnPresentCb;
} DXGI_DDI_BASE_CALLBACKS;


//========================================================================================================
// DXGI basic DDI device creation arguments

typedef struct DXGI_DDI_BASE_ARGS
{
    DXGI_DDI_BASE_CALLBACKS *pDXGIBaseCallbacks;         // in: The driver should record this pointer for later use
    DXGI_DDI_BASE_FUNCTIONS *pDXGIDDIBaseFunctions;      // in/out: The driver should fill the denoted struct with DXGI base driver entry points
} DXGI_DDI_BASE_ARGS;


#endif /* _DXGIDDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxmini.h
 *  Content:    Miniport support for DirectDraw DXAPI.  This file is
 *              analagous to Win95's ddkmmini.h.
 *
 ***************************************************************************/

#ifndef __DXMINI_INCLUDED__
#define __DXMINI_INCLUDED__

DEFINE_GUID(GUID_DxApi, 0x8a79bef0, 0xb915, 0x11d0, 0x91, 0x44, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);

#ifndef GUID_DEFS_ONLY
/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

#ifndef MDL_MAPPING_FLAGS

    typedef struct _MDL {
        struct _MDL *MdlNext;
        short MdlSize;
        short MdlFlags;
        struct _EPROCESS *Process;
        ULONG *lpMappedSystemVa;
        ULONG *lpStartVa;
        ULONG ByteCount;
        ULONG ByteOffset;
    } MDL;
    typedef MDL *PMDL;

    #define MDL_MAPPED_TO_SYSTEM_VA     0x0001
    #define MDL_PAGES_LOCKED            0x0002
    #define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
    #define MDL_ALLOCATED_FIXED_SIZE    0x0008
    #define MDL_PARTIAL                 0x0010
    #define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
    #define MDL_IO_PAGE_READ            0x0040
    #define MDL_WRITE_OPERATION         0x0080
    #define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
    #define MDL_LOCK_HELD               0x0200
    #define MDL_SCATTER_GATHER_VA       0x0400
    #define MDL_IO_SPACE                0x0800
    #define MDL_NETWORK_HEADER          0x1000
    #define MDL_MAPPING_CAN_FAIL        0x2000
    #define MDL_ALLOCATED_MUST_SUCCEED  0x4000
    #define MDL_64_BIT_VA               0x8000

    #define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )
#endif

/*============================================================================
 *
 * Error values that may be returned by the miniport
 *
 *==========================================================================*/

#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// Data for every DXAPI surface
//

typedef struct _DDSURFACEDATA {
    DWORD       ddsCaps;                // Ring 3 creation caps
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    DWORD       dwWidth;                // Surface width
    DWORD       dwHeight;               // Surface height
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayFlags;         // DDOVER_XX flags
    DWORD       dwOverlayOffset;        // Offset in frame buffer of overlay
    DWORD       dwOverlaySrcWidth;	// Src width of overlay
    DWORD       dwOverlaySrcHeight;	// Src height of overlay
    DWORD       dwOverlayDestWidth;	// Dest width of overlay
    DWORD       dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId;		// ID of video port (-1 if not connected to a video port)
    DWORD       dwFormatFlags;
    DWORD       dwFormatFourCC;
    DWORD       dwFormatBitCount;
    DWORD       dwRBitMask;
    DWORD       dwGBitMask;
    DWORD       dwBBitMask;
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved4;      // Reserved for the HAL/Miniport
} DDSURFACEDATA, *LPDDSURFACEDATA;

//
// Data for every DXAPI video port
//

typedef struct DDVIDEOPORTDATA {
    DWORD       dwVideoPortId;          // ID of video port (0 - MaxVideoPorts-1)
    DWORD       dwVPFlags;              // Video port DDVP_ option flags
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
} DDVIDEOPORTDATA, *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Miniport
 *
 *==========================================================================*/

typedef struct _DX_IRQDATA {
    DWORD       dwIrqFlags;             // DDIRQ_ flags ORed in by miniport
} DX_IRQDATA, *PDX_IRQDATA;

typedef VOID (*PDX_IRQCALLBACK)(PDX_IRQDATA pIrqData);

#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER                         0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l

// output from DxGetIrqInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwFlags;
} DDGETIRQINFO, *PDDGETIRQINFO;
#define IRQINFO_HANDLED		0x01	// Miniport is managing IRQ
#define IRQINFO_NOTHANDLED	0x02	// Not supported on NT

// input to DxEnableIrq
typedef struct _DDENABLEIRQINFO {
    DWORD           dwIRQSources;
    DWORD           dwLine;             // Line for DDIRQ_VPORTx_LINE interrupt
    PDX_IRQCALLBACK IRQCallback;	// Miniport calls this when IRQ happens
    PDX_IRQDATA     lpIRQData;          // Parameter to be passed to IRQCallback
} DDENABLEIRQINFO, *PDDENABLEIRQINFO;

// input to DxSkipNextField
typedef struct _DDSKIPNEXTFIELDINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    DWORD               dwSkipFlags;
} DDSKIPNEXTFIELDINFO, *PDDSKIPNEXTFIELDINFO;

#define DDSKIP_SKIPNEXT                 1
#define DDSKIP_ENABLENEXT               2

// intput to DxBobNextField
typedef struct _DDBOBNEXTFIELDINFO {
    LPDDSURFACEDATA     lpSurface;
} DDBOBNEXTFIELDINFO, *PDDBOBNEXTFIELDINFO;

// intput to DxSetState
typedef struct _DDSETSTATEININFO {
    LPDDSURFACEDATA     lpSurfaceData;
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDSETSTATEININFO, *PDDSETSTATEININFO;

// output from DxSetState
typedef struct _DDSETSTATEOUTINFO {
    BOOL                bSoftwareAutoflip;
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDSETSTATEOUTINFO, *PDDSETSTATEOUTINFO;

// input to DxLock
typedef struct _DDLOCKININFO {
    LPDDSURFACEDATA     lpSurfaceData;
} DDLOCKININFO, *PDDLOCKININFO;

// output from DxLock
typedef struct _DDLOCKOUTINFO {
    ULONG_PTR            dwSurfacePtr;
} DDLOCKOUTINFO, *PDDLOCKOUTINFO;

// input to DxFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlags;
} DDFLIPOVERLAYINFO, *PDDFLIPOVERLAYINFO;

// intput to DxFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO, *PDDFLIPVIDEOPORTINFO;

#define DDVPFLIP_VIDEO                  0x00000001l
#define DDVPFLIP_VBI                    0x00000002l

// input to DxGetPolarity
typedef struct _DDGETPOLARITYININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPOLARITYININFO, *PDDGETPOLARITYININFO;

// output from DxGetPolarity
typedef struct _DDGETPOLARITYOUTINFO {
    DWORD               bPolarity;
} DDGETPOLARITYOUTINFO, *PDDGETPOLARITYOUTINFO;

// input to DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETCURRENTAUTOFLIPININFO, *PDDGETCURRENTAUTOFLIPININFO;

// output from DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETCURRENTAUTOFLIPOUTINFO, *PDDGETCURRENTAUTOFLIPOUTINFO;

// input to DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPREVIOUSAUTOFLIPININFO, *PDDGETPREVIOUSAUTOFLIPININFO;

// output from DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETPREVIOUSAUTOFLIPOUTINFO, *PDDGETPREVIOUSAUTOFLIPOUTINFO;

// intput to DxTransfer
typedef struct _DDTRANSFERININFO {
    LPDDSURFACEDATA	lpSurfaceData;
    DWORD		dwStartLine;
    DWORD 		dwEndLine;
    ULONG_PTR   dwTransferID;
    DWORD 		dwTransferFlags;
    PMDL  		lpDestMDL;
} DDTRANSFERININFO, *PDDTRANSFERININFO;

#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100

// output from DxTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO, *PDDTRANSFEROUTINFO;

// output from DxGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD_PTR dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO, *PDDGETTRANSFEROUTINFO;

/*============================================================================
 *
 * DXAPI function prototypes
 *
 *==========================================================================*/

typedef DWORD (*PDX_GETIRQINFO)(PVOID,PVOID,PDDGETIRQINFO);
typedef DWORD (*PDX_ENABLEIRQ)(PVOID,PDDENABLEIRQINFO,PVOID);
typedef DWORD (*PDX_SKIPNEXTFIELD)(PVOID,PDDSKIPNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_BOBNEXTFIELD)(PVOID,PDDBOBNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_SETSTATE)(PVOID,PDDSETSTATEININFO,PDDSETSTATEOUTINFO);
typedef DWORD (*PDX_LOCK)(PVOID,PDDLOCKININFO,PDDLOCKOUTINFO);
typedef DWORD (*PDX_FLIPOVERLAY)(PVOID,PDDFLIPOVERLAYINFO,PVOID);
typedef DWORD (*PDX_FLIPVIDEOPORT)(PVOID,PDDFLIPVIDEOPORTINFO,PVOID);
typedef DWORD (*PDX_GETPOLARITY)(PVOID,PDDGETPOLARITYININFO,PDDGETPOLARITYOUTINFO);
typedef DWORD (*PDX_GETCURRENTAUTOFLIP)(PVOID,PDDGETCURRENTAUTOFLIPININFO,PDDGETCURRENTAUTOFLIPOUTINFO);
typedef DWORD (*PDX_GETPREVIOUSAUTOFLIP)(PVOID,PDDGETPREVIOUSAUTOFLIPININFO,PDDGETPREVIOUSAUTOFLIPOUTINFO);
typedef DWORD (*PDX_TRANSFER)(PVOID,PDDTRANSFERININFO,PDDTRANSFEROUTINFO);
typedef DWORD (*PDX_GETTRANSFERSTATUS)(PVOID,PVOID,PDDGETTRANSFEROUTINFO);

/*============================================================================
 *
 * HAL table filled in by the miniport and called by DirectDraw
 *
 *==========================================================================*/

#define DXAPI_HALVERSION 0x0001

typedef struct _DXAPI_INTERFACE {

    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PVOID                   InterfaceReference;
    PVOID                   InterfaceDereference;
    PDX_GETIRQINFO          DxGetIrqInfo;
    PDX_ENABLEIRQ           DxEnableIrq;
    PDX_SKIPNEXTFIELD       DxSkipNextField;
    PDX_BOBNEXTFIELD        DxBobNextField;
    PDX_SETSTATE            DxSetState;
    PDX_LOCK                DxLock;
    PDX_FLIPOVERLAY         DxFlipOverlay;
    PDX_FLIPVIDEOPORT       DxFlipVideoPort;
    PDX_GETPOLARITY         DxGetPolarity;
    PDX_GETCURRENTAUTOFLIP  DxGetCurrentAutoflip;
    PDX_GETPREVIOUSAUTOFLIP DxGetPreviousAutoflip;
    PDX_TRANSFER	    DxTransfer;
    PDX_GETTRANSFERSTATUS   DxGetTransferStatus;

} DXAPI_INTERFACE, *PDXAPI_INTERFACE;

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxgitype.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dxgitype.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __dxgitype_h__
#define __dxgitype_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxgitype_0000_0000 */
/* [local] */ 

#define _FACDXGI    0x87a
#define MAKE_DXGI_HRESULT( code )    MAKE_HRESULT( 1, _FACDXGI, code )
#define MAKE_DXGI_STATUS( code )    MAKE_HRESULT( 0, _FACDXGI, code )
#define DXGI_STATUS_OCCLUDED                MAKE_DXGI_STATUS(1 )
#define DXGI_STATUS_CLIPPED                 MAKE_DXGI_STATUS(2 )
#define DXGI_STATUS_NO_REDIRECTION          MAKE_DXGI_STATUS(4 )
#define DXGI_STATUS_NO_DESKTOP_ACCESS       MAKE_DXGI_STATUS(5 )
#define DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE       MAKE_DXGI_STATUS(6 )
#define DXGI_STATUS_MODE_CHANGED            MAKE_DXGI_STATUS(7 )
#define DXGI_STATUS_MODE_CHANGE_IN_PROGRESS MAKE_DXGI_STATUS(8 )
#define DXGI_ERROR_INVALID_CALL    MAKE_DXGI_HRESULT( 1 )
#define DXGI_ERROR_NOT_FOUND    MAKE_DXGI_HRESULT( 2 )
#define DXGI_ERROR_MORE_DATA    MAKE_DXGI_HRESULT( 3 )
#define DXGI_ERROR_UNSUPPORTED    MAKE_DXGI_HRESULT( 4 )
#define DXGI_ERROR_DEVICE_REMOVED    MAKE_DXGI_HRESULT( 5 )
#define DXGI_ERROR_DEVICE_HUNG    MAKE_DXGI_HRESULT( 6 )
#define DXGI_ERROR_DEVICE_RESET    MAKE_DXGI_HRESULT( 7 )
#define DXGI_ERROR_WAS_STILL_DRAWING    MAKE_DXGI_HRESULT( 10 )
#define DXGI_ERROR_FRAME_STATISTICS_DISJOINT MAKE_DXGI_HRESULT( 11 )
#define DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE MAKE_DXGI_HRESULT( 12 )
#define DXGI_ERROR_DRIVER_INTERNAL_ERROR    MAKE_DXGI_HRESULT( 32 )
#define DXGI_ERROR_NONEXCLUSIVE    MAKE_DXGI_HRESULT( 33 )
#define DXGI_ERROR_NOT_CURRENTLY_AVAILABLE   MAKE_DXGI_HRESULT( 34 )
#define DXGI_FORMAT_DEFINED 1
typedef 
enum DXGI_FORMAT
    {	DXGI_FORMAT_UNKNOWN	= 0,
	DXGI_FORMAT_R32G32B32A32_TYPELESS	= 1,
	DXGI_FORMAT_R32G32B32A32_FLOAT	= 2,
	DXGI_FORMAT_R32G32B32A32_UINT	= 3,
	DXGI_FORMAT_R32G32B32A32_SINT	= 4,
	DXGI_FORMAT_R32G32B32_TYPELESS	= 5,
	DXGI_FORMAT_R32G32B32_FLOAT	= 6,
	DXGI_FORMAT_R32G32B32_UINT	= 7,
	DXGI_FORMAT_R32G32B32_SINT	= 8,
	DXGI_FORMAT_R16G16B16A16_TYPELESS	= 9,
	DXGI_FORMAT_R16G16B16A16_FLOAT	= 10,
	DXGI_FORMAT_R16G16B16A16_UNORM	= 11,
	DXGI_FORMAT_R16G16B16A16_UINT	= 12,
	DXGI_FORMAT_R16G16B16A16_SNORM	= 13,
	DXGI_FORMAT_R16G16B16A16_SINT	= 14,
	DXGI_FORMAT_R32G32_TYPELESS	= 15,
	DXGI_FORMAT_R32G32_FLOAT	= 16,
	DXGI_FORMAT_R32G32_UINT	= 17,
	DXGI_FORMAT_R32G32_SINT	= 18,
	DXGI_FORMAT_R32G8X24_TYPELESS	= 19,
	DXGI_FORMAT_D32_FLOAT_S8X24_UINT	= 20,
	DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS	= 21,
	DXGI_FORMAT_X32_TYPELESS_G8X24_UINT	= 22,
	DXGI_FORMAT_R10G10B10A2_TYPELESS	= 23,
	DXGI_FORMAT_R10G10B10A2_UNORM	= 24,
	DXGI_FORMAT_R10G10B10A2_UINT	= 25,
	DXGI_FORMAT_R11G11B10_FLOAT	= 26,
	DXGI_FORMAT_R8G8B8A8_TYPELESS	= 27,
	DXGI_FORMAT_R8G8B8A8_UNORM	= 28,
	DXGI_FORMAT_R8G8B8A8_UNORM_SRGB	= 29,
	DXGI_FORMAT_R8G8B8A8_UINT	= 30,
	DXGI_FORMAT_R8G8B8A8_SNORM	= 31,
	DXGI_FORMAT_R8G8B8A8_SINT	= 32,
	DXGI_FORMAT_R16G16_TYPELESS	= 33,
	DXGI_FORMAT_R16G16_FLOAT	= 34,
	DXGI_FORMAT_R16G16_UNORM	= 35,
	DXGI_FORMAT_R16G16_UINT	= 36,
	DXGI_FORMAT_R16G16_SNORM	= 37,
	DXGI_FORMAT_R16G16_SINT	= 38,
	DXGI_FORMAT_R32_TYPELESS	= 39,
	DXGI_FORMAT_D32_FLOAT	= 40,
	DXGI_FORMAT_R32_FLOAT	= 41,
	DXGI_FORMAT_R32_UINT	= 42,
	DXGI_FORMAT_R32_SINT	= 43,
	DXGI_FORMAT_R24G8_TYPELESS	= 44,
	DXGI_FORMAT_D24_UNORM_S8_UINT	= 45,
	DXGI_FORMAT_R24_UNORM_X8_TYPELESS	= 46,
	DXGI_FORMAT_X24_TYPELESS_G8_UINT	= 47,
	DXGI_FORMAT_R8G8_TYPELESS	= 48,
	DXGI_FORMAT_R8G8_UNORM	= 49,
	DXGI_FORMAT_R8G8_UINT	= 50,
	DXGI_FORMAT_R8G8_SNORM	= 51,
	DXGI_FORMAT_R8G8_SINT	= 52,
	DXGI_FORMAT_R16_TYPELESS	= 53,
	DXGI_FORMAT_R16_FLOAT	= 54,
	DXGI_FORMAT_D16_UNORM	= 55,
	DXGI_FORMAT_R16_UNORM	= 56,
	DXGI_FORMAT_R16_UINT	= 57,
	DXGI_FORMAT_R16_SNORM	= 58,
	DXGI_FORMAT_R16_SINT	= 59,
	DXGI_FORMAT_R8_TYPELESS	= 60,
	DXGI_FORMAT_R8_UNORM	= 61,
	DXGI_FORMAT_R8_UINT	= 62,
	DXGI_FORMAT_R8_SNORM	= 63,
	DXGI_FORMAT_R8_SINT	= 64,
	DXGI_FORMAT_A8_UNORM	= 65,
	DXGI_FORMAT_R1_UNORM	= 66,
	DXGI_FORMAT_R9G9B9E5_SHAREDEXP	= 67,
	DXGI_FORMAT_R8G8_B8G8_UNORM	= 68,
	DXGI_FORMAT_G8R8_G8B8_UNORM	= 69,
	DXGI_FORMAT_BC1_TYPELESS	= 70,
	DXGI_FORMAT_BC1_UNORM	= 71,
	DXGI_FORMAT_BC1_UNORM_SRGB	= 72,
	DXGI_FORMAT_BC2_TYPELESS	= 73,
	DXGI_FORMAT_BC2_UNORM	= 74,
	DXGI_FORMAT_BC2_UNORM_SRGB	= 75,
	DXGI_FORMAT_BC3_TYPELESS	= 76,
	DXGI_FORMAT_BC3_UNORM	= 77,
	DXGI_FORMAT_BC3_UNORM_SRGB	= 78,
	DXGI_FORMAT_BC4_TYPELESS	= 79,
	DXGI_FORMAT_BC4_UNORM	= 80,
	DXGI_FORMAT_BC4_SNORM	= 81,
	DXGI_FORMAT_BC5_TYPELESS	= 82,
	DXGI_FORMAT_BC5_UNORM	= 83,
	DXGI_FORMAT_BC5_SNORM	= 84,
	DXGI_FORMAT_B5G6R5_UNORM	= 85,
	DXGI_FORMAT_B5G5R5A1_UNORM	= 86,
	DXGI_FORMAT_B8G8R8A8_UNORM	= 87,
	DXGI_FORMAT_B8G8R8X8_UNORM	= 88,
	DXGI_FORMAT_FORCE_UINT	= 0xffffffffUL
    } 	DXGI_FORMAT;

typedef struct DXGI_RGB
    {
    float Red;
    float Green;
    float Blue;
    } 	DXGI_RGB;

typedef struct DXGI_GAMMA_CONTROL
    {
    DXGI_RGB Scale;
    DXGI_RGB Offset;
    DXGI_RGB GammaCurve[ 1025 ];
    } 	DXGI_GAMMA_CONTROL;

typedef struct DXGI_GAMMA_CONTROL_CAPABILITIES
    {
    BOOL ScaleAndOffsetSupported;
    float MaxConvertedValue;
    float MinConvertedValue;
    UINT NumGammaControlPoints;
    float ControlPointPositions[ 1025 ];
    } 	DXGI_GAMMA_CONTROL_CAPABILITIES;

typedef struct DXGI_RATIONAL
    {
    UINT Numerator;
    UINT Denominator;
    } 	DXGI_RATIONAL;

typedef 
enum DXGI_MODE_SCANLINE_ORDER
    {	DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED	= 0,
	DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE	= 1,
	DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST	= 2,
	DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST	= 3
    } 	DXGI_MODE_SCANLINE_ORDER;

typedef 
enum DXGI_MODE_SCALING
    {	DXGI_MODE_SCALING_UNSPECIFIED	= 0,
	DXGI_MODE_SCALING_CENTERED	= 1,
	DXGI_MODE_SCALING_STRETCHED	= 2
    } 	DXGI_MODE_SCALING;

typedef 
enum DXGI_MODE_ROTATION
    {	DXGI_MODE_ROTATION_UNSPECIFIED	= 0,
	DXGI_MODE_ROTATION_IDENTITY	= 1,
	DXGI_MODE_ROTATION_ROTATE90	= 2,
	DXGI_MODE_ROTATION_ROTATE180	= 3,
	DXGI_MODE_ROTATION_ROTATE270	= 4
    } 	DXGI_MODE_ROTATION;

typedef struct DXGI_MODE_DESC
    {
    UINT Width;
    UINT Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
    } 	DXGI_MODE_DESC;

typedef struct DXGI_SAMPLE_DESC
    {
    UINT Count;
    UINT Quality;
    } 	DXGI_SAMPLE_DESC;



extern RPC_IF_HANDLE __MIDL_itf_dxgitype_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgitype_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxva2trace.h ===
//------------------------------------------------------------------------------
// File: dxva2Trace.h
//
// Desc: DirectX Video Acceleration 2 header file for ETW data
//
// Copyright (c) 1999 - 2005, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __inc_dxva2Trace_h
#define __inc_dxva2Trace_h

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA2Trace_Control, 0xa0386e75,0xf70c,0x464c,
    0xa9, 0xce, 0x33, 0xc4, 0x4e, 0x09, 0x16, 0x23);

// -------------------------------------------------------------------------
// DXVA2 Video Decoder ETW definitions
//
// There are event for:
//      Device creation
//      Device destruction
//
// When the device is being used there are events for:
//      Begin frame
//      Begin execute
//      End execute
//      End frame
// -------------------------------------------------------------------------
//
typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pD3DDevice;
    GUID                DeviceGuid;
    ULONG               Width;
    ULONG               Height;
    BOOL                Enter;
} DXVA2Trace_DecodeDevCreatedData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    BOOL                Enter;
} DXVA2Trace_DecodeDeviceData;

typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevDestroyedData;
typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevExecuteData;
typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevEndFrameData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pRenderTarget;
    BOOL                Enter;
} DXVA2Trace_DecodeDevBeginFrameData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    UINT                BufferType;
    BOOL                Enter;
} DXVA2Trace_DecodeDevGetBufferData;

DEFINE_GUID(DXVA2Trace_DecodeDevCreated, 0xb4de17a1,0xc5b2,0x44fe,
            0x86, 0xd5, 0xd9, 0x7a, 0x64, 0x81, 0x14, 0xff);

DEFINE_GUID(DXVA2Trace_DecodeDevDestroyed, 0x853ebdf2,0x4160,0x421d,
            0x88, 0x93, 0x63, 0xdc, 0xea, 0x4f, 0x18, 0xbb);

DEFINE_GUID(DXVA2Trace_DecodeDevBeginFrame, 0x9fd1acf6,0x44cb,0x4637,
            0xbc, 0x62, 0x2c, 0x11, 0xa9, 0x60, 0x8f, 0x90);

DEFINE_GUID(DXVA2Trace_DecodeDevExecute,0x850aeb4c,0xd19a,0x4609,
            0xb3, 0xb4, 0xbc, 0xbf, 0x0e, 0x22, 0x12, 0x1e);

DEFINE_GUID(DXVA2Trace_DecodeDevGetBuffer,0x57b128fb,0x72cb,0x4137,
            0xa5, 0x75, 0xd9, 0x1f, 0xa3, 0x16, 0x08, 0x97);

DEFINE_GUID(DXVA2Trace_DecodeDevEndFrame, 0x9fb3cb33,0x47dc,0x4899,
            0x98, 0xc8, 0xc0, 0xc6, 0xcd, 0x7c, 0xd3, 0xcb);



// -------------------------------------------------------------------------
// DXVA2 Video Processing ETW definitions
//
// There are event for:
//      Device creation
//      Device destruction
//
// When the device is being used there are events for:
//      Begin VideoProcessBlt
//      End VideoProcessBlt
// -------------------------------------------------------------------------
//
typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pD3DDevice;
    GUID                DeviceGuid;
    ULONG               RTFourCC;
    ULONG               Width;
    ULONG               Height;
    BOOL                Enter;
} DXVA2Trace_VideoProcessDevCreatedData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    BOOL                Enter;
} DXVA2Trace_VideoProcessDeviceData;
typedef DXVA2Trace_VideoProcessDeviceData DXVA2Trace_VideoProcessDevDestroyedData;
typedef DXVA2Trace_VideoProcessDeviceData DXVA2Trace_VideoProcessBltEndData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pRenderTarget;
    ULONGLONG           TargetFrameTime;
    RECT                TargetRect;
    BOOL                Enter;
} DXVA2TraceVideoProcessBltData;
#define DXVA2TraceVideoProcessBltDataData DXVA2TraceVideoProcessBltData;

DEFINE_GUID(DXVA2Trace_VideoProcessDevCreated, 0x895508c6,0x540d,0x4c87,
            0x98, 0xf8, 0x8d, 0xcb, 0xf2, 0xda, 0xbb, 0x2a);

DEFINE_GUID(DXVA2Trace_VideoProcessDevDestroyed, 0xf97f30b1,0xfb49,0x42c7,
            0x8e, 0xe8, 0x88, 0xbd, 0xfa, 0x92, 0xd4, 0xe2);

DEFINE_GUID(DXVA2Trace_VideoProcessBlt, 0x69089cc0,0x71ab,0x42d0,
            0x95, 0x3a, 0x28, 0x87, 0xbf, 0x05, 0xa8, 0xaf);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxva2api.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dxva2api.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxva2api_h__
#define __dxva2api_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirect3DDeviceManager9_FWD_DEFINED__
#define __IDirect3DDeviceManager9_FWD_DEFINED__
typedef interface IDirect3DDeviceManager9 IDirect3DDeviceManager9;
#endif 	/* __IDirect3DDeviceManager9_FWD_DEFINED__ */


#ifndef __IDirectXVideoAccelerationService_FWD_DEFINED__
#define __IDirectXVideoAccelerationService_FWD_DEFINED__
typedef interface IDirectXVideoAccelerationService IDirectXVideoAccelerationService;
#endif 	/* __IDirectXVideoAccelerationService_FWD_DEFINED__ */


#ifndef __IDirectXVideoDecoderService_FWD_DEFINED__
#define __IDirectXVideoDecoderService_FWD_DEFINED__
typedef interface IDirectXVideoDecoderService IDirectXVideoDecoderService;
#endif 	/* __IDirectXVideoDecoderService_FWD_DEFINED__ */


#ifndef __IDirectXVideoProcessorService_FWD_DEFINED__
#define __IDirectXVideoProcessorService_FWD_DEFINED__
typedef interface IDirectXVideoProcessorService IDirectXVideoProcessorService;
#endif 	/* __IDirectXVideoProcessorService_FWD_DEFINED__ */


#ifndef __IDirectXVideoDecoder_FWD_DEFINED__
#define __IDirectXVideoDecoder_FWD_DEFINED__
typedef interface IDirectXVideoDecoder IDirectXVideoDecoder;
#endif 	/* __IDirectXVideoDecoder_FWD_DEFINED__ */


#ifndef __IDirectXVideoProcessor_FWD_DEFINED__
#define __IDirectXVideoProcessor_FWD_DEFINED__
typedef interface IDirectXVideoProcessor IDirectXVideoProcessor;
#endif 	/* __IDirectXVideoProcessor_FWD_DEFINED__ */


#ifndef __IDirectXVideoMemoryConfiguration_FWD_DEFINED__
#define __IDirectXVideoMemoryConfiguration_FWD_DEFINED__
typedef interface IDirectXVideoMemoryConfiguration IDirectXVideoMemoryConfiguration;
#endif 	/* __IDirectXVideoMemoryConfiguration_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxva2api_0000_0000 */
/* [local] */ 

//
//   The following declarations within the 'if 0' block are dummy typedefs used to make
//   the evr.idl file build. The actual definitions are contained in d3d9.h
//
#if 0
typedef DWORD IDirect3DDevice9;

typedef DWORD IDirect3DSurface9;

typedef DWORD D3DFORMAT;

typedef DWORD D3DPOOL;

#endif
#ifndef DXVA2_API_DEFINED
#define DXVA2_API_DEFINED
DEFINE_GUID(DXVA2_ModeMPEG2_MoComp, 0xe6a9f44b, 0x61b0, 0x4563,0x9e,0xa4,0x63,0xd2,0xa3,0xc6,0xfe,0x66);
DEFINE_GUID(DXVA2_ModeMPEG2_IDCT,   0xbf22ad00, 0x03ea, 0x4690,0x80,0x77,0x47,0x33,0x46,0x20,0x9b,0x7e);
DEFINE_GUID(DXVA2_ModeMPEG2_VLD,    0xee27417f, 0x5e28, 0x4e65,0xbe,0xea,0x1d,0x26,0xb5,0x08,0xad,0xc9);
DEFINE_GUID(DXVA2_ModeH264_A,  0x1b81be64, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_B,  0x1b81be65, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_C,  0x1b81be66, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_D,  0x1b81be67, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_E,  0x1b81be68, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_F,  0x1b81be69, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV8_A,  0x1b81be80, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV8_B,  0x1b81be81, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_A,  0x1b81be90, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_B,  0x1b81be91, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_C,  0x1b81be94, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_A,   0x1b81beA0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_B,   0x1b81beA1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_C,   0x1b81beA2, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_D,   0x1b81beA3, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_VideoProcProgressiveDevice, 0x5a54a0c9,0xc7ec,0x4bd9,0x8e,0xde,0xf3,0xc7,0x5d,0xc4,0x39,0x3b);
DEFINE_GUID(DXVA2_VideoProcBobDevice,         0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);
DEFINE_GUID(DXVA2_VideoProcSoftwareDevice,    0x4553d47f,0xee7e,0x4e3f,0x94,0x75,0xdb,0xf1,0x37,0x6c,0x48,0x10);
#define DXVA2_ModeMPEG2_MOCOMP      DXVA2_ModeMPEG2_MoComp
#define DXVA2_ModeWMV8_PostProc     DXVA2_ModeWMV8_A
#define DXVA2_ModeWMV8_MoComp       DXVA2_ModeWMV8_B
#define DXVA2_ModeWMV9_PostProc     DXVA2_ModeWMV9_A
#define DXVA2_ModeWMV9_MoComp       DXVA2_ModeWMV9_B
#define DXVA2_ModeWMV9_IDCT         DXVA2_ModeWMV9_C
#define DXVA2_ModeVC1_PostProc      DXVA2_ModeVC1_A
#define DXVA2_ModeVC1_MoComp        DXVA2_ModeVC1_B
#define DXVA2_ModeVC1_IDCT          DXVA2_ModeVC1_C
#define DXVA2_ModeVC1_VLD           DXVA2_ModeVC1_D
#define DXVA2_ModeH264_MoComp_NoFGT DXVA2_ModeH264_A
#define DXVA2_ModeH264_MoComp_FGT   DXVA2_ModeH264_B
#define DXVA2_ModeH264_IDCT_NoFGT   DXVA2_ModeH264_C
#define DXVA2_ModeH264_IDCT_FGT     DXVA2_ModeH264_D
#define DXVA2_ModeH264_VLD_NoFGT    DXVA2_ModeH264_E
#define DXVA2_ModeH264_VLD_FGT      DXVA2_ModeH264_F
#define DXVA2_E_NOT_INITIALIZED     ((HRESULT)0x80041000L)
#define DXVA2_E_NEW_VIDEO_DEVICE    ((HRESULT)0x80041001L)
#define DXVA2_E_VIDEO_DEVICE_LOCKED ((HRESULT)0x80041002L)
#define DXVA2_E_NOT_AVAILABLE       ((HRESULT)0x80041003L)
#if defined(_WIN32) && !defined(_NO_COM)
DEFINE_GUID(IID_IDirect3DDeviceManager9,          0xa0cade0f,0x06d5,0x4cf4,0xa1,0xc7,0xf3,0xcd,0xd7,0x25,0xaa,0x75);
DEFINE_GUID(IID_IDirectXVideoAccelerationService, 0xfc51a550,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoDecoderService,      0xfc51a551,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoProcessorService,    0xfc51a552,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoDecoder,             0xf2b0810a,0xfd00,0x43c9,0x91,0x8c,0xdf,0x94,0xe2,0xd8,0xef,0x7d);
DEFINE_GUID(IID_IDirectXVideoProcessor,           0x8c3a39f0,0x916e,0x4690,0x80,0x4f,0x4c,0x80,0x01,0x35,0x5d,0x25);
DEFINE_GUID(IID_IDirectXVideoMemoryConfiguration, 0xb7f916dd,0xdb3b,0x49c1,0x84,0xd7,0xe4,0x5e,0xf9,0x9e,0xc7,0x26);
#endif
#ifndef MAX_DEINTERLACE_SURFACES
#define MAX_DEINTERLACE_SURFACES 32
#endif
#ifndef MAX_SUBSTREAMS
#define MAX_SUBSTREAMS 15
#endif
typedef struct _DXVA2_ExtendedFormat
    {
    union 
        {
        struct 
            {
            UINT SampleFormat	: 8;
            UINT VideoChromaSubsampling	: 4;
            UINT NominalRange	: 3;
            UINT VideoTransferMatrix	: 3;
            UINT VideoLighting	: 4;
            UINT VideoPrimaries	: 5;
            UINT VideoTransferFunction	: 5;
            } 	;
        UINT value;
        } 	;
    } 	DXVA2_ExtendedFormat;

typedef 
enum _DXVA2_SampleFormat
    {	DXVA2_SampleFormatMask	= 0xff,
	DXVA2_SampleUnknown	= 0,
	DXVA2_SampleProgressiveFrame	= 2,
	DXVA2_SampleFieldInterleavedEvenFirst	= 3,
	DXVA2_SampleFieldInterleavedOddFirst	= 4,
	DXVA2_SampleFieldSingleEven	= 5,
	DXVA2_SampleFieldSingleOdd	= 6,
	DXVA2_SampleSubStream	= 7
    } 	DXVA2_SampleFormat;

typedef 
enum _DXVA2_VideoChromaSubSampling
    {	DXVA2_VideoChromaSubsamplingMask	= 0xf,
	DXVA2_VideoChromaSubsampling_Unknown	= 0,
	DXVA2_VideoChromaSubsampling_ProgressiveChroma	= 0x8,
	DXVA2_VideoChromaSubsampling_Horizontally_Cosited	= 0x4,
	DXVA2_VideoChromaSubsampling_Vertically_Cosited	= 0x2,
	DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes	= 0x1,
	DXVA2_VideoChromaSubsampling_MPEG2	= ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes ) ,
	DXVA2_VideoChromaSubsampling_MPEG1	= DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes,
	DXVA2_VideoChromaSubsampling_DV_PAL	= ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_Cosited ) ,
	DXVA2_VideoChromaSubsampling_Cosited	= ( ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_Cosited )  | DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes ) 
    } 	DXVA2_VideoChromaSubSampling;

typedef 
enum _DXVA2_NominalRange
    {	DXVA2_NominalRangeMask	= 0x7,
	DXVA2_NominalRange_Unknown	= 0,
	DXVA2_NominalRange_Normal	= 1,
	DXVA2_NominalRange_Wide	= 2,
	DXVA2_NominalRange_0_255	= 1,
	DXVA2_NominalRange_16_235	= 2,
	DXVA2_NominalRange_48_208	= 3
    } 	DXVA2_NominalRange;

typedef 
enum _DXVA2_VideoTransferMatrix
    {	DXVA2_VideoTransferMatrixMask	= 0x7,
	DXVA2_VideoTransferMatrix_Unknown	= 0,
	DXVA2_VideoTransferMatrix_BT709	= 1,
	DXVA2_VideoTransferMatrix_BT601	= 2,
	DXVA2_VideoTransferMatrix_SMPTE240M	= 3
    } 	DXVA2_VideoTransferMatrix;

typedef 
enum _DXVA2_VideoLighting
    {	DXVA2_VideoLightingMask	= 0xf,
	DXVA2_VideoLighting_Unknown	= 0,
	DXVA2_VideoLighting_bright	= 1,
	DXVA2_VideoLighting_office	= 2,
	DXVA2_VideoLighting_dim	= 3,
	DXVA2_VideoLighting_dark	= 4
    } 	DXVA2_VideoLighting;

typedef 
enum _DXVA2_VideoPrimaries
    {	DXVA2_VideoPrimariesMask	= 0x1f,
	DXVA2_VideoPrimaries_Unknown	= 0,
	DXVA2_VideoPrimaries_reserved	= 1,
	DXVA2_VideoPrimaries_BT709	= 2,
	DXVA2_VideoPrimaries_BT470_2_SysM	= 3,
	DXVA2_VideoPrimaries_BT470_2_SysBG	= 4,
	DXVA2_VideoPrimaries_SMPTE170M	= 5,
	DXVA2_VideoPrimaries_SMPTE240M	= 6,
	DXVA2_VideoPrimaries_EBU3213	= 7,
	DXVA2_VideoPrimaries_SMPTE_C	= 8
    } 	DXVA2_VideoPrimaries;

typedef 
enum _DXVA2_VideoTransferFunction
    {	DXVA2_VideoTransFuncMask	= 0x1f,
	DXVA2_VideoTransFunc_Unknown	= 0,
	DXVA2_VideoTransFunc_10	= 1,
	DXVA2_VideoTransFunc_18	= 2,
	DXVA2_VideoTransFunc_20	= 3,
	DXVA2_VideoTransFunc_22	= 4,
	DXVA2_VideoTransFunc_709	= 5,
	DXVA2_VideoTransFunc_240M	= 6,
	DXVA2_VideoTransFunc_sRGB	= 7,
	DXVA2_VideoTransFunc_28	= 8
    } 	DXVA2_VideoTransferFunction;

//
// Deprecated labels - please use the ones in the DXVA2_VideoTransferFunction enum.
//
#define DXVA2_VideoTransFunc_22_709         DXVA2_VideoTransFunc_709     
#define DXVA2_VideoTransFunc_22_240M        DXVA2_VideoTransFunc_240M    
#define DXVA2_VideoTransFunc_22_8bit_sRGB   DXVA2_VideoTransFunc_sRGB    
typedef struct _DXVA2_Frequency
    {
    UINT Numerator;
    UINT Denominator;
    } 	DXVA2_Frequency;

typedef struct _DXVA2_VideoDesc
    {
    UINT SampleWidth;
    UINT SampleHeight;
    DXVA2_ExtendedFormat SampleFormat;
    D3DFORMAT Format;
    DXVA2_Frequency InputSampleFreq;
    DXVA2_Frequency OutputFrameFreq;
    UINT UABProtectionLevel;
    UINT Reserved;
    } 	DXVA2_VideoDesc;


enum __MIDL___MIDL_itf_dxva2api_0000_0000_0003
    {	DXVA2_DeinterlaceTech_Unknown	= 0,
	DXVA2_DeinterlaceTech_BOBLineReplicate	= 0x1,
	DXVA2_DeinterlaceTech_BOBVerticalStretch	= 0x2,
	DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap	= 0x4,
	DXVA2_DeinterlaceTech_MedianFiltering	= 0x8,
	DXVA2_DeinterlaceTech_EdgeFiltering	= 0x10,
	DXVA2_DeinterlaceTech_FieldAdaptive	= 0x20,
	DXVA2_DeinterlaceTech_PixelAdaptive	= 0x40,
	DXVA2_DeinterlaceTech_MotionVectorSteered	= 0x80,
	DXVA2_DeinterlaceTech_InverseTelecine	= 0x100,
	DXVA2_DeinterlaceTech_Mask	= 0x1ff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0004
    {	DXVA2_NoiseFilterLumaLevel	= 1,
	DXVA2_NoiseFilterLumaThreshold	= 2,
	DXVA2_NoiseFilterLumaRadius	= 3,
	DXVA2_NoiseFilterChromaLevel	= 4,
	DXVA2_NoiseFilterChromaThreshold	= 5,
	DXVA2_NoiseFilterChromaRadius	= 6,
	DXVA2_DetailFilterLumaLevel	= 7,
	DXVA2_DetailFilterLumaThreshold	= 8,
	DXVA2_DetailFilterLumaRadius	= 9,
	DXVA2_DetailFilterChromaLevel	= 10,
	DXVA2_DetailFilterChromaThreshold	= 11,
	DXVA2_DetailFilterChromaRadius	= 12
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0005
    {	DXVA2_NoiseFilterTech_Unsupported	= 0,
	DXVA2_NoiseFilterTech_Unknown	= 0x1,
	DXVA2_NoiseFilterTech_Median	= 0x2,
	DXVA2_NoiseFilterTech_Temporal	= 0x4,
	DXVA2_NoiseFilterTech_BlockNoise	= 0x8,
	DXVA2_NoiseFilterTech_MosquitoNoise	= 0x10,
	DXVA2_NoiseFilterTech_Mask	= 0x1f
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0006
    {	DXVA2_DetailFilterTech_Unsupported	= 0,
	DXVA2_DetailFilterTech_Unknown	= 0x1,
	DXVA2_DetailFilterTech_Edge	= 0x2,
	DXVA2_DetailFilterTech_Sharpening	= 0x4,
	DXVA2_DetailFilterTech_Mask	= 0x7
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0007
    {	DXVA2_ProcAmp_None	= 0,
	DXVA2_ProcAmp_Brightness	= 0x1,
	DXVA2_ProcAmp_Contrast	= 0x2,
	DXVA2_ProcAmp_Hue	= 0x4,
	DXVA2_ProcAmp_Saturation	= 0x8,
	DXVA2_ProcAmp_Mask	= 0xf
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0008
    {	DXVA2_VideoProcess_None	= 0,
	DXVA2_VideoProcess_YUV2RGB	= 0x1,
	DXVA2_VideoProcess_StretchX	= 0x2,
	DXVA2_VideoProcess_StretchY	= 0x4,
	DXVA2_VideoProcess_AlphaBlend	= 0x8,
	DXVA2_VideoProcess_SubRects	= 0x10,
	DXVA2_VideoProcess_SubStreams	= 0x20,
	DXVA2_VideoProcess_SubStreamsExtended	= 0x40,
	DXVA2_VideoProcess_YUV2RGBExtended	= 0x80,
	DXVA2_VideoProcess_AlphaBlendExtended	= 0x100,
	DXVA2_VideoProcess_Constriction	= 0x200,
	DXVA2_VideoProcess_NoiseFilter	= 0x400,
	DXVA2_VideoProcess_DetailFilter	= 0x800,
	DXVA2_VideoProcess_PlanarAlpha	= 0x1000,
	DXVA2_VideoProcess_LinearScaling	= 0x2000,
	DXVA2_VideoProcess_GammaCompensated	= 0x4000,
	DXVA2_VideoProcess_MaintainsOriginalFieldData	= 0x8000,
	DXVA2_VideoProcess_Mask	= 0xffff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0009
    {	DXVA2_VPDev_HardwareDevice	= 0x1,
	DXVA2_VPDev_EmulatedDXVA1	= 0x2,
	DXVA2_VPDev_SoftwareDevice	= 0x4,
	DXVA2_VPDev_Mask	= 0x7
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0010
    {	DXVA2_SampleData_RFF	= 0x1,
	DXVA2_SampleData_TFF	= 0x2,
	DXVA2_SampleData_RFF_TFF_Present	= 0x4,
	DXVA2_SampleData_Mask	= 0xffff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0011
    {	DXVA2_DestData_RFF	= 0x1,
	DXVA2_DestData_TFF	= 0x2,
	DXVA2_DestData_RFF_TFF_Present	= 0x4,
	DXVA2_DestData_Mask	= 0xffff
    } ;
typedef struct _DXVA2_VideoProcessorCaps
    {
    UINT DeviceCaps;
    D3DPOOL InputPool;
    UINT NumForwardRefSamples;
    UINT NumBackwardRefSamples;
    UINT Reserved;
    UINT DeinterlaceTechnology;
    UINT ProcAmpControlCaps;
    UINT VideoProcessorOperations;
    UINT NoiseFilterTechnology;
    UINT DetailFilterTechnology;
    } 	DXVA2_VideoProcessorCaps;

#ifdef __midl
typedef LONG DXVA2_Fixed32;

#else
typedef struct _DXVA2_Fixed32
{
    union {
        struct {
            USHORT  Fraction;
            SHORT   Value;
        };
        LONG ll;
    };
} DXVA2_Fixed32;
#endif
typedef struct _DXVA2_AYUVSample8
    {
    UCHAR Cr;
    UCHAR Cb;
    UCHAR Y;
    UCHAR Alpha;
    } 	DXVA2_AYUVSample8;

typedef struct _DXVA2_AYUVSample16
    {
    USHORT Cr;
    USHORT Cb;
    USHORT Y;
    USHORT Alpha;
    } 	DXVA2_AYUVSample16;

typedef LONGLONG REFERENCE_TIME;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)
typedef struct _DXVA2_VideoSample
    {
    REFERENCE_TIME Start;
    REFERENCE_TIME End;
    DXVA2_ExtendedFormat SampleFormat;
    IDirect3DSurface9 *SrcSurface;
    RECT SrcRect;
    RECT DstRect;
    DXVA2_AYUVSample8 Pal[ 16 ];
    DXVA2_Fixed32 PlanarAlpha;
    DWORD SampleData;
    } 	DXVA2_VideoSample;

#endif  // _D3D9_H_
typedef struct _DXVA2_ValueRange
    {
    DXVA2_Fixed32 MinValue;
    DXVA2_Fixed32 MaxValue;
    DXVA2_Fixed32 DefaultValue;
    DXVA2_Fixed32 StepSize;
    } 	DXVA2_ValueRange;

typedef struct _DXVA2_ProcAmpValues
    {
    DXVA2_Fixed32 Brightness;
    DXVA2_Fixed32 Contrast;
    DXVA2_Fixed32 Hue;
    DXVA2_Fixed32 Saturation;
    } 	DXVA2_ProcAmpValues;

typedef struct _DXVA2_FilterValues
    {
    DXVA2_Fixed32 Level;
    DXVA2_Fixed32 Threshold;
    DXVA2_Fixed32 Radius;
    } 	DXVA2_FilterValues;

typedef struct _DXVA2_VideoProcessBltParams
    {
    REFERENCE_TIME TargetFrame;
    RECT TargetRect;
    SIZE ConstrictionSize;
    UINT StreamingFlags;
    DXVA2_AYUVSample16 BackgroundColor;
    DXVA2_ExtendedFormat DestFormat;
    DXVA2_ProcAmpValues ProcAmpValues;
    DXVA2_Fixed32 Alpha;
    DXVA2_FilterValues NoiseFilterLuma;
    DXVA2_FilterValues NoiseFilterChroma;
    DXVA2_FilterValues DetailFilterLuma;
    DXVA2_FilterValues DetailFilterChroma;
    DWORD DestData;
    } 	DXVA2_VideoProcessBltParams;


enum __MIDL___MIDL_itf_dxva2api_0000_0000_0012
    {	DXVA2_PictureParametersBufferType	= 0,
	DXVA2_MacroBlockControlBufferType	= 1,
	DXVA2_ResidualDifferenceBufferType	= 2,
	DXVA2_DeblockingControlBufferType	= 3,
	DXVA2_InverseQuantizationMatrixBufferType	= 4,
	DXVA2_SliceControlBufferType	= 5,
	DXVA2_BitStreamDateBufferType	= 6,
	DXVA2_MotionVectorBuffer	= 7,
	DXVA2_FilmGrainBuffer	= 8
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0013
    {	DXVA2_VideoDecoderRenderTarget	= 0,
	DXVA2_VideoProcessorRenderTarget	= 1,
	DXVA2_VideoSoftwareRenderTarget	= 2
    } ;
typedef struct _DXVA2_ConfigPictureDecode
    {
    GUID guidConfigBitstreamEncryption;
    GUID guidConfigMBcontrolEncryption;
    GUID guidConfigResidDiffEncryption;
    UINT ConfigBitstreamRaw;
    UINT ConfigMBcontrolRasterOrder;
    UINT ConfigResidDiffHost;
    UINT ConfigSpatialResid8;
    UINT ConfigResid8Subtraction;
    UINT ConfigSpatialHost8or9Clipping;
    UINT ConfigSpatialResidInterleaved;
    UINT ConfigIntraResidUnsigned;
    UINT ConfigResidDiffAccelerator;
    UINT ConfigHostInverseScan;
    UINT ConfigSpecificIDCT;
    UINT Config4GroupedCoefs;
    USHORT ConfigMinRenderTargetBuffCount;
    USHORT ConfigDecoderSpecific;
    } 	DXVA2_ConfigPictureDecode;

typedef struct _DXVA2_DecodeBufferDesc
    {
    DWORD CompressedBufferType;
    UINT BufferIndex;
    UINT DataOffset;
    UINT DataSize;
    UINT FirstMBaddress;
    UINT NumMBsInBuffer;
    UINT Width;
    UINT Height;
    UINT Stride;
    UINT ReservedBits;
    PVOID pvPVPState;
    } 	DXVA2_DecodeBufferDesc;

typedef struct _DXVA2_DecodeExtensionData
    {
    UINT Function;
    PVOID pPrivateInputData;
    UINT PrivateInputDataSize;
    PVOID pPrivateOutputData;
    UINT PrivateOutputDataSize;
    } 	DXVA2_DecodeExtensionData;

typedef struct _DXVA2_DecodeExecuteParams
    {
    UINT NumCompBuffers;
    DXVA2_DecodeBufferDesc *pCompressedBuffers;
    DXVA2_DecodeExtensionData *pExtensionData;
    } 	DXVA2_DecodeExecuteParams;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)








extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0000_v0_0_s_ifspec;

#ifndef __IDirect3DDeviceManager9_INTERFACE_DEFINED__
#define __IDirect3DDeviceManager9_INTERFACE_DEFINED__

/* interface IDirect3DDeviceManager9 */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirect3DDeviceManager9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a0cade0f-06d5-4cf4-a1c7-f3cdd725aa75")
    IDirect3DDeviceManager9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResetDevice( 
            /* [in] */ 
            __in  IDirect3DDevice9 *pDevice,
            /* [in] */ 
            __in  UINT resetToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDeviceHandle( 
            /* [out] */ 
            __out  HANDLE *phDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDeviceHandle( 
            /* [in] */ 
            __in  HANDLE hDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestDevice( 
            /* [in] */ 
            __in  HANDLE hDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockDevice( 
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [out] */ 
            __deref_out  IDirect3DDevice9 **ppDevice,
            /* [in] */ 
            __in  BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockDevice( 
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [in] */ 
            __in  BOOL fSaveState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoService( 
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [in] */ 
            __in  REFIID riid,
            /* [out] */ 
            __deref_out  void **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirect3DDeviceManager9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirect3DDeviceManager9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirect3DDeviceManager9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  IDirect3DDevice9 *pDevice,
            /* [in] */ 
            __in  UINT resetToken);
        
        HRESULT ( STDMETHODCALLTYPE *OpenDeviceHandle )( 
            IDirect3DDeviceManager9 * This,
            /* [out] */ 
            __out  HANDLE *phDevice);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDeviceHandle )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  HANDLE hDevice);
        
        HRESULT ( STDMETHODCALLTYPE *TestDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  HANDLE hDevice);
        
        HRESULT ( STDMETHODCALLTYPE *LockDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [out] */ 
            __deref_out  IDirect3DDevice9 **ppDevice,
            /* [in] */ 
            __in  BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [in] */ 
            __in  BOOL fSaveState);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoService )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ 
            __in  HANDLE hDevice,
            /* [in] */ 
            __in  REFIID riid,
            /* [out] */ 
            __deref_out  void **ppService);
        
        END_INTERFACE
    } IDirect3DDeviceManager9Vtbl;

    interface IDirect3DDeviceManager9
    {
        CONST_VTBL struct IDirect3DDeviceManager9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirect3DDeviceManager9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirect3DDeviceManager9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirect3DDeviceManager9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirect3DDeviceManager9_ResetDevice(This,pDevice,resetToken)	\
    ( (This)->lpVtbl -> ResetDevice(This,pDevice,resetToken) ) 

#define IDirect3DDeviceManager9_OpenDeviceHandle(This,phDevice)	\
    ( (This)->lpVtbl -> OpenDeviceHandle(This,phDevice) ) 

#define IDirect3DDeviceManager9_CloseDeviceHandle(This,hDevice)	\
    ( (This)->lpVtbl -> CloseDeviceHandle(This,hDevice) ) 

#define IDirect3DDeviceManager9_TestDevice(This,hDevice)	\
    ( (This)->lpVtbl -> TestDevice(This,hDevice) ) 

#define IDirect3DDeviceManager9_LockDevice(This,hDevice,ppDevice,fBlock)	\
    ( (This)->lpVtbl -> LockDevice(This,hDevice,ppDevice,fBlock) ) 

#define IDirect3DDeviceManager9_UnlockDevice(This,hDevice,fSaveState)	\
    ( (This)->lpVtbl -> UnlockDevice(This,hDevice,fSaveState) ) 

#define IDirect3DDeviceManager9_GetVideoService(This,hDevice,riid,ppService)	\
    ( (This)->lpVtbl -> GetVideoService(This,hDevice,riid,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirect3DDeviceManager9_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoAccelerationService_INTERFACE_DEFINED__
#define __IDirectXVideoAccelerationService_INTERFACE_DEFINED__

/* interface IDirectXVideoAccelerationService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoAccelerationService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a550-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoAccelerationService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ 
            __in  UINT Width,
            /* [in] */ 
            __in  UINT Height,
            /* [in] */ 
            __in  UINT BackBuffers,
            /* [in] */ 
            __in  D3DFORMAT Format,
            /* [in] */ 
            __in  D3DPOOL Pool,
            /* [in] */ 
            __in  DWORD Usage,
            /* [in] */ 
            __in  DWORD DxvaType,
            /* [size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [out][in] */ 
            __inout_opt  HANDLE *pSharedHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoAccelerationServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoAccelerationService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoAccelerationService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoAccelerationService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoAccelerationService * This,
            /* [in] */ 
            __in  UINT Width,
            /* [in] */ 
            __in  UINT Height,
            /* [in] */ 
            __in  UINT BackBuffers,
            /* [in] */ 
            __in  D3DFORMAT Format,
            /* [in] */ 
            __in  D3DPOOL Pool,
            /* [in] */ 
            __in  DWORD Usage,
            /* [in] */ 
            __in  DWORD DxvaType,
            /* [size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        END_INTERFACE
    } IDirectXVideoAccelerationServiceVtbl;

    interface IDirectXVideoAccelerationService
    {
        CONST_VTBL struct IDirectXVideoAccelerationServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoAccelerationService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoAccelerationService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoAccelerationService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoAccelerationService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoAccelerationService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoDecoderService_INTERFACE_DEFINED__
#define __IDirectXVideoDecoderService_INTERFACE_DEFINED__

/* interface IDirectXVideoDecoderService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoDecoderService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a551-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoDecoderService : public IDirectXVideoAccelerationService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDecoderDeviceGuids( 
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderRenderTargets( 
            /* [in] */ 
            __in  REFGUID Guid,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderConfigurations( 
            /* [in] */ 
            __in  REFGUID Guid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __reserved  void *pReserved,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  DXVA2_ConfigPictureDecode **ppConfigs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVideoDecoder( 
            /* [in] */ 
            __in  REFGUID Guid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  const DXVA2_ConfigPictureDecode *pConfig,
            /* [size_is][in] */ 
            __in_ecount(NumRenderTargets)  IDirect3DSurface9 **ppDecoderRenderTargets,
            /* [in] */ 
            __in  UINT NumRenderTargets,
            /* [out] */ 
            __deref_out  IDirectXVideoDecoder **ppDecode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoDecoderServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoDecoderService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoDecoderService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ 
            __in  UINT Width,
            /* [in] */ 
            __in  UINT Height,
            /* [in] */ 
            __in  UINT BackBuffers,
            /* [in] */ 
            __in  D3DFORMAT Format,
            /* [in] */ 
            __in  D3DPOOL Pool,
            /* [in] */ 
            __in  DWORD Usage,
            /* [in] */ 
            __in  DWORD DxvaType,
            /* [size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderDeviceGuids )( 
            IDirectXVideoDecoderService * This,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderRenderTargets )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ 
            __in  REFGUID Guid,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderConfigurations )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ 
            __in  REFGUID Guid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __reserved  void *pReserved,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  DXVA2_ConfigPictureDecode **ppConfigs);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoDecoder )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ 
            __in  REFGUID Guid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  const DXVA2_ConfigPictureDecode *pConfig,
            /* [size_is][in] */ 
            __in_ecount(NumRenderTargets)  IDirect3DSurface9 **ppDecoderRenderTargets,
            /* [in] */ 
            __in  UINT NumRenderTargets,
            /* [out] */ 
            __deref_out  IDirectXVideoDecoder **ppDecode);
        
        END_INTERFACE
    } IDirectXVideoDecoderServiceVtbl;

    interface IDirectXVideoDecoderService
    {
        CONST_VTBL struct IDirectXVideoDecoderServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoDecoderService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoDecoderService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoDecoderService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoDecoderService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 


#define IDirectXVideoDecoderService_GetDecoderDeviceGuids(This,pCount,pGuids)	\
    ( (This)->lpVtbl -> GetDecoderDeviceGuids(This,pCount,pGuids) ) 

#define IDirectXVideoDecoderService_GetDecoderRenderTargets(This,Guid,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetDecoderRenderTargets(This,Guid,pCount,pFormats) ) 

#define IDirectXVideoDecoderService_GetDecoderConfigurations(This,Guid,pVideoDesc,pReserved,pCount,ppConfigs)	\
    ( (This)->lpVtbl -> GetDecoderConfigurations(This,Guid,pVideoDesc,pReserved,pCount,ppConfigs) ) 

#define IDirectXVideoDecoderService_CreateVideoDecoder(This,Guid,pVideoDesc,pConfig,ppDecoderRenderTargets,NumRenderTargets,ppDecode)	\
    ( (This)->lpVtbl -> CreateVideoDecoder(This,Guid,pVideoDesc,pConfig,ppDecoderRenderTargets,NumRenderTargets,ppDecode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoDecoderService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoProcessorService_INTERFACE_DEFINED__
#define __IDirectXVideoProcessorService_INTERFACE_DEFINED__

/* interface IDirectXVideoProcessorService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoProcessorService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a552-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoProcessorService : public IDirectXVideoAccelerationService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterVideoProcessorSoftwareDevice( 
            /* [in] */ 
            __in  void *pCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorDeviceGuids( 
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorRenderTargets( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorSubStreamFormats( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCaps( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpRange( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT ProcAmpCap,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterPropertyRange( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT FilterSetting,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVideoProcessor( 
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT MaxNumSubStreams,
            /* [out] */ 
            __deref_out  IDirectXVideoProcessor **ppVidProcess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoProcessorServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoProcessorService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoProcessorService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  UINT Width,
            /* [in] */ 
            __in  UINT Height,
            /* [in] */ 
            __in  UINT BackBuffers,
            /* [in] */ 
            __in  D3DFORMAT Format,
            /* [in] */ 
            __in  D3DPOOL Pool,
            /* [in] */ 
            __in  DWORD Usage,
            /* [in] */ 
            __in  DWORD DxvaType,
            /* [size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterVideoProcessorSoftwareDevice )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  void *pCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorDeviceGuids )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorRenderTargets )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorSubStreamFormats )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [out] */ 
            __out  UINT *pCount,
            /* [size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCaps )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpRange )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT ProcAmpCap,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterPropertyRange )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT FilterSetting,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoProcessor )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [in] */ 
            __in  UINT MaxNumSubStreams,
            /* [out] */ 
            __deref_out  IDirectXVideoProcessor **ppVidProcess);
        
        END_INTERFACE
    } IDirectXVideoProcessorServiceVtbl;

    interface IDirectXVideoProcessorService
    {
        CONST_VTBL struct IDirectXVideoProcessorServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoProcessorService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoProcessorService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoProcessorService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoProcessorService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 


#define IDirectXVideoProcessorService_RegisterVideoProcessorSoftwareDevice(This,pCallbacks)	\
    ( (This)->lpVtbl -> RegisterVideoProcessorSoftwareDevice(This,pCallbacks) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(This,pVideoDesc,pCount,pGuids)	\
    ( (This)->lpVtbl -> GetVideoProcessorDeviceGuids(This,pVideoDesc,pCount,pGuids) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(This,VideoProcDeviceGuid,pVideoDesc,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorRenderTargets(This,VideoProcDeviceGuid,pVideoDesc,pCount,pFormats) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorSubStreamFormats(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorSubStreamFormats(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCount,pFormats) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorCaps(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorCaps(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCaps) ) 

#define IDirectXVideoProcessorService_GetProcAmpRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,ProcAmpCap,pRange)	\
    ( (This)->lpVtbl -> GetProcAmpRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,ProcAmpCap,pRange) ) 

#define IDirectXVideoProcessorService_GetFilterPropertyRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,FilterSetting,pRange)	\
    ( (This)->lpVtbl -> GetFilterPropertyRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,FilterSetting,pRange) ) 

#define IDirectXVideoProcessorService_CreateVideoProcessor(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,MaxNumSubStreams,ppVidProcess)	\
    ( (This)->lpVtbl -> CreateVideoProcessor(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,MaxNumSubStreams,ppVidProcess) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoProcessorService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoDecoder_INTERFACE_DEFINED__
#define __IDirectXVideoDecoder_INTERFACE_DEFINED__

/* interface IDirectXVideoDecoder */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoDecoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f2b0810a-fd00-43c9-918c-df94e2d8ef7d")
    IDirectXVideoDecoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoDecoderService( 
            /* [out] */ 
            __deref_out  IDirectXVideoDecoderService **ppService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreationParameters( 
            /* [out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out_opt  DXVA2_ConfigPictureDecode *pConfig,
            /* [size_is][unique][out] */ 
            __out_ecount(*pNumSurfaces)  IDirect3DSurface9 ***pDecoderRenderTargets,
            /* [out] */ 
            __out_opt  UINT *pNumSurfaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ 
            __in  UINT BufferType,
            /* [out] */ 
            __out  void **ppBuffer,
            /* [out] */ 
            __out  UINT *pBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ 
            __in  UINT BufferType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFrame( 
            /* [in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [in] */ 
            __in_opt  void *pvPVPData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFrame( 
            /* [out] */ 
            __inout_opt  HANDLE *pHandleComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ 
            __in  const DXVA2_DecodeExecuteParams *pExecuteParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoDecoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoDecoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoDecoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoDecoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoDecoderService )( 
            IDirectXVideoDecoder * This,
            /* [out] */ 
            __deref_out  IDirectXVideoDecoderService **ppService);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreationParameters )( 
            IDirectXVideoDecoder * This,
            /* [out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out_opt  DXVA2_ConfigPictureDecode *pConfig,
            /* [size_is][unique][out] */ 
            __out_ecount(*pNumSurfaces)  IDirect3DSurface9 ***pDecoderRenderTargets,
            /* [out] */ 
            __out_opt  UINT *pNumSurfaces);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IDirectXVideoDecoder * This,
            /* [in] */ 
            __in  UINT BufferType,
            /* [out] */ 
            __out  void **ppBuffer,
            /* [out] */ 
            __out  UINT *pBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IDirectXVideoDecoder * This,
            /* [in] */ 
            __in  UINT BufferType);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFrame )( 
            IDirectXVideoDecoder * This,
            /* [in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [in] */ 
            __in_opt  void *pvPVPData);
        
        HRESULT ( STDMETHODCALLTYPE *EndFrame )( 
            IDirectXVideoDecoder * This,
            /* [out] */ 
            __inout_opt  HANDLE *pHandleComplete);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDirectXVideoDecoder * This,
            /* [in] */ 
            __in  const DXVA2_DecodeExecuteParams *pExecuteParams);
        
        END_INTERFACE
    } IDirectXVideoDecoderVtbl;

    interface IDirectXVideoDecoder
    {
        CONST_VTBL struct IDirectXVideoDecoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoDecoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoDecoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoDecoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoDecoder_GetVideoDecoderService(This,ppService)	\
    ( (This)->lpVtbl -> GetVideoDecoderService(This,ppService) ) 

#define IDirectXVideoDecoder_GetCreationParameters(This,pDeviceGuid,pVideoDesc,pConfig,pDecoderRenderTargets,pNumSurfaces)	\
    ( (This)->lpVtbl -> GetCreationParameters(This,pDeviceGuid,pVideoDesc,pConfig,pDecoderRenderTargets,pNumSurfaces) ) 

#define IDirectXVideoDecoder_GetBuffer(This,BufferType,ppBuffer,pBufferSize)	\
    ( (This)->lpVtbl -> GetBuffer(This,BufferType,ppBuffer,pBufferSize) ) 

#define IDirectXVideoDecoder_ReleaseBuffer(This,BufferType)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,BufferType) ) 

#define IDirectXVideoDecoder_BeginFrame(This,pRenderTarget,pvPVPData)	\
    ( (This)->lpVtbl -> BeginFrame(This,pRenderTarget,pvPVPData) ) 

#define IDirectXVideoDecoder_EndFrame(This,pHandleComplete)	\
    ( (This)->lpVtbl -> EndFrame(This,pHandleComplete) ) 

#define IDirectXVideoDecoder_Execute(This,pExecuteParams)	\
    ( (This)->lpVtbl -> Execute(This,pExecuteParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoDecoder_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoProcessor_INTERFACE_DEFINED__
#define __IDirectXVideoProcessor_INTERFACE_DEFINED__

/* interface IDirectXVideoProcessor */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c3a39f0-916e-4690-804f-4c8001355d25")
    IDirectXVideoProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorService( 
            /* [out] */ 
            __deref_out  IDirectXVideoProcessorService **ppService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreationParameters( 
            /* [out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out_opt  D3DFORMAT *pRenderTargetFormat,
            /* [out] */ 
            __out_opt  UINT *pMaxNumSubStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCaps( 
            /* [out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpRange( 
            /* [in] */ 
            __in  UINT ProcAmpCap,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterPropertyRange( 
            /* [in] */ 
            __in  UINT FilterSetting,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoProcessBlt( 
            /* [in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [in] */ 
            __in  const DXVA2_VideoProcessBltParams *pBltParams,
            /* [size_is][in] */ 
            __in_ecount(NumSamples)  const DXVA2_VideoSample *pSamples,
            /* [in] */ 
            __in  UINT NumSamples,
            /* [out] */ 
            __inout_opt  HANDLE *pHandleComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorService )( 
            IDirectXVideoProcessor * This,
            /* [out] */ 
            __deref_out  IDirectXVideoProcessorService **ppService);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreationParameters )( 
            IDirectXVideoProcessor * This,
            /* [out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [out] */ 
            __out_opt  D3DFORMAT *pRenderTargetFormat,
            /* [out] */ 
            __out_opt  UINT *pMaxNumSubStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCaps )( 
            IDirectXVideoProcessor * This,
            /* [out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpRange )( 
            IDirectXVideoProcessor * This,
            /* [in] */ 
            __in  UINT ProcAmpCap,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterPropertyRange )( 
            IDirectXVideoProcessor * This,
            /* [in] */ 
            __in  UINT FilterSetting,
            /* [out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *VideoProcessBlt )( 
            IDirectXVideoProcessor * This,
            /* [in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [in] */ 
            __in  const DXVA2_VideoProcessBltParams *pBltParams,
            /* [size_is][in] */ 
            __in_ecount(NumSamples)  const DXVA2_VideoSample *pSamples,
            /* [in] */ 
            __in  UINT NumSamples,
            /* [out] */ 
            __inout_opt  HANDLE *pHandleComplete);
        
        END_INTERFACE
    } IDirectXVideoProcessorVtbl;

    interface IDirectXVideoProcessor
    {
        CONST_VTBL struct IDirectXVideoProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoProcessor_GetVideoProcessorService(This,ppService)	\
    ( (This)->lpVtbl -> GetVideoProcessorService(This,ppService) ) 

#define IDirectXVideoProcessor_GetCreationParameters(This,pDeviceGuid,pVideoDesc,pRenderTargetFormat,pMaxNumSubStreams)	\
    ( (This)->lpVtbl -> GetCreationParameters(This,pDeviceGuid,pVideoDesc,pRenderTargetFormat,pMaxNumSubStreams) ) 

#define IDirectXVideoProcessor_GetVideoProcessorCaps(This,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorCaps(This,pCaps) ) 

#define IDirectXVideoProcessor_GetProcAmpRange(This,ProcAmpCap,pRange)	\
    ( (This)->lpVtbl -> GetProcAmpRange(This,ProcAmpCap,pRange) ) 

#define IDirectXVideoProcessor_GetFilterPropertyRange(This,FilterSetting,pRange)	\
    ( (This)->lpVtbl -> GetFilterPropertyRange(This,FilterSetting,pRange) ) 

#define IDirectXVideoProcessor_VideoProcessBlt(This,pRenderTarget,pBltParams,pSamples,NumSamples,pHandleComplete)	\
    ( (This)->lpVtbl -> VideoProcessBlt(This,pRenderTarget,pBltParams,pSamples,NumSamples,pHandleComplete) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoProcessor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxva2api_0000_0006 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_dxva2api_0000_0006_0001
    {	DXVA2_SurfaceType_DecoderRenderTarget	= 0,
	DXVA2_SurfaceType_ProcessorRenderTarget	= 1,
	DXVA2_SurfaceType_D3DRenderTargetTexture	= 2
    } 	DXVA2_SurfaceType;



extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0006_v0_0_s_ifspec;

#ifndef __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__
#define __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__

/* interface IDirectXVideoMemoryConfiguration */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoMemoryConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7f916dd-db3b-49c1-84d7-e45ef99ec726")
    IDirectXVideoMemoryConfiguration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAvailableSurfaceTypeByIndex( 
            /* [in] */ 
            __in  DWORD dwTypeIndex,
            /* [out] */ 
            __out  DXVA2_SurfaceType *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurfaceType( 
            /* [in] */ 
            __in  DXVA2_SurfaceType dwType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoMemoryConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoMemoryConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoMemoryConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableSurfaceTypeByIndex )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [in] */ 
            __in  DWORD dwTypeIndex,
            /* [out] */ 
            __out  DXVA2_SurfaceType *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurfaceType )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [in] */ 
            __in  DXVA2_SurfaceType dwType);
        
        END_INTERFACE
    } IDirectXVideoMemoryConfigurationVtbl;

    interface IDirectXVideoMemoryConfiguration
    {
        CONST_VTBL struct IDirectXVideoMemoryConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoMemoryConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoMemoryConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoMemoryConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoMemoryConfiguration_GetAvailableSurfaceTypeByIndex(This,dwTypeIndex,pdwType)	\
    ( (This)->lpVtbl -> GetAvailableSurfaceTypeByIndex(This,dwTypeIndex,pdwType) ) 

#define IDirectXVideoMemoryConfiguration_SetSurfaceType(This,dwType)	\
    ( (This)->lpVtbl -> SetSurfaceType(This,dwType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxva2api_0000_0007 */
/* [local] */ 

STDAPI DXVA2CreateDirect3DDeviceManager9(
    __out UINT* pResetToken,
    __deref_out IDirect3DDeviceManager9** ppDeviceManager
    );
STDAPI DXVA2CreateVideoService(
    __in IDirect3DDevice9* pDD,
    __in REFIID riid,
    __deref_out void** ppService
    );
#endif  // _D3D9_H_
__inline DXVA2_Fixed32 DXVA2FloatToFixed(__in const float _float_)
{
    DXVA2_Fixed32 _fixed_;
    _fixed_.Fraction = LOWORD(_float_ * 0x10000);
    _fixed_.Value = HIWORD(_float_ * 0x10000);
    return _fixed_;
}
__inline float DXVA2FixedToFloat(__in const DXVA2_Fixed32 _fixed_)
{
    return (FLOAT)_fixed_.Value + (FLOAT)_fixed_.Fraction / 0x10000;
}
__inline const DXVA2_Fixed32 DXVA2_Fixed32TransparentAlpha()
{
    DXVA2_Fixed32 _fixed_ = {0, 0};
    return _fixed_;
}
__inline const DXVA2_Fixed32 DXVA2_Fixed32OpaqueAlpha()
{
    DXVA2_Fixed32 _fixed_ = {0, 1};
    return _fixed_;
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eapauthenticatortypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for eapauthenticatortypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __eapauthenticatortypes_h__
#define __eapauthenticatortypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_eapauthenticatortypes_0000_0000 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum _EAP_AUTHENTICATOR_SEND_TIMEOUT
    {	EAP_AUTHENTICATOR_SEND_TIMEOUT_NONE	= 0,
	EAP_AUTHENTICATOR_SEND_TIMEOUT_BASIC	= ( EAP_AUTHENTICATOR_SEND_TIMEOUT_NONE + 1 ) ,
	EAP_AUTHENTICATOR_SEND_TIMEOUT_INTERACTIVE	= ( EAP_AUTHENTICATOR_SEND_TIMEOUT_BASIC + 1 ) 
    } 	EAP_AUTHENTICATOR_SEND_TIMEOUT;



extern RPC_IF_HANDLE __MIDL_itf_eapauthenticatortypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_eapauthenticatortypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxva.h ===
//------------------------------------------------------------------------------
// File: DXVA.h
//
// Desc: DirectX Video Acceleration header file.
//
// Copyright (c) 1999 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __DIRECTX_VA_COPP_ONLY
#define __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_DEINTERLACE__
#endif

#ifndef DXVABit
#define DXVABit(__x) (1 << __x)
#endif

// -------------------------------------------------------------------------
//
// The definitions that follow describe the DirectX Video Acceleration
// decoding interface.
// This interface is accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_DECODER__

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeH264_A,  0x1b81be64, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_B,  0x1b81be65, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_C,  0x1b81be66, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_D,  0x1b81be67, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_E,  0x1b81be68, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_F,  0x1b81be69, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV8_A,  0x1b81be80, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV8_B,  0x1b81be81, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV9_A,  0x1b81be90, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_B,  0x1b81be91, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_C,  0x1b81be94, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeVC1_A,   0x1b81beA0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_B,   0x1b81beA1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_C,   0x1b81beA2, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_D,   0x1b81beA3, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_ModeWMV8_PostProc                  DXVA_ModeWMV8_A
#define DXVA_ModeWMV8_MoComp                    DXVA_ModeWMV8_B

#define DXVA_ModeWMV9_PostProc                  DXVA_ModeWMV9_A
#define DXVA_ModeWMV9_MoComp                    DXVA_ModeWMV9_B
#define DXVA_ModeWMV9_IDCT                      DXVA_ModeWMV9_C

#define DXVA_ModeVC1_PostProc                   DXVA_ModeVC1_A
#define DXVA_ModeVC1_MoComp                     DXVA_ModeVC1_B
#define DXVA_ModeVC1_IDCT                       DXVA_ModeVC1_C
#define DXVA_ModeVC1_VLD                        DXVA_ModeVC1_D

#define DXVA_ModeH264_MoComp_NoFGT              DXVA_ModeH264_A
#define DXVA_ModeH264_MoComp_FGT                DXVA_ModeH264_B
#define DXVA_ModeH264_IDCT_NoFGT                DXVA_ModeH264_C
#define DXVA_ModeH264_IDCT_FGT                  DXVA_ModeH264_D
#define DXVA_ModeH264_VLD_NoFGT                 DXVA_ModeH264_E
#define DXVA_ModeH264_VLD_FGT                   DXVA_ModeH264_F

#define DXVA_RESTRICTED_MODE_UNRESTRICTED       0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A             1
#define DXVA_RESTRICTED_MODE_H261_B             2

#define DXVA_RESTRICTED_MODE_H263_A             3
#define DXVA_RESTRICTED_MODE_H263_B             4
#define DXVA_RESTRICTED_MODE_H263_C             5
#define DXVA_RESTRICTED_MODE_H263_D             6
#define DXVA_RESTRICTED_MODE_H263_E             7
#define DXVA_RESTRICTED_MODE_H263_F             8

#define DXVA_RESTRICTED_MODE_MPEG1_A            9

#define DXVA_RESTRICTED_MODE_MPEG2_A            0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B            0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C            0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D            0xD

#define DXVA_RESTRICTED_MODE_H264_A             0x64
#define DXVA_RESTRICTED_MODE_H264_B             0x65
#define DXVA_RESTRICTED_MODE_H264_C             0x66
#define DXVA_RESTRICTED_MODE_H264_D             0x67
#define DXVA_RESTRICTED_MODE_H264_E             0x68
#define DXVA_RESTRICTED_MODE_H264_F             0x69

#define DXVA_RESTRICTED_MODE_WMV8_A             0x80
#define DXVA_RESTRICTED_MODE_WMV8_B             0x81

#define DXVA_RESTRICTED_MODE_WMV9_A             0x90
#define DXVA_RESTRICTED_MODE_WMV9_B             0x91
#define DXVA_RESTRICTED_MODE_WMV9_C             0x94

#define DXVA_RESTRICTED_MODE_VC1_A              0xA0
#define DXVA_RESTRICTED_MODE_VC1_B              0xA1
#define DXVA_RESTRICTED_MODE_VC1_C              0xA2
#define DXVA_RESTRICTED_MODE_VC1_D              0xA3

#define DXVA_RESTRICTED_MODE_WMV8_POSTPROC      DXVA_RESTRICTED_MODE_WMV8_A
#define DXVA_RESTRICTED_MODE_WMV8_MOCOMP        DXVA_RESTRICTED_MODE_WMV8_B

#define DXVA_RESTRICTED_MODE_WMV9_POSTPROC      DXVA_RESTRICTED_MODE_WMV9_A
#define DXVA_RESTRICTED_MODE_WMV9_MOCOMP        DXVA_RESTRICTED_MODE_WMV9_B
#define DXVA_RESTRICTED_MODE_WMV9_IDCT          DXVA_RESTRICTED_MODE_WMV9_C

#define DXVA_RESTRICTED_MODE_VC1_POSTPROC       DXVA_RESTRICTED_MODE_VC1_A
#define DXVA_RESTRICTED_MODE_VC1_MOCOMP         DXVA_RESTRICTED_MODE_VC1_B
#define DXVA_RESTRICTED_MODE_VC1_IDCT           DXVA_RESTRICTED_MODE_VC1_C
#define DXVA_RESTRICTED_MODE_VC1_VLD            DXVA_RESTRICTED_MODE_VC1_D

#define DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT  DXVA_RESTRICTED_MODE_H264_A
#define DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT    DXVA_RESTRICTED_MODE_H264_B
#define DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT    DXVA_RESTRICTED_MODE_H264_C
#define DXVA_RESTRICTED_MODE_H264_IDCT_FGT      DXVA_RESTRICTED_MODE_H264_D
#define DXVA_RESTRICTED_MODE_H264_VLD_NOFGT     DXVA_RESTRICTED_MODE_H264_E
#define DXVA_RESTRICTED_MODE_H264_VLD_FGT       DXVA_RESTRICTED_MODE_H264_F

#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

/* H.264/AVC Additional buffer types */
#define DXVA_MOTION_VECTOR_BUFFER               16
#define DXVA_FILM_GRAIN_BUFFER                  17

#define DXVA_NUM_TYPES_COMP_BUFFERS             18

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4
#define DXVA_DEBLOCKING_FILTER_FUNCTION       5
#define DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION    6
#define DXVA_STATUS_REPORTING_FUNCTION        7

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;



/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample2 {
  BYTE bCrValue;
  BYTE bCbValue;
  BYTE bY_Value;
  BYTE bSampleAlpha8;
} DXVA_AYUVsample2, *LPDXVA_AYUVsample2;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample2 OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;

/* H.264/AVC-specific structures */

/* H.264/AVC picture entry data structure */
typedef struct _DXVA_PicEntry_H264 {
  union {
    struct {
      UCHAR  Index7Bits      : 7;
      UCHAR  AssociatedFlag  : 1;
    };
    UCHAR  bPicEntry;
  };
} DXVA_PicEntry_H264, *LPDXVA_PicEntry_H264;  /* 1 byte */

/* H.264/AVC picture parameters structure */
typedef struct _DXVA_PicParams_H264 {
  USHORT  wFrameWidthInMbsMinus1;
  USHORT  wFrameHeightInMbsMinus1;
  DXVA_PicEntry_H264  CurrPic; /* flag is bot field flag */
  UCHAR   num_ref_frames;

  union {
    struct {
      USHORT  field_pic_flag                 : 1;
      USHORT  MbaffFrameFlag                 : 1;
      USHORT  residual_colour_transform_flag : 1;
      USHORT  sp_for_switch_flag             : 1;
      USHORT  chroma_format_idc              : 2;
      USHORT  RefPicFlag                     : 1;
      USHORT  constrained_intra_pred_flag    : 1;

      USHORT  weighted_pred_flag             : 1;
      USHORT  weighted_bipred_idc            : 2;
      USHORT  MbsConsecutiveFlag             : 1;
      USHORT  frame_mbs_only_flag            : 1;
      USHORT  transform_8x8_mode_flag        : 1;
      USHORT  MinLumaBipredSize8x8Flag       : 1;
      USHORT  IntraPicFlag                   : 1;
    };
    USHORT  wBitFields;
  };
  UCHAR  bit_depth_luma_minus8;
  UCHAR  bit_depth_chroma_minus8;

  USHORT Reserved16Bits;
  UINT   StatusReportFeedbackNumber;

  DXVA_PicEntry_H264  RefFrameList[16]; /* flag LT */
  INT    CurrFieldOrderCnt[2];
  INT    FieldOrderCntList[16][2];

  CHAR   pic_init_qs_minus26;
  CHAR   chroma_qp_index_offset;   /* also used for QScb */
  CHAR   second_chroma_qp_index_offset; /* also for QScr */
  UCHAR  ContinuationFlag;

/* remainder for parsing */
  CHAR   pic_init_qp_minus26;
  UCHAR  num_ref_idx_l0_active_minus1;
  UCHAR  num_ref_idx_l1_active_minus1;
  UCHAR  Reserved8BitsA;

  USHORT FrameNumList[16];
  UINT   UsedForReferenceFlags;
  USHORT NonExistingFrameFlags;
  USHORT frame_num;

  UCHAR  log2_max_frame_num_minus4;
  UCHAR  pic_order_cnt_type;
  UCHAR  log2_max_pic_order_cnt_lsb_minus4;
  UCHAR  delta_pic_order_always_zero_flag;

  UCHAR  direct_8x8_inference_flag;
  UCHAR  entropy_coding_mode_flag;
  UCHAR  pic_order_present_flag;
  UCHAR  num_slice_groups_minus1;

  UCHAR  slice_group_map_type;
  UCHAR  deblocking_filter_control_present_flag;
  UCHAR  redundant_pic_cnt_present_flag;
  UCHAR  Reserved8BitsB;

  USHORT slice_group_change_rate_minus1;

  UCHAR  SliceGroupMap[810]; /* 4b/sgmu, Size BT.601 */

} DXVA_PicParams_H264, *LPDXVA_PicParams_H264;

/* H.264/AVC quantization weighting matrix data structure */
typedef struct _DXVA_Qmatrix_H264 {
  UCHAR  bScalingLists4x4[6][16];
  UCHAR  bScalingLists8x8[2][64];

} DXVA_Qmatrix_H264, *LPDXVA_Qmatrix_H264;

/* H.264/AVC slice control data structure - short form */
typedef struct _DXVA_Slice_H264_Short {
  UINT   BSNALunitDataLocation; /* type 1..5 */
  UINT   SliceBytesInBuffer; /* for off-host parse */
  USHORT wBadSliceChopping;  /* for off-host parse */
} DXVA_Slice_H264_Short, *LPDXVA_Slice_H264_Short;

/* H.264/AVC picture entry data structure - long form */
typedef struct _DXVA_Slice_H264_Long {
  UINT   BSNALunitDataLocation; /* type 1..5 */
  UINT   SliceBytesInBuffer; /* for off-host parse */
  USHORT wBadSliceChopping;  /* for off-host parse */

  USHORT first_mb_in_slice;
  USHORT NumMbsForSlice;

  USHORT BitOffsetToSliceData; /* after CABAC alignment */

  UCHAR  slice_type;
  UCHAR  luma_log2_weight_denom;
  UCHAR  chroma_log2_weight_denom;
  UCHAR  num_ref_idx_l0_active_minus1;
  UCHAR  num_ref_idx_l1_active_minus1;
  CHAR   slice_alpha_c0_offset_div2;
  CHAR   slice_beta_offset_div2;
  UCHAR  Reserved8Bits;
  DXVA_PicEntry_H264 RefPicList[2][32]; /* L0 & L1 */
  SHORT  Weights[2][32][3][2]; /* L0 & L1; Y, Cb, Cr */
  CHAR   slice_qs_delta;
                               /* rest off-host parse */
  CHAR   slice_qp_delta;
  UCHAR  redundant_pic_cnt;
  UCHAR  direct_spatial_mv_pred_flag;
  UCHAR  cabac_init_idc;
  UCHAR  disable_deblocking_filter_idc;
  USHORT slice_id;
} DXVA_Slice_H264_Long, *LPDXVA_Slice_H264_Long;

/* H.264/AVC macroblock control command data structure */
typedef struct _DXVA_MBctrl_H264 {
  union {
    struct {
      UINT  bSliceID                : 8;   /* 1 byte */
      UINT  MbType5Bits             : 5;
      UINT  IntraMbFlag             : 1;
      UINT  mb_field_decoding_flag  : 1;
      UINT  transform_size_8x8_flag : 1;   /* 2 bytes */
      UINT  HostResidDiff           : 1;
      UINT  DcBlockCodedCrFlag      : 1;
      UINT  DcBlockCodedCbFlag      : 1;
      UINT  DcBlockCodedYFlag       : 1;
      UINT  FilterInternalEdgesFlag : 1;
      UINT  FilterLeftMbEdgeFlag    : 1;
      UINT  FilterTopMbEdgeFlag     : 1;
      UINT  ReservedBit             : 1;
      UINT  bMvQuantity             : 8;   /* 4 bytes */
    };
    UINT  dwMBtype;                    /* 4 bytes so far */
  };
  USHORT  CurrMbAddr;                  /* 6 bytes so far */
  USHORT  wPatternCode[3];/* YCbCr, 16 4x4 blks, 1b each */
                                      /* 12 bytes so far */
  UCHAR   bQpPrime[3];    /* Y, Cb, Cr, need just 7b QpY */
  UCHAR   bMBresidDataQuantity;
  ULONG   dwMBdataLocation;  /* offset into resid buffer */
                                      /* 20 bytes so far */
  union {
    struct {
/* start here for Intra MB's  (9 useful bytes in branch) */
      USHORT LumaIntraPredModes[4];/* 16 blocks, 4b each */
                                      /* 28 bytes so far */
      union {
        struct {
          UCHAR  intra_chroma_pred_mode : 2;
          UCHAR  IntraPredAvailFlags    : 5;
          UCHAR  ReservedIntraBit       : 1;
        };
        UCHAR  bMbIntraStruct;        /* 29 bytes so far */
      };
      UCHAR ReservedIntra24Bits[3];   /* 32 bytes total  */
    };
    struct {
/* start here for non-Intra MB's (12 bytes in branch)    */
      UCHAR  bSubMbShapes;          /* 4 subMbs, 2b each */
      UCHAR  bSubMbPredModes;       /* 4 subMBs, 2b each */
                                      /* 22 bytes so far */
      USHORT wMvBuffOffset;     /* offset into MV buffer */
      UCHAR  bRefPicSelect[2][4];     /* 32 bytes total */
    };
  };
} DXVA_MBctrl_H264, *LPDXVA_MBctrl_H264;

/* H.264/AVC IndexA and IndexB data structure */
typedef struct _DXVA_DeblockIndexAB_H264 {
  UCHAR  bIndexAinternal; /* 6b - could get from MB CC */
  UCHAR  bIndexBinternal; /* 6b - could get from MB CC */

  UCHAR  bIndexAleft0;
  UCHAR  bIndexBleft0;

  UCHAR  bIndexAleft1;
  UCHAR  bIndexBleft1;

  UCHAR  bIndexAtop0;
  UCHAR  bIndexBtop0;

  UCHAR  bIndexAtop1;
  UCHAR  bIndexBtop1;
} DXVA_DeblockIndexAB_H264, *LPDXVA_DeblockIndexAB_H264;
                                /* 10 bytes in struct */

/* H.264/AVC deblocking filter control data structure */
typedef struct _DXVA_Deblock_H264 {
  USHORT  CurrMbAddr; /* dup info */   /* 2 bytes so far */
  union {
    struct {
      UCHAR  ReservedBit                : 1;
      UCHAR  FieldModeCurrentMbFlag     : 1; /* dup info */
      UCHAR  FieldModeLeftMbFlag        : 1;
      UCHAR  FieldModeAboveMbFlag       : 1;
      UCHAR  FilterInternal8x8EdgesFlag : 1;
      UCHAR  FilterInternal4x4EdgesFlag : 1;
      UCHAR  FilterLeftMbEdgeFlag       : 1;
      UCHAR  FilterTopMbEdgeFlag        : 1;
    };
    UCHAR  FirstByte;
  };
  UCHAR  Reserved8Bits;      /* 4 bytes so far */

  UCHAR  bbSinternalLeftVert; /* 2 bits per bS */
  UCHAR  bbSinternalMidVert;

  UCHAR  bbSinternalRightVert;
  UCHAR  bbSinternalTopHorz;  /* 8 bytes so far */

  UCHAR  bbSinternalMidHorz;
  UCHAR  bbSinternalBotHorz;       /* 10 bytes so far */

  USHORT wbSLeft0; /* 4 bits per bS (1 wasted) */
  USHORT wbSLeft1; /* 4 bits per bS (1 wasted) */

  USHORT wbSTop0;  /* 4 bits per bS (1 wasted) */
  USHORT wbSTop1;  /* 4b (2 wasted)  18 bytes so far*/

  DXVA_DeblockIndexAB_H264  IndexAB[3]; /* Y, Cb, Cr */

} DXVA_Deblock_H264, *LPDXVA_Deblock_H264;/* 48 bytes */

/* H.264/AVC film grain characteristics data structure */
typedef struct _DXVA_FilmGrainCharacteristics {

  USHORT  wFrameWidthInMbsMinus1;
  USHORT  wFrameHeightInMbsMinus1;

  DXVA_PicEntry_H264  InPic; /* flag is bot field flag */
  DXVA_PicEntry_H264  OutPic; /* flag is field pic flag */

  USHORT PicOrderCnt_offset;
  INT    CurrPicOrderCnt;
  UINT   StatusReportFeedbackNumber;

  UCHAR model_id;
  UCHAR separate_colour_description_present_flag;
  UCHAR film_grain_bit_depth_luma_minus8;
  UCHAR film_grain_bit_depth_chroma_minus8;

  UCHAR film_grain_full_range_flag;
  UCHAR film_grain_colour_primaries;
  UCHAR film_grain_transfer_characteristics;
  UCHAR film_grain_matrix_coefficients;

  UCHAR blending_mode_id;
  UCHAR log2_scale_factor;

  UCHAR comp_model_present_flag[4];
  UCHAR num_intensity_intervals_minus1[4];
  UCHAR num_model_values_minus1[4];

  UCHAR intensity_interval_lower_bound[3][16];
  UCHAR intensity_interval_upper_bound[3][16];
  SHORT comp_model_value[3][16][8];
} DXVA_FilmGrainChar_H264, *LPDXVA_FilmGrainChar_H264;

/* H.264/AVC status reporting data structure */
typedef struct _DXVA_Status_H264 {
  UINT   StatusReportFeedbackNumber;
  DXVA_PicEntry_H264  CurrPic; /* flag is bot field flag */
  UCHAR  field_pic_flag;
  UCHAR  bDXVA_Func;
  UCHAR  bBufType;
  UCHAR  bStatus;
  UCHAR  bReserved8Bits;
  USHORT wNumMbsAffected;
} DXVA_Status_H264, *LPDXVA_Status_H264;

/* VC-1 status reporting data structure */
typedef struct _DXVA_Status_VC1 {
  USHORT StatusReportFeedbackNumber;
  WORD   wDecodedPictureIndex;
  WORD   wDeblockedPictureIndex;
  UCHAR  bPicStructure;
  UCHAR  bBufType;
  UCHAR  bStatus;
  UCHAR  bReserved8Bits;
  USHORT wNumMbsAffected;
} DXVA_Status_VC1, *LPDXVA_Status_VC1;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)
#endif  /*   __DIRECTX_VA_DECODER__   */


// -------------------------------------------------------------------------
//
// D3DFORMAT describes a pixel memory layout, DXVA sample format contains
// additional information that describes how the pixels should be interpreted.
//
// DXVA Extended color data - occupies the SampleFormat DWORD
// data fields.
// -------------------------------------------------------------------------
#ifndef __DIRECTX_VA_SAMPLEFORMAT__
#define __DIRECTX_VA_SAMPLEFORMAT__

typedef enum _DXVA_SampleFormat {
    DXVA_SampleFormatMask = 0xFF,   // 8 bits used for DXVA Sample format
    DXVA_SampleUnknown = 0,
    DXVA_SamplePreviousFrame = 1,
    DXVA_SampleProgressiveFrame = 2,
    DXVA_SampleFieldInterleavedEvenFirst = 3,
    DXVA_SampleFieldInterleavedOddFirst = 4,
    DXVA_SampleFieldSingleEven = 5,
    DXVA_SampleFieldSingleOdd = 6,
    DXVA_SampleSubStream = 7
} DXVA_SampleFormat;

#define DXVA_ExtractSampleFormat(_sf) ((_sf) & (DXVA_SampleFormatMask))

#define DXVA_ExtractExtColorData(_sf, _Mask, _Shift) \
    (((_sf) & (_Mask)) >> (_Shift))

#define DXVABitMask(__n) (~((~0) << __n))
#define DXVA_ExtColorData_ShiftBase 8
#define DXVAColorMask(__bits,__base) (DXVABitMask(__bits) << (__base))

typedef enum _DXVA_VideoTransferFunction
{
    DXVA_VideoTransFuncShift = (DXVA_ExtColorData_ShiftBase + 19),
    DXVA_VideoTransFuncMask = DXVAColorMask(5, DXVA_VideoTransFuncShift),

    DXVA_VideoTransFunc_Unknown = 0,
    DXVA_VideoTransFunc_10 = 1,
    DXVA_VideoTransFunc_18 = 2,
    DXVA_VideoTransFunc_20 = 3,
    DXVA_VideoTransFunc_22 = 4,
    DXVA_VideoTransFunc_22_709  = 5,
    DXVA_VideoTransFunc_22_240M = 6,
    DXVA_VideoTransFunc_22_8bit_sRGB = 7,
    DXVA_VideoTransFunc_28 = 8
} DXVA_VideoTransferFunction;

typedef enum _DXVA_VideoPrimaries
{
    DXVA_VideoPrimariesShift = (DXVA_ExtColorData_ShiftBase + 14),
    DXVA_VideoPrimariesMask = DXVAColorMask(5, DXVA_VideoPrimariesShift),

    DXVA_VideoPrimaries_Unknown = 0,
    DXVA_VideoPrimaries_reserved = 1,
    DXVA_VideoPrimaries_BT709 = 2,
    DXVA_VideoPrimaries_BT470_2_SysM = 3,
    DXVA_VideoPrimaries_BT470_2_SysBG = 4,
    DXVA_VideoPrimaries_SMPTE170M = 5,
    DXVA_VideoPrimaries_SMPTE240M = 6,
    DXVA_VideoPrimaries_EBU3213 = 7,
    DXVA_VideoPrimaries_SMPTE_C = 8
} DXVA_VideoPrimaries;

typedef enum _DXVA_VideoLighting
{
    DXVA_VideoLightingShift = (DXVA_ExtColorData_ShiftBase + 10),
    DXVA_VideoLightingMask = DXVAColorMask(4, DXVA_VideoLightingShift),

    DXVA_VideoLighting_Unknown = 0,
    DXVA_VideoLighting_bright = 1,
    DXVA_VideoLighting_office = 2,
    DXVA_VideoLighting_dim = 3,
    DXVA_VideoLighting_dark = 4
} DXVA_VideoLighting;

typedef enum _DXVA_VideoTransferMatrix
{
    DXVA_VideoTransferMatrixShift = (DXVA_ExtColorData_ShiftBase + 7),
    DXVA_VideoTransferMatrixMask = DXVAColorMask(3, DXVA_VideoTransferMatrixShift),

    DXVA_VideoTransferMatrix_Unknown = 0,
    DXVA_VideoTransferMatrix_BT709 = 1,
    DXVA_VideoTransferMatrix_BT601 = 2,
    DXVA_VideoTransferMatrix_SMPTE240M = 3
} DXVA_VideoTransferMatrix;

typedef enum _DXVA_NominalRange
{
    DXVA_NominalRangeShift = (DXVA_ExtColorData_ShiftBase + 4),
    DXVA_NominalRangeMask = DXVAColorMask(3, DXVA_NominalRangeShift),

    DXVA_NominalRange_Unknown = 0,
    DXVA_NominalRange_Normal = 1,
    DXVA_NominalRange_Wide = 2,

    DXVA_NominalRange_0_255 = 1,
    DXVA_NominalRange_16_235 = 2,
    DXVA_NominalRange_48_208 = 3
} DXVA_NominalRange;


typedef enum _DXVA_VideoChromaSubsampling
{
    DXVA_VideoChromaSubsamplingShift = (DXVA_ExtColorData_ShiftBase + 0),
    DXVA_VideoChromaSubsamplingMask = DXVAColorMask(4, DXVA_VideoChromaSubsamplingShift),

    DXVA_VideoChromaSubsampling_Unknown = 0,
    DXVA_VideoChromaSubsampling_ProgressiveChroma = 0x8,
    DXVA_VideoChromaSubsampling_Horizontally_Cosited = 0x4,
    DXVA_VideoChromaSubsampling_Vertically_Cosited = 0x2,
    DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x1,

    // 4:2:0 variations
    DXVA_VideoChromaSubsampling_MPEG2  =   DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_MPEG1  =   DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_DV_PAL  =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited,
    // 4:4:4, 4:2:2, 4:1:1
    DXVA_VideoChromaSubsampling_Cosited =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes,
} DXVA_VideoChromaSubsampling;

typedef struct _DXVA_ExtendedFormat
{
    UINT                        SampleFormat : 8;           // See DXVA_SampleFormat
    UINT                        VideoChromaSubsampling : 4; // See DXVA_VideoChromaSubSampling
    DXVA_NominalRange           NominalRange : 3;           // See DXVA_NominalRange
    DXVA_VideoTransferMatrix    VideoTransferMatrix : 3;    // See DXVA_VideoTransferMatrix
    DXVA_VideoLighting          VideoLighting : 4;          // See DXVA_VideoLighting
    DXVA_VideoPrimaries         VideoPrimaries : 5;         // See DXVA_VideoPrimaries
    DXVA_VideoTransferFunction  VideoTransferFunction : 5;  // See DXVA_VideoTransferFunction
} DXVA_ExtendedFormat;

#endif



// -------------------------------------------------------------------------
//
// The definitions that follow describe the video de-interlace interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DEINTERLACE__
#define __DIRECTX_VA_DEINTERLACE__

typedef LONGLONG REFERENCE_TIME;

DEFINE_GUID(DXVA_DeinterlaceBobDevice,
    0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);

DEFINE_GUID(DXVA_DeinterlaceContainerDevice,
    0x0e85cb93,0x3046,0x4ff0,0xae,0xcc,0xd5,0x8c,0xb5,0xf0,0x35,0xfd);


#if (DIRECT3D_VERSION < 0x0800) || !defined(DIRECT3D_VERSION)
typedef DWORD D3DFORMAT;
enum {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,
    D3DPOOL_LOCALVIDMEM             = 4,
    D3DPOOL_NONLOCALVIDMEM          = 5,
    D3DPOOL_FORCE_DWORD             = 0x7fffffff
};
#endif


// -------------------------------------------------------------------------
// data structures shared by User mode and Kernel mode.
// -------------------------------------------------------------------------
//

typedef struct _DXVA_Frequency {
    DWORD Numerator;
    DWORD Denominator;
} DXVA_Frequency;

typedef struct _DXVA_VideoDesc {
    DWORD               Size;
    DWORD               SampleWidth;
    DWORD               SampleHeight;
    DWORD               SampleFormat; // also contains extend color data
    D3DFORMAT           d3dFormat;
    DXVA_Frequency      InputSampleFreq;
    DXVA_Frequency      OutputFrameFreq;
} DXVA_VideoDesc, *LPDXVA_VideoDesc;

typedef enum _DXVA_VideoProcessCaps {
    DXVA_VideoProcess_None                  = 0x0000,
    DXVA_VideoProcess_YUV2RGB               = 0x0001,
    DXVA_VideoProcess_StretchX              = 0x0002,
    DXVA_VideoProcess_StretchY              = 0x0004,
    DXVA_VideoProcess_AlphaBlend            = 0x0008,
    DXVA_VideoProcess_SubRects              = 0x0010,
    DXVA_VideoProcess_SubStreams            = 0x0020,
    DXVA_VideoProcess_SubStreamsExtended    = 0x0040,
    DXVA_VideoProcess_YUV2RGBExtended       = 0x0080,
    DXVA_VideoProcess_AlphaBlendExtended    = 0x0100
} DXVA_VideoProcessCaps;

typedef enum _DXVA_DeinterlaceTech {

    // the algorithm is unknown or proprietary
    DXVA_DeinterlaceTech_Unknown                = 0x0000,

    // the algorithm creates the missing lines by repeating
    // the line either above or below it - this method will look very jaggy and
    // isn't recommended
    DXVA_DeinterlaceTech_BOBLineReplicate       = 0x0001,

    // The algorithm creates the missing lines by vertically stretching each
    // video field by a factor of two by averaging two lines
    DXVA_DeinterlaceTech_BOBVerticalStretch     = 0x0002,

    // or using a [-1, 9, 9, -1]/16 filter across four lines.
    DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = 0x0100,

    // the pixels in the missing line are recreated by a median filtering operation
    DXVA_DeinterlaceTech_MedianFiltering        = 0x0004,

    // the pixels in the missing line are recreated by an edge filter.
    // In this process, spatial directional filters are applied to determine
    // the orientation of edges in the picture content, and missing
    // pixels are created by filtering along (rather than across) the
    // detected edges.
    DXVA_DeinterlaceTech_EdgeFiltering          = 0x0010,

    // the pixels in the missing line are recreated by switching on a field by
    // field basis between using either spatial or temporal interpolation
    // depending on the amount of motion.
    DXVA_DeinterlaceTech_FieldAdaptive          = 0x0020,

    // the pixels in the missing line are recreated by switching on a pixel by pixel
    // basis between using either spatial or temporal interpolation depending on
    // the amount of motion..
    DXVA_DeinterlaceTech_PixelAdaptive          = 0x0040,

    // Motion Vector Steering  identifies objects within a sequence of video
    // fields.  The missing pixels are recreated after first aligning the
    // movement axes of the individual objects in the scene to make them
    // parallel with the time axis.
    DXVA_DeinterlaceTech_MotionVectorSteered      = 0x0080

} DXVA_DeinterlaceTech;


typedef struct _DXVA_VideoSample {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DXVA_SampleFormat   SampleFormat;   // only lower 8 bits used
    VOID*               lpDDSSrcSurface;
} DXVA_VideoSample, *LPDXVA_VideoSample;



// -------------------------------------------------------------------------
// DeinterlaceBltEx declarations
// -------------------------------------------------------------------------
//

typedef enum _DXVA_SampleFlags {
    DXVA_SampleFlagsMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_SampleFlag_Palette_Changed         = 0x0001,
    DXVA_SampleFlag_SrcRect_Changed         = 0x0002,
    DXVA_SampleFlag_DstRect_Changed         = 0x0004,
    DXVA_SampleFlag_ColorData_Changed       = 0x0008,
} DXVA_SampleFlags;

typedef enum _DXVA_DestinationFlags {
    DXVA_DestinationFlagMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_DestinationFlag_Background_Changed = 0x0001,
    DXVA_DestinationFlag_TargetRect_Changed = 0x0002,
    DXVA_DestinationFlag_ColorData_Changed  = 0x0004,
    DXVA_DestinationFlag_Alpha_Changed      = 0x0008
} DXVA_DestinationFlags;




typedef struct _DXVA_VideoSample2 {
#ifdef _WIN64
    DWORD               Size;
    DWORD               Reserved;
#endif
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;   // cast to DXVA_ExtendedFormat, or use Extract macros
    DWORD               SampleFlags;
    VOID*               lpDDSSrcSurface;
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
} DXVA_VideoSample2, *LPDXVA_VideoSample2;

typedef struct _DXVA_DeinterlaceCaps {
    DWORD                   Size;
    DWORD                   NumPreviousOutputFrames;
    DWORD                   InputPool;
    DWORD                   NumForwardRefSamples;
    DWORD                   NumBackwardRefSamples;
    D3DFORMAT               d3dOutputFormat;
    DXVA_VideoProcessCaps   VideoProcessingCaps;
    DXVA_DeinterlaceTech    DeinterlaceTechnology;
} DXVA_DeinterlaceCaps, *LPDXVA_DeinterlaceCaps;




// -------------------------------------------------------------------------
// Data types used with RenderMoComp in kernel mode
// -------------------------------------------------------------------------
//

// Function codes for RenderMoComp

#define MAX_DEINTERLACE_SURFACES                        32

#ifdef _WIN64
//
// These structures are used for thunking 32 bit DeinterlaceBltEx calls on
// 64 bit drivers.
// 
typedef struct _DXVA_VideoSample32 {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;
    DWORD               SampleFlags;
    DWORD               lpDDSSrcSurface;  // 32 bit pointer size
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
    // DWORD Pad; 
    // 4 bytes of padding added by the compiler to align the struct to 8 bytes.
} DXVA_VideoSample32;
 
typedef struct _DXVA_DeinterlaceBltEx32 {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample32  Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx32;
#endif


typedef struct _DXVA_DeinterlaceBlt {
    DWORD               Size;
    DWORD               Reserved;
    REFERENCE_TIME      rtTarget;
    RECT                DstRect;
    RECT                SrcRect;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample    Source[MAX_DEINTERLACE_SURFACES];
} DXVA_DeinterlaceBlt;

#define DXVA_DeinterlaceBltFnCode                     0x01
// lpInput => DXVA_DeinterlaceBlt*
// lpOuput => NULL /* not currently used */


typedef struct _DXVA_DeinterlaceBltEx {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample2   Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx;

#define DXVA_DeinterlaceBltExFnCode                   0x02
// lpInput => DXVA_DeinterlaceBltEx*
// lpOuput => NULL /* not currently used */


#define MAX_DEINTERLACE_DEVICE_GUIDS                    32
typedef struct _DXVA_DeinterlaceQueryAvailableModes {
    DWORD               Size;
    DWORD               NumGuids;
    GUID                Guids[MAX_DEINTERLACE_DEVICE_GUIDS];
} DXVA_DeinterlaceQueryAvailableModes;

#define DXVA_DeinterlaceQueryAvailableModesFnCode     0x01
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_DeinterlaceQueryAvailableModes*


typedef struct _DXVA_DeinterlaceQueryModeCaps {
    DWORD               Size;
    GUID                Guid;
    DXVA_VideoDesc      VideoDesc;
} DXVA_DeinterlaceQueryModeCaps;

#define DXVA_DeinterlaceQueryModeCapsFnCode           0x02
// lpInput => DXVA_DeinterlaceQueryModeCaps*
// lpOuput => DXVA_DeinterlaceCaps*

#endif /*  __DIRECTX_VA_DEINTERLACE__ */


// -------------------------------------------------------------------------
//
// The definitions that follow describe the video ProcAmp interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_PROCAMPCONTROL__

DEFINE_GUID(DXVA_ProcAmpControlDevice,
    0x9f200913,0x2ffd,0x4056,0x9f,0x1e,0xe1,0xb5,0x08,0xf2,0x2d,0xcf);

typedef enum _DXVA_ProcAmpControlProp {
    DXVA_ProcAmp_None       = 0x0000,
    DXVA_ProcAmp_Brightness = 0x0001,
    DXVA_ProcAmp_Contrast   = 0x0002,
    DXVA_ProcAmp_Hue        = 0x0004,
    DXVA_ProcAmp_Saturation = 0x0008
} DXVA_ProcAmpControlProp;


typedef struct _DXVA_ProcAmpControlCaps {
    DWORD                   Size;
    DWORD                   InputPool;
    D3DFORMAT               d3dOutputFormat;
    DWORD                   ProcAmpControlProps;// see DXVA_ProcAmpControlProp
    DWORD                   VideoProcessingCaps;// see DXVA_VideoProcessCaps
} DXVA_ProcAmpControlCaps, *LPDXVA_ProcAmpControlCaps;

#define DXVA_ProcAmpControlQueryCapsFnCode             0x03
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_ProcAmpControlCaps*


typedef struct _DXVA_ProcAmpControlQueryRange {
    DWORD                   Size;
    DXVA_ProcAmpControlProp ProcAmpControlProp;
    DXVA_VideoDesc          VideoDesc;
} DXVA_ProcAmpControlQueryRange, *LPDXVA_ProcAmpControlQueryRange;

typedef struct _DXVA_VideoPropertyRange {
    FLOAT   MinValue;
    FLOAT   MaxValue;
    FLOAT   DefaultValue;
    FLOAT   StepSize;
} DXVA_VideoPropertyRange, *LPDXVA_VideoPropertyRange;

#define DXVA_ProcAmpControlQueryRangeFnCode            0x04
// lpInput => DXVA_ProcAmpControlQueryRange*
// lpOuput => DXVA_VideoPropertyRange*


typedef struct _DXVA_ProcAmpControlBlt {
    DWORD               Size;
    RECT                DstRect;
    RECT                SrcRect;
    FLOAT               Alpha;
    FLOAT               Brightness;
    FLOAT               Contrast;
    FLOAT               Hue;
    FLOAT               Saturation;
} DXVA_ProcAmpControlBlt;

#define DXVA_ProcAmpControlBltFnCode                   0x01
// lpInput => DXVA_ProcAmpControlBlt*
// lpOuput => NULL /* not currently used */

#endif /*  __DIRECTX_VA_PROCAMPCONTROL__ */


// -------------------------------------------------------------------------
//
// The definitions that follow describe the Certified Output Protection
// Protocol between the VMR and the graphics device driver.  This interface
// is not accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//

#ifndef __DIRECTX_VA_CERTOUTPUTPROTECT__
#define __DIRECTX_VA_CERTOUTPUTPROTECT__


DEFINE_GUID(DXVA_COPPDevice,
    0xd2457add,0x8999,0x45ed,0x8a,0x8a,0xd1,0xaa,0x04,0x7b,0xa4,0xd5);


// -------------------------------------------------------------------------
// COPPGetCertificateLength
// -------------------------------------------------------------------------
#define DXVA_COPPGetCertificateLengthFnCode         0x01
// lpInput => NULL
// lpOuput => DWORD*


// -------------------------------------------------------------------------
// COPPKeyExchange
// -------------------------------------------------------------------------
#define DXVA_COPPKeyExchangeFnCode                  0x02
// lpInputData => NULL
// lpOuputData => GUID*


// -------------------------------------------------------------------------
// COPPSequenceStart
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPSignature {
    UCHAR   Signature[256];
} DXVA_COPPSignature, *LPDXVA_COPPSignature;

#define DXVA_COPPSequenceStartFnCode                0x03
// lpInputData => DXVA_COPPSignature*
// lpOuputData => NULL



// -------------------------------------------------------------------------
// COPPCommand
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPCommand {
    GUID    macKDI;             //   16 bytes
    GUID    guidCommandID;      //   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   CommandData[4056];  // 4056 bytes (4056+4+4+16+16 = 4096)
}  DXVA_COPPCommand, *LPDXVA_COPPCommand;

#define DXVA_COPPCommandFnCode                      0x04
// lpInputData => DXVA_COPPCommand*
// lpOuputData => NULL


DEFINE_GUID(DXVA_COPPSetProtectionLevel,
    0x9bb9327c,0x4eb5,0x4727,0x9f,0x00,0xb4,0x2b,0x09,0x19,0xc0,0xda);

typedef struct _DXVA_COPPSetProtectionLevelCmdData {
    ULONG   ProtType;
    ULONG   ProtLevel;
    ULONG   ExtendedInfoChangeMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPSetProtectionLevelCmdData;

typedef enum _COPP_DPCP_Protection_Level {
    COPP_DPCP_Level0        = 0,
    COPP_DPCP_LevelMin      = COPP_DPCP_Level0,
    COPP_DPCP_Level1        = 1,
    COPP_DPCP_LevelMax      = COPP_DPCP_Level1,
    COPP_DPCP_ForceDWORD    = 0x7fffffff
} COPP_DPCP_Protection_Level;

// Set the HDCP protection level - (0 - 1 DWORD, 4 bytes)

typedef enum _COPP_HDCP_Protection_Level {
    COPP_HDCP_Level0    = 0,
    COPP_HDCP_LevelMin  = COPP_HDCP_Level0,
    COPP_HDCP_Level1    = 1,
    COPP_HDCP_LevelMax  = COPP_HDCP_Level1,
    COPP_HDCP_ForceDWORD = 0x7fffffff
} COPP_HDCP_Protection_Level;

typedef enum _COPP_CGMSA_Protection_Level {
    COPP_CGMSA_Disabled = 0,
    COPP_CGMSA_LevelMin = COPP_CGMSA_Disabled,
    COPP_CGMSA_CopyFreely = 1,
    COPP_CGMSA_CopyNoMore = 2,
    COPP_CGMSA_CopyOneGeneration   = 3,
    COPP_CGMSA_CopyNever = 4,
    COPP_CGMSA_RedistributionControlRequired = 0x08,
    COPP_CGMSA_LevelMax = (COPP_CGMSA_RedistributionControlRequired + COPP_CGMSA_CopyNever),
    COPP_CGMSA_ForceDWORD = 0x7fffffff
} COPP_CGMSA_Protection_Level;

typedef enum _COPP_ACP_Protection_Level {
    COPP_ACP_Level0     = 0,
    COPP_ACP_LevelMin   = COPP_ACP_Level0,
    COPP_ACP_Level1     = 1,
    COPP_ACP_Level2     = 2,
    COPP_ACP_Level3     = 3,
    COPP_ACP_LevelMax   = COPP_ACP_Level3,
    COPP_ACP_ForceDWORD = 0x7fffffff
} COPP_ACP_Protection_Level;

#define COPP_NoProtectionLevelAvailable  -1
#define COPP_DefaultProtectionLevel 0


//
// Bit flags of possible protection types.  Note that it is possible to apply
// different protection settings to a single connector.
//
enum {
    COPP_ProtectionType_Unknown      = 0x80000000,
    COPP_ProtectionType_None         = 0x00000000,
    COPP_ProtectionType_HDCP         = 0x00000001, 	
    COPP_ProtectionType_ACP          = 0x00000002,
    COPP_ProtectionType_CGMSA        = 0x00000004,
    COPP_ProtectionType_DPCP         = 0x00000010,
    COPP_ProtectionType_Mask         = 0x80000017,
    COPP_ProtectionType_Reserved     = 0x7FFFFFF8
};

DEFINE_GUID(DXVA_COPPSetSignaling,
    0x9a631a5, 0xd684, 0x4c60, 0x8e, 0x4d, 0xd3, 0xbb, 0xf, 0xb, 0xe3, 0xee);

typedef struct _DXVA_COPPSetSignalingCmdData {
    ULONG   ActiveTVProtectionStandard;           // See COPP_TVProtectionStandard
    ULONG   AspectRatioChangeMask1;
    ULONG   AspectRatioData1;                     // See COPP_ImageAspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioChangeMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioChangeMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoChangeMask[4];
    ULONG   ExtendedInfoData[4];
    ULONG   Reserved;
} DXVA_COPPSetSignalingCmdData;

// Add format enum and data enum
typedef enum _COPP_TVProtectionStandard {
    COPP_ProtectionStandard_Unknown                         = 0x80000000,
    COPP_ProtectionStandard_None                            = 0x00000000,
    COPP_ProtectionStandard_IEC61880_525i                   = 0x00000001,
    COPP_ProtectionStandard_IEC61880_2_525i                 = 0x00000002,
    COPP_ProtectionStandard_IEC62375_625p                   = 0x00000004,
    COPP_ProtectionStandard_EIA608B_525                     = 0x00000008,
    COPP_ProtectionStandard_EN300294_625i                   = 0x00000010,
    COPP_ProtectionStandard_CEA805A_TypeA_525p              = 0x00000020,
    COPP_ProtectionStandard_CEA805A_TypeA_750p              = 0x00000040,
    COPP_ProtectionStandard_CEA805A_TypeA_1125i             = 0x00000080,
    COPP_ProtectionStandard_CEA805A_TypeB_525p              = 0x00000100,
    COPP_ProtectionStandard_CEA805A_TypeB_750p              = 0x00000200,
    COPP_ProtectionStandard_CEA805A_TypeB_1125i             = 0x00000400,
    COPP_ProtectionStandard_ARIBTRB15_525i                  = 0x00000800,
    COPP_ProtectionStandard_ARIBTRB15_525p                  = 0x00001000,
    COPP_ProtectionStandard_ARIBTRB15_750p                  = 0x00002000,
    COPP_ProtectionStandard_ARIBTRB15_1125i                 = 0x00004000,
    COPP_ProtectionStandard_Mask                            = 0x80007FFF,
    COPP_ProtectionStandard_Reserved                        = 0x7FFF8000
} COPP_TVProtectionStandard;

#define COPP_ImageAspectRatio_EN300294_Mask                 0x00000007

typedef enum _COPP_ImageAspectRatio_EN300294 {
    COPP_AspectRatio_EN300294_FullFormat4by3                = 0,
    COPP_AspectRatio_EN300294_Box14by9Center                = 1,
    COPP_AspectRatio_EN300294_Box14by9Top                   = 2,
    COPP_AspectRatio_EN300294_Box16by9Center                = 3,
    COPP_AspectRatio_EN300294_Box16by9Top                   = 4,
    COPP_AspectRatio_EN300294_BoxGT16by9Center              = 5,
    COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = 6,
    COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic     = 7,
    COPP_AspectRatio_ForceDWORD                             = 0x7fffffff
} COPP_ImageAspectRatio_EN300294;


// -------------------------------------------------------------------------
// COPPQueryStatus
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPStatusInput {
    GUID    rApp;               //   16 bytes
    GUID    guidStatusRequestID;//   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   StatusData[4056];   // 4056 bytes (4056+4+4+16+16 = 4096)
} DXVA_COPPStatusInput, *LPDXVA_COPPStatusInput;

typedef struct _DXVA_COPPStatusOutput {
    GUID    macKDI;             //   16 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   COPPStatus[4076];   // 4076 bytes (4076+16+4 = 4096)
} DXVA_COPPStatusOutput, *LPDXVA_COPPStatusOutput;

typedef enum _COPP_StatusFlags {
    COPP_StatusNormal           = 0x00,
    COPP_LinkLost               = 0x01,
    COPP_RenegotiationRequired  = 0x02,
    COPP_StatusFlagsReserved    = 0xFFFFFFFC
} COPP_StatusFlags;

typedef struct _DXVA_COPPStatusData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   dwData;
    ULONG   ExtendedInfoValidMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPStatusData;

typedef struct _DXVA_COPPStatusDisplayData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   DisplayWidth;
    ULONG   DisplayHeight;
    ULONG   Format;     // also contains extended color data
    ULONG   d3dFormat;
    ULONG   FreqNumerator;
    ULONG   FreqDenominator;
} DXVA_COPPStatusDisplayData;

typedef enum _COPP_StatusHDCPFlags {
    COPP_HDCPRepeater       = 0x01,
    COPP_HDCPFlagsReserved  = 0xFFFFFFFE
} COPP_StatusHDCPFlags;

typedef struct _DXVA_COPPStatusHDCPKeyData {
    GUID    rApp;
    ULONG   dwFlags;        // See COPP_StatusFlags above
    ULONG   dwHDCPFlags;    // See COPP_StatusHDCPFlags above
    GUID    BKey;           // Lower 40 bits
    GUID    Reserved1;
    GUID    Reserved2;
} DXVA_COPPStatusHDCPKeyData;


#define DXVA_COPPQueryStatusFnCode 0x05
// lpInputData => DXVA_COPPStatusInput*
// lpOuputData => DXVA_COPPStatusOutput*


//
// Status GUID and enumerations
//
DEFINE_GUID(DXVA_COPPQueryConnectorType,
      0x81d0bfd5,0x6afe,0x48c2,0x99,0xc0,0x95,0xa0,0x8f,0x97,0xc5,0xda);

typedef enum _COPP_ConnectorType {
    COPP_ConnectorType_Unknown = -1,
    COPP_ConnectorType_VGA = 0,
    COPP_ConnectorType_SVideo = 1,
    COPP_ConnectorType_CompositeVideo = 2,
    COPP_ConnectorType_ComponentVideo = 3,
    COPP_ConnectorType_DVI = 4,
    COPP_ConnectorType_HDMI = 5,
    COPP_ConnectorType_LVDS = 6,
    COPP_ConnectorType_TMDS = 7,
    COPP_ConnectorType_D_JPN = 8,
    COPP_ConnectorType_SDI = 9,
    COPP_ConnectorType_DisplayPortExternal = 10,
    COPP_ConnectorType_DisplayPortEmbedded = 11,
    COPP_ConnectorType_UDIExternal = 12,
    COPP_ConnectorType_UDIEmbedded = 13,
    COPP_ConnectorType_Internal = 0x80000000,   // can be combined with the other connector types
    COPP_ConnectorType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_ConnectorType;

DEFINE_GUID(DXVA_COPPQueryProtectionType,
    0x38f2a801,0x9a6c,0x48bb,0x91,0x07,0xb6,0x69,0x6e,0x6f,0x17,0x97);

DEFINE_GUID(DXVA_COPPQueryLocalProtectionLevel,
    0xb2075857,0x3eda,0x4d5d,0x88,0xdb,0x74,0x8f,0x8c,0x1a,0x05,0x49);

DEFINE_GUID(DXVA_COPPQueryGlobalProtectionLevel,
    0x1957210a,0x7766,0x452a,0xb9,0x9a,0xd2,0x7a,0xed,0x54,0xf0,0x3a);

DEFINE_GUID(DXVA_COPPQueryDisplayData,
    0xd7bf1ba3,0xad13,0x4f8e,0xaf,0x98,0x0d,0xcb,0x3c,0xa2,0x04,0xcc);

DEFINE_GUID(DXVA_COPPQueryHDCPKeyData,
    0xdb59d74, 0xa992, 0x492e, 0xa0, 0xbd, 0xc2, 0x3f, 0xda, 0x56, 0x4e, 0x0);

DEFINE_GUID(DXVA_COPPQueryBusData,
    0xc6f4d673, 0x6174, 0x4184, 0x8e, 0x35, 0xf6, 0xdb, 0x52, 0x0, 0xbc, 0xba);

typedef enum _COPP_BusType {
    COPP_BusType_Unknown    = 0,
    COPP_BusType_PCI        = 1,
    COPP_BusType_PCIX       = 2,
    COPP_BusType_PCIExpress = 3,
    COPP_BusType_AGP        = 4,
    COPP_BusType_Integrated = 0x80000000, // can be combined with the other bus types
    COPP_BusType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_BusType;

DEFINE_GUID(DXVA_COPPQuerySignaling,
    0x6629a591, 0x3b79, 0x4cf3, 0x92, 0x4a, 0x11, 0xe8, 0xe7, 0x81, 0x16, 0x71);

typedef struct _DXVA_COPPStatusSignalingCmdData {
    GUID    rApp;
    ULONG   dwFlags;                                // See COPP_StatusFlags above
    ULONG   AvailableTVProtectionStandards;         // See COPP_TVProtectionStandard
    ULONG   ActiveTVProtectionStandard;             // See COPP_TVProtectionStandard
    ULONG   TVType;
    ULONG   AspectRatioValidMask1;
    ULONG   AspectRatioData1;                       // See COPP_AspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioValidMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioValidMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoValidMask[4];
    ULONG   ExtendedInfoData[4];
} DXVA_COPPStatusSignalingCmdData;


#endif /* __DIRECTX_VA_CERTOUTPUTPROTECT__ */

#ifdef __cplusplus
}
#endif

#ifdef __DXVA1_DEPRECATED_INTERFACES__   

#if !defined(__cplusplus)
#error C++ compiler required.
#endif

/* IID_IDirect3DVideoDevice9 */
DEFINE_GUID(IID_IDirect3DVideoDevice9, 
0x694036ac, 0x542a, 0x4a3a, 0x9a, 0x32, 0x53, 0xbc, 0x20, 0x0, 0x2c, 0x1b);

/* IID_IDirect3DDXVADevice9 */
DEFINE_GUID(IID_IDirect3DDXVADevice9, 
0x9f00c3d3, 0x5ab6, 0x465f, 0xb9, 0x55, 0x9f, 0xe, 0xbb, 0x2c, 0x56, 0x6);

interface IDirect3DVideoDevice9;
interface IDirect3DDXVADevice9;

typedef struct _DXVAUncompDataInfo
{
    DWORD       UncompWidth;    /* Width of uncompressed data */
    DWORD       UncompHeight;   /* Height of uncompressed data */
    D3DFORMAT   UncompFormat;   /* Format of uncompressed data */
} DXVAUncompDataInfo;

typedef struct _DXVACompBufferInfo
{
    DWORD       NumCompBuffers;     /* Number of buffers reqd for compressed data */
    DWORD       WidthToCreate;      /* Width of surface to create */
    DWORD       HeightToCreate;     /* Height of surface to create */
    DWORD       BytesToAllocate;    /* Total number of bytes used by each surface */
    DWORD       Usage;              /* Usage used to create the compressed buffer */
    D3DPOOL     Pool;               /* Pool where the compressed buffer belongs */
    D3DFORMAT   Format;             /* Format used to create the compressed buffer */
} DXVACompBufferInfo;

typedef struct _DXVABufferInfo
{
    VOID*               pCompSurface;   /* Pointer to buffer containing compressed data */
    DWORD               DataOffset;     /* Offset of relevant data from the beginning of buffer */
    DWORD               DataSize;       /* Size of relevant data */
} DXVABufferInfo;

#undef INTERFACE
#define INTERFACE IDirect3DVideoDevice9

DECLARE_INTERFACE_(IDirect3DVideoDevice9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVideoDevice9 methods ***/
    STDMETHOD(CreateSurface)(THIS_ UINT Width,UINT Height,UINT BackBuffers,
                             D3DFORMAT Format,D3DPOOL Pool,DWORD Usage,
                             IDirect3DSurface9** ppSurface,
                             HANDLE* pSharedHandle) PURE;
    STDMETHOD(GetDXVACompressedBufferInfo)(THIS_ GUID* pGuid,
                                           DXVAUncompDataInfo* pUncompData,
                                           DWORD* pNumBuffers,
                                           DXVACompBufferInfo* pBufferInfo) PURE;
    STDMETHOD(GetDXVAGuids)(THIS_ DWORD* pNumGuids,GUID* pGuids) PURE;
    STDMETHOD(GetDXVAInternalInfo)(THIS_ GUID* pGuid,
                                   DXVAUncompDataInfo* pUncompData,
                                   DWORD* pMemoryUsed) PURE;
    STDMETHOD(GetUncompressedDXVAFormats)(THIS_ GUID* pGuid,
                                          DWORD* pNumFormats,
                                          D3DFORMAT* pFormats) PURE;
    STDMETHOD(CreateDXVADevice)(THIS_ GUID* pGuid,
                                DXVAUncompDataInfo* pUncompData,
                                LPVOID pData,DWORD DataSize,
                                IDirect3DDXVADevice9** ppDXVADevice) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DDXVADevice9

DECLARE_INTERFACE_(IDirect3DDXVADevice9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDXVADevice9 methods ***/
    STDMETHOD(BeginFrame)(THIS_ IDirect3DSurface9* pDstSurface,
                          DWORD SizeInputData,VOID* pInputData,
                          DWORD* pSizeOutputData,VOID* pOutputData) PURE;
    STDMETHOD(EndFrame)(THIS_ DWORD SizeMiscData,VOID* pMiscData) PURE;
    STDMETHOD(Execute)(THIS_ DWORD FunctionNum,VOID* pInputData,
                       DWORD InputSize,VOID* OuputData,DWORD OutputSize,
                       DWORD NumBuffers,DXVABufferInfo* pBufferInfo) PURE;
    STDMETHOD(QueryStatus)(THIS_ IDirect3DSurface9* pSurface,DWORD Flags) PURE;
};

#endif /* __DXVA1_DEPRECATED_INTERFACES__ */        
#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

#ifndef PASCAL_INLINE
#ifdef _M_CEE_PURE
#define PASCAL_INLINE  __clrcall
#else
#define PASCAL_INLINE  PASCAL
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL_INLINE Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
	if ((nMax * cbElement) > (SIZE_MAX - sizeof(CDXPlex)))
	    return NULL;
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        if (p == NULL)
            return NULL;
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete [] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // oh well, it's better than crashing
        if (pNewData == NULL)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];

            // oh well, it's better than crashing
            if (pNewData == NULL)
                return;

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];

        // oh well, it's better than crashing
        if (m_pHashTable == NULL)
            return;

        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eaphostpeerconfigapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares methods that are used to configure EAP methods.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERCONFIGAPIS_H
#define EAPHOSTPEERCONFIGAPIS_H
#pragma once

#include "objbase.h"    //Required by msxml2.h
#include "msxml6.h"

#include "EapTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


// This API is used to enumerate all the EAP Methods installed and available for use; this
// includes legacy EAP Methods too. Returns non zero return code up on error.
DWORD WINAPI EapHostPeerGetMethods(
                // API fills the structure to have installed EAP Methods. Caller should free the inner pointers
                // using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_METHOD_INFO_ARRAY* pEapMethodInfoArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// This API is used to invoke configure UI of the specified EAP Method.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeConfigUI(
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // Flags to control the behavior of the EAP Method.
                IN DWORD dwFlags,
                // Identifies the EAP Method to configure
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of input configuration; this could be 0 when there is no configuration
                IN DWORD dwSizeOfConfigIn,
                // input configuration, this couldb NULL when there is no configuration
                IN __in_ecount_opt(dwSizeOfConfigIn) const BYTE* pConfigIn,
                // pointer to DWORD that receives configuration after user updated using UI
                OUT DWORD* pdwSizeOfConfigOut,
                // buffer that receives updated configuration after user updated using UI.
                // Caller should free the memory using EapHostPeerFreeMemory.
                OUT BYTE** ppConfigOut,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );

// This API is used to obtain the fields to be shown in Single Sign On scenario for
// showing UI in long screen. The structures returned have details on how to show the fields.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting
                // at the inner most pointer.
                OUT EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );


// Supplicant up on receiving user inputs from Single Sign On UI, calls this API to obtain
// credential blob that could used start authentication
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUserBlobFromCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure containing the data entered by the user in Single Sign On UI
                IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // pointer to DWORD that receives the size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                IN OUT DWORD *pdwUserBlobSize,
                // Pointer that receives the credential blob that can be used in authentication.
                // For incoming data caller should always allocate this memory using LocalAlloc()
                // Caller should free the memory using EapHostPeerFreeMemory.
                IN OUT __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );


// Tunnel Methods call this function to invoke Identity UI of the inner Methods.
// This function returns the identity as well as the credentials to use to start the authentication.
DWORD WINAPI EapHostPeerInvokeIdentityUI (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // EAP_FLAG_xxx defined in eaptypes.w
                IN DWORD dwFlags,
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // size of the buffer (pConnectionData) in bytes
                IN DWORD dwSizeofConnectionData,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwSizeofConnectionData) const BYTE* pConnectionData,
                // size of the ubuffer pUserData
                IN DWORD dwSizeofUserData,
                // user credential information pertinent to this auth
                IN __in_ecount_opt(dwSizeofUserData) const BYTE* pUserData,
                // size of the buffer pUserDataOut.
                IN OUT DWORD* pdwSizeOfUserDataOut,
                // user data information returned by method.
                // Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out_ecount(*pdwSizeOfUserDataOut)BYTE** ppUserDataOut,
                // identity returned by method. Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out LPWSTR* ppwszIdentity,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError
                // using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );


// While doing authentication with EapHost, when supplicant receives action code of EapHostPeerResponseInvokeUi
// supplicant should call EapHostPeerGetUIContext to get UI context data. After that. it then should call this
// API from a process where UI can be brought up.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeInteractiveUI(
                // window handle of the parent window under which dialog will show up
                IN HWND hwndParent,
                // size of UIcontext data received from EapHostPeerGetUIContext call
                IN DWORD dwSizeofUIContextData,
                // UIcontext data received from EapHostPeerGetUIContext call
                IN __in_ecount_opt(dwSizeofUIContextData) const BYTE* pUIContextData,
                // pointer to DWORD that receives data from interactive UI that is used for authentication
                // to continue
                OUT DWORD* pdwSizeOfDataFromInteractiveUI,
                // pointer that receives buffer filled with interactive UI that is used for authentication
                // to continue. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );

// This API will enable supplicants to collect necessary information from EAPHost to raise interactive UI and collect user information
// supplicant should call EapHostPeerQueryInteractiveUIInputFields() API first after it receives
// EapHostPeerResponseInvokeUi actionCode from EAPHost. If the return value from this API
// is EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED, then supplicant should fall back to
// traditional model of invoking method interactive UI, i.e. by calling EapHostPeerInvokeInteractiveUI()
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryInteractiveUIInputFields (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );

// This API will enable supplicants to convert user information into a user-blob which can be consumed by EAPHost runtime APIs
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUIBlobFromInteractiveUIInputFields(
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that carries data provided by user
                IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // pointer to DWORD that receives size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                IN OUT DWORD * pdwSizeOfDataFromInteractiveUI,
                // Pointer that receives the credential blob that can be used in authentication.
                // Caller should free the memory using EapHostPeerFreeMemory.
                IN OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );


// Supplicant can utilize XML based EAP configuration storing, managing, editing. When it wants to call EapHostPeerConfigureUI
// or when it has to start authentication, it calls this API to convert XML configuration into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // a node containing EAP XML configuration inside it
                IN IXMLDOMNode* pConfigDoc,
                // pointer to DWORD that receives the configuration blob size
                OUT DWORD* pdwSizeOfConfigOut,
                // pointer that receives configuration blob. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// authentication, it calls this API to convert XML based credentials into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerCredentialsXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // XML node that contains credentials
                IN IXMLDOMNode* pCredentialsDoc,
                // size of configuration blob that the credentials are configured for
                IN DWORD dwSizeOfConfigIn,
                // configuration blob that the credentials are configured for
                IN __in_ecount(dwSizeOfConfigIn) BYTE* pConfigIn,
                // pointer to DWORD that receives size of the credentials blob.
                OUT  DWORD* pdwSizeOfCredentialsOut,
                // pointer that receives credential blob buffer.  Caller should free the memory using
                // EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// convert configuration blob to XML, it can call this API.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigBlob2Xml(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // identifies the EAP Method
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of configuration blob that supplicant wants to convert
                IN DWORD dwSizeOfConfigIn,
                // Configuration blob that supplicant wants to convert
                IN __in_ecount(dwSizeOfConfigDataIn) BYTE* pConfigIn,
                // XML document that contains XML form of the blob. If the EAP Method does not support
                // EapPeerConfigBlob2Xml function, the XML contains ConfigBlob node with blob in string form
                OUT IXMLDOMDocument2** ppConfigDoc,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );

// Supplicant calls this API to free memory returned by Config APIs. Supplicant should not use this API
// for freeing EAP_ERROR structure.
VOID WINAPI EapHostPeerFreeMemory(BYTE* pData);

// Supplicant calls this API to free EAP_ERROR memory, which will get filled when an API fails.
VOID WINAPI EapHostPeerFreeErrorMemory(EAP_ERROR* pEapError);


#ifdef __cplusplus
}
#endif

#endif // EAPHOSTPEERCONFIGAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eapmethodtypes.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that executes the peer eap state machine.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPMETHODAPIS_H
#define EAPMETHODAPIS_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// structure that represents EAP packet on the wire
typedef struct tagEapPacket
{
   BYTE Code;
   BYTE Id;
   BYTE Length[2];
   BYTE Data[1];
   // Any additional data following the first byte. The length of
   // the data can be deduced by the length fields.
} EapPacket;

//
// EAP packet codes from EAP spec.
//
typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for 'code' in EAPPacket
enum tagEapCode
{
   EapCodeMinimum = 1,
   EapCodeRequest = 1,
   EapCodeResponse,
   EapCodeSuccess,
   EapCodeFailure,
   EapCodeMaximum = EapCodeFailure
} EapCode;

// This is a handle to an eap session owned by the individual eap methods.
typedef VOID* EAP_SESSION_HANDLE;

   
#ifdef __cplusplus
}
#endif

#endif // EAPMETHODAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\EapHostPeerTypes.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERTYPES_H
#define EAPHOSTPEERTYPES_H
#pragma once

// Request to provide guest access.
#define EAP_PEER_FLAG_GUEST_ACCESS           0x00000040 

typedef
#ifdef __midl
   [v1_enum]
#endif


// Possible reasons for which EAP-method can call getResult from EAPhost 
enum tagEapHostPeerMethodResultReason
{
   // if method has obtained success from some
   EapHostPeerMethodResultAltSuccessReceived = 1,

   // method timedout waiting for response
   EapHostPeerMethodResultTimeout,

   // normal completion of authentication process
   EapHostPeerMethodResultFromMethod
} EapHostPeerMethodResultReason;

   
typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerResponseAction
{
        // Discard the request as EAP cannot use it.
        EapHostPeerResponseDiscard = 0,
        // Send the packet to the authenticator
        EapHostPeerResponseSend,
        // Respond to EAP by acting on the returned attributes
        EapHostPeerResponseResult,
        // Invoke appropriate UI based on the context
        EapHostPeerResponseInvokeUi,
        // Display a string to the user received as part of a notification 
        // request
        // EapHostPeerResponseNotification,
        // The supplicant needs to take an action based on the context.
        EapHostPeerResponseRespond,
        // The supplicant needs to restart authentication with the same session. 
   //EapHostPeerResponseResetAuthentication,
        // The session could not be found. So the supplicant either needs to 
        // start session again with the same packet or discard the packet. 
   EapHostPeerResponseStartAuthentication,
        // The supplicant needs to take no action at all.
        EapHostPeerResponseNone
} EapHostPeerResponseAction;


typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerAuthParams {
   EapHostPeerAuthStatus = 1,    // current auth status
   EapHostPeerIdentity,           // obtain the inner method id
   EapHostPeerIdentityExtendedInfo // obtained from Identity packet
                                                                  // This includes NLA information for wireless
} EapHostPeerAuthParams;


typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for EAP status during authentication process
enum _EAPHOST_AUTH_STATUS
{
   EapHostInvalidSession = 0,
   EapHostAuthNotStarted,
   EapHostAuthIdentityExchange,
   EapHostAuthNegotiatingType,
   EapHostAuthInProgress,
   EapHostAuthSucceeded,
   EapHostAuthFailed
} EAPHOST_AUTH_STATUS;


// describes the current authentication info through different stages
// of EAP authentication process.
typedef struct _EAPHOST_AUTH_INFO
{
   EAPHOST_AUTH_STATUS status;
   DWORD dwErrorCode;
   DWORD dwReasonCode;
} EAPHOST_AUTH_INFO;


// Describes the isolation state of a machine, i.e. 
// whether connectivity is affected.
typedef
#ifdef __midl
   [v1_enum]
#endif
enum _ISOLATION_STATE
{
   ISOLATION_STATE_UNKNOWN = 0,
   ISOLATION_STATE_NOT_RESTRICTED = 1,
   ISOLATION_STATE_IN_PROBATION = 2,
   ISOLATION_STATE_RESTRICTED_ACCESS = 3
} ISOLATION_STATE;


// This carries the result information passed from EAPHost to EAP-method,
// when EAP-method calls GetResult
typedef struct tagEapHostPeerMethodResult
{
   BOOL fIsSuccess;
   UINT32 dwFailureReasonCode;
   BOOL fSaveConnectionData;
   UINT32 dwSizeofConnectionData;
#ifdef __midl   
   [size_is(dwSizeofConnectionData)] BYTE* pConnectionData;
#else
   BYTE* pConnectionData;
#endif
   BOOL fSaveUserData;
   UINT32 dwSizeofUserData;
#ifdef __midl   
   [size_is(dwSizeofUserData)] BYTE* pUserData;
#else
   BYTE* pUserData;
#endif
   EAP_ATTRIBUTES* pAttribArray;
   ISOLATION_STATE isolationState;      
   EAP_METHOD_INFO* pEapMethodInfo;
   EAP_ERROR* pEapError;
} EapHostPeerMethodResult;

#endif //EAPHOSTPEERTYPES_IDL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eapmethodauthenticatorapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that are needed by eap methods on the Peer.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAP_METHOD_AUTHENTICATOR_APIS_H
#define EAP_METHOD_AUTHENTICATOR_APIS_H
#pragma once

#include "EapAuthenticatorTypes.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\[EapTypeId])
//
// Custom EAP DLL registry installation example:
//                     Name      =  Sample.dll, 
//                     AuthorId  =  311(Microsoft), 
//                     EapTypeId = (decimal 40) 
// HKLM\System\CCS\Services\Eaphost\Methods\311\40
//
//      AuthenticatorDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      AuthenticatorFriendlyName        (REG_SZ) Sample EAP Protocol

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\254\[VendorId]\[EapTypeId])
//
// Custom Expanded EAP DLL registry installation example:
//                     Name      =  Sample.dll, 
//                     AuthorId  =  311(Microsoft),
//                     VendorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40) 
// HKLM\System\CCS\Services\Eaphost\Methods\311\254\311\40
//
//      AuthenticatorDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      AuthenticatorFriendlyName        (REG_SZ) Sample EAP Protocol


//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//


#define EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\EapHost\\Methods")

#define EAP_AUTHENTICATOR_VALUENAME_DLL_PATH      TEXT("AuthenticatorDllPath")
#define EAP_AUTHENTICATOR_VALUENAME_FRIENDLY_NAME TEXT("AuthenticatorFriendlyName")
#define EAP_AUTHENTICATOR_VALUENAME_PROPERTIES   TEXT("Properties")
#define EAP_AUTHENTICATOR_VALUENAME_CONFIGUI TEXT("AuthenticatorConfigUIPath")

//For authenticator
// Are these needed any more? Or are we going to define better ways of 
// encapsulating them.
//#define EAP_AUTHENTICATOR_VALUENAME_CONFIG_CLSID      TEXT("ConfigCLSID")
//#define EAP_AUTHENTICATOR_VALUENAME_PER_POLICY_CONFIG TEXT("PerPolicyConfig")


typedef
#ifdef __midl
   [v1_enum]
#endif
enum _EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION
{
	// Discard the request as EAP cannot use it.
	EAP_METHOD_AUTHENTICATOR_RESPONSE_DISCARD = 0,
	// Send the packet to the authenticator
	EAP_METHOD_AUTHENTICATOR_RESPONSE_SEND,
	// Respond to EAP by acting on the returned attributes
	EAP_METHOD_AUTHENTICATOR_RESPONSE_RESULT,
	// The supplicant needs to take an action based on the context.
	EAP_METHOD_AUTHENTICATOR_RESPONSE_RESPOND,
   EAP_METHOD_AUTHENTICATOR_RESPONSE_AUTHENTICATE,
   EAP_METHOD_AUTHENTICATOR_RESPONSE_HANDLE_IDENTITY
	// The supplicant needs to take no action at all.
	//EAP_METHOD_AUTHENTICATOR_RESPONSE_NONE
} EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION;


typedef struct _EAP_METHOD_AUTHENTICATOR_RESULT
{
   BOOL fIsSuccess;
   DWORD dwFailureReason;
	EAP_ATTRIBUTES* pAuthAttribs;
} EAP_METHOD_AUTHENTICATOR_RESULT;

// Structures used by EAP methods on the peer to communicate with the host.

// List of functions corresponding to the particular EAP method 
typedef struct _EAP_AUTHENTICATOR_METHOD_ROUTINES 
{  
   // FIXME: Why is the size needed?
   DWORD dwSizeInBytes;
   EAP_METHOD_TYPE* pEapType;


   DWORD (APIENTRY * EapMethodAuthenticatorInitialize) (
            IN EAP_METHOD_TYPE* pEapType, 
            OUT EAP_ERROR** ppEapError
            );

   DWORD (APIENTRY * EapMethodAuthenticatorBeginSession) (
         // Flags to qualify the authentication process.
         IN DWORD dwFlags,
         // Identity of the user being authenticated
         IN LPCWSTR pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // Specifies the size in bytes of the data pointed to by pConnectionData. 
         // If pConnectionData is NULL, this member is zero. 
         IN DWORD dwSizeofConnectionData,
         // Pointer to connection data received from the authentication protocol's 
         // configuration user interface.
         IN const BYTE* const pConnectionData,
         // This is the maximum size of an eap packet that the authenticator can send.
         IN DWORD dwMaxSendPacketSize,
         // The session handle that identifies the current authentication session.
         OUT EAP_SESSION_HANDLE* pSessionHandle,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** pEapError
         );

   DWORD (APIENTRY * EapMethodAuthenticatorUpdateInnerMethodParams)(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD dwFlags,
         IN CONST WCHAR* pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** pEapError         
         );

      // The authenticator calls this any time it receives a packet that the eaphost
      // needs to process. This should be called only after a successful call to
      // EapAuthenticatorBeginSession.
   DWORD (APIENTRY * EapMethodAuthenticatorReceivePacket) (
            // context handle as returned from a successful call to 
            // EapAuthenticatorBeginSession
            IN EAP_SESSION_HANDLE sessionHandle,
            // Specifies the size, in bytes, of the buffer pointed to by 
            // pReceivePacket
            IN DWORD cbReceivePacket,
            // Pointer to a buffer that contains the incoming EAP data received by 
            // the supplicant.
            IN const EapPacket* const pReceivePacket,
            // This enumeration tells the supplicant to take an appropriate action.
            // The supplicant will typically look at this action and either call 
            // another method on eaphost or do something else on its own.
            OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
            // On an unsuccessful call, this will contain any error information about
            // the failure. This will be null on a successful call.      
            OUT EAP_ERROR** pEapError
            );


   DWORD (APIENTRY * EapMethodAuthenticatorSendPacket) (
            // context handle as returned from a successful call to 
            // EapHostAuthenticatorBeginSession
            IN EAP_SESSION_HANDLE sessionHandle,
            // Id to use when constructing the SendPacket
            IN BYTE bPacketId,
            // Specifies the limit on the size, in bytes, on the packet generated
            // by eaphost. On a successful return, this will contain the size of the 
            // data added by the eap module.
            OUT DWORD* pcbSendPacket,
            // Pointer to a buffer that is allocated by the client and populated
            // by the eap module. The value of the incoming buffer is ignored and
            // the method populates it from the beginning of the buffer.
            OUT EapPacket* pSendPacket,
            // Timeout option for sending the packet
            OUT EAP_AUTHENTICATOR_SEND_TIMEOUT* pTimeout,
            // On an unsuccessful call, this will contain any error information about
            // the failure. This will be null on a successful call.      
            OUT EAP_ERROR** pEapError
            );


      // Returns an array of attributes that the caller needs to act on.
      // The supplicant will call this when a call to 
      // EapHostAuthenticatorProcessRequestPacket returns EapHostAuthenticatorResponseRespond. 
   DWORD (APIENTRY * EapMethodAuthenticatorGetAttributes) (
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Array of attributes that the caller needs to act on.
         OUT EapAttributes* pAttribs,
         OUT EAP_ERROR** pEapError
         );


      // Sets an array of attributes that the caller wants the eap method to act 
      // on. 
   DWORD (APIENTRY * EapMethodAuthenticatorSetAttributes) (
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN const EapAttributes* const pAttribs,
         // This enumeration tells the supplicant to take an appropriate action.
         // The supplicant will typically look at this action and either call 
         // another method on eaphost or do something else on its own.
         OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError
         );


      // The authenticator will call this on completion of an authentication. This 
      // can happen in any of the following scenarios:
      // 1. A call to EapHostAuthenticatorReceivePacket returned 
      //    EAP_HOST_AUTHENTICATOR_RESPONSE_SUCCESS or EAP_HOST_AUTHENTICATOR_RESPONSE_FAILURE
      //    Even if the action returned above was a success, the authenticator can choose to call
      //    this method with a failure.
      // 2. The server can choose to terminate an authentication with a failure in the middle of
      //    an authentication.
   DWORD (APIENTRY * EapMethodAuthenticatorGetResult) (
         // context handle as returned from a successful call to 
         // EapHostPeerBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // A structure that indicates the result and any state that the 
         // supplicant needs to save for future authentications.
         OUT EAP_METHOD_AUTHENTICATOR_RESULT* ppResult, 
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** pEapError         
         );


      // Ends the authentication session. This cleans up any state that the eap 
      // method or eaphost might be keeping.
   DWORD (APIENTRY * EapMethodAuthenticatorEndSession) (
         // context handle as returned from a successful call to 
         // EapHostPeerBeginSession. This will be set to NULL on a successful call.
         IN EAP_SESSION_HANDLE sessionHandle, 
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError
      );


   DWORD (APIENTRY * EapMethodAuthenticatorShutdown) (
            IN EAP_METHOD_TYPE* pEapType, 
            OUT EAP_ERROR** ppEapError
            );

} EAP_AUTHENTICATOR_METHOD_ROUTINES, *PEAP_AUTHENTICATOR_METHOD_ROUTINES;


//
// EAP Functions
//
void WINAPI EapMethodAuthenticatorFreeErrorMemory(IN EAP_ERROR* pEapError);
void WINAPI EapMethodAuthenticatorFreeMemory(
        IN void* pUIContextData
        );

DWORD EapMethodAuthenticatorGetInfo(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_AUTHENTICATOR_METHOD_ROUTINES* pEapInfo, 
         OUT EAP_ERROR** ppEapError
         );

DWORD EapMethodAuthenticatorInitialize(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_ERROR** ppEapError
         );

DWORD EapMethodAuthenticatorBeginSession(
      // Flags to qualify the authentication process.
      IN DWORD dwFlags,
      // Initial Id
      IN BYTE bInitialId,
      // Identity of the user being authenticated
      IN LPCWSTR pwszIdentity,
      // Pointer to an array of attributes. This array contains attributes that 
      // describe the entity being authenticated. 
      IN const EapAttributes* const pAttributeArray,
      // Specifies the size in bytes of the data pointed to by pConnectionData. 
      // If pConnectionData is NULL, this member is zero. 
      IN DWORD dwSizeofConnectionData,
      // Pointer to connection data received from the authentication protocol's 
      // configuration user interface.
      IN const BYTE* const pConnectionData,
      // This is the maximum size of an eap packet that the authenticator can send.
      IN DWORD dwMaxSendPacketSize,
      // The session handle that identifies the current authentication session.
      OUT EAP_SESSION_HANDLE* pSessionHandle,
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.
      OUT EAP_ERROR** pEapError
      );

DWORD EapMethodAuthenticatorUpdateInnerMethodParams(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD dwFlags,
         IN CONST WCHAR* pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** pEapError         
         );


   // The authenticator calls this any time it receives a packet that the eaphost
   // needs to process. This should be called only after a successful call to
   // EapAuthenticatorBeginSession.
DWORD EapMethodAuthenticatorReceivePacket(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Specifies the size, in bytes, of the buffer pointed to by 
         // pReceivePacket
         IN DWORD cbReceivePacket,
         // Pointer to a buffer that contains the incoming EAP data received by 
         // the supplicant.
         IN const EapPacket* const pReceivePacket,
         // This enumeration tells the supplicant to take an appropriate action.
         // The supplicant will typically look at this action and either call 
         // another method on eaphost or do something else on its own.
         OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** pEapError
         );


DWORD EapMethodAuthenticatorSendPacket(
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Id to use when constructing the SendPacket
         IN BYTE bPacketId,
         // Specifies the limit on the size, in bytes, on the packet generated
         // by eaphost. On a successful return, this will contain the size of the 
         // data added by the eap module.
         IN OUT DWORD* pcbSendPacket,
         // Pointer to a buffer that is allocated by the client and populated
         // by the eap module. The value of the incoming buffer is ignored and
         // the method populates it from the beginning of the buffer.
         OUT EapPacket* pSendPacket,
         // Timeout option for sending the packet
         OUT EAP_AUTHENTICATOR_SEND_TIMEOUT* pTimeout,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** pEapError
         );


   // Returns an array of attributes that the caller needs to act on.
   // The supplicant will call this when a call to 
   // EapHostAuthenticatorProcessRequestPacket returns EapHostAuthenticatorResponseRespond. 
DWORD EapMethodAuthenticatorGetAttributes(
      // context handle as returned from a successful call to 
      // EapHostAuthenticatorBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      // Array of attributes that the caller needs to act on.
      OUT EapAttributes* pAttribs,
      OUT EAP_ERROR** pEapError
      );



   // Sets an array of attributes that the caller wants the eap method to act 
   // on. 
DWORD EapMethodAuthenticatorSetAttributes(
      // context handle as returned from a successful call to 
      // EapHostAuthenticatorBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      IN const EapAttributes* const pAttribs,
      // This enumeration tells the supplicant to take an appropriate action.
      // The supplicant will typically look at this action and either call 
      // another method on eaphost or do something else on its own.
      OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** ppEapError
      );



   // The authenticator will call this on completion of an authentication. This 
   // can happen in any of the following scenarios:
   // 1. A call to EapHostAuthenticatorReceivePacket returned 
   //    EAP_HOST_AUTHENTICATOR_RESPONSE_SUCCESS or EAP_HOST_AUTHENTICATOR_RESPONSE_FAILURE
   //    Even if the action returned above was a success, the authenticator can choose to call
   //    this method with a failure.
   // 2. The server can choose to terminate an authentication with a failure in the middle of
   //    an authentication.
DWORD EapMethodAuthenticatorGetResult(
      // context handle as returned from a successful call to 
      // EapHostPeerBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      // A structure that indicates the result and any state that the 
      // supplicant needs to save for future authentications.
      OUT EAP_METHOD_AUTHENTICATOR_RESULT* ppResult, 
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** pEapError         
      );


   // Ends the authentication session. This cleans up any state that the eap 
   // method or eaphost might be keeping.
DWORD EapMethodAuthenticatorEndSession(
      // context handle as returned from a successful call to 
      // EapHostPeerBeginSession. This will be set to NULL on a successful call.
      IN EAP_SESSION_HANDLE sessionHandle, 
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** ppEapError
   );


DWORD EapMethodAuthenticatorShutdown(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_ERROR** ppEapError
         );


/// Config API

#define EAP_METHOD_AUTHENTICATOR_CONFIG_IS_IDENTITY_PRIVACY    0x1

DWORD WINAPI EapMethodAuthenticatorInvokeConfigUI(
                IN EAP_METHOD_TYPE* pEapMethodType,
                IN HWND hwndParent,
                IN DWORD dwFlags,
                IN LPCWSTR pwszMachineName,
                IN DWORD dwSizeOfConfigIn,
                IN BYTE* pConfigIn,
                OUT DWORD* pdwSizeOfConfigOut,
                OUT BYTE** ppConfigOut,
                OUT EAP_ERROR** pEapError
                );

#ifdef __cplusplus
}
#endif

#endif // EAP_METHOD_AUTHENTICATOR_APIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\emostore_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Dec 13 23:45:32 2000
 */
/* Compiler settings for P:\admin\src\libs\emolib\EMOSTORE.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExchangeServer,0x25150F47,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IStorageGroup,0x25150F46,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IPublicStoreDB,0x25150F44,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IMailboxStoreDB,0x25150F45,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IFolderTree,0x25150F43,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IDataSource2,0x25150F48,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Dec 13 23:45:32 2000
 */
/* Compiler settings for P:\admin\src\libs\emolib\EMOSTORE.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExchangeServer,0x25150F47,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IStorageGroup,0x25150F46,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IPublicStoreDB,0x25150F44,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IMailboxStoreDB,0x25150F45,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IFolderTree,0x25150F43,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);


MIDL_DEFINE_GUID(IID, IID_IDataSource2,0x25150F48,0x5734,0x11d2,0xA5,0x93,0x00,0xC0,0x4F,0x99,0x0D,0x8A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\EapHostError.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Scenario-specific error codes, reported by EapHost and Eap Method DLLs.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTERROR_H
#define EAPHOSTERROR_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define FACILITY_EAP                   0x0042  // 66L
#define FACILITY_EAP_MESSAGE           0x0842  // 66L + MessageId bit


// Errors common across different groups.
#define _EAP_CERT_FIRST     (+ 0x0)
#define _EAP_CERT_LAST      (+ 0xF)

#define _EAP_CERT_NOT_FOUND           (+ 0x1)
#define _EAP_CERT_INVALID             (+ 0x2)
#define _EAP_CERT_EXPIRED             (+ 0x3)
#define _EAP_CERT_REVOKED             (+ 0x4)
#define _EAP_CERT_OTHER_ERROR         (+ 0x5)
#define _EAP_CERT_REJECTED            (+ 0x6)
#define _EAP_CERT_NAME_REQUIRED       (+ 0x7)

#define _EAP_GENERAL_FIRST  (+ 0x10)   // (+16)
#define _EAP_GENERAL_LAST   (+ 0x3F)   // (+31)

//
// Individual groups of Eap-related Errors.
//

#define EAP_GROUP_MASK       0x0000FF00L


#define EAP_E_EAPHOST_FIRST  0x80420000L
#define EAP_E_EAPHOST_LAST   0x804200FFL
#define EAP_I_EAPHOST_FIRST  0x80420000L
#define EAP_I_EAPHOST_LAST   0x804200FFL

// Cert-Store can't be accessed on either authenticator or peer
#define EAP_E_CERT_STORE_INACCESSIBLE               0x80420010  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 0)

// Requested EAP-method is not installed
#define EAP_E_EAPHOST_METHOD_NOT_INSTALLED          0x80420011  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 1)

// 
#define EAP_E_EAPHOST_THIRDPARTY_METHOD_HOST_RESET  0x80420012  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 2)

// EAPHost not able to communicate with EAPQEC on a NAP enabled client
#define EAP_E_EAPHOST_EAPQEC_INACCESSIBLE           0x80420013  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 3)

// EAPHost returns this error, if the authenticator fails the authentication after peer sent its identity
#define EAP_E_EAPHOST_IDENTITY_UNKNOWN              0x80420014  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 4)

// EAPHost returns this error on authentication failure.
#define EAP_E_AUTHENTICATION_FAILED                 0x80420015  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 5)

// EAPHost returns this error, when the client & the server aren't configured with compatible EAP-types.
#define EAP_I_EAPHOST_EAP_NEGOTIATION_FAILED        0x40420016  // (EAP_I_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 6)

// EAPMethod received an EAP packet that can not be processed
#define EAP_E_EAPHOST_METHOD_INVALID_PACKET         0x80420017  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 7)

// EAPHost received a packet that can not be processed. 
#define EAP_E_EAPHOST_REMOTE_INVALID_PACKET         0x80420018  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 8)

// EAPHost ConfigSchema validation failed
#define EAP_E_EAPHOST_XML_MALFORMED                 0x80420019  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 9)

// EAPHost returns this error, when a configured EAP-method does not support a requested operation (procedure call)
#define EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED                 0x80420020  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 10)


#define EAP_E_USER_FIRST  0x80420100L
#define EAP_E_USER_LAST   0x804201FFL
#define EAP_I_USER_FIRST  0x40420100L
#define EAP_I_USER_LAST   0x404201FFL

// EAPHost could not find user-certificate for authentication    
#define EAP_E_USER_CERT_NOT_FOUND           0x80420100  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// user-cert being user for authentication does not have proper usage (EKU) set 
#define EAP_E_USER_CERT_INVALID             0x80420101  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found user-cert which has expired already
#define EAP_E_USER_CERT_EXPIRED             0x80420102  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// user-cert being used for authentication has been revoked
#define EAP_E_USER_CERT_REVOKED             0x80420103  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with user-cert being used for authentication
#define EAP_E_USER_CERT_OTHER_ERROR         0x80420104  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)

// Authenticator rejected user-cert for authentication
#define EAP_E_USER_CERT_REJECTED            0x80420105  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REJECTED)

// Received EAP-Failure after Identity exchange:  There is likely a problem with the authenticating user's account.
#define EAP_I_USER_ACCOUNT_OTHER_ERROR      0x40420110  // (EAP_I_USER_FIRST + _EAP_GENERAL_FIRST + 0

// Authenticator rejected user credentials for authentication 
#define EAP_E_USER_CREDENTIALS_REJECTED     0x80420111  // (EAP_E_USER_FIRST + _EAP_GENERAL_FIRST + 1)


#define EAP_E_SERVER_FIRST  0x80420200L
#define EAP_E_SERVER_LAST   0x804202FFL

// EAPHost could not find server-certificate for authentication    
#define EAP_E_SERVER_CERT_NOT_FOUND         0x80420200  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// server-cert being user for authentication does not have proper usage (EKU) set  
#define EAP_E_SERVER_CERT_INVALID           0x80420201  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found server-cert which has expired already
#define EAP_E_SERVER_CERT_EXPIRED           0x80420202  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// server-cert being used for authentication has been revoked
#define EAP_E_SERVER_CERT_REVOKED           0x80420203  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with server-cert being used for authentication
#define EAP_E_SERVER_CERT_OTHER_ERROR       0x80420204  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)


#define EAP_E_USER_ROOT_CERT_FIRST  0x80420300L
#define EAP_E_USER_ROOT_CERT_LAST   0x804203FFL


// EAPHost could not find a certificate in trusted-root cert-store for user cert velidation
#define EAP_E_USER_ROOT_CERT_NOT_FOUND      0x80420300  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the root certificate used for this network is invalid
#define EAP_E_USER_ROOT_CERT_INVALID        0x80420301  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// Trusted root certificate needed for user-cert validation has been expired.
#define EAP_E_USER_ROOT_CERT_EXPIRED        0x80420302  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

#define EAP_E_SERVER_ROOT_CERT_FIRST  0x80420400L
#define EAP_E_SERVER_ROOT_CERT_LAST   0x804204FFL

// EAPHost could not find a Root certificate in trusted-root cert-store for server cert velidation
#define EAP_E_SERVER_ROOT_CERT_NOT_FOUND        0x80420400  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the server certificate required for this network on the server computer is invalid
#define EAP_E_SERVER_ROOT_CERT_INVALID          0x80420401  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// The authentication failed because the certificate on the server computer does not have a server name specified
#define EAP_E_SERVER_ROOT_CERT_NAME_REQUIRED    0x80420406  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NAME_REQUIRED)


// Alternate names for certain errors.
#define EAP_METHOD_INVALID_PACKET  EAP_E_EAPHOST_METHOD_INVALID_PACKET
#define EAP_INVALID_PACKET         EAP_E_EAPHOST_REMOTE_INVALID_PACKET

// This is not a fixed GUID when it reaches supplicant, but 1st portion will be 
// filled by Generic Win32/Ras error. This helps create unique GUID for every 
// unique error that we don't understand. This helps collect SQM data.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Default \
        = { 0x00000000, 0x0000, 0x0000, 0, 0, 0, 0, 0, 0, 0, 0 };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDLLNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 1 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactSysadmin \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 2 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_CertStoreInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Generic_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_IdentityUnknown \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 4 } };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 5 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 6 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 7 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 9 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xA } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xB } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xC } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xD } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Account_OtherProblem \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CredsRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xF } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x10 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x11 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNameRequired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapQecInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 3, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Server_ClientSelectServerCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x18 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x19 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_GetNewCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1A } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_SelectValidCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Retry_Authentication \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapNegotiationFailed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1C } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_XmlMalformed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1D } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDoesNotSupportOperation \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1E } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_ObtainingCerts \
        = { 0xf535eea3, 0x1bdd, 0x46ca, { 0xa2, 0xfc, 0xa6, 0x65, 0x59, 0x39, 0xb7, 0xe8 } };

// This currently is a generic networking troubleshooting help page, not EAP specific.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_Troubleshooting \
        = { 0x33307acf, 0x0698, 0x41ba, { 0xb0, 0x14, 0xea, 0x0a, 0x2e, 0xb8, 0xd0, 0xa8 } };

#ifdef __cplusplus
}
#endif

#endif // EAPHOSTERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\edevdefs.h ===
//------------------------------------------------------------------------------
// File: EDevDefs.h
//
// Desc: External Device (such as a VCR) control interface parameter and
//       value definitions.  
//
//       Note:  new constants added:  ED_BASE+800L -> ED_BASE+811L
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __EDEVDEFS__
#define __EDEVDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Serial Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of device's synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns device's normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show device's input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on device's output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// device's output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L    // pause recording	
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// or'd  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L

#endif // __EDEVDEFS__

// eof edevdefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eappapis.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares apis to invoke peer apis on eaphost.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPAPIS_H
#define EAPPAPIS_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef void (CALLBACK *NotificationHandler) (
                 IN GUID connectionId,
                 IN void* pContextData
                 );


// General note about the memory allocated for the OUT parameters:
//
// If memory is dynamically allocated for the OUT parameters, the memory
// will be available until the caller makes the next call. If the caller
// want to keep the content cross multiple calls, the caller must keep its
// own copy.
// To have all the allocated memory (allocated by this DLL) reclaimed,
// the caller finally must call either EapHostPeerEndSession() or
// EapHostPeerClearConnection().
//
// EAP_ERROR** OUT parameter is an exception. The caller must call
// EapHostPeerFreeEapError() to free the memory.
//
//
// Thread safety:
// EapHostPeerInitialize() and EapHostPeerUninitialize() are always thread
// safe.
//
// EapHostPeerFreeEapError() is not thread safe. There should be only one
// thread being called to free the same EAP_ERROR*. And obviously it should
// not be called more than once for the same EAP_ERROR*.
//
// For all the other functions, there should only be one thread calling them
// for the same session. However, it is safe for multiple threads to call them
// for different sessions.
//
// If the functions succeed, they return ERROR_SUCCESS. Otherwise, it is
// considered failure.
//
// If an error code is returned, the out parameter ppEapError will contain
// related error information. The caller is expected to look into it to
// find out the error informations.
// However, there are some situation that it may not be possible to fill
// out information for ppEapError. For example, in out of memory situation,
// the method implementation may not be able to allocate memory for
// ppEapError as well. If for any reason it is not possible to fill ppEapError,
// *ppEapError should be set to NULL.


// Must call this before it starts to call any other fucntion.
// If this function fails, no other EapHostPeer... functions can be called.
//
// Inside this function, it calls CoInitializeEx(NULL, COINIT_MULTITHREADED)
// So the client should not initialize a conflicting COM environment.
// If the client really needs a different COM environment, it should use the
// COM APIs directly instead of using this C style APIs.
DWORD APIENTRY EapHostPeerInitialize();

// Must call this after it is done calling any other EapHostPeer...
// functions.
// Inside this function it calls CoUninitialize().
void APIENTRY EapHostPeerUninitialize();

// If this function succeeds, no matter the calls to other functions
// succeed or fail, the caller MUST call EapHostPeerEndSession() to end
// the authentication session. if EapHostPeerBeginSession() provides a
// valid GUID to register the connectionand, then EapHostPeerClearConnection()
// must be called at the very end (i.e. there will be no more authentication
// on this GUID) to remove the connection. The connection GUID
// is valid cross multiple authentications.
//
// However, if this function fails, the caller can not proceed with
// other calls. It should NOT call EapHostPeerEndSession() or
// EapHostPeerClearConnection() if this function fails.
//
// For the same pConnectionId, EapHostPeerEndSession() must be called
// before EapHostPeerBeginSession() can be called again.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapType:
//   the EAP method type to be used for the authentication.
//
// - pAttributeArray:
//   attributes passed to the method.
//
// - hTokenImpersonateUser:
//   Impersonation token for the user to be authenticated.
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   See the comment for pConnectionData for EapPeerGetIdentity()
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes
//
// - pUserData:
//   user data returned from EapPeerGetIdentity()
//
// - dwMaxSendPacketSize:
//   maximum packet size that the method can send. If the method needs to
//   send a message larger than this size, the method has to handle fragmentation
//   and resembling.
//
// - pConnectionId:
//   It can be NULL. Otherwise, it should point to a valid GUID which respresent
//   the connection. When re-authentication is needed due to system health change,
//   the callback function func will be called and this GUID pointer will
//   be passed as an IN parameter to indicate which connection the callback
//   is for.
//
// - func:
//   callback function pointer used for re-authentication. This function
//   will be called when system health changes and a re-authentication is needed.
//   if the function handler is NULL, pContextData will be ignored,
//   and it means the caller is not interested in system health change
//   notification
//
// - pSessionId:
//   Return session ID in it. This is used to identify the authentication session.
DWORD APIENTRY
EapHostPeerBeginSession(
   IN DWORD dwFlags,
   IN EAP_METHOD_TYPE eapType,
   IN const EapAttributes* const pAttributeArray,
   IN HANDLE hTokenImpersonateUser,
   IN DWORD dwSizeofConnectionData,
   IN const BYTE* const pConnectionData,
   IN DWORD dwSizeofUserData,
   IN const BYTE* const pUserData,
   IN DWORD dwMaxSendPacketSize,
   // If the supplicant is intrested in re-auth caused by NAP health change,
   // it should provide a unique GUID.
   // When this function is called by PEAP inner method, it will be NULL.
   //
   // When pConnectionId is NULL, func and pContextData will be ignored.
   IN const GUID* const pConnectionId,
   // if the function handler is NULL, pContextData will be ignored,
   // and it means the caller is not interested in SoH change notification
   // from EapQec.
   IN NotificationHandler func,
   // a pointer to some data that the supplicant want to associate with
   // the connection when NotificationHandler call back is called.
   // When NotificationHandler is called, it will be called as:
   // func(*pCOnnectionId, pContextData).
   IN void* pContextData,
   OUT EAP_SESSIONID* pSessionId,
   OUT EAP_ERROR** ppEapError
   );



// Supplicant will pass the packet to EAPHost for processing.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - cbReceivePacket:
//   buffer size of (pReceivePacket) in bytes
//
// - pReceivePacket:
//   pointer to received packet
//
// - pEapOutput:
//   It will tell the supplicant what's the next EAPHost API that it should call.
DWORD APIENTRY
EapHostPeerProcessReceivedPacket(
   IN EAP_SESSIONID sessionHandle,
   IN DWORD cbReceivePacket,
   IN const BYTE* const pReceivePacket,
   OUT EapHostPeerResponseAction* pEapOutput,
   OUT EAP_ERROR** ppEapError
   );


// This function returns the packet to be sent. Supplicant should send the
// returned packet to server.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pcbSendPacket:
//   Upon return, *pcbSendPacket is the sizeof the actual content in pSendPacket
//
// - ppSendPacket:
//   pointer to a buffer that contains the packet to send upon return
DWORD APIENTRY
EapHostPeerGetSendPacket(
   IN EAP_SESSIONID sessionHandle,
	OUT DWORD* pcbSendPacket,
	OUT BYTE** ppSendPacket,
	OUT EAP_ERROR** ppEapError
	);


// Supplicant calls this function to retrieve authentication result.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - reason:
//   One of the reason code defined in eaphostPeerTypes.h
//
// - ppResult:
//   EAPHost will fill this struct with related information as defined
//   by EapHostPeerMethodResult
DWORD APIENTRY
EapHostPeerGetResult(
   IN EAP_SESSIONID sessionHandle,
	IN EapHostPeerMethodResultReason reason,
	OUT EapHostPeerMethodResult* ppResult,
	OUT EAP_ERROR** ppEapError
	   );


// This will get called if UI should be raised during authentication session.
// This function will always be followed by EapHostPeerInvokeInteractiveUI()
// and then followed by EapHostPeerSetUIContext()
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pdwSizeOfUIContextData:
//   *pdwSizeOfUIContextData is the size of *ppUIContextData in bytes.
//
// - ppUIContextData:
//   It will be passed to EapHostPeerInvokeInteractiveUI() as IN parameter
//   pUIContextData
DWORD APIENTRY
EapHostPeerGetUIContext(
   IN EAP_SESSIONID sessionHandle,
   OUT DWORD* pdwSizeOfUIContextData,
   OUT BYTE** ppUIContextData,
	OUT EAP_ERROR** ppEapError
   );


// It will be called after UI has been raised. Refer to EapHostPeerGetUIContext()
// for more information.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - dwSizeOfUIContextData:
//   size of pUIContextData in bytes.
//
// - pUIContextData:
//   This is the data returned from EapHostPeerInvokeInteractiveUI() OUT
//   parameter
//   *ppDataFromInteractiveUI
//
// - pEapOutput:
//   It will tell the supplicant what's the next EAPHost API that it should call.
DWORD APIENTRY
EapHostPeerSetUIContext(
   IN EAP_SESSIONID sessionHandle,
   IN DWORD dwSizeOfUIContextData,
   IN const BYTE* const pUIContextData,
   OUT EapHostPeerResponseAction* pEapOutput,
	OUT EAP_ERROR** ppEapError
	);


// Return EAP attributes to supplicant. Supplicant should call
// EapHostPeerSetResponseAttributes() after it calls this function and finishes
// processing of the EAP attributes.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pAttributes:
//   EAP attributes returned to supplicant.
DWORD APIENTRY
EapHostPeerGetResponseAttributes(
   IN EAP_SESSIONID sessionHandle,
   OUT EapAttributes* pAttribs,
	OUT EAP_ERROR** ppEapError
   );


// See EapHostPeerGetResponseAttributes() for when this function will be called.
// Even if supplicant doesn't care about or doesn't understand the attributes
// returned from EapHostPeerGetResponseAttributes(), it should still call
// this function and pass a valid EapAttributes* which contains 0 EapAttribute
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pAttribs:
//   EAP attributes that the supplicant passes to EAPHost
DWORD APIENTRY
EapHostPeerSetResponseAttributes(
   IN EAP_SESSIONID sessionHandle,
   IN const EapAttributes* const pAttribs,
   OUT EapHostPeerResponseAction* pEapOutput,
	OUT EAP_ERROR** ppEapError
   );


// Supplicant calls it to retrieve authentication status.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - authParam:
//   one of the EapHostPeerAuthParams values defined in Eaphostpeertypes.h
//
// - pcbAuthData:
//   *pcbAuthData is the size of *ppAuthData in bytes
//
// - ppAuthData:
//   contains the returned authentication data. Interpretation of the data
//   depends on the "authParam" passed in
DWORD APIENTRY
EapHostPeerGetAuthStatus(
   IN EAP_SESSIONID sessionHandle,
   IN EapHostPeerAuthParams authParam,
   OUT DWORD* pcbAuthData,
   OUT BYTE** ppAuthData,
   OUT EAP_ERROR** ppEapError
   );


// Authentication has finished so clear up the data stored for this session.
// After this call, the session will no longer be valid.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
DWORD APIENTRY
EapHostPeerEndSession(
   IN EAP_SESSIONID sessionHandle,
   OUT EAP_ERROR** ppEapError
   );


// Clear up the connection. After this call, all states associated with this
// pConnectionId will be deleted, and no re-authentication will be triggered
// for connection associated with this GUID.
//
// Parameters:
// - pConnectionId:
//   the same connection GUID passed into EapHostPeerBeginSession(). If
//   a NULL is passed to EapHostPeerBeginSession() as the connection id,
//   then there is no need to call this API.
DWORD APIENTRY
EapHostPeerClearConnection(
   IN GUID* pConnectionId,
   OUT EAP_ERROR** ppEapError
   );


// If any of the previous function is called, and an EAP_ERROR is returned,
// this function must be called to free the memory.
void APIENTRY EapHostPeerFreeEapError(IN EAP_ERROR* pEapError);

// EAPHost will call this function, and it would return user data and user identity.

DWORD APIENTRY
EapHostPeerGetIdentity (
      // API's version number for ease of interoperability. It must be 0.
      IN DWORD dwVersion,
      // EAP_FLAG_xxx defined in eaptypes.w
      IN DWORD dwFlags,
      // Eap method type
      IN EAP_METHOD_TYPE eapMethodType,
      // size of the buffer (pConnectionData) in bytes
      IN DWORD dwSizeofConnectionData,
      // configuration data that is used for the EAP method
      IN __in_ecount(dwSizeofConnectionData) const BYTE* pConnectionData,
      // size of the ubuffer pUserData
      IN DWORD dwSizeofUserData,
      // user credential information pertinent to this auth
      IN __in_ecount_opt(dwSizeofUserData) const BYTE* pUserData,
      // impersonation token for logged on user, to obtain user-related information
      IN HANDLE hTokenImpersonateUser,
      // should return true if the user identity and user data blob can not be returned
      // successfully and in needs to be collected through UI
      OUT BOOL* pfInvokeUI,
      // size of the buffer pUserDataOut. caller should free this using EapHostPeerFreeRuntimeMemory
      IN OUT DWORD* pdwSizeOfUserDataOut,
      // user data information returned by method.
      OUT __deref_out_ecount(*pdwSizeOfUserDataOut) BYTE** ppUserDataOut,
      // identity returned by method. caller should free this using EapHostPeerFreeRuntimeMemory
      OUT __deref_out LPWSTR* ppwszIdentity,
      // In case of error, API fills ppEapError if possible. Caller should free ppEapError
      // using EapHostPeerFreeErrorMemory
      OUT EAP_ERROR** ppEapError,
      // Reserved for future usage. It must be NULL.
      IN OUT BYTE **ppvReserved
      );

// In case of GetInentity returned memory needs to be released using this API
void APIENTRY EapHostPeerFreeRuntimeMemory (IN BYTE* pData);


#ifdef __cplusplus
}
#endif

#endif // EAPPAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eapmethodpeerapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that are needed by eap methods on the Peer.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPEERMETHODAPIS_H
#define EAPPEERMETHODAPIS_H
#pragma once

#include "objbase.h"
#include "msxml6.h"
#include "EapMethodTypes.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\[EapTypeId])
//
// Custom EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\254\[VendorId]\[EapTypeId])
//
// Custom Expanded EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     VendorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\254\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1


#define EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\EapHost\\Methods")

#define EAP_PEER_VALUENAME_DLL_PATH          TEXT("PeerDllPath")
#define EAP_PEER_VALUENAME_FRIENDLY_NAME     TEXT("PeerFriendlyName")
#define EAP_PEER_VALUENAME_CONFIGUI          TEXT("PeerConfigUIPath")
#define EAP_PEER_VALUENAME_REQUIRE_CONFIGUI  TEXT("PeerRequireConfigUI")
#define EAP_PEER_VALUENAME_IDENTITY          TEXT("PeerIdentityPath")
#define EAP_PEER_VALUENAME_INTERACTIVEUI     TEXT("PeerInteractiveUIPath")
#define EAP_PEER_VALUENAME_INVOKE_NAMEDLG    TEXT("PeerInvokeUsernameDialog")
#define EAP_PEER_VALUENAME_INVOKE_PWDDLG     TEXT("PeerInvokePasswordDialog")
#define EAP_PEER_VALUENAME_PROPERTIES        TEXT("Properties")


// ENUMERATIONS USED by EAP methods on the peer to communicate their status to
// EapHost.

typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResponseAction
{
        // Discard the request as EAP cannot use it.
        EapPeerMethodResponseActionDiscard = 0,
        // Send the packet to the authenticator
        EapPeerMethodResponseActionSend,
        // Respond to EAP by acting on the returned attributes
        EapPeerMethodResponseActionResult,
        // Invoke appropriate UI based on the context
        EapPeerMethodResponseActionInvokeUI,
        // The supplicant needs to take an action based on the context.
        EapPeerMethodResponseActionRespond,
        // The supplicant needs to take no action at all.
        EapPeerMethodResponseActionNone
} EapPeerMethodResponseAction;


typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResultReason
{
   EapPeerMethodResultUnknown = 1,
   EapPeerMethodResultSuccess,
   EapPeerMethodResultFailure
} EapPeerMethodResultReason;


// Structures used by EAP methods on the peer to communicate with the host.

typedef struct tagEapPeerMethodOuput
{
        //EapPeerMethodDecision decision;
        //EapPeerMethodState state;
        EapPeerMethodResponseAction action;
        BOOL fAllowNotifications;
} EapPeerMethodOutput;

// This structure is used in EapPeerGetResult API to convey the authentication result and pass
// additional information to the EapHost and Supplicant.
typedef struct tagEapPeerMethodResult
{
        BOOL fIsSuccess;
   DWORD dwFailureReasonCode;
        BOOL fSaveConnectionData;
        DWORD dwSizeofConnectionData;
   __field_bcount(dwSizeofConnectionData) BYTE* pConnectionData;
        BOOL fSaveUserData;
        DWORD dwSizeofUserData;
   __field_bcount(dwSizeofUserData) BYTE* pUserData;
   EAP_ATTRIBUTES* pAttribArray;
    EAP_ERROR* pEapError;
} EapPeerMethodResult;


// List of functions corresponding to the particular EAP method
typedef struct _EAP_PEER_METHOD_ROUTINES
{
   DWORD dwVersion;
   EAP_TYPE* pEapType;

   DWORD (APIENTRY * EapPeerInitialize) (EAP_ERROR** pEapError);

   DWORD (APIENTRY * EapPeerGetIdentity) (
                        IN DWORD flags,
                        IN DWORD dwSizeofConnectionData,
                        IN const BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN const BYTE* pUserData,
                        IN HANDLE hTokenImpersonateUser,
                        OUT BOOL* pfInvokeUI,
                        IN OUT DWORD* pdwSizeOfUserDataOut,
                        OUT BYTE** ppUserDataOut,
                        OUT WCHAR** ppwszIdentity,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerBeginSession) (
                        IN DWORD dwFlags,
                        IN const EapAttributes* const pAttributeArray,
                        IN HANDLE hTokenImpersonateUser,
                        IN DWORD dwSizeofConnectionData,
                        IN BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN BYTE* pUserData,
                        IN DWORD dwMaxSendPacketSize,
                        OUT EAP_SESSION_HANDLE* pSessionHandle,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetCredentials) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN WCHAR* pwszIdentity,
                        IN WCHAR* pwszPassword,
                        OUT EAP_ERROR** pEapError
                        );
   DWORD (APIENTRY * EapPeerProcessRequestPacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD cbReceivePacket,
                        IN EapPacket* pReceivePacket,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponsePacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN OUT DWORD* pcbSendPacket,
                        OUT EapPacket* pSendPacket,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResult) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapPeerMethodResultReason reason,
                        OUT EapPeerMethodResult* ppResult,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT DWORD* dwSizeOfUIContextData,
                        OUT BYTE** pUIContextData,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD dwSizeOfUIContextData,
                        IN const BYTE* pUIContextData,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EapAttributes* pAttribs,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapAttributes* pAttribs,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerEndSession) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerShutdown) (OUT EAP_ERROR** pEapError);
} EAP_PEER_METHOD_ROUTINES;



//
// EAP Functions
//

// General comment regarding all APIs defined in this file:
//
// If the function succeeds, it returns ERROR_SUCCESS. Otherwise, it is
// considered failure.
//
// If an error code is returned, the out parameter ppEapError will contain
// related error information. The caller is expected to look into it to
// find out the error informations.
// However, there are some situation that it may not be possible to fill
// out information for ppEapError. For example, in out of memory situation,
// the method implementation may not be able to allocate memory for
// ppEapError as well. If for any reason it is not possible to fill ppEapError,
// *ppEapError should be set to NULL.


// This function should be an exported function from the DLL
//
// If any other APIs in this file returns EAP_ERROR, use this
// function to free the memory allocated for it
VOID WINAPI EapPeerFreeErrorMemory(IN EAP_ERROR* pEapError);


// This function should be an exported function from the DLL
//
// Returns information related to a given EAP type.
// Parameters:
// - pEapType:
//   the EAP type for this EAP method. Implementation should check this input
//   to make sure that it is the same as the method being implemented.
//
// - pEapInfo:
//   returns all the information related for pEapType.
DWORD WINAPI EapPeerGetInfo(
         IN EAP_TYPE* pEapType,
         OUT EAP_PEER_METHOD_ROUTINES* pEapInfo,
         OUT EAP_ERROR** ppEapError
         );


// This is the first function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should initialize
// everything needed for this method work properly.
DWORD WINAPI EapPeerInitialize(OUT EAP_ERROR** pEapError);


// EAPHost will call this function, and it would return user data
// and user identity.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   connection data specific to this method. It will be used to decide
//   the user data returned from this API, when the user data depends on
//   certain connection data configuration. The method implementation should
//   have default values for connection data, and when this parameter
//   is NULL, the default connection data should be used.
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes.
//
// - pUserData:
//   the user data specific to this authentication. It will be used to
//   pre-populate the user data.
//   When this API is called for the first time, or when it needs to start
//   a fresh authentication sessin, this parameter will be NULL.
//   When it is not NULL, its content should be the user data returned
//   from EapPeerGetResult() (*ppResult)->pUserData from previous successful
//   authentication session, if that session indicated that user data should be
//   saved.
//
// - pfInvokeUI:
//   should return true if the user identity and user data blob can not be
//   returned successfully and the method decides that it has to collect the
//   information from the user through UI.
//
// - pdwSizeOfUserDataOut:
//   *pdwSizeOfUserDataOut is the size of buffer *ppUserDataOut
//
// - ppUserDataOut:
//   returned user data. The data will be passed to EapPeerBeginSession()
//   as input pUserData
//
// - ppwszIdentity:
//   returned user identity. It will be included in the identity response packet
//   and returned to the server.
DWORD WINAPI EapPeerGetIdentity (
                IN DWORD dwFlags,
                IN DWORD dwSizeofConnectionData,
                IN const BYTE* pConnectionData,
                IN DWORD dwSizeofUserData,
                IN const BYTE* pUserData,
                IN HANDLE hTokenImpersonateUser,
                OUT BOOL* pfInvokeUI,
                IN OUT DWORD* pdwSizeOfUserDataOut,
                OUT BYTE** ppUserDataOut,
                OUT __out LPWSTR* ppwszIdentity,
                OUT EAP_ERROR** ppEapError
                );


// Start an authentication session.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - pAttributeArray:
//   attributes passed to the method.
//
// - hTokenImpersonateUser:
//   Impersonation token for the user to be authenticated.
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   See the comment for pConnectionData for EapPeerGetIdentity()
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes
//
// - pUserData:
//   user data returned from EapPeerGetIdentity()
//
// - dwMaxSendPacketSize:
//   maximum packet size that the method can send. If the method needs to
//   send a message larger than this size, the method has to handle fragmentation
//   and resembling.
//
// - pSessionHandle:
//   This is an "identifier" of the authentication session.
//   When other EapPeerXxxx() functions with a sessionHandle parameter
//   being called, *pSessionHandle will be passed as the session handle.
//   The method should be able to use this to find the information related
//   the authentication session.
DWORD WINAPI EapPeerBeginSession(
         IN DWORD dwFlags,
         IN const EapAttributes* const pAttributeArray,
         IN HANDLE hTokenImpersonateUser,
         IN DWORD dwSizeofConnectionData,
         IN BYTE* pConnectionData,
         IN DWORD dwSizeofUserData,
         IN BYTE* pUserData,
         IN DWORD dwMaxSendPacketSize,
         OUT EAP_SESSION_HANDLE* pSessionHandle,
         OUT EAP_ERROR** pEapError
         );


// A method exports either EapPeerGetIdentity (and EapPeerInvokeIdentityUI) or
// exports EapPeerSetCredentials (and sets the InvokeUserNameDlg regkey). The
// registry key controls which of the two apis will get called.
DWORD WINAPI EapPeerSetCredentials(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN __in LPWSTR pwszIdentity,
         IN __in LPWSTR pwszPassword,
         OUT EAP_ERROR** pEapError
         );


// EAPHost will pass the packet to the method for processing.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - cbRecevedPacket:
//   buffer size of (pReceivePacket) in bytes
//
// - pReceivedPacket:
//   pointer to received packet
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerProcessRequestPacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD cbReceivedPacket,
         IN EapPacket* pReceivedPacket,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** pEapError
         );


// This function returns the packet to be sent to the server.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pcbSendPacket:
//   *pcbSendPacket is the size of the buffer for (pSendPacket) when passed in.
//   Upon return, *pcbSendPacket is the sizeof the actual content in pSendPacket
//
// - pSendPacket:
//   pointer to a buffer that contains the packet to send upon return
DWORD WINAPI EapPeerGetResponsePacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN OUT DWORD* pcbSendPacket,
         OUT EapPacket* pSendPacket,
         OUT EAP_ERROR** pEapError
         );


// This will get called either when a method says that it has completed auth.
// or when the lower layer receives an alternative result.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - reason:
//   one of the reason enum defined above in this file.
//
// - ppResult:
//   Method should fill this struct with related information as defined
//   by EapPeerMethodResult
DWORD WINAPI EapPeerGetResult(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapPeerMethodResultReason reason,
         OUT EapPeerMethodResult* ppResult,
         OUT EAP_ERROR** pEapError
         );

// This will get called if UI should be raised during authentication session.
// This function will always be followed by EapPeerInvokeInteractiveUI() and
// then followed by EapPeerSetUIContext()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pdwSizeOfUIContextData:
//   *pdwSizeOfUIContextData is the size of *ppUIContextData in bytes.
//
// - ppUIContextData:
//   It will be passed to EapPeerInvokeInteractiveUI() as IN parameter
//   pUIContextData
DWORD WINAPI EapPeerGetUIContext(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT DWORD* pdwSizeOfUIContextData,
         OUT BYTE** ppUIContextData,
         OUT EAP_ERROR** pEapError
      );


// It will be called after UI has been raised. Refer to EapPeerGetUIContext()
// for more information.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - dwSizeOfUIContextData:
//   size of pUIContextData in bytes.
//
// - pUIContextData:
//   This is the data returned from EapPeerInvokeInteractiveUI() OUT parameter
//   *ppDataFromInteractiveUI
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetUIContext(
        IN EAP_SESSION_HANDLE sessionHandle,
        IN DWORD dwSizeOfUIContextData,
        IN const BYTE* pUIContextData,
        OUT EapPeerMethodOutput* pEapOutput,
        OUT EAP_ERROR** pEapError
     );


// If EAPHost calls any of the EapPeerXxxx() function, and that function has
// pEapOutput as a OUT parameter, and the action code in it is
// EapPeerMethodResponseActionRespond, this function will be the next function
// that EAPHost will call.
// And it will be follow by a call to EapPeerSetResponseAttributes()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   method should fill this with the attributes it need to return.
DWORD WINAPI EapPeerGetResponseAttributes(
        IN EAP_SESSION_HANDLE sessionHandle,
        OUT EapAttributes* pAttribs,
        OUT EAP_ERROR** pEapError
     );


// See EapPeerGetResponseAttributes() for when this function will be called.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   attributes passed to this method.
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetResponseAttributes(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapAttributes* pAttribs,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** pEapError
      );

// The last function that will be called for this authentication session.
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
DWORD WINAPI EapPeerEndSession(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT EAP_ERROR** pEapError
         );

// This is the last function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should un-initialize
// everything for this method.
DWORD WINAPI EapPeerShutdown(OUT EAP_ERROR** pEapError);


// It should raise a configuration UI so that the user can configure the method
// parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeOfConnectionDataIn:
//   size of pConnectionDataIn in bytes
//
// - pConnectionDataIn:
//   Used to pre-populate the configuration UI. The first time this function
//   is called, or if it is desired to start from scratch, it will be NULL,
//   otherwise, it will be the data returned from previous
//   EapPeerInvokeConfigUI() ppConnectionDataOut OUT parameter
//
// - pdwSizeOfConnectionDataOut:
//   *pdwSizeOfConnectionDataOut is the size of *ppConnectionDataOut
//
// - ppConnectionDataOut:
//   *ppConnectionDataOut is configuration data returned from this functioin.
//   It will be used to pass to next EapPeerInvokeConfigUI() call.
DWORD WINAPI EapPeerInvokeConfigUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwFlags,
         IN DWORD dwSizeOfConnectionDataIn,
         IN BYTE* pConnectionDataIn,
         OUT DWORD* pdwSizeOfConnectionDataOut,
         OUT BYTE** ppConnectionDataOut,
         OUT EAP_ERROR** pEapError
         );

// This function should raise interactive UI for the Method. What UI to be raised and how to raise
// is Method specific information that is embedded in pUIContextData.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
// - dwSizeofUIContextData:
//   Number of bytes of UIContext data referred by pUIContextData.
// - pUIContextData:
//   A blob that conveys the state of the authentication and describes what and how to show the UI
//   to the user.
// - pdwSizeOfDataFromInteractiveUI
//   Number of bytes of blob referred by *ppDataFromInteractiveUI.
// - ppDataFromInteractiveUI
//   A UI context blob that captures the result of UI interaction
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeInteractiveUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwSizeofUIContextData,
         IN BYTE* pUIContextData,
         OUT DWORD* pdwSizeOfDataFromInteractiveUI,
         OUT BYTE** ppDataFromInteractiveUI,
         OUT EAP_ERROR** pEapError
         );


// This function should raise credential UI for the Method. Method can use the configuration passed in to
// decide what kind of UI should be shown to the user.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwSizeOfConnectionData:
//   Number of bytes of pConnectionData.
//
// - pConnectionData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pUserData
//   Cached credential blob. This would be NULL if this is the first time successful authentication is being done.
//
// - ppwszIdentity
//   Pointer to unicode string that receives the identity that EapHost should use as part of EAP Identity reponse.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeIdentityUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN DWORD dwFlags,
         IN HWND hwndParent,
         IN DWORD dwSizeOfConnectionData,
         IN const BYTE* pConnectionData,
         IN DWORD dwSizeOfUserData,
         IN const BYTE* pUserData,
         OUT DWORD* pdwSizeOfUserDataOut,
         OUT BYTE** ppUserDataOut,
         OUT __out LPWSTR* ppwszIdentity,
         OUT EAP_ERROR** pEapError
         );


// This function returns credential fields to be shown to the user for the authentication. As part of this function
// Method should not bring up UI instead it should describe what credentials are to be obtained. Based on the
// return values, Supplicant draws the UI to the user and obtains the requested credentials.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that receives array of credential fields.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         OUT EAP_CONFIG_INPUT_FIELD_ARRAY* pEapConfigFieldsArray,
         OUT EAP_ERROR** pEapError
         );


// This function returns credential blob based on the credentials passed in the credential array structure.
// Method should not bring up UI. It should convert the credentials in to a blob that could be passed to
// EapPeerBeginSession.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that contains array of credential fields filled by supplicant.
//
// - pdwUserBlobSize:
//  Pointer to DWORD that receives the size of the ppbUserBlob.
//
// - ppbUserBlob
//  Pointer to buffer that receives credential blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryUserBlobFromCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
         // pointer to DWORD that receives size of credential blob, if EAPHost passes in
         // non-zero size and non-NULL data below, EAP-method will just attempt to Update
         // the blob with passed in values (if supported) instead of creating a new one. EAP-method
         // is not expected to release the passed in buffer, EAPHost will release it after API completion..
         IN OUT DWORD *pdwUserBlobSize,
         IN OUT __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
         OUT EAP_ERROR** pEapError
         );

// This function returns fields to be displayed during interactive time when alternative UI is used.
// Method should not bring up UI in this function.
//
DWORD WINAPI EapPeerQueryInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        //structure that gets filled with fields and how they should be shown to the user.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT EAP_INTERACTIVE_UI_DATA* pEapInteractiveUIData,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *pvReserved
        );

// This function returns interactive UI blob from the UI fields filled by the user
//
DWORD WINAPI EapPeerQueryUIBlobFromInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        // structure that carries data provided by user
        IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
        // pointer to DWORD that receives size of credential blob
        OUT DWORD * pdwSizeOfDataFromInteractiveUI,
        // Pointer that receives the credential blob that can be used in authentication.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *pvReserved
        );


// This function converts XML document containing configuration information into a blob that could be passed to other
// APIs that expect configuration blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pConfigDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the configuration XML
//
// - ppConfigOut
//   Pointer to buffer that receives configuration blob.
//
// - pdwSizeOfConfigOut
//   Pointer to DWORD that receives size of ppConfigOut.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pConfigDoc,
                OUT __out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                OUT DWORD* pdwSizeOfConfigOut,
                OUT EAP_ERROR** pEapError
                );


// This function converts XML document containing credential information into a blob that could be passed to other
// APIs that expect credential blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pCredentialsDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the credential XML
//
// - pConfigIn
//   Pointer to buffer that contains configuration blob.
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppCredentialsOut
//  Pointer to buffer that receives the credential blob
//
// - pdwSizeOfCredentialsOut
//  Pointer to DWORD that receives size of ppCredentialsOut
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerCredentialsXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pCredentialsDoc,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT __out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                OUT DWORD* pdwSizeOfCredentialsOut,
                OUT EAP_ERROR** pEapError
                );


// This function converts configuration blob into configuration XML document. Methods exporting this API
// will be supporting exporting of and importing of configuration with out problem. It also helps administrators
// modify the configuration.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pConfigIn:
//   Configuration blob
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppConfigDoc
//  Pointer to IXMLDOMDocument2 that receives configuration XML for the given configuration blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigBlob2Xml(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT IXMLDOMDocument2** ppConfigDoc,
                OUT EAP_ERROR** pEapError
                );


// This function frees memory returned by the configuration APIs. This function is called by EapHost when
// it is done with the memory returned by the Method.
//
// Parameters:
// - pUIContextData:
//   Any memory returned by configuration APIs.
//
VOID WINAPI EapPeerFreeMemory(
        IN void* pUIContextData
        );

#ifdef __cplusplus
}
#endif

#endif // EAP_PEER_METHOD_APIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\emostore.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Dec 13 23:45:32 2000
 */
/* Compiler settings for P:\admin\src\libs\emolib\EMOSTORE.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __EMOSTORE_h__
#define __EMOSTORE_h__

/* Forward Declarations */ 

#ifndef __IExchangeServer_FWD_DEFINED__
#define __IExchangeServer_FWD_DEFINED__
typedef interface IExchangeServer IExchangeServer;
#endif 	/* __IExchangeServer_FWD_DEFINED__ */


#ifndef __IStorageGroup_FWD_DEFINED__
#define __IStorageGroup_FWD_DEFINED__
typedef interface IStorageGroup IStorageGroup;
#endif 	/* __IStorageGroup_FWD_DEFINED__ */


#ifndef __IPublicStoreDB_FWD_DEFINED__
#define __IPublicStoreDB_FWD_DEFINED__
typedef interface IPublicStoreDB IPublicStoreDB;
#endif 	/* __IPublicStoreDB_FWD_DEFINED__ */


#ifndef __IMailboxStoreDB_FWD_DEFINED__
#define __IMailboxStoreDB_FWD_DEFINED__
typedef interface IMailboxStoreDB IMailboxStoreDB;
#endif 	/* __IMailboxStoreDB_FWD_DEFINED__ */


#ifndef __IFolderTree_FWD_DEFINED__
#define __IFolderTree_FWD_DEFINED__
typedef interface IFolderTree IFolderTree;
#endif 	/* __IFolderTree_FWD_DEFINED__ */


#ifndef __IDataSource2_FWD_DEFINED__
#define __IDataSource2_FWD_DEFINED__
typedef interface IDataSource2 IDataSource2;
#endif 	/* __IDataSource2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "msado15.h"
#include "cdoex.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_EMOSTORE_0000 */
/* [local] */ 







typedef 
enum CDOEXMStoreDBStatus
    {	cdoexmOnline	= 0,
	cdoexmOffline	= 0x1,
	cdoexmMounting	= 0x2,
	cdoexmDismounting	= 0x3
    }	CDOEXMStoreDBStatus;

typedef 
enum CDOEXMFolderTreeType
    {	cdoexmGeneralPurpose	= 0,
	cdoexmMAPI	= 0x1,
	cdoexmNNTPOnly	= 0x2
    }	CDOEXMFolderTreeType;

typedef 
enum CDOEXMServerType
    {	cdoexmBackEnd	= 0,
	cdoexmFrontEnd	= 0x1
    }	CDOEXMServerType;



extern RPC_IF_HANDLE __MIDL_itf_EMOSTORE_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_EMOSTORE_0000_v0_0_s_ifspec;

#ifndef __IExchangeServer_INTERFACE_DEFINED__
#define __IExchangeServer_INTERFACE_DEFINED__

/* interface IExchangeServer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IExchangeServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F47-5734-11d2-A593-00C04F990D8A")
    IExchangeServer : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExchangeVersion( 
            /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StorageGroups( 
            /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SubjectLoggingEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSubjectLoggingEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SubjectLoggingEnabled( 
            /* [in] */ VARIANT_BOOL varSubjectLoggingEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MessageTrackingEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MessageTrackingEnabled( 
            /* [in] */ VARIANT_BOOL varMessageTrackingEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeLogFileRemoval( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeLogFileRemoval( 
            /* [in] */ long varDaysBeforeLogFileRemoval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerType( 
            /* [retval][out] */ CDOEXMServerType __RPC_FAR *pServerType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ServerType( 
            /* [in] */ CDOEXMServerType varServerType) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DirectoryServer( 
            /* [retval][out] */ BSTR __RPC_FAR *varDirectoryServer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExchangeServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExchangeServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExchangeServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IExchangeServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExchangeVersion )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StorageGroups )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubjectLoggingEnabled )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSubjectLoggingEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubjectLoggingEnabled )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varSubjectLoggingEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageTrackingEnabled )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageTrackingEnabled )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varMessageTrackingEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeLogFileRemoval )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeLogFileRemoval )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ long varDaysBeforeLogFileRemoval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerType )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ CDOEXMServerType __RPC_FAR *pServerType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ServerType )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ CDOEXMServerType varServerType);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectoryServer )( 
            IExchangeServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDirectoryServer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IExchangeServer __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IExchangeServerVtbl;

    interface IExchangeServer
    {
        CONST_VTBL struct IExchangeServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExchangeServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExchangeServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExchangeServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExchangeServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExchangeServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExchangeServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExchangeServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExchangeServer_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IExchangeServer_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IExchangeServer_get_Name(This,varName)	\
    (This)->lpVtbl -> get_Name(This,varName)

#define IExchangeServer_get_ExchangeVersion(This,varExchangeVersion)	\
    (This)->lpVtbl -> get_ExchangeVersion(This,varExchangeVersion)

#define IExchangeServer_get_StorageGroups(This,varStorageGroups)	\
    (This)->lpVtbl -> get_StorageGroups(This,varStorageGroups)

#define IExchangeServer_get_SubjectLoggingEnabled(This,pSubjectLoggingEnabled)	\
    (This)->lpVtbl -> get_SubjectLoggingEnabled(This,pSubjectLoggingEnabled)

#define IExchangeServer_put_SubjectLoggingEnabled(This,varSubjectLoggingEnabled)	\
    (This)->lpVtbl -> put_SubjectLoggingEnabled(This,varSubjectLoggingEnabled)

#define IExchangeServer_get_MessageTrackingEnabled(This,pMessageTrackingEnabled)	\
    (This)->lpVtbl -> get_MessageTrackingEnabled(This,pMessageTrackingEnabled)

#define IExchangeServer_put_MessageTrackingEnabled(This,varMessageTrackingEnabled)	\
    (This)->lpVtbl -> put_MessageTrackingEnabled(This,varMessageTrackingEnabled)

#define IExchangeServer_get_DaysBeforeLogFileRemoval(This,pDaysBeforeLogFileRemoval)	\
    (This)->lpVtbl -> get_DaysBeforeLogFileRemoval(This,pDaysBeforeLogFileRemoval)

#define IExchangeServer_put_DaysBeforeLogFileRemoval(This,varDaysBeforeLogFileRemoval)	\
    (This)->lpVtbl -> put_DaysBeforeLogFileRemoval(This,varDaysBeforeLogFileRemoval)

#define IExchangeServer_get_ServerType(This,pServerType)	\
    (This)->lpVtbl -> get_ServerType(This,pServerType)

#define IExchangeServer_put_ServerType(This,varServerType)	\
    (This)->lpVtbl -> put_ServerType(This,varServerType)

#define IExchangeServer_get_DirectoryServer(This,varDirectoryServer)	\
    (This)->lpVtbl -> get_DirectoryServer(This,varDirectoryServer)

#define IExchangeServer_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_DataSource_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IExchangeServer_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_Fields_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IExchangeServer_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_Name_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varName);


void __RPC_STUB IExchangeServer_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_ExchangeVersion_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varExchangeVersion);


void __RPC_STUB IExchangeServer_get_ExchangeVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_StorageGroups_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varStorageGroups);


void __RPC_STUB IExchangeServer_get_StorageGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_SubjectLoggingEnabled_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSubjectLoggingEnabled);


void __RPC_STUB IExchangeServer_get_SubjectLoggingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_put_SubjectLoggingEnabled_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varSubjectLoggingEnabled);


void __RPC_STUB IExchangeServer_put_SubjectLoggingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_MessageTrackingEnabled_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pMessageTrackingEnabled);


void __RPC_STUB IExchangeServer_get_MessageTrackingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_put_MessageTrackingEnabled_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varMessageTrackingEnabled);


void __RPC_STUB IExchangeServer_put_MessageTrackingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_DaysBeforeLogFileRemoval_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeLogFileRemoval);


void __RPC_STUB IExchangeServer_get_DaysBeforeLogFileRemoval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_put_DaysBeforeLogFileRemoval_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [in] */ long varDaysBeforeLogFileRemoval);


void __RPC_STUB IExchangeServer_put_DaysBeforeLogFileRemoval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_ServerType_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ CDOEXMServerType __RPC_FAR *pServerType);


void __RPC_STUB IExchangeServer_get_ServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_put_ServerType_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [in] */ CDOEXMServerType varServerType);


void __RPC_STUB IExchangeServer_put_ServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_get_DirectoryServer_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDirectoryServer);


void __RPC_STUB IExchangeServer_get_DirectoryServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IExchangeServer_GetInterface_Proxy( 
    IExchangeServer __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IExchangeServer_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExchangeServer_INTERFACE_DEFINED__ */


#ifndef __IStorageGroup_INTERFACE_DEFINED__
#define __IStorageGroup_INTERFACE_DEFINED__

/* interface IStorageGroup */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IStorageGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F46-5734-11d2-A593-00C04F990D8A")
    IStorageGroup : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PublicStoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MailboxStoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFilePath( 
            /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SystemFilePath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CircularLogging( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCircularLogging) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_CircularLogging( 
            /* [in] */ VARIANT_BOOL varCircularLogging) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ZeroDatabase( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ZeroDatabase( 
            /* [in] */ VARIANT_BOOL varZeroDatabase) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveLogFiles( 
            /* [in] */ BSTR LogFilePath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveSystemFiles( 
            /* [in] */ BSTR SystemFilePath,
            /* [optional][in] */ long Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStorageGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStorageGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStorageGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStorageGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublicStoreDBs )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MailboxStoreDBs )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LogFilePath )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SystemFilePath )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CircularLogging )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCircularLogging);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CircularLogging )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varCircularLogging);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZeroDatabase )( 
            IStorageGroup __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZeroDatabase )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varZeroDatabase);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLogFiles )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR LogFilePath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSystemFiles )( 
            IStorageGroup __RPC_FAR * This,
            /* [in] */ BSTR SystemFilePath,
            /* [optional][in] */ long Flags);
        
        END_INTERFACE
    } IStorageGroupVtbl;

    interface IStorageGroup
    {
        CONST_VTBL struct IStorageGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStorageGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStorageGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStorageGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStorageGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStorageGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStorageGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStorageGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStorageGroup_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IStorageGroup_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IStorageGroup_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IStorageGroup_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IStorageGroup_get_PublicStoreDBs(This,varPublicStoreDBs)	\
    (This)->lpVtbl -> get_PublicStoreDBs(This,varPublicStoreDBs)

#define IStorageGroup_get_MailboxStoreDBs(This,varMailboxStoreDBs)	\
    (This)->lpVtbl -> get_MailboxStoreDBs(This,varMailboxStoreDBs)

#define IStorageGroup_get_LogFilePath(This,varLogFilePath)	\
    (This)->lpVtbl -> get_LogFilePath(This,varLogFilePath)

#define IStorageGroup_get_SystemFilePath(This,varSystemFilePath)	\
    (This)->lpVtbl -> get_SystemFilePath(This,varSystemFilePath)

#define IStorageGroup_get_CircularLogging(This,pCircularLogging)	\
    (This)->lpVtbl -> get_CircularLogging(This,pCircularLogging)

#define IStorageGroup_put_CircularLogging(This,varCircularLogging)	\
    (This)->lpVtbl -> put_CircularLogging(This,varCircularLogging)

#define IStorageGroup_get_ZeroDatabase(This,pZeroDatabase)	\
    (This)->lpVtbl -> get_ZeroDatabase(This,pZeroDatabase)

#define IStorageGroup_put_ZeroDatabase(This,varZeroDatabase)	\
    (This)->lpVtbl -> put_ZeroDatabase(This,varZeroDatabase)

#define IStorageGroup_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IStorageGroup_MoveLogFiles(This,LogFilePath,Flags)	\
    (This)->lpVtbl -> MoveLogFiles(This,LogFilePath,Flags)

#define IStorageGroup_MoveSystemFiles(This,SystemFilePath,Flags)	\
    (This)->lpVtbl -> MoveSystemFiles(This,SystemFilePath,Flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_DataSource_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IStorageGroup_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_Fields_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IStorageGroup_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_Name_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IStorageGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_put_Name_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IStorageGroup_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_PublicStoreDBs_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varPublicStoreDBs);


void __RPC_STUB IStorageGroup_get_PublicStoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_MailboxStoreDBs_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varMailboxStoreDBs);


void __RPC_STUB IStorageGroup_get_MailboxStoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_LogFilePath_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varLogFilePath);


void __RPC_STUB IStorageGroup_get_LogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_SystemFilePath_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSystemFilePath);


void __RPC_STUB IStorageGroup_get_SystemFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_CircularLogging_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCircularLogging);


void __RPC_STUB IStorageGroup_get_CircularLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_put_CircularLogging_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varCircularLogging);


void __RPC_STUB IStorageGroup_put_CircularLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_get_ZeroDatabase_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pZeroDatabase);


void __RPC_STUB IStorageGroup_get_ZeroDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_put_ZeroDatabase_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varZeroDatabase);


void __RPC_STUB IStorageGroup_put_ZeroDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_GetInterface_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IStorageGroup_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_MoveLogFiles_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR LogFilePath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IStorageGroup_MoveLogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStorageGroup_MoveSystemFiles_Proxy( 
    IStorageGroup __RPC_FAR * This,
    /* [in] */ BSTR SystemFilePath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IStorageGroup_MoveSystemFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStorageGroup_INTERFACE_DEFINED__ */


#ifndef __IPublicStoreDB_INTERFACE_DEFINED__
#define __IPublicStoreDB_INTERFACE_DEFINED__

/* interface IPublicStoreDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IPublicStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F44-5734-11d2-A593-00C04F990D8A")
    IPublicStoreDB : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FolderTree( 
            /* [retval][out] */ BSTR __RPC_FAR *pFolderTree) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FolderTree( 
            /* [in] */ BSTR varFolderTree) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DBPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SLVPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL varEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StoreQuota( 
            /* [retval][out] */ long __RPC_FAR *pStoreQuota) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StoreQuota( 
            /* [in] */ long varStoreQuota) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HardLimit( 
            /* [retval][out] */ long __RPC_FAR *pHardLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HardLimit( 
            /* [in] */ long varHardLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ItemSizeLimit( 
            /* [retval][out] */ long __RPC_FAR *pItemSizeLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ItemSizeLimit( 
            /* [in] */ long varItemSizeLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeItemExpiration( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeItemExpiration) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeItemExpiration( 
            /* [in] */ long varDaysBeforeItemExpiration) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeGarbageCollection( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeGarbageCollection( 
            /* [in] */ long varDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GarbageCollectOnlyAfterBackup( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GarbageCollectOnlyAfterBackup( 
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveDataFiles( 
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Mount( 
            /* [optional][in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [optional][in] */ long Timeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublicStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublicStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublicStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FolderTree )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pFolderTree);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FolderTree )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varFolderTree);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBPath )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SLVPath )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StoreQuota )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStoreQuota);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StoreQuota )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ long varStoreQuota);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HardLimit )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHardLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HardLimit )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ long varHardLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ItemSizeLimit )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pItemSizeLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ItemSizeLimit )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ long varItemSizeLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeItemExpiration )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeItemExpiration);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeItemExpiration )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ long varDaysBeforeItemExpiration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeGarbageCollection )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeGarbageCollection )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ long varDaysBeforeGarbageCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GarbageCollectOnlyAfterBackup )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GarbageCollectOnlyAfterBackup )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDataFiles )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Mount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dismount )( 
            IPublicStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        END_INTERFACE
    } IPublicStoreDBVtbl;

    interface IPublicStoreDB
    {
        CONST_VTBL struct IPublicStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublicStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublicStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublicStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublicStoreDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPublicStoreDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPublicStoreDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPublicStoreDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPublicStoreDB_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IPublicStoreDB_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IPublicStoreDB_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IPublicStoreDB_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IPublicStoreDB_get_FolderTree(This,pFolderTree)	\
    (This)->lpVtbl -> get_FolderTree(This,pFolderTree)

#define IPublicStoreDB_put_FolderTree(This,varFolderTree)	\
    (This)->lpVtbl -> put_FolderTree(This,varFolderTree)

#define IPublicStoreDB_get_DBPath(This,varDBPath)	\
    (This)->lpVtbl -> get_DBPath(This,varDBPath)

#define IPublicStoreDB_get_SLVPath(This,varSLVPath)	\
    (This)->lpVtbl -> get_SLVPath(This,varSLVPath)

#define IPublicStoreDB_get_Status(This,varStatus)	\
    (This)->lpVtbl -> get_Status(This,varStatus)

#define IPublicStoreDB_get_Enabled(This,pEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pEnabled)

#define IPublicStoreDB_put_Enabled(This,varEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,varEnabled)

#define IPublicStoreDB_get_StoreQuota(This,pStoreQuota)	\
    (This)->lpVtbl -> get_StoreQuota(This,pStoreQuota)

#define IPublicStoreDB_put_StoreQuota(This,varStoreQuota)	\
    (This)->lpVtbl -> put_StoreQuota(This,varStoreQuota)

#define IPublicStoreDB_get_HardLimit(This,pHardLimit)	\
    (This)->lpVtbl -> get_HardLimit(This,pHardLimit)

#define IPublicStoreDB_put_HardLimit(This,varHardLimit)	\
    (This)->lpVtbl -> put_HardLimit(This,varHardLimit)

#define IPublicStoreDB_get_ItemSizeLimit(This,pItemSizeLimit)	\
    (This)->lpVtbl -> get_ItemSizeLimit(This,pItemSizeLimit)

#define IPublicStoreDB_put_ItemSizeLimit(This,varItemSizeLimit)	\
    (This)->lpVtbl -> put_ItemSizeLimit(This,varItemSizeLimit)

#define IPublicStoreDB_get_DaysBeforeItemExpiration(This,pDaysBeforeItemExpiration)	\
    (This)->lpVtbl -> get_DaysBeforeItemExpiration(This,pDaysBeforeItemExpiration)

#define IPublicStoreDB_put_DaysBeforeItemExpiration(This,varDaysBeforeItemExpiration)	\
    (This)->lpVtbl -> put_DaysBeforeItemExpiration(This,varDaysBeforeItemExpiration)

#define IPublicStoreDB_get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)

#define IPublicStoreDB_put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)

#define IPublicStoreDB_get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)

#define IPublicStoreDB_put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)

#define IPublicStoreDB_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IPublicStoreDB_MoveDataFiles(This,DBPath,SLVPath,Flags)	\
    (This)->lpVtbl -> MoveDataFiles(This,DBPath,SLVPath,Flags)

#define IPublicStoreDB_Mount(This,Timeout)	\
    (This)->lpVtbl -> Mount(This,Timeout)

#define IPublicStoreDB_Dismount(This,Timeout)	\
    (This)->lpVtbl -> Dismount(This,Timeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DataSource_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IPublicStoreDB_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Fields_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IPublicStoreDB_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Name_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IPublicStoreDB_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_Name_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IPublicStoreDB_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_FolderTree_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pFolderTree);


void __RPC_STUB IPublicStoreDB_get_FolderTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_FolderTree_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varFolderTree);


void __RPC_STUB IPublicStoreDB_put_FolderTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DBPath_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDBPath);


void __RPC_STUB IPublicStoreDB_get_DBPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_SLVPath_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);


void __RPC_STUB IPublicStoreDB_get_SLVPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Status_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus);


void __RPC_STUB IPublicStoreDB_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_Enabled_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);


void __RPC_STUB IPublicStoreDB_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_Enabled_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varEnabled);


void __RPC_STUB IPublicStoreDB_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_StoreQuota_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStoreQuota);


void __RPC_STUB IPublicStoreDB_get_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_StoreQuota_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ long varStoreQuota);


void __RPC_STUB IPublicStoreDB_put_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_HardLimit_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHardLimit);


void __RPC_STUB IPublicStoreDB_get_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_HardLimit_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ long varHardLimit);


void __RPC_STUB IPublicStoreDB_put_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_ItemSizeLimit_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pItemSizeLimit);


void __RPC_STUB IPublicStoreDB_get_ItemSizeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_ItemSizeLimit_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ long varItemSizeLimit);


void __RPC_STUB IPublicStoreDB_put_ItemSizeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DaysBeforeItemExpiration_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeItemExpiration);


void __RPC_STUB IPublicStoreDB_get_DaysBeforeItemExpiration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_DaysBeforeItemExpiration_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ long varDaysBeforeItemExpiration);


void __RPC_STUB IPublicStoreDB_put_DaysBeforeItemExpiration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_DaysBeforeGarbageCollection_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);


void __RPC_STUB IPublicStoreDB_get_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_DaysBeforeGarbageCollection_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ long varDaysBeforeGarbageCollection);


void __RPC_STUB IPublicStoreDB_put_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_get_GarbageCollectOnlyAfterBackup_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);


void __RPC_STUB IPublicStoreDB_get_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_put_GarbageCollectOnlyAfterBackup_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);


void __RPC_STUB IPublicStoreDB_put_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_GetInterface_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IPublicStoreDB_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_MoveDataFiles_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [in] */ BSTR DBPath,
    /* [in] */ BSTR SLVPath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IPublicStoreDB_MoveDataFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_Mount_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IPublicStoreDB_Mount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPublicStoreDB_Dismount_Proxy( 
    IPublicStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IPublicStoreDB_Dismount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublicStoreDB_INTERFACE_DEFINED__ */


#ifndef __IMailboxStoreDB_INTERFACE_DEFINED__
#define __IMailboxStoreDB_INTERFACE_DEFINED__

/* interface IMailboxStoreDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMailboxStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F45-5734-11d2-A593-00C04F990D8A")
    IMailboxStoreDB : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PublicStoreDB( 
            /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_PublicStoreDB( 
            /* [in] */ BSTR varPublicStoreDB) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OfflineAddressList( 
            /* [retval][out] */ BSTR __RPC_FAR *pOfflineAddressList) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OfflineAddressList( 
            /* [in] */ BSTR varOfflineAddressList) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DBPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SLVPath( 
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL varEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StoreQuota( 
            /* [retval][out] */ long __RPC_FAR *pStoreQuota) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StoreQuota( 
            /* [in] */ long varStoreQuota) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OverQuotaLimit( 
            /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_OverQuotaLimit( 
            /* [in] */ long varOverQuotaLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HardLimit( 
            /* [retval][out] */ long __RPC_FAR *pHardLimit) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HardLimit( 
            /* [in] */ long varHardLimit) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeGarbageCollection( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeGarbageCollection( 
            /* [in] */ long varDaysBeforeGarbageCollection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DaysBeforeDeletedMailboxCleanup( 
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeDeletedMailboxCleanup) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DaysBeforeDeletedMailboxCleanup( 
            /* [in] */ long varDaysBeforeDeletedMailboxCleanup) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GarbageCollectOnlyAfterBackup( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GarbageCollectOnlyAfterBackup( 
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveDataFiles( 
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Mount( 
            /* [optional][in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [optional][in] */ long Timeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailboxStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailboxStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailboxStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublicStoreDB )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublicStoreDB )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varPublicStoreDB);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OfflineAddressList )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pOfflineAddressList);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OfflineAddressList )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR varOfflineAddressList);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBPath )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varDBPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SLVPath )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StoreQuota )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStoreQuota);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StoreQuota )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ long varStoreQuota);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OverQuotaLimit )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OverQuotaLimit )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ long varOverQuotaLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HardLimit )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHardLimit);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HardLimit )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ long varHardLimit);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeGarbageCollection )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeGarbageCollection )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ long varDaysBeforeGarbageCollection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DaysBeforeDeletedMailboxCleanup )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDaysBeforeDeletedMailboxCleanup);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DaysBeforeDeletedMailboxCleanup )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ long varDaysBeforeDeletedMailboxCleanup);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GarbageCollectOnlyAfterBackup )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GarbageCollectOnlyAfterBackup )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDataFiles )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [in] */ BSTR DBPath,
            /* [in] */ BSTR SLVPath,
            /* [optional][in] */ long Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Mount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dismount )( 
            IMailboxStoreDB __RPC_FAR * This,
            /* [optional][in] */ long Timeout);
        
        END_INTERFACE
    } IMailboxStoreDBVtbl;

    interface IMailboxStoreDB
    {
        CONST_VTBL struct IMailboxStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailboxStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailboxStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailboxStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailboxStoreDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailboxStoreDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailboxStoreDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailboxStoreDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailboxStoreDB_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IMailboxStoreDB_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IMailboxStoreDB_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IMailboxStoreDB_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IMailboxStoreDB_get_PublicStoreDB(This,pPublicStoreDB)	\
    (This)->lpVtbl -> get_PublicStoreDB(This,pPublicStoreDB)

#define IMailboxStoreDB_put_PublicStoreDB(This,varPublicStoreDB)	\
    (This)->lpVtbl -> put_PublicStoreDB(This,varPublicStoreDB)

#define IMailboxStoreDB_get_OfflineAddressList(This,pOfflineAddressList)	\
    (This)->lpVtbl -> get_OfflineAddressList(This,pOfflineAddressList)

#define IMailboxStoreDB_put_OfflineAddressList(This,varOfflineAddressList)	\
    (This)->lpVtbl -> put_OfflineAddressList(This,varOfflineAddressList)

#define IMailboxStoreDB_get_DBPath(This,varDBPath)	\
    (This)->lpVtbl -> get_DBPath(This,varDBPath)

#define IMailboxStoreDB_get_SLVPath(This,varSLVPath)	\
    (This)->lpVtbl -> get_SLVPath(This,varSLVPath)

#define IMailboxStoreDB_get_Status(This,varStatus)	\
    (This)->lpVtbl -> get_Status(This,varStatus)

#define IMailboxStoreDB_get_Enabled(This,pEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pEnabled)

#define IMailboxStoreDB_put_Enabled(This,varEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,varEnabled)

#define IMailboxStoreDB_get_StoreQuota(This,pStoreQuota)	\
    (This)->lpVtbl -> get_StoreQuota(This,pStoreQuota)

#define IMailboxStoreDB_put_StoreQuota(This,varStoreQuota)	\
    (This)->lpVtbl -> put_StoreQuota(This,varStoreQuota)

#define IMailboxStoreDB_get_OverQuotaLimit(This,pOverQuotaLimit)	\
    (This)->lpVtbl -> get_OverQuotaLimit(This,pOverQuotaLimit)

#define IMailboxStoreDB_put_OverQuotaLimit(This,varOverQuotaLimit)	\
    (This)->lpVtbl -> put_OverQuotaLimit(This,varOverQuotaLimit)

#define IMailboxStoreDB_get_HardLimit(This,pHardLimit)	\
    (This)->lpVtbl -> get_HardLimit(This,pHardLimit)

#define IMailboxStoreDB_put_HardLimit(This,varHardLimit)	\
    (This)->lpVtbl -> put_HardLimit(This,varHardLimit)

#define IMailboxStoreDB_get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> get_DaysBeforeGarbageCollection(This,pDaysBeforeGarbageCollection)

#define IMailboxStoreDB_put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)	\
    (This)->lpVtbl -> put_DaysBeforeGarbageCollection(This,varDaysBeforeGarbageCollection)

#define IMailboxStoreDB_get_DaysBeforeDeletedMailboxCleanup(This,pDaysBeforeDeletedMailboxCleanup)	\
    (This)->lpVtbl -> get_DaysBeforeDeletedMailboxCleanup(This,pDaysBeforeDeletedMailboxCleanup)

#define IMailboxStoreDB_put_DaysBeforeDeletedMailboxCleanup(This,varDaysBeforeDeletedMailboxCleanup)	\
    (This)->lpVtbl -> put_DaysBeforeDeletedMailboxCleanup(This,varDaysBeforeDeletedMailboxCleanup)

#define IMailboxStoreDB_get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> get_GarbageCollectOnlyAfterBackup(This,pGarbageCollectOnlyAfterBackup)

#define IMailboxStoreDB_put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)	\
    (This)->lpVtbl -> put_GarbageCollectOnlyAfterBackup(This,varGarbageCollectOnlyAfterBackup)

#define IMailboxStoreDB_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#define IMailboxStoreDB_MoveDataFiles(This,DBPath,SLVPath,Flags)	\
    (This)->lpVtbl -> MoveDataFiles(This,DBPath,SLVPath,Flags)

#define IMailboxStoreDB_Mount(This,Timeout)	\
    (This)->lpVtbl -> Mount(This,Timeout)

#define IMailboxStoreDB_Dismount(This,Timeout)	\
    (This)->lpVtbl -> Dismount(This,Timeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DataSource_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IMailboxStoreDB_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Fields_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IMailboxStoreDB_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Name_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IMailboxStoreDB_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_Name_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IMailboxStoreDB_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_PublicStoreDB_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPublicStoreDB);


void __RPC_STUB IMailboxStoreDB_get_PublicStoreDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_PublicStoreDB_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varPublicStoreDB);


void __RPC_STUB IMailboxStoreDB_put_PublicStoreDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_OfflineAddressList_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pOfflineAddressList);


void __RPC_STUB IMailboxStoreDB_get_OfflineAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_OfflineAddressList_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR varOfflineAddressList);


void __RPC_STUB IMailboxStoreDB_put_OfflineAddressList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DBPath_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varDBPath);


void __RPC_STUB IMailboxStoreDB_get_DBPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_SLVPath_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varSLVPath);


void __RPC_STUB IMailboxStoreDB_get_SLVPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Status_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ CDOEXMStoreDBStatus __RPC_FAR *varStatus);


void __RPC_STUB IMailboxStoreDB_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_Enabled_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);


void __RPC_STUB IMailboxStoreDB_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_Enabled_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varEnabled);


void __RPC_STUB IMailboxStoreDB_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_StoreQuota_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStoreQuota);


void __RPC_STUB IMailboxStoreDB_get_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_StoreQuota_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ long varStoreQuota);


void __RPC_STUB IMailboxStoreDB_put_StoreQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_OverQuotaLimit_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOverQuotaLimit);


void __RPC_STUB IMailboxStoreDB_get_OverQuotaLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_OverQuotaLimit_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ long varOverQuotaLimit);


void __RPC_STUB IMailboxStoreDB_put_OverQuotaLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_HardLimit_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHardLimit);


void __RPC_STUB IMailboxStoreDB_get_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_HardLimit_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ long varHardLimit);


void __RPC_STUB IMailboxStoreDB_put_HardLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DaysBeforeGarbageCollection_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeGarbageCollection);


void __RPC_STUB IMailboxStoreDB_get_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_DaysBeforeGarbageCollection_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ long varDaysBeforeGarbageCollection);


void __RPC_STUB IMailboxStoreDB_put_DaysBeforeGarbageCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_DaysBeforeDeletedMailboxCleanup_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDaysBeforeDeletedMailboxCleanup);


void __RPC_STUB IMailboxStoreDB_get_DaysBeforeDeletedMailboxCleanup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_DaysBeforeDeletedMailboxCleanup_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ long varDaysBeforeDeletedMailboxCleanup);


void __RPC_STUB IMailboxStoreDB_put_DaysBeforeDeletedMailboxCleanup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_get_GarbageCollectOnlyAfterBackup_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pGarbageCollectOnlyAfterBackup);


void __RPC_STUB IMailboxStoreDB_get_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_put_GarbageCollectOnlyAfterBackup_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL varGarbageCollectOnlyAfterBackup);


void __RPC_STUB IMailboxStoreDB_put_GarbageCollectOnlyAfterBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_GetInterface_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IMailboxStoreDB_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_MoveDataFiles_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [in] */ BSTR DBPath,
    /* [in] */ BSTR SLVPath,
    /* [optional][in] */ long Flags);


void __RPC_STUB IMailboxStoreDB_MoveDataFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_Mount_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IMailboxStoreDB_Mount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailboxStoreDB_Dismount_Proxy( 
    IMailboxStoreDB __RPC_FAR * This,
    /* [optional][in] */ long Timeout);


void __RPC_STUB IMailboxStoreDB_Dismount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailboxStoreDB_INTERFACE_DEFINED__ */


#ifndef __IFolderTree_INTERFACE_DEFINED__
#define __IFolderTree_INTERFACE_DEFINED__

/* interface IFolderTree */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IFolderTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F43-5734-11d2-A593-00C04F990D8A")
    IFolderTree : public IDispatch
    {
    public:
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR varName) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StoreDBs( 
            /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TreeType( 
            /* [retval][out] */ CDOEXMFolderTreeType __RPC_FAR *varTreeType) = 0;
        
        virtual /* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RootFolderURL( 
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolderTree __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolderTree __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolderTree __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ BSTR varName);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StoreDBs )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TreeType )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ CDOEXMFolderTreeType __RPC_FAR *varTreeType);
        
        /* [readonly][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RootFolderURL )( 
            IFolderTree __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            IFolderTree __RPC_FAR * This,
            /* [in] */ BSTR Interface,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);
        
        END_INTERFACE
    } IFolderTreeVtbl;

    interface IFolderTree
    {
        CONST_VTBL struct IFolderTreeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderTree_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolderTree_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolderTree_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolderTree_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolderTree_get_DataSource(This,varDataSource)	\
    (This)->lpVtbl -> get_DataSource(This,varDataSource)

#define IFolderTree_get_Fields(This,varFields)	\
    (This)->lpVtbl -> get_Fields(This,varFields)

#define IFolderTree_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IFolderTree_put_Name(This,varName)	\
    (This)->lpVtbl -> put_Name(This,varName)

#define IFolderTree_get_StoreDBs(This,varStoreDBs)	\
    (This)->lpVtbl -> get_StoreDBs(This,varStoreDBs)

#define IFolderTree_get_TreeType(This,varTreeType)	\
    (This)->lpVtbl -> get_TreeType(This,varTreeType)

#define IFolderTree_get_RootFolderURL(This,varRootFolderURL)	\
    (This)->lpVtbl -> get_RootFolderURL(This,varRootFolderURL)

#define IFolderTree_GetInterface(This,Interface,ppUnknown)	\
    (This)->lpVtbl -> GetInterface(This,Interface,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_DataSource_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ IDataSource2 __RPC_FAR *__RPC_FAR *varDataSource);


void __RPC_STUB IFolderTree_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_Fields_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ Fields __RPC_FAR *__RPC_FAR *varFields);


void __RPC_STUB IFolderTree_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_Name_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IFolderTree_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_put_Name_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ BSTR varName);


void __RPC_STUB IFolderTree_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_StoreDBs_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varStoreDBs);


void __RPC_STUB IFolderTree_get_StoreDBs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_TreeType_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ CDOEXMFolderTreeType __RPC_FAR *varTreeType);


void __RPC_STUB IFolderTree_get_TreeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [readonly][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_get_RootFolderURL_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *varRootFolderURL);


void __RPC_STUB IFolderTree_get_RootFolderURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFolderTree_GetInterface_Proxy( 
    IFolderTree __RPC_FAR * This,
    /* [in] */ BSTR Interface,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUnknown);


void __RPC_STUB IFolderTree_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderTree_INTERFACE_DEFINED__ */


#ifndef __IDataSource2_INTERFACE_DEFINED__
#define __IDataSource2_INTERFACE_DEFINED__

/* interface IDataSource2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataSource2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25150F48-5734-11d2-A593-00C04F990D8A")
    IDataSource2 : public IDataSource
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveToContainer( 
            /* [in] */ BSTR ContainerURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataSource2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataSource2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataSource2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataSource2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceClass )( 
            IDataSource2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSourceClass);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            IDataSource2 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *varSource);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDataSource2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDirty);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsDirty )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL varIsDirty);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceURL )( 
            IDataSource2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *varSourceURL);
        
        /* [readonly][helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            IDataSource2 __RPC_FAR * This,
            /* [retval][out] */ _Connection __RPC_FAR *__RPC_FAR *varActiveConnection);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToObject )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenObject )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *Source,
            /* [in] */ BSTR InterfaceName);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveTo )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ BSTR SourceURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [defaultvalue][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IDataSource2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToContainer )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ BSTR ContainerURL,
            /* [defaultvalue][in] */ IDispatch __RPC_FAR *ActiveConnection,
            /* [optional][in] */ ConnectModeEnum Mode,
            /* [optional][in] */ RecordCreateOptionsEnum CreateOptions,
            /* [optional][in] */ RecordOpenOptionsEnum Options,
            /* [optional][in] */ BSTR UserName,
            /* [optional][in] */ BSTR Password);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IDataSource2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveToContainer )( 
            IDataSource2 __RPC_FAR * This,
            /* [in] */ BSTR ContainerURL);
        
        END_INTERFACE
    } IDataSource2Vtbl;

    interface IDataSource2
    {
        CONST_VTBL struct IDataSource2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataSource2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataSource2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataSource2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataSource2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataSource2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataSource2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataSource2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataSource2_get_SourceClass(This,varSourceClass)	\
    (This)->lpVtbl -> get_SourceClass(This,varSourceClass)

#define IDataSource2_get_Source(This,varSource)	\
    (This)->lpVtbl -> get_Source(This,varSource)

#define IDataSource2_get_IsDirty(This,pIsDirty)	\
    (This)->lpVtbl -> get_IsDirty(This,pIsDirty)

#define IDataSource2_put_IsDirty(This,varIsDirty)	\
    (This)->lpVtbl -> put_IsDirty(This,varIsDirty)

#define IDataSource2_get_SourceURL(This,varSourceURL)	\
    (This)->lpVtbl -> get_SourceURL(This,varSourceURL)

#define IDataSource2_get_ActiveConnection(This,varActiveConnection)	\
    (This)->lpVtbl -> get_ActiveConnection(This,varActiveConnection)

#define IDataSource2_SaveToObject(This,Source,InterfaceName)	\
    (This)->lpVtbl -> SaveToObject(This,Source,InterfaceName)

#define IDataSource2_OpenObject(This,Source,InterfaceName)	\
    (This)->lpVtbl -> OpenObject(This,Source,InterfaceName)

#define IDataSource2_SaveTo(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> SaveTo(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)

#define IDataSource2_Open(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> Open(This,SourceURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)

#define IDataSource2_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IDataSource2_SaveToContainer(This,ContainerURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)	\
    (This)->lpVtbl -> SaveToContainer(This,ContainerURL,ActiveConnection,Mode,CreateOptions,Options,UserName,Password)


#define IDataSource2_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IDataSource2_MoveToContainer(This,ContainerURL)	\
    (This)->lpVtbl -> MoveToContainer(This,ContainerURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource2_Delete_Proxy( 
    IDataSource2 __RPC_FAR * This);


void __RPC_STUB IDataSource2_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataSource2_MoveToContainer_Proxy( 
    IDataSource2 __RPC_FAR * This,
    /* [in] */ BSTR ContainerURL);


void __RPC_STUB IDataSource2_MoveToContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataSource2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\effects.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for effectspri.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __effectspri_h__
#define __effectspri_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPEffects_FWD_DEFINED__
#define __IWMPEffects_FWD_DEFINED__
typedef interface IWMPEffects IWMPEffects;
#endif 	/* __IWMPEffects_FWD_DEFINED__ */


#ifndef __IWMPEffects2_FWD_DEFINED__
#define __IWMPEffects2_FWD_DEFINED__
typedef interface IWMPEffects2 IWMPEffects2;
#endif 	/* __IWMPEffects2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmp.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_effectspri_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================
#define	EFFECT_CANGOFULLSCREEN	( 0x1 )

#define	EFFECT_HASPROPERTYPAGE	( 0x2 )

#define	EFFECT_VARIABLEFREQSTEP	( 0x4 )

#define	EFFECT_WINDOWEDONLY	( 0x8 )

#define	EFFECT2_FULLSCREENEXCLUSIVE	( 0x10 )

#define	SA_BUFFER_SIZE	( 1024 )


enum PlayerState
    {	stop_state	= 0,
	pause_state	= 1,
	play_state	= 2
    } ;

//**********************************************************************
// Define the minimum and maximum frequency ranges returned in our
// TimedLevel frequency array (i.e. first index in TimedLevel.frequency
// is at 20Hz and last is at 22050Hz).
//**********************************************************************
static const float kfltTimedLevelMaximumFrequency = 22050.0F;
static const float kfltTimedLevelMinimumFrequency = 20.0F;

/*
 * FREQUENCY_INDEX() returns the index into TimedLevel.frequency[] where 
 * the specified frequency is located in the power spectrum
 */
#define FREQUENCY_INDEX(FREQ)\
  (int)(((FREQ) - kfltTimedLevelMinimumFrequency) /\
    (((kfltTimedLevelMaximumFrequency - kfltTimedLevelMinimumFrequency) / SA_BUFFER_SIZE)))

typedef struct tagTimedLevel
    {
    unsigned char frequency[ 2 ][ 1024 ];
    unsigned char waveform[ 2 ][ 1024 ];
    int state;
    hyper timeStamp;
    } 	TimedLevel;



extern RPC_IF_HANDLE __MIDL_itf_effectspri_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_effectspri_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPEffects_INTERFACE_DEFINED__
#define __IWMPEffects_INTERFACE_DEFINED__

/* interface IWMPEffects */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPEffects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D3984C13-C3CB-48e2-8BE5-5168340B4F35")
    IWMPEffects : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ TimedLevel *pLevels,
            /* [in] */ HDC hdc,
            /* [in] */ RECT *prc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MediaInfo( 
            /* [in] */ LONG lChannelCount,
            /* [in] */ LONG lSampleRate,
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pdwCapabilities) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [out] */ BSTR *bstrTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresetTitle( 
            /* [in] */ LONG nPreset,
            /* [out] */ BSTR *bstrPresetTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresetCount( 
            /* [out] */ LONG *pnPresetCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCurrentPreset( 
            /* [in] */ LONG nPreset) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentPreset( 
            /* [out] */ LONG *pnPreset) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayPropertyPage( 
            /* [in] */ HWND hwndOwner) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GoFullscreen( 
            /* [in] */ BOOL fFullScreen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RenderFullScreen( 
            /* [in] */ TimedLevel *pLevels) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPEffectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPEffects * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPEffects * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPEffects * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Render )( 
            IWMPEffects * This,
            /* [in] */ TimedLevel *pLevels,
            /* [in] */ HDC hdc,
            /* [in] */ RECT *prc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MediaInfo )( 
            IWMPEffects * This,
            /* [in] */ LONG lChannelCount,
            /* [in] */ LONG lSampleRate,
            /* [in] */ BSTR bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IWMPEffects * This,
            /* [out] */ DWORD *pdwCapabilities);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            IWMPEffects * This,
            /* [out] */ BSTR *bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetTitle )( 
            IWMPEffects * This,
            /* [in] */ LONG nPreset,
            /* [out] */ BSTR *bstrPresetTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetCount )( 
            IWMPEffects * This,
            /* [out] */ LONG *pnPresetCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCurrentPreset )( 
            IWMPEffects * This,
            /* [in] */ LONG nPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentPreset )( 
            IWMPEffects * This,
            /* [out] */ LONG *pnPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisplayPropertyPage )( 
            IWMPEffects * This,
            /* [in] */ HWND hwndOwner);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GoFullscreen )( 
            IWMPEffects * This,
            /* [in] */ BOOL fFullScreen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RenderFullScreen )( 
            IWMPEffects * This,
            /* [in] */ TimedLevel *pLevels);
        
        END_INTERFACE
    } IWMPEffectsVtbl;

    interface IWMPEffects
    {
        CONST_VTBL struct IWMPEffectsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPEffects_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPEffects_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPEffects_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPEffects_Render(This,pLevels,hdc,prc)	\
    ( (This)->lpVtbl -> Render(This,pLevels,hdc,prc) ) 

#define IWMPEffects_MediaInfo(This,lChannelCount,lSampleRate,bstrTitle)	\
    ( (This)->lpVtbl -> MediaInfo(This,lChannelCount,lSampleRate,bstrTitle) ) 

#define IWMPEffects_GetCapabilities(This,pdwCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities) ) 

#define IWMPEffects_GetTitle(This,bstrTitle)	\
    ( (This)->lpVtbl -> GetTitle(This,bstrTitle) ) 

#define IWMPEffects_GetPresetTitle(This,nPreset,bstrPresetTitle)	\
    ( (This)->lpVtbl -> GetPresetTitle(This,nPreset,bstrPresetTitle) ) 

#define IWMPEffects_GetPresetCount(This,pnPresetCount)	\
    ( (This)->lpVtbl -> GetPresetCount(This,pnPresetCount) ) 

#define IWMPEffects_SetCurrentPreset(This,nPreset)	\
    ( (This)->lpVtbl -> SetCurrentPreset(This,nPreset) ) 

#define IWMPEffects_GetCurrentPreset(This,pnPreset)	\
    ( (This)->lpVtbl -> GetCurrentPreset(This,pnPreset) ) 

#define IWMPEffects_DisplayPropertyPage(This,hwndOwner)	\
    ( (This)->lpVtbl -> DisplayPropertyPage(This,hwndOwner) ) 

#define IWMPEffects_GoFullscreen(This,fFullScreen)	\
    ( (This)->lpVtbl -> GoFullscreen(This,fFullScreen) ) 

#define IWMPEffects_RenderFullScreen(This,pLevels)	\
    ( (This)->lpVtbl -> RenderFullScreen(This,pLevels) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPEffects_INTERFACE_DEFINED__ */


#ifndef __IWMPEffects2_INTERFACE_DEFINED__
#define __IWMPEffects2_INTERFACE_DEFINED__

/* interface IWMPEffects2 */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPEffects2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("695386EC-AA3C-4618-A5E1-DD9A8B987632")
    IWMPEffects2 : public IWMPEffects
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCore( 
            /* [in] */ IWMPCore *pPlayer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyNewMedia( 
            /* [in] */ IWMPMedia *pMedia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnWindowMessage( 
            /* [in] */ UINT msg,
            /* [in] */ WPARAM WParam,
            /* [in] */ LPARAM LParam,
            /* [in] */ LRESULT *plResultParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderWindowed( 
            /* [in] */ TimedLevel *pData,
            /* [in] */ BOOL fRequiredRender) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPEffects2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPEffects2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPEffects2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPEffects2 * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Render )( 
            IWMPEffects2 * This,
            /* [in] */ TimedLevel *pLevels,
            /* [in] */ HDC hdc,
            /* [in] */ RECT *prc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MediaInfo )( 
            IWMPEffects2 * This,
            /* [in] */ LONG lChannelCount,
            /* [in] */ LONG lSampleRate,
            /* [in] */ BSTR bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IWMPEffects2 * This,
            /* [out] */ DWORD *pdwCapabilities);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            IWMPEffects2 * This,
            /* [out] */ BSTR *bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetTitle )( 
            IWMPEffects2 * This,
            /* [in] */ LONG nPreset,
            /* [out] */ BSTR *bstrPresetTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetCount )( 
            IWMPEffects2 * This,
            /* [out] */ LONG *pnPresetCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCurrentPreset )( 
            IWMPEffects2 * This,
            /* [in] */ LONG nPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentPreset )( 
            IWMPEffects2 * This,
            /* [out] */ LONG *pnPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisplayPropertyPage )( 
            IWMPEffects2 * This,
            /* [in] */ HWND hwndOwner);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GoFullscreen )( 
            IWMPEffects2 * This,
            /* [in] */ BOOL fFullScreen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RenderFullScreen )( 
            IWMPEffects2 * This,
            /* [in] */ TimedLevel *pLevels);
        
        HRESULT ( STDMETHODCALLTYPE *SetCore )( 
            IWMPEffects2 * This,
            /* [in] */ IWMPCore *pPlayer);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IWMPEffects2 * This,
            /* [in] */ HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IWMPEffects2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyNewMedia )( 
            IWMPEffects2 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        HRESULT ( STDMETHODCALLTYPE *OnWindowMessage )( 
            IWMPEffects2 * This,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM WParam,
            /* [in] */ LPARAM LParam,
            /* [in] */ LRESULT *plResultParam);
        
        HRESULT ( STDMETHODCALLTYPE *RenderWindowed )( 
            IWMPEffects2 * This,
            /* [in] */ TimedLevel *pData,
            /* [in] */ BOOL fRequiredRender);
        
        END_INTERFACE
    } IWMPEffects2Vtbl;

    interface IWMPEffects2
    {
        CONST_VTBL struct IWMPEffects2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPEffects2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPEffects2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPEffects2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPEffects2_Render(This,pLevels,hdc,prc)	\
    ( (This)->lpVtbl -> Render(This,pLevels,hdc,prc) ) 

#define IWMPEffects2_MediaInfo(This,lChannelCount,lSampleRate,bstrTitle)	\
    ( (This)->lpVtbl -> MediaInfo(This,lChannelCount,lSampleRate,bstrTitle) ) 

#define IWMPEffects2_GetCapabilities(This,pdwCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities) ) 

#define IWMPEffects2_GetTitle(This,bstrTitle)	\
    ( (This)->lpVtbl -> GetTitle(This,bstrTitle) ) 

#define IWMPEffects2_GetPresetTitle(This,nPreset,bstrPresetTitle)	\
    ( (This)->lpVtbl -> GetPresetTitle(This,nPreset,bstrPresetTitle) ) 

#define IWMPEffects2_GetPresetCount(This,pnPresetCount)	\
    ( (This)->lpVtbl -> GetPresetCount(This,pnPresetCount) ) 

#define IWMPEffects2_SetCurrentPreset(This,nPreset)	\
    ( (This)->lpVtbl -> SetCurrentPreset(This,nPreset) ) 

#define IWMPEffects2_GetCurrentPreset(This,pnPreset)	\
    ( (This)->lpVtbl -> GetCurrentPreset(This,pnPreset) ) 

#define IWMPEffects2_DisplayPropertyPage(This,hwndOwner)	\
    ( (This)->lpVtbl -> DisplayPropertyPage(This,hwndOwner) ) 

#define IWMPEffects2_GoFullscreen(This,fFullScreen)	\
    ( (This)->lpVtbl -> GoFullscreen(This,fFullScreen) ) 

#define IWMPEffects2_RenderFullScreen(This,pLevels)	\
    ( (This)->lpVtbl -> RenderFullScreen(This,pLevels) ) 


#define IWMPEffects2_SetCore(This,pPlayer)	\
    ( (This)->lpVtbl -> SetCore(This,pPlayer) ) 

#define IWMPEffects2_Create(This,hwndParent)	\
    ( (This)->lpVtbl -> Create(This,hwndParent) ) 

#define IWMPEffects2_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IWMPEffects2_NotifyNewMedia(This,pMedia)	\
    ( (This)->lpVtbl -> NotifyNewMedia(This,pMedia) ) 

#define IWMPEffects2_OnWindowMessage(This,msg,WParam,LParam,plResultParam)	\
    ( (This)->lpVtbl -> OnWindowMessage(This,msg,WParam,LParam,plResultParam) ) 

#define IWMPEffects2_RenderWindowed(This,pData,fRequiredRender)	\
    ( (This)->lpVtbl -> RenderWindowed(This,pData,fRequiredRender) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPEffects2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ErrorRep.h ===
/******************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:
    errorrep.h

Abstract:
    contains functions used to report errors to Microsoft

******************************************************************************/	

#ifndef __ERRORREP_H__
#define __ERRORREP_H__

typedef enum tagEFaultRepRetVal
{
    frrvOk = 0,
    frrvOkManifest,
    frrvOkQueued,
    frrvErr,
    frrvErrNoDW,
    frrvErrTimeout,
    frrvLaunchDebugger,
    frrvOkHeadless,
    frrvErrAnotherInstance
} EFaultRepRetVal;

EFaultRepRetVal APIENTRY ReportFault(__in LPEXCEPTION_POINTERS pep, __in DWORD dwOpt);

BOOL            APIENTRY AddERExcludedApplicationA(__in LPCSTR szApplication);
BOOL            APIENTRY AddERExcludedApplicationW(__in LPCWSTR wszApplication);


typedef EFaultRepRetVal (APIENTRY *pfn_REPORTFAULT)(__in LPEXCEPTION_POINTERS, __in DWORD);
typedef EFaultRepRetVal (APIENTRY *pfn_ADDEREXCLUDEDAPPLICATIONA)(__in LPCSTR);
typedef EFaultRepRetVal (APIENTRY *pfn_ADDEREXCLUDEDAPPLICATIONW)(__in LPCWSTR);

#ifdef UNICODE
#define AddERExcludedApplication AddERExcludedApplicationW
#define pfn_ADDEREXCLUDEDAPPLICATION pfn_ADDEREXCLUDEDAPPLICATIONW
#else
#define AddERExcludedApplication AddERExcludedApplicationA
#define pfn_ADDEREXCLUDEDAPPLICATION pfn_ADDEREXCLUDEDAPPLICATIONA
#endif

// 
//+++++++++++++++++++++ Hang reporting api ++++++++++++++++++++++++++++++++
//
__control_entrypoint(DllExport)
HRESULT 
WINAPI
WerReportHang(
    __in HWND hwndHungApp,
    __in_opt PCWSTR pwzHungApplicationName
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\errors.h ===
//------------------------------------------------------------------------------
// File: Errors.h
//
// Desc:  ActiveMovie error defines.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __ERRORS__
#define __ERRORS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_
#define AMOVIEAPI   DECLSPEC_IMPORT
#else
#define AMOVIEAPI
#endif

// codes 0-01ff are reserved for OLE
#define VFW_FIRST_CODE   0x200
#define MAX_ERROR_TEXT_LEN 160

#include <VFWMSGS.H>                    // includes all message definitions

typedef BOOL (WINAPI* AMGETERRORTEXTPROCA)(HRESULT, char *, DWORD);
typedef BOOL (WINAPI* AMGETERRORTEXTPROCW)(HRESULT, WCHAR *, DWORD);

AMOVIEAPI DWORD WINAPI AMGetErrorTextA( HRESULT hr , __out_ecount(MaxLen) LPSTR pbuffer , DWORD MaxLen);
AMOVIEAPI DWORD WINAPI AMGetErrorTextW( HRESULT hr , __out_ecount(MaxLen) LPWSTR pbuffer , DWORD MaxLen);


#ifdef UNICODE
#define AMGetErrorText  AMGetErrorTextW
typedef AMGETERRORTEXTPROCW AMGETERRORTEXTPROC;
#else
#define AMGetErrorText  AMGetErrorTextA
typedef AMGETERRORTEXTPROCA AMGETERRORTEXTPROC;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __ERRORS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\eaptypes.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPTYPES_H
#define EAPTYPES_H
#pragma once

#include <guiddef.h>  // Used by EAP_ERROR structure.


// Properties that EAP Methods support
#define eapPropCipherSuiteNegotiation      0x00000001
#define eapPropMutualAuth                  0x00000002
#define eapPropIntegrity                   0x00000004
#define eapPropReplayProtection            0x00000008
#define eapPropConfidentiality             0x00000010
#define eapPropKeyDerivation               0x00000020
#define eapPropKeyStrength64               0x00000040
#define eapPropKeyStrength128              0x00000080
#define eapPropKeyStrength256              0x00000100
#define eapPropKeyStrength512              0x00000200
#define eapPropKeyStrength1024             0x00000400
#define eapPropDictionaryAttackResistance  0x00000800
#define eapPropFastReconnect               0x00001000
#define eapPropCryptoBinding               0x00002000
#define eapPropSessionIndependence         0x00004000
#define eapPropFragmentation               0x00008000
#define eapPropChannelBinding              0x00010000
#define eapPropNap                         0x00020000
#define eapPropStandalone                  0x00040000
#define eapPropMppeEncryption              0x00080000
#define eapPropTunnelMethod                0x00100000
#define eapPropSupportsConfig              0x00200000
#define eapPropCertifiedMethod             0x00400000
#define eapPropHiddenMethod                0x00800000
#define eapPropReserved                    0x80000000

// Registry NameValue that stores Properties supported by EAP Method
#define EAP_VALUENAME_PROPERTIES L"Properties"

typedef DWORD EAP_SESSIONID;


typedef struct _EAP_TYPE
{
   BYTE type;
   DWORD dwVendorId;
   DWORD dwVendorType;
} EAP_TYPE;


// definition of EAP_METHOD_TYPE used for describing an EAP method
typedef struct _EAP_METHOD_TYPE
{
   EAP_TYPE eapType;
   DWORD dwAuthorId;
} EAP_METHOD_TYPE;


// Information pertaining to each EAP method is populated in this structure format
typedef struct _EAP_METHOD_INFO
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO* pInnerMethodInfo;
} EAP_METHOD_INFO;


// EAPHost populates this array with the information for all the eap-methods installed
// on machine and passes it to a supplicant
struct _EAP_METHOD_INFO_ARRAY_EX;


typedef struct _EAP_METHOD_INFO_EX
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO_ARRAY_EX* pInnerMethodInfoArray;
} EAP_METHOD_INFO_EX;


typedef struct _EAP_METHOD_INFO_ARRAY
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO* pEapMethods;
} EAP_METHOD_INFO_ARRAY;

// EAPHost populates this error structs with appropriate information and passes it to
// supplicant, which can use this information for error reporting and troubleshooting
typedef struct _EAP_METHOD_INFO_ARRAY_EX
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO_EX* pEapMethods;
} EAP_METHOD_INFO_ARRAY_EX;

typedef struct _EAP_ERROR
{
   DWORD dwWinError;
   EAP_METHOD_TYPE type;
   DWORD dwReasonCode;

   GUID   rootCauseGuid;
   GUID   repairGuid;
   GUID   helpLinkGuid;

   LPWSTR pRootCauseString;
   LPWSTR pRepairString;
} EAP_ERROR;


EXTERN_C const CLSID GUID_EapHost_Default;

EXTERN_C const CLSID GUID_EapHost_Cause_MethodDLLNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_EapNegotiationFailed;    //*!*
EXTERN_C const CLSID GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset;
EXTERN_C const CLSID GUID_EapHost_Cause_XmlMalformed;
EXTERN_C const CLSID GUID_EapHost_Cause_MethodDoesNotSupportOperation;
EXTERN_C const CLSID GUID_EapHost_Cause_EapQecInaccessible;      //*!*

EXTERN_C const CLSID GUID_EapHost_Cause_Generic_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Cause_IdentityUnknown;

EXTERN_C const CLSID GUID_EapHost_Cause_CertStoreInaccessible;

EXTERN_C const CLSID GUID_EapHost_Cause_User_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRejected;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRevoked;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Account_OtherProblem;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CredsRejected;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertRevoked;

EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertNotFound;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNameRequired;

EXTERN_C const CLSID GUID_EapHost_Repair_ContactSysadmin;
EXTERN_C const CLSID GUID_EapHost_Repair_Retry_Authentication;

EXTERN_C const CLSID GUID_EapHost_Repair_User_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Repair_User_GetNewCert;
EXTERN_C const CLSID GUID_EapHost_Repair_User_SelectValidCert;

EXTERN_C const CLSID GUID_EapHost_Repair_Server_ClientSelectServerCert;

EXTERN_C const CLSID GUID_EapHost_Help_ObtainingCerts;
EXTERN_C const CLSID GUID_EapHost_Help_Troubleshooting;

//--------------------------


typedef
#ifdef __midl
   [v1_enum]
#endif

// Attributes that EAP Methods support
enum _EAP_ATTRIBUTE_TYPE
{
    eatMinimum = 0,                // Undefined
    eatUserName,                   // Value field is a Pointer
    eatUserPassword,               // Value field is a Pointer
    eatMD5CHAPPassword,            // Value field is a Pointer
    eatNASIPAddress,               // Value field is a 32 bit integral value
    eatNASPort,                    // Value field is a 32 bit integral value
    eatServiceType,                // Value field is a 32 bit integral value
    eatFramedProtocol,             // Value field is a 32 bit integral value
    eatFramedIPAddress,            // Value field is a 32 bit integral value
    eatFramedIPNetmask,            // Value field is a 32 bit integral value
    eatFramedRouting = 10,         // Value field is a 32 bit integral value
    eatFilterId,                   // Value field is a Pointer
    eatFramedMTU,                  // Value field is a 32 bit integral value
    eatFramedCompression,          // Value field is a 32 bit integral value
    eatLoginIPHost,                // Value field is a 32 bit integral value
    eatLoginService,               // Value field is a 32 bit integral value
    eatLoginTCPPort,               // Value field is a 32 bit integral value
    eatUnassigned17,               // Undefined
    eatReplyMessage,               // Value field is a Pointer
    eatCallbackNumber,             // Value field is a Pointer
    eatCallbackId =20,             // Value field is a Pointer
    eatUnassigned21,               // Undefined
    eatFramedRoute,                // Value field is a Pointer
    eatFramedIPXNetwork,           // Value field is a 32 bit integral value
    eatState,                      // Value field is a Pointer
    eatClass,                      // Value field is a Pointer
    eatVendorSpecific,             // Value field is a Pointer
    eatSessionTimeout,             // Value field is a 32 bit integral value
    eatIdleTimeout,                // Value field is a 32 bit integral value
    eatTerminationAction,          // Value field is a 32 bit integral value
    eatCalledStationId = 30,       // Value field is a Pointer
    eatCallingStationId,           // Value field is a Pointer
    eatNASIdentifier,              // Value field is a Pointer
    eatProxyState,                 // Value field is a Pointer
    eatLoginLATService,            // Value field is a Pointer
    eatLoginLATNode,               // Value field is a Pointer
    eatLoginLATGroup,              // Value field is a Pointer
    eatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    eatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    eatFramedAppleTalkZone,        // Value field is a Pointer
    eatAcctStatusType = 40,        // Value field is a 32 bit integral value
    eatAcctDelayTime,              // Value field is a 32 bit integral value
    eatAcctInputOctets,            // Value field is a 32 bit integral value
    eatAcctOutputOctets,           // Value field is a 32 bit integral value
    eatAcctSessionId,              // Value field is a Pointer
    eatAcctAuthentic,              // Value field is a 32 bit integral value
    eatAcctSessionTime,            // Value field is a 32 bit integral value
    eatAcctInputPackets,           // Value field is a 32 bit integral value
    eatAcctOutputPackets,          // Value field is a 32 bit integral value
    eatAcctTerminateCause,         // Value field is a 32 bit integral value
    eatAcctMultiSessionId = 50,    // Value field is a Pointer
    eatAcctLinkCount,              // Value field is a 32 bit integral value
    eatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    eatMD5CHAPChallenge = 60,      // Value field is a Pointer
    eatNASPortType,                // Value field is a 32 bit integral value
    eatPortLimit,                  // Value field is a 32 bit integral value
    eatLoginLATPort,               // Value field is a Pointer
    eatTunnelType,                 // Value field is a 32 bit integral value
    eatTunnelMediumType,           // Value field is a 32 bit integral value
    eatTunnelClientEndpoint,       // Value field is a Pointer
    eatTunnelServerEndpoint,       // Value field is a Pointer
    eatARAPPassword = 70,          // Value field is a Pointer
    eatARAPFeatures,               // Value field is a Pointer
    eatARAPZoneAccess,             // Value field is a 32 bit integral value
    eatARAPSecurity,               // Value field is a 32 bit integral value
    eatARAPSecurityData,           // Value field is a Pointer
    eatPasswordRetry,              // Value field is a 32 bit integral value
    eatPrompt,                     // Value field is a 32 bit integral value
    eatConnectInfo,                // Value field is a Pointer
    eatConfigurationToken,         // Value field is a Pointer
    eatEAPMessage,                 // Value field is a Pointer
    eatSignature = 80,             // Value field is a Pointer
    eatARAPChallengeResponse = 84, // Value field is a Pointer
    eatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    eatNASIPv6Address = 95,  // Value field is a Pointer
    eatFramedInterfaceId, // Value field is a Pointer
    eatFramedIPv6Prefix, // Value field is a Pointer
    eatLoginIPv6Host, // Value field is a Pointer
    eatFramedIPv6Route, // Value field is a Pointer
    eatFramedIPv6Pool, // Value field is a Pointer
    eatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    eatCertificateOID,             // Value field is a Pointer
    eatEAPConfiguration,           // Value field is a Pointer
    eatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    eatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    eatEAPTLV = 8102,              // Value field is a Pointer
    eatCredentialsChanged,        // Value field is a Integer with boolean
                                   // semantics
    eatInnerEapMethodType,         // Value field is a pointer
                                   // EapMethodType of the inner method in
                                   // case of Tunnelled method
    eatClearTextPassword = 8107,   // Value field is a pointer
                                   // Clear text password that can be used
                                   // by certain password based eap methods
                                   // to authenticate a user.
    eatQuarantineSoH     = 8150, // Value field is a pointer
    eatPeerId                 = 9000,  // Value field is a pointer
    eatServerId,                          // Value field is a pointer
    eatMethodId,                          // Value field is a pointer
    eatEMSK,                               // Value field is a pointer
    eatSessionId,                               // Value field is a pointer
    eatReserved = 0xFFFFFFFF       // Undefined
} EAP_ATTRIBUTE_TYPE, EapAttributeType;


// format for carrying EAP attribute TLV (type, length and value)
typedef struct _EAP_ATTRIBUTE
{
        EAP_ATTRIBUTE_TYPE eaType;
        DWORD dwLength;
#ifdef __midl
        [size_is(dwLength)] BYTE* pValue;
#else
    BYTE *pValue;
#endif
} EAP_ATTRIBUTE, EapAttribute;


// List of EAP-attributes
typedef struct _EAP_ATTRIBUTES
{
        DWORD dwNumberOfAttributes;
#ifdef __midl
        [size_is(dwNumberOfAttributes)] EAP_ATTRIBUTE* pAttribs;
#else
    EAP_ATTRIBUTE *pAttribs;
#endif
} EAP_ATTRIBUTES, EapAttributes;


// No UI should be displayed
#define EAP_FLAG_Reserved1              0x00000001
#define EAP_FLAG_NON_INTERACTIVE        0x00000002

// The user data was obtained from Winlogon
#define EAP_FLAG_LOGON                  0x00000004

// Show the Credentails UI before authenticating even if cached creds are present
#define EAP_FLAG_PREVIEW                0x00000008

#define EAP_FLAG_Reserved2              0x00000010

// Authentication is for machine, i.e. not for user. Not setting this flag means
// it is user authentication.
#define EAP_FLAG_MACHINE_AUTH           0x00000020

// Request to provide guest access
#define EAP_FLAG_GUEST_ACCESS           0x00000040

#define EAP_FLAG_Reserved3              0x00000080

#define EAP_FLAG_Reserved4              0x00000100

// Indicates this is the first call after m/c resumed from hibernation.
#define EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200

#define EAP_FLAG_Reserved5              0x00000400

#define EAP_FLAG_Reserved6              0x00000800

// Should have this or make it reserved?
#define EAP_FLAG_FULL_AUTH              0x00001000

///   New EapHost Flags

// Prefer Credentails passed in BeginSession instead of other form of
// credentials, even if config says use certain way of cred retrieval. If this fails, fallback to
// Method specific credentail retrieval
#define EAP_FLAG_PREFER_ALT_CREDENTIALS     0x00002000

#define EAP_FLAG_Reserved7                  0x00004000

// To inform the cause of reauth is a NAP callback
#define EAP_PEER_FLAG_HEALTH_STATE_CHANGE   0x00008000

// Continue authentication with information available. If can not proceed, fail
// the authentication
#define EAP_FLAG_SUPRESS_UI                 0x00010000

// Pre logon scenario like PLAP
#define EAP_FLAG_PRE_LOGON                  0x00020000

// User Authentication. For legacy Methods not setting EAP_FLAG_MACHINE_AUTH
// also means user authentication.
#define EAP_FLAG_USER_AUTH                  0x00040000

// Config can be viewed but not updated
#define EAP_FLAG_CONFG_READONLY             0x00080000

#define EAP_FLAG_Reserved8                  0x00100000

// the various states of the input fields
#define EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT                0X00000000
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE        0X00000001

// This specifies that supplicant should cache this field data
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002


// default property value for entries field to be shown in UI
#define EAP_UI_INPUT_FIELD_PROPS_DEFAULT          EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT
// To qualify certain entry data on UI is non-displayable (e.g. password)
#define EAP_UI_INPUT_FIELD_PROPS_NON_DISPLAYABLE  EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE
// This specifies that supplicant should cache this field data
#define EAP_UI_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002
// This specifies that following field is read only (non-editable)
#define EAP_UI_INPUT_FIELD_PROPS_READ_ONLY              0X00000004


// the types of fields that eap can request to show
typedef enum _EAP_CONFIG_INPUT_FIELD_TYPE {
    EapConfigInputUsername,
    EapConfigInputPassword,
    EapConfigInputNetworkUsername,
    EapConfigInputNetworkPassword,
    EapConfigInputPin,
    EapConfigInputPSK,
    EapConfigInputEdit
} EAP_CONFIG_INPUT_FIELD_TYPE, *PEAP_CONFIG_INPUT_FIELD_TYPE;

#define EAP_CREDENTIAL_VERSION                     1
#define EAP_INTERACTIVE_UI_DATA_VERSION            1
#define EAPHOST_PEER_API_VERSION                   1
#define EAPHOST_METHOD_API_VERSION                 1
#define MAX_EAP_CONFIG_INPUT_FIELD_LENGTH          256
#define MAX_EAP_CONFIG_INPUT_FIELD_VALUE_LENGTH    1024


// structure for carrying EAP input field
typedef struct _EAP_CONFIG_INPUT_FIELD_DATA {
    DWORD dwSize;
    EAP_CONFIG_INPUT_FIELD_TYPE Type;
    DWORD dwFlagProps;
    LPWSTR pwszLabel;
    LPWSTR pwszData;
    DWORD dwMinDataLength;
    DWORD dwMaxDataLength;
} EAP_CONFIG_INPUT_FIELD_DATA, *PEAP_CONFIG_INPUT_FIELD_DATA;


// List of EAP input fields
typedef struct _EAP_CONFIG_INPUT_FIELD_ARRAY {
    DWORD dwVersion; // used for versioning
    DWORD dwNumberOfFields;
#ifdef __midl
    [size_is(dwNumberOfFields)] EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#else
    EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#endif
} EAP_CONFIG_INPUT_FIELD_ARRAY, *PEAP_CONFIG_INPUT_FIELD_ARRAY;


// provides type of data, EAP_INTERACTIVE_UI_DATA can carry
typedef enum _EAP_INTERACTIVE_UI_DATA_TYPE {
    EapCredReq,
    EapCredResp,
    EapCredExpiryReq,
    EapCredExpiryResp,
} EAP_INTERACTIVE_UI_DATA_TYPE;


// following determine type of data blob that can be pointed by
// pbUiData member of EAP_INTERACTIVE_UI_DATA
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_REQ;
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_RESP;

// pNewCreds can be NULL in case of EAP_CRED_EXPIRY_REQ
// in case of REQ, pNewCreds can be empty (will not be looked at)
typedef struct _EAP_CRED_EXPIRY_REQ {
    EAP_CONFIG_INPUT_FIELD_ARRAY curCreds;
    EAP_CONFIG_INPUT_FIELD_ARRAY newCreds;
} EAP_CRED_EXPIRY_REQ, EAP_CRED_EXPIRY_RESP;

#ifdef __midl
    typedef [switch_type(EAP_INTERACTIVE_UI_DATA_TYPE)]
    union {
       [case(EapCredReq, EapCredResp)]      EAP_CRED_REQ*  credData;
       [case(EapCredExpiryReq,EapCredExpiryResp)] EAP_CRED_EXPIRY_REQ* credExpiryData;
       [default]      ;
    } EAP_UI_DATA_FORMAT;
#else
    typedef union {
       EAP_CRED_REQ*  credData;
       EAP_CRED_EXPIRY_REQ* credExpiryData;
    } EAP_UI_DATA_FORMAT;
#endif


// Data carried from EAP-method to supplicant for interactive UI to raised
typedef struct _EAP_INTERACTIVE_UI_DATA {
    //specifies version of data structure. It must be 0.
    DWORD dwVersion;
    //specifies size of the entire structure.
    DWORD dwSize;
    // this determines what kind of interactive data is passed.
    EAP_INTERACTIVE_UI_DATA_TYPE dwDataType;
    // specifies size of the data pointed by pbUiByte.
    DWORD cbUiData;
    // pointer to a data blob of a type determined by dwDataType above.
    // This can be of type EAP_CRED_REQ/EAP_CRED_RESP or
    // EAP_CRED_EXPIRY_REQ/EAP_CRED_EXPIRY_RESP depending on uiDataType above
#ifdef __midl
    [switch_is (dwDataType)] EAP_UI_DATA_FORMAT pbUiData;
#else
    EAP_UI_DATA_FORMAT pbUiData;
#endif
} EAP_INTERACTIVE_UI_DATA ;


#endif //EAPTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\encdec.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for encdec.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __encdec_h__
#define __encdec_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IETFilterConfig_FWD_DEFINED__
#define __IETFilterConfig_FWD_DEFINED__
typedef interface IETFilterConfig IETFilterConfig;
#endif 	/* __IETFilterConfig_FWD_DEFINED__ */


#ifndef __IDTFilterConfig_FWD_DEFINED__
#define __IDTFilterConfig_FWD_DEFINED__
typedef interface IDTFilterConfig IDTFilterConfig;
#endif 	/* __IDTFilterConfig_FWD_DEFINED__ */


#ifndef __IXDSCodecConfig_FWD_DEFINED__
#define __IXDSCodecConfig_FWD_DEFINED__
typedef interface IXDSCodecConfig IXDSCodecConfig;
#endif 	/* __IXDSCodecConfig_FWD_DEFINED__ */


#ifndef __IDTFilterBlockedOverlay_FWD_DEFINED__
#define __IDTFilterBlockedOverlay_FWD_DEFINED__
typedef interface IDTFilterBlockedOverlay IDTFilterBlockedOverlay;
#endif 	/* __IDTFilterBlockedOverlay_FWD_DEFINED__ */


#ifndef __IETFilter_FWD_DEFINED__
#define __IETFilter_FWD_DEFINED__
typedef interface IETFilter IETFilter;
#endif 	/* __IETFilter_FWD_DEFINED__ */


#ifndef __IETFilterEvents_FWD_DEFINED__
#define __IETFilterEvents_FWD_DEFINED__
typedef interface IETFilterEvents IETFilterEvents;
#endif 	/* __IETFilterEvents_FWD_DEFINED__ */


#ifndef __ETFilter_FWD_DEFINED__
#define __ETFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class ETFilter ETFilter;
#else
typedef struct ETFilter ETFilter;
#endif /* __cplusplus */

#endif 	/* __ETFilter_FWD_DEFINED__ */


#ifndef __IDTFilter_FWD_DEFINED__
#define __IDTFilter_FWD_DEFINED__
typedef interface IDTFilter IDTFilter;
#endif 	/* __IDTFilter_FWD_DEFINED__ */


#ifndef __IDTFilter2_FWD_DEFINED__
#define __IDTFilter2_FWD_DEFINED__
typedef interface IDTFilter2 IDTFilter2;
#endif 	/* __IDTFilter2_FWD_DEFINED__ */


#ifndef __IDTFilter3_FWD_DEFINED__
#define __IDTFilter3_FWD_DEFINED__
typedef interface IDTFilter3 IDTFilter3;
#endif 	/* __IDTFilter3_FWD_DEFINED__ */


#ifndef __IDTFilterEvents_FWD_DEFINED__
#define __IDTFilterEvents_FWD_DEFINED__
typedef interface IDTFilterEvents IDTFilterEvents;
#endif 	/* __IDTFilterEvents_FWD_DEFINED__ */


#ifndef __DTFilter_FWD_DEFINED__
#define __DTFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DTFilter DTFilter;
#else
typedef struct DTFilter DTFilter;
#endif /* __cplusplus */

#endif 	/* __DTFilter_FWD_DEFINED__ */


#ifndef __IXDSCodec_FWD_DEFINED__
#define __IXDSCodec_FWD_DEFINED__
typedef interface IXDSCodec IXDSCodec;
#endif 	/* __IXDSCodec_FWD_DEFINED__ */


#ifndef __IXDSCodecEvents_FWD_DEFINED__
#define __IXDSCodecEvents_FWD_DEFINED__
typedef interface IXDSCodecEvents IXDSCodecEvents;
#endif 	/* __IXDSCodecEvents_FWD_DEFINED__ */


#ifndef __XDSCodec_FWD_DEFINED__
#define __XDSCodec_FWD_DEFINED__

#ifdef __cplusplus
typedef class XDSCodec XDSCodec;
#else
typedef struct XDSCodec XDSCodec;
#endif /* __cplusplus */

#endif 	/* __XDSCodec_FWD_DEFINED__ */


#ifndef __CXDSData_FWD_DEFINED__
#define __CXDSData_FWD_DEFINED__

#ifdef __cplusplus
typedef class CXDSData CXDSData;
#else
typedef struct CXDSData CXDSData;
#endif /* __cplusplus */

#endif 	/* __CXDSData_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "TvRatings.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_encdec_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//--------------------------------------------------------------------------
#pragma once
// {C4C4C4C4-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(SID_DRMSecureServiceChannel,
0xC4C4C4C4, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C481-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_ETFilterEncProperties,
0xC4C4C481, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C491-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_ETFilterTagProperties,
0xC4C4C491, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C482-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_DTFilterEncProperties,
0xC4C4C482, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C492-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_DTFilterTagProperties,
0xC4C4C492, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C483-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_XDSCodecProperties,
0xC4C4C483, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C493-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_XDSCodecTagProperties,
0xC4C4C493, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4FC-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(CLSID_CPCAFiltersCategory,
0xC4C4C4FC, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E0-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_XDSCodecNewXDSRating,
0xC4C4C4E0, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4DF-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_XDSCodecDuplicateXDSRating,
0xC4C4C4DF, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E1-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_XDSCodecNewXDSPacket,
0xC4C4C4E1, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E2-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterRatingChange,
0xC4C4C4E2, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E3-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterRatingsBlock,
0xC4C4C4E3, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E4-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterRatingsUnblock,
0xC4C4C4E4, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E5-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterXDSPacket,
0xC4C4C4E5, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E6-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETFilterEncryptionOn,
0xC4C4C4E6, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E7-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETFilterEncryptionOff,
0xC4C4C4E7, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E8-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterCOPPUnblock,
0xC4C4C4E8, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4E9-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_EncDecFilterError,
0xC4C4C4E9, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4EA-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterCOPPBlock ,
0xC4C4C4EA, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4EB-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETFilterCopyOnce,
0xC4C4C4EB, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4F0-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETFilterCopyNever,
0xC4C4C4F0, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4EC-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterDataFormatOK,
0xC4C4C4EC, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4ED-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_DTFilterDataFormatFailure,
0xC4C4C4ED, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4EE-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETDTFilterLicenseOK,
0xC4C4C4EE, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4EF-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(EVENTID_ETDTFilterLicenseFailure,
0xC4C4C4EF, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4D0-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(MEDIASUBTYPE_ETDTFilter_Tagged,
0xC4C4C4D0, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {C4C4C4D1-0049-4E2B-98FB-9537F6CE516D}
DEFINE_GUID(FORMATTYPE_ETDTFilter_Tagged,
0xC4C4C4D1, 0x0049, 0x4E2B, 0x98, 0xFB, 0x95, 0x37, 0xF6, 0xCE, 0x51, 0x6D);
// {4A1B465B-0FB9-4159-AFBD-E33006A0F9F4}
DEFINE_GUID(EVENTID_EncDecFilterEvent, 
0x4a1b465b, 0xfb9, 0x4159, 0xaf, 0xbd, 0xe3, 0x30, 0x6, 0xa0, 0xf9, 0xf4);
// {16155770-AED5-475c-BB98-95A33070DF0C}
DEFINE_GUID(EVENTID_DemultiplexerFilterDiscontinuity, 
0x16155770, 0xaed5, 0x475c, 0xbb, 0x98, 0x95, 0xa3, 0x30, 0x70, 0xdf, 0xc);
typedef LONGLONG REFERENCE_TIME;

typedef LONG PackedTvRating;


enum EncDecEvents
    {	ENCDEC_CPEVENT	= 0,
	ENCDEC_RECORDING_STATUS	= ( ENCDEC_CPEVENT + 1 ) 
    } ;

enum CPRecordingStatus
    {	RECORDING_STOPPED	= 0,
	RECORDING_STARTED	= 1
    } ;

enum CPEventBitShift
    {	CPEVENT_BITSHIFT_RATINGS	= 0,
	CPEVENT_BITSHIFT_COPP	= ( CPEVENT_BITSHIFT_RATINGS + 1 ) ,
	CPEVENT_BITSHIFT_LICENSE	= ( CPEVENT_BITSHIFT_COPP + 1 ) ,
	CPEVENT_BITSHIFT_ROLLBACK	= ( CPEVENT_BITSHIFT_LICENSE + 1 ) ,
	CPEVENT_BITSHIFT_SAC	= ( CPEVENT_BITSHIFT_ROLLBACK + 1 ) ,
	CPEVENT_BITSHIFT_DOWNRES	= ( CPEVENT_BITSHIFT_SAC + 1 ) ,
	CPEVENT_BITSHIFT_STUBLIB	= ( CPEVENT_BITSHIFT_DOWNRES + 1 ) ,
	CPEVENT_BITSHIFT_UNTRUSTEDGRAPH	= ( CPEVENT_BITSHIFT_STUBLIB + 1 ) 
    } ;

enum CPEvents
    {	CPEVENT_NONE	= 0,
	CPEVENT_RATINGS	= ( CPEVENT_NONE + 1 ) ,
	CPEVENT_COPP	= ( CPEVENT_RATINGS + 1 ) ,
	CPEVENT_LICENSE	= ( CPEVENT_COPP + 1 ) ,
	CPEVENT_ROLLBACK	= ( CPEVENT_LICENSE + 1 ) ,
	CPEVENT_SAC	= ( CPEVENT_ROLLBACK + 1 ) ,
	CPEVENT_DOWNRES	= ( CPEVENT_SAC + 1 ) ,
	CPEVENT_STUBLIB	= ( CPEVENT_DOWNRES + 1 ) ,
	CPEVENT_UNTRUSTEDGRAPH	= ( CPEVENT_STUBLIB + 1 ) 
    } ;

enum RevokedComponent
    {	REVOKED_COPP	= 0,
	REVOKED_SAC	= ( REVOKED_COPP + 1 ) ,
	REVOKED_APP_STUB	= ( REVOKED_SAC + 1 ) ,
	REVOKED_SECURE_PIPELINE	= ( REVOKED_APP_STUB + 1 ) ,
	REVOKED_MAX_TYPES	= ( REVOKED_SECURE_PIPELINE + 1 ) 
    } ;
typedef 
enum EnTag_Mode
    {	EnTag_Remove	= 0,
	EnTag_Once	= 0x1,
	EnTag_Repeat	= 0x2
    } 	EnTag_Mode;

typedef /* [public][public][public][public][public][v1_enum][uuid] */  DECLSPEC_UUID("25AEE876-3D61-4486-917E-7C0CB3D9983C") 
enum __MIDL___MIDL_itf_encdec_0000_0000_0001
    {	PROT_COPY_FREE	= 1,
	PROT_COPY_ONCE	= 2,
	PROT_COPY_NEVER	= 3,
	PROT_COPY_NEVER_REALLY	= 4,
	PROT_COPY_NO_MORE	= 5,
	PROT_COPY_FREE_CIT	= 6,
	PROT_COPY_BF	= 7,
	PROT_COPY_CN_RECORDING_STOP	= 8,
	PROT_COPY_FREE_SECURE	= 9,
	PROT_COPY_INVALID	= 50
    } 	ProtType;

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("6F8C2442-2BFB-4180-9EE5-EA1FB47AE35C") 
enum __MIDL___MIDL_itf_encdec_0000_0000_0002
    {	COPP_BadDriver	= 0,
	COPP_NoCardHDCPSupport	= 1,
	COPP_NoMonitorHDCPSupport	= 2,
	COPP_BadCertificate	= 3
    } 	COPPEventBlockReason;

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("57BCA1BE-DF7A-434e-8B89-26D6A0541FDA") 
enum __MIDL___MIDL_itf_encdec_0000_0000_0003
    {	LIC_BadLicense	= 0,
	LIC_NeedIndiv	= 1
    } 	LicenseEventBlockReason;

typedef /* [public][v1_enum][uuid] */  DECLSPEC_UUID("D5CC1CDC-EF31-48dc-95B8-AFD34C08036B") 
enum __MIDL___MIDL_itf_encdec_0000_0000_0004
    {	DOWNRES_Always	= 0,
	DOWNRES_InWindowOnly	= 1,
	DOWNRES_Undefined	= 2
    } 	DownResEventParam;



extern RPC_IF_HANDLE __MIDL_itf_encdec_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_encdec_0000_0000_v0_0_s_ifspec;

#ifndef __IETFilterConfig_INTERFACE_DEFINED__
#define __IETFilterConfig_INTERFACE_DEFINED__

/* interface IETFilterConfig */
/* [unique][helpstring][uuid][object][restricted] */ 


EXTERN_C const IID IID_IETFilterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4D1-0049-4E2B-98FB-9537F6CE516D")
    IETFilterConfig : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitLicense( 
            /* [in] */ int LicenseId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecureChannelObject( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IETFilterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IETFilterConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IETFilterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IETFilterConfig * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitLicense )( 
            IETFilterConfig * This,
            /* [in] */ int LicenseId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecureChannelObject )( 
            IETFilterConfig * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel);
        
        END_INTERFACE
    } IETFilterConfigVtbl;

    interface IETFilterConfig
    {
        CONST_VTBL struct IETFilterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IETFilterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IETFilterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IETFilterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IETFilterConfig_InitLicense(This,LicenseId)	\
    ( (This)->lpVtbl -> InitLicense(This,LicenseId) ) 

#define IETFilterConfig_GetSecureChannelObject(This,ppUnkDRMSecureChannel)	\
    ( (This)->lpVtbl -> GetSecureChannelObject(This,ppUnkDRMSecureChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IETFilterConfig_INTERFACE_DEFINED__ */


#ifndef __IDTFilterConfig_INTERFACE_DEFINED__
#define __IDTFilterConfig_INTERFACE_DEFINED__

/* interface IDTFilterConfig */
/* [unique][helpstring][uuid][object][restricted] */ 


EXTERN_C const IID IID_IDTFilterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4D2-0049-4E2B-98FB-9537F6CE516D")
    IDTFilterConfig : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecureChannelObject( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTFilterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilterConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilterConfig * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecureChannelObject )( 
            IDTFilterConfig * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel);
        
        END_INTERFACE
    } IDTFilterConfigVtbl;

    interface IDTFilterConfig
    {
        CONST_VTBL struct IDTFilterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilterConfig_GetSecureChannelObject(This,ppUnkDRMSecureChannel)	\
    ( (This)->lpVtbl -> GetSecureChannelObject(This,ppUnkDRMSecureChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDTFilterConfig_INTERFACE_DEFINED__ */


#ifndef __IXDSCodecConfig_INTERFACE_DEFINED__
#define __IXDSCodecConfig_INTERFACE_DEFINED__

/* interface IXDSCodecConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXDSCodecConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4D3-0049-4E2B-98FB-9537F6CE516D")
    IXDSCodecConfig : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecureChannelObject( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPauseBufferTime( 
            /* [in] */ DWORD dwPauseBufferTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXDSCodecConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXDSCodecConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXDSCodecConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXDSCodecConfig * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecureChannelObject )( 
            IXDSCodecConfig * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDRMSecureChannel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPauseBufferTime )( 
            IXDSCodecConfig * This,
            /* [in] */ DWORD dwPauseBufferTime);
        
        END_INTERFACE
    } IXDSCodecConfigVtbl;

    interface IXDSCodecConfig
    {
        CONST_VTBL struct IXDSCodecConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXDSCodecConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXDSCodecConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXDSCodecConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXDSCodecConfig_GetSecureChannelObject(This,ppUnkDRMSecureChannel)	\
    ( (This)->lpVtbl -> GetSecureChannelObject(This,ppUnkDRMSecureChannel) ) 

#define IXDSCodecConfig_SetPauseBufferTime(This,dwPauseBufferTime)	\
    ( (This)->lpVtbl -> SetPauseBufferTime(This,dwPauseBufferTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXDSCodecConfig_INTERFACE_DEFINED__ */


#ifndef __IDTFilterBlockedOverlay_INTERFACE_DEFINED__
#define __IDTFilterBlockedOverlay_INTERFACE_DEFINED__

/* interface IDTFilterBlockedOverlay */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDTFilterBlockedOverlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAF37694-909C-49cd-886F-C7382E5DB596")
    IDTFilterBlockedOverlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOverlay( 
            /* [in] */ DWORD dwOverlayCause) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearOverlay( 
            /* [in] */ DWORD dwOverlayCause) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOverlay( 
            /* [out] */ __RPC__out DWORD *pdwOverlayCause) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTFilterBlockedOverlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilterBlockedOverlay * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilterBlockedOverlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilterBlockedOverlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlay )( 
            IDTFilterBlockedOverlay * This,
            /* [in] */ DWORD dwOverlayCause);
        
        HRESULT ( STDMETHODCALLTYPE *ClearOverlay )( 
            IDTFilterBlockedOverlay * This,
            /* [in] */ DWORD dwOverlayCause);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverlay )( 
            IDTFilterBlockedOverlay * This,
            /* [out] */ __RPC__out DWORD *pdwOverlayCause);
        
        END_INTERFACE
    } IDTFilterBlockedOverlayVtbl;

    interface IDTFilterBlockedOverlay
    {
        CONST_VTBL struct IDTFilterBlockedOverlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilterBlockedOverlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilterBlockedOverlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilterBlockedOverlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilterBlockedOverlay_SetOverlay(This,dwOverlayCause)	\
    ( (This)->lpVtbl -> SetOverlay(This,dwOverlayCause) ) 

#define IDTFilterBlockedOverlay_ClearOverlay(This,dwOverlayCause)	\
    ( (This)->lpVtbl -> ClearOverlay(This,dwOverlayCause) ) 

#define IDTFilterBlockedOverlay_GetOverlay(This,pdwOverlayCause)	\
    ( (This)->lpVtbl -> GetOverlay(This,pdwOverlayCause) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDTFilterBlockedOverlay_INTERFACE_DEFINED__ */



#ifndef __EncDec_LIBRARY_DEFINED__
#define __EncDec_LIBRARY_DEFINED__

/* library EncDec */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EncDec;

#ifndef __IETFilter_INTERFACE_DEFINED__
#define __IETFilter_INTERFACE_DEFINED__

/* interface IETFilter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IETFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4B1-0049-4E2B-98FB-9537F6CE516D")
    IETFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EvalRatObjOK( 
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrRating( 
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrLicenseExpDate( 
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLastErrorCode( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRecordingOn( 
            BOOL fRecState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IETFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IETFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IETFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IETFilter * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EvalRatObjOK )( 
            IETFilter * This,
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrRating )( 
            IETFilter * This,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrLicenseExpDate )( 
            IETFilter * This,
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLastErrorCode )( 
            IETFilter * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRecordingOn )( 
            IETFilter * This,
            BOOL fRecState);
        
        END_INTERFACE
    } IETFilterVtbl;

    interface IETFilter
    {
        CONST_VTBL struct IETFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IETFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IETFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IETFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IETFilter_get_EvalRatObjOK(This,pHrCoCreateRetVal)	\
    ( (This)->lpVtbl -> get_EvalRatObjOK(This,pHrCoCreateRetVal) ) 

#define IETFilter_GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr)	\
    ( (This)->lpVtbl -> GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr) ) 

#define IETFilter_GetCurrLicenseExpDate(This,protType,lpDateTime)	\
    ( (This)->lpVtbl -> GetCurrLicenseExpDate(This,protType,lpDateTime) ) 

#define IETFilter_GetLastErrorCode(This)	\
    ( (This)->lpVtbl -> GetLastErrorCode(This) ) 

#define IETFilter_SetRecordingOn(This,fRecState)	\
    ( (This)->lpVtbl -> SetRecordingOn(This,fRecState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IETFilter_INTERFACE_DEFINED__ */


#ifndef __IETFilterEvents_DISPINTERFACE_DEFINED__
#define __IETFilterEvents_DISPINTERFACE_DEFINED__

/* dispinterface IETFilterEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IETFilterEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C4C4C4C1-0049-4E2B-98FB-9537F6CE516D")
    IETFilterEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IETFilterEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IETFilterEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IETFilterEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IETFilterEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IETFilterEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IETFilterEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IETFilterEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IETFilterEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IETFilterEventsVtbl;

    interface IETFilterEvents
    {
        CONST_VTBL struct IETFilterEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IETFilterEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IETFilterEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IETFilterEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IETFilterEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IETFilterEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IETFilterEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IETFilterEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IETFilterEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ETFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("C4C4C4F1-0049-4E2B-98FB-9537F6CE516D")
ETFilter;
#endif

#ifndef __IDTFilter_INTERFACE_DEFINED__
#define __IDTFilter_INTERFACE_DEFINED__

/* interface IDTFilter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDTFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4B2-0049-4E2B-98FB-9537F6CE516D")
    IDTFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EvalRatObjOK( 
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrRating( 
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfEnAttr) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockUnRated( 
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockUnRated( 
            /* [in] */ BOOL fBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockUnRatedDelay( 
            /* [retval][out] */ __RPC__out LONG *pmsecsDelayBeforeBlock) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockUnRatedDelay( 
            /* [in] */ LONG msecsDelayBeforeBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilter * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EvalRatObjOK )( 
            IDTFilter * This,
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrRating )( 
            IDTFilter * This,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockedRatingAttributes )( 
            IDTFilter * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockedRatingAttributes )( 
            IDTFilter * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRated )( 
            IDTFilter * This,
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRated )( 
            IDTFilter * This,
            /* [in] */ BOOL fBlockUnRatedShows);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRatedDelay )( 
            IDTFilter * This,
            /* [retval][out] */ __RPC__out LONG *pmsecsDelayBeforeBlock);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRatedDelay )( 
            IDTFilter * This,
            /* [in] */ LONG msecsDelayBeforeBlock);
        
        END_INTERFACE
    } IDTFilterVtbl;

    interface IDTFilter
    {
        CONST_VTBL struct IDTFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilter_get_EvalRatObjOK(This,pHrCoCreateRetVal)	\
    ( (This)->lpVtbl -> get_EvalRatObjOK(This,pHrCoCreateRetVal) ) 

#define IDTFilter_GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr)	\
    ( (This)->lpVtbl -> GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr) ) 

#define IDTFilter_get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr)	\
    ( (This)->lpVtbl -> get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr) ) 

#define IDTFilter_put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)	\
    ( (This)->lpVtbl -> put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs) ) 

#define IDTFilter_get_BlockUnRated(This,pfBlockUnRatedShows)	\
    ( (This)->lpVtbl -> get_BlockUnRated(This,pfBlockUnRatedShows) ) 

#define IDTFilter_put_BlockUnRated(This,fBlockUnRatedShows)	\
    ( (This)->lpVtbl -> put_BlockUnRated(This,fBlockUnRatedShows) ) 

#define IDTFilter_get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock) ) 

#define IDTFilter_put_BlockUnRatedDelay(This,msecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> put_BlockUnRatedDelay(This,msecsDelayBeforeBlock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDTFilter_INTERFACE_DEFINED__ */


#ifndef __IDTFilter2_INTERFACE_DEFINED__
#define __IDTFilter2_INTERFACE_DEFINED__

/* interface IDTFilter2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDTFilter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4B4-0049-4E2B-98FB-9537F6CE516D")
    IDTFilter2 : public IDTFilter
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ChallengeUrl( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrChallengeUrl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrLicenseExpDate( 
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLastErrorCode( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTFilter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilter2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilter2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EvalRatObjOK )( 
            IDTFilter2 * This,
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrRating )( 
            IDTFilter2 * This,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockedRatingAttributes )( 
            IDTFilter2 * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockedRatingAttributes )( 
            IDTFilter2 * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRated )( 
            IDTFilter2 * This,
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRated )( 
            IDTFilter2 * This,
            /* [in] */ BOOL fBlockUnRatedShows);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRatedDelay )( 
            IDTFilter2 * This,
            /* [retval][out] */ __RPC__out LONG *pmsecsDelayBeforeBlock);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRatedDelay )( 
            IDTFilter2 * This,
            /* [in] */ LONG msecsDelayBeforeBlock);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChallengeUrl )( 
            IDTFilter2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrChallengeUrl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrLicenseExpDate )( 
            IDTFilter2 * This,
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLastErrorCode )( 
            IDTFilter2 * This);
        
        END_INTERFACE
    } IDTFilter2Vtbl;

    interface IDTFilter2
    {
        CONST_VTBL struct IDTFilter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilter2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilter2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilter2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilter2_get_EvalRatObjOK(This,pHrCoCreateRetVal)	\
    ( (This)->lpVtbl -> get_EvalRatObjOK(This,pHrCoCreateRetVal) ) 

#define IDTFilter2_GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr)	\
    ( (This)->lpVtbl -> GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr) ) 

#define IDTFilter2_get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr)	\
    ( (This)->lpVtbl -> get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr) ) 

#define IDTFilter2_put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)	\
    ( (This)->lpVtbl -> put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs) ) 

#define IDTFilter2_get_BlockUnRated(This,pfBlockUnRatedShows)	\
    ( (This)->lpVtbl -> get_BlockUnRated(This,pfBlockUnRatedShows) ) 

#define IDTFilter2_put_BlockUnRated(This,fBlockUnRatedShows)	\
    ( (This)->lpVtbl -> put_BlockUnRated(This,fBlockUnRatedShows) ) 

#define IDTFilter2_get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock) ) 

#define IDTFilter2_put_BlockUnRatedDelay(This,msecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> put_BlockUnRatedDelay(This,msecsDelayBeforeBlock) ) 


#define IDTFilter2_get_ChallengeUrl(This,pbstrChallengeUrl)	\
    ( (This)->lpVtbl -> get_ChallengeUrl(This,pbstrChallengeUrl) ) 

#define IDTFilter2_GetCurrLicenseExpDate(This,protType,lpDateTime)	\
    ( (This)->lpVtbl -> GetCurrLicenseExpDate(This,protType,lpDateTime) ) 

#define IDTFilter2_GetLastErrorCode(This)	\
    ( (This)->lpVtbl -> GetLastErrorCode(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDTFilter2_INTERFACE_DEFINED__ */


#ifndef __IDTFilter3_INTERFACE_DEFINED__
#define __IDTFilter3_INTERFACE_DEFINED__

/* interface IDTFilter3 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDTFilter3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("513998cc-e929-4cdf-9fbd-bad1e0314866")
    IDTFilter3 : public IDTFilter2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProtectionType( 
            /* [out] */ __RPC__out ProtType *pProtectionType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LicenseHasExpirationDate( 
            /* [out] */ __RPC__out BOOL *pfLicenseHasExpirationDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRights( 
            /* [in] */ __RPC__in BSTR bstrRights) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDTFilter3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilter3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilter3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilter3 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EvalRatObjOK )( 
            IDTFilter3 * This,
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrRating )( 
            IDTFilter3 * This,
            /* [out] */ __RPC__out EnTvRat_System *pEnSystem,
            /* [out] */ __RPC__out EnTvRat_GenericLevel *pEnRating,
            /* [out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockedRatingAttributes )( 
            IDTFilter3 * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ __RPC__out LONG *plbfEnAttr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockedRatingAttributes )( 
            IDTFilter3 * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRated )( 
            IDTFilter3 * This,
            /* [retval][out] */ __RPC__out BOOL *pfBlockUnRatedShows);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRated )( 
            IDTFilter3 * This,
            /* [in] */ BOOL fBlockUnRatedShows);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRatedDelay )( 
            IDTFilter3 * This,
            /* [retval][out] */ __RPC__out LONG *pmsecsDelayBeforeBlock);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRatedDelay )( 
            IDTFilter3 * This,
            /* [in] */ LONG msecsDelayBeforeBlock);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChallengeUrl )( 
            IDTFilter3 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrChallengeUrl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrLicenseExpDate )( 
            IDTFilter3 * This,
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLastErrorCode )( 
            IDTFilter3 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProtectionType )( 
            IDTFilter3 * This,
            /* [out] */ __RPC__out ProtType *pProtectionType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LicenseHasExpirationDate )( 
            IDTFilter3 * This,
            /* [out] */ __RPC__out BOOL *pfLicenseHasExpirationDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRights )( 
            IDTFilter3 * This,
            /* [in] */ __RPC__in BSTR bstrRights);
        
        END_INTERFACE
    } IDTFilter3Vtbl;

    interface IDTFilter3
    {
        CONST_VTBL struct IDTFilter3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilter3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilter3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilter3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilter3_get_EvalRatObjOK(This,pHrCoCreateRetVal)	\
    ( (This)->lpVtbl -> get_EvalRatObjOK(This,pHrCoCreateRetVal) ) 

#define IDTFilter3_GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr)	\
    ( (This)->lpVtbl -> GetCurrRating(This,pEnSystem,pEnRating,plbfEnAttr) ) 

#define IDTFilter3_get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr)	\
    ( (This)->lpVtbl -> get_BlockedRatingAttributes(This,enSystem,enLevel,plbfEnAttr) ) 

#define IDTFilter3_put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)	\
    ( (This)->lpVtbl -> put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs) ) 

#define IDTFilter3_get_BlockUnRated(This,pfBlockUnRatedShows)	\
    ( (This)->lpVtbl -> get_BlockUnRated(This,pfBlockUnRatedShows) ) 

#define IDTFilter3_put_BlockUnRated(This,fBlockUnRatedShows)	\
    ( (This)->lpVtbl -> put_BlockUnRated(This,fBlockUnRatedShows) ) 

#define IDTFilter3_get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> get_BlockUnRatedDelay(This,pmsecsDelayBeforeBlock) ) 

#define IDTFilter3_put_BlockUnRatedDelay(This,msecsDelayBeforeBlock)	\
    ( (This)->lpVtbl -> put_BlockUnRatedDelay(This,msecsDelayBeforeBlock) ) 


#define IDTFilter3_get_ChallengeUrl(This,pbstrChallengeUrl)	\
    ( (This)->lpVtbl -> get_ChallengeUrl(This,pbstrChallengeUrl) ) 

#define IDTFilter3_GetCurrLicenseExpDate(This,protType,lpDateTime)	\
    ( (This)->lpVtbl -> GetCurrLicenseExpDate(This,protType,lpDateTime) ) 

#define IDTFilter3_GetLastErrorCode(This)	\
    ( (This)->lpVtbl -> GetLastErrorCode(This) ) 


#define IDTFilter3_GetProtectionType(This,pProtectionType)	\
    ( (This)->lpVtbl -> GetProtectionType(This,pProtectionType) ) 

#define IDTFilter3_LicenseHasExpirationDate(This,pfLicenseHasExpirationDate)	\
    ( (This)->lpVtbl -> LicenseHasExpirationDate(This,pfLicenseHasExpirationDate) ) 

#define IDTFilter3_SetRights(This,bstrRights)	\
    ( (This)->lpVtbl -> SetRights(This,bstrRights) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDTFilter3_INTERFACE_DEFINED__ */


#ifndef __IDTFilterEvents_DISPINTERFACE_DEFINED__
#define __IDTFilterEvents_DISPINTERFACE_DEFINED__

/* dispinterface IDTFilterEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IDTFilterEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C4C4C4C2-0049-4E2B-98FB-9537F6CE516D")
    IDTFilterEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IDTFilterEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDTFilterEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDTFilterEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDTFilterEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDTFilterEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDTFilterEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDTFilterEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDTFilterEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IDTFilterEventsVtbl;

    interface IDTFilterEvents
    {
        CONST_VTBL struct IDTFilterEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDTFilterEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDTFilterEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDTFilterEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDTFilterEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDTFilterEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDTFilterEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDTFilterEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IDTFilterEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DTFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("C4C4C4F2-0049-4E2B-98FB-9537F6CE516D")
DTFilter;
#endif

#ifndef __IXDSCodec_INTERFACE_DEFINED__
#define __IXDSCodec_INTERFACE_DEFINED__

/* interface IXDSCodec */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXDSCodec;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4C4C4B3-0049-4E2B-98FB-9537F6CE516D")
    IXDSCodec : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XDSToRatObjOK( 
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CCSubstreamService( 
            /* [in] */ long SubstreamMask) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CCSubstreamService( 
            /* [retval][out] */ __RPC__out long *pSubstreamMask) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetContentAdvisoryRating( 
            /* [out] */ __RPC__out PackedTvRating *pRat,
            /* [out] */ __RPC__out long *pPktSeqID,
            /* [out] */ __RPC__out long *pCallSeqID,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeStart,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetXDSPacket( 
            /* [out] */ __RPC__out long *pXDSClassPkt,
            /* [out] */ __RPC__out long *pXDSTypePkt,
            /* [out] */ __RPC__deref_out_opt BSTR *pBstrXDSPkt,
            /* [out] */ __RPC__out long *pPktSeqID,
            /* [out] */ __RPC__out long *pCallSeqID,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeStart,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrLicenseExpDate( 
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLastErrorCode( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXDSCodecVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXDSCodec * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXDSCodec * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXDSCodec * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XDSToRatObjOK )( 
            IXDSCodec * This,
            /* [retval][out] */ __RPC__out HRESULT *pHrCoCreateRetVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CCSubstreamService )( 
            IXDSCodec * This,
            /* [in] */ long SubstreamMask);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CCSubstreamService )( 
            IXDSCodec * This,
            /* [retval][out] */ __RPC__out long *pSubstreamMask);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetContentAdvisoryRating )( 
            IXDSCodec * This,
            /* [out] */ __RPC__out PackedTvRating *pRat,
            /* [out] */ __RPC__out long *pPktSeqID,
            /* [out] */ __RPC__out long *pCallSeqID,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeStart,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetXDSPacket )( 
            IXDSCodec * This,
            /* [out] */ __RPC__out long *pXDSClassPkt,
            /* [out] */ __RPC__out long *pXDSTypePkt,
            /* [out] */ __RPC__deref_out_opt BSTR *pBstrXDSPkt,
            /* [out] */ __RPC__out long *pPktSeqID,
            /* [out] */ __RPC__out long *pCallSeqID,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeStart,
            /* [out] */ __RPC__out REFERENCE_TIME *pTimeEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrLicenseExpDate )( 
            IXDSCodec * This,
            /* [in] */ __RPC__in ProtType *protType,
            /* [out] */ __RPC__out long *lpDateTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLastErrorCode )( 
            IXDSCodec * This);
        
        END_INTERFACE
    } IXDSCodecVtbl;

    interface IXDSCodec
    {
        CONST_VTBL struct IXDSCodecVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXDSCodec_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXDSCodec_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXDSCodec_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXDSCodec_get_XDSToRatObjOK(This,pHrCoCreateRetVal)	\
    ( (This)->lpVtbl -> get_XDSToRatObjOK(This,pHrCoCreateRetVal) ) 

#define IXDSCodec_put_CCSubstreamService(This,SubstreamMask)	\
    ( (This)->lpVtbl -> put_CCSubstreamService(This,SubstreamMask) ) 

#define IXDSCodec_get_CCSubstreamService(This,pSubstreamMask)	\
    ( (This)->lpVtbl -> get_CCSubstreamService(This,pSubstreamMask) ) 

#define IXDSCodec_GetContentAdvisoryRating(This,pRat,pPktSeqID,pCallSeqID,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetContentAdvisoryRating(This,pRat,pPktSeqID,pCallSeqID,pTimeStart,pTimeEnd) ) 

#define IXDSCodec_GetXDSPacket(This,pXDSClassPkt,pXDSTypePkt,pBstrXDSPkt,pPktSeqID,pCallSeqID,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetXDSPacket(This,pXDSClassPkt,pXDSTypePkt,pBstrXDSPkt,pPktSeqID,pCallSeqID,pTimeStart,pTimeEnd) ) 

#define IXDSCodec_GetCurrLicenseExpDate(This,protType,lpDateTime)	\
    ( (This)->lpVtbl -> GetCurrLicenseExpDate(This,protType,lpDateTime) ) 

#define IXDSCodec_GetLastErrorCode(This)	\
    ( (This)->lpVtbl -> GetLastErrorCode(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXDSCodec_INTERFACE_DEFINED__ */


#ifndef __IXDSCodecEvents_DISPINTERFACE_DEFINED__
#define __IXDSCodecEvents_DISPINTERFACE_DEFINED__

/* dispinterface IXDSCodecEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IXDSCodecEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C4C4C4C3-0049-4E2B-98FB-9537F6CE516D")
    IXDSCodecEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IXDSCodecEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXDSCodecEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXDSCodecEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXDSCodecEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXDSCodecEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXDSCodecEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXDSCodecEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXDSCodecEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IXDSCodecEventsVtbl;

    interface IXDSCodecEvents
    {
        CONST_VTBL struct IXDSCodecEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXDSCodecEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXDSCodecEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXDSCodecEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXDSCodecEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXDSCodecEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXDSCodecEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXDSCodecEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IXDSCodecEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XDSCodec;

#ifdef __cplusplus

class DECLSPEC_UUID("C4C4C4F3-0049-4E2B-98FB-9537F6CE516D")
XDSCodec;
#endif

EXTERN_C const CLSID CLSID_CXDSData;

#ifdef __cplusplus

class DECLSPEC_UUID("C4C4C4F4-0049-4E2B-98FB-9537F6CE516D")
CXDSData;
#endif
#endif /* __EncDec_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\EmptyVC.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for emptyvc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __emptyvc_h__
#define __emptyvc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEmptyVolumeCacheCallBack_FWD_DEFINED__
#define __IEmptyVolumeCacheCallBack_FWD_DEFINED__
typedef interface IEmptyVolumeCacheCallBack IEmptyVolumeCacheCallBack;
#endif 	/* __IEmptyVolumeCacheCallBack_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache_FWD_DEFINED__
#define __IEmptyVolumeCache_FWD_DEFINED__
typedef interface IEmptyVolumeCache IEmptyVolumeCache;
#endif 	/* __IEmptyVolumeCache_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache2_FWD_DEFINED__
#define __IEmptyVolumeCache2_FWD_DEFINED__
typedef interface IEmptyVolumeCache2 IEmptyVolumeCache2;
#endif 	/* __IEmptyVolumeCache2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_emptyvc_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// emptyvc.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Empty Volume Cache Interfaces.



// IEmptyVolumeCache Flags
#define EVCF_HASSETTINGS             0x0001
#define EVCF_ENABLEBYDEFAULT         0x0002
#define EVCF_REMOVEFROMLIST          0x0004
#define EVCF_ENABLEBYDEFAULT_AUTO    0x0008
#define EVCF_DONTSHOWIFZERO          0x0010
#define EVCF_SETTINGSMODE            0x0020
#define EVCF_OUTOFDISKSPACE          0x0040

// IEmptyVolumeCacheCallBack Flags
#define EVCCBF_LASTNOTIFICATION  0x0001

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPEMPTYVOLUMECACHECALLBACK_DEFINED
#define _LPEMPTYVOLUMECACHECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0000_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__
#define __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__

/* interface IEmptyVolumeCacheCallBack */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEmptyVolumeCacheCallBack *LPEMPTYVOLUMECACHECALLBACK;


EXTERN_C const IID IID_IEmptyVolumeCacheCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6E793361-73C6-11D0-8469-00AA00442901")
    IEmptyVolumeCacheCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScanProgress( 
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pcwszStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PurgeProgress( 
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pcwszStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEmptyVolumeCacheCallBack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEmptyVolumeCacheCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEmptyVolumeCacheCallBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScanProgress )( 
            IEmptyVolumeCacheCallBack * This,
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pcwszStatus);
        
        HRESULT ( STDMETHODCALLTYPE *PurgeProgress )( 
            IEmptyVolumeCacheCallBack * This,
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pcwszStatus);
        
        END_INTERFACE
    } IEmptyVolumeCacheCallBackVtbl;

    interface IEmptyVolumeCacheCallBack
    {
        CONST_VTBL struct IEmptyVolumeCacheCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCacheCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEmptyVolumeCacheCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEmptyVolumeCacheCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEmptyVolumeCacheCallBack_ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus)	\
    ( (This)->lpVtbl -> ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus) ) 

#define IEmptyVolumeCacheCallBack_PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus)	\
    ( (This)->lpVtbl -> PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE_DEFINED
#define _LPEMPTYVOLUMECACHE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0001_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache_INTERFACE_DEFINED__
#define __IEmptyVolumeCache_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEmptyVolumeCache *LPEMPTYVOLUMECACHE;


EXTERN_C const IID IID_IEmptyVolumeCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FCE5227-04DA-11d1-A004-00805F8ABE06")
    IEmptyVolumeCache : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR *ppwszDisplayName,
            /* [out] */ LPWSTR *ppwszDescription,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpaceUsed( 
            /* [out] */ __RPC__out DWORDLONG *pdwlSpaceUsed,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Purge( 
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [out] */ __RPC__out DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEmptyVolumeCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEmptyVolumeCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEmptyVolumeCache * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IEmptyVolumeCache * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR *ppwszDisplayName,
            /* [out] */ LPWSTR *ppwszDescription,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpaceUsed )( 
            IEmptyVolumeCache * This,
            /* [out] */ __RPC__out DWORDLONG *pdwlSpaceUsed,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb);
        
        HRESULT ( STDMETHODCALLTYPE *Purge )( 
            IEmptyVolumeCache * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb);
        
        HRESULT ( STDMETHODCALLTYPE *ShowProperties )( 
            IEmptyVolumeCache * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IEmptyVolumeCache * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCacheVtbl;

    interface IEmptyVolumeCache
    {
        CONST_VTBL struct IEmptyVolumeCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEmptyVolumeCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEmptyVolumeCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEmptyVolumeCache_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    ( (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags) ) 

#define IEmptyVolumeCache_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    ( (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb) ) 

#define IEmptyVolumeCache_Purge(This,dwlSpaceToFree,picb)	\
    ( (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb) ) 

#define IEmptyVolumeCache_ShowProperties(This,hwnd)	\
    ( (This)->lpVtbl -> ShowProperties(This,hwnd) ) 

#define IEmptyVolumeCache_Deactivate(This,pdwFlags)	\
    ( (This)->lpVtbl -> Deactivate(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEmptyVolumeCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE2_DEFINED
#define _LPEMPTYVOLUMECACHE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0002_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache2_INTERFACE_DEFINED__
#define __IEmptyVolumeCache2_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEmptyVolumeCache2 *LPEMPTYVOLUMECACHE2;


EXTERN_C const IID IID_IEmptyVolumeCache2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02b7e3ba-4db3-11d2-b2d9-00c04f8eec8c")
    IEmptyVolumeCache2 : public IEmptyVolumeCache
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR *ppwszDisplayName,
            /* [out] */ LPWSTR *ppwszDescription,
            /* [out] */ LPWSTR *ppwszBtnText,
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCache2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEmptyVolumeCache2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEmptyVolumeCache2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEmptyVolumeCache2 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IEmptyVolumeCache2 * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR *ppwszDisplayName,
            /* [out] */ LPWSTR *ppwszDescription,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpaceUsed )( 
            IEmptyVolumeCache2 * This,
            /* [out] */ __RPC__out DWORDLONG *pdwlSpaceUsed,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb);
        
        HRESULT ( STDMETHODCALLTYPE *Purge )( 
            IEmptyVolumeCache2 * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ __RPC__in_opt IEmptyVolumeCacheCallBack *picb);
        
        HRESULT ( STDMETHODCALLTYPE *ShowProperties )( 
            IEmptyVolumeCache2 * This,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IEmptyVolumeCache2 * This,
            /* [out] */ __RPC__out DWORD *pdwFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            IEmptyVolumeCache2 * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR *ppwszDisplayName,
            /* [out] */ LPWSTR *ppwszDescription,
            /* [out] */ LPWSTR *ppwszBtnText,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCache2Vtbl;

    interface IEmptyVolumeCache2
    {
        CONST_VTBL struct IEmptyVolumeCache2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEmptyVolumeCache2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEmptyVolumeCache2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEmptyVolumeCache2_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    ( (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags) ) 

#define IEmptyVolumeCache2_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    ( (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb) ) 

#define IEmptyVolumeCache2_Purge(This,dwlSpaceToFree,picb)	\
    ( (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb) ) 

#define IEmptyVolumeCache2_ShowProperties(This,hwnd)	\
    ( (This)->lpVtbl -> ShowProperties(This,hwnd) ) 

#define IEmptyVolumeCache2_Deactivate(This,pdwFlags)	\
    ( (This)->lpVtbl -> Deactivate(This,pdwFlags) ) 


#define IEmptyVolumeCache2_InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags)	\
    ( (This)->lpVtbl -> InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEmptyVolumeCache2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0000_0003 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\endpointvolume.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for endpointvolume.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __endpointvolume_h__
#define __endpointvolume_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAudioEndpointVolumeCallback_FWD_DEFINED__
#define __IAudioEndpointVolumeCallback_FWD_DEFINED__
typedef interface IAudioEndpointVolumeCallback IAudioEndpointVolumeCallback;
#endif 	/* __IAudioEndpointVolumeCallback_FWD_DEFINED__ */


#ifndef __IAudioEndpointVolume_FWD_DEFINED__
#define __IAudioEndpointVolume_FWD_DEFINED__
typedef interface IAudioEndpointVolume IAudioEndpointVolume;
#endif 	/* __IAudioEndpointVolume_FWD_DEFINED__ */


#ifndef __IAudioMeterInformation_FWD_DEFINED__
#define __IAudioMeterInformation_FWD_DEFINED__
typedef interface IAudioMeterInformation IAudioMeterInformation;
#endif 	/* __IAudioMeterInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "devicetopology.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_endpointvolume_0000_0000 */
/* [local] */ 

typedef struct AUDIO_VOLUME_NOTIFICATION_DATA
    {
    GUID guidEventContext;
    BOOL bMuted;
    float fMasterVolume;
    UINT nChannels;
    float afChannelVolumes[ 1 ];
    } 	AUDIO_VOLUME_NOTIFICATION_DATA;

typedef struct AUDIO_VOLUME_NOTIFICATION_DATA *PAUDIO_VOLUME_NOTIFICATION_DATA;

#define   ENDPOINT_HARDWARE_SUPPORT_VOLUME    0x00000001
#define   ENDPOINT_HARDWARE_SUPPORT_MUTE      0x00000002
#define   ENDPOINT_HARDWARE_SUPPORT_METER     0x00000004


extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_s_ifspec;

#ifndef __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
#define __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__

/* interface IAudioEndpointVolumeCallback */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioEndpointVolumeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("657804FA-D6AD-4496-8A60-352752AF4F89")
    IAudioEndpointVolumeCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNotify( 
            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioEndpointVolumeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioEndpointVolumeCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioEndpointVolumeCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioEndpointVolumeCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            IAudioEndpointVolumeCallback * This,
            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify);
        
        END_INTERFACE
    } IAudioEndpointVolumeCallbackVtbl;

    interface IAudioEndpointVolumeCallback
    {
        CONST_VTBL struct IAudioEndpointVolumeCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioEndpointVolumeCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioEndpointVolumeCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioEndpointVolumeCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioEndpointVolumeCallback_OnNotify(This,pNotify)	\
    ( (This)->lpVtbl -> OnNotify(This,pNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__ */


#ifndef __IAudioEndpointVolume_INTERFACE_DEFINED__
#define __IAudioEndpointVolume_INTERFACE_DEFINED__

/* interface IAudioEndpointVolume */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioEndpointVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CDF2C82-841E-4546-9722-0CF74078229A")
    IAudioEndpointVolume : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeNotify( 
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeNotify( 
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ 
            __out  UINT *pnChannelCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevel( 
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevelScalar( 
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevel( 
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevelScalar( 
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevelScalar( 
            /* [in] */ 
            __in  UINT nChannel,
            float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevel( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevelScalar( 
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMute( 
            /* [in] */ 
            __in  BOOL bMute,
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMute( 
            /* [out] */ 
            __out  BOOL *pbMute) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeStepInfo( 
            /* [out] */ 
            __out  UINT *pnStep,
            /* [out] */ 
            __out  UINT *pnStepCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepUp( 
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepDown( 
            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeRange( 
            /* [out] */ 
            __out  float *pflVolumeMindB,
            /* [out] */ 
            __out  float *pflVolumeMaxdB,
            /* [out] */ 
            __out  float *pflVolumeIncrementdB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioEndpointVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioEndpointVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioEndpointVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioEndpointVolume * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeNotify )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeNotify )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  IAudioEndpointVolumeCallback *pNotify);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  UINT *pnChannelCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pfLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            float fLevelDB,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            float fLevel,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevel )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevelDB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevelScalar )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  UINT nChannel,
            /* [out] */ 
            __out  float *pfLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
            IAudioEndpointVolume * This,
            /* [in] */ 
            __in  BOOL bMute,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  BOOL *pbMute);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeStepInfo )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  UINT *pnStep,
            /* [out] */ 
            __out  UINT *pnStepCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepUp )( 
            IAudioEndpointVolume * This,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepDown )( 
            IAudioEndpointVolume * This,
            /* [unique][in] */ LPCGUID pguidEventContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeRange )( 
            IAudioEndpointVolume * This,
            /* [out] */ 
            __out  float *pflVolumeMindB,
            /* [out] */ 
            __out  float *pflVolumeMaxdB,
            /* [out] */ 
            __out  float *pflVolumeIncrementdB);
        
        END_INTERFACE
    } IAudioEndpointVolumeVtbl;

    interface IAudioEndpointVolume
    {
        CONST_VTBL struct IAudioEndpointVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioEndpointVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioEndpointVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioEndpointVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioEndpointVolume_RegisterControlChangeNotify(This,pNotify)	\
    ( (This)->lpVtbl -> RegisterControlChangeNotify(This,pNotify) ) 

#define IAudioEndpointVolume_UnregisterControlChangeNotify(This,pNotify)	\
    ( (This)->lpVtbl -> UnregisterControlChangeNotify(This,pNotify) ) 

#define IAudioEndpointVolume_GetChannelCount(This,pnChannelCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,pnChannelCount) ) 

#define IAudioEndpointVolume_SetMasterVolumeLevel(This,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMasterVolumeLevel(This,fLevelDB,pguidEventContext) ) 

#define IAudioEndpointVolume_SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext) ) 

#define IAudioEndpointVolume_GetMasterVolumeLevel(This,pfLevelDB)	\
    ( (This)->lpVtbl -> GetMasterVolumeLevel(This,pfLevelDB) ) 

#define IAudioEndpointVolume_GetMasterVolumeLevelScalar(This,pfLevel)	\
    ( (This)->lpVtbl -> GetMasterVolumeLevelScalar(This,pfLevel) ) 

#define IAudioEndpointVolume_SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext) ) 

#define IAudioEndpointVolume_SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext)	\
    ( (This)->lpVtbl -> SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext) ) 

#define IAudioEndpointVolume_GetChannelVolumeLevel(This,nChannel,pfLevelDB)	\
    ( (This)->lpVtbl -> GetChannelVolumeLevel(This,nChannel,pfLevelDB) ) 

#define IAudioEndpointVolume_GetChannelVolumeLevelScalar(This,nChannel,pfLevel)	\
    ( (This)->lpVtbl -> GetChannelVolumeLevelScalar(This,nChannel,pfLevel) ) 

#define IAudioEndpointVolume_SetMute(This,bMute,pguidEventContext)	\
    ( (This)->lpVtbl -> SetMute(This,bMute,pguidEventContext) ) 

#define IAudioEndpointVolume_GetMute(This,pbMute)	\
    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 

#define IAudioEndpointVolume_GetVolumeStepInfo(This,pnStep,pnStepCount)	\
    ( (This)->lpVtbl -> GetVolumeStepInfo(This,pnStep,pnStepCount) ) 

#define IAudioEndpointVolume_VolumeStepUp(This,pguidEventContext)	\
    ( (This)->lpVtbl -> VolumeStepUp(This,pguidEventContext) ) 

#define IAudioEndpointVolume_VolumeStepDown(This,pguidEventContext)	\
    ( (This)->lpVtbl -> VolumeStepDown(This,pguidEventContext) ) 

#define IAudioEndpointVolume_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 

#define IAudioEndpointVolume_GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB)	\
    ( (This)->lpVtbl -> GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioEndpointVolume_INTERFACE_DEFINED__ */


#ifndef __IAudioMeterInformation_INTERFACE_DEFINED__
#define __IAudioMeterInformation_INTERFACE_DEFINED__

/* interface IAudioMeterInformation */
/* [unique][helpstring][nonextensible][uuid][local][object] */ 


EXTERN_C const IID IID_IAudioMeterInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C02216F6-8C67-4B5B-9D00-D008E73E0064")
    IAudioMeterInformation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPeakValue( 
            /* [out] */ float *pfPeak) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMeteringChannelCount( 
            /* [out] */ 
            __out  UINT *pnChannelCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelsPeakValues( 
            /* [in] */ UINT32 u32ChannelCount,
            /* [size_is][out] */ float *afPeakValues) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAudioMeterInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAudioMeterInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAudioMeterInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAudioMeterInformation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPeakValue )( 
            IAudioMeterInformation * This,
            /* [out] */ float *pfPeak);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringChannelCount )( 
            IAudioMeterInformation * This,
            /* [out] */ 
            __out  UINT *pnChannelCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelsPeakValues )( 
            IAudioMeterInformation * This,
            /* [in] */ UINT32 u32ChannelCount,
            /* [size_is][out] */ float *afPeakValues);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
            IAudioMeterInformation * This,
            /* [out] */ 
            __out  DWORD *pdwHardwareSupportMask);
        
        END_INTERFACE
    } IAudioMeterInformationVtbl;

    interface IAudioMeterInformation
    {
        CONST_VTBL struct IAudioMeterInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAudioMeterInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAudioMeterInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAudioMeterInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAudioMeterInformation_GetPeakValue(This,pfPeak)	\
    ( (This)->lpVtbl -> GetPeakValue(This,pfPeak) ) 

#define IAudioMeterInformation_GetMeteringChannelCount(This,pnChannelCount)	\
    ( (This)->lpVtbl -> GetMeteringChannelCount(This,pnChannelCount) ) 

#define IAudioMeterInformation_GetChannelsPeakValues(This,u32ChannelCount,afPeakValues)	\
    ( (This)->lpVtbl -> GetChannelsPeakValues(This,u32ChannelCount,afPeakValues) ) 

#define IAudioMeterInformation_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAudioMeterInformation_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\evalcom2.h ===
//--------------------------------------------------------------------------
//
//  Microsoft Windows - EvalCom2 MSI Validation Engine
//
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#pragma once

#include <objbase.h>


// returned from IEvalResult::GetResultType
typedef enum RESULTTYPES	
{
	ieUnknown = 0,
	ieError,
	ieWarning,
	ieInfo,
};

// values passed to status callback
typedef enum STATUSTYPES
{
	ieStatusGetCUB,
	ieStatusICECount,
	ieStatusMerge,
	ieStatusSummaryInfo,
	ieStatusCreateEngine,
	ieStatusStarting,
	ieStatusRunICE,
	ieStatusShutdown,
	ieStatusSuccess,
	ieStatusFail,
	ieStatusCancel
};

typedef BOOL (WINAPI* LPDISPLAYVAL)(LPVOID pContext, RESULTTYPES uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
typedef BOOL (WINAPI* LPEVALCOMCALLBACK)(STATUSTYPES iStatus, LPCWSTR szData, LPVOID pContext);

///////////////////////////////////////////////////////////
// IEval
interface IValidate : IUnknown
{
	virtual HRESULT __stdcall OpenDatabase(LPCOLESTR szDatabase) = 0;
	virtual HRESULT __stdcall OpenCUB(LPCOLESTR szCUBFile) = 0;
	virtual HRESULT __stdcall CloseDatabase() = 0;
	virtual HRESULT __stdcall CloseCUB() = 0;

	virtual HRESULT __stdcall SetDisplay(LPDISPLAYVAL pDisplayFunction, LPVOID pContext) = 0;
	virtual HRESULT __stdcall SetStatus(LPEVALCOMCALLBACK pStatusFunction, LPVOID pContext) = 0;
	
	virtual HRESULT __stdcall Validate(const WCHAR *wzICEs = NULL) = 0;
};
 

/* 6e5e1910-8053-4660-b795-6b612e29bc58 */
DEFINE_GUID(CLSID_EvalCom2, 0x6e5e1910, 0x8053, 0x4660, 0xb7, 0x95, 0x6b, 0x61, 0x2e, 0x29, 0xbc, 0x58);

/* e482e5c6-e31e-4143-a2e6-dbc3d8e4b8d3 */
DEFINE_GUID(IID_IValidate, 0xe482e5c6, 0xe31e, 0x4143, 0xa2, 0xe6, 0xdb, 0xc3, 0xd8, 0xe4, 0xb8, 0xd3);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\EvColl.h ===
/*++
Copyright (C) Microsoft Corporation.  All rights reserved. 


Module Name:

    evcoll.h

Abstract:

    Event Collector API 

--*/


#ifndef __EVCOLL_H__
#define __EVCOLL_H__

#ifdef __cplusplus
extern "C"
{
#endif


typedef HANDLE EC_HANDLE;
typedef HANDLE EC_OBJECT_ARRAY_PROPERTY_HANDLE;


// 
// Access Control Permissions
//

/*--------------------------------------------------------------------------
  Subscription Definitions
  --------------------------------------------------------------------------*/

typedef enum _EC_SUBSCRIPTION_PROPERTY_ID
{
    EcSubscriptionEnabled = 0,           // EcVarTypeBoolean
    EcSubscriptionEventSources,          // EcVarObjectArrayPropertyHandle
    EcSubscriptionEventSourceAddress,    // EcVarTypeString
    EcSubscriptionEventSourceEnabled,    // EcVarTypeBoolean
    EcSubscriptionEventSourceUserName,   // EcVarTypeString
    EcSubscriptionEventSourcePassword,   // EcVarTypeString
    EcSubscriptionDescription,           // EcVarTypeString
    EcSubscriptionURI,                   // EcVarTypeString
    EcSubscriptionConfigurationMode,     // EcVarTypeUInt32, EC_SUBSCRIPTION_CONFIGURATION_MODE
    EcSubscriptionExpires,               // EcVarTypeDateTime
    EcSubscriptionQuery,                 // EcVarTypeString
    EcSubscriptionTransportName,         // EcVarTypeString
    EcSubscriptionTransportPort,         // EcVarTypeUInt32        
    EcSubscriptionDeliveryMode,          // EcVarTypeUInt32, EC_SUBSCRIPTION_DELIVERY_MODE
    EcSubscriptionDeliveryMaxItems,      // EcVarTypeUInt32
    EcSubscriptionDeliveryMaxLatencyTime, // EcVarTypeUInt32
    EcSubscriptionHeartbeatInterval,     // EcVarTypeUInt32
    EcSubscriptionLocale,                // EcVarTypeString
    EcSubscriptionContentFormat,         // EcVarTypeUInt32, EC_SUBSCRIPTION_CONTENT_FORMAT
    EcSubscriptionLogFile,               // EcVarTypeString
    EcSubscriptionPublisherName,         // EcVarTypeString
    EcSubscriptionCredentialsType,       // EcVarTypeUInt32, EC_SUBSCRIPTION_CREDENTIALS_TYPE
    EcSubscriptionCommonUserName,        // EcVarTypeString
    EcSubscriptionCommonPassword,        // EcVarTypeString
    EcSubscriptionHostName,              // EcVarTypeString    
    EcSubscriptionReadExistingEvents,    // EcVarTypeBoolean
    EcSubscriptionDialect,               // EcVarTypeString
    EcSubscript