eption because the 
                // AssetLoader is set to not use fallback assets
                Logging.WriteEvent(new AssetRetrievalFailed(), ex);
                isLoadSuccessful = false;
            }

            return isLoadSuccessful;
        }

        /// <summary>
        /// Load and render avatar raw image.  Typically used to generate the full body image of an avatar.
        /// </summary> 
        /// <param name="avatar">Avatar data</param>
        internal int[] GenerateImage(AvatarPerspectiveData avatar)
        {
            if (!LoadAvatarData(avatar))
            {
                return null;
            }

            if (useCamera)
            {
                Matrix camera = avatarRenderer.GetPoseMatrix(avatar.Pose, cameraData.Offset, cameraData.Rotation, cameraData.FieldOfView);
                avatarRenderer.RenderPreviewImage(ref camera);
            }
            else
            {
                avatarRenderer.RenderDefaultPreview(avatar.Pose);
            }

            if (this.setBackgroundImage)
            {
                return avatarRenderer.GetImagePixelsWithBackground();
            }
            else
            {
                return avatarRenderer.GetImagePixels();
            }
        }

        /// <summary>
        /// Load the avatar asset data and render an image using a custom PoseConfiguration.  Typically
        /// used for generating a gamerpic image.
        /// </summary>
        /// <param name="avatarData"></param>
        /// <param name="pose"></param>
        /// <returns></returns>
        internal int[] GenerateImage(AvatarPerspectiveData avatarData, PoseConfiguration pose)
        {
            if (!LoadAvatarData(avatarData))
            {
                return null;
            }

            avatarRenderer.RenderDefaultPreview(pose);

            if (this.setBackgroundImage)
            {
                return avatarRenderer.GetImagePixelsWithBackground();
            }
            else
            {
                return avatarRenderer.GetImagePixels();
            }
        }

        /// <summary>
        /// Load and render avatar raw preview image with all default poses
        /// </summary> 
        /// <param name="avatar">Avatar data</param>
        /// <param name="grid">Distance between sub images in final preview image in pixels</param>
        /// <param name="stride">Returned width of preview image in pixels</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "0#")]
        internal int[] GeneratePreviewImage(AvatarPerspectiveData avatar, int grid, out int stride)
        {
            stride = 0;

            if (!LoadAvatarData(avatar))
            {
                return null;
            }

            int poseCount = (int)AvatarPose.PosesCount;

            int iWidth, iHeight;

            iWidth = iHeight = (int) Math.Sqrt((double)poseCount);

            if (iHeight * iWidth < poseCount)
            {
                iWidth = iHeight + 1;

                if (poseCount > iHeight * iWidth)
                {
                    iHeight += 1;
                }
            }
            
            int imageWidth = iWidth * avatarRenderer.Width + (iWidth - 1) * grid;
            int imageHeight = iHeight * avatarRenderer.Height + (iHeight - 1) * grid;

            int row_step = (iWidth - 1) * (avatarRenderer.Width + grid);
            int rowHeight = avatarRenderer.Height + grid;

            int[] finalPixels = new int[imageHeight * imageWidth];

            //all default poses are rendered
            for (AvatarPose pose = AvatarPose.BodyFixed; pose < AvatarPose.PosesCount; ++pose)
            {
                avatarRenderer.RenderDefaultPreview(pose);

                int[] pixels = avatarRenderer.GetImagePixels(); ;

                int i_addr = 0;
                int addr = (((int)pose) / iWidth) * rowHeight * imageWidth + (((int)pose) % iWidth) * (avatarRenderer.Width + grid);

                for (int m = 0; m < avatarRenderer.Height; ++m)
                {
                    for (int n = 0; n < avatarRenderer.Width; ++n)
                    {
                        finalPixels[addr++] = pixels[i_addr++];
                    }

                    addr += row_step;
                }
            }

            stride = imageWidth;
            return finalPixels;
        }

        /// <summary>
        /// Render avatar in given animation frame
        /// </summary> 
        /// <param name="frame">Animation frame</param>
        /// <param name="pose">Pose to render</param>
        internal int[] RenderAnimationFrame(int frame, AvatarPose pose)
        {
            if (frame >= avatarRenderer.AnimationFrameCount)
            {
                ArgumentOutOfRangeException argEx = new ArgumentOutOfRangeException("frame");
                Logging.TraceException(argEx, "AvatarLoader.RenderAnimationFrame, invalid frame value {0} > {1}", frame, avatarRenderer.AnimationFrameCount);
                throw argEx;
            }

            avatarRenderer.SetAnimationFrame(frame);
            avatarRenderer.RenderDefaultPreview(pose);

            int[] image = avatarRenderer.GetImagePixels();

            return image;
        }

        internal int[] LoadFrame(AvatarPose pose, float frame)
        {
            avatarRenderer.SetAnimationPose(frame);
            avatarRenderer.RenderDefaultPreview(pose);
            return avatarRenderer.GetImagePixels() as int[];
        }

        internal float GetLength()
        {
            return avatarRenderer.AvatarAnimation.Length;
        }

        internal int GetFrameCount()
        {
            return avatarRenderer.AvatarAnimation.FrameCount;
        }

        #endregion

        #region Private methods

        private AvatarLoader(string avatarAssetAddressFormat, string nonStockAssetAddressFormat)
        {
            this.assetDataManager = new AssetDataManager();
            this.assetDataManager.AddAssetProvider(new AssetUrlDataProvider(avatarAssetAddressFormat, nonStockAssetAddressFormat));
            
            this.assetLoader = new AssetLoader(assetDataManager, CoordinateSystem.LeftHanded);
            // this forces the renderer to dump requests that fail to load their assets rather than use fallback assets
            this.assetLoader.AllowAlternativeAvatarAssets = false;

            //enable caching with cache size set to the default size
            AssetLoader.EnableAssetCaching(assetCacheSize);

            this.avatarGender = AvatarGender.Unknown;
        }

        /// <summary>
        /// Create renderer
        /// </summary>
        /// <param name="data">Render initialization data</param>
        static private SoftwareRendererSingleThreaded CreateRenderer(ref ImageProperties imageProperties)
        {
            if (imageProperties.Width < 1 || imageProperties.Height < 1)
            {
                throw new ArgumentOutOfRangeException("imageProperties");
            }

            int[] pixels = new int[imageProperties.Width * imageProperties.Height];

            SoftwareRendererSingleThreaded renderer = new SoftwareRendererSingleThreaded(imageProperties.Width, imageProperties.Height, pixels, (Microsoft.XboxLive.SoftwareRenderer.AntialiasingMode)imageProperties.Quality);
            return renderer;

        }

       /// <summary>
       /// Load up (parse) the avatar manifest and set the animation & frame that will be used to 
       /// render the image.
       /// </summary>
       /// <param name="avatar">Avatar data</param>
        private bool LoadAvatarData(AvatarPerspectiveData avatarData)
        {
            Debug.Assert(avatarManifest != null);

            //Attempt to use prop animation if requested
            if (avatarData.UsePropAnimation)
            {
                Microsoft.XboxLive.Avatars.Internal.Avatar avatar = this.assetLoader.CreateAvatar(avatarManifest);

                if (avatar != null && avatar.Carryable != null && avatar.Carryable.Animation != null)
                {
                    if (!avatarRenderer.SetAnimation(avatar.Carryable.Animation))
                    {
                        return false;
                    }
                }
                else
                {
                    Logging.TraceInformation("No carryable animation found in manifest for XUID {0}", avatarData.XUID);
                    return false;
                }

            } else
            {
                //Set the default animation if the guid is empty
                if (avatarData.AnimationId == Guid.Empty)
                {
                    avatarData.AnimationId = new Guid(0x00400000, 0x0003, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
                }

                //Load the animation
                if (!avatarRenderer.LoadAnimation(avatarData.AnimationId))
                {
                    return false;
                }
            }

            //Set the frame or position of the animation
            if (avatarData.Position > 0)
            {
                avatarRenderer.SetAnimationPose(avatarData.Position);
            }
            else
            {
                avatarRenderer.SetAnimationFrame(avatarData.Frame);
            }

            if (avatarData.Blobs > 0)
            {
                avatarRenderer.LoadBlobsFromResources("Microsoft.XboxLive.Avatars.Rendering.Resources.avatar_shadow.png");
            }

            return true ;
        }

#endregion

        static BodyType AvatarGenderToBodyType(AvatarGender avatarGender)
        {
            BodyType bodyType = BodyType.Unknown;

            switch (avatarGender)
            {
                case AvatarGender.Male:
                    bodyType = BodyType.Male;
                    break;
                case AvatarGender.Female:
                    bodyType = BodyType.Female;
                    break;
                case AvatarGender.Both:
                    bodyType = BodyType.Both;
                    break;
                default:
                    bodyType = BodyType.Unknown;
                    break;
            }

            return bodyType;
        }

        public void Dispose()
        {
            if (assetDataManager != null)
            {
                assetDataManager.Cleanup();
            }
        }
 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\RequestorService.cs ===
﻿using System;
using System.IO;
using System.Data;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Runtime.Serialization.Formatters.Binary;
using System.Configuration;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.IO;
using System.Diagnostics;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Messaging
{
    using CoreCC = Leet.Core.IoCCo;

    internal static class SSRDiag
    {
        internal static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public sealed class RequestorService
    {
        private RequestorService()
        {
        }

        public static RequestorService Instance { get { return instance; } }

        public void Initialize(string componentName)
        {
            if (!initialized)
            {
                lock (this)
                {
                    if (!initialized)
                    {
                        CoreCC.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
                        CoreCC.Container.Instance.AddService<ILogFormatter, LogFormatter>();
                        CoreCC.Container.Instance.AddService<ILogging, Logging>();
                        ConfigurationSelector.RegisterProvider(componentName, "LEET");
                        IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                        connectionString = configSettings.GetConnectionString(QueueDatabaseInterface);
                        initialized = true;

                        Logging.TraceInformation("Connection string retrieved: {0}", connectionString);
                    }
                }
            }
        }

        public void SendMessage(BaseMessage message)
        {
            if (!initialized)
            {
                throw new InvalidOperationException("RequestorService was not initialized");
            }

            MemoryStream memStream = new MemoryStream();
            BinaryFormatter bf = new BinaryFormatter();

            bf.Serialize(memStream, message);

            //Prepend message with the version
            byte[] bMessage = new byte[sizeof(int) + memStream.Length];
            for (int i = 0; i < sizeof(int); i++)
            {
                bMessage[i] = (byte)(message.Version >> i * 8);
            }

            //Serialize message object into message
            memStream.Position = 0;
            int bytesWritten = memStream.Read(bMessage, 4, (int)memStream.Length);

            using (SqlConnection sqlConnection = new SqlConnection(connectionString))
            {
                StringBuilder commandString = new StringBuilder();

                commandString.Append(sendString);
                commandString.Append(message.GetType().ToString());
                commandString.Append("] (@messageBody);");

                commandString.Append("END CONVERSATION @conversationHandle");

                SqlCommand sqlCommand = null;

                try
                {
                    sqlConnection.Open();
                    sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.Transaction = sqlConnection.BeginTransaction();

                    sqlCommand.Parameters.Add("@conversationHandle", SqlDbType.UniqueIdentifier);
                    sqlCommand.Parameters.Add("@messageBody", SqlDbType.VarBinary);
                    sqlCommand.Parameters.Add("@lifeTime", SqlDbType.Int);

                    sqlCommand.Parameters["@conversationHandle"].Direction = ParameterDirection.Output;
                    sqlCommand.Parameters["@messageBody"].Direction = ParameterDirection.Input;
                    sqlCommand.Parameters["@lifeTime"].Direction = ParameterDirection.Input;

                    sqlCommand.Parameters["@lifeTime"].Value = lifetime;
                    sqlCommand.Parameters["@messageBody"].Value = bMessage;

                    sqlCommand.CommandText = commandString.ToString();

                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.Transaction.Commit();
                }
                catch (SqlException)
                {
                    if (sqlCommand != null && sqlCommand.Transaction != null)
                    {
                        sqlCommand.Transaction.Rollback();
                    }

                    throw;
                }
            }
        }

        bool initialized = false;

        static readonly RequestorService instance = new RequestorService();
        static string connectionString;
        //The lifetime will only affect the ability to send on this conversation again
        //We only need to send 1 message per conversation since sequencing is not required
        static readonly int lifetime = 5;
        static readonly string sendString = 
            "BEGIN DIALOG CONVERSATION @conversationHandle" +
                                " FROM SERVICE [Avatar.Services.ServerSideRenderer.Messaging.RequestorService]" +
                                " TO SERVICE 'Avatar.Services.ServerSideRenderer.Messaging.RendererService'" +
                                " ON CONTRACT [Avatar.Services.ServerSideRenderer.Messaging.RequestContract]" +
                                " WITH LIFETIME = @lifeTime, " +
                                " ENCRYPTION = OFF;" +
                                "SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [";

        private const string QueueDatabaseInterface = "lest_SSRQueue_db";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\GenerateGamerPictureMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Messaging
{
    [Serializable]
    public class GenerateGamerPictureMessage : BaseMessage
    {
        public Guid AnimationId { get; set; }
        public bool UsePropAnimation { get; set; }
        /// <summary>
        /// Indicates if the new gamerpic should be set as the profile's public gamerpic.  Defaults to true. 
        /// </summary>
        public bool SaveGamerpicToProfile { get; set; }
        public float Frame { get; set; }
        public float FieldOfView { get; set; }
        public float OffsetX { get; set; }
        public float OffsetY { get; set; }
        public float OffsetZ { get; set; }
        public float RotationX { get; set; }
        public float RotationY { get; set; }
        public float RotationZ { get; set; }
        public byte BackgroundRed { get; set; }
        public byte BackgroundGreen { get; set; }
        public byte BackgroundBlue { get; set; }
        public byte BackgroundAlpha { get; set; }
        public Int32 BackgroundImageId { get; set; }
        public Int32 FocalJoint { get; set; }
        public GenerateGamerPictureMessage() { version = 1; SaveGamerpicToProfile = true; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ServerSideRenderer.Messaging")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("496438d7-1c5f-4c59-a233-3ef4d7998ca6")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\IMessageConsumer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Messaging
{
    public enum MessageProcessResult
    {
        Success,
        Failed,
        Retryable
    };

    //This is interface use by message consumers within the SSR service
    public interface IMessageConsumer<MessageType>
    {
        //True is returned if the message could not be
        //successfully processed and a retry is warrented
        MessageProcessResult ProcessMessage(MessageType message);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\AvatarPerspectiveData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.XboxLive.Avatars.Rendering;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class AvatarPerspectiveData
    {
        internal AvatarPerspectiveData()
        {
            pose = 0;
            frame = 0;
            blobs = 0;
            position = 0;
            UsePropAnimation = false;
        }

        /// <summary>
        /// Avatar gamer tag
        ///  </summary>
        public ulong XUID {get; set;}

        /// <summary>
        /// Avatar manifest
        /// </summary>
        public byte[] RawManifest { get; set; }

        /// <summary>
        /// Avatar animation guid
        ///  </summary>
        public Guid AnimationId {get; set;}

        /// <summary>
        /// If this is set to true, the AnimationId property will be ignored
        /// </summary>
        public bool UsePropAnimation { get; set; }

        /// <summary>
        /// Relative position in avatar animation, value of 0 means position at the beginning, value of 1
        /// means position at the end
        ///  </summary>
        public float Position 
        {
            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }

        /// <summary>
        /// Frame of avatar animation, this value is valid only when Position is zero, otherwise is ignored
        /// </summary>
        public int Frame 
        {
            get
            {
                return frame;
            }
            set
            {
                frame = value;
            }
        }

        /// <summary>
        /// Predefined avatar pose.  Defaults to AvatarPose.BodyFixed.
        /// </summary>
        public AvatarPose Pose
        {
            get
            {
                return pose;
            }
            set
            {
                pose = value;
            }
        }

        /// <summary>
        /// Render blobs if value is greater then zero
        /// //render blobs if value > 1
        /// </summary>
        public int Blobs
        {
            get
            {
                return blobs;
            }
            set
            {
                blobs = value;
            }
        }

        public PoseDictionary PoseSet
        {
            get
            {
                return poseDictionary;
            }
            set
            {
                poseDictionary = value;
            }
        }

        public bool UseRandomPose { get; set; }
        public int UseThisPose { get; set; }

        private PoseDictionary poseDictionary;
        private int blobs;
        private float position;
        private int frame;
        private AvatarPose pose;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\DiagnosticData.cs ===
﻿using System;
using System.Diagnostics;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Service
{
    internal static class SSRDiag
    {
        /// <summary>
        /// Event handler for the Microsoft.XboxLive.Avatars logger to hook in to.  Will write trace
        /// events to the trace event log.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        internal static void AvatarApiLogger_LogReceived(object sender, Microsoft.XboxLive.Avatars.Internal.LogEventArgs e)
        {
          Logging.TraceError(
                "Microsoft.XboxLive.Avatars event.  Sender: {0} *** TimeStamp: {1} *** Message: {2}",
                e.Result.Sender,
                e.Result.TimeStamp,
                e.Result.Message);
        }
    }

    public class UnrecognizedMessageFormat : BaseEvent
    {
        public UnrecognizedMessageFormat()
            : base(100, TraceEventType.Warning, "The message body data format is incorrect.")
        {
        }
    }

    public class UnrecognizedMessageVersion : BaseEvent
    {
        public UnrecognizedMessageVersion()
            : base(101, TraceEventType.Warning, "The message version is not recognized.")
        {
        }
    }

    public class MessageNotProcessed : BaseEvent
    {
        public MessageNotProcessed()
            : base(102, TraceEventType.Warning, "The message failed to be properly processed.")
        {
        }
    }

    public class MessageProcessorStarted : BaseEvent
    {
        public MessageProcessorStarted()
            : base(103, TraceEventType.Start, "Render service message processing started")
        {
        }
    }

    public class MessageProcessorStopped : BaseEvent
    {
        public MessageProcessorStopped()
            : base(104, TraceEventType.Stop, "Render service message processing stopped")
        {
        }
    }

    public class ServiceBrokerErrorMessage : BaseEvent
    {
        public ServiceBrokerErrorMessage()
            : base(105, TraceEventType.Error, "Received an error message on the broker queue")
        {
        }
    }

    public class ImageGenerationFailed : BaseEvent
    {
        public ImageGenerationFailed()
            : base(106, TraceEventType.Warning, "The renderer failed to generate an image")
        {
        }
    }
    public class InvalidMessageData : BaseEvent
    {
        public InvalidMessageData()
            : base(107, TraceEventType.Warning, "The message body data is invalid and cannot be processed.")
        {
        }
    }

    public class ReceiverConstructionFailure : BaseEvent
    {
        public ReceiverConstructionFailure()
            : base(108, TraceEventType.Error, "A critical error is preventing construction of the message receiver.")
        {
        }
    }

    public class GamerProfileRetrievalFailure : BaseEvent
    {
        public GamerProfileRetrievalFailure()
            : base(109, TraceEventType.Warning, "Failed to retrieve gamer profile")
        {
        }
    }

    public class ManifestNotFound : BaseEvent
    {
        public ManifestNotFound()
            : base(110, TraceEventType.Warning, "Unable to find the a manifest for the user specified in the request")
        {
        }
    }

    public class MessageReceiveFailure : BaseEvent
    {
        public MessageReceiveFailure()
            : base(111, TraceEventType.Warning, "An exception occurred while waiting to receive a message")
        {
        }
    }

    public class RandomPoseConfigurationLoaded : BaseEvent
    {
        public RandomPoseConfigurationLoaded()
            : base(112, TraceEventType.Start, "Render service random pose configuration loaded")
        {
        }
    }

    public class InvalidPoseConfiguration : BaseEvent
    {
        public InvalidPoseConfiguration()
            : base(113, TraceEventType.Error, "Unable to load avatar poses configuration, default pose is being used")
        {
        }
    }

    public class EndReceiveFailure : BaseEvent
    {
        public EndReceiveFailure()
            : base(114, TraceEventType.Warning, "An exception occurred while completing a  message received processing")
        {
        }
    }

    public class StartupFailure : BaseEvent
    {
        public StartupFailure()
            : base(115, TraceEventType.Error, "An exception occurred while starting the service")
        {
        }
    }

    public class GamerpicProfileUpdateFailure : BaseEvent
    {
        public GamerpicProfileUpdateFailure()
            : base(116, TraceEventType.Warning, "Failed to update a user's profile with the new gamerpic")
        {
        }
    }

    public class ImageStorageFailed : BaseEvent
    {
        public ImageStorageFailed()
            : base(117, TraceEventType.Warning, "Failed to store the body shot")
        {
        }
    }

    public class AssetRetrievalFailed : BaseEvent
    {
        public AssetRetrievalFailed()
            : base(118, TraceEventType.Warning, "Failed to load avatar assets")
        {
        }
    }

    public class BackgroundImagesInvalidLoaction : BaseEvent
    {
        public BackgroundImagesInvalidLoaction()
            :base(119, TraceEventType.Warning)
        { }

        public BackgroundImagesInvalidLoaction(string searchLocation)
            : base(119, TraceEventType.Warning, String.Format("Invalid Images location. Location not found: {0}", searchLocation))
        {
        }
    }

    public class BackgroundImageLoadFailure : BaseEvent
    {
        public BackgroundImageLoadFailure()
            : base(121, TraceEventType.Error)
        { }

        public BackgroundImageLoadFailure(string backgroundImageFile)
            : base(122, TraceEventType.Error, String.Format("Failed to load background image file {0} ", backgroundImageFile))
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\BodyShotMessageProcessor.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Wgx.Services.Monitoring;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class BodyShotMessageProcessor : StaticImageGenerator, IMessageConsumer<GenerateBodyShotMessage>
    {
        public BodyShotMessageProcessor(PoseDictionary poseDictionary)
        {
            perfCounters = PerformanceCounters.GetPerformanceCounters(typeof(SSRPerfCounters));

            Debug.Assert(poseDictionary != null);

            randomPoseDictionary = poseDictionary;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message">The message to process</param>
        /// <returns>
        ///     False if the message was not successfully processed and
        ///     a retry is reasonable.
        /// </returns>
        public MessageProcessResult ProcessMessage(GenerateBodyShotMessage message)
        {
            MessageProcessResult processResult = MessageProcessResult.Failed;

            try
            {
                perfCounters.SafeIncrement(SSRPerfCounters.CurrentNumberBodyShotMessages);

                ImageProperties imageProperties = new ImageProperties();
                AvatarPerspectiveData avatarData = new AvatarPerspectiveData();
                BackgroundColor backgroundColor = new BackgroundColor(255, 255, 255);
                MemoryStream memoryStream;

                string imageType = "png";

                long elapsedTime = Stopwatch.GetTimestamp();

                avatarData.XUID = message.XUID;
                avatarData.RawManifest = message.AvatarManifest;
                avatarData.UseRandomPose = message.PickRandomPose;
                avatarData.UseThisPose = message.PoseIndex;
                avatarData.PoseSet = randomPoseDictionary;

                imageProperties.Width = m_imageWidth;
                imageProperties.Height = m_imageHeight;
                imageProperties.Quality = Antialiasing.Quincunx;

                imageProperties.Color = backgroundColor;

                memoryStream = StaticImageGenerator.GenerateImage(imageProperties, avatarData, imageType, false);

                if (memoryStream != null)
                {
                    if (StoreBodyShot(message, memoryStream))
                    {
                        processResult = MessageProcessResult.Success;

                        //Diagnostic messages go both to XBLS storage and to disk. Diagnostic tools will infer that
                        //StorageWrite worked if we get an updated image on disk
                        if (IsDiagnosticMessage(message))
                        {
                            WriteImageForDiagnostics(memoryStream.ToArray(), "avatar-body.png");
                        }

                        //We are only timing successful image generations
                        elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;
                        perfCounters.SafeIncrementBy(SSRPerfCounters.BodyShotDuration, elapsedTime);
                        perfCounters.SafeIncrement(SSRPerfCounters.BodyShotDurationBase);

                        //Successful body shot process rate
                        perfCounters.SafeIncrement(SSRPerfCounters.BodyShotProcessRate);

                        perfCounters.SafeIncrement(SSRPerfCounters.TotalBodyShotMessagesProcessed);
                    }
                }
                else
                {
                    //Failed body shot process rate
                    perfCounters.SafeIncrement(SSRPerfCounters.FailedBodyShotProcessRate);

                    perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedBodyShotMessages);

                    Logging.WriteEvent(new ImageGenerationFailed(), "GenerateBodyShotMessage for {0}", message.XUID);
                }
            }
            finally
            {
                perfCounters.SafeDecrement(SSRPerfCounters.CurrentNumberBodyShotMessages);
            }

            return processResult;
        }

        private bool StoreBodyShot(GenerateBodyShotMessage message, MemoryStream memoryStream)
        {
            bool result = true;

            long elapsedTime = Stopwatch.GetTimestamp();

            IAvatarStorageAccess pictureDataAccess = Container.Instance.GetComponent<IAvatarStorageAccess>();

            try
            {
                pictureDataAccess.StorageWrite(message.XUID, "avatar-body.png", memoryStream.ToArray());
                elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;

                perfCounters.SafeIncrementBy(SSRPerfCounters.BodyShotStoreDuration, elapsedTime);
                perfCounters.SafeIncrement(SSRPerfCounters.BodyShotStoreDurationBase);
            }
            catch (Exception ex)
            {
                Logging.WriteEvent(new ImageStorageFailed(), ex, "user XUID: {0}", message.XUID);
                result = false;
            }

            return result;
        }

        private void WriteImageForDiagnostics(Byte[] image, String fileName)
        {
            string filePath = String.Empty;

            Debug.Assert(!String.IsNullOrEmpty(fileName), "fileName");

            try
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                filePath = configSettings.GetSetting(Settings.AvatarSSRDiagnosticImageWriteUri);

                if (String.IsNullOrEmpty(filePath))
                {
                    //we will just return and not write anything
                    Logging.TraceVerbose("Did not write body shot image to the disk because filePath was empty");
                    return;
                }

                filePath = Path.Combine(Path.Combine(filePath, configSettings.Environment), fileName);
                FileStream fs = File.Create(filePath);
                fs.Write(image, 0, image.Length);
                fs.Flush();
                fs.Close();

                Logging.TraceVerbose("Wrote diagnostic body shot image to disk at {0}", filePath);
            }
            catch (Exception ex)
            {
                Logging.TraceVerbose("Failed to write body shot image to disk at {0}. \n Exception: {1}", filePath, ex.ToString());
            }
        }

        private int m_imageWidth = 150;
        private int m_imageHeight = 300;
        PerformanceCounterCollection perfCounters;
        PoseDictionary randomPoseDictionary;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\ImageGeneratorBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using Leet.Core.IoCCo;
using Avatar.Services.ServerSideRenderer.Messaging;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class ImageGeneratorBase
    {
        protected bool IsDiagnosticMessage(BaseMessage message)
        {
            return (0X80000000 & message.Version) == 0X80000000;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\GamerPictureMessageProcessor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.XboxLive.Avatars.ServerSideRendering;
using Microsoft.XboxLive.Avatars;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;
using System.Windows.Media.Imaging;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Live.Livecache.DataAccess;
using Leet.Core.IoCCo;
using Wgx.Services.Monitoring;
using System.Diagnostics;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class GamerPictureMessageProcessor : StaticImageGenerator, IMessageConsumer<GenerateGamerPictureMessage>
    {
        public GamerPictureMessageProcessor()
        {
            perfCounters = PerformanceCounters.GetPerformanceCounters(typeof(SSRPerfCounters));
        }

        public MessageProcessResult ProcessMessage(GenerateGamerPictureMessage message)
        {
            MessageProcessResult returnResult = MessageProcessResult.Failed;
            bool bResult;

            try
            {
                perfCounters.SafeIncrement(SSRPerfCounters.CurrentNumberGamerPictureMessages);

                AvatarPerspectiveData avatarData = new AvatarPerspectiveData();
                BackgroundColor backgroundColor = new BackgroundColor();
                CameraData cameraData = new CameraData();

                string imageType = "png";

                long elapsedTime = Stopwatch.GetTimestamp();
                avatarData.Position = message.Frame;
                avatarData.XUID = message.XUID;
                avatarData.RawManifest = message.AvatarManifest;

                if (message.AnimationId != Guid.Empty && !message.UsePropAnimation)
                {
                    avatarData.AnimationId = message.AnimationId;
                }
                else if (message.UsePropAnimation)
                {
                    avatarData.UsePropAnimation = true;
                }

                cameraData.FocalJoint = message.FocalJoint;
                cameraData.FieldOfView = message.FieldOfView;

                cameraData.Offset.X = message.OffsetX;
                cameraData.Offset.Y = message.OffsetY;
                cameraData.Offset.Z = message.OffsetZ;

                cameraData.Rotation.X = message.RotationX;
                cameraData.Rotation.Y = message.RotationY;
                cameraData.Rotation.Z = message.RotationZ;

                backgroundColor.Red = message.BackgroundRed;
                backgroundColor.Green = message.BackgroundGreen;
                backgroundColor.Blue = message.BackgroundBlue;
                backgroundColor.Alfa = message.BackgroundAlpha;

                writeCount = 0;

                bResult = GenerateSmallPicture(message, avatarData, backgroundColor, cameraData, imageType);

                if (bResult)
                {
                    bResult = GenerateLargePicture(message, avatarData, backgroundColor, cameraData, imageType);
                }

                if (bResult && message.SaveGamerpicToProfile)
                {
                    bResult = UpdateUserProfileGamerpicSetting(message);
                }

                if (bResult)
                {
                    returnResult = MessageProcessResult.Success;

                    elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;
                    perfCounters.SafeIncrementBy(SSRPerfCounters.GamerPicDuration, elapsedTime);
                    perfCounters.SafeIncrement(SSRPerfCounters.GamerPicDurationBase);

                    perfCounters.SafeIncrement(SSRPerfCounters.GamerPictureProcessRate);
                    perfCounters.SafeIncrement(SSRPerfCounters.TotalGamerPictureMessagesProcessed);
                }
                else
                {
                    returnResult = MessageProcessResult.Failed;

                    perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedGamerPictureMessages);
                    perfCounters.SafeIncrement(SSRPerfCounters.FailedGamerPictureProcessRate);
                }

                //Measure the elapsed time of all storage writes if 1 or more has occurred
                //The total aggregate write time is used which is why the counter is incremented by 1
                if (writeCount > 0)
                {
                    perfCounters.SafeIncrementBy(SSRPerfCounters.GamerPictureStoreDurationBase, 1);
                }
            }
            finally
            {
                perfCounters.SafeDecrement(SSRPerfCounters.CurrentNumberGamerPictureMessages);
            }

            return returnResult;
        }

        private bool GenerateSmallPicture(
            GenerateGamerPictureMessage message, 
            AvatarPerspectiveData avatarData,
            BackgroundColor backgroundColor, 
            CameraData cameraData, 
            string imageType)
        {
            bool returnResult = false;
            MemoryStream memoryStream;

            string backgroundImageFileName = SmallBackgroundImagesCache.GetFileNameFromKey(message.BackgroundImageId);
            Int32[] backgroundImage = GetBackgroundImage(SmallBackgroundImagesCache.GetBackgroundImagesCache(), backgroundImageFileName);

            ImageProperties imageProperties = new ImageProperties();
            imageProperties.Width = 32;
            imageProperties.Height = 32;
            imageProperties.Quality = Antialiasing.S2X2Y;
            imageProperties.Color = backgroundColor;
            imageProperties.BackgroundImage = backgroundImage;

            memoryStream = StaticImageGenerator.GenerateImage(imageProperties, avatarData, imageType, cameraData, true);

            if (memoryStream != null)
            {
                long elapsedTime = Stopwatch.GetTimestamp();

                IAvatarStorageAccess pictureDataAccess = Container.Instance.GetComponent<IAvatarStorageAccess>();

                try
                {
                    pictureDataAccess.StorageWrite(message.XUID, "avatarpic-s.png", memoryStream.ToArray());
                    returnResult = true;
                }
                catch (Exception ex)
                {
                    Logging.WriteEvent(new ImageStorageFailed(), ex, "user XUID: {0}", message.XUID);
                }

                elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;
                writeCount++;
                perfCounters.SafeIncrementBy(SSRPerfCounters.GamerPictureStoreDuration, elapsedTime);


                //Diagnostic messages go both to XBLS storage and to disk. Diagnostic tools will infer that
                //StorageWrite worked if we get an updated image on disk
                if (IsDiagnosticMessage(message))
                {
                    WriteImageForDiagnostics(memoryStream.ToArray(), "avatarpic-s.png");
                }
            }
            else
            {
                Logging.WriteEvent(new ImageGenerationFailed(), "GenerateSmallGamerPicture for {0}", avatarData.XUID);
            }

            return returnResult;
        }

        private bool GenerateLargePicture(GenerateGamerPictureMessage message, AvatarPerspectiveData avatarData, BackgroundColor backgroundColor, CameraData cameraData, string imageType)
        {
            bool returnResult = false;
            ImageProperties imageProperties = new ImageProperties();
            MemoryStream memoryStream;

            string backgroundImageFileName = LargeBackgroundImagesCache.GetFileNameFromKey(message.BackgroundImageId);
            Int32[] backgroundImage = GetBackgroundImage(LargeBackgroundImagesCache.GetBackgroundImagesCache(), backgroundImageFileName);

            imageProperties.Width = 64;
            imageProperties.Height = 64;
            imageProperties.Quality = Antialiasing.S2X2Y;
            imageProperties.Color = backgroundColor;
            imageProperties.BackgroundImage = backgroundImage;

            memoryStream = StaticImageGenerator.GenerateImage(imageProperties, avatarData, imageType, cameraData, true);

            if (memoryStream != null)
            {
                long elapsedTime = Stopwatch.GetTimestamp();

                IAvatarStorageAccess pictureDataAccess = Container.Instance.GetComponent<IAvatarStorageAccess>();

                try
                {
                    pictureDataAccess.StorageWrite(message.XUID, "avatarpic-l.png", memoryStream.ToArray());
                    returnResult = true;
                }
                catch (Exception ex)
                {
                    Logging.WriteEvent(new ImageStorageFailed(), ex, "user XUID: {0}", message.XUID);
                }

                writeCount++;
                elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;
                perfCounters.SafeIncrementBy(SSRPerfCounters.GamerPictureStoreDuration, elapsedTime);

                //Diagnostic messages go both to XBLS storage and to disk. Diagnostic tools will infer that
                //StorageWrite worked if we get an updated image on disk
                if (IsDiagnosticMessage(message))
                {
                    WriteImageForDiagnostics(memoryStream.ToArray(), "avatarpic-l.png");
                }
            }
            else
            {
                Logging.WriteEvent(new ImageGenerationFailed(), "GenerateLargeGamerPictgure for {0}", avatarData.XUID);
            }

            return returnResult;
        }

        /// <summary>
        /// Retrieves a gamerpic background image as an Int32[]
        /// </summary>
        /// <param name="imageCache">Dictionary containing the image array</param>
        /// <param name="imageFileName">File name</param>
        /// <returns></returns>
        private Int32[] GetBackgroundImage(IDictionary<String, Int32[]> imageCache, string imageFileName)
        {
            Int32[] imageArray = null;

            if (imageCache == null || !imageCache.TryGetValue(imageFileName, out imageArray))
            {
                Logging.WriteEvent(new BackgroundImageLoadFailure(imageFileName));
                throw new Exception("Failed to load background image");
            }
            else
            {
                return imageArray;
            }
        }

        private void WriteImageForDiagnostics(Byte[] image, String fileName)
        {
            string filePath = String.Empty;

            Debug.Assert(!String.IsNullOrEmpty(fileName) ,"fileName");

            try
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                filePath = configSettings.GetSetting(Settings.AvatarSSRDiagnosticImageWriteUri);

                if (String.IsNullOrEmpty(filePath))
                {
                    //we will just return and not write anything
                    Logging.TraceVerbose("Did not write gamer picture to the disk because filePath was empty");
                    return;
                }

                filePath = Path.Combine(Path.Combine(filePath, configSettings.Environment), fileName);
                FileStream fs = File.Create(filePath);
                fs.Write(image, 0, image.Length);
                fs.Flush();
                fs.Close();

                Logging.TraceVerbose("Wrote diagnostic gamer picture to disk at {0}", filePath);
            }
            catch(Exception ex)
            {
                Logging.TraceException(ex, "Failed to write gamer picture to disk at {0}", filePath);
            }
        }

        private static bool UpdateUserProfileGamerpicSetting(GenerateGamerPictureMessage message)
        {
            const string AVATAR_TITLE_ID = "fffe0854";

            // Create the setting value as a string
            Random rand = new Random(DateTime.Now.Millisecond);
            string random1 = rand.Next(9999).ToString("X4");
            string random2 = rand.Next(9999).ToString("X4");

            string stringSetting = String.Format("{0}0001{1}0001{2}\0", AVATAR_TITLE_ID, random1, random2);

            // Now encode the string into a unicode byte array before sync'ing it up to the profile
            Encoding unicode = Encoding.Unicode;
            byte[] settingByteValue = new byte[unicode.GetByteCount(stringSetting)];
            unicode.GetBytes(stringSetting, 0, stringSetting.Length, settingByteValue, 0);

            ProfileSetting gamerpicSetting = new ProfileSetting()
            {
                UserId = message.XUID,
                SettingId = (uint)StatsProfileSettings.GamercardTile,
                Value = settingByteValue,
                ValueLen = (ushort)settingByteValue.Length,
                Source = LivecacheConstants.XSOURCE_DEFAULT,
            };

            // TODO :::::::::::::::::::::::::::::::
            // Investigate if we should be putting the platform type in the message definitions so the 
            // Livecache API call can be "charged" against the right client ID.  Using 
            // LIVEnServiceMobileExtendedAuthDataProvider all requests will go against the WM7 client ID.

            LIVEnServiceMobileExtendedAuthDataProvider.Puid = message.XUID;
            ISettingsDataAccess settingsDA = Container.Instance.GetComponent<ISettingsDataAccess>();

            bool wasSuccessful = true;
            try
            {
                // Response object will not contain useful diagnostic info, only the collection of settings that 
                // have changed since the last time SyncSettings was called
                SaveSettingsResponse syncResponse = settingsDA.SyncSettings(message.XUID, new ProfileSetting[] { gamerpicSetting });
            }
            catch (LeetLivecacheResponseException ex)
            {
                Logging.WriteEvent(new GamerpicProfileUpdateFailure(), ex);
                wasSuccessful = false;
            }
            catch (Exception ex)
            {
                Logging.WriteEvent(new GamerpicProfileUpdateFailure(), ex);
                wasSuccessful = false;
            }

            return wasSuccessful;
        }

        int writeCount = 0;
        PerformanceCounterCollection perfCounters;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\ImageEncoding.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Service
{
    /// <summary>
    /// Supported image encoding
    ///  </summary>
    internal static class ImageEncoding
    {
        /// <summary>
        /// png format
        ///  </summary>
        internal const string Png = "PNG";

        /// <summary>
        /// jpeg format
        ///  </summary>
        internal const string Jpeg = "JPEG";
        internal const string Jpg = "JPG";

        /// <summary>
        /// tif format
        ///  </summary>
        internal const string Tif = "TIF";
        internal const string Tiff = "TIFF";

        /// <summary>
        /// bmp format
        ///  </summary>
        internal const string Bmp = "BMP";

        /// <summary>
        /// gif format
        ///  </summary>
        internal const string Gif = "GIF";

        /// <summary>
        /// animated format
        ///  </summary>
        internal const string AnimatedGif = "AGIF";

        /// <summary>
        /// raw format - pixel value is stored as int (RGBA value)
        ///  </summary>
        internal const string Raw = "RAW";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\main.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.ServiceProcess;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Service
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        static void Main(string[] args)
        {
            if (args.Length > 0 && string.Compare(args[0], "-debug") == 0)
            {
                string[] argArr = new string[args.Length - 1];

                if (args.Length - 1 > 0)
                {
                    Array.Copy(args, 1, argArr, 0, args.Length - 1);
                }

                RenderService renderService = new RenderService();
                renderService.Run(argArr);
            }
            else
            {
                ServiceBase[] ServicesToRun;

                ServicesToRun = new ServiceBase[] 
                { 
                    new RenderService() 
                };

                ServiceBase.Run(ServicesToRun);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\BackgroundImagesCache.cs ===
﻿using System;
using System.Drawing;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Service
{
    public sealed class LargeBackgroundImagesCache : BackgroundImagesCache
    {
        private static IDictionary<String, Int32[]> imageCache = new LargeBackgroundImagesCache() as IDictionary<String, Int32[]>;

        LargeBackgroundImagesCache()
        {
            base.LoadImages();
        }

        public static IDictionary<String, Int32[]> GetBackgroundImagesCache()
        {
            return imageCache;
        }
    }

    public sealed class SmallBackgroundImagesCache : BackgroundImagesCache
    {
        private static IDictionary<String, Int32[]> imageCache = new SmallBackgroundImagesCache() as IDictionary<String, Int32[]>;

        SmallBackgroundImagesCache()
        {
            base.LoadImages();
        }

        public static IDictionary<String, Int32[]> GetBackgroundImagesCache()
        {
            return imageCache;
        }

        /// <summary>
        /// Returns an image file as an array of ints representing the ARGB value of each pixel.
        /// This implementation will scale the image down to a 32x32 size.
        /// </summary>
        /// <param name="fullFilePath">File path</param>
        /// <returns>int[]</returns>
        protected override int[] GetImageBufferAsPixels(string fullFilePath)
        {
            using (FileStream fs = File.OpenRead(fullFilePath))
            {
                //Bitmap objects have to be disposed after use otherwise the image file will be locked.
                using (Bitmap bm = Image.FromStream(fs) as Bitmap)
                {
                    // Scale the image down to 32x32 rather than the original 64x64 size
                    Bitmap smallBM = ResizeBitmap(bm, 32, 32);

                    Int32 width = smallBM.Width;
                    Int32 height = smallBM.Height;
                    Int32[] pixelArray = new Int32[width * height];

                    for (Int32 y = 0; y < height; y++)
                    {
                        for (Int32 x = 0; x < width; x++)
                        {
                            pixelArray[y * width + x] = smallBM.GetPixel(x, y).ToArgb();
                        }
                    }

                    return pixelArray;
                }
            }
        }

        /// <summary>
        /// Scales a bitmap object down to the specified dimentions
        /// </summary>
        /// <param name="b"></param>
        /// <param name="nWidth"></param>
        /// <param name="nHeight"></param>
        /// <returns></returns>
        private Bitmap ResizeBitmap(Bitmap b, int width, int height)
        {
            Bitmap result = new Bitmap(width, height);
            using (Graphics g = Graphics.FromImage((Image)result))
            {
                g.DrawImage(b, 0, 0, width, height);
            }
            return result;
        }
    }



    /// <summary>
    /// Note:  This is a base class and should not be instantiated on its own.
    /// 
    /// Readonly collection cache of background images used for gamerpic rendering
    /// </summary>
    public class BackgroundImagesCache : IDictionary<String, Int32[]>
    {
        private const String BackgroundImageFileFormat = "gamerpic_background_{0}.png";
        private Dictionary<String, Int32[]> backingDictionary = new Dictionary<String, Int32[]>();

        public static String GetFileNameFromKey(Int32 key)
        {
            return String.Format(BackgroundImageFileFormat, key.ToString());
        }

        protected void LoadImages()
        {
            IConfigurationProvider configSettings = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();
            String configurationPath = configSettings.GetSetting(Settings.AvatarBackgroundImagesLocationUri);

            if (String.IsNullOrEmpty(configurationPath) || !Directory.Exists(configurationPath))
            {
                Logging.WriteEvent(new BackgroundImagesInvalidLoaction(configurationPath));
                return;
            }
            
            String[] bfiles = null;

            try
            {
                bfiles = Directory.GetFiles(configurationPath, String.Format(BackgroundImageFileFormat, "*"), SearchOption.TopDirectoryOnly);
            }
            catch (Exception ex)
            {
                Logging.WriteEvent(new BackgroundImageLoadFailure(configurationPath), ex);
                return;
            }

            foreach (String bfile in bfiles)
            {
                try
                {
                    this.backingDictionary.Add(Path.GetFileName(bfile), GetImageBufferAsPixels(Path.GetFullPath(bfile)));
                }
                catch (Exception ex)
                {
                    Logging.WriteEvent(new BackgroundImageLoadFailure(bfile), ex);
                }
            }
        }

        protected virtual Int32[] GetImageBufferAsPixels(String fullFilePath)
        {
            using(FileStream fs = File.OpenRead(fullFilePath))
            {
                //Bitmap objects have to be disposed after use otherwise the image file will be locked.
                using (Bitmap bm = Image.FromStream(fs) as Bitmap)
                {
                    Int32 width = bm.Width;
                    Int32 height = bm.Height;
                    Int32[] pixelArray = new Int32[width * height];

                    for (Int32 y = 0; y < height; y++)
                    {
                        for (Int32 x = 0; x < width; x++)
                        {
                            pixelArray[y * width + x] = bm.GetPixel(x, y).ToArgb();
                        }
                    }

                    return pixelArray;
                }
            }
        }

        #region ICollection<KeyValuePair<string,Int32[]>> Members

        public void Add(String key, Int32[] value)
        {
            throw new InvalidOperationException();
        }

        public bool ContainsKey(String key)
        {
            return backingDictionary.ContainsKey(key);
        }

        public ICollection<String> Keys
        {
            get { return backingDictionary.Keys; }
        }

        public bool Remove(String key)
        {
            throw new InvalidOperationException();
        }

        public bool TryGetValue(String key, out Int32[] value)
        {
            return backingDictionary.TryGetValue(key, out value);
        }

        public ICollection<Int32[]> Values
        {
            get { return backingDictionary.Values; }
        }

        public Int32[] this[String key]
        {
            get { return backingDictionary[key]; }
            set { throw new InvalidOperationException(); }
        }

        public void Add(KeyValuePair<String, Int32[]> item)
        {
            throw new InvalidOperationException();
        }

        public void Clear()
        {
            throw new InvalidOperationException();
        }

        public bool Contains(String key)
        {
            return backingDictionary.ContainsKey(key);
        }

        public int Count
        {
            get { return backingDictionary.Count; }
        }

        public bool IsReadOnly
        {
            get { return true; }
        }

        public bool Remove(KeyValuePair<String, Int32[]> item)
        {
            throw new InvalidOperationException();
        }

        public IEnumerator<KeyValuePair<String, Int32[]>> GetEnumerator()
        {
            return backingDictionary.GetEnumerator();
        }

        public bool Contains(KeyValuePair<string, Int32[]> item)
        {
            return ((IDictionary<String, Int32[]>)this.backingDictionary).Contains(item);
        }

        public void CopyTo(KeyValuePair<string, Int32[]>[] array, int arrayIndex)
        {
            ((IDictionary<String, Int32[]>)this.backingDictionary).CopyTo(array, arrayIndex);
        }

           System.Collections.IEnumerator
               System.Collections.IEnumerable.GetEnumerator()
        {
            return ((System.Collections.IEnumerable)backingDictionary).GetEnumerator();
        }

        #endregion

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\ProjectInstaller.Designer.cs ===
﻿namespace Avatar.Services.ServerSideRenderer.Service
{
    partial class ProjectInstaller
    {
        private const string componentName = "avatarsvcs_serversiderenderer";

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.serverRendererProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
            this.renderServiceInstaller = new System.ServiceProcess.ServiceInstaller();
            // 
            // serverRendererProcessInstaller1
            // 
            this.serverRendererProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.NetworkService;
            this.serverRendererProcessInstaller1.Password = null;
            this.serverRendererProcessInstaller1.Username = null;
            // 
            // renderServiceInstaller
            // 
            this.renderServiceInstaller.ServiceName = componentName;
            this.renderServiceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            // 
            // ProjectInstaller
            //
            this.Installers.AddRange(new System.Configuration.Install.Installer[] {
            this.serverRendererProcessInstaller1,
            this.renderServiceInstaller});

        }

        #endregion

        private System.ServiceProcess.ServiceProcessInstaller serverRendererProcessInstaller1;
        private System.ServiceProcess.ServiceInstaller renderServiceInstaller;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\ProjectInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Linq;


namespace Avatar.Services.ServerSideRenderer.Service
{
    [RunInstaller(true)]
    public partial class ProjectInstaller : Installer
    {
        public ProjectInstaller()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\RandomPose.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;

namespace Avatar.Services.ServerSideRenderer.Service
{
    using Avatar.Services.ServerSideRenderer.Common;

    internal class PoseDictionary
    {
        BodyShotPose defaultPose = null;
        BodyShotPose[] malePoses;
        BodyShotPose[] femalePoses;
        bool usingDefaultPose = true;

        internal PoseDictionary()
        {
            defaultPose = new BodyShotPose();

            //Animation = Generic Stand 0
            defaultPose.Animation = new Guid(0x00400000, 0x0003, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
            defaultPose.BodyType = BodyType.Both;
            defaultPose.FieldOfView = -0.011f;
            defaultPose.Frame = 0;
            defaultPose.OffsetX = defaultPose.OffsetZ = 0;
            defaultPose.OffsetY = -0.14f;
            defaultPose.RotationX = defaultPose.RotationY = defaultPose.RotationZ = 0;
        }

        internal BodyShotPose DefaultPose
        {
            get
            {
                return defaultPose;
            }
        }

        private XDocument GetPosesFromConfiguration(string configurationPath)
        {
            string xmlFileName = configurationPath + @"\AvatarPoses.xml";
            string xsdFileName = configurationPath + @"\AvatarPoses.xsd";

            FileStream fileStream = null;
            XmlSchemaSet schemaSet = null;
            XDocument poses = null;

            if (!File.Exists(xmlFileName))
            {
                throw new ArgumentException("Unable to find {0}", xmlFileName);
            }

            //Load the random pose schema
            try
            {
                using (fileStream = new FileStream(xsdFileName, FileMode.Open, FileAccess.Read))
                {
                    schemaSet = new XmlSchemaSet();
                    XmlSchema schema = XmlSchema.Read(fileStream, null);
                    schemaSet.Add(schema);

                    //Load and validate the random pose configuration
                    poses = XDocument.Load(xmlFileName);
                    poses.Validate(schemaSet, null);
                }
            }
            catch (FileNotFoundException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }
            catch (DirectoryNotFoundException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }
            catch (PathTooLongException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }
            catch (XmlSchemaException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }
            catch (ArgumentNullException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }
            catch (System.UnauthorizedAccessException ex)
            {
                throw new ArgumentException("Configuration unavailable", ex);
            }

            return poses;
        }

        internal void LoadPoses(string configurationPath)
        {
            if (string.IsNullOrEmpty(configurationPath))
            {
                throw new ArgumentException("configurationPath value is invalid");
            }

            List<BodyShotPose> malePosesList = new List<BodyShotPose>();
            List<BodyShotPose> femalePosesList = new List<BodyShotPose>();
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(BodyShotPose));

            //Load and validate the random pose configuration
            XDocument poses = GetPosesFromConfiguration(configurationPath);

            //Get the poses
            XElement avatarPoses = poses.Element("AvatarPoses");
            IEnumerable<XElement> childElements =
                from el in avatarPoses.Elements(typeof(BodyShotPose).Name)
                select el;

            //Load the dictionary
            foreach (XElement poseElement in childElements)
            {
                BodyShotPose avPose = null;
                try
                {
                    avPose = (BodyShotPose)xmlSerializer.Deserialize(poseElement.CreateReader());
                } catch(InvalidOperationException ex)
                {
                    throw new ArgumentException("Failed to load poses", ex);
                }

                AvatarGender animationGender = AssetLoader.GetAssetBodyType(avPose.Animation);

                //Verify that animation matches bodytype

                switch(avPose.BodyType)
                {
                    case BodyType.Male:
                        {
                            if (animationGender == AvatarGender.Female || animationGender == AvatarGender.Unknown)
                            {
                                throw new ArgumentException(string.Format("Animation gender {0} not consistent with avatar gender {1}", animationGender, avPose.BodyType));
                            }

                            malePosesList.Add(avPose);
                        }
                        break;

                    case BodyType.Female:
                        {
                            if (animationGender == AvatarGender.Male || animationGender == AvatarGender.Unknown)
                            {
                                throw new ArgumentException(string.Format("Animation gender {0} not consistent with avatar gender {1}", animationGender, avPose.BodyType));
                            }

                            femalePosesList.Add(avPose);
                        }
                        break;

                    default:
                    throw new ArgumentException(string.Format("BodyType {0} not supported", avPose.BodyType));
                }
            }

            malePoses = malePosesList.ToArray();
            femalePoses = femalePosesList.ToArray();

            if (malePoses.Length < 1)
            {
                throw new ArgumentException(string.Format("Invalid number of male poses specified (must have at least 1 male pose): {0}", malePoses.Length));
            }

            if (femalePoses.Length < 1)
            {
                throw new ArgumentException(string.Format("Invalid number of female poses specified (must have at least 1 female pose): {0}", femalePoses.Length));
            }

            usingDefaultPose = false;
        }

        internal int GetNumberOfPoses(BodyType bodyType)
        {
            if (usingDefaultPose)
            {
                return 1;
            }

            switch (bodyType)
            {
                case BodyType.Male:
                    return malePoses.Length;
                case BodyType.Female:
                    return femalePoses.Length;
                default:
                    throw new ArgumentOutOfRangeException(string.Format("BodyType {0} not supported", bodyType));
            }
        }

        internal BodyShotPose GetPose(BodyType bodyType, int index)
        {
            BodyShotPose pose = null;

            if (usingDefaultPose)
            {
                return defaultPose;
            }

            switch (bodyType)
            {
                case BodyType.Female:
                    pose = femalePoses[index];
                    break;
                case BodyType.Male:
                    pose = malePoses[index];
                    break;
                default:
                    throw new ArgumentException(string.Format("BodyType {0} not supported", bodyType));
            }

            return pose;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\SSRPerfCounters.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Wgx.Services.Monitoring;

namespace Avatar.Services.ServerSideRenderer.Service
{
    [PerformanceCategory(CategoryName = "AvatarSvcs - ServerSideRenderer", CategoryType = PerformanceCounterCategoryType.SingleInstance)]
    class SSRPerfCounters
    {
        private SSRPerfCounters() { }

        public static PerformanceCounterCollection Counters { get; set; }

        public static string Name
        {
            get { return "AvatarSvcs - ServerSideRenderer"; }
        }

        [PerformanceCounterAttribute(CounterName = "TotalMessagesProcessed", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of messages processed")]
        public static int TotalMessagesProcessed;

        [PerformanceCounterAttribute(CounterName = "TotalFailedMessages", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of messages that failed to be processed")]
        public static int TotalFailedMessages;

        [PerformanceCounterAttribute(CounterName = "MessageDurationBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Latency time for processing a message of any type")]
        public static int MessageDurationBase;

        [PerformanceCounterAttribute(CounterName = "MessageDuration", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Latency time for processing a message of any type", BasePropertyName = "MessageDurationBase")]
        public static int MessageDuration;

        [PerformanceCounterAttribute(CounterName = "MessageProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of successful messages processed per second")]
        public static int MessageProcessRate;

        [PerformanceCounterAttribute(CounterName = "CurrentNumberMessages", CounterType = PerformanceCounterType.NumberOfItems32,
            CounterDescription = "Number of messages being processed")]
        public static int CurrentNumberMessages;

        [PerformanceCounterAttribute(CounterName = "FailedMessageProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of failed messages processed per second")]
        public static int FailedMessageProcessRate;

        [PerformanceCounterAttribute(CounterName = "BodyShotDurationBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Latency time for rendering and storing a body shot image")]
        public static int BodyShotDurationBase;

        [PerformanceCounterAttribute(CounterName = "BodyShotDuration", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Latency time for rendering and storing a body shot image", BasePropertyName = "BodyShotDurationBase")]
        public static int BodyShotDuration;

        [PerformanceCounterAttribute(CounterName = "BodyShotStoreDurationBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Latency time for storing a body shot image in LIVE")]
        public static int BodyShotStoreDurationBase;

        [PerformanceCounterAttribute(CounterName = "BodyShotStoreDuration", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Latency time for storing a body shot image in LIVE", BasePropertyName = "BodyShotStoreDurationBase")]
        public static int BodyShotStoreDuration;

        [PerformanceCounterAttribute(CounterName = "BodyShotProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of successful body shot messages processed per second")]
        public static int BodyShotProcessRate;

        [PerformanceCounterAttribute(CounterName = "FailedBodyShotProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of failed body shot messages processed per second")]
        public static int FailedBodyShotProcessRate;

        [PerformanceCounterAttribute(CounterName = "CurrentNumberBodyShotMessages", CounterType = PerformanceCounterType.NumberOfItems32,
            CounterDescription = "Number of body shot messages being processed")]
        public static int CurrentNumberBodyShotMessages;

        [PerformanceCounterAttribute(CounterName = "TotalBodyShotMessagesProcessed", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of body shot messages processed")]
        public static int TotalBodyShotMessagesProcessed;

        [PerformanceCounterAttribute(CounterName = "TotalFailedBodyShotMessages", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of body shot messages that failed to be processed")]
        public static int TotalFailedBodyShotMessages;

        [PerformanceCounterAttribute(CounterName = "GamerPicDurationBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Latency time for rendering and storing a gamer picture image")]
        public static int GamerPicDurationBase;

        [PerformanceCounterAttribute(CounterName = "GamerPicDuration", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Latency time for rendering and storing a gamer picture image", BasePropertyName = "GamerPicDurationBase")]
        public static int GamerPicDuration;

        [PerformanceCounterAttribute(CounterName = "GamerPictureProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of successful gamer picture messages processed per second")]
        public static int GamerPictureProcessRate;

        [PerformanceCounterAttribute(CounterName = "FailedGamerPictureProcessRate", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Number of failed gamer picture messages processed per second")]
        public static int FailedGamerPictureProcessRate;

        [PerformanceCounterAttribute(CounterName = "CurrentNumberGamerPictureMessages", CounterType = PerformanceCounterType.NumberOfItems32,
            CounterDescription = "Number of gamer picture messages being processed")]
        public static int CurrentNumberGamerPictureMessages;

        [PerformanceCounterAttribute(CounterName = "GamerPictureStoreDurationBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Latency time for storing the gamer picture images in LIVE")]
        public static int GamerPictureStoreDurationBase;

        [PerformanceCounterAttribute(CounterName = "GamerPictureStoreDuration", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Latency time for storing the gamer picture images in LIVE", BasePropertyName = "GamerPictureStoreDurationBase")]
        public static int GamerPictureStoreDuration;

        [PerformanceCounterAttribute(CounterName = "TotalGamerPictureMessagesProcessed", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of gamer picture messages processed")]
        public static int TotalGamerPictureMessagesProcessed;

        [PerformanceCounterAttribute(CounterName = "TotalFailedGamerPictureMessages", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total number of gamer picture messages that failed to be processed")]
        public static int TotalFailedGamerPictureMessages;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\MessageReceiver.cs ===
﻿using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class MessageReceiver : IDisposable
    {
        public MessageReceiver(string connectionString)
        {
            if (string.IsNullOrEmpty(connectionString))
            {
                throw new ArgumentException("String is null or empty", "connectionString");
            }

            sqlConnection = new SqlConnection(connectionString);
            sqlConnection.Open();
        }

        //The value within the waitCommand must be lower
        //than the commandTimeout value to avoid timeout
        //exceptions
        const int commandTimeout = 30;
        const string waitCommand = "WAITFOR (" +
                                " RECEIVE top(1)" +
                                " @messageType = message_type_name," +
                                " @messageBody = message_body," +
                                " @conversationHandle = conversation_handle" +
                                " FROM [Avatar.Services.ServerSideRenderer.Messaging.RequestQueue]" +
                                " ) , TIMEOUT 15000";

        public BaseMessage BeginReceive()
        {
            BaseMessage message = null;

            StringBuilder textCommand = new StringBuilder();
            sqlCommand = sqlConnection.CreateCommand();

            sqlCommand.Parameters.Add("@conversationHandle", SqlDbType.UniqueIdentifier);
            sqlCommand.Parameters.Add("@messageType", SqlDbType.NVarChar, 4000);
            sqlCommand.Parameters.Add("@messageBody", SqlDbType.VarBinary, 8000);

            sqlCommand.Parameters["@conversationHandle"].Direction = ParameterDirection.Output;
            sqlCommand.Parameters["@messageType"].Direction = ParameterDirection.Output;
            sqlCommand.Parameters["@messageBody"].Direction = ParameterDirection.Output;

            sqlCommand.CommandTimeout = commandTimeout;
            sqlCommand.CommandText = waitCommand;

            sqlCommand.Transaction = sqlConnection.BeginTransaction();

            int rowsReceived = sqlCommand.ExecuteNonQuery();

            if (rowsReceived > 0)
            {
                doCommit = true;

                string messageType = sqlCommand.Parameters["@messageType"].Value.ToString();

                Logging.TraceVerbose("Received MessageType {0}", messageType);

                if (string.Compare(messageType, endDialogString, true) == 0)
                {
                    sqlCommand.Parameters["@conversationHandle"].Direction = ParameterDirection.Input;
                    textCommand.Remove(0, textCommand.Length);
                    textCommand.Append("End Conversation @conversationHandle with cleanup");
                    sqlCommand.CommandText = textCommand.ToString();
                    sqlCommand.ExecuteNonQuery();
                }
                else if (string.Compare(messageType, errorMessageString, true) == 0)
                {
                    sqlCommand.Parameters["@conversationHandle"].Direction = ParameterDirection.Input;
                    textCommand.Remove(0, textCommand.Length);
                    textCommand.Append("End Conversation @conversationHandle");
                    sqlCommand.CommandText = textCommand.ToString();
                    sqlCommand.ExecuteNonQuery();
                    Logging.WriteEvent(new ServiceBrokerErrorMessage());
                }
                else if (string.Compare(messageType, typeof(GenerateBodyShotMessage).ToString(), true) == 0)
                {
                    message = ExtractMessage<GenerateBodyShotMessage>();
                    if (message != null)
                    {
                        Logging.TraceVerbose("Received GenerateBodyShotMessage. XUID: {0}", message.XUID);
                    }
                }
                else if (string.Compare(messageType, typeof(GenerateGamerPictureMessage).ToString(), true) == 0)
                {
                    message = ExtractMessage<GenerateGamerPictureMessage>();
                    if (message != null)
                    {
                        Logging.TraceVerbose("Received GenerateGamerPictureMessage. XUID: {0}", message.XUID);
                    }
                }
            }

            return message;
        }

        /// <summary>
        /// Deserializes the message from the message queue and returns the message object
        /// </summary>
        /// <typeparam name="MessageType"></typeparam>
        /// <returns>The message object if successful, null if failure</returns>
        private MessageType ExtractMessage<MessageType>()
        {
            MessageType message = default(MessageType);
            int messageVersion = 0;

            byte[] messageBuffer = sqlCommand.Parameters["@messageBody"].Value as byte[];

            //Get message version
            for (int i = 0; i < sizeof(int); i++)
            {
                messageVersion += (int)messageBuffer[i] << i * 8;
            }

            //The highest order bit can be used to signal that this is a
            //diagnostic message, clear it first before comparing version number
            messageVersion = (int)(messageVersion & 0X7FFFFFFF);

            switch (messageVersion)
            {
                case 1:
                    try
                    {
                        MemoryStream memStream = new MemoryStream(messageBuffer, sizeof(int), messageBuffer.Length - sizeof(int));
                        BinaryFormatter bf = new BinaryFormatter();

                        message = (MessageType)bf.Deserialize(memStream);
                    }
                    catch (System.Runtime.Serialization.SerializationException)
                    {
                        Logging.WriteEvent(new UnrecognizedMessageFormat(), "Message Type: {0}", typeof(MessageType).ToString());
                    }
                    catch (InvalidCastException ex)
                    {
                        Logging.WriteEvent(new UnrecognizedMessageFormat(), ex);
                    }
                    break;
                default:
                    Logging.WriteEvent(new UnrecognizedMessageVersion(), "Message Type: {0}: Version {1}", typeof(MessageType).ToString(), messageVersion);
                    break;
            }

            return message;
        }

        /// <summary>
        /// EndReceive either commits or rollsback a message transaction
        /// Currently if a message is successfully retrieved it is committed
        /// and removed from the queue even if it was not processed
        /// </summary>
        public void EndReceive(bool doRollback)
        {
            try
            {
                if (doCommit && !doRollback)
                {
                    if (sqlCommand.Transaction != null) sqlCommand.Transaction.Commit();
                }
                else
                {
                    if (sqlCommand.Transaction != null) sqlCommand.Transaction.Rollback();
                }
            }
            catch (SqlException ex)
            {
                Logging.WriteEvent(new EndReceiveFailure(), ex);
            }
        }

        public void Dispose()
        {
            sqlConnection.Dispose();
            GC.SuppressFinalize(this);
        }

        private SqlConnection sqlConnection;
        private SqlCommand sqlCommand;
        private bool doCommit = false;
        const string endDialogString = "http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog";
        const string errorMessageString = "http://schemas.microsoft.com/SQL/ServiceBroker/Error";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\RendererData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.XboxLive.MathUtilities;
using Microsoft.XboxLive.SoftwareRenderer;

namespace Avatar.Services.ServerSideRenderer.Service
{
    /// <summary>
    /// Camera data
    /// Camera always look at currently selected pose of avatar, the position, the look direction and field of view can be set
    ///  </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
    public struct CameraData
    {
        /// <summary>
        /// offset from the default avatar position
        ///  </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public Vector3 Offset;

        /// <summary>
        /// rotation of camera
        ///  </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public Vector3 Rotation;


        /// <summary>
        /// field of view
        ///  </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public float FieldOfView;


        /// <summary>
        /// focal joint
        ///  </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public int FocalJoint;
    }

    /// <summary>
    /// Color for background define by red, green, blue, alfa component
    ///  </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
    public struct BackgroundColor
    {
        /// <summary>
        /// Red component
        ///  </summary>
        public byte Red{get;set;}

        /// <summary>
        /// Green component
        ///  </summary>
        public byte Green{get;set;}

        /// <summary>
        /// Blue component
        ///  </summary>
        public byte Blue{get;set;}

        /// <summary>
        /// Alfa component
        ///  </summary>
        public byte Alfa{get;set;}

        /// <summary>
        /// Initialize object with red, green and blue component, alfa is set to 255
        ///  </summary>
        public BackgroundColor(byte red, byte green, byte blue)
            : this()
        {
            Red = red;
            Green = green;
            Blue = blue;
            Alfa = 0;
        }

        /// <summary>
        /// Initialize object with red, green blue and alfa component
        ///  </summary>
        public BackgroundColor(byte red, byte green, byte blue, byte alfa)
            : this()
        {
            Red = red;
            Green = green;
            Blue = blue;
            Alfa = alfa;

        }
    }

    /// <summary>
    /// Antialiasing used for image's rendering
    ///  </summary>
    public enum Antialiasing
    {
        Invalid = AntialiasingMode.Invalid,
        None = AntialiasingMode.None,
        S2X2Y = AntialiasingMode.Supersampling2X2Y,
        Quincunx = AntialiasingMode.Quincunx,
    }

    /// <summary>
    /// Renderer data describes the request for size and quality of rendered image
    ///  </summary>
    public struct ImageProperties
    {
        /// <summary>
        /// Image width 
        /// </summary>
        public int Width{get;set;}

        /// <summary>
        /// Image height 
        /// </summary>
        public int Height{get;set;}

        /// <summary>
        /// Used anti aliasing used for rendering 
        /// </summary>
        public Antialiasing Quality{get;set;}


        /// <summary>
        /// Background color for renderer image 
        /// </summary>
        public BackgroundColor Color { get; set; }


        /// <summary>
        /// Background image for renderer image 
        /// </summary>
        public Int32[] BackgroundImage { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\RenderService.Designer.cs ===
﻿namespace Avatar.Services.ServerSideRenderer.Service
{
    partial class RenderService
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            // 
            // RenderService
            // 
            this.ServiceName = componentName;

        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\RenderService.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.ServiceProcess;
using System.Text;
using System.Configuration;
using System.Threading;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Health.Common;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache;
using Leet.Core.IO;
using Avatar.Services.ServerSideRenderer.Messaging;
using Wgx.Services.Monitoring;

namespace Avatar.Services.ServerSideRenderer.Service
{
    using CoreCC = Leet.Core.IoCCo;

    /// <summary>
    /// The render service reads messages from a service broker queue and
    /// passes the messages to the appropriate processor that includes
    /// rendering a static avatar body shot PNG, an avatar based game picture
    /// PNG and messenger dynamic display pictures
    /// </summary>
    public partial class RenderService : ServiceBase
    {
        public RenderService()
        {
            perfCounters = PerformanceCounters.GetPerformanceCounters(typeof(SSRPerfCounters));

            foreach (PerformanceCounter perfCounter in perfCounters)
            {
                perfCounter.RawValue = 0;
            }

            delay = 0;
            nextVal = 1;
            InitializeComponent();

            randomPoseDictionary = new PoseDictionary();
            CanStop = true;
            CanShutdown = true;
            doShutdown = false;
            messagesProcessing = 0;

            shutdownEvent = new ManualResetEvent(false);
        }

        private void DispatchProcessorThread()
        {
            if (delay > 0)
            {
                int whatsLeft = delay;

                while (whatsLeft > 0)
                {
                    int sleepVal;

                    sleepVal = whatsLeft > 15 ? 15 : whatsLeft;

                    if (doShutdown) break;

                    if (sleepVal > 0) Thread.Sleep(sleepVal * 1000);

                    whatsLeft = whatsLeft - 15;
                }
            }

            if (!doShutdown)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ProcessMessage));
            }
        }

        /// <summary>
        /// The primary message processing loop for the RenderService
        /// One thread is allowed to block on the queue at a time and
        /// each thread is responsible for queuing a new receiver thread
        /// prior to processing a received message
        /// </summary>
        /// <param name="state"></param>
        private void ProcessMessage(Object state)
        {
            MessageReceiver receiver = null;
            bool resetDelay = true;

            try
            {
                try
                {
                    receiver = new MessageReceiver(connectionString);
                }
                catch (Exception ex)
                {
                    UpdateDelay();
                    resetDelay = false;
                    Logging.WriteEvent(new ReceiverConstructionFailure(), ex);
                }

                if (receiver == null)
                {
                    DispatchProcessorThread();
                }
                else
                {
                    BaseMessage message = null;

                    try
                    {
                        //This will either return null (timed out waiting) or a message
                        //to process. It should not throw an exception under normal behavior.
                        message = receiver.BeginReceive();
                    }
                    catch (Exception ex)
                    {
                        UpdateDelay();
                        resetDelay = false;
                        Logging.WriteEvent(new MessageReceiveFailure(), ex);
                    }
                    finally
                    {
                        // Limit max # of messages processing at once to minimize thread thrash and increase overall throughput
                        while (this.messagesProcessing > maxConcurrentThreads - 1)
                        {
                            Thread.Sleep(10);
                        }
                        DispatchProcessorThread();
                    }

                    try
                    {
                        long elapsedTime;

                        //If the receiver times out, the message will be null and this will cause the
                        //processor to dispatch a new waiter
                        if (message != null)
                        {
                            MessageProcessResult messageResult = MessageProcessResult.Failed;

                            Interlocked.Increment(ref messagesProcessing);
                            perfCounters.SafeIncrement(SSRPerfCounters.CurrentNumberMessages);
                            elapsedTime = Stopwatch.GetTimestamp();

                            if (message.GetType() == typeof(GenerateBodyShotMessage))
                            {
                                BodyShotMessageProcessor bodyShotProcessor = new BodyShotMessageProcessor(randomPoseDictionary);

                                //If we wish to implement a retry, the bool return value should be
                                //read and used as a hint to retry based on a numeric policy. The
                                //retry attempt count must be less than 5 to avoid service broker
                                //queue disabling
                                messageResult = bodyShotProcessor.ProcessMessage((GenerateBodyShotMessage)message);
                            }
                            else if (message.GetType() == typeof(GenerateGamerPictureMessage))
                            {
                                GamerPictureMessageProcessor gamerPicMessageProcessor = new GamerPictureMessageProcessor();

                                messageResult = gamerPicMessageProcessor.ProcessMessage((GenerateGamerPictureMessage)message);
                            }

                            if (messageResult == MessageProcessResult.Success)
                            {
                                elapsedTime = Stopwatch.GetTimestamp() - elapsedTime;
                                perfCounters.SafeIncrementBy(SSRPerfCounters.MessageDuration, elapsedTime);
                                perfCounters.SafeIncrement(SSRPerfCounters.MessageDurationBase);

                                perfCounters.SafeIncrement(SSRPerfCounters.MessageProcessRate);
                                perfCounters.SafeIncrement(SSRPerfCounters.TotalMessagesProcessed);
                            }
                            else
                            {
                                perfCounters.SafeIncrement(SSRPerfCounters.FailedMessageProcessRate);
                                perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedMessages);

                                //If we get an unexpected exception, messages will be dropped
                                Logging.WriteEvent(new MessageNotProcessed(), "user XUID: {0}", message.XUID);
                            }

                        }
                        //Reset delay upon success
                        if (resetDelay)
                        {
                            delay = 0;
                            nextVal = 1;
                        }
                    }
                    catch (Exception ex)
                    {
                        UpdateDelay();

                        perfCounters.SafeIncrement(SSRPerfCounters.FailedMessageProcessRate);
                        perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedMessages);

                        if (message != null)
                        {
                            if (message.GetType() == typeof(GenerateBodyShotMessage))
                            {
                                perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedBodyShotMessages);
                            }
                            else if (message.GetType() == typeof(GenerateGamerPictureMessage))
                            {
                                perfCounters.SafeIncrement(SSRPerfCounters.TotalFailedGamerPictureMessages);
                            }
                        }

                        //If we get an unexpected exception, messages will be dropped
                        Logging.WriteEvent(new MessageNotProcessed(), ex);
                    }
                    finally
                    {
                        if (message != null)
                        {
                            Interlocked.Decrement(ref messagesProcessing);
                            perfCounters.SafeDecrement(SSRPerfCounters.CurrentNumberMessages);
                        }

                        //If the parameter passed is true, then the receiver will
                        //rollback the transaction and allow the message to be read
                        //again for a retry. Care must be exercised on retries since
                        //if a given dialogue is retried 5 times, the queue will be
                        //disabled.
                        receiver.EndReceive(false);
                    }
                }
            }
            finally
            {
                if (doShutdown && messagesProcessing == 0)
                {
                    //Signal shudownEvent
                    shutdownEvent.Set();
                }

                if (receiver != null)
                {
                    receiver.Dispose();
                }
            }
        }

        private void InitializePoseDictionary()
        {
            String strPath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase);

            string uriPrefix = @"file:\";

            if (strPath.StartsWith(uriPrefix))
            {
                strPath = strPath.Substring(uriPrefix.Length, strPath.Length - uriPrefix.Length);
            }

            try
            {
                randomPoseDictionary.LoadPoses(strPath);
            }
            catch (ArgumentException ex)
            {
                Logging.WriteEvent(new InvalidPoseConfiguration(), ex);
                return;
            }

            Logging.WriteEvent(new RandomPoseConfigurationLoaded());
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                CoreCC.Container.Instance.AddService<ILogFormatter, LogFormatter>();
                CoreCC.Container.Instance.AddService<ILogging, Logging>();
                CoreCC.Container.Instance.AddService<ILcAuthManager, AnonymousLcAuthManager>();
                CoreCC.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();

                ConfigurationSelector.RegisterProvider(componentName, "LEET");
                LeetLivecacheClient.RegisterServiceInterfacesAndInitialize(componentName);

                IConfigurationProvider configSettings = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();
                connectionString = configSettings.GetConnectionString(queueDatabaseInterface);

                try
                {
                    //Load the background images and cache them
                    LargeBackgroundImagesCache.GetBackgroundImagesCache();
                    SmallBackgroundImagesCache.GetBackgroundImagesCache();
                }
                catch (Exception e)
                {
                    Logging.WriteEvent(new BackgroundImageLoadFailure(), e);
                    throw;
                }

                InitializePoseDictionary();

                // Wire up an event handler for the AvatarApi logger to use to log internal events
                Microsoft.XboxLive.Avatars.Internal.Logger.LogReceived += SSRDiag.AvatarApiLogger_LogReceived;

                // Initialize the thread pool and max concurrent requests
                maxConcurrentThreads = configSettings.GetIntSetting(Settings.AvatarSSRMaxConcurrentThreads);
                ThreadPool.SetMinThreads(maxConcurrentThreads, maxConcurrentThreads);

                // initialize the health listner
                try
                {
                    string healthCheckPort = ConfigurationManager.AppSettings["HealthCheck_HighPort"]; ;
                    // invoke the health listner only when port can be found in Avatar.Services.ServerSideRenderer.Service.exe.config
                    if (String.IsNullOrEmpty(healthCheckPort))
                    {
                        Logging.TraceError("{0}: {1}",
                            componentName,
                            "healthCheckPort is empty in the Avatar.Services.ServerSideRenderer.Service.exe.config file.");
                    }
                    else
                    {
                        ushort listnerPort = UInt16.Parse(healthCheckPort);
                        HealthListener.InitializeHealthListener(componentName, listnerPort);
                    }
                }
                catch (Exception ex)
                {
                    // we should let the SSR Service run
                    // any exception caught here can only be due to bad configuration which should not happen
                    Logging.TraceException(ex, "{0}: {1}",
                        componentName,
                        "Caught exception initializing health blocks.");
                }

                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ProcessMessage));

                Logging.WriteEvent(new MessageProcessorStarted());
            }
            catch (Exception ex)
            {
                Logging.WriteEvent(new StartupFailure(), ex);
                throw ex;
            }
        }

        protected override void OnStop()
        {
            shutdownEvent.Reset();
            doShutdown = true;
            shutdownEvent.WaitOne();

            Logging.WriteEvent(new MessageProcessorStopped());
        }

        protected override void OnShutdown()
        {
            shutdownEvent.Reset();
            doShutdown = true;
            shutdownEvent.WaitOne();

            Logging.WriteEvent(new MessageProcessorStopped());

            base.OnShutdown();
        }

        internal void Run(string[] args)
        {
            OnStart(args);

            while (true)
            {
                //int c = Console.Read();

                //if (c == 'q')
                //{
                //    break;
                //}

                Thread.Sleep(2000);
            }
        }

        private void UpdateDelay()
        {
            Logging.TraceInformation("Delay increasing to {0} seconds", delay);
            if (delay < 120)
            {
                int tmp = nextVal;
                nextVal = delay + nextVal;
                delay = tmp;
            }
        }

        private const string componentName = "avatarsvcs_serversiderenderer";
        private const string queueDatabaseInterface = "lest_SSRQueue_db";
        int delay, nextVal;
        static string connectionString;
        private PerformanceCounterCollection perfCounters;
        private PoseDictionary randomPoseDictionary;
        bool doShutdown;
        ManualResetEvent shutdownEvent;
        int messagesProcessing;
        volatile int maxConcurrentThreads;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\StaticImageGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Windows.Media.Imaging;
using Leet.Core.Configuration;
using Microsoft.XboxLive.Avatars.Rendering;
using Microsoft.XboxLive.MathUtilities;

namespace Avatar.Services.ServerSideRenderer.Service
{
    class StaticImageGenerator : ImageGeneratorBase
    {
        /// <summary>
        /// Generates a gamerpic image
        /// </summary>
        /// <param name="imageProperties"></param>
        /// <param name="avatarData"></param>
        /// <param name="imageType"></param>
        /// <param name="cameraData"></param>
        /// <param name="useBackgroundImage"></param>
        /// <returns></returns>
        protected static MemoryStream GenerateImage(ImageProperties imageProperties, AvatarPerspectiveData avatarData, string imageType,
            CameraData cameraData, bool useBackgroundImage)
        {
            AvatarLoader avatarLoader;
            MemoryStream memoryStream = null;

            IConfigurationProvider configSettings = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();

            string avatarAssetAddressFormat = configSettings.GetSetting(Settings.AvatarAssetURIStock);
            string nonStockAssetAddressFormat = configSettings.GetSetting(Settings.AvatarAssetURIMarketAward);

            //Generate pixels
            using (avatarLoader = new AvatarLoader(imageProperties, avatarAssetAddressFormat, nonStockAssetAddressFormat,useBackgroundImage))
            {
                bool isManifestLoaded = false;
                if (avatarData.RawManifest == null)
                {
                    isManifestLoaded = avatarLoader.LoadProfileAndManifest(avatarData.XUID);
                }
                else
                {
                    isManifestLoaded = avatarLoader.LoadManifest(avatarData.RawManifest);
                }

                if(isManifestLoaded)
                {
                    // Build a pose based on the gamerpic parameters that were passed in - the camera will be positioned
                    // relative to the focal joint and not the world origin
                    PoseConfiguration gamerpicPose = new PoseConfiguration(cameraData.FocalJoint, PoseCameraStyle.TrackPosition,
                        cameraData.Rotation, cameraData.Offset, cameraData.FieldOfView);

                    int[] pixels = avatarLoader.GenerateImage(avatarData, gamerpicPose);

                    if (pixels != null)
                    {
                        memoryStream = EncodeImage(pixels, imageProperties, imageType);
                    }
                }
            }

            return memoryStream;
        }

        /// <summary>
        /// Generates a full body shot image
        /// </summary>
        /// <param name="imageProperties"></param>
        /// <param name="avatarData"></param>
        /// <param name="imageType"></param>
        /// <param name="useBackgroundImage"></param>
        /// <returns></returns>
        protected static MemoryStream GenerateImage(ImageProperties imageProperties, AvatarPerspectiveData avatarData, string imageType, bool useBackgroundImage)
        {
            AvatarLoader avatarLoader;
            MemoryStream memoryStream = null;

            IConfigurationProvider configSettings = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();

            string avatarAssetAddressFormat = configSettings.GetSetting(Settings.AvatarAssetURIStock);
            string nonStockAssetAddressFormat = configSettings.GetSetting(Settings.AvatarAssetURIMarketAward);

            //Generate pixels
            using (avatarLoader = new AvatarLoader(imageProperties, avatarAssetAddressFormat, nonStockAssetAddressFormat, useBackgroundImage))
            {
                bool isManifestLoaded = false;
                if (avatarData.RawManifest == null)
                {
                    isManifestLoaded = avatarLoader.LoadProfileAndManifest(avatarData.XUID);
                }
                else
                {
                    isManifestLoaded = avatarLoader.LoadManifest(avatarData.RawManifest);
                }

                if (isManifestLoaded)
                {
                    if (avatarData.UseRandomPose)
                    {
                        avatarLoader.PickRandomPose(avatarData);
                    }
                    else
                    {
                        avatarLoader.SetChosenPose(avatarData);
                    }

                    int[] pixels = avatarLoader.GenerateImage(avatarData);

                    if (pixels != null)
                    {
                        memoryStream = EncodeImage(pixels, imageProperties, imageType);
                    }
                }
            }

            return memoryStream;
        }

        private static MemoryStream EncodeImage(int[] pixels, ImageProperties imageProperties, string imageType)
        {
            MemoryStream memoryStream = null;

            //Encode pixels into image format
            BitmapSource bmpSource = BitmapSource.Create(imageProperties.Width, imageProperties.Height, 96.0, 96.0, System.Windows.Media.PixelFormats.Pbgra32, null, pixels, imageProperties.Width * 4);
            BitmapFrame bmpFrame = BitmapFrame.Create(bmpSource);

            BitmapEncoder encoder = CreateEncoder(imageType);
            encoder.Frames.Add(bmpFrame);

            memoryStream = new MemoryStream();
            encoder.Save(memoryStream);

            return memoryStream;
        }


        protected static BitmapEncoder CreateEncoder(string ext)
        {
            switch (ext)
            {
                case ImageEncoding.Png:
                    return new PngBitmapEncoder();
                case ImageEncoding.Tif:
                case ImageEncoding.Tiff:
                    return new TiffBitmapEncoder();
                case ImageEncoding.Jpeg:
                case ImageEncoding.Jpg:
                    return new JpegBitmapEncoder();
                case ImageEncoding.Gif:
                    return new GifBitmapEncoder();
                case ImageEncoding.Bmp:
                    return new BmpBitmapEncoder();
                default:
                    return new PngBitmapEncoder();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SSRService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: InternalsVisibleTo("Test.Avatar.Functional.AvatarServiceTests")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e4c82aac-17da-43ee-9de0-658e581d4ce0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Form1.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Configuration;
using System.Globalization;

namespace Avatar.Services.ServerSideRenderer.Test
{
    public partial class Requestor : Form
    {
        public Requestor()
        {
            InitializeComponent();
        }

        private void UpdateManifest_Click(object sender, EventArgs e)
        {
            MessageClient ssrMsgClient = new MessageClient();

            for (int i = 0; i < (int)numberInvalidMessages.Value; i++)
            {
                ssrMsgClient.SendInvalidBodyShotMessage(i);
            }

            for (int i = 0; i < (int)numericBodyShotMsgs.Value; i++)
            {
                int version = 1;
                ulong xuid;

                //version = (int)((uint)version | 0X80000000);
                if (ulong.TryParse(txtCannedBodyShotMessageGT.Text, out xuid))
                {
                    ssrMsgClient.SendGenerateBodyShot(xuid, version);
                }
            }

            for (int i = 0; i < (int)this.numberInvalidMessageTypeMessages.Value; i++)
            {
                ssrMsgClient.SendInvalidMessageType();
            }

            //for (int i = 0; i < (int)this.numberInvalidVersionBodyShotMessages.Value; i++)
            //{
            //    ssrMsgClient.SendInvalidVersionBodyShotMessage(i.ToString());
            //}

            for (int i = 0; i < (int)numericCannedGamerPic.Value; i++)
            {
                ulong xuid;
                int backgroundImgIndex;

                if (ulong.TryParse(txtGamerPicMsgs.Text, out xuid) && int.TryParse(BackgroundImgTextBox.Text, out backgroundImgIndex))
                {
                    ssrMsgClient.SendStandardGenerateGamerPicture(xuid, backgroundImgIndex);
                }
            }

            for (int i = 0; i < (int)numericBodyShotGamerTag.Value; i++)
            {
                ulong xuid;

                if (ulong.TryParse(txtBodyShotGamerTag.Text, out xuid))
                {
                    ssrMsgClient.SendGenerateBodyShot(xuid);
                }
            }

            for (int i = 0; i < (int)numericCarryable.Value; i++)
            {
                ulong xuid;
                int frame;
                float cameraX, cameraY, cameraZ;

                if (ulong.TryParse(textCarryableXUID.Text, out xuid))
                {
                    frame = (int)carryableFrameNumber.Value;
                    if (float.TryParse(cameraXPosition.Text, out cameraX) &&
                       float.TryParse(cameraYPosition.Text, out cameraY) &&
                       float.TryParse(cameraZPosition.Text, out cameraZ))
                    {
                        ssrMsgClient.SendCarryableGamerPicture(xuid, cameraX, cameraY, cameraZ, frame, 0);
                    }
                }
            }

        }

        private void Requestor_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\MessageClient.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using Avatar.Services.ServerSideRenderer.Messaging;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Configuration;

namespace Avatar.Services.ServerSideRenderer.Test
{
    class MessageClient : IDisposable
    {
        private const int HEAD_JOINT = 19;

        internal MessageClient()
        {
            RequestorService.Instance.Initialize(componentName);
        }

        [Serializable]
        class InvalidMessage : BaseMessage
        {
            public InvalidMessage(double init)
            {
                invalidData = init;
                version = 1;
            }

            double invalidData;
        };

        public void SendCarryableGamerPicture(ulong xuid, float cameraX, float cameraY, float cameraZ, int frame, int backgroundImageId)
        {
            GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();

            message.XUID = xuid;

            message.UsePropAnimation = true;
            message.Version = 1;
            message.Version = (int)((uint)message.Version | 0x80000000);
            message.OffsetX = cameraX;
            message.OffsetY = cameraY;
            message.OffsetZ = cameraZ;
            message.FocalJoint = HEAD_JOINT;
            message.FieldOfView = 0.113f;
            message.BackgroundImageId = backgroundImageId;
            message.Frame = frame;

            RequestorService.Instance.SendMessage(message);
        }

        public void SendGenerateBodyShot(ulong xuid, int Version)
        {
            GenerateBodyShotMessage message = new GenerateBodyShotMessage();
            message.XUID = xuid;
            message.Version = Version;
            message.Version = (int)((uint)message.Version | 0x80000000);
            message.PickRandomPose = true;
            message.PoseIndex = -3;
            RequestorService.Instance.SendMessage(message);
        }

        public void SendGenerateBodyShot(ulong xuid)
        {
            SendGenerateBodyShot(xuid, 1);
        }

        public void SendStandardGenerateGamerPicture(ulong xuid, int backgroundImageId)
        {
            GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
            message.XUID = xuid;
            message.Version = 1;
            message.Version = (int)((uint)message.Version | 0x80000000);
            message.AnimationId = new Guid("00400000-0003-0003-c1c8-f109a19cb2e0");
            message.UsePropAnimation = false;
            message.FocalJoint = HEAD_JOINT;
            message.OffsetX = 0;
            message.OffsetY = -0.05f;
            message.OffsetZ = 4.5f;
            message.RotationY = 0.01f;
            message.FieldOfView = 0.113f;
            message.BackgroundImageId = backgroundImageId;

            RequestorService.Instance.SendMessage(message);
        }

        //Sends the incorrect binary structure within a GenerateBodyShotMessage message
        public void SendInvalidMessageType()
        {
            InvalidMessage message = new InvalidMessage(1.3456);
            RequestorService.Instance.SendMessage(message);
        }

        public void SendInvalidBodyShotMessage(long xuid)
        {
            InvalidMessage message = new InvalidMessage(1.3456);
            TestRequestorService.Instance.SendMessage(
                message, 
                "Avatar.Services.ServerSideRenderer.Messaging.GenerateBodyShotMessage",
                message.Version);
        }

        public void SendInvalidVersionBodyShotMessage(ulong xuid)
        {
            GenerateBodyShotMessage message = new GenerateBodyShotMessage();
            message.XUID = xuid;
            TestRequestorService.Instance.SendMessage(
                message,
                message.GetType().ToString(),
                3);
        }

        public void Dispose()
        {
            GC.SuppressFinalize(this);
        }

        private const string componentName = "avatarsvcs_serversiderenderer_testclient";
    }
    public sealed class TestRequestorService
    {
        private TestRequestorService()
        {
            connectionString = ConfigurationManager.ConnectionStrings["SSRConnectionString"].ConnectionString;
        }

        public static TestRequestorService Instance { get { return instance; } }

        public void SendMessage(BaseMessage message, string messageName, int version)
        {
            MemoryStream memStream = new MemoryStream();
            BinaryFormatter bf = new BinaryFormatter();

            bf.Serialize(memStream, message);

            //Prepend message with the version
            byte[] bMessage = new byte[sizeof(int) + memStream.Length];
            for (int i = 0; i < sizeof(int); i++)
            {
                bMessage[i] = (byte)(version >> i * 8);
            }

            //Serialize message object into message
            memStream.Position = 0;
            int bytesWritten = memStream.Read(bMessage, 4, (int)memStream.Length);

            using (SqlConnection sqlConnection = new SqlConnection(connectionString))
            {
                StringBuilder commandString = new StringBuilder();

                commandString.Append(sendString);
                commandString.Append(messageName);
                commandString.Append("] (@messageBody);");

                commandString.Append("END CONVERSATION @conversationHandle");

                SqlCommand sqlCommand = null;

                try
                {
                    sqlConnection.Open();
                    sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.Transaction = sqlConnection.BeginTransaction();

                    sqlCommand.Parameters.Add("@conversationHandle", SqlDbType.UniqueIdentifier);
                    sqlCommand.Parameters.Add("@messageBody", SqlDbType.VarBinary);

                    sqlCommand.Parameters["@conversationHandle"].Direction = ParameterDirection.Output;
                    sqlCommand.Parameters["@messageBody"].Direction = ParameterDirection.Input;

                    sqlCommand.Parameters["@messageBody"].Value = bMessage;

                    sqlCommand.CommandText = commandString.ToString();

                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.Transaction.Commit();
                }
                catch (SqlException)
                {
                    if (sqlCommand != null)
                    {
                        sqlCommand.Transaction.Rollback();
                    }
                }
            }
        }

        static readonly TestRequestorService instance = new TestRequestorService();
        static string connectionString;
        static readonly string sendString =
            "BEGIN DIALOG CONVERSATION @conversationHandle" +
                                " FROM SERVICE [Avatar.Services.ServerSideRenderer.Messaging.RequestorService]" +
                                " TO SERVICE 'Avatar.Services.ServerSideRenderer.Messaging.RendererService'" +
                                " ON CONTRACT [Avatar.Services.ServerSideRenderer.Messaging.RequestContract]" +
                                " WITH LIFETIME = 600," +
                                " ENCRYPTION = OFF;" +
                                "SEND ON CONVERSATION @conversationHandle MESSAGE TYPE [";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace Avatar.Services.ServerSideRenderer.Test
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Requestor());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Form1.Designer.cs ===
﻿namespace Avatar.Services.ServerSideRenderer.Test
{
    partial class Requestor
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.cameraXPosition = new System.Windows.Forms.TextBox();
            this.UpdateManifest = new System.Windows.Forms.Button();
            this.BodyShotLabel = new System.Windows.Forms.Label();
            this.numericBodyShotMsgs = new System.Windows.Forms.NumericUpDown();
            this.numberInvalidMessages = new System.Windows.Forms.NumericUpDown();
            this.invalidMessageLabel = new System.Windows.Forms.Label();
            this.invalidBodyShotVersion = new System.Windows.Forms.Label();
            this.numberInvalidVersionBodyShotMessages = new System.Windows.Forms.NumericUpDown();
            this.invalidMessageTypeMessages = new System.Windows.Forms.Label();
            this.numberInvalidMessageTypeMessages = new System.Windows.Forms.NumericUpDown();
            this.label1 = new System.Windows.Forms.Label();
            this.numericCannedGamerPic = new System.Windows.Forms.NumericUpDown();
            this.label2 = new System.Windows.Forms.Label();
            this.txtBodyShotGamerTag = new System.Windows.Forms.TextBox();
            this.numericBodyShotGamerTag = new System.Windows.Forms.NumericUpDown();
            this.txtCannedBodyShotMessageGT = new System.Windows.Forms.TextBox();
            this.txtGamerPicMsgs = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.textCarryableXUID = new System.Windows.Forms.TextBox();
            this.numericCarryable = new System.Windows.Forms.NumericUpDown();
            this.carryableFrameNumber = new System.Windows.Forms.NumericUpDown();
            this.cameraZPosition = new System.Windows.Forms.TextBox();
            this.label7 = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.label11 = new System.Windows.Forms.Label();
            this.cameraYPosition = new System.Windows.Forms.TextBox();
            this.label12 = new System.Windows.Forms.Label();
            this.BackgroundImgTextBox = new System.Windows.Forms.TextBox();
            this.label13 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.numericBodyShotMsgs)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidMessages)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidVersionBodyShotMessages)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidMessageTypeMessages)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericCannedGamerPic)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericBodyShotGamerTag)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericCarryable)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.carryableFrameNumber)).BeginInit();
            this.SuspendLayout();
            // 
            // cameraXPosition
            // 
            this.cameraXPosition.Location = new System.Drawing.Point(878, 124);
            this.cameraXPosition.Name = "cameraXPosition";
            this.cameraXPosition.Size = new System.Drawing.Size(113, 20);
            this.cameraXPosition.TabIndex = 31;
            // 
            // UpdateManifest
            // 
            this.UpdateManifest.Location = new System.Drawing.Point(310, 394);
            this.UpdateManifest.Name = "UpdateManifest";
            this.UpdateManifest.Size = new System.Drawing.Size(98, 28);
            this.UpdateManifest.TabIndex = 0;
            this.UpdateManifest.Text = "SendMessages";
            this.UpdateManifest.UseVisualStyleBackColor = true;
            this.UpdateManifest.Click += new System.EventHandler(this.UpdateManifest_Click);
            // 
            // BodyShotLabel
            // 
            this.BodyShotLabel.AutoSize = true;
            this.BodyShotLabel.Location = new System.Drawing.Point(49, 105);
            this.BodyShotLabel.Name = "BodyShotLabel";
            this.BodyShotLabel.Size = new System.Drawing.Size(170, 13);
            this.BodyShotLabel.TabIndex = 2;
            this.BodyShotLabel.Text = "Valid Canned BodyShot Messages";
            // 
            // numericBodyShotMsgs
            // 
            this.numericBodyShotMsgs.Location = new System.Drawing.Point(527, 98);
            this.numericBodyShotMsgs.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numericBodyShotMsgs.Name = "numericBodyShotMsgs";
            this.numericBodyShotMsgs.Size = new System.Drawing.Size(70, 20);
            this.numericBodyShotMsgs.TabIndex = 3;
            // 
            // numberInvalidMessages
            // 
            this.numberInvalidMessages.Location = new System.Drawing.Point(527, 134);
            this.numberInvalidMessages.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numberInvalidMessages.Name = "numberInvalidMessages";
            this.numberInvalidMessages.Size = new System.Drawing.Size(70, 20);
            this.numberInvalidMessages.TabIndex = 4;
            // 
            // invalidMessageLabel
            // 
            this.invalidMessageLabel.AutoSize = true;
            this.invalidMessageLabel.Location = new System.Drawing.Point(49, 141);
            this.invalidMessageLabel.Name = "invalidMessageLabel";
            this.invalidMessageLabel.Size = new System.Drawing.Size(141, 13);
            this.invalidMessageLabel.TabIndex = 5;
            this.invalidMessageLabel.Text = "Invalid BodyShot  Messages";
            // 
            // invalidBodyShotVersion
            // 
            this.invalidBodyShotVersion.AutoSize = true;
            this.invalidBodyShotVersion.Location = new System.Drawing.Point(49, 177);
            this.invalidBodyShotVersion.Name = "invalidBodyShotVersion";
            this.invalidBodyShotVersion.Size = new System.Drawing.Size(176, 13);
            this.invalidBodyShotVersion.TabIndex = 6;
            this.invalidBodyShotVersion.Text = "Invalid Version BodyShot Messages";
            // 
            // numberInvalidVersionBodyShotMessages
            // 
            this.numberInvalidVersionBodyShotMessages.Location = new System.Drawing.Point(527, 170);
            this.numberInvalidVersionBodyShotMessages.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numberInvalidVersionBodyShotMessages.Name = "numberInvalidVersionBodyShotMessages";
            this.numberInvalidVersionBodyShotMessages.Size = new System.Drawing.Size(70, 20);
            this.numberInvalidVersionBodyShotMessages.TabIndex = 7;
            // 
            // invalidMessageTypeMessages
            // 
            this.invalidMessageTypeMessages.AutoSize = true;
            this.invalidMessageTypeMessages.Location = new System.Drawing.Point(49, 213);
            this.invalidMessageTypeMessages.Name = "invalidMessageTypeMessages";
            this.invalidMessageTypeMessages.Size = new System.Drawing.Size(162, 13);
            this.invalidMessageTypeMessages.TabIndex = 8;
            this.invalidMessageTypeMessages.Text = "Invalid Message Type Messages";
            // 
            // numberInvalidMessageTypeMessages
            // 
            this.numberInvalidMessageTypeMessages.Location = new System.Drawing.Point(527, 206);
            this.numberInvalidMessageTypeMessages.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numberInvalidMessageTypeMessages.Name = "numberInvalidMessageTypeMessages";
            this.numberInvalidMessageTypeMessages.Size = new System.Drawing.Size(70, 20);
            this.numberInvalidMessageTypeMessages.TabIndex = 9;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(49, 249);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(170, 13);
            this.label1.TabIndex = 10;
            this.label1.Text = "Valid Canned GamerPic Messages";
            // 
            // numericCannedGamerPic
            // 
            this.numericCannedGamerPic.Location = new System.Drawing.Point(527, 242);
            this.numericCannedGamerPic.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numericCannedGamerPic.Name = "numericCannedGamerPic";
            this.numericCannedGamerPic.Size = new System.Drawing.Size(70, 20);
            this.numericCannedGamerPic.TabIndex = 11;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(49, 322);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(168, 13);
            this.label2.TabIndex = 12;
            this.label2.Text = "Valid Custom BodyShot Messages";
            // 
            // txtBodyShotGamerTag
            // 
            this.txtBodyShotGamerTag.Location = new System.Drawing.Point(310, 315);
            this.txtBodyShotGamerTag.Name = "txtBodyShotGamerTag";
            this.txtBodyShotGamerTag.Size = new System.Drawing.Size(184, 20);
            this.txtBodyShotGamerTag.TabIndex = 13;
            // 
            // numericBodyShotGamerTag
            // 
            this.numericBodyShotGamerTag.Location = new System.Drawing.Point(527, 315);
            this.numericBodyShotGamerTag.Maximum = new decimal(new int[] {
            1000,
            0,
            0,
            0});
            this.numericBodyShotGamerTag.Name = "numericBodyShotGamerTag";
            this.numericBodyShotGamerTag.Size = new System.Drawing.Size(70, 20);
            this.numericBodyShotGamerTag.TabIndex = 14;
            // 
            // txtCannedBodyShotMessageGT
            // 
            this.txtCannedBodyShotMessageGT.Location = new System.Drawing.Point(310, 98);
            this.txtCannedBodyShotMessageGT.Name = "txtCannedBodyShotMessageGT";
            this.txtCannedBodyShotMessageGT.Size = new System.Drawing.Size(184, 20);
            this.txtCannedBodyShotMessageGT.TabIndex = 15;
            // 
            // txtGamerPicMsgs
            // 
            this.txtGamerPicMsgs.Location = new System.Drawing.Point(310, 242);
            this.txtGamerPicMsgs.Name = "txtGamerPicMsgs";
            this.txtGamerPicMsgs.Size = new System.Drawing.Size(184, 20);
            this.txtGamerPicMsgs.TabIndex = 16;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label3.Location = new System.Drawing.Point(48, 44);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(112, 20);
            this.label3.TabIndex = 17;
            this.label3.Text = "Message Type";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label4.Location = new System.Drawing.Point(306, 44);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(87, 20);
            this.label4.TabIndex = 18;
            this.label4.Text = "User XUID";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label5.Location = new System.Drawing.Point(484, 44);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(160, 20);
            this.label5.TabIndex = 19;
            this.label5.Text = "Number of Messages";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label6.Location = new System.Drawing.Point(768, 44);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(214, 20);
            this.label6.TabIndex = 20;
            this.label6.Text = "Gamer Picture with Carryable";
            // 
            // textCarryableXUID
            // 
            this.textCarryableXUID.Location = new System.Drawing.Point(878, 86);
            this.textCarryableXUID.Name = "textCarryableXUID";
            this.textCarryableXUID.Size = new System.Drawing.Size(113, 20);
            this.textCarryableXUID.TabIndex = 21;
            // 
            // numericCarryable
            // 
            this.numericCarryable.Location = new System.Drawing.Point(899, 274);
            this.numericCarryable.Name = "numericCarryable";
            this.numericCarryable.Size = new System.Drawing.Size(92, 20);
            this.numericCarryable.TabIndex = 22;
            // 
            // carryableFrameNumber
            // 
            this.carryableFrameNumber.Location = new System.Drawing.Point(899, 235);
            this.carryableFrameNumber.Name = "carryableFrameNumber";
            this.carryableFrameNumber.Size = new System.Drawing.Size(92, 20);
            this.carryableFrameNumber.TabIndex = 23;
            // 
            // cameraZPosition
            // 
            this.cameraZPosition.Location = new System.Drawing.Point(878, 196);
            this.cameraZPosition.Name = "cameraZPosition";
            this.cameraZPosition.Size = new System.Drawing.Size(113, 20);
            this.cameraZPosition.TabIndex = 24;
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label7.Location = new System.Drawing.Point(749, 89);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(33, 13);
            this.label7.TabIndex = 25;
            this.label7.Text = "XUID";
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label8.Location = new System.Drawing.Point(749, 281);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(107, 13);
            this.label8.TabIndex = 26;
            this.label8.Text = "Number of Messages";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label9.Location = new System.Drawing.Point(749, 199);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(93, 13);
            this.label9.TabIndex = 27;
            this.label9.Text = "Camera Z Position";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label10.Location = new System.Drawing.Point(749, 242);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(76, 13);
            this.label10.TabIndex = 28;
            this.label10.Text = "Frame Number";
            // 
            // label11
            // 
            this.label11.AutoSize = true;
            this.label11.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label11.Location = new System.Drawing.Point(749, 163);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(93, 13);
            this.label11.TabIndex = 30;
            this.label11.Text = "Camera Y Position";
            // 
            // cameraYPosition
            // 
            this.cameraYPosition.Location = new System.Drawing.Point(878, 160);
            this.cameraYPosition.Name = "cameraYPosition";
            this.cameraYPosition.Size = new System.Drawing.Size(113, 20);
            this.cameraYPosition.TabIndex = 29;
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label12.Location = new System.Drawing.Point(749, 127);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(93, 13);
            this.label12.TabIndex = 32;
            this.label12.Text = "Camera X Position";
            // 
            // BackgroundImgTextBox
            // 
            this.BackgroundImgTextBox.Location = new System.Drawing.Point(310, 278);
            this.BackgroundImgTextBox.MaxLength = 2;
            this.BackgroundImgTextBox.Name = "BackgroundImgTextBox";
            this.BackgroundImgTextBox.Size = new System.Drawing.Size(113, 20);
            this.BackgroundImgTextBox.TabIndex = 33;
            this.BackgroundImgTextBox.Text = "0";
            // 
            // label13
            // 
            this.label13.AutoSize = true;
            this.label13.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label13.Location = new System.Drawing.Point(112, 281);
            this.label13.Name = "label13";
            this.label13.Size = new System.Drawing.Size(99, 13);
            this.label13.TabIndex = 34;
            this.label13.Text = "Background Img ID";
            // 
            // Requestor
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1057, 453);
            this.Controls.Add(this.label13);
            this.Controls.Add(this.BackgroundImgTextBox);
            this.Controls.Add(this.label12);
            this.Controls.Add(this.cameraXPosition);
            this.Controls.Add(this.label11);
            this.Controls.Add(this.cameraYPosition);
            this.Controls.Add(this.label10);
            this.Controls.Add(this.label9);
            this.Controls.Add(this.label8);
            this.Controls.Add(this.label7);
            this.Controls.Add(this.cameraZPosition);
            this.Controls.Add(this.carryableFrameNumber);
            this.Controls.Add(this.numericCarryable);
            this.Controls.Add(this.textCarryableXUID);
            this.Controls.Add(this.label6);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.txtGamerPicMsgs);
            this.Controls.Add(this.txtCannedBodyShotMessageGT);
            this.Controls.Add(this.numericBodyShotGamerTag);
            this.Controls.Add(this.txtBodyShotGamerTag);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.numericCannedGamerPic);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.numberInvalidMessageTypeMessages);
            this.Controls.Add(this.invalidMessageTypeMessages);
            this.Controls.Add(this.numberInvalidVersionBodyShotMessages);
            this.Controls.Add(this.invalidBodyShotVersion);
            this.Controls.Add(this.invalidMessageLabel);
            this.Controls.Add(this.numberInvalidMessages);
            this.Controls.Add(this.numericBodyShotMsgs);
            this.Controls.Add(this.BodyShotLabel);
            this.Controls.Add(this.UpdateManifest);
            this.Name = "Requestor";
            this.Text = "SSR Test Client";
            this.Load += new System.EventHandler(this.Requestor_Load);
            ((System.ComponentModel.ISupportInitialize)(this.numericBodyShotMsgs)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidMessages)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidVersionBodyShotMessages)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numberInvalidMessageTypeMessages)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericCannedGamerPic)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericBodyShotGamerTag)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.numericCarryable)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.carryableFrameNumber)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button UpdateManifest;
        private System.Windows.Forms.Label BodyShotLabel;
        private System.Windows.Forms.NumericUpDown numericBodyShotMsgs;
        private System.Windows.Forms.NumericUpDown numberInvalidMessages;
        private System.Windows.Forms.Label invalidMessageLabel;
        private System.Windows.Forms.Label invalidBodyShotVersion;
        private System.Windows.Forms.NumericUpDown numberInvalidVersionBodyShotMessages;
        private System.Windows.Forms.Label invalidMessageTypeMessages;
        private System.Windows.Forms.NumericUpDown numberInvalidMessageTypeMessages;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.NumericUpDown numericCannedGamerPic;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox txtBodyShotGamerTag;
        private System.Windows.Forms.NumericUpDown numericBodyShotGamerTag;
        private System.Windows.Forms.TextBox txtCannedBodyShotMessageGT;
        private System.Windows.Forms.TextBox txtGamerPicMsgs;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.TextBox textCarryableXUID;
        private System.Windows.Forms.NumericUpDown numericCarryable;
        private System.Windows.Forms.NumericUpDown carryableFrameNumber;
        private System.Windows.Forms.TextBox cameraZPosition;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.Label label11;
        private System.Windows.Forms.TextBox cameraYPosition;
        private System.Windows.Forms.Label label12;
        private System.Windows.Forms.TextBox cameraXPosition;
        private System.Windows.Forms.TextBox BackgroundImgTextBox;
        private System.Windows.Forms.Label label13;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Avatar.Services.ServerSideRenderer.Test.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Avatar.Services.ServerSideRenderer.Test.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SSRTestClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7ba913d1-abaf-44a9-8258-68ae1c634a30")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b87a763b-5f56-4c48-b381-3277ec7a345b")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.TestClient\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Avatar.Services.ServerSideRenderer.Test.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=DRBECK-DEV\\FULLSQL;Initial Catalog=SSRDB;Integrated Security=True")]
        public string SSRDBConnectionString {
            get {
                return ((string)(this["SSRDBConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\App.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;

namespace Avatar.Services.Tools.AvatarPreviewer
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.UnitTests\BakgroundImagesCacheTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Avatar.Services.ServerSideRenderer.Service;
using Leet.Core.Diagnostics;
using Leet.TestUtilities;
using Rhino.Mocks;

namespace Avatar.Services.ServerSideRenderer.UnitTests
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class BackgroundImagesCacheTests
    {
        public BackgroundImagesCacheTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        private TestContext testContextInstance;
        
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        [TestMethod]
        public void LargeImageLoadTests()
        {
            Stubs stubs = RegisterStubs();
            SetUpValidConfigStub(stubs);

            IDictionary<String, Int32[]> imageCache = LargeBackgroundImagesCache.GetBackgroundImagesCache();

            Assert.AreEqual<Int32>(18, imageCache.Count, "18 images should be loaded");

            for (Int32 count = 0; count < 18; count++)
            { 
                String key = String.Format("gamerpic_background_{0}.png", count);
                Assert.IsTrue(imageCache.ContainsKey(key.Trim()));
                Assert.IsTrue(imageCache[key] != null);
                Assert.IsTrue(imageCache[key].Length == 4096); // 64x64
            }
        }

        [TestMethod]
        public void SmallImageLoadTests()
        {
            Stubs stubs = RegisterStubs();
            SetUpValidConfigStub(stubs);

            IDictionary<String, Int32[]> imageCache = SmallBackgroundImagesCache.GetBackgroundImagesCache();

            Assert.AreEqual<Int32>(18, imageCache.Count, "18 images should be loaded");

            for (Int32 count = 0; count < 18; count++)
            {
                String key = String.Format("gamerpic_background_{0}.png", count);
                Assert.IsTrue(imageCache.ContainsKey(key.Trim()));
                Assert.IsTrue(imageCache[key] != null);
                Assert.IsTrue(imageCache[key].Length == 1024); // 32x32
            }
        }

        [TestMethod]
        public void LargeImageLoadInvalidLocation()
        {
            Stubs stubs = RegisterStubs();
            SetUpInvalidConfigStub(stubs);

            IDictionary<String, Int32[]> imageCache = LargeBackgroundImagesCache.GetBackgroundImagesCache();
            Assert.AreEqual<Int32>(imageCache.Count, 0, "0 images should be loaded");
        }

        [TestMethod]
        public void SmallImageLoadInvalidLocation()
        {
            Stubs stubs = RegisterStubs();
            SetUpInvalidConfigStub(stubs);

            IDictionary<String, Int32[]> imageCache = SmallBackgroundImagesCache.GetBackgroundImagesCache();
            Assert.AreEqual<Int32>(imageCache.Count, 0, "0 images should be loaded");
        }


        private void SetUpValidConfigStub(Stubs stubs)
        {
            stubs.ConfigProvider.Stub(config => config.GetSetting(Settings.AvatarBackgroundImagesLocationUri)).Return(@"C:\Public\FW__GamerPic_Background");
        }

        private void SetUpInvalidConfigStub(Stubs stubs)
        {
            stubs.ConfigProvider.Stub(config => config.GetSetting(Settings.AvatarBackgroundImagesLocationUri)).Return(@"C:\NoDirectoryHere");
        }
        
        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.ConfigProvider = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.Logging = stubs.Stubber.RegisterWithContainer<ILogging>();

            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public IConfigurationProvider ConfigProvider;
            public ILogging Logging;
        }
    }

    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\PreviewGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using Microsoft.XboxLive.Avatars.Internal;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Rendering;
using Microsoft.XboxLive.SoftwareRenderer;
using MU = Microsoft.XboxLive.MathUtilities;
using Microsoft.XboxLive.MathUtilities;

namespace Avatar.Services.Tools.AvatarPreviewer
{
    internal class PreviewGenerator
    {
        public PreviewGenerator(int width, int height)
        {
            this.imageWidth = 300;// width;
            this.imageHeight = 300; // height;

            AssetLoader.EnableAssetCaching(512 * 1024 * 1024);

            int[] pixels = new int[imageWidth * imageHeight];

            SoftwareRendererSingleThreaded renderer = new SoftwareRendererSingleThreaded(imageWidth, imageHeight, pixels, AntialiasingMode.Quincunx);
            renderer.BackgroundColor = new MU.Colorb(255, 255, 255, 0);

            dataManager = new AssetDataManager();
            dataManager.AddAssetProvider(new AssetUrlDataProvider(@"http://download.xboxlive.com/content/584d07d1/{0}.bin",
                                                        @"\\xswgxtfile01\AvatarResources\{0}\avataritems\{1}.bin"));
            
            avatarRenderer = new AvatarRenderer(renderer, dataManager, new AvatarSceneLighting(512));

            assetLoader = new AssetLoader(dataManager, CoordinateSystem.LeftHanded);
        }

        private AvatarRenderer avatarRenderer;
        private AssetDataManager dataManager;
        private AssetLoader assetLoader;
        private AvatarManifestEditor editor;
        private static Dictionary<int, MemoryStream> imageCache = new Dictionary<int, MemoryStream>();
        private Guid largeHatAsset = new Guid("00000040-0002-4103-C111-0123FFFFBAAA");
        private int imageWidth;
        private int imageHeight;

        public MemoryStream GetImage(int frame)
        {
            if (imageCache.ContainsKey(frame))
                return imageCache[frame];
            else
                return null;
        }

        public int ImageCount
        {
            get { return imageCache.Count; }
        }

        public void GenerateAnimationFrames(AvatarGender gender, float heightFactor, float weightFactor, bool largeHat, Guid animationId, Vector3 cameraOffset, Vector3 cameraRotation, float cameraFieldOfView, int focalJoint)
        {
            AvatarManifest avatarManifest = AvatarManifest.CreateRandom(dataManager, gender, 1)[0];

            if (largeHat)
            {
                avatarManifest.Update(dataManager, largeHatAsset);
            }

            editor = new AvatarManifestEditor(avatarManifest, dataManager, assetLoader);
            editor.AvatarHeightFactor = heightFactor;
            editor.AvatarWidthFactor = weightFactor;

            avatarRenderer.LoadAvatar(editor.Manifest);

            avatarRenderer.LoadAnimation(animationId);
            int totalFrameCount = avatarRenderer.AnimationFrameCount;

            imageCache = new Dictionary<int, MemoryStream>();
            for (int i = 0; i < avatarRenderer.AnimationFrameCount; i++)
            {
                avatarRenderer.SetAnimationFrame(i);

                PoseConfiguration currentPose = new PoseConfiguration(focalJoint, PoseCameraStyle.TrackPosition,
                    cameraRotation, cameraOffset, cameraFieldOfView);

                avatarRenderer.RenderDefaultPreview(currentPose);

                int[] pixels = avatarRenderer.GetImagePixels();

                MemoryStream ms = EncodeImage(pixels, imageWidth, imageHeight);
                imageCache.Add(i, ms);
            }
        }

        private static MemoryStream EncodeImage(int[] pixels, int width, int height)
        {
            MemoryStream memoryStream = null;

            //Encode pixels into image format
            BitmapSource bmpSource = BitmapSource.Create(width, height, 96.0, 96.0, PixelFormats.Pbgra32, null, pixels, width * 4);
            BitmapFrame bmpFrame = BitmapFrame.Create(bmpSource);

            BitmapEncoder encoder = new PngBitmapEncoder();
            encoder.Frames.Add(bmpFrame);

            memoryStream = new MemoryStream();
            encoder.Save(memoryStream);

            return memoryStream;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\obj\Debug\GeneratedInternalTypeHelper.g.cs ===
﻿
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\SpinList.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace Avatar.Services.Tools.AvatarPreviewer
{
    /// <summary>
    /// Interaction logic for SpinList.xaml
    /// </summary>
    public partial class SpinList : UserControl
    {
        public SpinList()
        {
            InitializeComponent();

            this.leftButton.Click += new RoutedEventHandler(leftButton_Click);
            this.rightButton.Click += new RoutedEventHandler(rightButton_Click);
        }

        void rightButton_Click(object sender, RoutedEventArgs e)
        {
            this.Value += this.Increment;
            this.Value = Math.Min(this.MaximumValue, this.Value);
        }

        void leftButton_Click(object sender, RoutedEventArgs e)
        {
            this.Value -= this.Increment;
            this.Value = Math.Max(this.MinimumValue, this.Value);
        }

        public float Value
        {
            get { return Convert.ToSingle(this.valueTextBox.Text); }
            set { this.valueTextBox.Text = value.ToString(); }
        }

        public float MinimumValue = float.MinValue;
        public float MaximumValue = float.MaxValue;
        public float Increment = 0.1f;


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\obj\Debug\App.g.cs ===
﻿#pragma checksum "..\..\App.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "F3FF305E89D0061362B66C1B3570C0DB"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace Avatar.Services.Tools.AvatarPreviewer {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            
            #line 4 "..\..\App.xaml"
            this.StartupUri = new System.Uri("PreviewWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static void Main() {
            Avatar.Services.Tools.AvatarPreviewer.App app = new Avatar.Services.Tools.AvatarPreviewer.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\PreviewWindow.xaml.cs ===
﻿using System;
using System.IO;
using System.Reflection;
using System.Threading;
using System.Windows;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Xml.Linq;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using Avatar.Services.ServerSideRenderer.Common;
using System.Xml.Serialization;
using System.Xml;
using System.Text;
using System.Drawing;
using System.Drawing.Text;
using System.Drawing.Drawing2D;
using Microsoft.XboxLive.MathUtilities;
using System.Configuration;
using System.Collections.Generic;

namespace Avatar.Services.Tools.AvatarPreviewer
{
    /// <summary>
    /// Interaction logic for PreviewWindow.xaml
    /// </summary>
    public partial class PreviewWindow : Window
    {
        // Render data
        private Guid animationId;
        private Vector3 cameraOffset = new Vector3();
        private Vector3 cameraRotation = new Vector3();
        private float cameraFieldOfView;
        private int totalFrameCount;
        private AvatarGender selectedGender;
        private BodyShotPose currentPose;
        private float heightFactor;
        private float weightFactor;
        private bool largeHat = false;
        private int focalJoint;

        private Dictionary<string, int> jointList = new Dictionary<string,int>();

        // Update loop
        private bool updateImage = false;
        private bool loading = false;
        private Thread imageGeneratorThread;
        private ManualResetEvent imageEvent = new ManualResetEvent(false);

        // Image generator
        private PreviewGenerator generator;

        #region Initialize
        public PreviewWindow()
        {
            InitializeData();
            InitializeComponent();
            InitializeControls();

            imageGeneratorThread = new Thread(new ThreadStart(GenerateImages));
            imageGeneratorThread.IsBackground = true;
            imageGeneratorThread.Start();

            CompositionTarget.Rendering += new EventHandler(OnRendering);

        }

        private void InitializeData()
        {
            this.jointList.Add("Head", 19);
            this.generator = new PreviewGenerator(300, 300);
            //this.generator = new PreviewGenerator((int)this.snapshotImage.Width, (int)this.snapshotImage.Height);
        }

        private void InitializeControls()
        {
            // Initialize guids
            foreach (MemberInfo info in typeof(AvatarAssetsPack).GetMembers())
            {
                if (info.Name.StartsWith("Animation"))
                    this.animationGuidComboBox.Items.Add(info.Name);
            }
            if (this.animationGuidComboBox.Items.Count > 0)
                this.animationGuidComboBox.SelectedIndex = 0;

            foreach (string jointName in this.jointList.Keys)
            {
                this.focalJointComboBox.Items.Add(jointName);
            }

            // Initialize frame
            this.frameSlider.ValueChanged += new RoutedPropertyChangedEventHandler<double>(frameSlider_ValueChanged);

            // Initialize radio buttons
            this.maleRadioButton.Checked += new RoutedEventHandler(maleRadioButton_Checked);
            this.femaleRadioButton.Checked += new RoutedEventHandler(femaleRadioButton_Checked);
            this.femaleRadioButton.IsChecked = true;
            this.largeHatCheckBox.Click += new RoutedEventHandler(largeHatCheckBox_Click);

            // Initialize weight/height factor spinlists
            this.heightFactorSpinList.MinimumValue = -1;
            this.heightFactorSpinList.MaximumValue = 1;
            this.weightFactorSpinList.MinimumValue = -1;
            this.weightFactorSpinList.MaximumValue = 1;
            this.weightFactorSpinList.Increment = 0.5f;

            foreach (string name in ConfigurationManager.AppSettings.AllKeys)
            {
                if (this.FindName(name) is SpinList)
                {
                    SpinList spinList = this.FindName(name) as SpinList;
                    //spinList.IsEnabled = false;
                    float value = 0;
                    float.TryParse(ConfigurationManager.AppSettings[name], out value);
                    spinList.Value = value;
                }
            }
        }
        #endregion

        #region Events
        private void OnRendering(object sender, EventArgs e)
        {
            if (this.loading)
                this.loadingTextBlock.Text = "Loading...";
            else
                this.loadingTextBlock.Text = "";

            UpdateImage();
        }

        private void frameSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (this.frameValueTextBlock.Text != ((int)this.frameSlider.Value).ToString())
            {
                this.frameValueTextBlock.Text = ((int)this.frameSlider.Value).ToString();
                this.xmlTextBox.Text = GetXml();
                this.imageNameTextBox.Text = string.Format("{0}_{1}.png", this.animationGuidComboBox.SelectedValue, (int)this.frameSlider.Value);
                this.updateImage = true;
            }
        }

        private void updateButton_Click(object sender, RoutedEventArgs e)
        {
            UpdateValues();

            this.xmlTextBox.Text = GetXml();
            this.imageNameTextBox.Text = string.Format("{0}_{1}.png", this.animationGuidComboBox.SelectedValue, (int)this.frameSlider.Value);

            this.imageEvent.Set();
        }

        private void saveButton_Click(object sender, RoutedEventArgs e)
        {
            UpdateValues();

            int frame = (int)this.frameSlider.Value;
            MemoryStream ms = generator.GetImage(frame);

            Bitmap image = new Bitmap(ms);

            if (ms != null)
            {
                string imagePath = this.imageNameTextBox.Text;

                Graphics graphicImage = Graphics.FromImage(image);
                graphicImage.SmoothingMode = SmoothingMode.AntiAlias;
                graphicImage.DrawString(imagePath, new Font("Arial", 10, System.Drawing.FontStyle.Regular), SystemBrushes.WindowText, new System.Drawing.Point(10, 575));
                graphicImage.DrawRectangle(new System.Drawing.Pen(System.Drawing.Color.Black, 1), new Rectangle(0, 0, 299, 599));

                using (FileStream fs = File.Create(imagePath))
                {
                    image.Save(fs, System.Drawing.Imaging.ImageFormat.Png);
                }

                string xmlPath = this.imageNameTextBox.Text.Replace("png", "xml");
                XmlSerializer xmlSerializer = new XmlSerializer(typeof(BodyShotPose));
                using (XmlWriter writer = XmlWriter.Create(File.Create(xmlPath), new XmlWriterSettings() { Encoding = Encoding.UTF8, Indent = true }))
                {
                    xmlSerializer.Serialize(writer, currentPose);
                }
            }
        }

        private void femaleRadioButton_Checked(object sender, RoutedEventArgs e)
        {
            this.selectedGender = AvatarGender.Female;
        }

        private void maleRadioButton_Checked(object sender, RoutedEventArgs e)
        {
            this.selectedGender = AvatarGender.Male;
        }

        private void largeHatCheckBox_Click(object sender, RoutedEventArgs e)
        {
            this.largeHat = !this.largeHat;
        }
        #endregion

        #region Updates

        private void UpdateValues()
        {
            FieldInfo fieldInfo = typeof(AvatarAssetsPack).GetField(this.animationGuidComboBox.SelectedValue.ToString());
            if (fieldInfo != null)
                this.animationId = (Guid)fieldInfo.GetValue(null);
            else
                this.animationId = AvatarAssetsPack.AnimationGenericStand0;

            this.cameraOffset.X = this.OffsetX.Value;
            this.cameraOffset.Y = this.OffsetY.Value;
            this.cameraOffset.Z = this.OffsetZ.Value;
            this.cameraRotation.X = this.RotationX.Value;
            this.cameraRotation.Y = this.RotationY.Value;
            this.cameraRotation.Z = this.RotationZ.Value;
            this.cameraFieldOfView = this.FieldOfView.Value;

            this.heightFactor = this.heightFactorSpinList.Value;
            this.weightFactor = this.weightFactorSpinList.Value;

            this.focalJoint = this.jointList[this.focalJointComboBox.SelectedValue.ToString()];
        }

        private void UpdateImage()
        {
            if (updateImage)
            {
                this.frameSlider.Maximum = this.totalFrameCount;
                int frame = (int)this.frameSlider.Value;
                MemoryStream ms = this.generator.GetImage(frame);

                if (ms != null)
                {
                    BitmapImage imageSource = new BitmapImage();
                    imageSource.BeginInit();
                    imageSource.StreamSource = ms;
                    imageSource.StreamSource.Seek(0, SeekOrigin.Begin);
                    imageSource.EndInit();
                    this.snapshotImage.Source = imageSource;
                }

                this.updateImage = false;
            }
        }

        private void GenerateImages()
        {
            while (true)
            {
                imageEvent.WaitOne();
                this.loading = true;
                generator.GenerateAnimationFrames(this.selectedGender, this.heightFactor, this.weightFactor, this.largeHat, this.animationId, this.cameraOffset, this.cameraRotation, this.cameraFieldOfView, this.focalJoint);
                this.totalFrameCount = generator.ImageCount - 1;
                this.loading = false;
                this.updateImage = true;
                imageEvent.Reset();
            }
        }
        #endregion

        #region Static helpers
        private string GetXml()
        {
            currentPose = new BodyShotPose();
            currentPose.Animation = animationId;
            currentPose.BodyType = (BodyType)Enum.Parse(typeof(BodyType), selectedGender.ToString());
            currentPose.FieldOfView = cameraFieldOfView;
            currentPose.Frame = (int)frameSlider.Value;
            currentPose.OffsetX = cameraOffset.X;
            currentPose.OffsetY = cameraOffset.Y;
            currentPose.OffsetZ = cameraOffset.Z;
            currentPose.RotationX = cameraRotation.X;
            currentPose.RotationY = cameraRotation.Y;
            currentPose.RotationZ = cameraRotation.Z;


            XmlSerializer xmlSerializer = new XmlSerializer(typeof(BodyShotPose));
            StringBuilder sb = new StringBuilder();
            using (XmlWriter writer = XmlTextWriter.Create(sb))
            {
                xmlSerializer.Serialize(writer, currentPose);
            }

            return sb.ToString();
        }

        private static byte[] GenerateManifestData(string hexManifestString)
        {
            byte[] manifestData = new byte[1000];

            for (int i = 0; i < 1000; i++)
            {
                manifestData[i] = Convert.ToByte(hexManifestString.Substring(2 * i, 2), 16);
            }

            return manifestData;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\obj\Debug\PreviewWindow.g.cs ===
﻿#pragma checksum "..\..\PreviewWindow.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "83A5FA6C1C7DB71971BFA42FC0B78963"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Avatar.Services.Tools.AvatarPreviewer;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace Avatar.Services.Tools.AvatarPreviewer {
    
    
    /// <summary>
    /// PreviewWindow
    /// </summary>
    public partial class PreviewWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 7 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.Image snapshotImage;
        
        #line default
        #line hidden
        
        
        #line 8 "..\..\PreviewWindow.xaml"
        internal System.Windows.Shapes.Rectangle rectangle1;
        
        #line default
        #line hidden
        
        
        #line 9 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.ComboBox animationGuidComboBox;
        
        #line default
        #line hidden
        
        
        #line 10 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.Slider frameSlider;
        
        #line default
        #line hidden
        
        
        #line 11 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock frameTextBlock;
        
        #line default
        #line hidden
        
        
        #line 12 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock animationTextBlock;
        
        #line default
        #line hidden
        
        
        #line 13 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock xuidTextBlock;
        
        #line default
        #line hidden
        
        
        #line 14 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock frameValueTextBlock;
        
        #line default
        #line hidden
        
        
        #line 15 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.Button updateButton;
        
        #line default
        #line hidden
        
        
        #line 16 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList OffsetX;
        
        #line default
        #line hidden
        
        
        #line 17 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList OffsetY;
        
        #line default
        #line hidden
        
        
        #line 18 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList OffsetZ;
        
        #line default
        #line hidden
        
        
        #line 19 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList RotationX;
        
        #line default
        #line hidden
        
        
        #line 20 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList RotationY;
        
        #line default
        #line hidden
        
        
        #line 21 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList RotationZ;
        
        #line default
        #line hidden
        
        
        #line 22 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock1;
        
        #line default
        #line hidden
        
        
        #line 23 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock2;
        
        #line default
        #line hidden
        
        
        #line 24 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock3;
        
        #line default
        #line hidden
        
        
        #line 25 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock4;
        
        #line default
        #line hidden
        
        
        #line 26 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock5;
        
        #line default
        #line hidden
        
        
        #line 27 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock6;
        
        #line default
        #line hidden
        
        
        #line 28 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.Button saveButton;
        
        #line default
        #line hidden
        
        
        #line 29 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBox xmlTextBox;
        
        #line default
        #line hidden
        
        
        #line 30 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList FieldOfView;
        
        #line default
        #line hidden
        
        
        #line 31 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock7;
        
        #line default
        #line hidden
        
        
        #line 32 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.RadioButton maleRadioButton;
        
        #line default
        #line hidden
        
        
        #line 33 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.RadioButton femaleRadioButton;
        
        #line default
        #line hidden
        
        
        #line 36 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock loadingTextBlock;
        
        #line default
        #line hidden
        
        
        #line 37 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBox imageNameTextBox;
        
        #line default
        #line hidden
        
        
        #line 38 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList heightFactorSpinList;
        
        #line default
        #line hidden
        
        
        #line 39 "..\..\PreviewWindow.xaml"
        internal Avatar.Services.Tools.AvatarPreviewer.SpinList weightFactorSpinList;
        
        #line default
        #line hidden
        
        
        #line 40 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock8;
        
        #line default
        #line hidden
        
        
        #line 41 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.TextBlock textBlock9;
        
        #line default
        #line hidden
        
        
        #line 42 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.CheckBox largeHatCheckBox;
        
        #line default
        #line hidden
        
        
        #line 43 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.ComboBox focalJointComboBox;
        
        #line default
        #line hidden
        
        
        #line 44 "..\..\PreviewWindow.xaml"
        internal System.Windows.Controls.Label label1;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/Avatar.Services.Tools.AvatarPreviewer;component/previewwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\PreviewWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal System.Delegate _CreateDelegate(System.Type delegateType, string handler) {
            return System.Delegate.CreateDelegate(delegateType, this, handler);
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.snapshotImage = ((System.Windows.Controls.Image)(target));
            return;
            case 2:
            this.rectangle1 = ((System.Windows.Shapes.Rectangle)(target));
            return;
            case 3:
            this.animationGuidComboBox = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 4:
            this.frameSlider = ((System.Windows.Controls.Slider)(target));
            return;
            case 5:
            this.frameTextBlock = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 6:
            this.animationTextBlock = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 7:
            this.xuidTextBlock = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 8:
            this.frameValueTextBlock = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 9:
            this.updateButton = ((System.Windows.Controls.Button)(target));
            
            #line 15 "..\..\PreviewWindow.xaml"
            this.updateButton.Click += new System.Windows.RoutedEventHandler(this.updateButton_Click);
            
            #line default
            #line hidden
            return;
            case 10:
            this.OffsetX = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 11:
            this.OffsetY = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 12:
            this.OffsetZ = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 13:
            this.RotationX = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 14:
            this.RotationY = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 15:
            this.RotationZ = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 16:
            this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 17:
            this.textBlock2 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 18:
            this.textBlock3 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 19:
            this.textBlock4 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 20:
            this.textBlock5 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 21:
            this.textBlock6 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 22:
            this.saveButton = ((System.Windows.Controls.Button)(target));
            
            #line 28 "..\..\PreviewWindow.xaml"
            this.saveButton.Click += new System.Windows.RoutedEventHandler(this.saveButton_Click);
            
            #line default
            #line hidden
            return;
            case 23:
            this.xmlTextBox = ((System.Windows.Controls.TextBox)(target));
            return;
            case 24:
            this.FieldOfView = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 25:
            this.textBlock7 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 26:
            this.maleRadioButton = ((System.Windows.Controls.RadioButton)(target));
            return;
            case 27:
            this.femaleRadioButton = ((System.Windows.Controls.RadioButton)(target));
            return;
            case 28:
            this.loadingTextBlock = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 29:
            this.imageNameTextBox = ((System.Windows.Controls.TextBox)(target));
            return;
            case 30:
            this.heightFactorSpinList = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 31:
            this.weightFactorSpinList = ((Avatar.Services.Tools.AvatarPreviewer.SpinList)(target));
            return;
            case 32:
            this.textBlock8 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 33:
            this.textBlock9 = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 34:
            this.largeHatCheckBox = ((System.Windows.Controls.CheckBox)(target));
            return;
            case 35:
            this.focalJointComboBox = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 36:
            this.label1 = ((System.Windows.Controls.Label)(target));
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.PosesBuilder\AvatarPoses.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Avatar.Services.ServerSideRenderer.Common;
using System.Xml.Serialization;

namespace Avatar.Services.Tools.PosesBuilder
{
    [Serializable]
    [XmlType(AnonymousType = true)]
    [XmlRoot(Namespace = "", IsNullable = false)]
    public class AvatarPoses
    {
        private BodyShotPose[] bodyShotPoseArray;

        [XmlElementAttribute("BodyShotPose")]
        public BodyShotPose[] BodyShotPoseArray
        {
            get
            {
                return this.bodyShotPoseArray;
            }
            set
            {
                this.bodyShotPoseArray = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\obj\Debug\SpinList.g.cs ===
﻿#pragma checksum "..\..\SpinList.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "7935CD5DB0856553EE7DEBB0924E6988"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace Avatar.Services.Tools.AvatarPreviewer {
    
    
    /// <summary>
    /// SpinList
    /// </summary>
    public partial class SpinList : System.Windows.Controls.UserControl, System.Windows.Markup.IComponentConnector {
        
        
        #line 6 "..\..\SpinList.xaml"
        internal System.Windows.Controls.Button leftButton;
        
        #line default
        #line hidden
        
        
        #line 7 "..\..\SpinList.xaml"
        internal System.Windows.Controls.Button rightButton;
        
        #line default
        #line hidden
        
        
        #line 8 "..\..\SpinList.xaml"
        internal System.Windows.Controls.TextBox valueTextBox;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/Avatar.Services.Tools.AvatarPreviewer;component/spinlist.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\SpinList.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.leftButton = ((System.Windows.Controls.Button)(target));
            return;
            case 2:
            this.rightButton = ((System.Windows.Controls.Button)(target));
            return;
            case 3:
            this.valueTextBox = ((System.Windows.Controls.TextBox)(target));
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.PosesBuilder\Logger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Avatar.Services.Tools.PosesBuilder
{
    public class Logger
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public void Write(string message)
        {
            MessageEventArgs e = new MessageEventArgs(message);
            OnMessageNotifier(e);
        }

        public void WriteLine()
        {
            Write("\r\n");
        }

        public void WriteLine(string value)
        {
            Write(value);
            Write("\r\n");
        }

        public void WriteLine(string format, params object[] arg)
        {
            WriteLine(String.Format(format, arg));
        }

        /// <summary>
        /// 
        /// </summary>
        public event MessageEventHandler OnMessage;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnMessageNotifier(MessageEventArgs e)
        {
            if (OnMessage != null)
            {
                // Invokes the delegates. 
                OnMessage(this, e);
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public delegate void MessageEventHandler(object sender, MessageEventArgs e);

    /// <summary>
    /// 
    /// </summary>
    public class MessageEventArgs : EventArgs
    {
        private string message = "";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public MessageEventArgs(string message)
        {
            Message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return message; }
            set
            {
                if (value == null)
                {
                    message = "";
                }
                else
                {
                    message = value;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.AvatarPreviewer\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AvatarPreviewer")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("AvatarPreviewer")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
    //(used if a resource is not found in the page, 
    // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
    //(used if a resource is not found in the page, 
    // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.PosesBuilder\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Tools.PosesBuilder")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("Avatar.Services.Tools.PosesBuilder")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8d096508-6bda-4351-beee-9b04695b1a42")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.PosesBuilder\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using Avatar.Services.ServerSideRenderer.Common;
using System.Xml.Linq;
using System.Xml.Schema;

namespace Avatar.Services.Tools.PosesBuilder
{
    class Program
    {
        private static Logger logger = new Logger();
        private static TextWriter logWriter = null;
        private static string posesPath = string.Empty;
        private static string outputFile = "AvatarPoses.xml";
        private static string xsdFile = "AvatarPoses.xsd";

        static void Main(string[] args)
        {
            logger.OnMessage += new MessageEventHandler(ConsoleMessageLogger);
            if (!ParseArguments(args))
            {
                PrintUsage();
                return;
            }

            BuildPosesFile();
        }

        private static void BuildPosesFile()
        {
            // Get individual poses files
            string[] files = Directory.GetFiles(posesPath, "*.xml");

            if (files.Length == 0)
            {
                logger.WriteLine("There were no pose xml's found in the directory: {0}", posesPath);
                return;
            }

            // Deserialize into BodyShotPose and add to the list
            List<BodyShotPose> poseList = new List<BodyShotPose>();
            XmlSerializer serializer = new XmlSerializer(typeof(BodyShotPose));
            foreach (string file in files)
            {
                try
                {
                    //using (XmlReader reader = XmlReader.Create(file))
                    using (XmlReader reader = XmlTextReader.Create(file))
                    {
                        BodyShotPose pose = serializer.Deserialize(reader) as BodyShotPose;

                        if (!poseList.Contains(pose))
                        {
                            poseList.Add(pose);
                        }
                        else
                        {
                            logger.WriteLine("Skipped duplicate file {0}", file);
                        }
                    }
                    logger.WriteLine("Successfully read file: {0}", file);
                }
                catch (Exception ex)
                {
                    logger.WriteLine("There was an error reading file {0}: {1}", file, ex.ToString());
                }
            }
            logger.WriteLine("{0} poses were added to the list.", poseList.Count);

            // Serialize into AvatarPoses and write the xml
            AvatarPoses avatarPoses = new AvatarPoses();
            avatarPoses.BodyShotPoseArray = poseList.ToArray();

            serializer = new XmlSerializer(typeof(AvatarPoses));
            using (FileStream fileStream = File.Create(outputFile))
            using (XmlWriter writer = XmlWriter.Create(fileStream, new XmlWriterSettings() { Encoding = Encoding.UTF8, Indent = true }))
            {
                serializer.Serialize(writer, avatarPoses);
            }
            logger.WriteLine("Avatar pose file generated: {0}", outputFile);

            // Read and validate the xml against the xsd
            try
            {
                using (FileStream fileStream = new FileStream(xsdFile, FileMode.Open))
                {
                    XmlSchemaSet schemaSet = new XmlSchemaSet();
                    XmlSchema schema = XmlSchema.Read(fileStream, null);
                    schemaSet.Add(schema);

                    //Load and validate the random pose configuration
                    XDocument poses = XDocument.Load(outputFile);
                    poses.Validate(schemaSet, null);
                }
                logger.WriteLine("The output file passed validation.");
            }
            catch (Exception ex)
            {
                logger.WriteLine("ERROR: The output file failed validation against the given xsd ({0}): {1}", xsdFile, ex.ToString());
            }
        }

        private static bool ParseArguments(string[] args)
        {
            if (args.Length == 0)
            {
                return false;
            }

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].StartsWith("/"))
                {
                    switch (args[i].ToLower())
                    {
                        case "/?":
                            return false;
                        case "/logfile":
                            i++;
                            if (i < args.Length)
                            {
                                logWriter = new StreamWriter(args[i]);
                                logger.OnMessage += new MessageEventHandler(FileMessageLogger);
                                i++;
                            }
                            else
                            {
                                logger.WriteLine("No file specified for /logfile option.");
                                return false;
                            }
                            break;
                        case "/d":
                            i++;
                            if (i < args.Length)
                            {
                                posesPath = args[i];
                                i++;

                                if (!Directory.Exists(posesPath))
                                {
                                    return false;
                                }
                                logger.WriteLine("Poses path: " + posesPath);
                            }
                            else
                            {
                                logger.WriteLine("No path specified for /d option.");
                            }
                            break;
                        case "/o":
                            i++;
                            if (i < args.Length)
                            {
                                outputFile = args[i];
                                i++;
                            }
                            else
                            {
                                logger.WriteLine("No output file specified for /o option. Using default.");
                            }
                            break;
                        case "/x":
                            i++;
                            if (i < args.Length)
                            {
                                xsdFile = args[i];
                                i++;
                            }
                            else
                            {
                                logger.WriteLine("No xsd file specified for /x option. Using default.");
                            }
                            break;
                        default:
                            logger.WriteLine("Unknown option {0} specified.", args[i]);
                            return false;
                    }
                }
            }
            return true;
        }

        private static void PrintUsage()
        {
            logger.WriteLine();
            logger.WriteLine("Avatar.Services.Tools.PosesBuilder: A tool used to generate the poses file ");
            logger.WriteLine("from a set of pose xml files for Server Side Renderer.");
            logger.WriteLine();
            logger.WriteLine("Usage:");
            logger.WriteLine("  Avatar.Services.Tools.PosesBuilder.exe [flags]");
            logger.WriteLine();
            logger.WriteLine("  /? - Displays help");
            logger.WriteLine("  /logfile - Send output to the specified file");
            logger.WriteLine("  /d - Path to all the pose xml files.");
            logger.WriteLine("  /o - Output file name [Optional: default = AvatarPoses.xml]");
            logger.WriteLine("  /x - XSD file name to validate against [Optional: default = AvatarPoses.xsd]");
        }

        private static void ConsoleMessageLogger(object sender, MessageEventArgs e)
        {
            Console.Write(e.Message);
        }

        private static void FileMessageLogger(object sender, MessageEventArgs e)
        {
            if (logWriter != null)
            {
                logWriter.Write(e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\TocAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Tools.TocBuilder
{
    public class TocAsset
    {
        public Guid Id { get; set; }
        public string Description { get; set; }
        public List<String> ColorRGBValues { get; set; }
        public bool ColorSupported { get; set; }

        public TocAsset()
        {
            this.ColorRGBValues = new List<string>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace Avatar.Services.Tools.TocBuilder
{
    class TocBuilderApplication
    {
        private Logger _logger = new Logger();
        private TextWriter _logWriter = null;

        static void Main(string[] args)
        {
            TocBuilderApplication app = new TocBuilderApplication();
            app.Start(args);
        }

        private void Start(string[] args)
        {
            _logger.OnMessage += new MessageEventHandler(ConsoleMessageLogger);

            try
            {
                ExecuteTocBuilder(args);
            }
            catch (Exception e)
            {
                _logger.WriteLine("An error occured:");
                _logger.WriteLine();
                _logger.WriteLine(e.ToString());
            }

            if (_logWriter != null)
            {
                _logWriter.Close();
                _logWriter = null;
            }
        }

        private void ExecuteTocBuilder(string[] args)
        {
            string tocXmlFilePath = String.Empty;
            string tocHdrFilePath = String.Empty;

            if (args.Length == 0)
            {
                WriteHelpText();
            }
            else
            {
                int currentArg = 0;

                while ((currentArg < args.Length) && (args[currentArg].StartsWith("/")))
                {
                    switch (args[currentArg].ToLower())
                    {
                        case "/logfile":
                            currentArg++;
                            if (currentArg < args.Length)
                            {
                                _logWriter = new StreamWriter(args[currentArg]);
                                _logger.OnMessage += new MessageEventHandler(FileMessageLogger);
                                currentArg++;
                            }
                            else
                            {
                                _logger.WriteLine("No file specified for /logfile option.");
                                WriteHelpText();
                                currentArg = args.Length;
                            }
                            break;
                        case "/x":
                            currentArg++;
                            if (currentArg < args.Length)
                            {
                                tocXmlFilePath = args[currentArg];
                                currentArg++;
                            }
                            else
                            {
                                _logger.WriteLine("No file specified for /x option.");
                                WriteHelpText();
                                currentArg = args.Length;
                            }
                            break;
                        case "/h":
                            currentArg++;
                            if (currentArg < args.Length)
                            {
                                tocHdrFilePath = args[currentArg];
                                currentArg++;
                            }
                            else
                            {
                                _logger.WriteLine("No file specified for /h option.");
                                WriteHelpText();
                                currentArg = args.Length;
                            }
                            break;
                        case "/?":
                            WriteHelpText();
                            currentArg = args.Length;
                            break;
                        default:
                            _logger.WriteLine("Unknown option {0} specified.", args[currentArg]);
                            WriteHelpText();
                            currentArg = args.Length;
                            break;
                    }
                }
            }

            if (!String.IsNullOrEmpty(tocHdrFilePath) && !String.IsNullOrEmpty(tocXmlFilePath))
            {
                TocBuilderController controller = new TocBuilderController(tocXmlFilePath, tocHdrFilePath, _logger);

                controller.BuildAssetPackXmlFiles();
            }
        }

        private void WriteHelpText()
        {
            _logger.WriteLine();
            _logger.WriteLine("Avatar.Services.Tools.TocBuilder:  A tool used to build the localized index files ");
            _logger.WriteLine("for the avatar TOC assets that is consumed by cross-platfrom avatar editor tool.");
            _logger.WriteLine();
            _logger.WriteLine("IMPORTANT:  This tool requires a current XENON enlistment for access to the");
            _logger.WriteLine("AvatarAssetPack.xml and AvatarAssetPack.h files that are the data  sources");
            _logger.WriteLine("the TocBuider tool uses.");
            _logger.WriteLine();
            _logger.WriteLine("Usage:");
            _logger.WriteLine("   Avatar.Services.Tools.TocBuilder.exe [flags]");
            _logger.WriteLine();
            _logger.WriteLine("Flags:");
            _logger.WriteLine("   /? - Displays help");
            _logger.WriteLine("   /logfile - Send output to the specified file");
            _logger.WriteLine("   /x - Path of the AvatarAssetPack.xml file <required>");
            _logger.WriteLine("   /h - Path of the AvatarAssetPack.h file <required>");

        }

        private void FileMessageLogger(object sender, MessageEventArgs e)
        {
            if (_logWriter != null)
            {
                _logWriter.Write(e.Message);
            }
        }

        private void ConsoleMessageLogger(object sender, MessageEventArgs e)
        {
            Console.Write(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\AssetCategories.cs ===
﻿using System;
using System.ComponentModel;
using System.Reflection;

namespace Avatar.Services.Tools.TocBuilder
{
    public enum AssetCategories
    {
        Head = 1, 
        Body, 
        Hair, 
        Shirt, 
        Trousers, 
        Shoes, 
        Hat, 
        Gloves, 
        Glasses, 
        Wristwear, 
        Earrings, 
        Ring, 
        Eyes, 
        Eyebrows, 
        Mouth, 
        [Description("Facial Hair")]
        FacialHair, 
        [Description("Facial other")]
        FacialOther, 
        [Description("Eye Shadow")]
        EyeShadow, 
        Nose, 
        Chin, 
        Ears, 
        Animation, 
        Costume
    };

    public static class EnumHelper
    {
        public static string ToDescription(this Enum en)
        {
            Type type = en.GetType();
            MemberInfo[] memInfo = type.GetMember(en.ToString());
            if (memInfo != null && memInfo.Length > 0)
            {
                object[] attrs = memInfo[0].GetCustomAttributes(typeof(DescriptionAttribute), false);
                if (attrs != null && attrs.Length > 0)
                    return ((DescriptionAttribute)attrs[0]).Description;
            }
            return en.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\TocBuilderController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Tools.TocBuilder
{
    public class TocBuilderController
    {
        private string _assetPackXmlPath;
        private string _assetPackHeaderPath;
        private List<AssetCategories> _includedCategoriesList;
        private List<String> _languageList;

        private Logger _errorLog;

        public TocBuilderController(string assetPackXmlPath, string assetPackHeaderPath, Logger errorLog)
        {
            _assetPackHeaderPath = assetPackHeaderPath;
            _assetPackXmlPath = assetPackXmlPath;
            _errorLog = errorLog;

            SetUpAssetCategoryList();
            SetUpLanguageList();
        }

        private void SetUpAssetCategoryList()
        {
            _includedCategoriesList = new List<AssetCategories>(19);

            _includedCategoriesList.Add(AssetCategories.Costume);
            _includedCategoriesList.Add(AssetCategories.Chin);
            _includedCategoriesList.Add(AssetCategories.Earrings);
            _includedCategoriesList.Add(AssetCategories.Ears);
            _includedCategoriesList.Add(AssetCategories.Eyebrows);
            _includedCategoriesList.Add(AssetCategories.Eyes);
            _includedCategoriesList.Add(AssetCategories.FacialHair);
            _includedCategoriesList.Add(AssetCategories.FacialOther);
            _includedCategoriesList.Add(AssetCategories.Glasses);
            _includedCategoriesList.Add(AssetCategories.Gloves);
            _includedCategoriesList.Add(AssetCategories.Hair);
            _includedCategoriesList.Add(AssetCategories.Hat);
            _includedCategoriesList.Add(AssetCategories.Mouth);
            _includedCategoriesList.Add(AssetCategories.Nose);
            _includedCategoriesList.Add(AssetCategories.Ring);
            _includedCategoriesList.Add(AssetCategories.Shirt);
            _includedCategoriesList.Add(AssetCategories.Shoes);
            _includedCategoriesList.Add(AssetCategories.Trousers);
            _includedCategoriesList.Add(AssetCategories.Wristwear);
        }

        private void SetUpLanguageList()
        {
            _languageList = new List<String>();

            _languageList.Add("English|en");
            _languageList.Add("German|de");
            _languageList.Add("TChinese|zh");
            _languageList.Add("Spanish|es");
            _languageList.Add("French|fr");
            _languageList.Add("Italian|it");
            _languageList.Add("Japanese|jp");
            _languageList.Add("Korean|kr");
            _languageList.Add("Polish|pl");
            _languageList.Add("Portuguese|pt");
            _languageList.Add("Russian|ru");
        }

        public void BuildAssetPackXmlFiles()
        {
            const string FILENAME_TEMPLATE = "tocindex_{0}.xml";
            const int LANG_NODENAME_INDEX = 0;      // Name of the language node in the asset source XML file
            const int LANG_CODE_INDEX = 1;          // Language abbreviation used to name the output file

            AssetPackReader reader = new AssetPackReader(_errorLog);

            try
            {
                reader.Initialize(_assetPackXmlPath, _assetPackHeaderPath);
            }
            catch (Exception ex)
            {
                _errorLog.WriteLine("An error occurred while initializing the file readers: {0}", ex.Message);
            }

            // Iterate through the languages and build each loc'ed asset index file in turn
            foreach (String language in _languageList)
            {
                string[] languageSet = language.Split('|');
                string outputFileName = String.Format(FILENAME_TEMPLATE, languageSet[LANG_CODE_INDEX]);

                using (TocWriter writer = new TocWriter(outputFileName))
                {
                    foreach (AssetCategories category in _includedCategoriesList)
                    {
                        try
                        {
                            writer.WriteAssetCategory(category, reader.GetAssetByCategory(languageSet[LANG_NODENAME_INDEX], category));
                        }
                        catch (Exception ex)
                        {
                            _errorLog.WriteLine("An error occurred while writing the index file: {0}", ex.Message);
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Databases\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\TocWriter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;

namespace Avatar.Services.Tools.TocBuilder
{
    public class TocWriter : IDisposable
    {
        private XmlTextWriter _xmlWriter;

        public TocWriter(string fileName)
        {
            _xmlWriter = new XmlTextWriter(fileName, Encoding.UTF8);
            _xmlWriter.WriteStartDocument();
            _xmlWriter.WriteStartElement("Assets");
        }

        public void WriteAssetCategory(AssetCategories category, List<TocAsset> assetsByCategory)
        {
            _xmlWriter.WriteStartElement("AssetCategory");
            _xmlWriter.WriteAttributeString("name", category.ToDescription());
            _xmlWriter.WriteAttributeString("id", ((int)category).ToString());

            int assetIndexByCategory = 0;
            foreach (TocAsset asset in assetsByCategory)
            {
                _xmlWriter.WriteStartElement("Asset");
                _xmlWriter.WriteAttributeString("id", asset.Id.ToString());
                _xmlWriter.WriteAttributeString("index", assetIndexByCategory++.ToString());
                _xmlWriter.WriteAttributeString("colorSupported", asset.ColorSupported.ToString());

                _xmlWriter.WriteStartElement("Description");
                _xmlWriter.WriteValue(asset.Description);
                _xmlWriter.WriteEndElement();

                foreach (string color in asset.ColorRGBValues)
                {
                    _xmlWriter.WriteStartElement("Color");
                    _xmlWriter.WriteAttributeString("rgb", color);
                    _xmlWriter.WriteEndElement();
                }

                _xmlWriter.WriteEndElement();
            }

            _xmlWriter.WriteEndElement();
        }

        public void Close()
        {
            _xmlWriter.WriteEndDocument();
            _xmlWriter.Flush();
            _xmlWriter.Close();
        }

        #region IDisposable Members

        public void Dispose()
        {
            this.Close();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\AssetPackReader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;
using System.Reflection;
using System.ComponentModel;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using System.Security;
using System.Globalization;

namespace Avatar.Services.Tools.TocBuilder
{
    public class AssetPackReader
    {
        XDocument _assetPackDoc;
        Dictionary<string, Guid> _assetIdTable;
        Logger _errorLog = null;


        public AssetPackReader(Logger errorLog)
        {
            _assetIdTable = new Dictionary<string, Guid>(64);
            _errorLog = errorLog;
        }

        public void Initialize(string assetPackPath, string headerFilePath)
        {
            _assetPackDoc = XDocument.Load(assetPackPath);

            LoadAssetIdsFromHeader(headerFilePath);
        }

        private void LoadAssetIdsFromHeader(string headerFilePath)
        {
            const int PREFIX_LENGTH = 34;
            const int GUID_LENGTH = 75;

            using (StreamReader sr = new StreamReader(headerFilePath))
            {
                string line;
                while ((line = sr.ReadLine()) != null)
                {
                    if (line.StartsWith("DEFINE_GUID"))
                    {
                        int firstComma = line.IndexOf(',', 0);
                        string rawName = line.Substring(PREFIX_LENGTH, firstComma - PREFIX_LENGTH);
                        string rawGuid = line.Substring(firstComma + 1, GUID_LENGTH);

                        string cleanName = rawName.ToLower();
                        string cleanGuid = rawGuid.Replace("0x", "").Replace(", ", "");

                        _assetIdTable.Add(cleanName, new Guid(cleanGuid));
                    }
                }
            }
        }

        public List<TocAsset> GetAssetByCategory(string language, AssetCategories assetCategory)
        {
            IEnumerable<XElement> categoryNodes =
                from el in _assetPackDoc.Descendants("Asset")
                where ((string)el.Attribute("Category")).IndexOf(assetCategory.ToDescription()) == 0 
                && (string)el.Attribute("Visible") != "False"
                && (string)el.Attribute("Disabled") != "true"
                select el;

            List<TocAsset> assets = ConvertAndAddIds(language, categoryNodes);

            return assets;
        }

        private List<TocAsset> ConvertAndAddIds(string language, IEnumerable<XElement> categoryNodes)
        {
            List<TocAsset> assetList = new List<TocAsset>();

            foreach (XElement node in categoryNodes)
            {
                // If localized language node is missing, fall back to English - this is console behavior
                string description = String.Empty;
                if (node.Element(language) == null)
                {
                    description = (string)node.Element("English").Attribute("Name");
                }
                else
                {
                    description = (string)node.Element(language).Attribute("Name");
                }

                // This will be used to index into the header file to find the GUID
                string uniqueName = (string)node.Element("Unique").Attribute("Name");
                bool colorSupported = ((string)node.Attribute("ColorAdjustable")) == "True";

                Regex replacementRegex = new Regex("[\\s'-]");
                string cleanedName = replacementRegex.Replace(uniqueName, "_");

                if (_assetIdTable.ContainsKey(cleanedName.ToLower()))
                {
                    Guid assetId = _assetIdTable[cleanedName.ToLower()];

                    TocAsset avatarAsset = new TocAsset() { 
                        Description = description, 
                        Id = assetId, 
                        ColorSupported = colorSupported 
                    };

                    // Now add custom colors for the asset (if they exist)
                    IEnumerable<XElement> colorNodes =
                        from el in node.Descendants("Color")
                        select el;

                    foreach (XElement colorNode in colorNodes)
                    {
                        string rgbValue = ConvertStringToHexRGB((string)colorNode.Attribute("RGB"));
                        if (!String.IsNullOrEmpty(rgbValue))
                        {
                            avatarAsset.ColorRGBValues.Add(rgbValue);
                        }
                    }

                    assetList.Add(avatarAsset);
                }
                else
                {
                    _errorLog.WriteLine("An ID was not found for an asset and will not be included in the XML:  {0}", cleanedName);
                }
            }

            return assetList;
        }

        private string ConvertStringToHexRGB(string rawRGBValues)
        {
            if (String.IsNullOrEmpty(rawRGBValues))
            {
                _errorLog.WriteLine("Unable to find the RGB color value for the asset.  Color value will not be included.");
                return String.Empty;
            }

            string[] colorChannels = rawRGBValues.Split(':');

            if (colorChannels.Length != 3)
            {
                _errorLog.WriteLine("The format of the RGB color value provided is invalid:  {0}.  The color will be skipped.", rawRGBValues);
                return String.Empty;
            }

            string hexColor = String.Format("#{0:X2}{1:X2}{2:X2}", Int32.Parse(colorChannels[0]), Int32.Parse(colorChannels[1]), Int32.Parse(colorChannels[2]));

            return hexColor;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\Logger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Avatar.Services.Tools.TocBuilder
{
    public class Logger
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public void Write(string message)
        {
            MessageEventArgs e = new MessageEventArgs(message);
            OnMessageNotifier(e);
        }

        public void WriteLine()
        {
            Write("\r\n");
        }

        public void WriteLine(string value)
        {
            Write(value);
            Write("\r\n");
        }

        public void WriteLine(string format, params object[] arg)
        {
            WriteLine(String.Format(format, arg));
        }

        /// <summary>
        /// 
        /// </summary>
        public event MessageEventHandler OnMessage;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        protected virtual void OnMessageNotifier(MessageEventArgs e)
        {
            if (OnMessage != null)
            {
                // Invokes the delegates. 
                OnMessage(this, e);
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public delegate void MessageEventHandler(object sender, MessageEventArgs e);

    /// <summary>
    /// 
    /// </summary>
    public class MessageEventArgs : EventArgs
    {
        private string message = "";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public MessageEventArgs(string message)
        {
            Message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return message; }
            set
            {
                if (value == null)
                {
                    message = "";
                }
                else
                {
                    message = value;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Tools.TocBuilder\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Tools.TocBuilder")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2e2f1ff3-a7b0-4ac1-ac86-0d60da33ceec")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client\IGameMetadataClient.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GameMetadata.Common;

namespace GameMetadata.Client
{
    public interface IGameMetadataClient
    {
        /// <summary>
        /// Get a Game Metadata Composite for the given GameID, localized in the given locale (or fallback locale if that locale is unavailable).
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <param name="locale">The locale to retrieve localized information for.</param>
        /// <returns>Returns a GameMetadataComposite object for valid GameIDs, null for invalid GameIDs</returns>
        GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale);
        
        /// <summary>
        /// Get a Game Metadata Composite for the given GameID and VariantID, localized in the given locale (or fallback locale if that locale is unavailable).
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <param name="locale">The locale to retrieve localized information for.</param>
        /// <param name="variantId">The specific VariantID to retrieve information about</param>
        /// <returns>Returns a GameMetadataComposite object for valid GameIDs.  If VariantID is invalid for the given GameID, returns information about the default Variant for that game.  Returns null for invalid GameIDs</returns>
        GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId);

        /// <summary>
        /// Get a profile redirection URL for a given identity token
        /// </summary>
        /// <param name="identityToken">Gamertag</param>
        /// <returns>fully qualified URL</returns>
        string GetProfileRedirectionUrl(string gamertag);

        /// <summary>
        /// Get a game redirection URL for a given GameID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <returns>fully qualified URL</returns>
        string GetGameRedirectionUrl(UInt32 gameId);
        
        /// <summary>
        /// Get a game redirection URL for a given GameID and VariantID combo
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <param name="variantId">The target VariantID (this will be validated at redirection time)</param>
        /// <returns>fully qualified URL</returns>
        string GetGameRedirectionUrl(UInt32 gameId, UInt32 variantId);

        /// <summary>
        /// Get a game session redirection URL (for invites and turn notifications) for a given GameID and SessionID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <param name="sessionId">Target SessionID</param>
        /// <returns>fully qualified URL</returns>
        string GetGameSessionRedirectionUrl(UInt32 gameId, string sessionId);

        /// <summary>
        /// Get the default Game Variant information for a given GameID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <returns>A GameVaraintComposite if the GameID is valid, null if the GameID is invalid</returns>
        GameVariantComposite GetGameVariant(UInt32 gameId);
        
        /// <summary>
        /// Get the default Game Variant information for a given GameID and VariantID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <param name="variantId">The target VariantID</param>
        /// <returns>A GameVaraintComposite for the given VariantID if both GameID and VariantID are valid, a GameVariantComposite for the default Variant if the VariantID is invalid but the GameID is valid, null if the GameID is invalid</returns>
        GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId);

        /// <summary>
        /// Get a list of VariantIDs for a given GameID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <returns>A list of VariantIDs (there will always be at least one in the list) if the GameID is valid, an empty list if the GameID is invalid</returns>
        List<UInt32> GetGameVariantIds(UInt32 gameId);

        /// <summary>
        /// Get a dictionary of VariantIDs and GameVariantComposits for a given GameID
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <returns>A dictionary of VariantIDs and GameVariantComposits (there will always be at least one in the list) if the GameID is valid, an empty dictionary if the GameID is invalid</returns>
        Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId);

        /// <summary>
        /// Check whether the given GameID is valid
        /// </summary>
        /// <param name="gameId">The GameID/TitleID of the target title</param>
        /// <returns></returns>
        bool CheckIsValidGameId(UInt32 gameId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client\GameMetadataServiceShim.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GameMetadata.Common;
using Leet.Core.Wcf;

namespace GameMetadata.Client
{
    public class GameMetadataServiceShim : IGameMetadataService
    {
        private readonly IWcfProxyFactory<IGameMetadataService> factory;

        public GameMetadataServiceShim(IWcfProxyFactory<IGameMetadataService> factory)
        {
            if (factory == null)
            {
                throw new ArgumentNullException("factory");
            }

            this.factory = factory;
        }

        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId)
        {
            return factory.Send(proxy => proxy.GetGameMetadata(gameId, locale, variantId));
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId)
        {
            return factory.Send(proxy => proxy.GetGameVariant(gameId, variantId));
        }

        public List<UInt32> GetGameVariantIds(UInt32 gameId)
        {
            return factory.Send(proxy => proxy.GetGameVariantIds(gameId));
        }

        public Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId)
        {
            return factory.Send(proxy => proxy.GetGameVariants(gameId));
        }

        public bool CheckIsValidGameId(UInt32 gameId)
        {
            return factory.Send(proxy => proxy.CheckIsValidGameId(gameId));
        }

        public Dictionary<int, string> GetRedirectionUrlFormats()
        {
            return factory.Send(proxy => proxy.GetRedirectionUrlFormats());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client\GameMetadataClient.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GameMetadata.Common;
using Leet.Core.IoCCo;
using Leet.Core.Wcf;
using System.Collections;
using System.Globalization;

namespace GameMetadata.Client
{
    internal class CacheObject
    {
        public Object Data { get; private set; }
        public DateTime LastSync { get; private set; }

        public CacheObject(object data, DateTime timstamp)
        {
            Data = data;
            LastSync = timstamp;
        }
    }

    public class GameMetadataClient : IGameMetadataClient
    {
        private const UInt32 DEFAULTVARIANTID = 0;
        private const UInt32 CacheExpiryHours = 1;

        // The following key format strings MUST generate unique strings,
        // Hence they contain pre-ambles making them unique accross.
        // NOTE: variantId and sessionId MAY end up having the same strings otherwise.
        // NOTE: gamertag and gameId COULD end up having the same string otherwise.
        // gameId-locale-variantId
        private const string GetGameMetadataKeyFormat = "GGM{0}-{1}-{2}";
        // gamertag
        private const string GetProfileRedirectionUrlKeyFormat = "GPRU{0}";
        // gameId-variantId
        private const string GetGameRedirectionUrlKeyFormat = "GGRU{0}-{1}";
        // gameId-sessionId
        private const string GetGameSessionRedirectionUrlKeyFormat = "GGSRU{0}-{1}";
        // gameId-variantId
        private const string GetGameVariantKeyFormat = "GGV{0}-{1}";
        // gameId
        private const string GetGameVariantIdsKeyFormat = "GGVI{0}";
        // gameId
        private const string GetGameVariantsKeyFormat = "GGVs{0}";
        // gameId
        private const string CheckIsValidGameIdKeyFormat = "CIVGI{0}";


        private static Hashtable CacheResponses;

        /// <summary>
        /// Register all of the services in the IOC container required for the client to establish a connection to the service.
        /// </summary>
        public static void RegisterContainerServices()
        {
            Container.Instance.AddService<IEndpointConfigurator<IGameMetadataService>, EndpointConfigurator<IGameMetadataService>>();
            Container.Instance.AddService<IWcfProxyFactory<IGameMetadataService>, ServerProxyFactory<IGameMetadataService>>();
            Container.Instance.AddService<IGameMetadataService, GameMetadataServiceShim>();
            Container.Instance.AddEmulatableService<IGameMetadataClient, GameMetadataClient>();
            CacheResponses = new Hashtable();
            // Creates a synchronized wrapper around the Hashtable.
            CacheResponses = Hashtable.Synchronized(CacheResponses);
        }

        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale)
        {
            return GetGameMetadata(gameId, locale, DEFAULTVARIANTID);
        }

        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId)
        {
            string key = String.Format(GetGameMetadataKeyFormat, gameId, locale, variantId);
            GameMetadataComposite retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (GameMetadataComposite) ((CacheObject) CacheResponses[key]).Data;
            }
            else
            {
                retVal = Service.GetGameMetadata(gameId, locale, variantId);
                CacheResponses[key]= new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        public string GetProfileRedirectionUrl(string gamertag)
        {
            string key = String.Format(GetProfileRedirectionUrlKeyFormat, gamertag);
            string retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (string)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = String.Format(GetRedirectionUrlFormatString(RedirectionUrlType.Profile), gamertag);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        public string GetGameRedirectionUrl(UInt32 gameId)
        {
            return GetGameRedirectionUrl(gameId, DEFAULTVARIANTID);
        }

        public string GetGameRedirectionUrl(UInt32 gameId, UInt32 variantId)
        {
            string key = String.Format(GetGameRedirectionUrlKeyFormat, gameId, variantId);
            string retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (string)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = String.Format(GetRedirectionUrlFormatString(RedirectionUrlType.Game), gameId, variantId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
         }

        public string GetGameSessionRedirectionUrl(UInt32 gameId, string sessionId)
        {
            string key = String.Format(GetGameSessionRedirectionUrlKeyFormat, gameId, sessionId);
            string retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (string)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = String.Format(GetRedirectionUrlFormatString(RedirectionUrlType.GameSession), gameId, sessionId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId)
        {
            return GetGameVariant(gameId, DEFAULTVARIANTID);
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId)
        {
            string key = String.Format(GetGameVariantKeyFormat, gameId, variantId);
            GameVariantComposite retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (GameVariantComposite)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = Service.GetGameVariant(gameId, variantId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        public List<UInt32> GetGameVariantIds(UInt32 gameId)
        {
            string key = string.Format(GetGameVariantIdsKeyFormat, gameId);
            List<UInt32> retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (List<UInt32>)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = Service.GetGameVariantIds(gameId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
         }

        public Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId)
        {
            string key = string.Format(GetGameVariantsKeyFormat, gameId);
            Dictionary<UInt32, GameVariantComposite> retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (Dictionary<UInt32, GameVariantComposite>)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = Service.GetGameVariants(gameId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        public bool CheckIsValidGameId(UInt32 gameId)
        {
            string key = string.Format(CheckIsValidGameIdKeyFormat, gameId);
            bool retVal;

            if (CacheResponses.ContainsKey(key) && ((CacheObject)CacheResponses[key]).LastSync.AddHours(CacheExpiryHours) > DateTime.Now)
            {
                retVal = (bool)((CacheObject)CacheResponses[key]).Data;
            }
            else
            {
                retVal = Service.CheckIsValidGameId(gameId);
                CacheResponses[key] = new CacheObject(retVal, DateTime.Now);
            }
            return retVal;
        }

        private IGameMetadataService Service
        {
            get { return Container.Instance.GetComponent<IGameMetadataService>(); }
        }


        private Dictionary<int, string> _serviceFormatStrings;
        private DateTime _serviceFormatStringsLastUpdated = DateTime.MinValue;
        private Dictionary<int, string> ServiceFormatStrings
        {
            get
            {
                // if we haven't gotten the list or it's more than 6 hours old..
                if ((_serviceFormatStrings == null) || (_serviceFormatStringsLastUpdated < DateTime.Now.AddHours(-6)))
                {
                    _serviceFormatStrings = Service.GetRedirectionUrlFormats();
                    _serviceFormatStringsLastUpdated = DateTime.Now;
                }
                return _serviceFormatStrings;
            }
        }

        private string GetRedirectionUrlFormatString(RedirectionUrlType urlType)
        {
            string formatString = String.Empty;
            if (ServiceFormatStrings.TryGetValue((int)urlType, out formatString))
            {
                return formatString;
            }
            throw new ArgumentException(String.Format("No Redirection Url Format String defined for {0}", urlType), "urlType");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client\FakeGameMetadataClient.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GameMetadata.Common;
using System.Globalization;

namespace GameMetadata.Client
{
    /// <summary>
    /// Mock GameMetadataClient that returns predictable data based on method inputs.
    /// </summary>
    public class FakeGameMetadataClient : IGameMetadataClient
    {
        private const UInt32 DEFAULTVARIANTID = 0;

        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale)
        {
            return GetGameMetadata(gameId, locale, DEFAULTVARIANTID);
        }

        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId)
        {
            if (!CheckIsValidGameId(gameId))
                return null;

            GameMetadataComposite gmc = new GameMetadataComposite();
            gmc.GameId = gameId;
            gmc.VariantId = variantId;
            gmc.GameAndVariantName = String.Format("Game and Variant Name for {0}:{1} in {2}", gameId, variantId, locale);
            gmc.GameName = String.Format("Base Game Name for {0} in {1}", gameId, locale);
            gmc.GameRedirectionUrl = GetGameRedirectionUrl(gameId, variantId);
            gmc.Images.Add(ImageType.GameTile_WebSmall, new GameImageComposite { ImageUrl = String.Format("http://icons.xboxlive.com/{0}/{1}/GameTile_WebSmall.png", gameId, variantId), Height = 32, Width = 32, ImageType = ImageType.GameTile_WebSmall });
            gmc.Images.Add(ImageType.GameTile_WebLarge, new GameImageComposite { ImageUrl = String.Format("http://icons.xboxlive.com/{0}/{1}/GameTile_WebLarge.png", gameId, variantId), Height = 64, Width = 64, ImageType = ImageType.GameTile_WebLarge });
            gmc.Images.Add(ImageType.GameTile_MobileSmall, new GameImageComposite { ImageUrl = String.Format("http://icons.xboxlive.com/{0}/{1}/GameTile_MobileSmall.png", gameId, variantId), Height = 99, Width = 99, ImageType = ImageType.GameTile_MobileSmall });
            gmc.Images.Add(ImageType.GameTile_MobileLarge, new GameImageComposite { ImageUrl = String.Format("http://icons.xboxlive.com/{0}/{1}/GameTile_MobileLarge.png", gameId, variantId), Height = 173, Width = 173, ImageType = ImageType.GameTile_MobileLarge });
            gmc.IsUsingFallbackLocale = false;
            gmc.LocalizationLocale = locale;
            gmc.UsesLiveMultiplayerServices = (gameId % 2 == 1);

            // Putting in 7777 because there is no number that is odd and also divisible by 6.
            // Hence, unless we explicitly allow a gameId, there can be no live multiplayer game on mobile platform (platformId: 5).
            if (gameId % 6 <= 0 || gameId == 7777 || gameId == 1297287394)
                gmc.SupportedPlatforms.Add(5);
            if (gameId % 6 <= 1)
                gmc.SupportedPlatforms.Add(4);
            if (gameId % 6 <= 2)
                gmc.SupportedPlatforms.Add(3);
            if (gameId % 6 <= 3)
                gmc.SupportedPlatforms.Add(2);
            if (gameId % 6 <= 4)
                gmc.SupportedPlatforms.Add(1);
            if (gameId % 6 <= 5)
                gmc.SupportedPlatforms.Add(0);

            return gmc;
        }

        public string GetProfileRedirectionUrl(string gamertag)
        {
            return String.Format("http://profileredirect.xboxlive.com/{0}/", gamertag);
        }

        public string GetGameRedirectionUrl(UInt32 gameId)
        {
            return GetGameRedirectionUrl(gameId, DEFAULTVARIANTID);
        }

        public string GetGameRedirectionUrl(UInt32 gameId, UInt32 variantId)
        {
            return String.Format("http://gameredirect.xboxlive.com/{0}/{1}/", gameId, variantId);
        }

        public string GetGameSessionRedirectionUrl(UInt32 gameId, string sessionId)
        {
            return String.Format("http://gamesessionredirect.xboxlive.com/{0}/{1}/", gameId, sessionId);
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId)
        {
            return GetGameVariant(gameId, DEFAULTVARIANTID);
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId)
        {
            if (!CheckIsValidGameId(gameId))
                return null;

            GameVariantComposite gvc = new GameVariantComposite();
            gvc.GameId = gameId;
            gvc.VariantId = variantId;
            switch (variantId % 4)
            {
                case 0:
                    gvc.StatRankings.Add("BestScore", StatRanking.High);
                    break;
                case 1:
                    gvc.StatRankings.Add("BestScore", StatRanking.High);
                    gvc.StatRankings.Add("BestTime", StatRanking.High);
                    gvc.StatRankings.Add("Wins", StatRanking.High);
                    break;
                case 2:
                    gvc.StatRankings.Add("BestTime", StatRanking.High);
                    break;
                case 3:
                    gvc.StatRankings.Add("BestTime", StatRanking.Low);
                    break;
            }
            return gvc;
        }

        public List<UInt32> GetGameVariantIds(UInt32 gameId)
        {
            if (!CheckIsValidGameId(gameId))
                return new List<UInt32>();

            List<UInt32> variants = new List<UInt32>();

            if (gameId % 4 <= 0)
                variants.Add(3);
            if (gameId % 4 <= 1)
                variants.Add(2);
            if (gameId % 4 <= 2)
                variants.Add(1);
            if (gameId % 4 <= 3)
                variants.Add(0);

            return variants;
        }

        public Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId)
        {
            if (!CheckIsValidGameId(gameId))
                return new Dictionary<UInt32, GameVariantComposite>();

            Dictionary<UInt32, GameVariantComposite> variants = new Dictionary<UInt32, GameVariantComposite>();
            List<UInt32> variantIds = GetGameVariantIds(gameId);
            foreach (UInt32 variantId in variantIds)
            {
                variants.Add(variantId, GetGameVariant(gameId, variantId));
            }
            return variants;
        }

        public bool CheckIsValidGameId(UInt32 gameId)
        {
            if (gameId % 100 == 0) // have 1% of random GameIDs be treated as invalid
            {
                return false;
            }
            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Client")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("70bd9d22-80fb-4f5d-9c09-a26cdde9ad9b")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client.Test\GameMetadataClientTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using Rhino.Mocks;
using Leet.Core.Configuration;
using GameMetadata.Common;
using GameMetadata.Client;

namespace GameMetadata.Client.Test
{
    [TestClass]
    public class GameMetadataClientTest
    {
        [TestMethod]
        public void TestCheckIsValidGameId()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.CheckIsValidGameId(Arg<UInt32>.Is.Anything)).Return(true);

            GameMetadataClient gmc = new GameMetadataClient();

            gmc.CheckIsValidGameId((uint)10);

            service.AssertWasCalled(c => c.CheckIsValidGameId((uint)10));
        }

        [TestMethod]
        public void TestGetGameMetadata()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.GetGameMetadata(Arg<uint>.Is.Anything, Arg<string>.Is.Anything, Arg<uint>.Is.Anything)).Return(new GameMetadataComposite());

            GameMetadataClient gmc = new GameMetadataClient();

            // call with no VariantID
            gmc.GetGameMetadata((uint)10, "en-US");
            service.AssertWasCalled(c => c.GetGameMetadata((uint)10, "en-US", (uint)0));

            // call with defined VariantID
            gmc.GetGameMetadata((uint)10, "en-US", (uint)4);
            service.AssertWasCalled(c => c.GetGameMetadata((uint)10, "en-US", (uint)4));
        }

        [TestMethod]
        public void TestGetGameVariant()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.GetGameVariant(Arg<uint>.Is.Anything, Arg<uint>.Is.Anything)).Return(new GameVariantComposite());

            GameMetadataClient gmc = new GameMetadataClient();

            // call with no VariantID
            gmc.GetGameVariant((uint)10);
            service.AssertWasCalled(c => c.GetGameVariant((uint)10, (uint)0));

            // call with defined VariantID
            gmc.GetGameVariant((uint)10, (uint)4);
            service.AssertWasCalled(c => c.GetGameVariant((uint)10, (uint)4));
        }

        [TestMethod]
        public void TestGetGameVariantIds()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.GetGameVariantIds(Arg<uint>.Is.Anything)).Return(new List<uint>());

            GameMetadataClient gmc = new GameMetadataClient();

            gmc.GetGameVariantIds((uint)10);
            service.AssertWasCalled(c => c.GetGameVariantIds((uint)10));
        }

        [TestMethod]
        public void TestGetGameVariants()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.GetGameVariants(Arg<uint>.Is.Anything)).Return(new Dictionary<uint, GameVariantComposite>());

            GameMetadataClient gmc = new GameMetadataClient();

            gmc.GetGameVariants((uint)10);
            service.AssertWasCalled(c => c.GetGameVariants((uint)10));
        }

        [TestMethod]
        public void TestRedirectionUrls()
        {
            Stubber stubber = new Stubber();
            IGameMetadataService service = stubber.RegisterWithContainer<IGameMetadataService>();
            service.Stub(c => c.GetRedirectionUrlFormats()).Return(new Dictionary<int, string>(){ {(int)RedirectionUrlType.Game,""} });

            GameMetadataClient gmc = new GameMetadataClient();

            gmc.GetGameRedirectionUrl((uint)10);
            service.AssertWasCalled(c => c.GetRedirectionUrlFormats());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\GameVariantComposite.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Runtime.Serialization;

namespace GameMetadata.Common
{
    public enum StatRanking : int
    {
        High,
        Low,
    }

    [DataContract]
    public class GameVariantComposite
    {
        private IDictionary<string, StatRanking> _statRankings = new Dictionary<string, StatRanking>();

        [DataMember]
        public IDictionary<string, StatRanking> StatRankings
        {
            get { return this._statRankings; }
            private set { this._statRankings = value; }
        }

        [DataMember]
        [DefaultValue(0)]
        public UInt32 GameId { get; set; }

        [DataMember]
        [DefaultValue(0)]
        public UInt32 VariantId { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\ImageType.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GameMetadata.Common
{
    public enum ImageType
    {
        GameTile_WebSmall = 1, // 32x32
        GameTile_WebLarge = 2, // 64x64
        GameTile_MobileSmall = 3, // 99x99
        GameTile_MobileLarge = 4, // 179x179
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\RedirectionUrlType.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GameMetadata.Common
{
    public enum RedirectionUrlType
    {
        Profile = 1,
        Game = 2,
        GameSession = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Client.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Client.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c3df9d85-e8c2-4b51-aa2f-92c4664b1dbd")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\Diagnostics.cs ===
﻿

namespace GameMetadata.Common
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;
    public class GmsDiagnostics
    {
    
        public static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public class ServiceStarted : BaseEvent
    {
        public ServiceStarted()
            : base(40000, TraceEventType.Information, "Service started.")
        {
        }
    }

    public class ServiceStopped : BaseEvent
    {
        public ServiceStopped()
            : base(40001, TraceEventType.Information, "Service stopped.")
        {
        }
    }

    public class SqlExceptionError : BaseEvent
    {
        public SqlExceptionError()
            : base(40002, TraceEventType.Error, "A Sql exception has occurred.")
        {
        }
    }

    public class ErrorLoadingXml : BaseEvent
    {
        public ErrorLoadingXml()
            : base(40003, TraceEventType.Warning, "An error in loading XML that was passed to ingestion service.")
        {
        }
    }

    public class ErrorConfiguringGame : BaseEvent
    {
        public ErrorConfiguringGame()
            : base(40004, TraceEventType.Warning, "An error in configuring game has occurred.")
        {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\IGameMetadataService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;

namespace GameMetadata.Common
{
    [ServiceContract]
    public interface IGameMetadataService
    {
        [OperationContract]
        GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId);

        [OperationContract]
        GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId);

        [OperationContract]
        List<UInt32> GetGameVariantIds(UInt32 gameId);

        [OperationContract]
        Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId);

        [OperationContract]
        bool CheckIsValidGameId(UInt32 gameId);

        [OperationContract]
        Dictionary<int, string> GetRedirectionUrlFormats();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\GameImageComposite.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;
using System.ComponentModel;

namespace GameMetadata.Common
{
    public class GameImageComposite
    {
        [DataMember]
        [DefaultValue("")]
        public string ImageUrl { get; set; }

        [DataMember]
        [DefaultValue(0)]
        public int Height { get; set; }

        [DataMember]
        [DefaultValue(0)]
        public int Width { get; set; }

        [DataMember]
        [DefaultValue(ImageType.GameTile_WebSmall)]
        public ImageType ImageType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\Mix\ContentIngestion\ServiceContract.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.ComponentModel;

namespace GameMetadata.Common.Mix.ContentIngestion
{
    [ServiceContract(Namespace = "http://gamemetadata.common.mix.contentingestion/V1")]
    public interface IIngestionService
    {
        [OperationContract]
        void ConfigureGame(Game game);

        [OperationContract]
        bool ConfigureGameViaXml(string gameXml);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\GameMetadataComposite.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Runtime.Serialization;
using System.Collections;

namespace GameMetadata.Common
{
    [DataContract]
    public class GameMetadataComposite
    {
        private IList<UInt32> _supportedPlatforms = new List<UInt32>();

        private IDictionary<ImageType, GameImageComposite> _imageUrls = new Dictionary<ImageType, GameImageComposite>();

        [DataMember]
        [DefaultValue(false)]
        public bool IsUsingFallbackLocale { get; set; }

        [DataMember]
        [DefaultValue("")]
        public string LocalizationLocale { get; set; }

        [DataMember]
        [DefaultValue("")]
        public string GameName { get; set; }

        [DataMember]
        [DefaultValue("")]
        public string GameAndVariantName { get; set; }

        [DataMember]
        [DefaultValue("")]
        public string GameRedirectionUrl { get; set; }

        [DataMember]
        public IDictionary<ImageType, GameImageComposite> Images
        {
            get { return this._imageUrls; }
            private set { this._imageUrls = value; }
        }

        [DataMember]
        public IList<UInt32> SupportedPlatforms
        {
            get { return this._supportedPlatforms; }
            private set { this._supportedPlatforms = value; }
        }

        [DataMember]
        public uint SupportedPlatformsBitMask { get; set; }

        [DataMember]
        [DefaultValue(0)]
        public UInt32 GameId { get; set; }

        [DataMember]
        [DefaultValue(0)]
        public UInt32 VariantId { get; set; }

        [DataMember]
        [DefaultValue(false)]
        public bool UsesLiveMultiplayerServices { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\GameMetadataCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;

namespace GameMetadata.GameMetadataStore
{
    public class GameMetadataCollection
    {
        public DateTime Created { get; set; }

        private Dictionary<UInt32, GameInformation> games = new Dictionary<UInt32, GameInformation>();
        public Dictionary<UInt32, GameInformation> Games
        {
            get { return games; }
            private set { games = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\Mix\ContentIngestion\DataContract.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.ComponentModel;
using System.Xml;
using System.IO;

namespace GameMetadata.Common.Mix.ContentIngestion
{
    [DataContract(Namespace = "http://xonline.mix.contentingestion.contracts/V1")]
    public class Game
    {
        [DataMember]
        public UInt32 Id { get; set; }

        [DataMember]
        public int VisibiltyStatus { get; set; }

        [DataMember]
        [DefaultValue(false)]
        public bool UsesLiveMultiplayerServices { get; set; }

        [DataMember]
        public UInt32[] AvailablePlatforms { get; set; }

        [DataMember]
        public LocalizedData[] LocalizedData { get; set; }

        [DataMember]
        public GameImage[] Images { get; set; }

        [DataMember]
        public GameVariant[] Variants { get; set; }

        #region ToStoreXml
        public string ToStoreXml()
        {
            StringWriter stringWriter = new StringWriter();

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.OmitXmlDeclaration = true;
            settings.Indent = true;

            XmlWriter writer = XmlWriter.Create(stringWriter, settings);

            writer.Settings.OmitXmlDeclaration = true;

            writer.WriteStartElement("game");
            writer.WriteAttributeString("id", this.Id.ToString());
            writer.WriteAttributeString("visibility", this.VisibiltyStatus.ToString());
            writer.WriteAttributeString("usesLiveMultiplayerServices", this.UsesLiveMultiplayerServices ? "1" : "0");

            if (this.LocalizedData != null)
            {
                // localized names
                writer.WriteStartElement("localizedNames");
                foreach (LocalizedData localizedData in this.LocalizedData)
                {
                    writer.WriteStartElement("name");
                    writer.WriteAttributeString("locale", localizedData.Locale);
                    writer.WriteCData(localizedData.Name);
                    writer.WriteEndElement(); // name
                }
                writer.WriteEndElement(); // localizedNames
            }

            if (this.Images != null)
            {
                // images
                writer.WriteStartElement("images");
                foreach (GameImage img in this.Images)
                {
                    writer.WriteStartElement("image");
                    writer.WriteAttributeString("type", img.ImageType.ToString());
                    writer.WriteCData(img.ImageUrl);
                    writer.WriteEndElement(); // image
                }
                writer.WriteEndElement(); // images
            }

            if (this.AvailablePlatforms != null)
            {
                // available platforms
                writer.WriteStartElement("availablePlatforms");
                foreach (UInt32 platformId in this.AvailablePlatforms)
                {
                    writer.WriteStartElement("platform");
                    writer.WriteAttributeString("id", platformId.ToString());
                    writer.WriteEndElement(); // platform
                }
                writer.WriteEndElement(); // availablePlatforms
            }

            writer.WriteStartElement("variants");
            foreach (GameVariant variant in this.Variants)
            {
                writer.WriteStartElement("variant");
                writer.WriteAttributeString("id", variant.Id.ToString());

                if (variant.StatRankings != null)
                {
                    // stat rankings
                    writer.WriteStartElement("statRankings");
                    foreach (StatRanking statRanking in variant.StatRankings)
                    {
                        writer.WriteStartElement("stat");
                        writer.WriteAttributeString("name", statRanking.StatName);
                        writer.WriteAttributeString("preferHighValues", statRanking.PreferHighValues ? "1" : "0");
                        writer.WriteEndElement(); // stat
                    }
                    writer.WriteEndElement(); // statRankings
                }

                if (variant.LocalizedData != null)
                {
                    // localized names
                    writer.WriteStartElement("localizedNames");
                    foreach (LocalizedData localizedData in variant.LocalizedData)
                    {
                        writer.WriteStartElement("name");
                        writer.WriteAttributeString("locale", localizedData.Locale);
                        writer.WriteCData(localizedData.Name);
                        writer.WriteEndElement(); // name
                    }
                    writer.WriteEndElement(); // localizedNames
                }


                writer.WriteEndElement(); // variant;
            }
            writer.WriteEndElement(); // variants

            writer.WriteEndElement(); // game

            writer.Flush();
            writer.Close();
            stringWriter.Flush();

            return stringWriter.ToString();

        }
        #endregion
    }

    [DataContract(Namespace = "http://xonline.mix.contentingestion.contracts/V1")]
    public class GameVariant
    {
        [DataMember]
        [DefaultValue(0)]
        public UInt32 Id { get; set; }

        [DataMember]
        public LocalizedData[] LocalizedData { get; set; }

        [DataMember]
        public StatRanking[] StatRankings { get; set; }
    }

    [DataContract(Namespace = "http://xonline.mix.contentingestion.contracts/V1")]
    public class LocalizedData
    {
        [DataMember]
        public string Locale { get; set; }

        [DataMember]
        public string Name { get; set; }
    }

    [DataContract(Namespace = "http://xonline.mix.contentingestion.contracts/V1")]
    public class StatRanking
    {
        [DataMember]
        public string StatName { get; set; }

        [DataMember]
        [DefaultValue(true)]
        public bool PreferHighValues { get; set; }
    }

    [DataContract(Namespace = "http://xonline.mix.contentingestion.contracts/V1")]
    public class GameImage
    {
        [DataMember]
        public int ImageType { get; set; }

        [DataMember]
        public string ImageUrl { get; set; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\IGameMetadataStore.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web.Caching;

namespace GameMetadata.GameMetadataStore
{
    public interface IGameMetadataStore
    {
        GameMetadataCollection GetGameMetadataCollection();
        void ConfigureGame(string gameXml);
        CacheDependency GetGameMetadataCollectionCacheDependency();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Common\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("39e24f1a-b06c-45b7-b39e-9e09ca517e72")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\GameVariantInformation.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GameMetadata.GameMetadataStore
{
    public class GameVariantInformation
    {
        private Dictionary<string, string> localizedNames = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
        public Dictionary<string, string> LocalizedNames
        {
            get { return localizedNames; }
            private set { localizedNames = value; }
        }

        private Dictionary<string, bool> statRankings = new Dictionary<string, bool>(StringComparer.InvariantCultureIgnoreCase);
        public Dictionary<string, bool> StatRankings
        {
            get { return statRankings; }
            private set { statRankings = value; }
        }


        public string GetName(string targetLocale)
        {
            string usedLocale;
            return GetName(targetLocale, out usedLocale);
        }

        public string GetName(string targetLocale, out string usedLocale)
        {
            return LocalizationHelper.GetLocalizedString(LocalizedNames, targetLocale, out usedLocale);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\IGameMetadataStoreDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data;
using System.Web.Caching;

namespace GameMetadata.GameMetadataStore
{
    public interface IGameMetadataStoreDataAccess
    {
        IDataReader GetPublishedGameMetadata();
        CacheDependency GetPublishedGameMetadataCacheDependency();

        void ConfigureGame(string gameXml);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\GameInformation.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Collections;
using GameMetadata.Common;

namespace GameMetadata.GameMetadataStore
{
    public class GameInformation
    {
        public bool UsesLiveMultiplayerServices { get; set; }

        private List<UInt32> availablePlatforms = new List<UInt32>();
        public List<UInt32> AvailablePlatforms
        {
            get { return availablePlatforms; }
            private set { availablePlatforms = value; }
        }

        private Dictionary<string, string> localizedNames = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
        public Dictionary<string, string> LocalizedNames
        {
            get { return localizedNames; }
            private set { localizedNames = value; }
        }

        private Dictionary<ImageType, GameImageComposite> images = new Dictionary<ImageType, GameImageComposite>();
        public Dictionary<ImageType, GameImageComposite> Images
        {
            get { return images; }
            private set { images = value; }
        }

        private Dictionary<UInt32, GameVariantInformation> variants = new Dictionary<UInt32, GameVariantInformation>();
        public Dictionary<UInt32, GameVariantInformation> Variants
        {
            get { return variants; }
            private set { variants = value; }
        }

        public string GetName(string targetLocale)
        {
            string usedLocale;
            return GetName(targetLocale, out usedLocale);
        }

        public string GetName(string targetLocale, out string usedLocale)
        {
            return LocalizationHelper.GetLocalizedString(LocalizedNames, targetLocale, out usedLocale);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\SqlGameMetadataStore.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Web.Caching;
using GameMetadata.Common;
using Leet.Core.Utils;

namespace GameMetadata.GameMetadataStore
{
    public class SqlGameMetadataStore : IGameMetadataStore
    {
        private IGameMetadataStoreDataAccess _da;

        public SqlGameMetadataStore(IGameMetadataStoreDataAccess da)
        {
            _da = da;
        }

        public void ConfigureGame(string gameXml)
        {
            _da.ConfigureGame(gameXml);
        }

        public GameMetadataCollection GetGameMetadataCollection()
        {
            GameMetadataCollection collection = new GameMetadataCollection();

            try
            {

                using (IDataReader reader = this._da.GetPublishedGameMetadata())
                {
                    PopulateGameIds(reader, collection);
                    PopulateAvailablePlatforms(reader, collection);
                    PopulateGameNames(reader, collection);
                    PopulateGameImages(reader, collection);
                    PopulateGameVariants(reader, collection);
                    PopulateGameVariantNames(reader, collection);
                    PopulateGameVariantStatRankings(reader, collection);
                }
            }

            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex);
                throw;
            }

            collection.Created = DateTime.Now;
            return collection;
        }

        public CacheDependency GetGameMetadataCollectionCacheDependency()
        {
            return _da.GetPublishedGameMetadataCacheDependency();
        }

        private void PopulateGameIds(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int multiplayerOrdinal = reader.GetOrdinal("UsesLiveMultiplayerServices");
            UInt32 gameId;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                bool usesMultiplayerServices = reader.GetBoolean(multiplayerOrdinal);

                collection.Games[gameId] = new GameInformation() { UsesLiveMultiplayerServices = usesMultiplayerServices };
            }
            reader.NextResult();
        }

        private void PopulateAvailablePlatforms(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int platformIdOrdinal = reader.GetOrdinal("PlatformId");
            UInt32 gameId;
            UInt32 platformId;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                platformId = (UInt32)reader.GetInt32(platformIdOrdinal);

                collection.Games[gameId].AvailablePlatforms.Add(platformId);
            }
            reader.NextResult();
        }

        private void PopulateGameNames(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int localeOrdinal = reader.GetOrdinal("Locale");
            int gameNameOrdinal = reader.GetOrdinal("GameName");
            UInt32 gameId;
            string locale;
            string gameName;
            
            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                locale = reader.GetString(localeOrdinal);
                gameName = reader.GetString(gameNameOrdinal);

                collection.Games[gameId].LocalizedNames[locale] = gameName;
            }
            reader.NextResult();
        }

        private void PopulateGameImages(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int imageTypeOrdinal = reader.GetOrdinal("ImageType");
            int imageUrlOrdinal = reader.GetOrdinal("ImageUrl");
            int imageHeightOrdinal = reader.GetOrdinal("ImageHeight");
            int imageWidthOrdinal = reader.GetOrdinal("ImageWidth");
            UInt32 gameId;
            int imageType;
            string imageUrl;
            int imageHeight;
            int imageWidth;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                imageType = reader.GetInt32(imageTypeOrdinal);
                imageUrl = reader.GetString(imageUrlOrdinal);
                imageHeight = reader.GetInt32(imageHeightOrdinal);
                imageWidth = reader.GetInt32(imageWidthOrdinal);

                collection.Games[gameId].Images[(ImageType)imageType] = new GameImageComposite { ImageUrl = imageUrl, Height = imageHeight, Width = imageWidth, ImageType = (ImageType)imageType };

            }
            reader.NextResult();
        }

        private void PopulateGameVariants(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int variantIdOrdinal = reader.GetOrdinal("VariantId");
            UInt32 gameId;
            UInt32 variantId;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                variantId = (UInt32)reader.GetInt32(variantIdOrdinal);

                collection.Games[gameId].Variants[variantId] = new GameVariantInformation();
            }
            reader.NextResult();
        }

        private void PopulateGameVariantNames(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int variantIdOrdinal = reader.GetOrdinal("VariantId");
            int localeOrdinal = reader.GetOrdinal("Locale");
            int gameVariantNameOrdinal = reader.GetOrdinal("GameVariantName");
            UInt32 gameId;
            UInt32 variantId;
            string locale;
            string gameVariantName;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                variantId = (UInt32)reader.GetInt32(variantIdOrdinal);
                locale = reader.GetString(localeOrdinal);
                gameVariantName = reader.GetString(gameVariantNameOrdinal);

                collection.Games[gameId].Variants[variantId].LocalizedNames[locale] = gameVariantName;
            }
            reader.NextResult();
        }

        private void PopulateGameVariantStatRankings(IDataReader reader, GameMetadataCollection collection)
        {
            int gameIdOrdinal = reader.GetOrdinal("GameId");
            int variantIdOrdinal = reader.GetOrdinal("VariantId");
            int statNameOrdinal = reader.GetOrdinal("StatName");
            int preferHighValuesOrdinal = reader.GetOrdinal("PreferHighValues");
            UInt32 gameId;
            UInt32 variantId;
            string statName;
            bool preferHighValues;

            while (reader.Read())
            {
                gameId = (UInt32)reader.GetInt64(gameIdOrdinal);
                variantId = (UInt32)reader.GetInt32(variantIdOrdinal);
                statName = reader.GetString(statNameOrdinal);
                preferHighValues = reader.GetBoolean(preferHighValuesOrdinal);

                collection.Games[gameId].Variants[variantId].StatRankings[statName] = preferHighValues;
            }
            reader.NextResult();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\SqlGameMetadataStoreDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Web.Caching;
using GameMetadata.Common;
using Leet.Core.Utils;

namespace GameMetadata.GameMetadataStore
{
    public class SqlGameMetadataStoreDataAccess : IGameMetadataStoreDataAccess
    {
        public IDataReader GetPublishedGameMetadata()
        {
            return ExecuteReader("p_getPublishedGameMetadata");
        }

        public void ConfigureGame(string gameXml)
        {
            ExecuteNonQuery("p_configureGame",
                new SqlParameter("@xmlData", gameXml));
        }


        public CacheDependency GetPublishedGameMetadataCacheDependency()
        {
            SqlCacheDependency cacheDependency = null;
            try
            {
                using (SqlConnection connection = this.CreateConnection())
                {
                    SqlCommand cmd = new SqlCommand()
                    {
                        Connection = connection,
                        CommandType = CommandType.StoredProcedure,
                        CommandText = "p_getPublishedGameMetadataDependency"
                    };

                    cacheDependency = new SqlCacheDependency(cmd);

                    connection.Open();
                    cmd.ExecuteNonQuery();
                }
            }

            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex,"Sproc:{0}","p_getPublishedGameMetadataDependency");
                throw;
            }
          
            return cacheDependency;
        }


        #region SqlCommand helper methods

        private SqlConnection CreateConnection()
        {
            return new SqlConnection(SqlContentStoreConfiguration.Instance.ConnectionString);
        }

        private IDataReader ExecuteReader(string storedProcName, params SqlParameter[] parameters)
        {
            SqlCommand cmd = new SqlCommand()
            {
                Connection = this.CreateConnection(),
                CommandType = CommandType.StoredProcedure,
                CommandText = storedProcName
            };

            cmd.Parameters.AddRange(parameters);

            try
            {
                cmd.Connection.Open();
                return cmd.ExecuteReader(CommandBehavior.CloseConnection);
            }
            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex, "Sproc:{0}, Params:{1}", storedProcName, parameters);
                cmd.Connection.Close();
                throw;
            }            
        }

        private void ExecuteNonQuery(string storedProcName, params SqlParameter[] parameters)
        {
            try
            {
                using (SqlConnection connection = this.CreateConnection())
                {
                    SqlCommand cmd = new SqlCommand()
                    {
                        Connection = connection,
                        CommandType = CommandType.StoredProcedure,
                        CommandText = storedProcName
                    };

                    cmd.Parameters.AddRange(parameters);

                    connection.Open();
                    cmd.ExecuteNonQuery();
                }
            }
            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex, "Sproc:{0}, Params:{1}", storedProcName, parameters);
                throw;
            }        
            
        }

        private TReturn ExecuteScaler<TReturn>(string storedProcName, params SqlParameter[] parameters)
        {
            TReturn result = default(TReturn);
            try
            {

                using (SqlConnection connection = this.CreateConnection())
                {
                    SqlCommand cmd = new SqlCommand()
                    {
                        Connection = connection,
                        CommandType = CommandType.StoredProcedure,
                        CommandText = storedProcName
                    };

                    cmd.Parameters.AddRange(parameters);

                    connection.Open();
                    result = (TReturn)cmd.ExecuteScalar();
                }
            }
            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex, "Sproc:{0}, Params:{1}", storedProcName, parameters);
                throw;
            }

            return result;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\SqlGameMetadataStoreConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;

namespace GameMetadata.GameMetadataStore
{

    public class SqlContentStoreConfiguration
    {
        private static readonly SqlContentStoreConfiguration instance = new SqlContentStoreConfiguration();

        private SqlContentStoreConfiguration()
        {
        }

        public static SqlContentStoreConfiguration Instance
        {
            get { return instance; }
        }

        public string ConnectionString
        {
            get
            {
                return Container.Instance.GetComponent<IConfigurationProvider>().GetConnectionString("lest_gamemetadata_db");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\LocalizationHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;

namespace GameMetadata.GameMetadataStore
{
    public class LocalizationHelper
    {
        public static string GetLocalizedString(Dictionary<string, string> stringCollection, string targetLocale)
        {
            string usedLocale;
            return GetLocalizedString(stringCollection, targetLocale, out usedLocale);
        }

        public static string GetLocalizedString(Dictionary<string, string> stringCollection, string targetLocale, out string usedLocale)
        {
            string searchLocale = targetLocale.Trim();
            // try the passed in culture ("en-US")
            if (stringCollection.ContainsKey(searchLocale))
            {
                usedLocale = searchLocale;
                return stringCollection[usedLocale];
            }

            // couldn't find the locale, just try the language prefix ("en")
            if (searchLocale.Contains("-"))
            {
                searchLocale = searchLocale.Substring(0, searchLocale.IndexOf("-"));
            }
            else if (searchLocale.Length > 2) // oddly, no dash, just take the first two characters
            {
                searchLocale = searchLocale.Substring(0, 2);
            }
            if (stringCollection.ContainsKey(searchLocale))
            {
                usedLocale = searchLocale;
                return stringCollection[usedLocale];
            }

            // couldn't find that, just look for the default culture ("")
            searchLocale = "";
            if (stringCollection.ContainsKey(searchLocale))
            {
                usedLocale = searchLocale;
                return stringCollection[usedLocale];
            }

            // Fall back to en-US if "" is not present
            searchLocale = "en-US";
            if (stringCollection.ContainsKey(searchLocale))
            {
                usedLocale = searchLocale;
                return stringCollection[usedLocale];
            }

            // failed all the way through, really shouldn't happen, but return it in a manner that consumers can tell.
            usedLocale = null;
            return String.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.GameMetadataStore")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("49aa2a5a-bfd4-41b1-bdf5-bf40b50abc41")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore.Test\FakeGameMetadataStoreDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GameMetadata.GameMetadataStore;
using System.Data;
using GameMetadata.Common;
using System.Web.Caching;

namespace GameMetadata.GameMetadataStore.Test
{
    public class FakeGameMetadataStoreDataAccess : IGameMetadataStoreDataAccess
    {
        public void ConfigureGame(string gameXml)
        {
            // nothing to do.
        }

        public IDataReader GetPublishedGameMetadata()
        {
            DataSet ds = new DataSet();
            ds.Tables.Add(CreateGameIdDataTable());
            ds.Tables.Add(CreateGameAvailablePlatformDataTable());
            ds.Tables.Add(CreateGameNameDataTable());
            ds.Tables.Add(CreateGameImageDataTable());
            ds.Tables.Add(CreateGameVariantDataTable());
            ds.Tables.Add(CreateGameVariantNameDataTable());
            ds.Tables.Add(CreateGameVariantStatRankingTable());

            return ds.CreateDataReader();
        }

        public CacheDependency GetPublishedGameMetadataCacheDependency()
        {
            return null;  // no dependencies
        }

        private DataTable CreateGameIdDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("UsesLiveMultiplayerServices", typeof(bool));

            // Test Game IDs
            table.Rows.Add(10, true); // standard title
            table.Rows.Add(20, true); // no images and no default variant
            table.Rows.Add(30, true); // no variant stat rankings
            table.Rows.Add(40, true); // no variant names
            table.Rows.Add(50, true); // no variants at all
            table.Rows.Add(60, true); // no game names and no variants
            table.Rows.Add(70, true); // just a gameId, no other records.

            return table;
        }

        private DataTable CreateGameAvailablePlatformDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("PlatformId", typeof(int));

            table.Rows.Add(10, 1);
            table.Rows.Add(10, 2);

            table.Rows.Add(20, 1);
            table.Rows.Add(20, 3);

            table.Rows.Add(30, 1);
            table.Rows.Add(30, 4);
            
            table.Rows.Add(40, 1);
            table.Rows.Add(40, 5);
            
            table.Rows.Add(50, 1);
            table.Rows.Add(50, 6);

            table.Rows.Add(60, 1);
            table.Rows.Add(60, 7);

            // no 70


            return table;
        }

        private DataTable CreateGameNameDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("Locale", typeof(string));
            table.Columns.Add("GameName", typeof(string));

            table.Rows.Add(10, "", "Game 10 default");
            table.Rows.Add(10, "en", "Game 10 en");
            table.Rows.Add(10, "es", "Game 10 es");
            table.Rows.Add(10, "en-US", "Game 10 en-US");
            table.Rows.Add(10, "es-ES", "Game 10 es-ES");
            table.Rows.Add(10, "en-GB", "Game 10 en-GB");
            table.Rows.Add(10, "es-MX", "Game 10 es-MX");

            table.Rows.Add(20, "", "Game 20 default");
            table.Rows.Add(20, "en", "Game 20 en");
            table.Rows.Add(20, "es", "Game 20 es");
            table.Rows.Add(20, "en-US", "Game 20 en-US");
            table.Rows.Add(20, "es-ES", "Game 20 es-ES");
            table.Rows.Add(20, "en-GB", "Game 20 en-GB");
            table.Rows.Add(20, "es-MX", "Game 20 es-MX");

            table.Rows.Add(30, "", "Game 30 default");
            table.Rows.Add(30, "en", "Game 30 en");
            table.Rows.Add(30, "es", "Game 30 es");
            table.Rows.Add(30, "en-US", "Game 30 en-US");
            table.Rows.Add(30, "es-ES", "Game 30 es-ES");
            table.Rows.Add(30, "en-GB", "Game 30 en-GB");
            table.Rows.Add(30, "es-MX", "Game 30 es-MX");

            table.Rows.Add(40, "", "Game 40 default");
            table.Rows.Add(40, "en", "Game 40 en");
            table.Rows.Add(40, "es", "Game 40 es");
            table.Rows.Add(40, "en-US", "Game 40 en-US");
            table.Rows.Add(40, "es-ES", "Game 40 es-ES");
            table.Rows.Add(40, "en-GB", "Game 40 en-GB");
            table.Rows.Add(40, "es-MX", "Game 40 es-MX");

            table.Rows.Add(50, "", "Game 50 default");
            table.Rows.Add(50, "en", "Game 50 en");
            table.Rows.Add(50, "es", "Game 50 es");
            table.Rows.Add(50, "en-US", "Game 50 en-US");
            table.Rows.Add(50, "es-ES", "Game 50 es-ES");
            table.Rows.Add(50, "en-GB", "Game 50 en-GB");
            table.Rows.Add(50, "es-MX", "Game 50 es-MX");

            // no 60

            // no 70


            return table;
        }

        private DataTable CreateGameImageDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("ImageType", typeof(int));
            table.Columns.Add("ImageUrl", typeof(string));
            table.Columns.Add("ImageHeight", typeof(int));
            table.Columns.Add("ImageWidth", typeof(int));


            table.Rows.Add(10, 1, "http://image10.1.gif", 32, 32);
            table.Rows.Add(10, 2, "http://image10.2.gif", 64, 64);
            // no 20
            table.Rows.Add(30, 1, "http://image30.1.gif", 32, 32);
            table.Rows.Add(30, 2, "http://image30.2.gif", 64, 64);
            table.Rows.Add(40, 1, "http://image40.1.gif", 32, 32);
            table.Rows.Add(40, 2, "http://image40.2.gif", 64, 64);
            table.Rows.Add(50, 1, "http://image50.1.gif", 32, 32);
            table.Rows.Add(50, 2, "http://image50.2.gif", 64, 64);
            table.Rows.Add(60, 1, "http://image60.1.gif", 32, 32);
            table.Rows.Add(60, 2, "http://image60.2.gif", 64, 64);
            // no 70

            return table;
        }

        private DataTable CreateGameVariantDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("VariantId", typeof(int));

            table.Rows.Add(10, 0);
            table.Rows.Add(20, 1); // no default variant
            table.Rows.Add(30, 0);
            table.Rows.Add(30, 1);
            table.Rows.Add(40, 0);
            // no 50
            // no 60
            // no 70

            return table;
        }

        private DataTable CreateGameVariantNameDataTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("VariantId", typeof(int));
            table.Columns.Add("Locale", typeof(string));
            table.Columns.Add("GameVariantName", typeof(string));


            table.Rows.Add(10, 0, "", "Game 10 Variant 0 default");
            table.Rows.Add(10, 0, "en", "Game 10 Variant 0 en");
            table.Rows.Add(10, 0, "es", "Game 10 Variant 0 es");
            table.Rows.Add(10, 0, "en-US", "Game 10 Variant 0 en-US");
            table.Rows.Add(10, 0, "es-ES", "Game 10 Variant 0 es-ES");
            table.Rows.Add(10, 0, "en-GB", "Game 10 Variant 0 en-GB");
            table.Rows.Add(10, 0, "es-MX", "Game 10 Variant 0 es-MX");

            table.Rows.Add(20, 1, "", "Game 20 Variant 1 default");
            table.Rows.Add(20, 1, "en", "Game 20 Variant 1 en");
            table.Rows.Add(20, 1, "es", "Game 20 Variant 1 es");
            table.Rows.Add(20, 1, "en-US", "Game 20 Variant 1 en-US");
            table.Rows.Add(20, 1, "es-ES", "Game 20 Variant 1 es-ES");
            table.Rows.Add(20, 1, "en-GB", "Game 20 Variant 1 en-GB");
            table.Rows.Add(20, 1, "es-MX", "Game 20 Variant 1 es-MX");

            table.Rows.Add(30, 0, "", "Game 30 Variant 0 default");
            table.Rows.Add(30, 0, "en", "Game 30 Variant 0 en");
            table.Rows.Add(30, 0, "es", "Game 30 Variant 0 es");
            table.Rows.Add(30, 0, "en-US", "Game 30 Variant 0 en-US");
            table.Rows.Add(30, 0, "es-ES", "Game 30 Variant 0 es-ES");
            table.Rows.Add(30, 0, "en-GB", "Game 30 Variant 0 en-GB");
            table.Rows.Add(30, 0, "es-MX", "Game 30 Variant 0 es-MX");
            table.Rows.Add(30, 1, "", "Game 30 Variant 1 default");
            table.Rows.Add(30, 1, "en", "Game 30 Variant 1 en");
            table.Rows.Add(30, 1, "es", "Game 30 Variant 1 es");
            table.Rows.Add(30, 1, "en-US", "Game 30 Variant 1 en-US");
            table.Rows.Add(30, 1, "es-ES", "Game 30 Variant 1 es-ES");
            table.Rows.Add(30, 1, "en-GB", "Game 30 Variant 1 en-GB");
            table.Rows.Add(30, 1, "es-MX", "Game 30 Variant 1 es-MX");

            // no 40

            // no 50
            
            // no 60

            // no 70

            return table;
        }

        private DataTable CreateGameVariantStatRankingTable()
        {
            DataTable table = new DataTable();
            table.Columns.Add("GameId", typeof(int));
            table.Columns.Add("VariantId", typeof(int));
            table.Columns.Add("StatName", typeof(string));
            table.Columns.Add("PreferHighValues", typeof(bool));

            table.Rows.Add(10, 0, "Score", true);
            table.Rows.Add(20, 1, "Time", true);
            // no 30
            table.Rows.Add(40, 0, "Score", false);
            table.Rows.Add(40, 0, "Time", true);
            // no 50
            // no 60
            // no 70

            return table;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore.Test\SqlGameMetadataStoreTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo;
using GameMetadata.GameMetadataStore;
using GameMetadata.Common;

namespace GameMetadata.GameMetadataStore.Test
{
    [TestClass]
    public class SqlGameMetadataStoreTest
    {
        [TestInitialize]
        public void TestInitialize()
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<IGameMetadataStoreDataAccess, FakeGameMetadataStoreDataAccess>();
            Container.Instance.AddService<IGameMetadataStore, SqlGameMetadataStore>();
        }

        private IGameMetadataStore Store
        {
            get { return Container.Instance.GetComponent<IGameMetadataStore>(); }
        }

        private GameMetadataCollection Collection
        {
            get { return Store.GetGameMetadataCollection(); }
        }

        [TestMethod]
        public void TestGameIdCollection()
        {
            Assert.IsTrue(Collection.Games.ContainsKey(10));
            Assert.IsTrue(Collection.Games.ContainsKey(20));
            Assert.IsTrue(Collection.Games.ContainsKey(30));
            Assert.IsTrue(Collection.Games.ContainsKey(40));
            Assert.IsTrue(Collection.Games.ContainsKey(50));
            Assert.IsTrue(Collection.Games.ContainsKey(60));
            Assert.IsTrue(Collection.Games.ContainsKey(70));
        }

        [TestMethod]
        public void TestGamePlatforms()
        {
            Assert.IsTrue(Collection.Games[10].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[10].AvailablePlatforms.Contains(2));

            Assert.IsTrue(Collection.Games[20].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[20].AvailablePlatforms.Contains(3));

            Assert.IsTrue(Collection.Games[30].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[30].AvailablePlatforms.Contains(4));

            Assert.IsTrue(Collection.Games[40].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[40].AvailablePlatforms.Contains(5));

            Assert.IsTrue(Collection.Games[50].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[50].AvailablePlatforms.Contains(6));

            Assert.IsTrue(Collection.Games[60].AvailablePlatforms.Contains(1));
            Assert.IsTrue(Collection.Games[60].AvailablePlatforms.Contains(7));
        }


        [TestMethod]
        public void TestGameNames()
        {
            Assert.AreEqual("Game 10 default", Collection.Games[10].LocalizedNames[""]);
            Assert.AreEqual("Game 10 en", Collection.Games[10].LocalizedNames["en"]);
            Assert.AreEqual("Game 10 es", Collection.Games[10].LocalizedNames["es"]);
            Assert.AreEqual("Game 10 en-US", Collection.Games[10].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 10 es-ES", Collection.Games[10].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 10 en-GB", Collection.Games[10].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 10 es-MX", Collection.Games[10].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 20 default", Collection.Games[20].LocalizedNames[""]);
            Assert.AreEqual("Game 20 en", Collection.Games[20].LocalizedNames["en"]);
            Assert.AreEqual("Game 20 es", Collection.Games[20].LocalizedNames["es"]);
            Assert.AreEqual("Game 20 en-US", Collection.Games[20].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 20 es-ES", Collection.Games[20].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 20 en-GB", Collection.Games[20].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 20 es-MX", Collection.Games[20].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 30 default", Collection.Games[30].LocalizedNames[""]);
            Assert.AreEqual("Game 30 en", Collection.Games[30].LocalizedNames["en"]);
            Assert.AreEqual("Game 30 es", Collection.Games[30].LocalizedNames["es"]);
            Assert.AreEqual("Game 30 en-US", Collection.Games[30].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 30 es-ES", Collection.Games[30].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 30 en-GB", Collection.Games[30].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 30 es-MX", Collection.Games[30].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 40 default", Collection.Games[40].LocalizedNames[""]);
            Assert.AreEqual("Game 40 en", Collection.Games[40].LocalizedNames["en"]);
            Assert.AreEqual("Game 40 es", Collection.Games[40].LocalizedNames["es"]);
            Assert.AreEqual("Game 40 en-US", Collection.Games[40].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 40 es-ES", Collection.Games[40].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 40 en-GB", Collection.Games[40].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 40 es-MX", Collection.Games[40].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 50 default", Collection.Games[50].LocalizedNames[""]);
            Assert.AreEqual("Game 50 en", Collection.Games[50].LocalizedNames["en"]);
            Assert.AreEqual("Game 50 es", Collection.Games[50].LocalizedNames["es"]);
            Assert.AreEqual("Game 50 en-US", Collection.Games[50].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 50 es-ES", Collection.Games[50].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 50 en-GB", Collection.Games[50].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 50 es-MX", Collection.Games[50].LocalizedNames["es-MX"]);

        
        }

        [TestMethod]
        public void TestGameImage()
        {
            Assert.AreEqual("http://image10.1.gif", Collection.Games[10].Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual("http://image10.2.gif", Collection.Games[10].Images[ImageType.GameTile_WebLarge].ImageUrl);

            Assert.AreEqual(0, Collection.Games[20].Images.Keys.Count);

            Assert.AreEqual("http://image30.1.gif", Collection.Games[30].Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual("http://image30.2.gif", Collection.Games[30].Images[ImageType.GameTile_WebLarge].ImageUrl);

            Assert.AreEqual("http://image40.1.gif", Collection.Games[40].Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual("http://image40.2.gif", Collection.Games[40].Images[ImageType.GameTile_WebLarge].ImageUrl);

            Assert.AreEqual("http://image50.1.gif", Collection.Games[50].Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual("http://image50.2.gif", Collection.Games[50].Images[ImageType.GameTile_WebLarge].ImageUrl);

            Assert.AreEqual("http://image60.1.gif", Collection.Games[60].Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual("http://image60.2.gif", Collection.Games[60].Images[ImageType.GameTile_WebLarge].ImageUrl);
        }

        [TestMethod]
        public void TestGameVariants()
        {
            Assert.IsTrue(Collection.Games[10].Variants.ContainsKey(0));
            Assert.IsTrue(Collection.Games[20].Variants.ContainsKey(1));
            Assert.IsTrue(Collection.Games[30].Variants.ContainsKey(0));
            Assert.IsTrue(Collection.Games[30].Variants.ContainsKey(1));
            Assert.IsTrue(Collection.Games[40].Variants.ContainsKey(0));
        }

        [TestMethod]
        public void TestGameVariantNames()
        {
            Assert.AreEqual("Game 10 Variant 0 default", Collection.Games[10].Variants[0].LocalizedNames[""]);
            Assert.AreEqual("Game 10 Variant 0 en", Collection.Games[10].Variants[0].LocalizedNames["en"]);
            Assert.AreEqual("Game 10 Variant 0 es", Collection.Games[10].Variants[0].LocalizedNames["es"]);
            Assert.AreEqual("Game 10 Variant 0 en-US", Collection.Games[10].Variants[0].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 10 Variant 0 es-ES", Collection.Games[10].Variants[0].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 10 Variant 0 en-GB", Collection.Games[10].Variants[0].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 10 Variant 0 es-MX", Collection.Games[10].Variants[0].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 20 Variant 1 default", Collection.Games[20].Variants[1].LocalizedNames[""]);
            Assert.AreEqual("Game 20 Variant 1 en", Collection.Games[20].Variants[1].LocalizedNames["en"]);
            Assert.AreEqual("Game 20 Variant 1 es", Collection.Games[20].Variants[1].LocalizedNames["es"]);
            Assert.AreEqual("Game 20 Variant 1 en-US", Collection.Games[20].Variants[1].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 20 Variant 1 es-ES", Collection.Games[20].Variants[1].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 20 Variant 1 en-GB", Collection.Games[20].Variants[1].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 20 Variant 1 es-MX", Collection.Games[20].Variants[1].LocalizedNames["es-MX"]);

            Assert.AreEqual("Game 30 Variant 0 default", Collection.Games[30].Variants[0].LocalizedNames[""]);
            Assert.AreEqual("Game 30 Variant 0 en", Collection.Games[30].Variants[0].LocalizedNames["en"]);
            Assert.AreEqual("Game 30 Variant 0 es", Collection.Games[30].Variants[0].LocalizedNames["es"]);
            Assert.AreEqual("Game 30 Variant 0 en-US", Collection.Games[30].Variants[0].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 30 Variant 0 es-ES", Collection.Games[30].Variants[0].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 30 Variant 0 en-GB", Collection.Games[30].Variants[0].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 30 Variant 0 es-MX", Collection.Games[30].Variants[0].LocalizedNames["es-MX"]);
            Assert.AreEqual("Game 30 Variant 1 default", Collection.Games[30].Variants[1].LocalizedNames[""]);
            Assert.AreEqual("Game 30 Variant 1 en", Collection.Games[30].Variants[1].LocalizedNames["en"]);
            Assert.AreEqual("Game 30 Variant 1 es", Collection.Games[30].Variants[1].LocalizedNames["es"]);
            Assert.AreEqual("Game 30 Variant 1 en-US", Collection.Games[30].Variants[1].LocalizedNames["en-US"]);
            Assert.AreEqual("Game 30 Variant 1 es-ES", Collection.Games[30].Variants[1].LocalizedNames["es-ES"]);
            Assert.AreEqual("Game 30 Variant 1 en-GB", Collection.Games[30].Variants[1].LocalizedNames["en-GB"]);
            Assert.AreEqual("Game 30 Variant 1 es-MX", Collection.Games[30].Variants[1].LocalizedNames["es-MX"]);
        }

        [TestMethod]
        public void TestGameVariantStatRankings()
        {
            Assert.IsTrue(Collection.Games[10].Variants[0].StatRankings["Score"]);
            Assert.IsTrue(Collection.Games[20].Variants[1].StatRankings["Time"]);
            Assert.AreEqual(0, Collection.Games[30].Variants[0].StatRankings.Keys.Count);
            Assert.AreEqual(0, Collection.Games[30].Variants[1].StatRankings.Keys.Count);
            Assert.IsFalse(Collection.Games[40].Variants[0].StatRankings["Score"]);
            Assert.IsTrue(Collection.Games[40].Variants[0].StatRankings["Time"]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore.Test\LocalizationHelperTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace GameMetadata.GameMetadataStore.Test
{
    /// <summary>
    /// Summary description for LocalizationHelperTest
    /// </summary>
    [TestClass]
    public class LocalizationHelperTest
    {
        private Dictionary<string, string> LocalizedStrings = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);

        [TestInitialize]
        public void TestInitialize()
        {
            LocalizedStrings.Add("", "DEFAULT");
            LocalizedStrings.Add("en", "EN");
            LocalizedStrings.Add("en-US", "EN-US");
            LocalizedStrings.Add("en-GB", "EN-GB");
            LocalizedStrings.Add("es-ES", "ES-ES");
            LocalizedStrings.Add("es-MX", "ES-MX");
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TestDefinedFullCulturesWithFallbackWithDefault()
        {
            string usedLocale;
            Assert.AreEqual("EN-US", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-US", out usedLocale));
            Assert.AreEqual("en-US", usedLocale);
            Assert.AreEqual("EN-GB", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-GB", out usedLocale));
            Assert.AreEqual("en-GB", usedLocale);
        }

        [TestMethod]
        public void TestUndefinedFullCulturesWithFallbackWithDefault()
        {
            string usedLocale;
            Assert.AreEqual("EN", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-CA", out usedLocale));
            Assert.AreEqual("en", usedLocale);
        }

        [TestMethod]
        public void TestDefinedFullCulturesWithNoFallbackWithDefault()
        {
            string usedLocale;
            Assert.AreEqual("ES-ES", LocalizationHelper.GetLocalizedString(LocalizedStrings, "es-ES", out usedLocale));
            Assert.AreEqual("es-ES", usedLocale);
            Assert.AreEqual("ES-MX", LocalizationHelper.GetLocalizedString(LocalizedStrings, "es-MX", out usedLocale));
            Assert.AreEqual("es-MX", usedLocale);
        }

        [TestMethod]
        public void TestUndefinedFullCulturesWithNoFallbackWithDefault()
        {
            string usedLocale;
            Assert.AreEqual("DEFAULT", LocalizationHelper.GetLocalizedString(LocalizedStrings, "nl-BE", out usedLocale));
            Assert.AreEqual("", usedLocale);
        }

        [TestMethod]
        public void TestDefinedFullCulturesWithFallbackWithNoDefault()
        {
            if (LocalizedStrings.ContainsKey(""))
            {
                LocalizedStrings.Remove("");
            }
            string usedLocale;
            Assert.AreEqual("EN-US", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-US", out usedLocale));
            Assert.AreEqual("en-US", usedLocale);
            Assert.AreEqual("EN-GB", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-GB", out usedLocale));
            Assert.AreEqual("en-GB", usedLocale);
        }

        [TestMethod]
        public void TestUndefinedFullCulturesWithFallbackWithNoDefault()
        {
            if (LocalizedStrings.ContainsKey(""))
            {
                LocalizedStrings.Remove("");
            }
            string usedLocale;
            Assert.AreEqual("EN", LocalizationHelper.GetLocalizedString(LocalizedStrings, "en-CA", out usedLocale));
            Assert.AreEqual("en", usedLocale);
        }

        [TestMethod]
        public void TestDefinedFullCulturesWithNoFallbackWithNoDefault()
        {
            if (LocalizedStrings.ContainsKey(""))
            {
                LocalizedStrings.Remove("");
            }
            string usedLocale;
            Assert.AreEqual("ES-ES", LocalizationHelper.GetLocalizedString(LocalizedStrings, "es-ES", out usedLocale));
            Assert.AreEqual("es-ES", usedLocale);
            Assert.AreEqual("ES-MX", LocalizationHelper.GetLocalizedString(LocalizedStrings, "es-MX", out usedLocale));
            Assert.AreEqual("es-MX", usedLocale);
        }

        [TestMethod]
        public void TestUndefinedFullCulturesWithNoFallbackWithNoDefault()
        {
            if (LocalizedStrings.ContainsKey(""))
            {
                LocalizedStrings.Remove("");
            }
            string usedLocale;
            Assert.AreEqual("", LocalizationHelper.GetLocalizedString(LocalizedStrings, "nl-BE", out usedLocale));
            Assert.AreEqual(null, usedLocale);
        }
         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.GameMetadataStore.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.GameMetadataStore.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a36b24a4-adff-4a58-9941-3f1312f2b0d5")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\GameRedirectionController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Routing;
using System.Web.Security;
using System.Web.SessionState;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using GameMetadata.Common;
using System.Globalization;
using Leet.Core.Platforms;

namespace GameMetadata.Web.Redirection
{
    public class GameRedirectionController : RedirectionServiceControllerBase
    {
        public RedirectResult HandleRedirection(string gameIdParam, string variantIdParam)
        {
            UInt32 gameId;
            UInt32 variantId;
            if (UInt32.TryParse(gameIdParam, out gameId) && UInt32.TryParse(variantIdParam, out variantId))
            {
                // they're both at least valid UInt32s
                GameMetadataComposite composite = base.GetMetadataComposite(gameId, variantId);
                if (composite != null)
                {
                    string urlFormat;
                    // it's a valid combination, see if it's available for mobile.
                    bool availableOnMobile = composite.SupportedPlatforms.Contains((uint)PlatformType.Mobile);
                    if (availableOnMobile && RequesterIsWindowsMobile)
                    {
                        // get the mobile redirection URL
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_Game_Mobile);
                    }
                    else
                    {
                        // get the standard web redirection URL
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_Game_Web);
                    }
                    // redirect
                    return Redirect(String.Format(urlFormat, gameId.ToString("x"), variantId.ToString("x")));
                }
            }

            Response.StatusCode = 404;
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\GameSessionRedirectionController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Routing;
using System.Web.Security;
using System.Web.SessionState;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using GameMetadata.Common;
using System.Globalization;
using Leet.Core.Platforms;

namespace GameMetadata.Web.Redirection
{
    public class GameSessionRedirectionController : RedirectionServiceControllerBase
    {
        public RedirectResult HandleRedirection(string gameIdParam, string sessionIdParam)
        {
            UInt32 gameId;
            if (UInt32.TryParse(gameIdParam, out gameId))
            {
                GameMetadataComposite composite = base.GetMetadataComposite(gameId);
                if (composite != null)
                {
                    string urlFormat;
                    // it's a valid combination, see if it's available for mobile.
                    bool availableOnMobile = composite.SupportedPlatforms.Contains((uint)PlatformType.Mobile);
                    if (availableOnMobile && RequesterIsWindowsMobile)
                    {
                        // get the mobile redirection URL
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_GameSession_Mobile);
                    }
                    else
                    {
                        // get the standard web redirection URL
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_GameSession_Web);
                    }
                    string redirectUrl = String.Format(urlFormat, gameId.ToString("x"), sessionIdParam);
                    // game session redirections may have additional querystring parameters.  Make sure to pass them on.
                    if (!String.IsNullOrEmpty(Request.QueryString.ToString()))
                    {
                        redirectUrl = String.Concat(redirectUrl, "&", Request.QueryString.ToString());
                    }
                    // redirect
                    return Redirect(redirectUrl);
                }
            }


            Response.StatusCode = 404;
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\ProfileRedirectionController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Routing;
using System.Web.Security;
using System.Web.SessionState;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using System.Text.RegularExpressions;

namespace GameMetadata.Web.Redirection
{
    public class ProfileRedirectionController : RedirectionServiceControllerBase
    {
        public RedirectResult HandleRedirection(string gamertagParam)
        {
            if (!String.IsNullOrEmpty(gamertagParam))
            {
                // make sure the tag contains only alphanumeric characters and spaces (and is 1 to 15 characters long)
                Regex validGamerTag = new Regex(@"^[a-zA-Z0-9 ]{1,15}$");
                if (validGamerTag.IsMatch(gamertagParam))
                {
                    string urlFormat;
                    if (RequesterIsWindowsMobile)
                    {
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_Profile_Mobile);
                    }
                    else
                    {
                        urlFormat = Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.GameMetadata_Redirection_Profile_Web);
                    }

                    return Redirect(String.Format(urlFormat, gamertagParam));
                }
            }

            Response.StatusCode = 404;
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\Global.asax.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Routing;
using System.Web.Security;
using System.Web.SessionState;
using GameMetadata.Common;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Core.IO;
using Leet.Core.Utils;
using Leet.Core.Configuration;
using GameMetadata.Client;
using Leet.Core.Caching;

namespace GameMetadata.Web.Redirection
{
    public class Global : System.Web.HttpApplication
    {
        public static void RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

            routes.MapRoute(
                "GameRedirection",
                "g/{gameIdParam}/{variantIdParam}",
                new { controller = "GameRedirection", action = "HandleRedirection", variantIdParam = "0" }
            );

            routes.MapRoute(
                "GameSessionRedirection",
                "s/{gameIdParam}/{sessionIdParam}",
                new { controller = "GameSessionRedirection", action = "HandleRedirection" }
            );

            routes.MapRoute(
                "ProfileRedirection",
                "p/{gamertagParam}",
                new { controller = "ProfileRedirection", action = "HandleRedirection" }
            );
        }

        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();
            
            ConfigurationSelector.RegisterProvider("gamemetadata_web_redirection", "LEET");

            GameMetadataClient.RegisterContainerServices();
            
            RegisterRoutes(RouteTable.Routes);
            GmsDiagnostics.Logging.LogEvent(new ServiceStarted(),"GMS Redirector Service was started ");
        }


        /// <summary>
        /// Application End
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Application_End(object sender, EventArgs e)
        {
            GmsDiagnostics.Logging.LogEvent(new ServiceStopped(), "GMS Redirector service stopped ");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Web.Redirection")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Redirection\RedirectionServiceControllerBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Web.Routing;
using System.Web.Security;
using System.Web.SessionState;
using System.Text.RegularExpressions;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using GameMetadata.Client;
using GameMetadata.Common;
using Leet.Core.Caching;
using System.Globalization;

namespace GameMetadata.Web.Redirection
{
    public class RedirectionServiceControllerBase : Controller
    {
        private const UInt32 DEFAULTVARIANTID = 0;

        public GameMetadataComposite GetMetadataComposite(UInt32 gameId)
        {
            return GetMetadataComposite(gameId, DEFAULTVARIANTID);
        }

        public GameMetadataComposite GetMetadataComposite(UInt32 gameId, UInt32 variantId)
        {
            ICacheProvider cache = Container.Instance.GetComponent<ICacheProvider>();
            string cacheKey = String.Format("gmc_{0}_{1}", gameId, variantId);

            GameMetadataComposite composite = cache.GetObject(cacheKey) as GameMetadataComposite;

            if (composite == null)
            {
                // cache miss
                composite = Container.Instance.GetComponent<IGameMetadataClient>().GetGameMetadata(gameId, "", variantId);

                if (composite == null)
                {
                    // there's no valid metadata for this gameId, but we don't want to keep hitting the service (opens up DOS vector)
                    // so cache an empty composite item instead...
                    composite = new GameMetadataComposite();
                }

                // add it to the cache
                cache.Insert(cacheKey, composite, DateTime.Now.AddMinutes(Container.Instance.GetComponent<IConfigurationProvider>().GetIntSetting(Settings.GameMetadata_Redirection_CacheTTLMinutes)));
            }
            
            // check to see if it's a blank object...
            if (composite.GameId == 0)
            {
                composite = null; // set it to null (what the service would have returned if we hadn't cached a blank object)
            }

            return composite;
        }

        public bool RequesterIsWindowsMobile
        {
            get
            {
                if (String.IsNullOrEmpty(Request.UserAgent))
                {
                    return false;
                }
                double minVersion = Container.Instance.GetComponent<IConfigurationProvider>().GetDoubleSetting(Settings.GameMetadata_Redirection_WindowsMobileMinVersion);
                string agent = Request.UserAgent;
                Regex winmo = new Regex(@"windows mobile (\d+\.\d)", RegexOptions.IgnoreCase);
                if (winmo.IsMatch(agent))
                {
                    Match m = winmo.Match(agent);
                    double version;
                    if (Double.TryParse(m.Groups[1].Value, out version))
                    {
                        if (version >= minVersion)
                        {
                            return true;
                        }
                    }
                }
                // This is new UA string as a result of re-branding
                winmo = new Regex(@"Windows Phone OS (\d+\.\d)", RegexOptions.IgnoreCase);
                if (winmo.IsMatch(agent))
                {
                    Match m = winmo.Match(agent);
                    double version;
                    if (Double.TryParse(m.Groups[1].Value, out version))
                    {
                        if (version >= minVersion)
                        {
                            return true;
                        }
                    }
                }

                // This is IE User Agent string
                if (agent.ToLower().Contains("xblwp"))
                {
                    return true;
                }

                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\GameMetadataServiceHostFactory.cs ===
﻿using Leet.Core.Wcf;
using GameMetadata.Common;

namespace GameMetadata.Web.Service
{
    public class GameMetadataServiceHostFactory : ConfigurableServiceHostFactory<IGameMetadataService> { }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\GameMetadata.svc.cs ===
﻿using System;
using System.Collections.Generic;
using GameMetadata.Common;
using GameMetadata.GameMetadataStore;
using Leet.Core.IoCCo;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using System.Web.Caching;
using Leet.Core.Utils;
using System.Diagnostics;

namespace GameMetadata.Web.Service
{
    public class GameMetadataSvc : IGameMetadataService
    {
        public GameMetadataComposite GetGameMetadata(UInt32 gameId, string locale, UInt32 variantId)
        {
            if (!CheckIsValidGameId(gameId))
                return null;

            GameInformation gi = Metadata.Games[gameId];
            if (!gi.Variants.ContainsKey(variantId))
            {
                return null; // variantId is invalid
            }
            GameVariantInformation gvi = Metadata.Games[gameId].Variants[variantId];
            
            GameMetadataComposite gmc = new GameMetadataComposite();
            try
            {
                gmc.GameId = gameId;
                gmc.VariantId = variantId;
                gmc.GameRedirectionUrl = GetGameRedirectionUrl(gameId, variantId);
                foreach (ImageType key in gi.Images.Keys)
                {
                    gmc.Images.Add(key, gi.Images[key]);
                }
                gmc.UsesLiveMultiplayerServices = gi.UsesLiveMultiplayerServices;

                string usedLocale;
                gmc.GameAndVariantName = gvi.GetName(locale, out usedLocale);
                if (usedLocale == null)
                {
                    // there were usable records for localizing the game variant name (it's an empty string).
                    // so that the information is more usable, try using just the game name instead.
                    gmc.GameAndVariantName = gi.GetName(locale, out usedLocale);
                }
                gmc.GameName = gi.GetName(locale);

                gmc.IsUsingFallbackLocale = (usedLocale != locale);
                gmc.LocalizationLocale = usedLocale;

                foreach (UInt32 platform in gi.AvailablePlatforms)
                {
                    gmc.SupportedPlatforms.Add(platform);

                }

                // Update the plaform bit mask
                gmc.SupportedPlatformsBitMask = Platforms.GetPlatformsBitMask(gi.AvailablePlatforms);


            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogTrace(TraceLevel.Error,ex);
                throw;
            }
           
            return gmc;
        }

        public GameVariantComposite GetGameVariant(UInt32 gameId, UInt32 variantId)
        {
            if (!CheckIsValidGameId(gameId))
                return null;

            GameInformation gi = Metadata.Games[gameId];
            if (!gi.Variants.ContainsKey(variantId))
            {
                return null; // variantId is invalid
            }
            GameVariantInformation gvi = Metadata.Games[gameId].Variants[variantId];

            var gvc = new GameVariantComposite();

            try
            {
                gvc.GameId = gameId;
                gvc.VariantId = variantId;
                foreach (string statName in gvi.StatRankings.Keys)
                {
                    gvc.StatRankings[statName] = gvi.StatRankings[statName] ? StatRanking.High : StatRanking.Low;
                }
            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogTrace(TraceLevel.Error, ex);
                throw;
            }
           
            return gvc;
        }

        public List<UInt32> GetGameVariantIds(UInt32 gameId)
        {
            if (!CheckIsValidGameId(gameId))
                return new List<UInt32>();

            List<UInt32> variants = new List<UInt32>();
            foreach (UInt32 variantId in Metadata.Games[gameId].Variants.Keys)
            {
                variants.Add(variantId);
            }

            return variants;
        }

        public Dictionary<UInt32, GameVariantComposite> GetGameVariants(UInt32 gameId)
        {
            if (!CheckIsValidGameId(gameId))
                return new Dictionary<UInt32, GameVariantComposite>();

            var variants = new Dictionary<UInt32, GameVariantComposite>();
            try
            {
                List<UInt32> variantIds = GetGameVariantIds(gameId);
                foreach (UInt32 variantId in variantIds)
                {
                    GameVariantComposite gvc = GetGameVariant(gameId, variantId);
                    if (gvc != null) // we shouldn't ever get null objects since we got the variantId from the same collection, but best to check.
                    {
                        variants.Add(variantId, gvc);
                    }
                }
            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogTrace(TraceLevel.Error, ex);
                throw;
            }
            
            return variants;
        }

        public Dictionary<int, string> GetRedirectionUrlFormats()
        {
            Dictionary<int, string> urlFormats = new Dictionary<int, string>();
            try
            {
                IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                urlFormats.Add((int)RedirectionUrlType.Game,
                    String.Concat(ServiceConfiguration.RedirectionBaseUrl, config.GetSetting(Settings.GameMetadata_GameRedirectionUrlFormat)));
                urlFormats.Add((int)RedirectionUrlType.GameSession,
                    String.Concat(ServiceConfiguration.RedirectionBaseUrl, config.GetSetting(Settings.GameMetadata_GameSessionRedirectionUrlFormat)));
                urlFormats.Add((int)RedirectionUrlType.Profile,
                    String.Concat(ServiceConfiguration.RedirectionBaseUrl, config.GetSetting(Settings.GameMetadata_ProfileRedirectionUrlFormat)));
        

            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogTrace(TraceLevel.Error, ex);
                throw;
            }
            
            return urlFormats;

        }

        public bool CheckIsValidGameId(UInt32 gameId)
        {
            return Metadata.Games.ContainsKey(gameId);
        }

        private string GetGameRedirectionUrl(UInt32 gameId, UInt32 variantId)
        {
            Dictionary<int, string> urlFormatStrings = GetRedirectionUrlFormats();
            return String.Format(urlFormatStrings[(int)RedirectionUrlType.Game], gameId, variantId);
        }

        private GameMetadataCollection Metadata
        {
            get
            {
                ICacheProvider cache = Container.Instance.GetComponent<ICacheProvider>();
                GameMetadataCollection metadata = cache.GetObject("GameMetadataCollection") as GameMetadataCollection;
                if ((metadata == null))
                {
                    try
                    {
                        IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                        metadata = Container.Instance.GetComponent<IGameMetadataStore>().GetGameMetadataCollection();
                        CacheDependency dependency = Container.Instance.GetComponent<IGameMetadataStore>().GetGameMetadataCollectionCacheDependency();
                        DateTime absoluteExpiration = DateTime.Now.AddMinutes(config.GetIntSetting(Settings.GameMetadata_Service_CacheMaximumTTLMinutes));
                        cache.Insert("GameMetadataCollection", metadata, dependency, absoluteExpiration, Cache.NoSlidingExpiration);
                    }
                    catch (Exception ex)
                    {
                        GmsDiagnostics.Logging.LogTrace(TraceLevel.Error, ex);
                        throw;
                    }
                    
                }
                return metadata;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\Global.asax.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Global.asax.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="smangla">
//    Smangla
// </author>
//
// <summary>
// Implements global asax code
// </summary>
//
// <remarks/>
//
// 
//-------------------------------------------------------------------

using GameMetadata.Common;
using Leet.Core.Diagnostics;

namespace GameMetadata.Web.Service
{
    using System;
    using System.Data.SqlClient;
    using GameMetadata.GameMetadataStore;
    using Leet.Core.Caching;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;

    /// <summary>
    /// 
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Application boostrap
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<IGameMetadataStoreDataAccess, SqlGameMetadataStoreDataAccess>();
            Container.Instance.AddService<IGameMetadataStore, SqlGameMetadataStore>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            ConfigurationSelector.RegisterProvider("gamemetadata_web_service", "LEET");
            SqlDependency.Start(SqlContentStoreConfiguration.Instance.ConnectionString);
            GmsDiagnostics.Logging.LogEvent(new ServiceStarted(), "GameMetadata Service started ");
        }

        /// <summary>
        /// Application End
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Application_End(object sender, EventArgs e)
        {
            SqlDependency.Stop(SqlContentStoreConfiguration.Instance.ConnectionString);
            GmsDiagnostics.Logging.LogEvent(new ServiceStopped(), "GameMetadata Service stopped ");
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\Ingestion.svc.cs ===
﻿using System;
using System.Data.SqlClient;
using System.ServiceModel;
using System.Xml;
using Leet.Core.IoCCo;
using GameMetadata.GameMetadataStore;
using GameMetadata.Common.Mix.ContentIngestion;
using GameMetadata.Common;

namespace GameMetadata.Web.Service
{
    // Remove any address filtering because requests coming via WebSG will have websg address in the host header
    [ServiceBehavior(AddressFilterMode = AddressFilterMode.Any)]
    public class IngestionSvc : IIngestionService
    {
        public void ConfigureGame(Game game)
        {
            try
            {
                Container.Instance.GetComponent<IGameMetadataStore>().ConfigureGame(game.ToStoreXml());
            }
            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex);
                throw;
            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogEvent(new ErrorConfiguringGame(), ex);
                throw;
            }

        }

        public bool ConfigureGameViaXml(string gameXml)
        {
            var doc = new XmlDocument();
            try
            {
                doc.LoadXml(gameXml);
            }
            catch (Exception ex)
            {
                GmsDiagnostics.Logging.LogEvent(new ErrorLoadingXml(), ex);
                return false;
            }

            try
            {
                // handle multiple nodes in the XML (will typically only be one)
                XmlNodeList gameNodes = doc.SelectNodes("//game");
                if (gameNodes != null)
                    foreach (XmlNode node in gameNodes)
                    {

                        Container.Instance.GetComponent<IGameMetadataStore>().ConfigureGame(node.OuterXml);
                    }
            }
            catch (SqlException ex)
            {
                GmsDiagnostics.Logging.LogEvent(new SqlExceptionError(), ex);
                return false;
            }
            catch (Exception ex)
            {

                GmsDiagnostics.Logging.LogEvent(new ErrorConfiguringGame(), ex);
                return false;
            }
           
            
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\IngestionServiceHostFactory.cs ===
﻿using Leet.Core.Wcf;
using GameMetadata.Common.Mix.ContentIngestion;

namespace GameMetadata.Web.Service
{
    public class IngestionServiceHostFactory : ConfigurableServiceHostFactory<IIngestionService> { }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Web.Service")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("93e691ab-f09a-4150-8fca-06ca88624c2e")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service\ServiceConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace GameMetadata.Web.Service
{
    public class ServiceConfiguration
    {
        public static string RedirectionBaseUrl
        {
            get
            {
                IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                if (config.GetBoolSetting(Settings.GameMetadata_Service_UseRedirectionUrlHostOverride))
                {
                    return config.GetSetting(Settings.GameMetadata_Service_RedirectionUrlHostOverride);
                }
                else
                {
                    string url = config.GetInterfaceEndpoint("gamemetadata_web_redirection", false);
                    if (url.EndsWith("/"))
                    {
                        url = url.Substring(0, url.Length - 1); // trim off trailing slash
                    }
                    return url;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameMetadata.Web.Service.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fc0f2b01-0f11-4bbf-9e69-524761de4c91")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service.Test\InMemoryCacheProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.Caching;
using System.Web.Caching;

namespace GameMetadata.Web.Service.Test
{
    public class InMemoryCacheProvider : ICacheProvider
    {
        private class CachedObject
        {
            public System.DateTime ExpirationDate = DateTime.MaxValue;
            public CacheDependency Dependency = null;
            public object Value = null;
        }
        private static Dictionary<string, CachedObject> _cache = new Dictionary<string, CachedObject>();

        public object GetObject(string key)
        {
            if (_cache.ContainsKey(key))
            {
                CachedObject obj = _cache[key];
                if (obj.ExpirationDate < DateTime.Now)
                {
                    // its expiration date is in the past
                    _cache.Remove(key);
                    return null;
                }
                else if ((obj.Dependency != null) && (obj.Dependency.HasChanged))
                {
                    // it has a dependency and the dependency has changed...
                    _cache.Remove(key);
                    return null;
                }
                // expiration date is in the future and any dependency is valid
                return obj.Value;
            }
            return null;
        }
        public void Insert(string key, object value, DateTime expirationDate)
        {
            CachedObject obj = new CachedObject() { ExpirationDate = expirationDate, Value = value };
            _cache[key] = obj;
        }

        public void Insert(string key, object value, CacheDependency dependencies)
        {
            CachedObject obj = new CachedObject() { Dependency = dependencies, Value = value };
            _cache[key] = obj;
        }
        public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration)
        {
            // no real support for TimeSpan in InMemoryCache
            CachedObject obj = new CachedObject() { Dependency = dependencies, ExpirationDate = absoluteExpiration, Value = value };
            _cache[key] = obj;
        }
        public void Clear()
        {
            _cache = new Dictionary<string, CachedObject>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\BasicClient\App.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;
using Leet.Core.IoCCo;
using GameMetadata.Client;
using Leet.Core.Configuration;
using Leet.Core.IO;
using GameMetadata.Common;
using Leet.Core.Wcf;
using BasicClient.Properties;

namespace BasicClient
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        public App()
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider("BasicClient", "LEET");

            if (ConfigSettings.Default.UseFakeClient)
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
            }
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            var appWindow = new AppWindow();
            appWindow.Show();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\BasicClient\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BasicClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
    //(used if a resource is not found in the page, 
    // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
    //(used if a resource is not found in the page, 
    // app, or any theme specific resource dictionaries)
)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\GameMetadata.Web.Service.Test\GameMetadataServiceTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo;
using GameMetadata.GameMetadataStore;
using GameMetadata.Common;
using GameMetadata.Web.Service;
using GameMetadata.GameMetadataStore.Test;
using Rhino.Mocks;
using Leet.TestUtilities;
using Leet.Core.Configuration;
using Leet.Core.Caching;

namespace GameMetadata.Web.Service.Test
{
    [TestClass]
    public class GameMetadataServiceTest
    {
        [ClassInitialize]
        public static void ClassInitialize(TestContext testContext)
        {
            // only want to add these once (to avoid dictionary exceptions)
            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = "gamemetadata_web_redirection", Port = 62502, VSiteId = 1 });
            InMemoryConfigurationProvider.AddInterfaceServer("gamemetadata_web_redirection", "TESTSERVER");
        }

        [TestInitialize]
        public void TestInitialize()
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<ICacheProvider, InMemoryCacheProvider>();
            Container.Instance.AddService<IGameMetadataStoreDataAccess, FakeGameMetadataStoreDataAccess>();
            Container.Instance.AddService<IGameMetadataStore, SqlGameMetadataStore>();

            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_Service_UseRedirectionUrlHostOverride", "true");
            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_Service_RedirectionUrlHostOverride", "http://redirection.xboxlive.com");
            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_ProfileRedirectionUrlFormat", "/p/{0}/");
            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_GameRedirectionUrlFormat", "/g/{0}/{1}/");
            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_GameSessionRedirectionUrlFormat", "/s/{0}/{1}/");
            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_Service_CacheMaximumTTLMinutes", "300");


            Container.Instance.AddService<IConfigurationProvider, InMemoryConfigurationProvider>();
        }

        [TestMethod]
        public void TestGetRedirectionUrlFormats()
        {
            GameMetadataSvc service = new GameMetadataSvc();
            Dictionary<int,string> strings = service.GetRedirectionUrlFormats();

            Assert.AreEqual("http://redirection.xboxlive.com/p/{0}/", strings[(int)RedirectionUrlType.Profile]);
            Assert.AreEqual("http://redirection.xboxlive.com/g/{0}/{1}/", strings[(int)RedirectionUrlType.Game]);
            Assert.AreEqual("http://redirection.xboxlive.com/s/{0}/{1}/", strings[(int)RedirectionUrlType.GameSession]);
        }

        [TestMethod]
        public void TestGetRedirectionUrlFormatsWithDerivedHostName()
        {

            InMemoryConfigurationProvider.SetSetting("lest_GameMetadata_Service_UseRedirectionUrlHostOverride", "false");

            GameMetadataSvc service = new GameMetadataSvc();
            Dictionary<int, string> strings = service.GetRedirectionUrlFormats();

            Assert.AreEqual("http://TESTSERVER:62502/p/{0}/", strings[(int)RedirectionUrlType.Profile]);
            Assert.AreEqual("http://TESTSERVER:62502/g/{0}/{1}/", strings[(int)RedirectionUrlType.Game]);
            Assert.AreEqual("http://TESTSERVER:62502/s/{0}/{1}/", strings[(int)RedirectionUrlType.GameSession]);
        }

        [TestMethod]
        public void TestGameFullyPopulated()
        {
            UInt32 gameId = 10;
            UInt32 variantId = 0;
            GameMetadataComposite gmc;

            GameMetadataSvc service = new GameMetadataSvc();

            gmc = service.GetGameMetadata(gameId, "en-US", variantId); // defined culture
            Assert.AreEqual("Game 10 Variant 0 en-US", gmc.GameAndVariantName);
            Assert.AreEqual("Game 10 en-US", gmc.GameName);
            Assert.AreEqual("http://redirection.xboxlive.com/g/10/0/", gmc.GameRedirectionUrl);
            Assert.AreEqual("http://image10.1.gif", gmc.Images[ImageType.GameTile_WebSmall].ImageUrl);
            Assert.AreEqual(32, gmc.Images[ImageType.GameTile_WebSmall].Height);
            Assert.AreEqual(32, gmc.Images[ImageType.GameTile_WebSmall].Width);
            Assert.AreEqual(ImageType.GameTile_WebSmall, gmc.Images[ImageType.GameTile_WebSmall].ImageType);
            Assert.AreEqual("http://image10.2.gif", gmc.Images[ImageType.GameTile_WebLarge].ImageUrl);
            Assert.AreEqual(64, gmc.Images[ImageType.GameTile_WebLarge].Height);
            Assert.AreEqual(64, gmc.Images[ImageType.GameTile_WebLarge].Width);
            Assert.AreEqual(ImageType.GameTile_WebLarge, gmc.Images[ImageType.GameTile_WebLarge].ImageType);
            Assert.IsFalse(gmc.IsUsingFallbackLocale);
            Assert.AreEqual("en-US", gmc.LocalizationLocale);
            Assert.AreEqual(variantId, gmc.VariantId);
            Assert.AreEqual(2, gmc.SupportedPlatforms.Count);
            Assert.IsTrue(gmc.SupportedPlatforms.Contains((uint)1));
            Assert.IsTrue(gmc.SupportedPlatforms.Contains((uint)2));
            Assert.IsTrue(gmc.SupportedPlatformsBitMask == 6);

            variantId = 1;
            gmc = service.GetGameMetadata(gameId, "en-US", variantId);
            Assert.IsNull(gmc);
        }

        [TestMethod]
        public void TestGameMissingImages()
        {
            UInt32 gameId = 20;
            UInt32 variantId = 1;
            GameMetadataComposite gmc;

            GameMetadataSvc service = new GameMetadataSvc();

            gmc = service.GetGameMetadata(gameId, "en-US", variantId);
            Assert.AreEqual(0, gmc.Images.Count);

            variantId = 0;
            gmc = service.GetGameMetadata(gameId, "en-US", variantId);
            Assert.IsNull(gmc);
        }

        [TestMethod]
        public void TestGameMissingVariantNames()
        {
            UInt32 gameId = 40;
            UInt32 variantId = 0;
            GameMetadataComposite gmc;

            GameMetadataSvc service = new GameMetadataSvc();

            gmc = service.GetGameMetadata(gameId, "en-US", variantId); // defined culture
            Assert.AreEqual("Game 40 en-US", gmc.GameAndVariantName);
            Assert.AreEqual("Game 40 en-US", gmc.GameName);

            variantId = 1;
            gmc = service.GetGameMetadata(gameId, "en-US", variantId);
            Assert.IsNull(gmc);
        }

        [TestMethod]
        public void TestCheckIsValidGameId()
        {
            GameMetadataSvc service = new GameMetadataSvc();

            Assert.IsFalse(service.CheckIsValidGameId(0));
            Assert.IsTrue(service.CheckIsValidGameId(10));
            Assert.IsTrue(service.CheckIsValidGameId(20));
            Assert.IsTrue(service.CheckIsValidGameId(30));
            Assert.IsTrue(service.CheckIsValidGameId(40));
            Assert.IsTrue(service.CheckIsValidGameId(50));
            Assert.IsTrue(service.CheckIsValidGameId(60));
            Assert.IsTrue(service.CheckIsValidGameId(70));
            Assert.IsFalse(service.CheckIsValidGameId(80));
        }

        [TestMethod]
        public void TestGetGameVariant()
        {
            UInt32 gameId = 10;
            UInt32 variantId = 0;
            GameVariantComposite gvc;

            GameMetadataSvc service = new GameMetadataSvc();

            // standard varaint;
            gvc = service.GetGameVariant(gameId, variantId);
            Assert.AreEqual(gameId, gvc.GameId);
            Assert.AreEqual(variantId, gvc.VariantId);
            Assert.AreEqual(1, gvc.StatRankings.Count);
            Assert.IsTrue(gvc.StatRankings.ContainsKey("Score"));
            Assert.AreEqual(StatRanking.High, gvc.StatRankings["Score"]);

            // variant with multiple stats
            gameId = 40;
            variantId = 0;
            gvc = service.GetGameVariant(gameId, variantId);
            Assert.AreEqual(gameId, gvc.GameId);
            Assert.AreEqual(variantId, gvc.VariantId);
            Assert.AreEqual(2, gvc.StatRankings.Count);
            Assert.IsTrue(gvc.StatRankings.ContainsKey("Score"));
            Assert.IsTrue(gvc.StatRankings.ContainsKey("Time"));
            Assert.AreEqual(StatRanking.Low, gvc.StatRankings["Score"]);
            Assert.AreEqual(StatRanking.High, gvc.StatRankings["Time"]);

            // valid GameId, invalid VariantId
            gameId = 40;
            variantId = 2;
            gvc = service.GetGameVariant(gameId, variantId);
            Assert.IsNull(gvc);

            // invalid GameId and invalid VariantId
            gameId = 0;
            variantId = 2;
            gvc = service.GetGameVariant(gameId, variantId);
            Assert.IsNull(gvc);
        }

        [TestMethod]
        public void TestGetGameVariantIds()
        {
            UInt32 gameId = 10;
            List<UInt32> variantIds;

            GameMetadataSvc service = new GameMetadataSvc();

            // just a default variant
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(1, variantIds.Count);
            Assert.IsTrue(variantIds.Contains(0));

            // default variant but with multiple stats.
            gameId = 40;
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(1, variantIds.Count);
            Assert.IsTrue(variantIds.Contains(0));

            // two variants (but no stats)
            gameId = 30;
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(2, variantIds.Count);
            Assert.IsTrue(variantIds.Contains(0));
            Assert.IsTrue(variantIds.Contains(1));

            // no default variants
            gameId = 20;
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(1, variantIds.Count);
            Assert.IsTrue(variantIds.Contains(1));

            // no variants
            gameId = 50;
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(0, variantIds.Count);

            // invalid GameId
            gameId = 0;
            variantIds = service.GetGameVariantIds(gameId);
            Assert.AreEqual(0, variantIds.Count);
        }

        [TestMethod]
        public void TestGetGameVariants()
        {
            UInt32 gameId = 10;
            Dictionary<UInt32, GameVariantComposite> variants;

            GameMetadataSvc service = new GameMetadataSvc();

            // just a default variant
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(1, variants.Keys.Count);
            Assert.AreEqual((uint)0, variants[(uint)0].VariantId);
            Assert.AreEqual(1, variants[(uint)0].StatRankings.Count);

            // default variant but with multiple stats.
            gameId = 40;
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(1, variants.Keys.Count);
            Assert.AreEqual((uint)0, variants[(uint)0].VariantId);
            Assert.AreEqual(2, variants[(uint)0].StatRankings.Count);

            // two variants (but no stats)
            gameId = 30;
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(2, variants.Keys.Count);
            Assert.AreEqual((uint)0, variants[(uint)0].VariantId);
            Assert.AreEqual(0, variants[(uint)0].StatRankings.Count);
            Assert.AreEqual((uint)1, variants[(uint)1].VariantId);
            Assert.AreEqual(0, variants[(uint)1].StatRankings.Count);

            // no default variants
            gameId = 20;
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(1, variants.Keys.Count);
            Assert.AreEqual((uint)1, variants[(uint)1].VariantId);
            Assert.AreEqual(1, variants[(uint)1].StatRankings.Count);

            // no variants
            gameId = 50;
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(0, variants.Keys.Count);

            // invalid GameId
            gameId = 0;
            variants = service.GetGameVariants(gameId);
            Assert.AreEqual(0, variants.Keys.Count);
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\BasicClient\AppWindow.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

using GameMetadata.Common;
using GameMetadata.Client;
using Leet.Core.IoCCo;

namespace BasicClient
{
    /// <summary>
    /// Interaction logic for AppWindow.xaml
    /// </summary>
    public partial class AppWindow : Window
    {
        public AppWindow()
        {
            InitializeComponent();
        }

        private IGameMetadataClient Client
        {
            get
            {
                return Container.Instance.GetComponent<IGameMetadataClient>();
            }
        }

        private void GetGameMetadata_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;
            string locale;
            UInt32 variantId;

            if (!UInt32.TryParse(GetGameMetadata_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }


            if (String.IsNullOrEmpty(GetGameMetadata_Locale.Text))
            {
                OutputTextBlock.Text = "Must provide a Locale";
                return;
            }
            else
            {
                locale = GetGameMetadata_Locale.Text;
            }

            GameMetadataComposite composite;
            if (UInt32.TryParse(GetGameMetadata_VariantId.Text, out variantId))
            {
                composite = Client.GetGameMetadata(gameId, locale, variantId);
            }
            else
            {
                composite = Client.GetGameMetadata(gameId, locale);
            }

            OutputTextBlock.Text = FormatGameMetadataComposite(composite);

        }

        private void ProfileUrl_Execute_Click(object sender, RoutedEventArgs e)
        {
            string gamertag;

            if (String.IsNullOrEmpty(ProfileUrl_IdentityToken.Text))
            {
                OutputTextBlock.Text = "Must provide an Gamertag";
                return;
            }
            else
            {
                gamertag = ProfileUrl_IdentityToken.Text.Trim();
            }

            OutputTextBlock.Text = Client.GetProfileRedirectionUrl(gamertag);
        }

        private void RedirectionUrl_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;
            UInt32 variantId;

            if (!UInt32.TryParse(RedirectionUrl_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }

            string url;
            if (UInt32.TryParse(RedirectionUrl_VariantId.Text, out variantId))
            {
                url = Client.GetGameRedirectionUrl(gameId, variantId);
            }
            else
            {
                url = Client.GetGameRedirectionUrl(gameId);
            }

            OutputTextBlock.Text = url;
        }

        private void SessionUrl_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;
            string sessionId;

            if (!UInt32.TryParse(SessionUrl_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }

            if (String.IsNullOrEmpty(SessionUrl_SessionId.Text))
            {
                OutputTextBlock.Text = "Must provide a SessionId";
                return;
            }
            else
            {
                sessionId = SessionUrl_SessionId.Text.Trim();
            }

            OutputTextBlock.Text = Client.GetGameSessionRedirectionUrl(gameId, sessionId);
        }

        private void GetGameVariant_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;
            UInt32 variantId;

            if (!UInt32.TryParse(GetGameVariant_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }

            GameVariantComposite composite;
            if (UInt32.TryParse(GetGameVariant_VariantId.Text, out variantId))
            {
                composite = Client.GetGameVariant(gameId, variantId);
            }
            else
            {
                composite = Client.GetGameVariant(gameId);
            }

            OutputTextBlock.Text = FormatGameVariantComposite(composite);
        }

        private void GetGameVariantIds_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;

            if (!UInt32.TryParse(GetGameVariantIds_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }
            List<UInt32> variantIds = Client.GetGameVariantIds(gameId);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("VarientIds:");
            foreach (UInt32 variantId in variantIds)
            {
                sb.AppendLine(String.Format("\t{0}", variantId));
            }
            OutputTextBlock.Text = sb.ToString();
        }

        private void GetGameVariants_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;

            if (!UInt32.TryParse(GetGameVariants_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }

            Dictionary<UInt32, GameVariantComposite> variants = Client.GetGameVariants(gameId);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("Varients:");
            foreach (UInt32 variantId in variants.Keys)
            {
                sb.Append(FormatGameVariantComposite(variants[variantId]));
                sb.AppendLine();
            }
            OutputTextBlock.Text = sb.ToString();

        }

        private void CheckIsValidGameId_Execute_Click(object sender, RoutedEventArgs e)
        {
            UInt32 gameId;

            if (!UInt32.TryParse(CheckIsValidGameId_GameId.Text, out gameId))
            {
                OutputTextBlock.Text = "Couldn't Parse GameID";
                return;
            }

            OutputTextBlock.Text = Client.CheckIsValidGameId(gameId).ToString();
        }

        private string FormatGameMetadataComposite(GameMetadataComposite composite)
        {

            StringBuilder sb = new StringBuilder();
            if (composite != null)
            {
                sb.AppendLine(String.Format("GameId: {0}", composite.GameId));
                sb.AppendLine(String.Format("VariantId: {0}", composite.VariantId));
                sb.AppendLine(String.Format("IsUsingFallbackLocale: {0}", composite.IsUsingFallbackLocale));
                sb.AppendLine(String.Format("LocalizationLocale: {0}", composite.LocalizationLocale));
                sb.AppendLine(String.Format("UsesLiveMultiplayerServices: {0}", composite.UsesLiveMultiplayerServices));
                sb.AppendLine(String.Format("GameName: {0}", composite.GameName));
                sb.AppendLine(String.Format("GameAndVariantName: {0}", composite.GameAndVariantName));
                sb.AppendLine(String.Format("GameRedirectionUrl: {0}", composite.GameRedirectionUrl));
                sb.AppendLine("Images: ");
                foreach (ImageType imageType in composite.Images.Keys)
                {
                    sb.AppendLine(String.Format("{0}:{1} {2}x{3}", imageType, composite.Images[imageType].Width, composite.Images[imageType].ImageUrl, composite.Images[imageType].Height));
                }
                sb.Append("SupportedPlatforms: ");
                foreach (uint supportedPlatform in composite.SupportedPlatforms)
                {
                    sb.Append(String.Format("{0}, ", supportedPlatform));
                }
            }
            else
            {
                sb.AppendLine("null");
            }
            return sb.ToString();
        }

        private string FormatGameVariantComposite(GameVariantComposite composite)
        {

            StringBuilder sb = new StringBuilder();
            if (composite != null)
            {
                sb.AppendLine(String.Format("VariantId: {0}", composite.VariantId));
                sb.AppendLine("StatRankings: ");
                foreach (string key in composite.StatRankings.Keys)
                {
                    sb.AppendLine(String.Format("\t{0}: {1}", key,composite.StatRankings[key].ToString()));
                }
            }
            else
            {
                sb.AppendLine("null");
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\ManualIngestionTool\EnvironmentSettings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ManualIngestionTool {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class EnvironmentSettings : global::System.Configuration.ApplicationSettingsBase {
        
        private static EnvironmentSettings defaultInstance = ((EnvironmentSettings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new EnvironmentSettings())));
        
        public static EnvironmentSettings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("localhost")]
        public string IngestionServiceHost {
            get {
                return ((string)(this["IngestionServiceHost"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("62501")]
        public int IngestionServicePort {
            get {
                return ((int)(this["IngestionServicePort"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Ingestion.svc")]
        public string IngestionServicePath {
            get {
                return ((string)(this["IngestionServicePath"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\BasicClient\Properties\ConfigSettings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BasicClient.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class ConfigSettings : global::System.Configuration.ApplicationSettingsBase {
        
        private static ConfigSettings defaultInstance = ((ConfigSettings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new ConfigSettings())));
        
        public static ConfigSettings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool UseFakeClient {
            get {
                return ((bool)(this["UseFakeClient"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\ManualIngestionTool\Service References\ServiceReference1\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ManualIngestionTool.ServiceReference1 {
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(Namespace="http://gamemetadata.common.mix.contentingestion/V1", ConfigurationName="ServiceReference1.IIngestionService")]
    public interface IIngestionService {
        
        [System.ServiceModel.OperationContractAttribute(Action="http://gamemetadata.common.mix.contentingestion/V1/IIngestionService/ConfigureGam" +
            "e", ReplyAction="http://gamemetadata.common.mix.contentingestion/V1/IIngestionService/ConfigureGam" +
            "eResponse")]
        void ConfigureGame(GameMetadata.Common.Mix.ContentIngestion.Game game);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://gamemetadata.common.mix.contentingestion/V1/IIngestionService/ConfigureGam" +
            "eViaXml", ReplyAction="http://gamemetadata.common.mix.contentingestion/V1/IIngestionService/ConfigureGam" +
            "eViaXmlResponse")]
        bool ConfigureGameViaXml(string gameXml);
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface IIngestionServiceChannel : ManualIngestionTool.ServiceReference1.IIngestionService, System.ServiceModel.IClientChannel {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class IngestionServiceClient : System.ServiceModel.ClientBase<ManualIngestionTool.ServiceReference1.IIngestionService>, ManualIngestionTool.ServiceReference1.IIngestionService {
        
        public IngestionServiceClient() {
        }
        
        public IngestionServiceClient(string endpointConfigurationName) : 
                base(endpointConfigurationName) {
        }
        
        public IngestionServiceClient(string endpointConfigurationName, string remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public IngestionServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public IngestionServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(binding, remoteAddress) {
        }
        
        public void ConfigureGame(GameMetadata.Common.Mix.ContentIngestion.Game game) {
            base.Channel.ConfigureGame(game);
        }
        
        public bool ConfigureGameViaXml(string gameXml) {
            return base.Channel.ConfigureGameViaXml(gameXml);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\ManualIngestionTool\Program.cs ===
﻿using System;
using System.IO;
using ManualIngestionTool.ServiceReference1;

namespace ManualIngestionTool
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
            string endPointAddress = "http://localhost/Ingestion.svc";
            string xmlFileName = String.Empty;
            string endPointconfig = String.Empty;

            if (args.Length == 3)
            {
                endPointconfig = args[0].ToLower() == "secure" ? "MixGmsSecure" : "MixGmsUnSecure";
                endPointAddress = args[1];
                xmlFileName = args[2];
            }
          
            else
            {
                PrintUsage();
                Console.ReadLine();
                return;
            }
           
            // read XML
            string xmlToIngest = String.Empty;
            IngestionServiceClient client = new IngestionServiceClient(endPointconfig, endPointAddress);
            using (FileStream fs = new FileStream(xmlFileName, FileMode.Open))
            {
                using (StreamReader reader = new StreamReader(fs))
                {
                    xmlToIngest = reader.ReadToEnd();
                }
            }
            
            // ingest XML
            //IIngestionService service = Container.Instance.GetComponent<IIngestionService>();
            Console.WriteLine("Submitting XML");
            
                bool result = client.ConfigureGameViaXml(xmlToIngest);
                Console.WriteLine(String.Format("Submitted with result: {0}", result));
                Console.WriteLine("Done!");
            }
            catch (Exception e)
            {
                ConsoleColor originalColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Error Submitting XML");
                Console.WriteLine(e.Message);
                Console.WriteLine(e.StackTrace);
                Console.ForegroundColor = originalColor;
            }

        }

        private static void PrintUsage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("ManualIngestionTool.exe [secure/unsecure] [IngestionServicePath] GameXmlFile");
            Console.WriteLine("IngestionServerName: e.g., https://websg.int2.xboxlive.com/Ingestion.svc");
            Console.WriteLine("GameXmlFile: path to the XML to ingest.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GameMetadata\Utilities\ManualIngestionTool\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ManualIngestionTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5ed6de16-efd9-4c20-bf0b-e3170860aa8e")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineException.cs ===
﻿using System;
using System.Runtime.Serialization;


namespace Gds.ActionEngine
{
    [Serializable]
    public class ActionEngineException : Exception
    {
        public ActionEngineException()
        {
        }
        
        public ActionEngineException(string message ) : base( message )
        {
        }

        public ActionEngineException(string message, Exception inner ) 
            : base( message, inner )
        {
        }

        protected ActionEngineException(SerializationInfo info, StreamingContext context ) 
            : base( info, context )
        {
        }
    }

    [Serializable]
    public class ActionEngineOperationException : ActionEngineException
    {
        public ActionEngineOperationException()
            : base()
        {
        }

        public ActionEngineOperationException(string message ) : base( message )
        {
        }

        public ActionEngineOperationException(string message, Exception inner)
            : base(message, inner)
        {
        }

        protected ActionEngineOperationException(SerializationInfo info, StreamingContext context) 
            : base( info, context )
        {
        }
    }

    [Serializable]
    public class ActionEngineArgumentException : ActionEngineException
    {
        public ActionEngineArgumentException ()
            : base()
        {
        }

        public ActionEngineArgumentException (string message)
            : base(message)
        {
        }

        public ActionEngineArgumentException (string message, Exception inner)
            : base(message, inner)
        {
        }

        protected ActionEngineArgumentException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

    [Serializable]
    public class ActionEngineIdempotencyException : ActionEngineException
    {
        public ActionEngineIdempotencyException ()
            : base()
        {
        }

        public ActionEngineIdempotencyException (string message)
            : base(message)
        {
        }

        public ActionEngineIdempotencyException (string message, Exception inner)
            : base(message, inner)
        {
        }

        protected ActionEngineIdempotencyException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineConverterFilter.cs ===
﻿namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using GameMetadata.Common;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;

    public class ActionEngineConverterFilter : IUserStorageConverterFilter
    {
        public string PropertyKey { get; set; }

        public string AliasName { get; set; }

        public bool IsRemoved { get; set; }

        public Entry Process(string name, string value)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// If given statName does exists and ranking type does match return "do not remove" i.e. false.
        /// Otherwise return true, indicating that stat should be removed from final reported statistic list.
        /// </summary>
        /// <param name="rankings">GMS provided Dictionary of statNames and ranking/ordering</param>
        /// <param name="statName">UDS provided statName</param>
        /// <param name="statRanking">UDS provided HIGH or LOW stat name</param>
        /// <returns></returns>
        public static bool StatRemoved(IDictionary<string, StatRanking> rankings, string statName, StatRanking statRanking)
        {
            var q = from ranking in rankings.AsQueryable()
                    where ranking.Key.Equals(statName, StringComparison.OrdinalIgnoreCase) &&
                          ranking.Value == statRanking
                    select ranking;
            if (q.Count() > 0)
            {
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineEvents.cs ===
﻿namespace Gds.ActionEngine
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    [EventCategory(MessageIdBase = 15000, IncrementAmount = 1)]
    public static class ActionEngineEvents
    {
        public const string ComponentName = "ActionEngine";

        /// <summary>
        /// General Verbose, unstructured event category
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [Event(TraceEventType = TraceEventType.Verbose, Message="")]
        public static int VerboseMessage;

        /// <summary>
        /// Unexpected failure
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [Event(MessageId = -1, Message = "Unexpected failure.", TraceEventType = TraceEventType.Error)]
        public static int UnexpectedFailure = 1;

        private static EventsCollection actionEngineEvents;
        private static WgxTraceSource rewardsTraceSource;
        private static object lockObject = new object();

        public static WgxTraceSource TraceSource
        {
            get
            {
                Initialize(ActionEngineEvents.ComponentName);
                return rewardsTraceSource;
            }
        }
        
        public static EventsCollection Events
        {
            get
            {
                Initialize(ActionEngineEvents.ComponentName);
                return actionEngineEvents;
            }
        }

        private static void Initialize(string eventSource)
        {
            if (actionEngineEvents == null)
            {
                lock (ActionEngineEvents.lockObject)
                {
                    if (actionEngineEvents == null)
                    {
                        rewardsTraceSource = new WgxTraceSource(eventSource);
                        actionEngineEvents = rewardsTraceSource.GetEventsCollection(typeof(ActionEngineEvents));
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineType.cs ===
﻿namespace Gds.ActionEngine
{
    /// <summary>
    /// Enum for what kind of ActionEngine to create in the Class Factory.
    /// </summary>
    public enum ActionEngineType
    {
        /// <summary>
        /// An in-proc action engine that can work with silverlight
        /// </summary>
        SilverlightActionEngine,         

        /// <summary>
        /// An in-proc action engine that works against a basic SQL store,
        /// Check the test spec for the store schema.
        /// </summary>
        TestActionEngine,

        /// <summary>
        /// The real action engine used in a futuristic deployment.
        /// </summary>
        DeploymentActionEngine
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineFactory.cs ===
﻿using System;
using Leet.Core.IoCCo;


namespace Gds.ActionEngine
{
    /// <summary>
    /// The class Factory for various ActionEngine implementations.
    /// </summary>
    public static class ActionEngineFactory
    {
        /// <summary>
        /// Creates a specified IActionEngine interface
        /// </summary>
        /// <param name="actionEngineType">The type of action engine to create</param>
        /// <param name="decisionTreeQueueAddress">The Uri of where the Decision tree queue is located in</param>
        /// <returns>An actionEngine implementation</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "decisionTreeQueueAddress")]
        public static IActionEngine Create(ActionEngineType actionEngineType, Uri decisionTreeQueueAddress)
        {
            switch (actionEngineType)
            {
                case ActionEngineType.DeploymentActionEngine:
                    throw new NotImplementedException();

                case ActionEngineType.SilverlightActionEngine:
                    throw new NotImplementedException();

                case ActionEngineType.TestActionEngine:
                    return new TestActionEngine();

                default:
                    return new TestActionEngine();
            }
        }

        /// <summary>
        /// Registers a default IActionEngine class based on configuration or environement variables.
        /// </summary>
        /// <returns>An actionEngine implementation</returns>
        public static void RegisterActionEngineInterfaces()
        {
            Container.Instance.AddService<IActionEngine, LivecacheActionEngine>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionParameterUtility.cs ===
﻿namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Leet.Core;
    using Gds.Contracts.ActionEngine;

    
    public static class ActionParameterUtility
    {
        // TODO: Consider moving these to proper RuleActionParameter names.
        public const string MaxActionParameterNamePreamble = "Max";
        public const string MinActionParameterNamePreamble = "Min";
        public const string SumActionParameterNamePreamble = "Sum";

        private const string EventPropertyPathPreamble = "/Event/Property[";
        private const string StorePropertyPathPreamble = "/Store/User[";

        // the format of the stat paths are like the following:
        // /Store/User[ID=’/Event/UserID’]/Game[ID=’/Event/GameKey’]/LifeTimeScore
        // and we are looking for "LifeTimeScore".
        public static string TryGetStatisticName(string actionParameterPath)
        {
            if (string.IsNullOrEmpty(actionParameterPath))
            {
                return null;
            }

            string statName = actionParameterPath.GetSubStringAfterLastInstanceOf("/");
            return statName;
        }

        // right now this string is formatted to be like the following : /Event/Property[Score]
        // we are actually look for "Score".
        public static string TryGetEventPropertyName(string actionParameterPath)
        {
            if (string.IsNullOrEmpty(actionParameterPath))
            {
                return null;
            }

            // TODO: Check if using xpath directly from the XML rather 
            // than the deserialized object is a better approach. 
            // or find a better alternative.
            string propertyName = actionParameterPath.GetSubStringAfterLastInstanceOf("[");

            if (!string.IsNullOrEmpty(propertyName))
            {
                propertyName = propertyName.Trim(new char[] { ']', '[' });
            }

            return propertyName;
        }

        /// <summary>
        /// TODO: Both the action and the actionparameters are enough to deduce the preambles 
        /// extent the RuleAction class and relevant RuleActionParameters to remove the necessity.
        /// This is a temporary kludge.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="parameterPreamble"></param>
        /// <param name="statisticName"></param>
        /// <param name="parameterName"></param>
        public static string TryGetStatisticName(RuleAction action, string parameterPreamble)
        {
            string statisticName = null;

            try
            {
                // TODO: read 'sum' and 'store' as config settings from DB.
                IEnumerable<RuleActionParameter> nonEmptyParamCollection = ActionParameterUtility.GetParametersFiltered(action, true, true, false);

                var candidateStats = from actionParam in nonEmptyParamCollection
                                     where actionParam.Name.Contains(parameterPreamble, StringComparison.OrdinalIgnoreCase) &&
                                           actionParam.Path.Contains(ActionParameterUtility.StorePropertyPathPreamble, StringComparison.OrdinalIgnoreCase)
                                     select actionParam.Path;

                if (candidateStats.Count() > 0)
                {
                    string queryStatParamPath = candidateStats.First();

                    if (!string.IsNullOrEmpty(queryStatParamPath))
                    {
                        statisticName = ActionParameterUtility.TryGetStatisticName(queryStatParamPath);
                    }
                }

                return statisticName;
            }
            catch (InvalidOperationException)
            {
                // TODO: is this a logable error?
                // absorb and return
                return null;
            }
        }

        public static string TryGetPropertyName(RuleAction action, string parameterPreamble)
        {
            string parameterName = null;

            try
            {
                IEnumerable<RuleActionParameter> nonEmptyParamCollection = ActionParameterUtility.GetParametersFiltered(action, true, true, false);

                var queryPropertyParamPath = from actionparam in nonEmptyParamCollection
                                             where actionparam.Name.Contains(parameterPreamble, StringComparison.OrdinalIgnoreCase) &&
                                                   actionparam.Path.Contains(ActionParameterUtility.EventPropertyPathPreamble, StringComparison.OrdinalIgnoreCase)
                                             select actionparam.Path;

                if (queryPropertyParamPath.Count() > 0)
                {
                    string propertyParamPath = queryPropertyParamPath.First(); 
                    if (!string.IsNullOrEmpty(propertyParamPath ))
                    {
                        parameterName = ActionParameterUtility.TryGetEventPropertyName(propertyParamPath);
                    }
                }

                return parameterName;
            }
            catch (InvalidOperationException)
            {
                return null;
            }
        }

        internal static string TryGetValueParameterValue(RuleAction action, string parameterPreamble)
        {

            try
            {
                IEnumerable<RuleActionParameter> nonEmptyParamCollection = ActionParameterUtility.GetParametersFiltered(action, true, false, true);

                var queryParamValue = from actionparam in nonEmptyParamCollection
                                      where actionparam.Name.Contains(parameterPreamble, StringComparison.OrdinalIgnoreCase)
                                      select actionparam.Value;

                if (queryParamValue.Count() > 0)
                {
                    return queryParamValue.First();
                }

                return null;
            }
            catch (InvalidOperationException)
            {
                return null;
            }
        }

        internal static IEnumerable<RuleActionParameter> GetParametersFiltered(RuleAction action, bool checkName, bool checkPath, bool checkValue)
        {
            Func<RuleActionParameter, bool> filterFunction = delegate(RuleActionParameter parameter)
            {
                if (checkName && string.IsNullOrEmpty(parameter.Name))
                {
                    return false;
                }

                if (checkPath && string.IsNullOrEmpty(parameter.Path))
                {
                    return false;
                }

                if (checkValue && string.IsNullOrEmpty(parameter.Value))
                {
                    return false;
                }

                return true;
            };

            //var nonEmptyParamCollection = from nonEmpty in action.ActionParameters
            //                              where !string.IsNullOrEmpty(nonEmpty.Name) &&
            //                                    !string.IsNullOrEmpty(nonEmpty.Path)
            //                              select nonEmpty;
            var nonEmptyParamCollection = action.ActionParameters.Where<RuleActionParameter>(filterFunction);

            return nonEmptyParamCollection;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\DeploymentActionEngine.cs ===
﻿namespace Gds.ActionEngine
{
    /// <summary>
    /// 
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
    internal class DeploymentActionEngine : IActionEngine
    {
        /// <summary>
        /// Initializes a new instance of the DeploymentActionEngine class
        /// </summary>
        public DeploymentActionEngine()
        {}

        /// <summary>
        /// Initialize this Action Engine (create any SQL connection here)
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "actionEngineQueueWriter")]
        public static void Initialize(IActionEngineQueueWriter actionEngineQueueWriter)
        {
        }

        /// <summary>
        /// Schedule the Execution of the given action set
        /// </summary>
        /// <param name="xmlActionSet">a string containing the XML action set</param>
        /// <param name="xmlEvent">a string containign the XML event</param>
        public void Execute(string xmlActionSet, string xmlEvent)
        {
        }

        /// <summary>
        /// Implementing the Dispose pattern to close down any resources 
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public void Dispose()
        {
        }

        /// <summary>
        /// The private Dispose method, which is here to satisfy the Dispose pattern.
        /// </summary>
        /// <param name="isDisposing">boolean value indicating whether we are disposing or finalizing</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        private void Dispose(bool isDisposing)
        {
            if (isDisposing)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionEngineUtils.cs ===
﻿// <copyright file="ActionEngineUtils.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-05-25</date>
// <summary>Contains the lutilities which are used by action engines.</summary>

namespace Gds.ActionEngine
{
    using System;
    using System.Threading;
    using Contracts;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Providers;
    using Leet.Utils;

    /// <summary>
    /// This class has utilities that can be used by action engine implementation.
    /// </summary>
    public class ActionEngineUtils
    {
        /// <summary>
        /// This is a best-effor operation to update the last played time of a title.
        /// If it fails for whatever reason, it should NOT cause a roll-back of any kind.
        /// Hence, we simply schedule it for a later time and go our merry way.
        /// </summary>
        /// <param name="gameEvent">The game event for which to update the title.</param>
        internal static void UpdateSyncTitle(GameEvent gameEvent)
        {
            try
            {
                ThreadPool.QueueUserWorkItem((object state) =>
                {
                    ushort lcid = 0;
                    try
                    {
                        LIVEnServiceMobileExtendedAuthDataProvider.PlatformType = gameEvent.PlatformId.ToString();
                        LIVEnServiceMobileExtendedAuthDataProvider.Puid = gameEvent.UserId;

                        var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

                        if (!string.IsNullOrEmpty(gameEvent.Culture))
                        {
                            lcid = localeHelper.GetLCID(gameEvent.Culture);
                        }

                        var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();
                        achievementDataAccess.SyncTitles(gameEvent.GameId, gameEvent.UserId, lcid, gameEvent.TimeStamp);
                    }
                    catch (Exception ex)
                    {
                        ActionEngineDiag.Logging.LogEvent(new SyncTitlesFailed(), ex, "TitleId={0}, XUID={1}, Lcid={2}, Timestamp={3}", gameEvent.GameId, gameEvent.UserId, lcid, String.Format("{0:u}", gameEvent.TimeStamp));
                    }
                });
            }
            catch (Exception ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SyncTitlesFailed(), ex, "Failed to queue a SyncTitle call");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\ActionUtilities.cs ===
﻿namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Gds.Contracts;

    internal static class ActionUtilities
    {
        /// <summary>
        /// TODO: Consider creating a local cache out of these, keyed off of GameId/Variant
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public static IDictionary<string, IUserStorageConverterFilter> GetStatConverterFromGmsSettings(uint gameId, uint variant)
        {
            Dictionary<string, IUserStorageConverterFilter> converterFilter = null;

            // At this point of the code, the gmsProxy MUST exist. No need for null check. (*)
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();

            // Again, it must be guaranteed that this gvc exists at this point. (*)
            GameVariantComposite gvc = gmsProxy.GetGameVariant(gameId, variant);

            converterFilter = new Dictionary<string, IUserStorageConverterFilter>(gvc.StatRankings.Count, StringComparer.OrdinalIgnoreCase);

            // create filters
            ActionEngineConverterFilter[] filters = new ActionEngineConverterFilter[4]
                                         { 
                                            new ActionEngineConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestHighTime, 
                                                    AliasName = StatisticsConstants.BestTime, 
                                                    IsRemoved = ActionEngineConverterFilter.StatRemoved(gvc.StatRankings, StatisticsConstants.BestTime, StatRanking.High)
                                                },
                                            new ActionEngineConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestLowTime, 
                                                    AliasName = StatisticsConstants.BestTime,
                                                    IsRemoved = ActionEngineConverterFilter.StatRemoved(gvc.StatRankings, StatisticsConstants.BestTime, StatRanking.Low)
                                                },
                                            new ActionEngineConverterFilter() 
                                                { 
                                                    PropertyKey = StatisticsConstants.BestHighScore, 
                                                    AliasName = StatisticsConstants.BestScore, 
                                                    IsRemoved = ActionEngineConverterFilter.StatRemoved(gvc.StatRankings, StatisticsConstants.BestScore, StatRanking.High) 
                                                },
                                            new ActionEngineConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestLowScore, 
                                                    AliasName = StatisticsConstants.BestScore, 
                                                    IsRemoved = ActionEngineConverterFilter.StatRemoved(gvc.StatRankings, StatisticsConstants.BestScore, StatRanking.Low) 
                                                }
                                         };
            foreach (var filter in filters)
            {
                converterFilter.Add(filter.PropertyKey, filter);
            }

            return converterFilter;
        }

        public static string GetSubStringAfterLastInstanceOf(this string expression, string lookup)
        {
            int indexStart = expression.LastIndexOf(lookup, StringComparison.OrdinalIgnoreCase);
            return expression.Substring(indexStart + 1);
        }

        /// <summary>
        /// TODO: retrieve this value from sum2 parameter, and not from gameEvent
        /// </summary>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.Parse(System.String)")]
        public static long? GetPropertyValueAsLong(this GameEvent gameEvent, string propertyName)
        {
            string longValue = gameEvent.GetPropertyValueAsString(propertyName);
            if (string.IsNullOrEmpty(longValue))
            {
                return null;
            }

            return long.Parse(longValue);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int32.Parse(System.String)")]
        public static int GetPropertyValueAsInt(this GameEvent gameEvent, string propertyName)
        {
            int intPropertyName = int.Parse(gameEvent.GetPropertyValueAsString(propertyName));
            return intPropertyName;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.Parse(System.String)")]
        public static uint GetPropertyValueAsUInt(this GameEvent gameEvent, string propertyName)
        {
            return uint.Parse(gameEvent.GetPropertyValueAsString(propertyName));
        }

        public static string GetPropertyValueAsString(this GameEvent gameEvent, string propertyName)
        {
            var query = from property in gameEvent.Properties
                        where property.Name.Equals(propertyName, StringComparison.OrdinalIgnoreCase)
                        select property.Value;

            if (query.Count() > 0)
            {
                return query.First();
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\IActionEngine.cs ===
﻿using System;


namespace Gds.ActionEngine
{
    public interface IActionEngine
    {
        void Execute(string xmlActionSet, string gameEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\DiagnosticData.cs ===
﻿

namespace Gds.ActionEngine
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public static class ActionEngineDiag
    {
        internal static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public class SyncTitlesFailed : BaseEvent
    {
        public SyncTitlesFailed() : base(30200, TraceEventType.Error, "Failed to sync titles.")
        {
        }
    }

    public class InvalidActionSet : BaseEvent
    {
        public InvalidActionSet() : base(30201, TraceEventType.Error, "Invalid action set.")
        {
        }
    }

    public class InvalidGameEvent : BaseEvent
    {
        public InvalidGameEvent() : base(30202, TraceEventType.Error, "Invalid game event set.")
        {
        }
    }

    public class RemoveBlobFailed : BaseEvent
    {
        public RemoveBlobFailed() : base(30203, TraceEventType.Error, "Failed to remove datablob.")
        {
        }
    }

    public class SumPropertyFailed : BaseEvent
    {
        public SumPropertyFailed() : base(30204, TraceEventType.Error, "Failed to sum property.")
        {
        }
    }

    public class MaxPropertyFailed : BaseEvent
    {
        public MaxPropertyFailed() : base(30205, TraceEventType.Error, "Failed to max property.")
        {
        }
    }

    public class MinPropertyFailed : BaseEvent
    {
        public MinPropertyFailed() : base(30206, TraceEventType.Error, "Failed to min property.")
        {
        }
    }
    
    public class InsertOrUpdateBlobFailed : BaseEvent
    {
        public InsertOrUpdateBlobFailed() : base(30207, TraceEventType.Error, "Failed to insert or update datablob property.")
        {
        }
    }

    public class SqlExceptionError : BaseEvent
    {
        public SqlExceptionError() : base(30208, TraceEventType.Error, "A Sql exception has occurred.")
        {
        }
    }

    public class IdempotencyExceptionError : BaseEvent
    {
        public IdempotencyExceptionError() : base(30209, TraceEventType.Error, "A repeat message was asked to be processed")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\GdsRetryController.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GdsRetryController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-gamavi">
// </author>
//
// <summary>
//  Generic class to handle retrying operations
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
//
//-------------------------------------------------------------------

namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Threading;

    /// <summary>
    /// This is a in-thread Retry controller that re-tries should the operation fail,
    /// after certain amount of Thread.Sleep.
    /// </summary>
    public class GdsRetryController
    {
        /// <summary>
        /// Flag used to specify that the retry controller should stop retrying.
        /// See: http://www.yoda.arachsys.com/csharp/multithreading.html#volatile for reference.
        /// </summary>
        private static volatile bool shouldStopRetrying = false;

        /// <summary>
        /// The retry controller should stop retrying.
        /// </summary>
        public static void StopRetrying()
        {
            GdsRetryController.shouldStopRetrying = true;
        }

        /// <summary>
        /// Retry without transaction handling
        /// </summary>
        /// <param name="retryMax">A function that returns maximum retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="exceptionLogger"></param>
        /// <returns></returns>
        public static TResult RetryFunc<TResult>(Func<int> retryMax,
                                     int retryFrequency,
                                     List<Type> listException,
                                      Action<Exception, bool> exceptionLogger,
                                      Func<TResult> retryDelegate
  )
        {
            int retryCount = 0;
            TResult result = default(TResult);
            while (retryCount < retryMax())
            {
                if (GdsRetryController.shouldStopRetrying)
                {
                    // Stop retrying and throw an exception for the caller to handle.
                    ApplicationException appException = new ApplicationException("GdsRetryController.RetryFunc() was asked to stop retrying!");
                    if (exceptionLogger != null)
                    {
                        exceptionLogger(appException, false); // Log the exception.
                    }

                    throw appException;
                }

                try
                {
                    result = retryDelegate();
                    break;
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        if (exceptionLogger != null)
                        {
                            string message = String.Format("Retry #{0} of {1} in GdsRetryController.RetryFunc()", retryCount, retryMax());
                            ApplicationException appException = new ApplicationException(message, ex);
                            exceptionLogger(appException, true); // log the retriable exception

                        }

                        retryCount++;
                        if (retryCount < retryMax())
                        {
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        {
                            // tried retryMax times
                            // let the caller to handle the exception
                            ApplicationException appException = new ApplicationException("Retry count exceeded in GdsRetryController.RetryFunc()", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                            throw;
                        }
                    }
                    else
                    {
                        // non retriable exception
                        // let the caller to handle the exception
                        throw;
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Retry without transaction handling
        /// </summary>
        /// <param name="retryMax">Maximum number of retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="exceptionLogger"></param>
        /// <returns></returns>
        public static void Retry(int retryMax,
                                     int retryFrequency,
                                     List<Type> listException,
                                      Action<Exception, bool> exceptionLogger,
                                      Action retryDelegate
  )
        {
            int retryCount = 0;
            while (retryCount < retryMax)
            {
                if (GdsRetryController.shouldStopRetrying)
                {
                    // Stop retrying and throw an exception for the caller to handle.
                    ApplicationException appException = new ApplicationException("GdsRetryController.Retry() was asked to stop retrying!");
                    if (exceptionLogger != null)
                    {
                        exceptionLogger(appException, false); // Log the exception.
                    }

                    throw appException;
                }

                try
                {
                    retryDelegate();
                    break;
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        if (exceptionLogger != null)
                        {
                            string message = String.Format("Retry #{0} of {1} in GdsRetryController.Retry()", retryCount, retryMax);
                            ApplicationException appException = new ApplicationException(message, ex);
                            exceptionLogger(appException, true); // log the retriable exception

                        }

                        retryCount++;
                        if (retryCount < retryMax)
                        {
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        {
                            // tried retryMax times
                            // let the caller to handle the exception
                            ApplicationException appException = new ApplicationException("Retry count exceeded in GdsRetryController.Retry()", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                            throw;
                        }
                    }
                    else
                    {
                        // non retriable exception
                        // let the caller to handle the exception
                        throw;
                    }
                }
            }

            return;
        }

        /// <summary>
        /// Retry with transaction handling
        /// </summary>
        /// <param name="retryMax">Maximum number of retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="exceptionLogger"></param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="commitDelegate">Commit Delegate</param>
        /// <param name="rollbackDelegate">Rollback Delegate</param>
        /// <returns></returns>
        public static void Retry(int retryMax,
                                int retryFrequency,
                                List<Type> listException,
                                Action<Exception, bool> exceptionLogger,
                                Action retryDelegate,
                                Action commitDelegate,
                                Action rollbackDelegate)
        {
            int retryCount = 0;
            bool commitTransaction = true;
            while (retryCount < retryMax)
            {
                if (GdsRetryController.shouldStopRetrying)
                {
                    // Stop retrying and throw an exception for the caller to handle.
                    ApplicationException appException = new ApplicationException("GdsRetryController.Retry() was asked to stop retrying!");
                    if (exceptionLogger != null)
                    {
                        exceptionLogger(appException, false); // Log the exception.
                    }

                    commitTransaction = false;
                    break;
                }

                try
                {
                    retryDelegate();
                    break; // No exceptions, break from the loop to commit
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        retryCount++;
                        if (retryCount < retryMax)
                        {
                            if (exceptionLogger != null)
                            {
                                string message = String.Format("Retry #{0} of {1} in GdsRetryController.Retry()", retryCount, retryMax);
                                ApplicationException appException = new ApplicationException(message, ex);
                                exceptionLogger(appException, true); // log the retriable exception
                            }

                            // NOTE: it is bad for performance to block a TP thread for extended period of times.
                            // consider writing a seperate RetryController, that operates cross threads and 
                            // uses Timers to perform re-tries.
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        {
                            if (exceptionLogger != null)
                            {
                                ApplicationException appException = new ApplicationException("Retry count exceeded in GdsRetryController.Retry(). SQL Rollback called", ex);
                                exceptionLogger(appException, false); // log the non-retriable exception
                            }
                            commitTransaction = false;
                        }
                    }
                    else
                    {
                        if (exceptionLogger != null)
                        {
                            ApplicationException appException = new ApplicationException("Unexpected non retriable exception is caught in GdsRetryController.Retry(). SQL Rollback called", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                        }
                        commitTransaction = false;
                        break;
                    }
                }
            }

            if (commitTransaction)
            {
                commitDelegate();
            }
            else
            {
                rollbackDelegate();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\IActionEngineQueueWriter.cs ===
﻿using System;


namespace Gds.ActionEngine
{
    public interface IActionEngineQueueWriter : IDisposable
    {
        void Write(string gameEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\LivecacheRetriableException.cs ===
﻿// <copyright file="LivecacheRetriableException.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-06-09</date>
// <summary>Contains the exception class for Livecache retriable exceptions.</summary>

namespace Gds.ActionEngine
{
    using System;
    using xonline.common.webplatform.livecache;

    /// <summary>
    /// This class has been created to distinguish retriable live cache exception from those that are not.
    /// </summary>
    public class LivecacheRetriableException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the LivecacheRetriableException class.
        /// </summary>
        /// <param name="ex">The exception based on which this instance is being created.</param>
        public LivecacheRetriableException(LivecacheResponseException ex)
        {
            this.LiveCacheException = ex;
        }

        /// <summary>
        /// Gets or sets the live cache exception that is the basis of this exception.
        /// </summary>
        public LivecacheResponseException LiveCacheException
        {
            get; set;
        }

        /// <summary>
        /// Is this a retriable exception?
        /// </summary>
        /// <param name="ex">The exception which is to be distinguished.</param>
        /// <returns>True if this a retriable exception, false otherwise.</returns>
        public static bool IsRetriableException(LivecacheResponseException ex)
        {
            bool isRetriableException;
            switch (ex.HResult)
            {
                case xonline.common.service.HResult.XONLINE_E_TASK_THROTTLED:
                    isRetriableException = true;
                    break;

                case xonline.common.service.HResult.XONLINE_E_LIVECACHE_FORWARD_FAILED:
                    isRetriableException = true;
                    break;

                case xonline.common.service.HResult.XONLINE_E_LIVECACHE_OFFLINE:
                    isRetriableException = true;
                    break;

                    default:
                    isRetriableException = false;
                    break;
            }

            return isRetriableException;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ActionEgine")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\LivecacheActionEngine.cs ===
﻿// <copyright file="LivecacheActionEngine.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-05-25</date>
// <summary>Contains the live cache based implementation of the action engine.</summary>

namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using DataAccess.UserData;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Gds.Contracts;
    using Gds.Contracts.Converters;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using xonline.common.protocol;
    using xonline.common.webplatform.livecache;
    using xonline.common.xlastutil;

    /// <summary>
    /// Provides an implementation of action engine that uses the LiveCache to send leaderboard stats to XBL leaderboards.
    /// </summary>
    public class LivecacheActionEngine : IActionEngine
    {
        /// <summary>
        /// Maximum number of times to retry.
        /// </summary>
        private const int RetryMax = 1200;

        /// <summary>
        /// Number of seconds to wait before next retry.
        /// </summary>
        private const int RetryFrequency = 30;

        /// <summary>
        /// The Livecache storage reference to be used.
        /// </summary>
        private static readonly LcTitleStorage Storage = new LcTitleStorage();

        /// <summary>
        ///  List of retriable exceptions.
        /// </summary>
        private static readonly List<Type> RetriableExceptionList;

        /// <summary>
        /// The delegate for the exception logging method.
        /// </summary>
        private static readonly Action<string, Exception, bool> ExceptionLogger;

        /// <summary>
        /// Initializes static members of the LivecacheActionEngine class.
        /// </summary>
        static LivecacheActionEngine()
        {
            // Create the list of retriable exceptions.
            RetriableExceptionList = new List<Type>();
            RetriableExceptionList.Add(typeof(LivecacheRetriableException));

            ExceptionLogger = LogException;
        }

        /// <summary>
        /// The delegate for storage.
        /// </summary>
        /// <param name="ownerPuid">The blob owner's Puid.</param>
        /// <param name="path">The storage path.</param>
        /// <param name="data">The data to be written into storage.</param>
        /// <param name="expirationDate">The expiration data for the data.</param>
        /// <param name="clientType">The client type.</param>
        /// <param name="titleId">The titleId for which the blob is being posted.</param>
        internal delegate void StorageDelegate(ulong ownerPuid, string path, byte[] data, DateTime expirationDate, LivecacheClientType clientType, uint titleId);

        /// <summary>
        /// Executes the action specified.
        /// </summary>
        /// <param name="xmlActionSet">Not used in this implementation.</param>
        /// <param name="gameEvent">The gameEvent to be processed.</param>
        public void Execute(string xmlActionSet, string gameEvent)
        {
            GameEvent myGameEvent = null;

            if (!string.IsNullOrEmpty(gameEvent))
            {
                myGameEvent = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEvent, typeof(GameEvent));
            }

            if (myGameEvent == null)
            {
                ActionEngineDiag.Logging.LogEvent(new InvalidGameEvent(), "GameEvent={0}", gameEvent);
                throw new ActionEngineArgumentException("Invalid GameEvent XML, it is a required to be valid: myGameEvent");
            }

            try
            {
                ICollection<MsgStatPostProcedureCall> procList = new List<MsgStatPostProcedureCall>();
                IDictionary<int, bool> leaderboardPositionInfo = new Dictionary<int, bool>();

                byte[] byteBlob = GetBlobBytes(myGameEvent);

                // Gets the stats which can be posted to the lifetime leaderboard.
                LivecacheActionEngine.GetDatagroupStatsForPosting(myGameEvent, UserStatisticsDatagroupEnum.Lifetime, byteBlob.Length, leaderboardPositionInfo, procList);

                // Gets the stats which can be posted to the weekly leaderboard.
                LivecacheActionEngine.GetDatagroupStatsForPosting(myGameEvent, UserStatisticsDatagroupEnum.W1, byteBlob.Length, leaderboardPositionInfo, procList);

                // Post the stats.to leaderboard.
                LivecacheActionEngine.PostLeaderboardStats(procList, myGameEvent);

                // Write the leaderboard blobs to storage.
                LivecacheActionEngine.WriteLeaderboardBlobs(leaderboardPositionInfo, myGameEvent, byteBlob);

                // Update the last played played time for the title.
                ActionEngineUtils.UpdateSyncTitle(myGameEvent);
            }
            catch (SafeToDropException ex)
            {
                // Drop the event, this probably means that a bad event was read from the queue.
                LivecacheActionEngine.LogEvent(RulesEvents.Events, RulesEvents.GameEventDropped, ex, gameEvent);
            }
            catch (Exception ex)
            {
                LivecacheActionEngine.LogEvent(RulesEvents.Events, RulesEvents.ExceptionWhileProcessingGameEvent, ex, gameEvent);
                throw;
            }
        }

        /// <summary>
        /// Gets the array of bytes for a blob in a game event.
        /// </summary>
        /// <param name="gameEvent">The game event that has the blob.</param>
        /// <returns>The array of bytes for a blob in a game event.</returns>
        private static byte[] GetBlobBytes(GameEvent gameEvent)
        {
            byte[] byteBlob;

            string base64Blob = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.BlobPropertyName);

            if (!string.IsNullOrEmpty(base64Blob))
            {
                // May throw FormatException if string is invalid formatted.
                byteBlob = Convert.FromBase64String(base64Blob);
            }
            else
            {
                byteBlob = new byte[0];
            }

            return byteBlob;
        }

        /// <summary>
        /// Post stats to leaderboard.
        /// </summary>
        /// <param name="procList">The enumeration of stats procs to post.</param>
        /// <param name="gameEvent">The game event for which to post stats.</param>
        private static void PostLeaderboardStats(IEnumerable<MsgStatPostProcedureCall> procList, GameEvent gameEvent)
        {
            ReqStatPost postData = new ReqStatPost
                                       {
                                           _uiTitleId = gameEvent.GameId,
                                           _procs = procList.ToArray(),
                                           _teamTickets = LivecacheActionEngine.GetTeamTickets(gameEvent)
                                       };
            postData._usProcCount = (ushort)postData._procs.Length;

            Action<ReqStatPost, ulong> retryDelegate = LivecacheActionEngine.PostLeaderboardResult;

            // Use the generic transaction handler for retrying transactions
            // Retrying RetryMax times with RetryFrequency seconds
            GdsRetryController.Retry(
                RetryMax,
                RetryFrequency,
                RetriableExceptionList,
                (Exception ex, bool retriable) => ExceptionLogger("LivecacheActionEngine.GetStatsForPosting()", ex, retriable),
                () => retryDelegate(postData, gameEvent.UserId));
        }

        /// <summary>
        ///  Write the leaderboard blobs to storage.
        /// </summary>
        /// <param name="leaderboardPositionInfo">A dictionary of whether the position in each leaderboard was improved.</param>
        /// <param name="gameEvent">The game event for which the blob is being posted.</param>
        /// <param name="byteBlob">The blob to write in bytes</param>
        private static void WriteLeaderboardBlobs(IDictionary<int, bool> leaderboardPositionInfo, GameEvent gameEvent, byte[] byteBlob)
        {
            int[] leaderboardIds = leaderboardPositionInfo.Keys.ToArray();

            foreach (int leaderboardId in leaderboardIds)
            {
                // If the position in leaderboard has improved, then write the blob.
                if (leaderboardPositionInfo[leaderboardId])
                {
                    WriteBlob(gameEvent, byteBlob, leaderboardId);
                }
            }
        }

        /// <summary>
        /// Get the stats for the data group that can be posted.
        /// </summary>
        /// <param name="gameEvent">The game event for which to post the stats.</param>
        /// <param name="datagroup">The datagroup to which the stats should be posted</param>
        /// <param name="blobSize">The size of the blob in bytes.</param>
        /// <param name="leaderboardPositionInfo">A dictionary of whether the position in each leaderboard was improved.</param>
        /// <param name="procList">The stats for the data group that can be posted.</param>
        private static void GetDatagroupStatsForPosting(
            GameEvent gameEvent, UserStatisticsDatagroupEnum datagroup, int blobSize, IDictionary<int, bool> leaderboardPositionInfo, ICollection<MsgStatPostProcedureCall> procList)
        {
            // Get the list of leaderboards supported for the variant from GMS.
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();
            uint variant = gameEvent.GetPropertyValueAsUInt(GameResultConverterExtension.VariantPropertyName);
            GameVariantComposite gmsGameVariantComposite = gmsProxy.GetGameVariant(gameEvent.GameId, variant);

            ICollection<string> statColumns = gmsGameVariantComposite.StatRankings.Keys;
            foreach (var statColumn in statColumns)
            {
                // Get the leaderboardId.
                MobileAndWebRatingColumn ratingColumn = GetRatingColumn(statColumn);
                StatRanking statRanking = gmsGameVariantComposite.StatRankings[statColumn];
                MobileAndWebLeaderboardType leaderboardType = (datagroup == UserStatisticsDatagroupEnum.Lifetime)
                                                                  ? MobileAndWebLeaderboardType.Lifetime
                                                                  : MobileAndWebLeaderboardType.Weekly;
                int leaderboardId = MobileAndWebLeaderboardUtils.GetLeaderboardId(variant, ratingColumn, leaderboardType);

                // NOTE: Race condition: If a user posts better stats for the same leaderboard at the same time,
                // it is possible that the blob for the worse stats overwrites a better one.

                // Find out if the leaderboard stats have improved in the latest post.
                bool wasLeaderboardImproved = WasLeaderboardPositionImproved(gameEvent, leaderboardId, ratingColumn, statRanking);
                leaderboardPositionInfo.Add(leaderboardId, wasLeaderboardImproved);

                // Post new stats to the leaderboard.
                GetStatsForPosting(gameEvent, leaderboardId, gmsGameVariantComposite.StatRankings[statColumn], ratingColumn, wasLeaderboardImproved, blobSize, procList);
            }
        }

        /// <summary>
        /// Will the leaderboard position improve due to game event? Note that this does not actually post to the leaderboard.
        /// </summary>
        /// <param name="gameEvent">The game event that was posted.</param>
        /// <param name="leaderboardId">The id of the leaderboard for which the event was posted.</param>
        /// <param name="ratingColumn">The rating column for the leaderboard.</param>
        /// <param name="statRanking">The stat ranking for the leaderboard.</param>
        /// <returns>Will the leaderboard position improve due to game event?</returns>
        private static bool WasLeaderboardPositionImproved(GameEvent gameEvent, int leaderboardId, MobileAndWebRatingColumn ratingColumn, StatRanking statRanking)
        {
            StatsReadRequest request = new StatsReadRequest();
            request.TitleId = gameEvent.GameId;
            request.UserCount = 1;
            request.Users = new ulong[] { gameEvent.UserId };

            request.SpecCount = 1;
            request.Specs = new StatsSpec[1];
            request.Specs[0] = new StatsSpec();
            request.Specs[0].ViewId = (uint)leaderboardId;
            request.Specs[0].ColumnCount = 1;

            long? gameEventRatingValue;
            switch (ratingColumn)
            {
                case MobileAndWebRatingColumn.BestScore:
                    gameEventRatingValue = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.ScorePropertyName);
                    break;

                case MobileAndWebRatingColumn.BestTime:
                    gameEventRatingValue = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.TimePropertyName);
                    break;

                case MobileAndWebRatingColumn.MostWins:
                    string outcome = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.OutcomePropertyName);
                    bool winEvent = string.Compare(outcome, GameResultConverterExtension.OutcomeWin, true) == 0;
                    gameEventRatingValue = winEvent ? 1L : 0L;
                    break;

                default:
                    throw new SafeToDropException(GetColumnNotSupportedException(ratingColumn.ToString()));
            }

            // If there is no rating value posted, the leaderboard position could not have been improved.
            if (!gameEventRatingValue.HasValue)
            {
                return false;
            }

            // Change the sign to order in ascending order.
            if (statRanking == StatRanking.Low)
            {
                gameEventRatingValue *= -1;
            }

            // Just get the columnId of Rating field
            request.Specs[0].ColumnIds = new ushort[]
                                             {
                                                 MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Rating].AttributeId
                                             };

            // delegates for transaction handling/retrying
            Func<StatsReadRequest, ulong, StatsReadResponse> retryDelegate = LivecacheActionEngine.GetLeaderboardInfo;

            // Use the generic transaction handler for retrying transactions
            // Retrying RetryMax times with RetryFrequency seconds
            StatsReadResponse statsResponse = GdsRetryController.RetryFunc(
                                                    () => RetryMax,
                                                    RetryFrequency,
                                                    RetriableExceptionList,
                                                    (Exception ex, bool retriable) => ExceptionLogger("LivecacheActionEngine.WasLeaderboardPositionImproved()", ex, retriable),
                                                    () => retryDelegate(request, gameEvent.UserId));

            bool wasLeaderboardImproved;

            // In case there is no result, the current result by default improves the leaderboard rank.
            if (statsResponse == null || statsResponse.ResultsCount == 0)
            {
                wasLeaderboardImproved = true;
            }
            else
            {
                if (statsResponse.Results == null || statsResponse.Results.Count() == 0)
                {
                    wasLeaderboardImproved = true;
                }
                else
                {
                    StatsResultSet resultSet = statsResponse.Results[0];
                    if (resultSet.Rows == null || resultSet.Rows.Count() == 0)
                    {
                        wasLeaderboardImproved = true;
                    }
                    else
                    {
                        StatsRow statsRow = resultSet.Rows[0];

                        // If the rank is 0, the latest post will improve the leaderboard position.
                        if (statsRow.Rank == 0)
                        {
                            wasLeaderboardImproved = true;
                        }
                        else
                        {
                            ulong rating = statsRow.Rating;

                            // Add the stats value in DB to the value in the gameEvent to get the sum value.
                            if (ratingColumn == MobileAndWebRatingColumn.MostWins)
                            {
                                gameEventRatingValue += (long)rating;
                            }

                            wasLeaderboardImproved = gameEventRatingValue > (long)rating;
                        }
                    }
                }
            }

            return wasLeaderboardImproved;
        }

        /// <summary>
        /// Gets the exception to throw when the rating column is not supported.
        /// </summary>
        /// <param name="ratingColumn">The rating column which is not supported.</param>
        /// <returns>The exception to throw when the rating column is not supported.</returns>
        private static LIVEnException GetColumnNotSupportedException(string ratingColumn)
        {
            return new LIVEnException(
                                    RulesEvents.Events,
                                    RulesEvents.RatingColumnNotSupported,
                                    HttpStatusCode.InternalServerError,
                                    null,
                                    true,
                                    ratingColumn);
        }

        /// <summary>
        /// Gets the stats which can be posted to the leaderboard.
        /// </summary>
        /// <param name="gameEvent">The game event which has the stat.</param>
        /// <param name="leaderboardId">The id of the leaderboard for which to post stats.</param>
        /// <param name="statRanking">The stat ranking for the leaderboard.</param>
        /// <param name="ratingColumn">The rating column for the leaderboard.</param>
        /// <param name="wasLeaderboardImproved">Whether this post will improve the leaderboard position.</param>
        /// <param name="blobSize">The size of the blob in bytes.</param>
        /// <param name="procList">The stats procs which can be posted.</param>
        private static void GetStatsForPosting(
            GameEvent gameEvent, int leaderboardId, StatRanking statRanking, MobileAndWebRatingColumn ratingColumn, bool wasLeaderboardImproved, int blobSize, ICollection<MsgStatPostProcedureCall> procList)
        {
            // Get the values of the columns from the game event.
            long? newScoreColumnValue;
            long? newTimeColumnValue;
            long? newWinsColumnValueToAdd;
            long? newLossesColumnValueToAdd;
            GetNewColumnValues(gameEvent, out newScoreColumnValue, out newTimeColumnValue, out newWinsColumnValueToAdd, out newLossesColumnValueToAdd);

            // Get the stats order adjustment, this will be used for ascending/descending rating calculation.
            int orderAdjustment = GetOrderAdjustment(statRanking);

            // Get the info for rating column and find out the base column for the rating column.
            long? ratingColumnValue;
            ushort ratingProc;
            MobileAndWebRatingColumn baseColumn;
            switch (ratingColumn)
            {
                case MobileAndWebRatingColumn.BestScore:
                    ratingColumnValue = orderAdjustment * newScoreColumnValue;
                    ratingProc = StatPostProcedure.Max;
                    baseColumn = MobileAndWebRatingColumn.BestScore;
                    break;

                case MobileAndWebRatingColumn.BestTime:
                    ratingColumnValue = orderAdjustment * newTimeColumnValue;
                    ratingProc = StatPostProcedure.Max;
                    baseColumn = MobileAndWebRatingColumn.BestTime;
                    break;

                case MobileAndWebRatingColumn.MostWins:
                    ratingColumnValue = orderAdjustment * newWinsColumnValueToAdd;
                    ratingProc = StatPostProcedure.Add;
                    baseColumn = MobileAndWebRatingColumn.MostWins;
                    break;

                default:
                    throw new SafeToDropException(GetColumnNotSupportedException(ratingColumn.ToString()));
            }

            // Get the stats to be posted for the various columns.
            ushort columnId;

            // Get the Rating proc.
            if (ratingColumnValue.HasValue)
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Rating].AttributeId;
                procList.Add(GetStatPostProcedureCall(ratingProc, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, ratingColumnValue));
            }

            // Get the Score proc.
            if (newScoreColumnValue.HasValue && (baseColumn != MobileAndWebRatingColumn.BestScore || (baseColumn == MobileAndWebRatingColumn.BestScore && statRanking == StatRanking.Low)))
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.BestScore].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Min, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newScoreColumnValue));
            }

            // Get the Time proc.
            if (newTimeColumnValue.HasValue && (baseColumn != MobileAndWebRatingColumn.BestTime || (baseColumn == MobileAndWebRatingColumn.BestTime && statRanking == StatRanking.Low)))
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.BestTime].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Min, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newTimeColumnValue));
            }

            // Get the Games Played proc.
            columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.GamesPlayed].AttributeId;
            procList.Add(GetStatPostProcedureCall(StatPostProcedure.Add, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, 1L));

            // Get the Last Played Datetime proc.
            columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.LastPlayedDateTime].AttributeId;
            procList.Add(GetStatPostProcedureCall(StatPostProcedure.Replace, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, DateTime.UtcNow.Ticks));

            // Get the Wins proc.
            if (newWinsColumnValueToAdd.HasValue && (baseColumn != MobileAndWebRatingColumn.MostWins || (baseColumn == MobileAndWebRatingColumn.MostWins && statRanking == StatRanking.Low)))
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Wins].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Add, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newWinsColumnValueToAdd));
            }

            // Get the Cumulative Score proc.
            if (newScoreColumnValue.HasValue)
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.CumulativeScore].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Add, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newScoreColumnValue));
            }

            // Get the Cumulative Time proc.
            if (newTimeColumnValue.HasValue)
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.CumulativeTime].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Add, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newTimeColumnValue));
            }

            // Get the Losses proc.
            if (newLossesColumnValueToAdd.HasValue)
            {
                columnId = MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Losses].AttributeId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Add, gameEvent.UserId, leaderboardId, columnId, StatParam.Int64, newLossesColumnValueToAdd));
            }

            // Get the attachment size proc.
            if (wasLeaderboardImproved && (blobSize != 0))
            {
                columnId = UserProfileStorageLivecache.AttachmentSizeColumnId;
                procList.Add(GetStatPostProcedureCall(StatPostProcedure.Replace, gameEvent.UserId, leaderboardId, columnId, StatParam.Int32, blobSize));
            }
        }

        /// <summary>
        /// Gets the new values of the columns in the game event.
        /// </summary>
        /// <param name="gameEvent">The game event.</param>
        /// <param name="newScoreColumnValue">The value of score column in the game event.</param>
        /// <param name="newTimeColumnValue">The value of time column in the game event.</param>
        /// <param name="newWinsColumnValueToAdd">The value of win column in the game event.</param>
        /// <param name="newLossesColumnValueToAdd">The value of losses column in the game event.</param>
        private static void GetNewColumnValues(
            GameEvent gameEvent, out long? newScoreColumnValue, out long? newTimeColumnValue, out long? newWinsColumnValueToAdd, out long? newLossesColumnValueToAdd)
        {
            newScoreColumnValue = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.ScorePropertyName);
            newTimeColumnValue = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.TimePropertyName);

            string outcome = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.OutcomePropertyName);
            if (outcome == null)
            {
                newWinsColumnValueToAdd = null;
                newLossesColumnValueToAdd = null;
            }
            else
            {
                newWinsColumnValueToAdd = string.Compare(outcome, GameResultConverterExtension.OutcomeWin, true) == 0 ? 1L : 0L;
                newLossesColumnValueToAdd = string.Compare(outcome, GameResultConverterExtension.OutcomeLoss, true) == 0 ? 1L : 0L;
            }
        }

        /// <summary>
        /// Gets the order adjustment.
        /// </summary>
        /// <param name="statRanking">The stat ranking.</param>
        /// <returns>1 for higher is better, -1 for lower is better.</returns>
        private static int GetOrderAdjustment(StatRanking statRanking)
        {
            int orderAdjustment;

            switch (statRanking)
            {
                case StatRanking.High:
                    orderAdjustment = 1;
                    break;

                case StatRanking.Low:
                    orderAdjustment = -1;
                    break;

                default:
                    LIVEnException ex = new LIVEnException(
                                RulesEvents.Events,
                                RulesEvents.StatRankingNotSupported,
                                HttpStatusCode.InternalServerError,
                                null,
                                true,
                                statRanking.ToString());
                    throw new SafeToDropException(ex);
            }

            return orderAdjustment;
        }

        /// <summary>
        /// Gets the team ticket based on the game event.
        /// </summary>
        /// <param name="gameEvent">The game event.</param>
        /// <returns>The team ticket based on the game event.</returns>
        private static TeamTickets GetTeamTickets(GameEvent gameEvent)
        {
            TeamTickets teamTickets = new TeamTickets
                                          {
                                              wType = TeamTickets.TEAM_TICKETS_TYPE,
                                              wLength = 14,
                                              cTickets = 1,
                                              teamTickets = new TeamTicket[1]
                                          };
            teamTickets.teamTickets[0] = new TeamTicket(gameEvent.UserId, 1);

            return teamTickets;
        }

        /// <summary>
        /// Gets the procedure call to be applied based on the params.
        /// </summary>
        /// <param name="procId">The procedure Id.</param>
        /// <param name="userId">The userId.</param>
        /// <param name="leaderboardId">The leaderboardId.</param>
        /// <param name="columnId">The columnId.</param>
        /// <param name="columnParamType">The main stat column type.</param>
        /// <param name="columnValue">The main stat column value..</param>
        /// <returns>The procedure call to be applied based on the params.</returns>
        private static MsgStatPostProcedureCall GetStatPostProcedureCall(ushort procId, ulong userId, int leaderboardId, ushort columnId, byte columnParamType, object columnValue)
        {
            // No dependency capability needed.
            const short DependProcId = 0;

            MsgStatPostProcedureCall procedureCall = new MsgStatPostProcedureCall
                                                         {
                                                             _usProcId = procId,
                                                             _usParamCount = 5,
                                                             _params = new MsgStatPostParameter[5]
                                                         };

            short paramColumnId = (short)columnId;

            procedureCall._params[0] = new MsgStatPostParameter { _bParamType = StatParam.Puid, _data = userId };
            procedureCall._params[1] = new MsgStatPostParameter { _bParamType = StatParam.Int32, _data = leaderboardId };
            procedureCall._params[2] = new MsgStatPostParameter { _bParamType = StatParam.Int16, _data = DependProcId };
            procedureCall._params[3] = new MsgStatPostParameter { _bParamType = StatParam.Int16, _data = paramColumnId };
            procedureCall._params[4] = new MsgStatPostParameter { _bParamType = columnParamType, _data = columnValue };

            return procedureCall;
        }

        /// <summary>
        /// Gets the rating column based on the stat column string.
        /// </summary>
        /// <param name="statColumn">The stat column string</param>
        /// <returns>The rating column based on the stat column string.</returns>
        private static MobileAndWebRatingColumn GetRatingColumn(string statColumn)
        {
            MobileAndWebRatingColumn ratingColumn;

            try
            {
                ratingColumn = UserProfileStorageLivecache.GetRatingColumn(statColumn);
            }
            catch (ArgumentOutOfRangeException)
            {
                throw new SafeToDropException(GetColumnNotSupportedException(statColumn));
            }

            return ratingColumn;
        }

        /// <summary>
        /// Write the blob for the leaderboard entry to storage.
        /// </summary>
        /// <param name="gameEvent">The game event that has the blob.</param>
        /// <param name="byteBlob">The blob to write.</param>
        /// <param name="leaderboardId">The leaderboardId to which the blob must be posted.</param>
        private static void WriteBlob(GameEvent gameEvent, byte[] byteBlob, int leaderboardId)
        {
            if (byteBlob.Length > 0)
            {
                // Now actually put the Blob in the storage
                string attachmentPath = UserProfileStorageLivecache.GetAttachmentPath(
                    gameEvent.UserId, gameEvent.GameId, leaderboardId);

                // Expiring blobs that fall off the weekly leaderboard are expected to be cleaned up by SQL jobs.
                DateTime expirationDate = DateTime.MaxValue;

                // Use the generic transaction handler for retrying transactions
                // Retrying RetryMax times with RetryFrequency seconds
                StorageDelegate retryDelegate = LivecacheActionEngine.StorageWrite;

                try
                {
                    GdsRetryController.Retry(
                    RetryMax,
                    RetryFrequency,
                    RetriableExceptionList,
                    (Exception ex, bool retriable) => ExceptionLogger("LivecacheActionEngine.WriteBlob()", ex, retriable),
                    () => retryDelegate(gameEvent.UserId, attachmentPath, byteBlob, expirationDate, LivecacheClientType.LIVEn, gameEvent.GameId));
                }
                catch (Exception ex)
                {
                    // The exception is ignored, we are dropping this blob write. We make our best effort but do not rollback in case it fails.
                    LivecacheActionEngine.LogEvent(
                                            RulesEvents.Events,
                                            RulesEvents.LeaderboardDataBlobWriteFailed,
                                            ex,
                                            gameEvent.UserId.ToString(),
                                            attachmentPath,
                                            gameEvent.GameId.ToString());
                }
            }
        }

        /// <summary>
        /// Logs an event.
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="eventIndex">The index to the predefined event message.</param>
        /// <param name="exception">Inner exception.</param>
        /// <param name="arguments">Insertions strings for the message in message resource.</param>
        private static void LogEvent(EventsCollection events, int eventIndex, Exception exception, params string[] arguments)
        {
            string optionalMessage = string.Empty;
            if (exception != null)
            {
                optionalMessage = "\r\nException:\r\n" + exception.ToString();
            }

            events.TraceEvent(eventIndex, optionalMessage, arguments);
        }

        /// <summary>
        /// Post to the leaderboard, this is a wrapper to allow retriability.
        /// </summary>
        /// <param name="request">The stats post request.</param>
        /// <param name="callingLivePuid">The user for which the stats is being posted.</param>
        private static void PostLeaderboardResult(ReqStatPost request, ulong callingLivePuid)
        {
            ILcLeaderboards liveCacheLbds = Container.Instance.GetComponent<ILcLeaderboards>();
            try
            {
                liveCacheLbds.PostLeaderboardResult(request, callingLivePuid);
            }
            catch (LivecacheResponseException ex)
            {
                if (LivecacheRetriableException.IsRetriableException(ex))
                {
                    throw new LivecacheRetriableException(ex);
                }
                else
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Write to storage, this is a wrapper to allow retriability.
        /// </summary>
        /// <param name="ownerPuid">The blob owner's Puid.</param>
        /// <param name="path">The storage path.</param>
        /// <param name="data">The data to be written into storage.</param>
        /// <param name="expirationDate">The expiration data for the data.</param>
        /// <param name="clientType">The client type.</param>
        /// <param name="titleId">The titleId for which the blob is being posted.</param>
        private static void StorageWrite(ulong ownerPuid, string path, byte[] data, DateTime expirationDate, LivecacheClientType clientType, uint titleId)
        {
            // Get the countryId
            uint clientServiceId = LivecacheUtil.GetClientServiceId(clientType, LcserviceId.StorageWrite);
            LcserviceInfo si = LcserviceInfo.Lookup(clientServiceId);

            // Get current language and country.
            // When is CurrentLocaleHandler not set, default everything to zero.
            // Also default to zero if the SPI is not locale sensitive (eg. does not return a string).
            uint langId = 0;
            uint countryIdAsUint = 0;

            if (si.CultureSensitive && LivecacheRequest.CurrentLocaleHandler != null)
            {
                LivecacheRequest.CurrentLocaleHandler(out langId, out countryIdAsUint);
            }

            byte countryId = (byte)countryIdAsUint;
            try
            {
                Storage.StorageWrite(ownerPuid, path, data, expirationDate, countryId, clientType, titleId);
            }
            catch (LivecacheResponseException ex)
            {
                if (LivecacheRetriableException.IsRetriableException(ex))
                {
                    throw new LivecacheRetriableException(ex);
                }
                else
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Get the leaderboard info for the user, this is a wrapper to allow retriability.
        /// </summary>
        /// <param name="request">The stats read request.</param>
        /// <param name="callingLivePuid">The user for which to leaderboard information.</param>
        /// <returns>The stats read response to the call.</returns>
        private static StatsReadResponse GetLeaderboardInfo(StatsReadRequest request, ulong callingLivePuid)
        {
            StatsReadResponse statsReadResponse;
            ILcLeaderboards liveCacheLbds = Container.Instance.GetComponent<ILcLeaderboards>();
            try
            {
                statsReadResponse = liveCacheLbds.GetFriendsLeaderboardInfo(request, callingLivePuid);
            }
            catch (LivecacheResponseException ex)
            {
                if (LivecacheRetriableException.IsRetriableException(ex))
                {
                    throw new LivecacheRetriableException(ex);
                }
                else
                {
                    throw;
                }
            }

            return statsReadResponse;
        }

        /// <summary>
        /// Log exception using the event system.
        /// </summary>
        /// <param name="methodName">The name of the method.</param>
        /// <param name="exception">The exception.</param>
        /// <param name="retriable">Wther the operation that caused the exception is retriable.</param>
        private static void LogException(string methodName, Exception exception, bool retriable)
        {
            if (retriable)
            {
                LivecacheActionEngine.LogEvent(RulesEvents.Events, RulesEvents.RetriableExceptionOccurred, exception);
            }
            else
            {
                LivecacheActionEngine.LogEvent(RulesEvents.Events, RulesEvents.NonRetriableExceptionOccurred, exception);
            }

            ActionEngineDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, exception);
        }

        /// <summary>
        /// This exception indicates those game events which can be safely dropped.
        /// </summary>
        public class SafeToDropException : Exception
        {
            /// <summary>
            ///  Initializes a new instance of the SafeToDropException class.
            /// </summary>
            /// <param name="ex">The exception based on which this instance is being created.</param>
            public SafeToDropException(LIVEnException ex)
            {
                this.Ex = ex;
            }

            /// <summary>
            /// Gets or sets the LIVEn  exception that is the basis of this exception.
            /// </summary>
            protected LIVEnException Ex
            {
                get;
                set;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEngine.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ActionEngine.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0c85d43f-ca67-4e38-be82-dcb48e618dfb")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\BusinessObject.Test\Program.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="Program.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// NOTES: 
// 1) First Update by Savas Guven added string and stream converter functions and fixed bugs.
// </copyright>
// <summary>Serializer Deserializer Sample program</summary>
//-------------------------------------------------------------------------------------------------

namespace BusinessObject.Test
{
    using System;
    using System.IO;
    using Gds.Contracts;

    /// <summary>
    /// start point of test application
    /// </summary>
    public sealed class Program
    {
        public static void Main()
        {
            try
            {
                //TestGameEvent.Run();
                //TestActionSet.Run();
                TestGameResult.Run();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }

            Console.WriteLine("Press any key..");
            Console.ReadLine();
        }


        internal static object TestDeserializeFromString(string filePath, Type dataContractType)
        {
            FileStream fs = null;
            
            string validGameEventXml = string.Empty;

            if (!string.IsNullOrEmpty(filePath))
            {
                using (fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
                {
                    using (StreamReader sr = new StreamReader(fs, true))
                    {
                        validGameEventXml = sr.ReadToEnd();
                    }
                }
            }

            return SerializerDeserializer.DeserializeFromString(validGameEventXml, dataContractType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\WebstoreActionEngine.cs ===
﻿namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Gds.Contracts;
    using Gds.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Gds.Contracts.Converters;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using GDS.DataAccess.UserData;
    using Leet.Live.Livecache.Providers;
    using Leet.Utils;
    using Leet.Live.Livecache.DataAccess;
    using System.Threading;

    public class WebstoreActionEngine : IActionEngine
    {
        private static IUserProfileStorage UserProfileStorage { get; set; }

        // At this point of the code, the gmsProxy MUST exist. No need for null check. (*)
        private static IGameMetadataClient GameMetadataClient { get; set; }

        static WebstoreActionEngine()
        {
            WebstoreActionEngine.UserProfileStorage = Container.Instance.GetComponent<IUserProfileStorage>();
            WebstoreActionEngine.GameMetadataClient = Container.Instance.GetComponent<IGameMetadataClient>();

        }

        public void Execute(string xmlActionSet, string gameEvent)
        {
            GameEvent myGameEvent = null;

            if (!string.IsNullOrEmpty(gameEvent))
            {
                myGameEvent = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEvent, typeof(GameEvent));
            }

            if (myGameEvent == null)
            {
                ActionEngineDiag.Logging.LogEvent(new InvalidGameEvent(), "GameEvent={0}", gameEvent);
                throw new ActionEngineArgumentException("Invalid GameEvent XML, it is a required to be valid: myGameEvent");
            }

            try
            {
                // Lifetime
                this.ProcessGameEvent(myGameEvent, 0);

                // Current week.
                this.ProcessGameEvent(myGameEvent, UserDataUtilities.GetDatagroupNumberForDate(DateTime.UtcNow));
            }
            // by-pass ActionEngineExceptions
            catch (ActionEngineException)
            {
                throw;
            }
            catch (UserProfileDataAccessOperationException ex)
            {
                throw new ActionEngineOperationException("A DAL operation exception has occured, check inner exception for more details", ex);
            }
            catch (UserProfileDataAccessArgumentException ex)
            {
                throw new ActionEngineArgumentException("A DAL argument exception has occured, check inner exception for more details", ex);
            }
            catch (Exception ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SqlExceptionError(), ex, "An unknown processing exception has occured GameEvent = {0}", gameEvent);
                throw new ActionEngineException("An unknown exception has occured, check inner exception for more details", ex);
            }
        }

        private void ProcessGameEvent(GameEvent gameEvent, uint datagroup)
        {
            // fetch stat 
            uint variant = gameEvent.GetPropertyValueAsUInt(GameResultConverterExtension.VariantPropertyName);

            UserStatsEx existingStatistic =
                ExceptionLoggingCallToDAL(() => WebstoreActionEngine.UserProfileStorage.GetStatisticEntry(gameEvent.UserId, gameEvent.GameId, variant, datagroup));

            if (existingStatistic == null)
            {
                existingStatistic = new UserStatsEx()
                {
                    Xuid = UncheckedConvert.ToInt64(gameEvent.UserId),
                    GameID = UncheckedConvert.ToInt32(gameEvent.GameId),
                    Variant = UncheckedConvert.ToInt32(variant),
                    Datagroup = UncheckedConvert.ToInt32(datagroup)
                };
            }
            // The last message processed is being re-processed.
            else if (existingStatistic.GameEventID == gameEvent.GameEventId)
            {
                // Log - this May happen under transient error cases where 
                // Lifetime submission is processed, but the Week1 failed, and a re-try is being attempted.
                ActionEngineDiag.Logging.LogEvent(new IdempotencyExceptionError(), "A DAL exception has occured for Idempotency: GameEventId={0}", existingStatistic.GameEventID);   
#if DBG
                // If it does, SSB is not locking the conversation group, the way it is supposed to.
                throw new ActionEngineIdempotencyException("This message was previously processed");
#endif
                // silently return 
                return;
            }

            // process
            bool isBlobWriteNecessary = this.UpdateUserStat(existingStatistic, gameEvent);
            
            if (isBlobWriteNecessary)
            {
                // insert-update blob if any
                InsertOrUpdateBlob(existingStatistic, gameEvent);
            }

            // update stat
            ExceptionLoggingCallToDAL(() => WebstoreActionEngine.UserProfileStorage.InsertOrUpdateStatForUser(existingStatistic));

            // schedule a syncTitle call
            ActionEngineUtils.UpdateSyncTitle(gameEvent);
        }

        private static void InsertOrUpdateBlob(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            string base64blob = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.BlobPropertyName);

            if (!string.IsNullOrEmpty(base64blob))
            {
                // May throw FormatException if string is invalid formatted.
                byte[] byteBlob = Convert.FromBase64String(base64blob);

                if (byteBlob.Length > 0)
                {
                    if (existingStatistic.BlobID.HasValue)
                    {
                        ExceptionLoggingCallToDAL(() => WebstoreActionEngine.UserProfileStorage.UpdateBlob(existingStatistic.BlobID.Value, byteBlob, DateTime.UtcNow));
                    }
                    else
                    {
                        Guid blobId = ExceptionLoggingCallToDAL(() =>
                            WebstoreActionEngine.UserProfileStorage.InsertBlob(byteBlob, DateTime.UtcNow));
                        existingStatistic.BlobID = blobId;
                    }
                }
            }
        }

        /// <summary>
        /// Updates in-place the existingStatistic, according to the gameEvent submission.
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns>
        /// Returns true if a blob write is allowed 
        /// (for new 'Best' stat on Leaderboardable property: i.e. BestTime OR BestScore)
        /// false if not.
        /// </returns>
        private bool UpdateUserStat(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            bool isBlobWriteRequired = false;

            existingStatistic.GameEventID = gameEvent.GameEventId;
            existingStatistic.GameSessionID = gameEvent.GameSessionId;
            existingStatistic.PlatformID = UncheckedConvert.ToInt32(gameEvent.PlatformId);

            // A change in the following statistics only will cause a blob update.
            isBlobWriteRequired |= this.UpdateBestScore(existingStatistic, gameEvent);
            isBlobWriteRequired |= this.UpdateBestTime(existingStatistic, gameEvent);
            
            this.UpdateCumulativeScore(existingStatistic, gameEvent);
            this.UpdateCumulativeTime(existingStatistic, gameEvent);
            this.UpdateWins(existingStatistic, gameEvent);
            this.UpdateLosses(existingStatistic, gameEvent);
            this.UpdateTie(existingStatistic, gameEvent);

            this.UpdateGamesPlayed(existingStatistic, gameEvent);

            existingStatistic.DTUpdated = DateTime.UtcNow;
            existingStatistic.DTCreated = DateTime.UtcNow;

            return isBlobWriteRequired;
        }

        /// <summary>
        /// GamesPlayed - is an unsigned operation
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        private void UpdateGamesPlayed(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            ulong gamesPlayed = UncheckedConvert.ToUInt64(existingStatistic.GamesPlayed ?? 0);
            gamesPlayed++;
            existingStatistic.GamesPlayed = UncheckedConvert.ToInt64(gamesPlayed);
        }

        /// <summary>
        /// We actually don't track Ties as an explicit stat,
        /// but a valid Tie outcome should result in an update of several fields: such as GamesPlayed, Last played time, etc.
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateTie(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            string outcome = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.OutcomePropertyName);

            bool isTie = String.Equals(outcome, GameResultConverterExtension.OutcomeTie, StringComparison.OrdinalIgnoreCase);

            return isTie;
        }
        
        /// <summary>
        /// Loss is an Unsigned operation
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateLosses(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            string outcome = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.OutcomePropertyName);

            bool isLoss = String.Equals(outcome, GameResultConverterExtension.OutcomeLoss, StringComparison.OrdinalIgnoreCase);

            if (isLoss)
            {
                ulong losses = UncheckedConvert.ToUInt64(existingStatistic.Losses ?? 0);
                losses++;
                existingStatistic.Losses = UncheckedConvert.ToInt64(losses);
            }

            return isLoss;
        }

        /// <summary>
        /// Wins is an unsigned operation
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateWins(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            string outcome = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.OutcomePropertyName);

            bool isWin = String.Equals(outcome, GameResultConverterExtension.OutcomeWin, StringComparison.OrdinalIgnoreCase);

            if (isWin)
            {
                ulong wins = UncheckedConvert.ToUInt64(existingStatistic.Wins ?? 0);
                wins++;
                existingStatistic.Wins = UncheckedConvert.ToInt64(wins);
            }

            return isWin;
        }

        /// <summary>
        /// Cumulative Time is UNSIGNED operation
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateCumulativeTime(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            long? gameTime = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.TimePropertyName);

            // gameTime of zero is an allowed value.
            if (gameTime.HasValue && gameTime > -1)
            {
                ulong cumulativeTime = UncheckedConvert.ToUInt64(existingStatistic.CumulativeTime ?? 0);
                cumulativeTime += (ulong)(gameTime.Value);
                existingStatistic.CumulativeTime = UncheckedConvert.ToInt64(cumulativeTime);
                return true;
            }

            return false;
        }

        /// <summary>
        /// This operation is using SIGNED arithmetics.
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateCumulativeScore(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            long? gameScore = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.ScorePropertyName);

            if (gameScore.HasValue && gameScore > 0)
            {
                long cumulativeScore = existingStatistic.CumulativeScore ?? 0;
                cumulativeScore += gameScore.Value;
                existingStatistic.CumulativeScore = cumulativeScore;
                return true;
            }

            return false;
        }

        /// <summary>
        /// This is an UNSIGNED arithmetic
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateBestTime(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            StatRanking? rankingOrder = null;

            try
            {
                uint gameId = gameEvent.GameId;
                uint variant = gameEvent.GetPropertyValueAsUInt(GameResultConverterExtension.VariantPropertyName); 

                rankingOrder = GetRankingForGameVariantProperty(gameId, variant, StatisticsConstants.BestTime);

                long? gameTimeActual = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.TimePropertyName);

                // no update necessary
                if (!gameTimeActual.HasValue)
                {
                    return false;
                }

                ulong gameTimeApparent = UncheckedConvert.ToUInt64(gameTimeActual.Value);
                ulong? existingBestTime = null;
                
                if (existingStatistic.BestTime.HasValue)
                {
                    existingBestTime = UncheckedConvert.ToUInt64(existingStatistic.BestTime.Value);
                }

                // If rankingOrder has no value, will default to using High being the better stat.
                ulong? updatedBestTime = DetermineNewBestStat<ulong>(rankingOrder.Value, gameTimeApparent, existingBestTime);

                if (updatedBestTime.HasValue)
                {
                    existingStatistic.BestTime = UncheckedConvert.ToInt64(updatedBestTime.Value);

                    // Only return true, if a blob update/insert is required.
                    // this can only happen if there is a rankingOrder, the absence of it means, 
                    // this stat is not being tracked 
                    if (rankingOrder.HasValue)
                    {
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                if (rankingOrder.HasValue && rankingOrder.Value == StatRanking.Low)
                {
                    ActionEngineDiag.Logging.LogEvent(new MinPropertyFailed(), ex.ToString());
                }
                else
                {
                    ActionEngineDiag.Logging.LogEvent(new MaxPropertyFailed(), ex.ToString());
                }

                throw;
            }

            return false;
        }

        /// <summary>
        /// BestScore is a SIGNED arithmetic, negatives are allowed.
        /// </summary>
        /// <param name="existingStatistic"></param>
        /// <param name="gameEvent"></param>
        /// <returns></returns>
        private bool UpdateBestScore(UserStatsEx existingStatistic, GameEvent gameEvent)
        {
            StatRanking? rankingOrder = null;
            try
            {
                uint gameId = gameEvent.GameId;
                uint variant = gameEvent.GetPropertyValueAsUInt(GameResultConverterExtension.VariantPropertyName);

                rankingOrder = GetRankingForGameVariantProperty(gameId, variant, StatisticsConstants.BestScore);

                long? gameScore = gameEvent.GetPropertyValueAsLong(GameResultConverterExtension.ScorePropertyName);
                if (!gameScore.HasValue)
                {
                    return false;
                }

                // If rankingOrder has no value, will default to using High being the better stat.
                long? updatedBestScore = DetermineNewBestStat<long>(rankingOrder.Value, gameScore, existingStatistic.BestScore);

                if (updatedBestScore.HasValue)
                {
                    existingStatistic.BestScore = updatedBestScore.Value;

                    // Only return true, if a blob update/insert is required.
                    // this can only happen if there is a rankingOrder, the absence of it means, 
                    // this stat is not being tracked 
                    if (rankingOrder.HasValue)
                    {
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                if (rankingOrder.HasValue && rankingOrder.Value == StatRanking.Low)
                {
                    ActionEngineDiag.Logging.LogEvent(new MinPropertyFailed(), ex.ToString());
                }
                else
                {
                    ActionEngineDiag.Logging.LogEvent(new MaxPropertyFailed(), ex.ToString());
                }

                throw;
            }

            return false;
        }

        /// <summary>
        /// Based on the RankingOrder (High or Low), compares new and existing Stats.
        /// if the new score is considered better, it is returned otherwise null is returned.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="rankingOrder"></param>
        /// <param name="newStat"></param>
        /// <param name="existingStat">can have no value</param>
        /// <returns></returns>
        private static T? DetermineNewBestStat<T>(StatRanking? rankingOrder, T? newStat, T? existingStat)
            where T : struct, IComparable
        {
            // if newStat has no value, return existingStat as is.
            if (!newStat.HasValue)
            {
                return existingStat;
            }

            // if existingStat has no value, return newStat as is.
            if (!existingStat.HasValue)
            {
                return newStat;
            }

            // If no StatRanking is defined, simply default to High being the better stat.
            StatRanking rankingToUse = rankingOrder ?? StatRanking.High;

            // If both values do exist, determine which one is better.
            // If higher stat is better.
            if (rankingToUse == StatRanking.High)
            {
                // we update as long as the existingStat is same or less
                // if (existingStat <= newStat)
                if (existingStat.Value.CompareTo(newStat.Value) < 1)
                {
                    return newStat;
                }
            }
            // if lower stat is better. i.e. 
            // if (existingStat >= newStat)
            else if (existingStat.Value.CompareTo(newStat.Value) > -1)
            {
                return newStat;
            }

            return existingStat;
        }
        
        private static StatRanking? GetRankingForGameVariantProperty(uint gameId, uint variant, string property)
        {
            GameVariantComposite gvc = WebstoreActionEngine.GameMetadataClient.GetGameVariant(gameId, variant);
            if (gvc != null)
            {
                // fetch properties statranking (for ex: "BestScore"s ) from GMS metadata
                KeyValuePair<string, StatRanking> itemResult = gvc.StatRankings.FirstOrDefault( 
                    (KeyValuePair<string, StatRanking> item) => item.Key.Equals(property, StringComparison.OrdinalIgnoreCase) );
                
                // itemResult is a struct, on default, the itemResult.Value shall be null.
                // hence no need for null check.
                return itemResult.Value;
            }
            else
            {
                // the GVC must exist.
                throw new ActionEngineOperationException(String.Format("The GameVariantComposite for given game:{0}, variant:{1} does NOT exist", gameId, variant));
            }
        }

        // Catches DAL exceptions and logs them.
        private static TResult ExceptionLoggingCallToDAL<TResult>(Func<TResult> configCallDelegate)
        {
            try
            {
                return configCallDelegate();
            }
            catch (UserProfileDataAccessOperationException ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SqlExceptionError(), ex, "A DAL exception has occured");   
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEgine\TestActionEngine.cs ===
﻿
namespace Gds.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Text;
    using System.Threading;
    using Gds.Contracts;
    using Gds.Contracts.ActionEngine;
    using Gds.Contracts.Converters;
    using GDS.DataAccess.UserData;
    using Leet.Core;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Providers;
    using Leet.Utils;
    using Leet.Core.Diagnostics;
    /// <summary>
    /// The test Action Engine that posts back to the DT in-memory and updates the basic SQL store.
    /// </summary>
    public class TestActionEngine : IActionEngine
    {
        private const string ActionNotSupportedExceptionString = "Badge related actions are cut from V1.";
        private const string DefaultNamespace = "xmlns=\"http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine\"";
        private const string AnotherNamespace = "xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\"";
        private const string InjectionPoint = "<ActionSet";
        private const string InternalEventString = "InternalEvent";

        private const string VariantPropertyName = "Variant";
        private const string ScorePropertyName = "Score";
        private const string TimePropertyName = "Time";

        private const string SyncTitlesAction = "SyncTitles";

        private static Dictionary<string, ExecuteDelegate> actionTable;

        /// <summary>
        /// Initializes a new instance of the TestActionEngine class
        /// </summary>
        public TestActionEngine()
        {
            this.Initialize();
        }

        private delegate void ExecuteDelegate(RuleAction ra, GameEvent ge, UserStatisticsDatagroupEnum dm);

        /// <summary>
        /// Schedule the Execution of the given action set
        /// </summary>
        /// <param name="xmlActionSet">a string containing the XML action set</param>
        /// <param name="gameEvent">a string containign the game event</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Text.StringBuilder.AppendFormat(System.String,System.Object[])")]
        public void Execute(string xmlActionSet, string gameEvent)
        {
            GameEvent myGameEvent = null;

            if (string.IsNullOrEmpty(xmlActionSet) || xmlActionSet.Length < TestActionEngine.InjectionPoint.Length)
            {
                ActionEngineDiag.Logging.LogEvent(new InvalidActionSet(), "ActionSet={0}", xmlActionSet);
                throw new ArgumentException("xmlActionSet is invalid size", "xmlActionSet");
            }

            // TODO: the actionSet comes without a namespace, let's inject one temporarily.
            // we need to figure out the real solution here. This is extremely kludgy
            StringBuilder sb = new StringBuilder(1024);
            sb.AppendFormat("{0} {1} {2} {3}", 
                            TestActionEngine.InjectionPoint, 
                            TestActionEngine.DefaultNamespace,
                            TestActionEngine.AnotherNamespace,
                            xmlActionSet.Substring(TestActionEngine.InjectionPoint.Length));
            xmlActionSet = sb.ToString();

            RuleActionSet ras = (RuleActionSet)SerializerDeserializer.DeserializeFromString(xmlActionSet, typeof(RuleActionSet));

            if (ras == null)
            {
                ActionEngineDiag.Logging.LogEvent(new InvalidActionSet(), "ActionSet={0}", xmlActionSet);
                throw new ArgumentException("Invalid ActionSet XML");
            }

            if (TestActionEngine.ContainsEventGeneration(ras))
            {
                if (string.IsNullOrEmpty(gameEvent))
                {
                    ActionEngineDiag.Logging.LogEvent(new InvalidGameEvent(), "GameEvent={0}", gameEvent);
                    throw new ArgumentNullException("gameEvent", "For action sets containing internal event generation xmlEvent is a required parameter");
                }

                myGameEvent = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEvent, typeof(GameEvent));

                if (myGameEvent == null)
                {
                    ActionEngineDiag.Logging.LogEvent(new InvalidGameEvent(), "GameEvent={0}", gameEvent);
                    throw new ArgumentException("Invalid GameEvent XML, it is a required to be valid", "myGameEvent");
                }
            }
            else
            {
                // TODO: investigate the need for this else statement. 
                // currently we need this to work.
                myGameEvent = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEvent, typeof(GameEvent));
                if (myGameEvent == null)
                {
                    ActionEngineDiag.Logging.LogEvent(new InvalidGameEvent(), "GameEvent={0}", gameEvent);
                    throw new ArgumentException("Invalid GameEvent XML, it is a required to be valid", "myGameEvent");
                }
            }

            // execute actions
            foreach (RuleAction action in ras.RuleActions)
            {
                if (String.Compare(action.Name, SyncTitlesAction, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    // for SyncTitles UserStatisticsDatagroupEnum argument is not used, calling once is enough
                    TestActionEngine.actionTable[action.Name](action, myGameEvent, UserStatisticsDatagroupEnum.Lifetime);
                }
                else
                {
                    TestActionEngine.actionTable[action.Name](action, myGameEvent, UserStatisticsDatagroupEnum.Lifetime);
                    TestActionEngine.actionTable[action.Name](action, myGameEvent, UserStatisticsDatagroupEnum.W1);
                }
            }
        }

        /// <summary>
        /// Implementing the Dispose pattern to close down any resources 
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public void Dispose()
        {
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object,System.Object)")]
        private static void RemoveBlob(Guid? blobId)
        {
            IUserDataStorage userDataStorage = Container.Instance.GetComponent<IUserDataStorage>();
            UserDataError deleteBlobError = new UserDataError { ErrorCode = 0, ErrorMessage = null };

            if (blobId.IsNullOrEmpty())
            {
                return;
            }

            try
            {
                // TODO: if this fails, we are leaking a blob entry.
                // we do need an extra process to track orphaned/zombied blobs.
                deleteBlobError = userDataStorage.DeleteBlob(blobId.Value);
            }
            catch (SqlException ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SqlExceptionError(), ex, "BlobId={0}", blobId.ToString());
            }
            finally
            {
                if (deleteBlobError.ErrorCode != UserDataError.SuccessCode)
                {
                    ActionEngineDiag.Logging.LogEvent(new RemoveBlobFailed(), "BlobId={0}, DeleteBlobErrorCode={1}, DeleteBlobErrorMessage={2}", blobId.ToString(), deleteBlobError.ErrorCode, deleteBlobError.ErrorMessage);
                }
            }
        }

        /// <summary>
        /// Initialize this Action Engine (create any SQL connection here)
        /// </summary>
        private void Initialize()
        {
            if (actionTable == null)
            {
                Dictionary<string, ExecuteDelegate> tmp = new Dictionary<string, ExecuteDelegate>(5, StringComparer.Ordinal);

                // only 1 thread can enter here
                if (Interlocked.CompareExchange(ref TestActionEngine.actionTable, tmp, null) == null)
                {
                    // TODO: Move this entire logic to be loaded from DB.
                    tmp.Add(SumPropertyAction.ActionName, new ExecuteDelegate(this.SumProperty));
                    tmp.Add(MaxPropertyAction.ActionName, new ExecuteDelegate(this.MaxProperty));
                    tmp.Add(SyncTitlesAction, new ExecuteDelegate(this.SyncTitles));

                    // TODO: we will be deprecating "PreCannedActionBase" and its derived classes.
                    // Hence, what was previously "MinPropertyAction.ActionName" will NOT exist.
                    // The replacement will be to load from ActionDefinition table from the Reward DB.
                    // As a consequence the name "MinProperty will be loaded from the "ActionDefinition.Name"
                    tmp.Add("MinProperty", new ExecuteDelegate(this.MinProperty));
                    tmp.Add(CreateAndSubmitEventAction.ActionName, new ExecuteDelegate(this.CreateAndSubmitEvent));
                }
            }
        }

        /// <summary>
        /// Assumes one of the sumX params contains the path to the user stat
        /// and the other sumX param contains the path to the event event property.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="gameEvent"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.Parse(System.String)")]
        private void SumProperty(RuleAction action, GameEvent gameEvent, UserStatisticsDatagroupEnum datagroupMode)
        {
            Console.WriteLine("SumProperty");

            // NOTE: for demo purposes ignore all action parameters but simply add the prop value up.
            string statName;
            long? summationValue = 0;

            bool performOperation = false;

            uint datagroupNumber = 0;

            if (datagroupMode == UserStatisticsDatagroupEnum.W1)
            {
                datagroupNumber = UserDataUtilities.GetDatagroupNumberForDate(gameEvent.TimeStamp);
            }

            statName = ActionParameterUtility.TryGetStatisticName(action, ActionParameterUtility.SumActionParameterNamePreamble);

            if (!string.IsNullOrEmpty(statName))
            {
                string propertyName = ActionParameterUtility.TryGetPropertyName(action, ActionParameterUtility.SumActionParameterNamePreamble);

                if (!string.IsNullOrEmpty(propertyName))
                {
                    // BUG BUG: Assumes that the type of the property is strictly Ulong, 
                    // possibly a crummy assumption at best for v1, and outright a bug for the full-feature set.
                    summationValue = gameEvent.GetPropertyValueAsLong(propertyName);
                    performOperation = true;
                }
                else
                {
                    string value = ActionParameterUtility.TryGetValueParameterValue(action, ActionParameterUtility.SumActionParameterNamePreamble);
                    if (!string.IsNullOrEmpty(value))
                    {
                        summationValue = long.Parse(value);
                        performOperation = true;
                    }
                }

                if (performOperation)
                {
                    TestActionEngine.ExecuteOperationOnStatLong(gameEvent, UserDataOperationEnum.SumProperty, statName, datagroupNumber, summationValue.Value, null);
                    return;
                }
            }

            ActionEngineDiag.Logging.LogEvent(new SumPropertyFailed());
        }

        private void MaxProperty(RuleAction action, GameEvent gameEvent, UserStatisticsDatagroupEnum datagroupMode)
        {
            UserDataError sqlError = new UserDataError();
            bool undoBlob = false;

            string statName;
            string propertyName;

            uint datagroupNumber = 0;

            if (datagroupMode == UserStatisticsDatagroupEnum.W1)
            {
                datagroupNumber = UserDataUtilities.GetDatagroupNumberForDate(gameEvent.TimeStamp);
            }

            statName = ActionParameterUtility.TryGetStatisticName(action, ActionParameterUtility.MaxActionParameterNamePreamble);
            propertyName = ActionParameterUtility.TryGetPropertyName(action, ActionParameterUtility.MaxActionParameterNamePreamble);

            if (!string.IsNullOrEmpty(statName) && !string.IsNullOrEmpty(propertyName))
            {
                // BUG BUG: Assumes that the type of the property is strictly Ulong, 
                // possibly a crummy assumption at best for v1, and outright a bug for the full-feature set.
                long? maxValue = gameEvent.GetPropertyValueAsLong(propertyName);

                Guid? blobId = TestActionEngine.InsertOrUpdateBlob(gameEvent, UserDataOperationEnum.MaxProperty, maxValue.Value, statName, datagroupNumber);

                try
                {
                    sqlError = TestActionEngine.ExecuteOperationOnStatLong(gameEvent, UserDataOperationEnum.MaxProperty, statName, datagroupNumber, maxValue.Value, blobId);

                    if (sqlError.ErrorCode != UserDataError.SuccessCode)
                    {
                        undoBlob = true;
                    }
                }
                catch (SqlException)
                {
                    undoBlob = true;
                    throw;
                }
                finally
                {
                    if (undoBlob)
                    {
                        RemoveBlob(blobId);
                    }
                }
            }
            else
            {
                ActionEngineDiag.Logging.LogEvent(new MaxPropertyFailed());
            }
        }

        private void MinProperty(RuleAction action, GameEvent gameEvent, UserStatisticsDatagroupEnum datagroupMode)
        {
            string statName;
            string propertyName;
            UserDataError sqlError;
            bool undoBlob = false;

            uint datagroupNumber = 0;

            if (datagroupMode == UserStatisticsDatagroupEnum.W1)
            {
                datagroupNumber = UserDataUtilities.GetDatagroupNumberForDate(gameEvent.TimeStamp);
            }

            statName = ActionParameterUtility.TryGetStatisticName(action, ActionParameterUtility.MinActionParameterNamePreamble);
            propertyName = ActionParameterUtility.TryGetPropertyName(action, ActionParameterUtility.MinActionParameterNamePreamble);

            if (!string.IsNullOrEmpty(statName) && !string.IsNullOrEmpty(propertyName))
            {
                // BUG BUG: Assumes that the type of the property is strictly Ulong, 
                // possibly a crummy assumption at best for v1, and outright a bug for the full-feature set.
                long? minValue = gameEvent.GetPropertyValueAsLong(propertyName);

                Guid? blobId = TestActionEngine.InsertOrUpdateBlob(gameEvent, UserDataOperationEnum.MinProperty, minValue.Value, statName, datagroupNumber);

                try
                {
                    sqlError = TestActionEngine.ExecuteOperationOnStatLong(gameEvent, UserDataOperationEnum.MinProperty, statName, datagroupNumber, minValue.Value, null);

                    if (sqlError.ErrorCode != UserDataError.SuccessCode)
                    {
                        undoBlob = true;
                    }
                }
                catch (SqlException)
                {
                    undoBlob = true;
                    throw;
                }
                finally
                {
                    if (undoBlob)
                    {
                        RemoveBlob(blobId);
                    }
                }
            }
            else
            {
                ActionEngineDiag.Logging.LogEvent(new MinPropertyFailed());
            }
        }

        /// <summary>
        /// checks whether a blob exists in the current GameEvent
        /// If Yes, Check if current stat will be updated: score or time is higher/lower than the one already there
        ///     If Yes, then update/insert blob.
        /// If No, Do nothing.
        /// </summary>
        /// <param name="gameEvent"></param>
        /// <param name="userDataOperationEnum"></param>
        /// <param name="maxValue"></param>
        /// <param name="statName"></param>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        private static Guid? InsertOrUpdateBlob(
                            GameEvent gameEvent,
                            UserDataOperationEnum userDataOperationEnum,
                            long minOrmaxValue,
                            string statName,
                            uint datagroup)
        {
            bool storeBlob = false;
            Guid? blobId = null;
            UserStat statEntry = null;

            try
            {
                // Determine first if it is ok to store blob for this statistic:
                IDictionary<string, IUserStorageConverterFilter> converterFilter = ActionUtilities.GetStatConverterFromGmsSettings(
                                                                                            gameEvent.GameId, 
                                                                                            gameEvent.GetPropertyValueAsUInt(TestActionEngine.VariantPropertyName));
                
                // This may constitute an early optimization. The idea is as following:
                // If this stat entry is ultimately removed when it is reported to the user, simply never store it.
                if (converterFilter[statName].IsRemoved)
                {
                    return null;
                }

                IUserDataStorage userDataStorage = Container.Instance.GetComponent<IUserDataStorage>();

                string base64blob = gameEvent.GetPropertyValueAsString(GameResultConverterExtension.BlobPropertyName);

                if (string.IsNullOrEmpty(base64blob))
                {
                    return null;
                }

                // may throw FormatException if string is invalid formatted.
                byte[] byteBlob = Convert.FromBase64String(base64blob);

                if (byteBlob.Length < 1)
                {
                    return null;
                }

                // check if current stat does exists.
                statEntry = userDataStorage.GetStatisticEntry(
                                            gameEvent.UserId,
                                            gameEvent.GameId,
                                            gameEvent.GetPropertyValueAsUInt(TestActionEngine.VariantPropertyName),
                                            statName,
                                            datagroup);

                // We should only evaluate the need for storing, if there is 
                // a) a statistic entry for the given property AND
                // b) it has a valid blobId.
                // Otherwise, simply proceed with inserting a blobId.
                if (statEntry != null && !statEntry.BlobID.IsNullOrEmpty())
                {
                    // well we need to compare the existing score, and see if an insert/update is warranted.
                    switch (userDataOperationEnum)
                    {
                        case UserDataOperationEnum.MaxProperty:
                            if (statEntry.Value < minOrmaxValue)
                            {
                                storeBlob = true;
                            }

                            break;

                        case UserDataOperationEnum.MinProperty:
                            if (statEntry.Value > minOrmaxValue)
                            {
                                storeBlob = true;
                            }

                            break;

                        default:
                            // we don't support non-max/min blobs.
                            return null;
                    }

                    blobId = statEntry.BlobID;
                }
                else
                {
                    storeBlob = true;
                }

                // either insert or update.
                if (storeBlob)
                {
                    // if we have a valid (old) Blob Id, ensure we just do an update, and not an insert.
                    if (!blobId.IsNullOrEmpty())
                    {
                        userDataStorage.UpdateBlob(blobId.Value, byteBlob, DateTime.UtcNow);
                    }
                    else
                    {
                        blobId = userDataStorage.InsertBlob(byteBlob, DateTime.UtcNow);
                    }

                    return blobId;
                }
            }
            catch (SqlException ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SqlExceptionError(), ex);
                throw;
            }
            catch (FormatException ex)
            {
                ActionEngineDiag.Logging.LogEvent(new InsertOrUpdateBlobFailed(), ex);
            }

            return blobId;
        }

        private void CreateAndSubmitEvent(RuleAction action, GameEvent gameEvent, UserStatisticsDatagroupEnum dm)
        {
            throw new NotImplementedException(TestActionEngine.ActionNotSupportedExceptionString);
        }

        /// <summary>
        /// An action to call SyncTitles through LiveCache
        /// </summary>
        /// <param name="ruleAction">Contains the Action set</param>
        /// <param name="gameEvent">GameEvent object</param>
        /// <param name="dm">Datagroup enumeration (unused)</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private void SyncTitles(RuleAction ruleAction, GameEvent gameEvent, UserStatisticsDatagroupEnum dm)
        {
            ushort lcid = 0;
            try
            {
                LIVEnServiceMobileExtendedAuthDataProvider.PlatformType = gameEvent.PlatformId.ToString();
                LIVEnServiceMobileExtendedAuthDataProvider.Puid = gameEvent.UserId;

                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

                if (!string.IsNullOrEmpty(gameEvent.Culture))
                {
                    lcid = localeHelper.GetLCID(gameEvent.Culture);
                }

                var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();
                achievementDataAccess.SyncTitles(gameEvent.GameId, gameEvent.UserId, lcid, gameEvent.TimeStamp);
            }
            catch (Exception ex)
            {
                ActionEngineDiag.Logging.LogEvent(new SyncTitlesFailed(), ex, "TitleId={0}, XUID={1}, Lcid={2}, Timestamp={3}", gameEvent.GameId, gameEvent.UserId, lcid, String.Format("{0:u}", gameEvent.TimeStamp));
            }
        }

        private static bool ContainsEventGeneration(RuleActionSet ras)
        {
            foreach (RuleAction action in ras.RuleActions)
            {
                if (String.Equals(action.Name, CreateAndSubmitEventAction.ActionName, StringComparison.Ordinal))
                {
                    return true;
                }
            }

            return false;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object[])")]
        private static UserDataError ExecuteOperationOnStatLong(
                                GameEvent gameEvent, 
                                UserDataOperationEnum operation, 
                                string statName, 
                                uint datagroup,
                                long value, 
                                Guid? blobId)
        {
            long resultingValue = 0;
            UserDataError udError;

            try
            {
                IUserDataStorage userDataStorage = Container.Instance.GetComponent<IUserDataStorage>();
                udError = userDataStorage.OperateOnUserStatValueLong(
                                                           operation,
                                                           gameEvent.UserId,
                                                           gameEvent.PlatformId,
                                                           gameEvent.GameId,
                                                           gameEvent.GetPropertyValueAsUInt(TestActionEngine.VariantPropertyName),
                                                           statName,
                                                           datagroup,
                                                           value,
                                                           gameEvent.GameEventId,
                                                           gameEvent.GameSessionId,
                                                           blobId,
                                                           DateTime.UtcNow,
                                                           ref resultingValue);
                if (udError.ErrorCode != 0)
                {
                   Logging.TraceVerbose("Error message: {0}", udError.ErrorMessage);
                }
            }
            catch (SqlException ex)
            {
                Logging.WriteEvent(new SqlExceptionError(), ex, "Operation:{0}, Statistic:{1}, Value:{2}, BlobId:{3}", operation.ToString(), statName, value, (blobId ?? Guid.Empty).ToString());
                throw;
            }

            return udError;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\ActionEngine.Test\Program.cs ===
﻿using System.Collections.Generic;
using System;
using BusinessObject.Test;
using Gds.ActionEngine;
using Wgx.Services.Gds.BusinessObjects;
using Wgx.Services.Gds.BusinessObjects.ActionEngine;

namespace ActionEngine.Test
{
    class Program
    {
        /// <summary>
        /// SumProperty - update the HighScore for user by a certain amount.
        /// CreateAndSubmitEvent - add a property for the new HighScore.
        /// </summary>
        /// <returns>A default Action set that does the description</returns>
        static RuleActionSet CreateLevel1ActionSet()
        {
            RuleActionSet ras = new RuleActionSet();
            ras.RuleActions = new List<RuleAction>(2);
            SumPropertyAction spa = (SumPropertyAction)TestActionSet.ConstructSumPropertyAction();

            // modify the Sum2 parameter to have a path section instead of Value.
            spa.ActionParameters[1].Path = "/Store/User[ID=1]/Game[ID=116]/HighScore";
            spa.ActionParameters[1].Value = null;
            spa.ActionParameters[2].Path = null;
            spa.ActionParameters[2].Value = "100";
            ras.RuleActions.Add(spa);
            ras.RuleActions.Add(TestActionSet.ConstructCreateAndSubmitEventAction());
            return ras;
        }

        /// <summary>
        /// CreateBadge - award a sample badge to user.
        /// </summary>
        /// <returns>A default Action set that does the description</returns>
        static RuleActionSet CreateLevel2ActionSet()
        {
            RuleActionSet ras = new RuleActionSet();
            ras.RuleActions = new List<RuleAction>(1);

            ras.RuleActions.Add(TestActionSet.ConstructCreateBadgeAction());
            return ras;
        }

        static GameEvent CreateGameEvent()
        {
            GameEvent ge = TestGameEvent.ConstructGameEvent();

            ge.EventCategory = "Score";
            ge.GameKey = 116;
            ge.LivePuid = 1;
            ge.Platform = "MSN";
            ge.PropertySchemaName = "MSN.StandardScore";
            ge.TimeStamp = DateTime.Now;
            ge.Properties[0].Name = "Score";
            ge.Properties[0].PropertyType = "System.Int32";
            ge.Properties[0].Value = "100";
            return ge;
        }

        static void Main(string[] args)
        {
            using (IActionEngine actionEngine = ActionEngineFactory.Create())
            {
                string actionXml = SerializerDeserializer.SerializeToString(Program.CreateLevel1ActionSet());
                string gameEventXml = SerializerDeserializer.SerializeToString(Program.CreateGameEvent());

                // TODO: Add mock object here:
                actionEngine.Initialize(null);
                actionEngine.Execute(actionXml, gameEventXml);

                actionXml = SerializerDeserializer.SerializeToString(Program.CreateLevel2ActionSet());
                actionEngine.Execute(actionXml, null);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\BusinessObject.Test\TestGameEvent.cs ===
﻿namespace BusinessObject.Test
{
    using System;
    using System.IO;
    using Gds.Contracts;
    using Gds.Contracts.ActionEngine;
    using System.Collections.Generic;

    public class TestGameEvent
    {
        private const string ValidGameEventXmlFile1 = @"..\..\Xml\ValidGameEvent1.xml";
        private const string ValidGameEventXmlFile2 = @"..\..\Xml\ValidGameEvent2.xml";
        private const string InvalidGameEventXmlFile1 = @"..\..\Xml\InvalidGameEvent1.xml";
        private const string InvalidGameEventXmlFile2 = @"..\..\Xml\InvalidGameEvent2.xml";

        internal static void Run()
        {
            TestGameEvent.Serialization();
            TestGameEvent.Deserialization();
        }

        private static void Serialization()
        {
            GameEvent ge = TestGameEvent.ConstructGameEvent();
            string str = SerializerDeserializer.SerializeToString(ge);
            Console.WriteLine(str);
        }

        private static void Deserialization()
        {
            GameEvent ge = null;

            ge = (GameEvent)Program.TestDeserializeFromString(TestGameEvent.ValidGameEventXmlFile1, typeof(GameEvent));
            if (ge == null) throw new InvalidOperationException("Test Has Failed!");

            ge = (GameEvent)Program.TestDeserializeFromString(TestGameEvent.ValidGameEventXmlFile2, typeof(GameEvent));
            if (ge == null) throw new InvalidOperationException("Test Has Failed!");

            ge = (GameEvent)Program.TestDeserializeFromString(TestGameEvent.InvalidGameEventXmlFile1, typeof(GameEvent));
            if (ge != null) throw new InvalidOperationException("Test Has Failed!");

            ge = (GameEvent)Program.TestDeserializeFromString(string.Empty, typeof(GameEvent));
            if (ge != null) throw new InvalidOperationException("Test Has Failed!");

            ge = (GameEvent)Program.TestDeserializeFromString(TestGameEvent.InvalidGameEventXmlFile2, typeof(GameEvent));
            if (ge != null) throw new InvalidOperationException("Test Has Failed!");

            // in this test we are expecting an ArgumentException; as the type passed in is invalid.
            try
            {
                Program.TestDeserializeFromString(TestGameEvent.ValidGameEventXmlFile1, typeof(Program));
                throw new InvalidOperationException("Test Has Failed!");
            }
            catch (ArgumentException) { } // absorb error.
        }

        public static GameEvent ConstructGameEvent()
        {
            GameEvent ge = new GameEvent();
            ge.EventCategory = "Horror";
            ge.Culture = "fr-FR";

            ge.PropertySchemaName = "MySchemaName";
            ge.GameEventId = Guid.NewGuid();
            ge.GameSessionId = Guid.NewGuid();
            ge.UserId= 0x00842652;
            ge.GameId = 778979;
            ge.TimeStamp = DateTime.Now;
            ge.PlatformId = 1;
            ge.EventCategory = "Score";

            Property prop = new Property();
            prop.Name = "Int prop";
            prop.Value = "123";
            prop.PropertyType = "Integer";

            ge.Properties = new System.Collections.Generic.List<Property>();
            ge.Properties.Add(prop);

            return ge;
        }

        public static GameEvent ConstructScoreEvent(ulong userid, int score)
        {
            GameEvent ge = TestGameEvent.ConstructGameEvent();
            ge.UserId = userid;

            ge.Culture = "en-us";
            ge.GameId = 116;
            ge.Properties[0].Name = "Score";
            ge.Properties[0].Value = score.ToString();
            ge.Properties[0].PropertyType = "System.Int32";
            return ge;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\BusinessObject.Test\TestActionSet.cs ===
﻿namespace BusinessObject.Test
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts;
    using Gds.Contracts.ActionEngine;

    public class TestActionSet
    {
        private const string InvalidActionSetXmlFile1 = @"..\..\Xml\InvalidActionSet1.xml";
        private const string InvalidCreateAndSubmitEventActionSetXmlFile1 = @"..\..\Xml\InvalidCreateAndSubmitEventActionSet1.xml";
        private const string InvalidCreateBadgeActionSetXmlFile1 = @"..\..\Xml\InvalidCreateBadgeActionSet1.xml";
        private const string InvalidCreateRangeBadgeActionSetXmlFile1 = @"..\..\Xml\InvalidCreateRangeBadgeActionSet1.xml";
        private const string InvalidMaxActionSetXmlFile1 = @"..\..\Xml\InvalidMaxActionSet1.xml";
        private const string InvalidSumActionSetXmlFile1 = @"..\..\Xml\InvalidSumActionSet1.xml";

        private const string ValidActionSetXmlFile1 = @"..\..\Xml\ValidActionSet1.xml";
        private const string ValidCreateAndSubmitEventActionSetXmlFile1 = @"..\..\Xml\ValidCreateAndSubmitEventActionSet1.xml";
        private const string ValidCreateBadgeActionSetXmlFile1 = @"..\..\Xml\ValidCreateBadgeActionSet1.xml";
        private const string ValidCreateRangeBadgeActionSetXmlFile1 = @"..\..\Xml\ValidCreateRangeBadgeActionSet1.xml";
        private const string ValidMaxActionSetXmlFile1 = @"..\..\Xml\ValidMaxActionSet1.xml";
        private const string ValidSumActionSetXmlFile1 = @"..\..\Xml\ValidSumActionSet1.xml";

        internal static void Run()
        {
            TestActionSet.Serialization();
            TestActionSet.Deserialization();
        }

        private static void Serialization()
        {
            RuleActionSet ras = TestActionSet.ConstructActionSet();
            string str = SerializerDeserializer.SerializeToString(ras);
            Console.WriteLine(str);
            Console.WriteLine();

            ras = new RuleActionSet();

            // construct a SumProperty action.
            ras.RuleActions = new List<RuleAction>(1);
            ras.RuleActions.Add(TestActionSet.ConstructSumPropertyAction());
            str = SerializerDeserializer.SerializeToString(ras);
            Console.WriteLine(str);
            Console.WriteLine();

            // construct a MaxProperty action.
            ras.RuleActions = new List<RuleAction>(1);
            ras.RuleActions.Add(TestActionSet.ConstructMaxPropertyAction());
            str = SerializerDeserializer.SerializeToString(ras);
            Console.WriteLine(str);
            Console.WriteLine();

            // construct a MaxProperty action.
            ras.RuleActions = new List<RuleAction>(1);
            ras.RuleActions.Add(TestActionSet.ConstructCreateBadgeAction());
            str = SerializerDeserializer.SerializeToString(ras);
            Console.WriteLine(str);
            Console.WriteLine();

            // construct a MaxProperty action.
            ras.RuleActions = new List<RuleAction>(1);
            ras.RuleActions.Add(TestActionSet.ConstructCreateAndSubmitEventAction());
            str = SerializerDeserializer.SerializeToString(ras);
            Console.WriteLine(str);
            Console.WriteLine();
        }

        private static void Deserialization()
        {
            TestActionSet.BasicValidDeserialization();
            TestActionSet.BasicInvalidDeserialization();
        }

        private static void BasicInvalidDeserialization()
        {
            RuleActionSet ras = null;

            // this will fail, even though that per schema it is valid. 
            // we have strengthened the schema with in-code validation.
            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidActionSetXmlFile1, typeof(RuleActionSet));
            if (ras != null) throw new InvalidOperationException("Test Has Failed!");

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.InvalidActionSetXmlFile1, typeof(RuleActionSet));
            if (ras != null) throw new InvalidOperationException("Test Has Failed!");

            // in this test we are expecting an ArgumentException; as the type passed in is invalid.
            try
            {
                Program.TestDeserializeFromString(TestActionSet.ValidActionSetXmlFile1, typeof(Program));
                throw new InvalidOperationException("Test Has Failed!");
            }
            catch (ArgumentException) { } // absorb error.
        }

        private static void BasicValidDeserialization()
        {
            RuleActionSet ras = null;

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidCreateAndSubmitEventActionSetXmlFile1, typeof(RuleActionSet));
            if (ras == null) throw new InvalidOperationException("Test Has Failed!");

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidCreateBadgeActionSetXmlFile1, typeof(RuleActionSet));
            if (ras == null) throw new InvalidOperationException("Test Has Failed!");

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidCreateRangeBadgeActionSetXmlFile1, typeof(RuleActionSet));
            if (ras == null) throw new InvalidOperationException("Test Has Failed!");

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidMaxActionSetXmlFile1, typeof(RuleActionSet));
            if (ras == null) throw new InvalidOperationException("Test Has Failed!");

            ras = (RuleActionSet)Program.TestDeserializeFromString(TestActionSet.ValidSumActionSetXmlFile1, typeof(RuleActionSet));
            if (ras == null) throw new InvalidOperationException("Test Has Failed!");
        }

        private static RuleActionSet ConstructActionSet()
        {
            RuleActionSet ras = new RuleActionSet();
            ras.RuleActions = new List<RuleAction>(1);

            RuleAction action = new RuleAction();
            action.ActionParameters = new List<RuleActionParameter>(1);

            RuleActionParameter acParam = new RuleActionParameter();
            acParam.Name = "some name";
            acParam.Type = "Integer";
            acParam.Value = "5";

            action.ActionParameters.Add(acParam);
            action.Name = "someaction";
            ras.RuleActions.Add(action);

            return ras;
        }

        public static RuleAction ConstructSumPropertyAction()
        {
            string typeString = typeof(int).ToString();
            RuleAction action = new SumPropertyAction(
                                        1, 
                                        typeString, 
                                        "/Event/Properties[Score]", 
                                        typeString, 
                                        6,
                                        typeString, 
                                        "/Store/User[ID=1]/Game[ID=116]/HighScore");
            return action;
        }

        public static RuleAction ConstructMaxPropertyAction()
        {
            string typeString = typeof(int).ToString();
            RuleAction action = new MaxPropertyAction(
                                        1,
                                        typeString,
                                        "/Event/Properties[Score]",
                                        typeString,
                                        6,
                                        typeString,
                                        "/Store/User[ID=6]/Game[ID=116]/MaxScore");
            return action;
        }

        public static RuleAction ConstructCreateBadgeAction()
        {
            RuleAction action = new CreateBadgeAction(1, 1);
            return action;
        }

        public static RuleAction ConstructCreateAndSubmitEventAction()
        {
            RuleAction action = new CreateAndSubmitEventAction(1, "HighScore", typeof (long).ToString(), "/Store/User[ID=1]/Game[ID=116]/HighScore");
            return action;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\BusinessObject.Test\Properties\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AssemblyInfo.cs" company="Microsoft" author="Atin Jain">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>SerializerDeserializer Sample project</summary>
//-------------------------------------------------------------------------------------------------
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SerializerDeserializerSample")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]


// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("99fb4344-fa73-4c69-89f3-d4c6c5dac82c")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\BusinessObject.Test\TestGameResult.cs ===
﻿namespace BusinessObject.Test
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts;

    public class TestGameResult
    {
        private const string ValidGameResultXmlFile = @"..\..\Xml\GameResult\ValidGameResult.xml";

        internal static void Run()
        {
            //TestGameResultSerialization();
            //TestGrantAchievementSerialization();
            //TestGameResultDeserialization();
            TestLeaderboardSerialization();
        }

        private static void TestGameResultSerialization()
        {
            try
            {
                GameResult gr = new GameResult()
                {
                    GameId = 1,
                    Variant = 0,
                    GameResultId = Guid.NewGuid(),
                    Outcome = "Win",
                    Score = 5,
                    Time = 1000,
                    TimeStamp = DateTime.Now,
                };

                string str = SerializerDeserializer.SerializeToString(gr);
                Console.WriteLine(str);
                Console.WriteLine();

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        private static void TestGameResultDeserialization()
        {
            try
            {
                GameResult gr = null;

                gr = (GameResult)Program.TestDeserializeFromString(TestGameResult.ValidGameResultXmlFile, typeof(GameResult));
                if (gr == null) throw new InvalidOperationException("Test Has Failed!");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }
        
        private static void TestGrantAchievementSerialization()
        {
            try
            {
                AchievementEarned ae = new AchievementEarned()
                {
                    Key = "blah",
                    EarnedOnline = true,
                    EarnedDateTime = DateTime.Now
                };

                GrantAchievements ga = new GrantAchievements()
                {
                    AppId = Guid.NewGuid().ToString(),
                    GameId = 55,
                    Achievements = new List<AchievementEarned>()
                };

                ga.Achievements.Add(ae);

                string str = SerializerDeserializer.SerializeToString(ga);
                Console.WriteLine(str);
                Console.WriteLine();

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        private static void TestLeaderboardSerialization()
        {
            try
            {
                Entry statEntry = new Entry()
                {
                    Name = "score",
                    Value = "1"
                };

                LeaderboardUser user = new LeaderboardUser()
                {
                    Cid = 5,
                    DisplayName = "blah",
                    GamerTag = "blahgt",
                    PictureUrl = "http://buzzoff"
                };

                LeaderboardItem li = new LeaderboardItem()
                {
                    Rank = 1,
                    Statistics = new List<Entry>(),
                    User = user,
                    Value = 5
                };

                li.Statistics.Add(statEntry);


                LeaderboardResult myObj = new LeaderboardResult()
                {
                    TotalNumberOfRows = 1,
                    Leaderboard = new List<LeaderboardItem>()
                };

                myObj.Leaderboard.Add(li);

                string str = SerializerDeserializer.SerializeToString(myObj);
                Console.WriteLine(str);
                Console.WriteLine();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.ActionEngine.Test\ActionEngineTestUtilities.cs ===
﻿namespace Gds.ActionEngine.Test
{
    using System;
    using GameMetadata.Client;
    using Gds.ActionEngine;
    using Gds.DataAccess.Rewards;
    using Gds.Mocks;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;

    public static class ActionEngineTestUtilities
    {
        public static void PerformBasicActionEngineCall(string actionXmlFile, string gameEventXmlFile)
        {
            string actionXml = GdsTestUtilities.FetchFileContent(actionXmlFile);
            string gameEventXml = GdsTestUtilities.FetchFileContent(gameEventXmlFile);

            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
            actionEngine.Execute(actionXml, gameEventXml);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.ActionEngine.Test\TestActionEngineTest.cs ===
﻿namespace Gds.ActionEngine.Test
{
    using System;
    using GameMetadata.Client;
    using Gds.ActionEngine;
    using Gds.DataAccess.Rewards;
    using Gds.Mocks;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
     
    /// <summary>
    ///This is a test class for TestActionEngineTest and is intended
    ///to contain all TestActionEngineTest Unit Tests
    ///</summary>
    [TestClass()]
    public class ActionEngineTest
    {
        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }

            set
            {
                testContextInstance = value;
            }
        }

         
        //You can use the following additional attributes as you write your tests:
        //Use ClassInitialize to run code before running the first test in the class
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            Console.WriteLine("MyClassInitialize");
            Container.Instance.AddService<IUserDataStorage, MockUserDataStorage>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            Container.Instance.AddService<IRewardsQueueReader, InMemoryRewardsQueueReader>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<IActionEngine, TestActionEngine>();
        }
        
        //Use ClassCleanup to run code after all tests in a class have run
        [ClassCleanup()]
        public static void MyClassCleanup()
        {
            Console.WriteLine("MyClassCleanup");
        }
        
        // Use TestInitialize to run code before running each test
        [TestInitialize()]
        public void MyTestInitialize()
        {
            Console.WriteLine("MyTestInitialize");
        }
        
        //Use TestCleanup to run code after each test has run
        [TestCleanup()]
        public void MyTestCleanup()
        {
            Console.WriteLine("MyTestCleanup");
        }

        [TestMethod()]
        public void FirstTest()
        {
        }

        [TestMethod()]
        public void InitializeActionEngine()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
        }

        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ActionEngineExecuteNullAction()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
            actionEngine.Execute(null, string.Empty);
        }

        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ActionEngineExecuteNullActionAndEvent()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
            actionEngine.Execute(string.Empty, null);
        }

        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ActionEngineExecuteInvalidActionAndNullEvent()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
            actionEngine.Execute(ActionEngineTestSettings.InvalidActionXmlShortString, null);
        }

        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ActionEngineExecuteInvalidLongActionAndNullEvent()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
                actionEngine.Execute(ActionEngineTestSettings.InvalidActionXmlLongString, null);
        }


        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ActionEngineExecuteNullActionAndInvalidEvent()
        {
            IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
            actionEngine.Execute(null, ActionEngineTestSettings.InvalidGameResultXmlString);
        }

        [TestMethod()]
        public void ValidMaxBestHighScoreCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.MaxBestHighScoreXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidMinBestLowScoreCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.MinBestLowScoreXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidMaxBestHighTimeCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.MaxBestHighTimeXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile); 
        }

        [TestMethod()]
        public void ValidMinBestLowTimeCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.MinBestLowTimeXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidSumCumulativeScoreCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.SumCumulativeScoreXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }


        [TestMethod()]
        public void ValidSumCumulativeTimeCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.SumCumulativeTimeXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidSumGamesPlayedCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.SumGamesPlayedXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidSumWinsCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.SumWinsXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }

        [TestMethod()]
        public void ValidSyncTitlesCall()
        {
            ActionEngineTestUtilities.PerformBasicActionEngineCall(ActionEngineTestSettings.SyncTitlesXmlFile, ActionEngineTestSettings.ValidGameEventWithScoreTimeOutcomeBlobXmlFile);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.ActionEngine.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.ActionEngine.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("Gds.ActionEngine.Test")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ec0909d7-be39-4a57-8697-6c63958c3c1a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.ActionEngine.Test\ActionEngineTestSettings.cs ===
﻿namespace Gds.ActionEngine.Test
{
    internal class ActionEngineTestSettings
    {
        public const string InvalidActionXmlShortString = "blah";
        public const string InvalidActionXmlLongString = "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah";
        public const string InvalidGameResultXmlString = "blah";

        public const string MaxBestHighScoreXmlFile = @"MaxBestHighScore.xml";
        public const string MaxBestHighTimeXmlFile = @"MaxBestHighTime.xml";
        public const string MinBestLowScoreXmlFile = @"MinBestLowScore.xml";
        public const string MinBestLowTimeXmlFile = @"MinBestLowTime.xml";
        public const string SumCumulativeScoreXmlFile = @"SumCumulativeScore.xml";
        public const string SumCumulativeTimeXmlFile = @"SumCumulativeTime.xml";
        public const string SumGamesPlayedXmlFile = @"SumGamesPlayed.xml";
        public const string SumWinsXmlFile = @"SumWins.xml";
        public const string SyncTitlesXmlFile = @"SyncTitles.xml";

        public const string ValidGameEventWithScoreTimeOutcomeBlobXmlFile = @"ValidGameEventWithScoreTimeOutcomeBlob.xml";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\AccountInformation.cs ===
﻿
namespace Gds.Contracts
{
    using System.Runtime.Serialization;

    [DataContract(Name = "AccountInformation", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class AccountInformation
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "MsftPointsBalance", Order = 0)]
        public ulong MsftPointsBalance { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\AvatarAwardsAsset.cs ===
﻿
namespace Leet.UserGameData.DataContracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "AvatarAwardsAsset", Namespace = "")]
    public class AvatarAwardsAsset
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameId", Order = 0)]
        public uint GameId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Key", Order = 1)]
        public string Key { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Description", Order = 2)]
        public string Description { get; set; }

        [DataMember(EmitDefaultValue = false, IsRequired = false, Name = "EarnedDateTime", Order = 3)]
        public DateTime EarnedDateTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "EarnedOnline", Order = 4)]
        public bool EarnedOnline { get; set; }
       
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "HowToEarn", Order = 5)]
        public string HowToEarn { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "IsEarned", Order = 6)]
        public bool IsEarned { get; set; }
        
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Name", Order = 7)]
        public string Name { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\AchievementsResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.Serialization;
using Leet.UserGameData.DataContracts;

namespace Gds.Contracts
{
    /// <summary>
    /// Result of GET Achievements
    /// </summary>
    [DataContract(Name = "AchievementsResult", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class AchievementsResult
    {

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Achievements", Order = 1)]
        public List<Achievement> Achievements;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\AchievementsRequest.cs ===
﻿
namespace Gds.Contracts
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "AchievementsRequest", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class AchievementsRequest
    {
        /// <summary>
        /// Gets or sets GameId
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "GameId")]
        public string GameId { get; set; }

        /// <summary>
        /// Gets or sets list of Gamertags
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "Gamertags")]
        public List<Gamertag> GamerTags { get; set; }
    }

    [DataContract(Name = "Gamertag", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class Gamertag
    {
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "Name")]
        public string Name { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\AvatarAwardsAssetResult.cs ===
﻿
namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using Leet.UserGameData.DataContracts;

    /// <summary>
    /// Result of GET Avatar Awards Assets
    /// </summary>
    [DataContract(Name = "AvatarAwardsAssetResult", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class AvatarAwardsAssetResult 
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameId", Order = 0)]
        public uint GameId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "AvatarAwardsAssets", Order = 1)]
        public List<AvatarAwardsAsset> AvatarAwardsAssets;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Friend.cs ===
﻿
namespace Gds.Contracts
{
    using System.Runtime.Serialization;
    using System.Xml.Serialization;

    /// <summary>
    /// Data class representing the friend of a user
    /// </summary>
    [DataContract(Name = "Friend", Namespace = "")]
    [XmlRoot(Namespace = "")]
    public class Friend
    {
        /// <summary>
        /// Profile of the friend
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "ProfileEx", Order = 0)]
        public ProfileEx ProfileEx { get; set; }

        /// <summary>
        /// State of the friend in relation to the caller
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "FriendStatus", Order = 1)]
        public uint FriendState { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Achievements.cs ===
﻿
namespace Gds.Contracts
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using Leet.UserGameData.DataContracts;
    
    /// <summary>
    /// Achievements class
    /// </summary>
    [DataContract(Name = "Achievements", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class Achievements
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "UserAchievementsCollection", Order = 0)]
        public List<UserAchievements> UserAchievementsCollection;
    }

    [DataContract(Name = "UserAchievements", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class UserAchievements
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GamerTag", Order = 0)]
        public string Gamertag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalAchievementsEarned", Order = 1)]
        public ulong TotalAchievementsEarned { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalPossibleAchievements", Order = 2)]
        public ulong TotalPossibleAchievements { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Gamerscore", Order = 3)]
        public ulong Gamerscore { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalPossibleGamerscore", Order = 4)]
        public ulong TotalPossibleGamerscore { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "AchievementList", Order = 5)]
        public List<Achievement> AchievementList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\GameInfo.cs ===
﻿
namespace Gds.Contracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "GameInfo", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class GameInfo
    {
        /// <summary>
        /// Game Id
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Id", Order = 0)]
        public uint Id { get; set; }

        /// <summary>
        /// Name of the game
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Name", Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Indicates the platform of the game (LIVEn or Xbox LIVE)
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Type", Order = 2)]
        public uint Type { get; set; }

        /// <summary>
        /// URL for the game page
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameUrl", Order = 3)]
        public string GameUrl { get; set; }

        /// <summary>
        /// URL for the game image
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "ImageUrl", Order = 4)]
        public string ImageUrl { get; set; }

        /// <summary>
        /// When this game was last played by the user
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "LastPlayed", Order = 5)]
        public DateTime LastPlayed { get; set; }

        /// <summary>
        /// Indicates number of achievements earned for this game 
        /// by the user. 
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "AchievementsEarned", Order = 6)]
        public int AchievementsEarned { get; set; }

        /// <summary>
        /// Indicates total number of achievements available for 
        /// this game 
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalAchievements", Order = 7)]
        public int TotalAchievements { get; set; }

        /// <summary>
        /// 
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Gamerscore", Order = 8)]
        public uint Gamerscore { get; set; }

        /// <summary>
        /// 
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalPossibleGamerscore", Order = 9)]
        public uint TotalPossibleGamerscore { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\GameDataResult.cs ===
﻿using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Gds.Contracts
{
    /// <summary>
    /// Result of GET Leaderboard
    /// </summary>
    [DataContract(Name = "LeaderboardResult", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class LeaderboardResult
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalNumberOfRows", Order = 0)]
        public uint TotalNumberOfRows { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Leaderboard", Order = 1)]
        public IList<LeaderboardItem> Leaderboard;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\GameStatisticsResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Gds.Contracts
{
    /// <summary>
    /// Result for GET Datablob
    /// </summary>
    [DataContract]
    public class DatablobResult
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "DatablobId", Order = 0)]
        public Guid DatablobId;

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "Blob", Order = 1)]
        public byte[] Blob;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IFriend.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="IFriend.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  IFriend interface
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace Gds.Contracts
{
    using System.ServiceModel;
    using System.ServiceModel.Web;

    [ServiceContract]
    public interface IFriend
    {
        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "add?gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void AddFriend(string gamertag);

        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "accept?gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void AcceptFriend(string gamertag);

        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "decline?gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void DeclineFriendRequest(string gamertag);

        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "remove?gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void RemoveFriend(string gamertag);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\GrantAchievements.cs ===
﻿
namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using Leet.UserGameData.DataContracts;

    [DataContract(Name = "GrantAchievements", Namespace="http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class GrantAchievements
    {
        /// <summary>
        /// Gets or sets GameId
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "GameId")]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets AppId
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "AppId")]
        public string AppId { get; set; }

        /// <summary>
        /// Gets or sets list of Acheivement
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 2, Name = "Achievements")]
        public List<AchievementEarned> Achievements { get; set; }
    }

    [DataContract(Name = "AchievementEarned", Namespace = "")]
    public class AchievementEarned
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Key", Order = 0)]
        public string Key { get; set; }

        [DataMember(EmitDefaultValue = false, IsRequired = true, Name = "EarnedDateTime", Order = 1)]
        public DateTime EarnedDateTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "EarnedOnline", Order = 2)]
        public bool EarnedOnline { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\GrantAvatarAssets.cs ===
﻿
namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "GrantAvatarAssets", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class GrantAvatarAssets
    {
        /// <summary>
        /// Gets or sets GameId
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "GameId")]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets AppId
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "AppId")]
        public string AppId { get; set; }

        /// <summary>
        /// Gets or sets list of avatar assets
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 2, Name = "AvatarAssets")]
        public List<AvatarAssetEarned> AvatarAssets { get; set; }
    }

    [DataContract(Name = "AvatarAssetEarned", Namespace = "")]
    public class AvatarAssetEarned
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Key", Order = 0)]
        public string Key { get; set; }

        [DataMember(EmitDefaultValue = false, IsRequired = true, Name = "EarnedDateTime", Order = 1)]
        public DateTime EarnedDateTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "EarnedOnline", Order = 2)]
        public bool EarnedOnline { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "IsUnisexItem", Order = 3)]
        public bool IsUnisexItem { get; set; }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IFriendService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="FriendManager.cs" company="Microsoft" author="shaken">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>FriendService interface</summary>
//-------------------------------------------------------------------------------------------------

namespace Gds.Contracts
{
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// IFriendService interface
    /// </summary>
    [ServiceContract]
    public interface IFriendService
    {
        /// <summary>
        /// Attempts to add the newFriendXuid to the usersXuid friends baised on the usersXuid privileges
        /// </summary>
        /// <param name="userXuid">callers Xuid</param>
        /// <param name="newFriendXuid">targets Xuid</param>
        /// <returns>True if the AddFriend call is made to livecache</returns>
        [OperationContract]
        [WebGet(UriTemplate = "addfriend?format=xml&userxuid={userXuid}&newfriendxuid={newFriendxuid}", ResponseFormat = WebMessageFormat.Xml)]
        [WebHelp(Comment = "Returns true if the addFriend call is made.  Can throw ParentalControlPermissionDenied exception if Add Friend Privilege is not present")]
        bool AddFriendAsXml(ulong userXuid, ulong newFriendXuid);

        /// <summary>
        /// Attempts to add the newFriendXuid to the usersXuid friends baised on the usersXuid privileges
        /// </summary>
        /// <param name="userXuid">callers Xuid</param>
        /// <param name="newFriendXuid">targets Xuid</param>
        /// <returns>True if the AddFriend call is made to livecache</returns>
        [OperationContract]
        [WebGet(UriTemplate = "addfriend?format=json&userxuid={userXuid}&newfriendxuid={newFriendxuid}", ResponseFormat = WebMessageFormat.Json)]
        [WebHelp(Comment = "Returns true if the addFriend call is made.  Can throw ParentalControlPermissionDenied exception if Add Friend Privilege is not present")]
        bool AddFriendAsJson(ulong userXuid, ulong newFriendXuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Games.cs ===
﻿

namespace Gds.Contracts
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Games class
    /// </summary>
    [DataContract(Name = "Games", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class Games
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalUniqueGames", Order = 0)]
        public uint TotalUniqueGames;

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "UserGamesCollection", Order = 1)]
        public List<UserGames> UserGamesCollection;

    }

    [DataContract(Name = "UserGames", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class UserGames
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GamerTag", Order = 0)]
        public string Gamertag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalGamesPlayed", Order = 1)]
        public uint TotalGamesPlayed { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Gamerscore", Order = 2)]
        public uint Gamerscore { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "TotalPossibleGamerscore", Order = 3)]
        public uint TotalPossibleGamerscore { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameList", Order = 4)]
        public List<GameInfo> GameList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IPresence.cs ===
﻿
namespace Gds.Contracts
{
    using System.ServiceModel;
    using System.ServiceModel.Web;

    [ServiceContract]
    public interface IPresence
    {
        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "update",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void UpdatePresence();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IMessage.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="IMessage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  IMessageService interface
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System.Collections.Generic;
    using System.ServiceModel;
    using System.ServiceModel.Web;

    [ServiceContract]
    public interface IMessageService
    {
        [OperationContract]
        [WebGet(UriTemplate = "summarylist?hashCode={hashCode}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        MessageSummariesResponse GetMessageSummaries(string hashCode); 

        [OperationContract]
        [WebGet(UriTemplate = "messagedetails?messageId={messageId}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        MessageDetails GetMessageDetails(uint messageId);

        [OperationContract]
        [WebInvoke(Method = "POST", UriTemplate = "send",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        ResponseWithErrorCode SendMessage(SendMessageRequest request);

        [OperationContract]
        [WebInvoke(Method = "DELETE", UriTemplate = "delete?messageId={messageId}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        ResponseWithErrorCode DeleteMessage(uint messageId);

        [OperationContract]
        [WebInvoke(Method = "DELETE", UriTemplate = "block?messageId={messageId}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        ResponseWithErrorCode DeleteMessageAndBlockGamertag(uint messageId);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IGameDataPartner.cs ===
﻿
namespace Gds.Contracts
{
    using System.ServiceModel;
    using System.ServiceModel.Web;

    [ServiceContract]
    public interface IGameDataPartner
    {
        [OperationContract]
        [WebGet(UriTemplate = "games?gamertags={gamertags}&pageStart={pageStart}&pageCount={pageCount}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        Games GetGames(string gamertags, string pageStart, string pageCount);

        [OperationContract]
        [WebGet(UriTemplate = "achievements?gameId={gameId}&gamertags={gamertags}", RequestFormat = WebMessageFormat.Xml)]
        Achievements GetAchievements(string gameId, string gamertags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IProfiles.cs ===
﻿using System.ServiceModel;
using System.ServiceModel.Web;
using Leet.UserGameData.DataContracts;
using Microsoft.ServiceModel.Web;

namespace Gds.Contracts
{
    /// <summary>
    /// Service contract for Profiles
    /// </summary>
    [ServiceContract]
    public interface IProfiles
    {
        [OperationContract]
        [XmlSerializerFormat]
        [WebGet(UriTemplate = "profile?format=xml&sectionflags={sectionFlags}&gamertag={gamertag}", ResponseFormat = WebMessageFormat.Xml)]
        [WebHelp(Comment = "Returns the specified sections for the Profile in XML format.  All fields that have valid permissions will be returned.")]
        Leet.UserGameData.DataContracts.Profile GetProfileAsXml(long sectionFlags, string gamertag);

        [OperationContract]
        [WebGet(UriTemplate = "profile?format=json&sectionflags={sectionFlags}&gamertag={gamertag}", ResponseFormat = WebMessageFormat.Json)]
        [WebHelp(Comment = "Returns the specifiled sections for the Profile in JSON format.  All fields that have valid permissions will be returned.")]
        Leet.UserGameData.DataContracts.Profile GetProfileAsJson(long sectionFlags, string gamertag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IProfile.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="IProfile.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  IProfile interface
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace Gds.Contracts
{
    using System.ServiceModel;
    using System.ServiceModel.Web;

    [ServiceContract]
    public interface IProfile
    {
        [OperationContract]
        [XmlSerializerFormat]
        [WebGet(UriTemplate = "profile?sectionFlags={sectionFlags}&friendsSectionFlags={friendsSectionFlags}&gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        ProfileEx GetProfile(string sectionFlags, string friendsSectionFlags, string gamertag);

        [OperationContract]
        [XmlSerializerFormat]
        [WebInvoke(Method = "POST", UriTemplate = "",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        void UpdateProfile(ProfileEx profile);

        [OperationContract]
        [XmlSerializerFormat]
        [WebInvoke(Method = "POST", UriTemplate = "gamertag/change?gamertag={gamertag}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        string[] ChangeGamertag(string gamertag);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ISecurityTokens.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Web;

namespace Gds.Contracts
{
    [ServiceContract]
    public interface ISecurityTokens
    {
       
        [OperationContract]
        [WebGet(UriTemplate = "usertoken?gameId={gameId}&gameVersion={gameVersion}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        TokenResult GetUserTokenXml(uint gameId, ushort gameVersion);

        [OperationContract]
        [WebGet(UriTemplate = "partnertoken?gameId={gameId}&gameVersion={gameVersion}&audienceUri={audienceUri}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        TokenResult GetPartnerTokenXml(uint gameId, ushort gameVersion, string audienceUri);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\IGameData.cs ===
﻿using System;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.Collections.Generic;
using Microsoft.ServiceModel.Web;

namespace Gds.Contracts
{
    /// <summary>
    /// Service contract for GameData
    /// </summary>
    [ServiceContract]
    public interface IGameData
    {
        [WebHelp(Comment = "Retrieve the leaderboard information of a particular game.")]
        [OperationContract]
        [WebGet(UriTemplate = "leaderboard?format=xml&gameId={gameId}&variant={variant}&property={property}&datagroup={datagroup}&numRows={numRows}&rankStart={rankStart}&socialGraph={socialGraph}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        LeaderboardResult GetLeaderboardXml(uint gameId, uint variant, string property, string dataGroup, uint numRows, uint rankStart, uint socialGraph);

        [WebHelp(Comment = "Retrieve the leaderboard information of a particular game.")]
        [OperationContract]
        [WebGet(UriTemplate = "leaderboard?format=json&gameId={gameId}&variant={variant}&property={property}&datagroup={datagroup}&numRows={numRows}&rankStart={rankStart}&socialGraph={socialGraph}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Json)]
        LeaderboardResult GetLeaderboardJson(uint gameId, uint variant, string property, string dataGroup, uint numRows, uint rankStart, uint socialGraph);

        [WebHelp(Comment = "Retrieve all achievements of a particular game.")]
        [OperationContract]
        [WebGet(UriTemplate = "achievements?format=xml&gameId={gameId}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Xml)]
        AchievementsResult GetAchievementsXml(uint gameId);

        [WebHelp(Comment = "Retrieve all achievements of a particular game.")]
        [OperationContract]
        [WebGet(UriTemplate = "achievements?format=json&gameId={gameId}",
            BodyStyle = WebMessageBodyStyle.Bare,
            ResponseFormat = WebMessageFormat.Json)]
        AchievementsResult GetAchievementsJson(uint gameId);

        [WebHelp(Comment = "Retrieve datablob.")]
        [OperationContract]
        [WebGet(UriTemplate = "datablob?format=xml&datablobId={datablobId}", ResponseFormat = WebMessageFormat.Xml)]
        DatablobResult GetDatablobXml(string datablobId);

        [WebHelp(Comment = "Retrieve datablob.")]
        [OperationContract]
        [WebGet(UriTemplate = "datablob?format=json&datablobId={datablobId}", ResponseFormat = WebMessageFormat.Json)]
        DatablobResult GetDatablobJson(string datablobId);

        [WebHelp(Comment = "Retrieve all avatar awards assets of a particular game.")]
        [OperationContract]
        [WebGet(UriTemplate = "avatarawardsassets?gameId={gameId}", BodyStyle = WebMessageBodyStyle.Bare, ResponseFormat = WebMessageFormat.Xml)]
        AvatarAwardsAssetResult GetAvatarAwardsAssets(uint gameId);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Leaderboard.cs ===
﻿namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Data contract for Item in Leaderboard
    /// </summary>
    [DataContract(Name = "Item", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class LeaderboardItem
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "User", Order = 0)]
        public LeaderboardUser User { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Rank", Order = 1)]
        public uint Rank { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Value", Order = 2)]
        public long Value { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Statistics", Order = 3)]
        public IList<Entry> Statistics { get; set; }
    }

    /// <summary>
    /// Data contract for User
    /// </summary>
    [DataContract(Name = "User", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class LeaderboardUser
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GamerTag", Order = 0)]
        public string GamerTag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "Cid", Order = 0)]
        public ulong Cid { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "DisplayName", Order = 1)]
        public string DisplayName { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "PictureUrl", Order = 2)]
        public string PictureUrl { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\PrivacySetting.cs ===
﻿
namespace Gds.Contracts
{
    public enum PrivacySetting
    {
        VoiceAndText,
        Video,
        GamerProfile,
        OnlineStatus,
        MemberContent,
        PlayedGames,
        FriendsList
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\MessageSummary.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="MessageSummary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  Message Header class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "MessageSummary", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class MessageSummary
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "MessageId", Order = 0)]
        public uint MessageId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "MessageType", Order = 1)]
        public uint MessageType { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "SenderGamertag", Order = 2)]
        public string SenderGamertag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "SenderGamerPicUrl", Order = 3)]
        public string SenderGamerPicUrl { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "SenderTitleId", Order = 4)]
        public uint SenderTitleId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "SentTime", Order = 5)]
        public DateTime SentTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "Subject", Order = 6)]
        public string Subject { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "HasBeenRead", Order = 7)]
        public bool HasBeenRead { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "IsFromFriend", Order = 8)]
        public bool IsFromFriend { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "CanDelete", Order = 9)]
        public bool CanDelete { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "CanSetReadFlag", Order = 10)]
        public bool CanSetReadFlag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "HasVoice", Order = 11)]
        public bool HasVoice { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "HasImage", Order = 12)]
        public bool HasImage { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "HasText", Order = 13)]
        public bool HasText { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\MessageDetails.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="MessageDetails.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Feng Gao
// </author>
//
// <summary>
//  Message Details class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/17/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "MessageDetails", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class MessageDetails
    {
        /// <summary>
        /// MessageId
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "MessageId", Order = 0)]
        public uint MessageId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "SentTime", Order = 1)]
        public DateTime SentTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "SenderGamerTag", Order = 2)]
        public string SenderGamerTag { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "MessageBody", Order = 3)]
        public string MessageBody { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Presence.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Presence.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  Presence class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
using System;

namespace Gds.Contracts
{
    using System.Runtime.Serialization;

    [DataContract(Name = "Presence", Namespace = "")]
    public class Presence
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "OnlineState", Order = 0)]
        public uint OnlineState;

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "LastSeenDateTime", Order = 1)]
        public DateTime LastSeenDateTime;

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "LastSeenTitleId", Order = 2)]
        public uint LastSeenTitleId;

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "LastSeenTitleName", Order = 3)]
        public string LastSeenTitleName;

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "DetailedPresence", Order = 4)]
        public string DetailedPresence;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ProfileEx.cs ===
﻿
namespace Gds.Contracts
{
    using System.Runtime.Serialization;
    using System.Xml.Serialization;
    using Leet.UserGameData.DataContracts;

    /// <summary>
    /// Data class representing the profile of a user
    /// </summary>
    [DataContract(Name = "ProfileEx", Namespace = "")]
    [XmlRoot(Namespace = "")]
    public class ProfileEx
    {
        /// <summary>
        /// A bit mask that represents a set of ProfileSections bit 
        /// flags - this indicates what sections are requested or 
        /// provided in the profile
        /// </summary>
        [DataMember]
        public long SectionFlags { get; set; }

        /// <summary>
        /// Property bag, contains Xbox Live and Windows Live properties 
        /// </summary>
        [DataMember]
        public XmlSerializableDictionary<ProfileProperty, object> ProfileProperties { get; set; }

        /// <summary>
        /// List of achievements recently unlocked by user
        /// </summary>
        [DataMember]
        public XmlSerializableList<Achievement> RecentAchievements { get; set; }

        /// <summary>
        /// The privacy level of the user's profile
        /// </summary>
        [DataMember]
        public XmlSerializableList<Leet.UserGameData.DataContracts.GameInfo> RecentGames { get; set; }

        /// <summary>
        /// A list of the user's friends
        /// </summary>
        [DataMember]
        public XmlSerializableList<ProfileEx> Friends { get; set; }
        /// <summary>
        /// Presence Info
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "PresenceInfo", Order = 5)]
        public Presence PresenceInfo { get; set; }

        /// <summary>
        /// Privacy Settings
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "PrivacySettings", Order = 6)]
        public XmlSerializableDictionary<PrivacySetting, uint> PrivacySettings { get; set; }

        /// <summary>
        /// FriendList
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired=false, Name="FriendList", Order = 7)]
        public XmlSerializableList<Friend> FriendList { get; set; }

        /// <summary>
        /// FriendList
        /// </summary>
        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "AccountInformation", Order = 8)]
        public AccountInformation AccountInformation { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\MessageSummariesResponse.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="MessageSummariesResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Feng Gao
// </author>
//
// <summary>
//  Message Summaries Response class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/16/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic; 
    using System.Runtime.Serialization;

    [DataContract(Name = "MessageSummariesResponse", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class MessageSummariesResponse
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Summaries", Order = 0)]
        public List<MessageSummary> Summaries { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "HashCode", Order = 1)]
        public string HashCode { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ResponseWithErrorCode.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="ResponseWithErrorCode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The generic response with error code. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/16/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "ResponseWithErrorCode", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class ResponseWithErrorCode
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "ErrorCode", Order = 0)]
        public uint ErrorCode { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "ErrorMessage", Order = 1)]
        public string ErrorMessage { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\SocialGraph.cs ===
﻿namespace Gds.Contracts
{
    public enum LeetSocialGraphs : uint
    {
        All = 1,
        XboxLiveFriends = 2,
        MsnFriends = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\TokenResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.Serialization;

namespace Gds.Contracts
{
    [DataContract(Name = "Tokens")]
    public class TokenResult
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "User", Order = 0)]
        public string User { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Partner", Order = 1)]
        public string Partner { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\StatisticSet.cs ===
﻿namespace Gds.Contracts
{
    using System;
    using System.Runtime.Serialization;
    using System.Collections.Generic;

    /// <summary>
    /// Data contract for a Stat
    /// </summary>
    [DataContract(Name = "Entry", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class Entry
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Name", Order = 0)]
        public string Name { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = false, Name = "Value", Order = 1)]
        public string Value { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\UserStatisticsDatagroupEnum.cs ===
﻿namespace Gds.Contracts
{
    /// <summary>
    /// The enum names are spec defined
    /// </summary>
    public enum UserStatisticsDatagroupEnum : uint
    {
        Lifetime = 1,
        W1 = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\SendMessageRequest.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="SendMessageRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  SendMessageRequest class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Contracts
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "SendMessageRequest", Namespace = "http://schemas.datacontract.org/2004/07/GDS.Contracts")]
    public class SendMessageRequest
    {
        /// <summary>
        /// Gets or sets list of Recipients
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "Recipients")]
        public List<string> Recipients { get; set; }

        /// <summary>
        /// Gets or sets MessageText
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "MessageText")]
        public string MessageText { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\BadgeIDParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class BadgeIDParameter : PreCannedParameterBase
    {
        public const string PropertyName = "BadgeID";
        public const string ParameterType = "System.Int32";

        public BadgeIDParameter(RuleActionParameter actionParameter, string actionName)
            : base(BadgeIDParameter.PropertyName)
        {
            ActionParameterValidator validator = new BadgeIDParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public BadgeIDParameter(string actionName, string value)
            : base(BadgeIDParameter.PropertyName)
        {
            this.Value = value;
            this.Type = BadgeIDParameter.ParameterType;
            this.ActionName = actionName;

            ActionParameterValidator validator = new BadgeIDParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\ActionSet.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine")]
    public class RuleActionParameter
    {
        [DataMember(IsRequired = true)]
        public string Name { get; set; }

        [DataMember(IsRequired = false, EmitDefaultValue = false)]
        public string Path { get; set; }

        [DataMember(IsRequired = false, EmitDefaultValue = false)]
        public string Value { get; set; }

        [DataMember(IsRequired = true)]
        public string Type { get; set; }
    }

    [DataContract(Name = "ScoreRange", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine")]
    public class ScoreRange
    {
        [DataMember(IsRequired = true)]
        public string Name { get; set; }

        [DataMember(IsRequired = true)]
        public ulong RewardId { get; set; }

        [DataMember(IsRequired = true)]
        public ulong Range { get; set; }
    }

    [DataContract(Name = "Settings", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine")]
    public class RuleActionSettings
    {
        [DataMember(IsRequired = false, EmitDefaultValue = false)]
        public List<ScoreRange> ScoreRanges { get; set; }
    }

    [DataContract(Name = "Action", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine")]
    public class RuleAction
    {
        [DataMember(IsRequired = true)]
        public string Name { get; set; }

        [DataMember(IsRequired = true, Name = "Parameters")]
        public List<RuleActionParameter> ActionParameters { get; set; }

        [DataMember(IsRequired = false, Name = "Settings", EmitDefaultValue = false)]
        public RuleActionSettings ActionSettings { get; set; }
    }

    [DataContract(Name = "ActionSet", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects.ActionEngine")]
    public class RuleActionSet
    {
        [DataMember(IsRequired = true, Name = "Actions")]
        public List<RuleAction> RuleActions { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\CreateAndSubmitEventAction.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "Action")]
    public class CreateAndSubmitEventAction : PreCannedActionBase
    {
        public const string ActionName = "CreateAndSubmitEvent";

        private Dictionary<string, ActionParameterValidator> parameterVerificationTable = null;
        
        public CreateAndSubmitEventAction(RuleAction action)
            : base(CreateAndSubmitEventAction.ActionName)
        {
            this.InternalValidate(action);
        }

        public CreateAndSubmitEventAction(long puid, string propertyName, string propertyValueType, string propertyValuePath)
            : base(CreateAndSubmitEventAction.ActionName)
        {
            this.ActionParameters = new List<RuleActionParameter>(4);

            // add user parameter.
            this.ActionParameters.Add(new UserParameter(CreateAndSubmitEventAction.ActionName, null, puid.ToString()));
            this.ActionParameters.Add(new PropertyNameParameter(CreateAndSubmitEventAction.ActionName, propertyName));
            this.ActionParameters.Add(new PropertyValueParameter(CreateAndSubmitEventAction.ActionName, propertyValuePath, propertyValueType));
            this.ActionParameters.Add(new GameEventParameter(CreateAndSubmitEventAction.ActionName));

            this.InternalValidate(this);
        }

        internal override Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                if (this.parameterVerificationTable == null)
                {
                    this.parameterVerificationTable = new Dictionary<string, ActionParameterValidator>(2, StringComparer.Ordinal);

                    ActionParameterValidator parameterValidator = null;

                    // Add the User Id parameter - 
                    parameterValidator = new UserParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the propertyName
                    parameterValidator = new PropertyNameParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the propertyValue
                    parameterValidator = new PropertyValueParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the mark for GameEvent
                    parameterValidator = new GameEventParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);
                }

                return this.parameterVerificationTable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\CreateBadgeAction.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    
    [DataContract(Name = "Action")]
    public class CreateBadgeAction : PreCannedActionBase
    {
        public const string ActionName = "CreateBadge";

        // TODO: Make static
        private Dictionary<string, ActionParameterValidator> parameterVerificationTable = null;

        public CreateBadgeAction(RuleAction action)
            : base(CreateBadgeAction.ActionName)
        {
            this.InternalValidate(action);
        }

        public CreateBadgeAction(long puid, uint badgeID)
            : base(CreateBadgeAction.ActionName)
        {
            this.ActionParameters = new List<RuleActionParameter>(4);

            // add user parameter.
            this.ActionParameters.Add(new UserParameter(CreateBadgeAction.ActionName, null, puid.ToString()));
            this.ActionParameters.Add(new BadgeIDParameter(CreateBadgeAction.ActionName, badgeID.ToString()));

            this.InternalValidate(this);
        }

        internal override Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                if (this.parameterVerificationTable == null)
                {
                    this.parameterVerificationTable = new Dictionary<string, ActionParameterValidator>(2, StringComparer.Ordinal);

                    ActionParameterValidator parameterValidator = null;

                    // Add the User Id parameter - 
                    parameterValidator = new UserParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the Badge Id parameter
                    parameterValidator = new BadgeIDParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);
                }

                return this.parameterVerificationTable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\ActionParameterValidator.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;

    internal class ActionParameterValidator
    {
        public ActionParameterValidator(string actionName, string name, bool pathRequired, bool valueRequired, string type)
        {
            this.ActionName = actionName;
            this.PathRequired = pathRequired;
            this.ValueRequired = valueRequired;
            this.Type = type;
            this.Name = name;
        }

        public bool PathRequired { get; private set; }

        public bool ValueRequired { get; private set; }

        public string Type { get; private set; }

        public string Name { get; private set; }

        private string ActionName { get; set; }

        public void Validate(RuleActionParameter parameter)
        {
            this.InternalValidate(parameter);
        }

        protected void InternalValidate(RuleActionParameter parameter)
        {
            this.InternalValidateName(parameter);
            this.InternalValidatePath(parameter);
            this.InternalValidateType(parameter);
            this.InternalValidateValue(parameter);
        }

        protected void InternalValidateName(RuleActionParameter parameter)
        {
            // Ensure parameter name matches.
            if (!string.Equals(parameter.Name, this.Name, StringComparison.OrdinalIgnoreCase))
            {
                string message = String.Format(
                                        "Action {0}, Parameter {1}, Name validation failed {2}",
                                        this.ActionName,
                                        this.Name,
                                        parameter.Name);
                throw new BusinessObjectsValidationException(message);
            }
        }
        
        // if Path property is required, ensure it exists.
        protected void InternalValidatePath(RuleActionParameter parameter)
        { 
            if (this.PathRequired && string.IsNullOrEmpty(parameter.Path))
            {
                string message = String.Format(
                                    "Action: {0}, Parameter: {1}, Required Path field not present",
                                    this.ActionName,
                                    this.Name);
                throw new BusinessObjectsValidationException(message);
            }

            if (!string.IsNullOrEmpty(parameter.Path))
            {
                // TODO: Parse the path string to validate it is a XPath query.
            }
        }

        protected void InternalValidateType(RuleActionParameter parameter)
        {
            // check that Types are equal.
            if (!string.IsNullOrEmpty(this.Type))
            {
                if (!string.Equals(this.Type, parameter.Type, StringComparison.OrdinalIgnoreCase))
                {
                    string message = String.Format(
                        "Action {0}, Parameter {1}, Required Type field is invalid: Excpected {2}, Found {3}",
                        this.ActionName,
                        this.Name,
                        this.Type,
                        parameter.Type);
                    throw new BusinessObjectsValidationException(message);
                }
            }
            else
            {
                // check parameter.Type against well known types.
            }
        }

        protected void InternalValidateValue(RuleActionParameter parameter)
        {
            // if Value property is required, ensure it exists.
            if (this.ValueRequired && string.IsNullOrEmpty(parameter.Value))
            {
                string message = String.Format(
                                    "Action {0}, Parameter {1}, Required Value field not present",
                                    this.ActionName,
                                    this.Name);
                throw new BusinessObjectsValidationException(message);
            }

            this.InternalValidateValueToTypeConversion(parameter);
        }

        protected void InternalValidateValueToTypeConversion(RuleActionParameter parameter)
        {
            // TODO Try Converting the Value string into the type here.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\CreateRangeBadgeAction.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    // TODO: Add further validation logic for the settings-range section.
    // For ex:
    // -- validate existence.
    // -- validate monotonically increasing range.
    // -- validate existence of badgeIds etc.
    [DataContract(Name = "Action")]
    public class CreateRangeBadgeAction : PreCannedActionBase
    {
        public const string ActionName = "CreateRangeBadge";

        // TODO: make static 
        private Dictionary<string, ActionParameterValidator> parameterVerificationTable = null;


        public CreateRangeBadgeAction(RuleAction action)
            : base(CreateRangeBadgeAction.ActionName)
        {
            this.InternalValidate(action);
        }

        internal override Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                if (this.parameterVerificationTable == null)
                {
                    this.parameterVerificationTable = new Dictionary<string, ActionParameterValidator>(2, StringComparer.Ordinal);

                    ActionParameterValidator parameterValidator = null;

                    // Add the User Id parameter - 
                    parameterValidator = new UserParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the Badge Id parameter
                    parameterValidator = new SourceValueParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);
                }

                return this.parameterVerificationTable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\Max1Parameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class Max1Parameter : PreCannedParameterBase
    {
        public const string PropertyName = "Max1";

        public Max1Parameter(RuleActionParameter actionParameter, string actionName)
            : base(Max1Parameter.PropertyName)
        {
            ActionParameterValidator validator = new Max1ParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public Max1Parameter(string actionName, string type, string path)
            : base(Max1Parameter.PropertyName)
        {
            this.Path = path;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new Max1ParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\GameEventParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class GameEventParameter : PreCannedParameterBase
    {
        public const string PropertyName = "GameEvent";
        public const string PropertyType = "GDS.Event";

        public GameEventParameter(RuleActionParameter actionParameter, string actionName)
            : base(GameEventParameter.PropertyName)
        {
            ActionParameterValidator validator = new GameEventParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public GameEventParameter(string actionName)
            : base(GameEventParameter.PropertyName)
        {
            this.Type = GameEventParameter.PropertyType;
            this.ActionName = actionName;

            ActionParameterValidator validator = new GameEventParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\PreCannedParameterBase.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class PreCannedParameterBase : RuleActionParameter
    {
        public PreCannedParameterBase(string name)
        {
            this.Name = name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\MaxPropertyAction.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    // TODO: Further verification between Max1-Max2-Store is required.
    // check that all 3 parameters are identicaly typed.
    [DataContract(Name = "Action")]
    public class MaxPropertyAction : PreCannedActionBase
    {
        public const string ActionName = "MaxProperty";

        // TODO: Make static
        private Dictionary<string, ActionParameterValidator> parameterVerificationTable = null;

        public MaxPropertyAction(RuleAction action)
            : base(MaxPropertyAction.ActionName)
        {
            this.InternalValidate(action);
        }

        public MaxPropertyAction(
                            long puid, 
                            string max1Type, 
                            string max1Path, 
                            string max2Type, 
                            object max2Value,
                            string storeType,
                            string storePath)
            : base(MaxPropertyAction.ActionName)
        {
            this.ActionParameters = new List<RuleActionParameter>(4);

            // add user parameter.
            this.ActionParameters.Add(new UserParameter(MaxPropertyAction.ActionName, null, puid.ToString()));
            this.ActionParameters.Add(new Max1Parameter(MaxPropertyAction.ActionName, max1Type, max1Path));
            this.ActionParameters.Add(new Max2Parameter(MaxPropertyAction.ActionName, max2Type, max2Value.ToString()));
            this.ActionParameters.Add(new StoreParameter(MaxPropertyAction.ActionName, storeType, storePath));

            this.InternalValidate(this);
        }

        internal override Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                if (this.parameterVerificationTable == null)
                {
                    this.parameterVerificationTable = new Dictionary<string, ActionParameterValidator>(2, StringComparer.Ordinal);

                    ActionParameterValidator parameterValidator = null;

                    // Add the User Id parameter - 
                    parameterValidator = new UserParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the Badge Id parameter
                    parameterValidator = new Max1ParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    parameterValidator = new Max2ParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    parameterValidator = new StoreParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);
                }

                return this.parameterVerificationTable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\Max2Parameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class Max2Parameter : PreCannedParameterBase
    {
        public const string PropertyName = "Max2";

        public Max2Parameter(RuleActionParameter actionParameter, string actionName)
            : base(Max2Parameter.PropertyName)
        {
            ActionParameterValidator validator = new Max2ParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public Max2Parameter(string actionName, string type, string value)
            : base(Max2Parameter.PropertyName)
        {
            this.Value = value;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new Max2ParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\PropertyNameParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class PropertyNameParameter : PreCannedParameterBase
    {
        public const string PropertyName = "PropertyName";
        public const string PropertyType = "System.string";

        public PropertyNameParameter(RuleActionParameter actionParameter, string actionName)
            : base(PropertyNameParameter.PropertyName)
        {
            ActionParameterValidator validator = new PropertyNameParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public PropertyNameParameter(string actionName, string value)
            : base(PropertyNameParameter.PropertyName)
        {
            this.Value = value;
            this.Type = PropertyNameParameter.PropertyType;
            this.ActionName = actionName;

            ActionParameterValidator validator = new PropertyNameParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\PreCannedActionBase.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "Action")]
    public class PreCannedActionBase : RuleAction
    {
        protected object lockObject = new object();

        protected PreCannedActionBase(string name)
        {
            this.Name = name;
        }

        internal virtual Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                throw new NotImplementedException("Derived class should implement this");
            }
        }

        internal virtual void ValidateAndSetName(string name)
        {
        }

        internal virtual void ValidateAndSetParameters(List<RuleActionParameter> listOfParams)
        {
        }

        protected void InternalValidate(RuleAction action)
        {
            this.InternalValidateAndSetName(action.Name);
            this.InternalValidateAndSetParameters(action.ActionParameters);
        }

        protected void InternalValidateAndSetName(string name)
        {
            if (!string.Equals(name, this.Name, StringComparison.Ordinal))
            {
                throw new BusinessObjectsValidationException("Action name is invalid");
            }

            // call into derived class
            this.ValidateAndSetName(Name);
        }

        protected void InternalValidateAndSetParameters(List<RuleActionParameter> listOfParams)
        {
            try
            {
                int i = this.ParameterVerificationTable.Count;

                ActionParameterValidator parameterValidator = null;

                foreach (RuleActionParameter param in listOfParams)
                {
                    if (i-- > 0)
                    {
                        if (this.ParameterVerificationTable.TryGetValue(param.Name, out parameterValidator))
                        {
                            parameterValidator.Validate(param);
                        }
                        else
                        {
                            string message = String.Format(
                                                "Unexpected Action Parameter {0} for Action {1}",
                                                param.Name,
                                                this.Name);
                            throw new BusinessObjectsValidationException(message);
                        }
                    }
                    else
                    {
                        string message = String.Format(
                                            "Unexpected Action Parameter {0} for Action {1}",
                                            param.Name,
                                            this.Name);
                        throw new BusinessObjectsValidationException(message);
                    }
                }

                if (i != 0)
                {
                    throw new BusinessObjectsValidationException("Missing parameter encountered in ActionSet Xml");
                }

                this.ActionParameters = listOfParams;

                // call into derived class for extended verification
                this.ValidateAndSetParameters(listOfParams);
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\PropertyValueParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class PropertyValueParameter : PreCannedParameterBase
    {
        public const string PropertyName = "PropertyValue";

        public PropertyValueParameter(RuleActionParameter actionParameter, string actionName)
            : base(PropertyValueParameter.PropertyName)
        {
            ActionParameterValidator validator = new PropertyValueParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public PropertyValueParameter(string actionName, string path, string type)
            : base(PropertyValueParameter.PropertyName)
        {
            this.Path = path;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new PropertyValueParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\RuleActionSetConverter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts.ActionEngine;

    internal static class RuleActionSetConverter
    {
        private static object lockObject = new object();

        internal static RuleActionSet TryConvert(RuleActionSet actionSet)
        {
            List<RuleAction> newActionsList = new List<RuleAction>(actionSet.RuleActions.Count);
            try
            {
                foreach (RuleAction action in actionSet.RuleActions)
                {
                    RuleAction preCannedAction = RuleActionSetConverter.ConvertToPreCannedAction(action);
                    newActionsList.Add(preCannedAction);
                }

                actionSet.RuleActions = newActionsList;
                return actionSet;
            }
            catch (BusinessObjectsValidationException)
            {
                // TODO: Log here.
                throw;
            }
        }

        internal static RuleAction ConvertToPreCannedAction(RuleAction action)
        {
            if (string.Equals(action.Name, CreateBadgeAction.ActionName, StringComparison.OrdinalIgnoreCase))
            {
                return new CreateBadgeAction(action);
            }
            else if (string.Equals(action.Name, CreateAndSubmitEventAction.ActionName, StringComparison.OrdinalIgnoreCase))
            {
                return new CreateAndSubmitEventAction(action);
            }
            else if (string.Equals(action.Name, CreateRangeBadgeAction.ActionName, StringComparison.OrdinalIgnoreCase))
            {
                return new CreateRangeBadgeAction(action);
            }
            else if (string.Equals(action.Name, MaxPropertyAction.ActionName, StringComparison.OrdinalIgnoreCase))
            {
                return new MaxPropertyAction(action);
            }
            else if (string.Equals(action.Name, SumPropertyAction.ActionName, StringComparison.OrdinalIgnoreCase))
            {
                return new SumPropertyAction(action);
            }
            else
            {
                return action;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\Sum2Parameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class Sum2Parameter : PreCannedParameterBase
    {
        public const string PropertyName = "Sum2";

        public Sum2Parameter(RuleActionParameter actionParameter, string actionName)
            : base(Sum2Parameter.PropertyName)
        {
            ActionParameterValidator validator = new Sum2ParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public Sum2Parameter(string actionName, string type, string value)
            : base(Sum2Parameter.PropertyName)
        {
            this.Value = value;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new Sum2ParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\SourceValueParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class SourceValueParameter : PreCannedParameterBase
    {
        public const string PropertyName = "SourceValue";

        public SourceValueParameter(RuleActionParameter actionParameter, string actionName)
            : base(SourceValueParameter.PropertyName)
        {
            ActionParameterValidator validator = new StoreParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public SourceValueParameter(string actionName, string type, string path)
            : base(SourceValueParameter.PropertyName)
        {
            this.Path = path;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new StoreParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\SumPropertyAction.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    // TODO: Further verification between Max1-Max2-Store is required.
    // check that all 3 parameters are identicaly typed.
    [DataContract(Name = "Action")]
    public class SumPropertyAction : PreCannedActionBase
    {
        public const string ActionName = "SumProperty";

        // TODO: Make static
        private Dictionary<string, ActionParameterValidator> parameterVerificationTable = null;

        public SumPropertyAction(RuleAction action)
            : base(SumPropertyAction.ActionName)
        {
            this.InternalValidate(action);
        }

        public SumPropertyAction(
                            long puid, 
                            string sum1Type, 
                            string sum1Path, 
                            string sum2Type, 
                            object sum2Value,
                            string storeType,
                            string storePath)
            : base(SumPropertyAction.ActionName)
        {
            this.ActionParameters = new List<RuleActionParameter>(4);

            // add user parameter.
            this.ActionParameters.Add(new UserParameter(SumPropertyAction.ActionName, null, puid.ToString()));
            this.ActionParameters.Add(new Sum1Parameter(SumPropertyAction.ActionName, sum1Type, sum1Path));
            this.ActionParameters.Add(new Sum2Parameter(SumPropertyAction.ActionName, sum2Type, sum2Value.ToString()));
            this.ActionParameters.Add(new StoreParameter(SumPropertyAction.ActionName, storeType, storePath));

            this.InternalValidate(this);
        }

        internal override Dictionary<string, ActionParameterValidator> ParameterVerificationTable
        {
            get
            {
                if (this.parameterVerificationTable == null)
                {
                    this.parameterVerificationTable = new Dictionary<string, ActionParameterValidator>(2, StringComparer.Ordinal);

                    ActionParameterValidator parameterValidator = null;

                    // Add the User Id parameter - 
                    parameterValidator = new UserParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    // Add the Badge Id parameter
                    parameterValidator = new Sum1ParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    parameterValidator = new Sum2ParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);

                    parameterValidator = new StoreParameterValidator(CreateAndSubmitEventAction.ActionName);
                    this.parameterVerificationTable.Add(parameterValidator.Name, parameterValidator);
                }

                return this.parameterVerificationTable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\UserParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class UserParameter : PreCannedParameterBase
    {
        public const string PropertyName = "User";
        public const string ParameterType = "System.Int64";

        public UserParameter(RuleActionParameter actionParameter, string actionName)
            : base(UserParameter.PropertyName)
        {
            ActionParameterValidator validator = new UserParameterValidator(actionName);
            validator.Validate(actionParameter);
            
            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public UserParameter(string actionName, string path, string value)
            : base(UserParameter.PropertyName)
        {
            this.Path = path;
            this.Value = value;
            this.Type = UserParameter.ParameterType;
            this.ActionName = actionName;
            
            ActionParameterValidator validator = new UserParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\Sum1Parameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class Sum1Parameter : PreCannedParameterBase
    {
        public const string PropertyName = "Sum1";

        public Sum1Parameter(RuleActionParameter actionParameter, string actionName)
            : base(Sum1Parameter.PropertyName)
        {
            ActionParameterValidator validator = new Sum1ParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public Sum1Parameter(string actionName, string type, string path)
            : base(Sum1Parameter.PropertyName)
        {
            this.Path = path;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new Sum1ParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\StoreParameter.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Parameter")]
    public class StoreParameter : PreCannedParameterBase
    {
        public const string PropertyName = "Store";

        public StoreParameter(RuleActionParameter actionParameter, string actionName)
            : base(StoreParameter.PropertyName)
        {
            ActionParameterValidator validator = new StoreParameterValidator(actionName);
            validator.Validate(actionParameter);

            // continue constructing if validation passed.
            this.Path = actionParameter.Path;
            this.Type = actionParameter.Type;
            this.Value = actionParameter.Value;
            this.ActionName = actionName;
        }

        public StoreParameter(string actionName, string type, string path)
            : base(StoreParameter.PropertyName)
        {
            this.Path = path;
            this.Type = type;
            this.ActionName = actionName;

            ActionParameterValidator validator = new StoreParameterValidator(actionName);
            validator.Validate(this);
        }

        public string ActionName { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Converters\GameResultConverter.cs ===
﻿namespace Gds.Contracts.Converters
{
    using Gds.Contracts;
    using System;

    public static class GameResultConverterExtension
    {
        public const string TimePropertyName = "Time";
        public const string ScorePropertyName = "Score";
        public const string VariantPropertyName = "Variant";
        public const string OutcomePropertyName = "Outcome";
        public const string BlobPropertyName = "Blob";
        public const int MaximumAllowedBlobSize = 10240; // 10K

        private const string DefaultPropertySchemaName = "WinMobile.GameResult";
        private const string DefaultEventCategory = "WinMobile.Score";
        
        private const string TimePropertyTypeName = "long";
        private const string ScorePropertyTypeName = "long";
        private const string VariantPropertyTypeName = "int";
        private const string OutcomePropertyTypeName = "string";
        private const string BlobPropertyTypeName = "Byte[]";

        public const string OutcomeWin = "Win";
        public const string OutcomeLoss = "Loss";
        public const string OutcomeTie = "Tie";
        public const string OutcomeNone = "None";

        

        public static GameEvent ConvertToGameEvent(this GameResult gameResult, ulong Xuid, uint platformId, string locale)
        {
            GameEvent gameEvent = new GameEvent();

            gameEvent.UserId = Xuid;
            gameEvent.Culture = locale;
            gameEvent.GameEventId = gameResult.GameResultId;
            gameEvent.PlatformId = platformId;
            gameEvent.EventCategory = GameResultConverterExtension.DefaultEventCategory;
            gameEvent.PropertySchemaName = GameResultConverterExtension.DefaultPropertySchemaName;
            gameEvent.GameSessionId = Guid.Empty;
            gameEvent.GameId = gameResult.GameId;

            // We should NOT use client provided time stamp, as this data is suspect for tampering:
            //gameEvent.TimeStamp = gameResult.TimeStamp;
            gameEvent.TimeStamp = DateTime.UtcNow;
            
            // Lets add the properties section - first create the object.
            gameEvent.Properties = new System.Collections.Generic.List<Property>();

            // Add the variant as an property.
            Property gameEventProperty = new Property();

            gameEventProperty.Name = GameResultConverterExtension.VariantPropertyName;
            gameEventProperty.PropertyType = GameResultConverterExtension.VariantPropertyTypeName;
            gameEventProperty.Value = gameResult.Variant.ToString();
            gameEvent.Properties.Add(gameEventProperty);

            if (gameResult.Time.HasValue)
            {
                if (gameResult.Time.Value > -1)
                {
                    gameEventProperty = new Property();

                    gameEventProperty.Name = GameResultConverterExtension.TimePropertyName;
                    gameEventProperty.PropertyType = GameResultConverterExtension.TimePropertyTypeName;
                    gameEventProperty.Value = gameResult.Time.Value.ToString();
                    gameEvent.Properties.Add(gameEventProperty);
                }
                else
                {
                    throw new GameResultConverterException(string.Format("A negative time value ({0}) is submitted, we shall actively refuse this submission", gameResult.Time.Value));
                }
            }

            if (gameResult.Score.HasValue)
            {
                gameEventProperty = new Property();

                gameEventProperty.Name = GameResultConverterExtension.ScorePropertyName;
                gameEventProperty.PropertyType = GameResultConverterExtension.ScorePropertyTypeName;
                gameEventProperty.Value = gameResult.Score.Value.ToString();
                gameEvent.Properties.Add(gameEventProperty);
            }

            // Convert outcome if valid.
            if (gameResult.HasOutcomePresent())
            {
                gameEventProperty = new Property();

                gameEventProperty.Name = GameResultConverterExtension.OutcomePropertyName;
                gameEventProperty.PropertyType = GameResultConverterExtension.OutcomePropertyTypeName;
                gameEventProperty.Value = gameResult.Outcome;
                gameEvent.Properties.Add(gameEventProperty);
            }

            // if we only have "1" property thus far, it is just the variant Id.
            // and hence we have neither Score, nor Time, nor Outcome properties in the GameResult.
            // which means, we should not process this any further.
            if (gameEvent.Properties.Count == 1)
            {
                throw new GameResultConverterException("None of the following properties are provided: Score, Outcome, Time. You need at least one for a valid GameResult");
            }

            // convert blob if valid, to a property in gameEvent.
            if (gameResult.HasValidBlob())
            {
                gameEventProperty = new Property();

                gameEventProperty.Name = GameResultConverterExtension.BlobPropertyName;
                gameEventProperty.PropertyType = GameResultConverterExtension.BlobPropertyTypeName;
                gameEventProperty.Value = Convert.ToBase64String(gameResult.Blob);
                gameEvent.Properties.Add(gameEventProperty);
            }

            return gameEvent;
        }

        public static bool HasOutcomePresent(this GameResult gameResult)
        {
            if (!String.IsNullOrEmpty(gameResult.Outcome))
            {
                if (string.Compare(gameResult.Outcome, GameResultConverterExtension.OutcomeWin, StringComparison.InvariantCultureIgnoreCase) == 0)
                {
                    return true;
                }
                else if (string.Compare(gameResult.Outcome, GameResultConverterExtension.OutcomeLoss, StringComparison.InvariantCultureIgnoreCase) == 0)
                {
                    return true;
                }
                else if (string.Compare(gameResult.Outcome, GameResultConverterExtension.OutcomeTie, StringComparison.InvariantCultureIgnoreCase) == 0)
                {
                    return true;
                }
                else if (string.Compare(gameResult.Outcome, GameResultConverterExtension.OutcomeNone, StringComparison.InvariantCultureIgnoreCase) == 0)
                {
                    return false;
                }
                else
                {
                    // something completely out of whack is put here.
                    throw new GameResultConverterException("An invalid Outcome string is provided in GameResult. This message will not be processed further");
                }
            }

            return false;
        }

        public static bool HasValidBlob(this GameResult gameResult)
        {
            if (gameResult.Blob == null)
            {
                return false;
            }

            if (gameResult.Blob.Length > GameResultConverterExtension.MaximumAllowedBlobSize)
            {
                throw new GameResultConverterException("An Invalid Blob Length is given in the GameResult. This message will not be processed further");
            }

            return true;
        }
    }

    public class GameResultConverterException : InvalidOperationException
    {
        public GameResultConverterException(string msg)
            : base(msg)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\ActionEngine\UserParameterValidator.cs ===
﻿namespace Gds.Contracts.ActionEngine
{
    using System;

    internal class UserParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = UserParameter.PropertyName;
        private const string ParameterType = UserParameter.ParameterType;

        // Note that we set the required field to false for both Path and Value properties
        // as the DecisionTree converts the Path (after parsing) into the correct Value properties.
        // Hence, depending on who the caller is (Decision Tree or Action Engine) we have different required fields.
        internal UserParameterValidator(string actionName)
            : base(actionName, UserParameterValidator.ParameterName, false, false, UserParameterValidator.ParameterType)
        {}
    }

    internal class BadgeIDParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = BadgeIDParameter.PropertyName;
        private const string ParameterType = BadgeIDParameter.ParameterType;

        internal BadgeIDParameterValidator(string actionName)
            : base(actionName, BadgeIDParameterValidator.ParameterName, false, false, BadgeIDParameterValidator.ParameterType)
        {}
    }

    internal class PropertyNameParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = PropertyNameParameter.PropertyName;
        private const string ParameterType = PropertyNameParameter.PropertyType;

        internal PropertyNameParameterValidator(string actionName)
            : base(actionName, PropertyNameParameterValidator.ParameterName, false, false, PropertyNameParameterValidator.ParameterType)
        {}
    }

    internal class PropertyValueParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = PropertyValueParameter.PropertyName;
        private const string ParameterType = null;

        internal PropertyValueParameterValidator(string actionName)
            : base(actionName, PropertyValueParameterValidator.ParameterName, false, false, PropertyValueParameterValidator.ParameterType)
        {}
    }

    internal class GameEventParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = GameEventParameter.PropertyName;
        private const string ParameterType = GameEventParameter.PropertyType;

        internal GameEventParameterValidator(string actionName)
            : base(actionName, GameEventParameterValidator.ParameterName, false, false, GameEventParameterValidator.ParameterType)
        {}
    }

    internal class SourceValueParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = SourceValueParameter.PropertyName;
        private const string ParameterType = null;

        internal SourceValueParameterValidator(string actionName)
            : base(
                actionName, SourceValueParameterValidator.ParameterName, false, false, SourceValueParameterValidator.ParameterType)
        {
        }
    }

    internal class Max1ParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = Max1Parameter.PropertyName;
        private const string ParameterType = null;

        internal Max1ParameterValidator(string actionName)
            : base(actionName, Max1ParameterValidator.ParameterName, false, false, Max1ParameterValidator.ParameterType)
        {
        }
    }

    // we may have either path or value, so don't require any for the time being.
    internal class Max2ParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = Max2Parameter.PropertyName;
        private const string ParameterType = null;

        internal Max2ParameterValidator(string actionName)
            : base(actionName, Max2ParameterValidator.ParameterName, false, false, Max2ParameterValidator.ParameterType)
        {
        }
    }

    internal class StoreParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = StoreParameter.PropertyName;
        private const string ParameterType = null;

        internal StoreParameterValidator(string actionName)
            : base(actionName, StoreParameterValidator.ParameterName, false, false, StoreParameterValidator.ParameterType)
        {
        }
    }

    internal class Sum1ParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = Sum1Parameter.PropertyName;
        private const string ParameterType = null;

        internal Sum1ParameterValidator(string actionName)
            : base(actionName, Sum1ParameterValidator.ParameterName, false, false, Sum1ParameterValidator.ParameterType)
        {
        }
    }
    
    internal class Sum2ParameterValidator : ActionParameterValidator
    {
        private const string ParameterName = Sum2Parameter.PropertyName;
        private const string ParameterType = null;

        internal Sum2ParameterValidator(string actionName)
            : base(actionName, Sum2ParameterValidator.ParameterName, false, false, Sum2ParameterValidator.ParameterType)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\GameResultOutcome.cs ===
﻿namespace Gds.Contracts
{
    public enum GameResultOutcome : uint
    {
        None = 0,
        Win = 1,
        Loss = 2,
        Tie = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\BusinessObjectsValidationException.cs ===
﻿namespace Gds.Contracts
{
    using System;

    [Serializable]
    public class BusinessObjectsValidationException : Exception
    {
        public BusinessObjectsValidationException()
        {
        }

        public BusinessObjectsValidationException(string message)
            : base(message)
        {
        }

        public BusinessObjectsValidationException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Contracts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corporation")]
//[assembly: AssemblyProduct("GDS.Contracts")]
//[assembly: AssemblyCopyright("Copyright © 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

//// Setting ComVisible to false makes the types in this assembly not visible 
//// to COM components.  If you need to access a type in this assembly from 
//// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

//// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("89d2c189-c29c-4788-b6d0-b696eb529658")]

//// Version information for an assembly consists of the following four values:
////
////      Major Version
////      Minor Version 
////      Build Number
////      Revision
////
//// You can specify all the values or you can default the Build and Revision Numbers 
//// by using the '*' as shown below:
//// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\GameEvent.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="GameEvent.cs" company="Microsoft" author="Atin Jain">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>GameEvent data object</summary>
//-------------------------------------------------------------------------------------------------
namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Defines the object passed as a parameter to the SubmitEvent operation.
    /// </summary>
    [DataContract(Name = "GameEvent", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    public class GameEvent
    {
        /// <summary>
        /// Gets or sets the culture value of the event source, e.g. en-us, etc.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "Culture")]
        public string Culture { get; set; }

        /// <summary>
        /// Gets or sets GameKey 
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "GameId")]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the Platform identifier string.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 2, Name = "PlatformId")]
        public uint PlatformId { get; set; }

        /// <summary>
        /// Gets or sets the Windows Live PUID that uniquely identifies the user
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 3, Name = "UserId")]
        public ulong UserId { get; set; }

        /// <summary>
        /// Gets or sets a unique identifier for the Session.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 4, Name = "GameSessionId")]
        public Guid GameSessionId { get; set; }

        /// <summary>
        /// Gets or sets a unique identifier for this event instance. (e.g. a message id)
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 5, Name = "GameEventId")]
        public Guid GameEventId { get; set; }
        
        /// <summary>
        /// Gets or sets the buckets of events.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 6, Name = "EventCategory")]
        public string EventCategory { get; set; }

        /// <summary>
        /// Gets or sets the unique schema name for the property bag.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 7, Name = "PropertySchemaName")]
        public string PropertySchemaName { get; set; }

        /// <summary>
        /// Gets or sets the 
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 8, Name = "TimeStamp")]
        public DateTime TimeStamp { get; set; }

        /// <summary>
        /// Gets or sets a strongly typed XML fragment defining the name/value property pairs.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 9, Name = "Properties")]
        public List<Property> Properties { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\GameResult.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="GameResult.cs" company="Microsoft" author="Savas Guven">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>GameEvent data object</summary>
//-------------------------------------------------------------------------------------------------
namespace Gds.Contracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "GameResult", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    public class GameResult
    {
        /// <summary>
        /// Gets or sets GameID 
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "GameId")]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the Variant of the game.
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "Variant")]
        public uint Variant { get; set; }

        /// <summary>
        /// Gets or sets a unique identifier for this event instance. (e.g. a message id)
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 2, Name = "GameResultId")]
        public Guid GameResultId { get; set; }

        /// <summary>
        /// Gets or sets the TimeStamp
        /// </summary>
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 3, Name = "TimeStamp")]
        public DateTime TimeStamp { get; set; }

        /// <summary>
        /// Gets or sets the Game Score achieved.
        /// </summary>
        [DataMember(IsRequired = false, EmitDefaultValue = false, Order = 4, Name = "Score")]
        public long? Score { get; set; }

        /// <summary>
        /// Gets or sets Time in seconds played.
        /// </summary>
        [DataMember(IsRequired = false, EmitDefaultValue = false, Order = 5, Name = "Time")]
        public long? Time { get; set; }

        /// <summary>
        /// Gets or sets the outcome, win or loss or tie
        /// </summary>
        [DataMember(IsRequired = false, EmitDefaultValue = true, Order = 6, Name = "Outcome")]
        public string Outcome { get; set; }

        /// <summary>
        /// Gets or sets a binary blob to be saved in cases where a Best Time or Score is achieved.
        /// </summary>
        [DataMember(IsRequired = false, EmitDefaultValue = true, Order = 7, Name = "Blob")]
        public byte[] Blob { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\RewardsQueueSettings.cs ===
﻿namespace Gds.Contracts.Rewards
{
    using System.Text;

    // These names are under which names they are catalogued in LIVEn NPDB
    public static class RewardsQueueSettings
    {
        // retrieved from t_interfaces table.
        public const string DatabaseName = "lest_rewardsqueue_db";

        // This is the standard Queue Encoding used when moving from byte <-> string
        public static readonly Encoding QueueEncoding = Encoding.Unicode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\SerializerDeserializer.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="SerializerDeserializer.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>serialization and deserialization class</summary>
//-------------------------------------------------------------------------------------------------
using System.Text.RegularExpressions;

namespace Gds.Contracts
{
    using System;
    using System.Configuration;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Threading;
    using System.Xml;
    using System.Xml.Schema;
    using Gds.Contracts.ActionEngine;

    /// <summary>
    /// Class responsible for serialization and deserialization of an object
    /// </summary>
    public static class SerializerDeserializer
    {
        private const string DefaultXsdPath = @".\";

        private const string ActionEngineXsdFileName = "ActionEngine.xsd";
        private const string GameEventXsdFileName = "GameEvent.xsd";
        private const string GameResultXsdFileName = "GameResult.xsd";

        private static int isInitialized = 0;

        private static string XsdFilesLocationPath { get; set; }

        /// <summary>
        /// Deserializes a given string into the DataContract object whose type is passed in
        /// If there is any problem with the xml we return a null object.
        /// If the environment is not set up correctly, or if the schema file cannot be found
        /// There will be exceptions flying out.
        /// NOTE: if schema paths are not set properly OR schemas cannot be found locally it will throw
        ///       a) DirectoryNotFoundException or
        ///       b) FileNotFoundException
        /// </summary>
        /// <param name="inputXml">The Serialized string</param>
        /// <param name="targetType">The target DataContract type</param>
        /// <returns>The deserialized DataContract object whose type was specified</returns>
        public static object DeserializeFromString(string inputXml, Type targetType)
        {
            SerializerDeserializer.Initialize();

            if (string.IsNullOrEmpty(inputXml))
            {
                return null;
            }

            string xsdFilePath = SerializerDeserializer.GetXsdFilePathForType(targetType);
            bool invalid = false;

            // Create validator
            XmlReaderSettings readerSettings = new XmlReaderSettings();

            readerSettings.ValidationType = ValidationType.Schema;
            readerSettings.Schemas.Add(null, xsdFilePath);


            readerSettings.ValidationEventHandler += delegate(object sender, ValidationEventArgs vargs)
            {
                invalid = true;

                // TODO: Change to some other logging type.
                Console.WriteLine("{0}: {1}", vargs.Severity, vargs.Message);
            };

            MemoryStream memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(inputXml), false);
            memoryStream.Position = 0;

            // Process de-serialization using validator
            object outObject = null;

            try
            {
                using (XmlReader xmlReader = XmlReader.Create(memoryStream, readerSettings))
                {
                    DataContractSerializer dcs = new DataContractSerializer(targetType);
                    outObject = dcs.ReadObject(xmlReader);
                    invalid = !SerializerDeserializer.IsValidObject(outObject, targetType);
                }
            }
            catch (SerializationException se)
            {
                throw new BusinessObjectsValidationException("Exception for serialization of a game event.", se);
            }
            catch (XmlException xe)
            {
                throw new BusinessObjectsValidationException("Xml exception occurred for game events.", xe);
            }

            if (!invalid)
            {
                return TryGetDerivedObject(outObject);
            }

            throw new BusinessObjectsValidationException("Invalid game event.");
        }

        public static bool IsValidObject(object target, Type targetType)
        {
            if (targetType == typeof(GameEvent))
            {
                return SerializerDeserializer.IsValidGameEvent((GameEvent)target);
            }

            return true;
        }

        private static bool IsValidGameEvent(GameEvent gameEvent)
        {
            if (!IsValidLocale(gameEvent.Culture))
            {
                return false;
            }


            if (gameEvent.PlatformId < 1)
            {
                return false;
            }

            // Validate UserID
            // GameSessionID
            // GameEventID

            foreach (Property property in gameEvent.Properties)
            {
                if (string.IsNullOrEmpty(property.Name) ||
                    property.Name.Length > 60)
                {
                    return false;
                }

                if (string.IsNullOrEmpty(property.PropertyType) ||
                    property.PropertyType.Length > 60)
                {
                    return false;
                }

                if (string.IsNullOrEmpty(property.PropertyType) ||
                    property.PropertyType.Length > 60)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool IsAlphaNumeric(string strToCheck)
        {
            Regex objAlphaNumericPattern = new Regex("[^a-zA-Z0-9]");

            return !objAlphaNumericPattern.IsMatch(strToCheck);
        }

        public static bool IsAlpha(string strToCheck)
        {
            Regex objAlphaPattern = new Regex("[^a-zA-Z]");

            return !objAlphaPattern.IsMatch(strToCheck);
        }

        public static bool IsValidLocale(string locale)
        {
            try
            {
                string[] localeParts = locale.Trim().Split('-');
                string language = localeParts[0];
                string country = localeParts[1];

                if (IsAlpha(language) && IsAlpha(country))
                {
                    return true;
                }
            }
            catch { }

            return false;
        }

        /// <summary>
        /// Serializes a DataContract object into a string.
        /// Note that DataContractSerializer serializes in UTF-8, so be careful about BOM.
        /// </summary>
        /// <param name="inputValue">A DataContract object</param>
        /// <returns>The string representation of the XML</returns>
        public static string SerializeToString(object inputValue)
        {
            MemoryStream memStream = new MemoryStream(1024);

            DataContractSerializer serializer = new DataContractSerializer(inputValue.GetType());
            serializer.WriteObject(memStream, inputValue);

            memStream.Position = 0;
            StreamReader sr = new StreamReader(memStream, Encoding.UTF8);

            return sr.ReadToEnd();
        }

        /// <summary>
        /// Serializes a DataContract object into a MemoryStream in UTF-8 encoding
        /// </summary>
        /// <param name="inputValue">A DataContractable object</param>
        /// <returns>The memory stream with the position reset</returns>
        public static Stream SerializeToStreamInUtf8(object inputValue)
        {
            MemoryStream memStream = new MemoryStream(1024);

            DataContractSerializer serializer = new DataContractSerializer(inputValue.GetType());
            serializer.WriteObject(memStream, inputValue);

            memStream.Position = 0;
            return memStream;
        }

        /// <summary>
        /// Initializes Config variables for XSD file locations
        /// </summary>
        private static void Initialize()
        {
            if (isInitialized != 0)
            {
                return;
            }

            if (Interlocked.Increment(ref SerializerDeserializer.isInitialized) == 1)
            {
                SerializerDeserializer.XsdFilesLocationPath = ConfigurationManager.AppSettings["RulesService_Config_BusinessObjectXsdPath"];
            }
        }

        private static string GetXsdFilePathForType(Type targetType)
        {
            StringBuilder sb = new StringBuilder(1024);

            if (!string.IsNullOrEmpty(SerializerDeserializer.XsdFilesLocationPath))
            {
                sb.AppendFormat("{0}\\", SerializerDeserializer.XsdFilesLocationPath);
            }
            else
            {
                sb.AppendFormat("{0}\\", SerializerDeserializer.DefaultXsdPath);
            }

            if (targetType == typeof(GameEvent))
            {
                sb.Append(SerializerDeserializer.GameEventXsdFileName);
            }
            else if (targetType == typeof(RuleActionSet))
            {
                sb.Append(SerializerDeserializer.ActionEngineXsdFileName);
            }
            else if (targetType == typeof(GameResult))
            {
                sb.Append(SerializerDeserializer.GameResultXsdFileName);
            }
            else
            {
                throw new ArgumentException("targetType");
            }

            return sb.ToString();
        }

        private static object TryGetDerivedObject(object obj)
        {
            // populate the internal list of action with proper derived class instances and validate them.
            if (obj.GetType() == typeof(RuleActionSet))
            {
                return RuleActionSetConverter.TryConvert((RuleActionSet)obj);
            }
            return obj;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Contracts\Rewards\Property.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="Property.cs" company="Microsoft" author="Atin Jain">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>Property data class</summary>
//-------------------------------------------------------------------------------------------------
namespace Gds.Contracts
{
    using System.Runtime.Serialization;

    /// <summary>
    /// Defines the Property class used as property bag
    /// </summary>
    [DataContract(Name = "Property", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    public class Property
    {
        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 0, Name = "Name")]
        public string Name { get; set; }

        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 1, Name = "PropertyType")]
        public string PropertyType { get; set; }

        [DataMember(IsRequired = true, EmitDefaultValue = true, Order = 2, Name = "Value")]
        public string Value { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\CompositeGameResult.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using Gds.Contracts;

    public class CompositeGameResult
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public ulong Xuid { get; set; }

        public GameResult GameResult { get; set; }

        public string Locale { get; set; }

        public string PlatformType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Gds.Services")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\GameResultSubmissionEnum.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
    public enum GameResultSubmissionEnum
    {
        Invalid = 0,
        RewardsServiceSubmission,
        MultiplayerServiceSubmission
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\IIdempotencyFilter.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Idempotency")]
    public interface IIdempotencyFilter
    {
        /// <summary>
        /// Checks if given Id is previously seen or not
        /// If mark flag is set, the checked Id is noted for future checks.
        /// </summary>
        /// <param name="Id"></param>
        /// <param name="mark"></param>
        /// <returns></returns>
        bool IsProcessed(Guid id, bool mark);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\CSubmitGameResult.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using Gds.Contracts;
    using Gds.Contracts.Converters;
    using Gds.Services;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
    public class CSubmitGameResult : ISubmitGameResult
    {
        public static void RegisterInterfaces(IContainer container)
        {
            RewardsEvents.Initialize("gds_rewards");
            container.AddService<IRewardsQueueWriter, RewardsQueueWriter>();
            container.AddService<ISubmitGameResult, CSubmitGameResult>();
            Container.Instance.AddService<IIdempotencyFilter, InMemoryBasicIdempotencyFilter>();
        }

        public void Submit(CompositeGameResult compGameResult, GameResultSubmissionEnum submissionMode)
        {
            ValidateCompositeGameResult(compGameResult, submissionMode);
            CSubmitGameResult.ValidatedSubmit(compGameResult, submissionMode);
        }

        public void SubmitBatch(System.Collections.Generic.IList<CompositeGameResult> listCompositeGameResult, GameResultSubmissionEnum submissionMode)
        {
            if (listCompositeGameResult == null)
            {
                throw new RewardsDataAccessValidationException("listCompositeGameResult", "A Null reference is passed in");
            }

            if (listCompositeGameResult.Count == 0)
            {
                throw new RewardsDataAccessValidationException("listCompositeGameResult does NOT contain any items");
            }

            // Use the single version to iterate over and Validate.
            foreach (CompositeGameResult compGameResult in listCompositeGameResult)
            {
                ValidateCompositeGameResult(compGameResult, submissionMode);
            }

            // since all parameters are validated, simply re-iterate over the list and submit them all.
            foreach (CompositeGameResult compGameResult in listCompositeGameResult)
            {
                CSubmitGameResult.ValidatedSubmit(compGameResult, submissionMode);
            }
        }

        private static void ValidateCompositeGameResult(CompositeGameResult compGameResult, GameResultSubmissionEnum submissionMode)
        {
            if (compGameResult == null)
            {
                throw new RewardsDataAccessValidationException("compGameResult", "A Null reference is passed in");
            }

            try
            {
                // throws ArgumentException based exception
                ServiceParameterValidator.ValidateXuid(compGameResult.Xuid);

                // validate the timestamp, throws ArgumentOutOfRangeException
                // BUG: 10693 -- We are removing the Client provided timestamp validation.
                // this timestamp is not propagated to the internal but instead we are using the server time.
                //ServiceParameterValidator.ValidateGameTimestamp(compGameResult.GameResult.TimeStamp);   

                // only throws ArgumentException derived class, OR GMS related connectivity exceptions.
                GameResultValidator.ValidatePostGameResult(compGameResult.GameResult, compGameResult.Locale, compGameResult.PlatformType, submissionMode);
            }
            catch (ArgumentException ex)
            {
                throw new RewardsDataAccessValidationException("Validation Failure, check inner exception for details", ex);
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessOperationException("An internal error prevents Validation from completing, check inner exception for details", ex);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.Parse(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "submissionMode")]
        private static void ValidatedSubmit(CompositeGameResult compGameResult, GameResultSubmissionEnum submissionMode)
        {
            try
            {
                // Ensure that this message was not processed before.
                if (Container.Instance.GetComponent<IIdempotencyFilter>().IsProcessed(compGameResult.GameResult.GameResultId, true))
                {
                    throw new RewardsDataAccessIdempotencyException(compGameResult.GameResult.GameResultId.ToString());
                }

                IRewardsQueueWriter queueWriter = Container.Instance.GetComponent<IRewardsQueueWriter>();
                GameEvent gameEvent = compGameResult.GameResult.ConvertToGameEvent(compGameResult.Xuid, uint.Parse(compGameResult.PlatformType), compGameResult.Locale);
                queueWriter.Write(gameEvent);
            }
            catch (RewardsDataAccessIdempotencyException ex)
            {
                // Log but otherwise absorb.
                RewardsEvents.Events.TraceEvent(RewardsEvents.IdempotencyFilterDuplicateError, ex.ToString());
            }
            catch (RewardsDataAccessException)
            {
                throw;
            }
            catch (GameResultConverterException ex)
            {
                throw new RewardsDataAccessValidationException("The CompositeGameResult passed is mis-constructed, check inner exception for more details", ex);
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessOperationException("Submitting a CompositeGameResult has failed, check inner exception for more detail", ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\GameResultValidator.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Gds.Contracts;
    using Gds.Services;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    public static class GameResultValidator
    {
        /// <summary>
        /// When validation fails, ArgumentException or a derived type will bubble up.
        /// When a GMS call fails for whatever reason, we do throw InvalidOperationException, 
        /// with the InnerException set to the actual exception
        /// </summary>
        /// <param name="gameResult"></param>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        public static void ValidatePostGameResult(GameResult gameResult, string locale, string platformType)
        {
            // a non-null game Result must exist.
            if (gameResult == null)
            {
                throw new ArgumentNullException("gameResult", "GameResult object not set to an instance");
            }
            else
            {
               Logging.TraceVerbose("GameResultValidator.ValidatePostGameResult GameId {0} | Variant | {1} | Score | {2}",
                        gameResult.GameId.ToString(),
                        gameResult.Variant.ToString(),
                        gameResult.Score.ToString());
            }

            ServiceParameterValidator.ValidateAgainstGmsBasic(gameResult.GameId, locale, platformType);

            // verify that the variant does exists.
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();
            GameVariantComposite gvc = gmsProxy.GetGameVariant(gameResult.GameId, gameResult.Variant);
            if (gvc == null)
            {
                throw new ArgumentException("Game does not have the variant specified");
            }
        }

        /// <summary>
        /// Validates also that the title being submitted is coming from the correct flow path.
        /// I.e. for MP games, MP service submits it. AND
        ///  for SP games, Rewards Service submits it.
        /// </summary>
        /// <param name="gameResult"></param>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="submissionMode"></param>
        public static void ValidatePostGameResult(GameResult gameResult, string locale, string platformType, GameResultSubmissionEnum submissionMode)
        {
            GameResultValidator.ValidatePostGameResult(gameResult, locale, platformType);

            // BUGfix: 5633 - We are removing the check for MP flags 
            // as its use for us as wether a game/variant is using SessionService is not valid.
#if CHECK_MP_FLAG
            // Validating the the data is coming from the correct channel.
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();
            GameMetadataComposite gmsComposite = gmsProxy.GetGameMetadata(gameResult.GameId, locale);
            
            switch (submissionMode)
            {
                case GameResultSubmissionEnum.MultiplayerServiceSubmission:
                    if (!gmsComposite.UsesLiveMultiplayerServices)
                    {
                        throw new ArgumentException("While the submission is coming from MP, the title is not an MP title");
                    }

                    break;

                case GameResultSubmissionEnum.RewardsServiceSubmission:
                    if (gmsComposite.UsesLiveMultiplayerServices)
                    {
                        throw new ArgumentException("While the submission is coming from Rewards, the title is an MP title");
                    }

                    break;

                default:
                    throw new ArgumentException("Wrong GameResultSubmissionEnum is specified");
            }
#endif // CHECK_MP_FLAG
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\IRewardsQueueReader.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Data.SqlClient;
    using System.Runtime.InteropServices;
    using Gds.Contracts;

    [ComVisible(false)]
    public interface IRewardsQueueReader 
    {
        GameEvent Read(TimeSpan timeout, ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction);
        GameEvent Read(TimeSpan timeout);
        GameEvent Read();
        void Commit(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction);
        void Rollback(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\IRewardsQueueWriter.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts;

    public interface IRewardsQueueWriter 
    {
        void Write(GameEvent gameEvent);

        void WriteToJail(GameEvent gameEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\ISubmitGameResult.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System.Collections.Generic;
    using Gds.Contracts;

    public interface ISubmitGameResult
    {
        void Submit(CompositeGameResult compGameResult, GameResultSubmissionEnum submissionMode);

        void SubmitBatch(IList<CompositeGameResult> listCompositeGameResult, GameResultSubmissionEnum submissionMode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\InMemoryBasicIdempotencyFilter.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Threading;

    /// <summary>
    /// Note: This is a simply in-memory, circular store of limited Id's. This does allow the catching of test or clients that create 
    ///       consistently identical Ids, that are expected to be Unique.
    ///       This class DOES NOT protect against multitute of other attack vectors where duplicate messages may creep up in the system.
    /// 
    /// Note: It is possible that 2 racing queries will end up Allowing the same Id; making one a false-negative.
    ///       we are NOT targeting to make a perfect solution, but an immediate, good-enough solution to catch prevent blatant disregards of 
    ///       violating the uniqueness requirement for whatever Id is tracked.
    ///       
    /// Note: The memory footprint of this object is trakingCount x sizeof(Guid) = 1000 x 16 = ~16k
    /// 
    /// Note: The Lookup time is O(n). But we do save time through reduced lock contention.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Idempotency")]
    public class InMemoryBasicIdempotencyFilter : IIdempotencyFilter
    {
        /// <summary>
        /// We treat this Id Invalid under any condition.
        /// </summary>
        private static readonly Guid InvalidId = Guid.Empty;

        /// <summary>
        /// How Many Ids we track.
        /// </summary>
        private const int TrackingCount = 1000;

        /// <summary>
        /// In this List we track the processed Ids.
        /// </summary>
        private static readonly List<Guid> listOfMarkedIds = new List<Guid>(TrackingCount);

        /// <summary>
        /// everytime we want to mark an Id, we simply bump out the oldest entry.
        /// </summary>
        private static int currentIndex = 0;

        /// <summary>
        /// Static Intializer to ensure the list is filled up w/ values.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily")]
        static InMemoryBasicIdempotencyFilter()
        {
            for (int i = 0; i < TrackingCount; i++)
            {
                listOfMarkedIds.Add(InvalidId);
            }
        }

        public bool IsProcessed(Guid id, bool mark)
        {
            if (id == Guid.Empty)
            {
                throw new RewardsDataAccessValidationException("Invalid Id is specified - as Guid.Empty");
            }

            // Step 1 - read through the list and figure out if any entry w/ given Id exists.
            if (InMemoryBasicIdempotencyFilter.listOfMarkedIds.Contains(id))
            {
                return true;
            }

            // Step 2 - the Id was not processed before, let's note it down to the last Oldes position.
            if (mark)
            {
                // Note: Interlocked.Increment does wrap the target number.
                // Note: The modulus operation is required otherwise we will be forced to re-set currentIndex outside an atomic operation
                //       Otherwise we create hard-to-fix race conditions.
                int swapIndex = Interlocked.Increment(ref InMemoryBasicIdempotencyFilter.currentIndex) % TrackingCount;
                listOfMarkedIds[swapIndex] = id;
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\RewardsDataAccessException.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Runtime.Serialization;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable")]
    public class RewardsDataAccessException : Exception
    {
        public RewardsDataAccessException()
            : base()
        {
        }

        public RewardsDataAccessException(string msg)
            : base(msg)
        { 
        }

        public RewardsDataAccessException(string msg, Exception innerException)
            : base(msg, innerException)
        {
        }

        protected RewardsDataAccessException(SerializationInfo info, StreamingContext context)
            : base(info, context) 
        {
        }
    }

    // Mimicks ArgumentException, with RewardsDataAccessException as the base class.
    public class RewardsDataAccessValidationException : RewardsDataAccessException
    {
        public RewardsDataAccessValidationException()
            : base()
        {
        }

        public RewardsDataAccessValidationException(string msg)
            : base(msg)
        {
        }

        public RewardsDataAccessValidationException(string msg, Exception innerException)
            : base(msg, innerException)
        {
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object,System.Object)")]
        public RewardsDataAccessValidationException(string argument, string msg)
            : base(string.Format("argument: {0} reason: {1}", argument, msg))
        {
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object,System.Object)")]
        public RewardsDataAccessValidationException(string argument, string msg, Exception innerException)
            : base(string.Format("argument: {0} reason: {1}", argument, msg), innerException)
        {
        }

        protected RewardsDataAccessValidationException(SerializationInfo info, StreamingContext context)
            : base(info, context) 
        {
        }
    }

    // Mimicks InvalidOperationException
    public class RewardsDataAccessOperationException : RewardsDataAccessException
    {
        public RewardsDataAccessOperationException()
            : base()
        {
        }

        public RewardsDataAccessOperationException(string msg)
            : base(msg)
        { 
        }

        public RewardsDataAccessOperationException(string msg, Exception innerException)
            : base(msg, innerException)
        {
        }

        protected RewardsDataAccessOperationException(SerializationInfo info, StreamingContext context)
            : base(info, context) 
        {
        }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Idempotency")]
    public class RewardsDataAccessIdempotencyException : RewardsDataAccessException
    {
        public RewardsDataAccessIdempotencyException()
            : base()
        {
        }

        public RewardsDataAccessIdempotencyException(string msg)
            : base(msg)
        {
        }

        public RewardsDataAccessIdempotencyException(string msg, Exception innerException)
            : base(msg, innerException)
        {
        }

        protected RewardsDataAccessIdempotencyException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\RewardsQueueWriter.cs ===
﻿
namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Data.SqlClient;
    using Gds.Contracts;
    using Gds.Contracts.Rewards;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using LIVEN.Common.Diagnostics;
    using Wgx.Common.ServiceBroker;

    public class RewardsQueueWriter : IRewardsQueueWriter
    {
        private object lockObject = new object();
        private string rewardsQueueMessageType;
        private string rewardsQueueContractName;
        private string rewardsTargetServiceName;
        private string rewardsTargetJailServiceName;

        public RewardsQueueWriter()
        {
            try
            {
                this.Initialize();
            }
            catch (RewardsDataAccessException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessException("RewardsQueueWriter initialization failed, check inner exception for more details", ex);
            }
        }

        private bool IsInitialized { get; set; }

        private BrokerDatabase BrokerDatabase { get; set; }

        private BrokerQueue BrokerQueue { get; set; }

        private BrokerQueue BrokerJailQueue { get; set; }

        private BrokerService BrokerService { get; set; }

        private BrokerService BrokerJailService { get; set; }

        public void Write(GameEvent gameEvent)
        {
            try
            {
                string strMessage = SerializerDeserializer.SerializeToString(gameEvent);

                using (SqlConnection sqlConnection = this.BrokerDatabase.GetOpenedConnection())
                {
                    BrokerContract brokerContract = this.BrokerService.GetContract(this.rewardsQueueContractName, StringComparison.OrdinalIgnoreCase);
                    Guid conversationHandle;

                    conversationHandle = this.BrokerService.CreateConversation(
                                                    this.rewardsTargetServiceName,
                                                    null,
                                                    brokerContract,
                                                    null,
                                                    TimeSpan.Zero,
                                                    false,
                                                    Guid.Empty,
                                                    sqlConnection);

                    using (BrokerConversation conv = this.BrokerService.GetConversation(conversationHandle))
                    {
                        conv.Send(RewardsQueueSettings.QueueEncoding.GetBytes(strMessage), this.rewardsQueueMessageType, sqlConnection);
                    }
                }
            }
            catch (SqlException ex)
            {
                RewardsEvents.Events.TraceEvent(RewardsEvents.SqlExceptionError);
                Logging.TraceException(ex, "RewardsQueueWriter");
                throw;
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessException("RewardsQueueWriter.Write(), check inner exception for more details", ex);
            }

        }

        public void WriteToJail(GameEvent gameEvent)
        {
            try
            {
                string strMessage = SerializerDeserializer.SerializeToString(gameEvent);

                using (SqlConnection sqlConnection = this.BrokerDatabase.GetOpenedConnection())
                {
                    BrokerContract brokerContract = this.BrokerJailService.GetContract(this.rewardsQueueContractName, StringComparison.OrdinalIgnoreCase);
                    Guid conversationHandle;

                    conversationHandle = this.BrokerJailService.CreateConversation(
                                                    this.rewardsTargetJailServiceName,
                                                    null,
                                                    brokerContract,
                                                    null,
                                                    TimeSpan.Zero,
                                                    false,
                                                    Guid.Empty,
                                                    sqlConnection);

                    using (BrokerConversation conv = this.BrokerJailService.GetConversation(conversationHandle))
                    {
                        conv.Send(RewardsQueueSettings.QueueEncoding.GetBytes(strMessage), this.rewardsQueueMessageType, sqlConnection);
                    }
                }
            }
            catch (SqlException ex)
            {
                RewardsEvents.Events.TraceEvent(RewardsEvents.SqlExceptionError);
                Logging.TraceException(ex, "RewardsQueueWriter");
                throw;
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessException("RewardsQueueWriter.WriteToJail(), check inner exception for more details", ex);
            }
        }

        private void Initialize()
        {
            if (!this.IsInitialized)
            {
                lock (this.lockObject)
                {
                    if (!this.IsInitialized)
                    {
                        this.UnsafeInitialize();
                        this.IsInitialized = true;
                    }
                }
            }
        }

        private void UnsafeInitialize()
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            string connectionString = configProvider.GetConnectionString(RewardsQueueSettings.DatabaseName);
            string initiatorQueueName = configProvider.GetSetting(Settings.RewardsService_Config_InitiatorQueue);
            string initiatorJailQueueName = configProvider.GetSetting(Settings.RewardsService_Config_InitiatorJailQueue);
            string initiatorServiceName = configProvider.GetSetting(Settings.RewardsService_Config_InitiatorService);
            string initiatorJailServiceName = configProvider.GetSetting(Settings.RewardsService_Config_InitiatorJailService);

            this.rewardsTargetServiceName = configProvider.GetSetting(Settings.RewardsService_Config_TargetService);
            this.rewardsTargetJailServiceName = configProvider.GetSetting(Settings.RewardsService_Config_TargetJailService);

            this.rewardsQueueMessageType = configProvider.GetSetting(Settings.RewardsService_Config_RequestMessageType);
            this.rewardsQueueContractName = configProvider.GetSetting(Settings.RewardsService_Config_ContractName);

            this.BrokerDatabase = new BrokerDatabase(connectionString);
            this.BrokerQueue = this.BrokerDatabase.GetQueue(initiatorQueueName, StringComparison.OrdinalIgnoreCase);
            this.BrokerJailQueue = this.BrokerDatabase.GetQueue(initiatorJailQueueName, StringComparison.OrdinalIgnoreCase);
            this.BrokerService = this.BrokerQueue.GetService(initiatorServiceName, StringComparison.OrdinalIgnoreCase);
            this.BrokerJailService = this.BrokerJailQueue.GetService(initiatorJailServiceName, StringComparison.OrdinalIgnoreCase);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.DataAccess.Rewards")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("Gds.DataAccess.Rewards")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e17dda86-6e80-440e-bffd-23532352f276")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards.Test\SubmitGameResultTest.cs ===
﻿namespace Gds.DataAccess.Rewards.Test
{
    using Gds.Mocks;
    using Leet.Core.IoCCo;
    using Leet.Utils;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using GameMetadata.Client;
    using Gds.Contracts;
    using System;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class SubmitGameResultTest
    {
        public SubmitGameResultTest()
        {
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        // You can use the following additional attributes as you write your tests:
        // Use ClassInitialize to run code before running the first test in the class
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext) 
        {
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<IRewardsQueueReader, InMemoryRewardsQueueReader>();
            Container.Instance.AddService<ISubmitGameResult, CSubmitGameResult>();
            Container.Instance.AddService<IIdempotencyFilter, InMemoryBasicIdempotencyFilter>();

            RewardsEvents.Initialize("gds_rewards");
        }

        // Use ClassCleanup to run code after all tests in a class have run
        [ClassCleanup()]
        public static void MyClassCleanup() { }

        // Use TestInitialize to run code before running each test 
        [TestInitialize()]
        public void MyTestInitialize() { }
        
        // Use TestCleanup to run code after each test has run
        [TestCleanup()]
        public void MyTestCleanup() { }

        [TestMethod]
        public void InitializeSubmitGameResult()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
        }

        [TestMethod]
        [ExpectedException(typeof(RewardsDataAccessValidationException))]
        public void SubmitNullCompositeGameResult()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            submitter.Submit(null, GameResultSubmissionEnum.RewardsServiceSubmission);
        }

        [TestMethod]
        public void SubmitValidGameResult()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            CompositeGameResult cgr = new CompositeGameResult()
            {
                GameResult = new GameResult()
                {
                    GameId = 7777,
                    Variant = 0,
                    GameResultId = Guid.NewGuid(),
                    Outcome = "win",
                    Score = 100,
                    TimeStamp = DateTime.UtcNow,
                },
                Locale = "en-US",
                PlatformType = "5",
                Xuid = 5
            };

            submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);

            GameEvent ge = Container.Instance.GetComponent<IRewardsQueueReader>().Read();
            Assert.IsTrue(ge != null);
        }

        [TestMethod]
        public void SubmitValidGameResultWithOutcomeNone()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            CompositeGameResult cgr = new CompositeGameResult()
            {
                GameResult = new GameResult()
                {
                    GameId = 7777,
                    Variant = 0,
                    GameResultId = Guid.NewGuid(),
                    Outcome = "None",
                    Score = 100,
                    TimeStamp = DateTime.UtcNow,
                },
                Locale = "en-US",
                PlatformType = "5",
                Xuid = 5
            };

            submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);

            GameEvent ge = Container.Instance.GetComponent<IRewardsQueueReader>().Read();
            Assert.IsTrue(ge != null);
        }

        [TestMethod]
        [ExpectedException(typeof(RewardsDataAccessValidationException))]
        public void SubmitNullGameResult()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            CompositeGameResult cgr = new CompositeGameResult()
            {
                GameResult = null,
                Locale = "en-US",
                PlatformType = "5",
                Xuid = 5
            };

            submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);
        }

        [TestMethod]
        [ExpectedException(typeof(RewardsDataAccessValidationException))]
        public void SubmitValidGameResultWithEmptyResultId()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            CompositeGameResult cgr = new CompositeGameResult()
            {
                GameResult = new GameResult()
                {
                    GameId = 7777,
                    Variant = 0,
                    GameResultId = Guid.Empty,
                    Outcome = "None",
                    Score = 100,
                    TimeStamp = DateTime.UtcNow,
                },
                Locale = "en-US",
                PlatformType = "5",
                Xuid = 5
            };

            submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);

            GameEvent ge = Container.Instance.GetComponent<IRewardsQueueReader>().Read();
            Assert.IsTrue(ge != null);
        }

        [TestMethod]
        public void SubmitValidGameResultTriggerIdempotency()
        {
            ISubmitGameResult submitter = Container.Instance.GetComponent<ISubmitGameResult>();
            CompositeGameResult cgr = new CompositeGameResult()
            {
                GameResult = new GameResult()
                {
                    GameId = 7777,
                    Variant = 0,
                    GameResultId = Guid.NewGuid(),
                    Outcome = "None",
                    Score = 100,
                    TimeStamp = DateTime.UtcNow,
                },
                Locale = "en-US",
                PlatformType = "5",
                Xuid = 5
            };

            submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);

            // try submitting an identical result, many times.
            for (int i = 0; i < 5000; i++)
            {
                CompositeGameResult cgr2 = new CompositeGameResult()
                {
                    GameResult = cgr.GameResult,
                    Locale = "en-US",
                    PlatformType = "5",
                    Xuid = 5
                };

                submitter.Submit(cgr, GameResultSubmissionEnum.MultiplayerServiceSubmission);
            }

            // there must be only 1 message
            GameEvent ge = Container.Instance.GetComponent<IRewardsQueueReader>().Read();
            Assert.IsTrue(ge != null);

            ge = Container.Instance.GetComponent<IRewardsQueueReader>().Read();
            Assert.IsTrue(ge == null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards\RewardsQueueReader.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using Gds.Contracts;
    using Gds.Contracts.Rewards;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Wgx.Common.ServiceBroker;

    public class RewardsQueueReader : IRewardsQueueReader
    {
        public const int DefaultFetchSize = 1;

        private string rewardsQueueMessageType;

        private object lockObject = new object();

        public RewardsQueueReader()
        {
            try
            {
                this.Initialize();
            }
            catch (RewardsDataAccessException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessException("RewardsQueueReader initialization faild, check inner exception for more details", ex);
            }
        }

        private bool IsInitialized { get; set; }

        private BrokerDatabase BrokerDatabase { get; set; }

        private BrokerQueue BrokerQueue { get; set; }

        private BrokerService BrokerService { get; set; }

        [ThreadStatic]
        private static ICollection<BrokerMessage> currentMessageList = null;

        public GameEvent Read(TimeSpan timeout, ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction)
        {
            sqlConnection = this.BrokerDatabase.GetOpenedConnection();
            sqlTransaction = sqlConnection.BeginTransaction();

            try
            {
                currentMessageList = this.BrokerService.ReceiveMessage(timeout, RewardsQueueReader.DefaultFetchSize, sqlConnection, sqlTransaction);

                foreach (BrokerMessage message in currentMessageList)
                {
                    if (string.Equals(message.MessageType, this.rewardsQueueMessageType, StringComparison.Ordinal))
                    {
                        byte[] buffer = message.GetBody();

                        string gameEventString = RewardsQueueSettings.QueueEncoding.GetString(buffer);

                        GameEvent ge = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEventString, typeof(GameEvent));

                        return ge;
                    }
                }
            }
            catch (BusinessObjectsValidationException ex)
            {
                throw new RewardsDataAccessOperationException("Deserialization failed", ex);
            }

            return null;
        }

        public GameEvent Read(TimeSpan timeout)
        {
            try
            {
                using (SqlConnection sqlConnection = this.BrokerDatabase.GetOpenedConnection())
                {
                    ICollection<BrokerMessage> messageList = this.BrokerService.ReceiveMessage(timeout, RewardsQueueReader.DefaultFetchSize, sqlConnection);

                    foreach (BrokerMessage message in messageList)
                    {
                        if (string.Equals(message.MessageType, this.rewardsQueueMessageType, StringComparison.Ordinal))
                        {
                            byte[] buffer = message.GetBody();

                            string gameEventString = RewardsQueueSettings.QueueEncoding.GetString(buffer);

                            GameEvent ge = (GameEvent)SerializerDeserializer.DeserializeFromString(gameEventString, typeof(GameEvent));

                            return ge;
                        }
                    }
                }
            }
            catch (RewardsDataAccessException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new RewardsDataAccessOperationException("RewardsQueueReader initialization faild, check inner exception for more details", ex);
            }

            return null;
        }

        public GameEvent Read()
        {
            return this.Read(TimeSpan.MaxValue);
        }

        public void Commit(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction)
        {
            if (sqlTransaction != null)
            {
                sqlTransaction.Commit();
                sqlTransaction = null;
            }

            if (sqlConnection != null)
            {
                sqlConnection.Close();
                sqlConnection = null;
            }

            // Ensure messages are disposed
            // What matters is that we close the conversationHandle after the commit operation.
            if (currentMessageList != null)
            {
                foreach (BrokerMessage message in currentMessageList)
                {
                    // only dispose if it is an actual message, all other message tyes are simply conversation end messages.
                    // by which time we ought to have closed the handle.
                    if (string.Equals(message.MessageType, this.rewardsQueueMessageType, StringComparison.Ordinal))
                    {
                        message.Close(true);
                    }
                }

                currentMessageList = null;
            }
        }

        public void Rollback(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction)
        {
            if (sqlTransaction != null)
            {
                sqlTransaction.Rollback();
                sqlTransaction = null;
            }

            if (sqlConnection != null)
            {
                sqlConnection.Close();
                sqlConnection = null;
            }

            // no dispose necessary.
            currentMessageList = null;
        }

        private void Initialize()
        {
            if (!this.IsInitialized)
            {
                lock (this.lockObject)
                {
                    if (!this.IsInitialized)
                    {
                        this.UnsafeInitialize();
                        this.IsInitialized = true;
                    }
                }
            }
        }

        private void UnsafeInitialize()
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            string connectionString = configProvider.GetConnectionString(RewardsQueueSettings.DatabaseName);

            string targetQueueName = configProvider.GetSetting(Settings.RewardsService_Config_TargetQueue);
            string targetServiceName = configProvider.GetSetting(Settings.RewardsService_Config_TargetService);

            this.rewardsQueueMessageType = configProvider.GetSetting(Settings.RewardsService_Config_RequestMessageType);

            this.BrokerDatabase = new BrokerDatabase(connectionString);
            this.BrokerQueue = this.BrokerDatabase.GetQueue(targetQueueName, StringComparison.OrdinalIgnoreCase);
            this.BrokerService = this.BrokerQueue.GetService(targetServiceName, StringComparison.OrdinalIgnoreCase);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\RulesStorage.cs ===
﻿

namespace Gds.DataAccess.Rules
{
    using System;
    using System.Collections.Generic;
    using System.Data.Linq;
    using System.Data.SqlClient;
    using System.Linq;
    using System.Threading;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// RulesStorage class that implemetns IRulesStorage
    /// </summary>
    public class RulesStorage : IRulesStorage
    {
        /// <summary>
        /// Component name of RulesStorage
        /// </summary>
        public const string ComponentName = "RulesStorage";

        /// <summary>
        /// RulesStorageConnection string
        /// </summary>
        private const string RulesStorageConnectionConfigName = "lest_rewards_db";

        /// <summary>
        /// Number of SQL retries per operation
        /// </summary>
        private const int NumRetries = 3;

        /// <summary>
        /// Initializes a new instance of the RulesStorage class
        /// </summary>
        public RulesStorage()
        {
            string rulesDataStoreConnectionString = Container.Instance.GetComponent<IConfigurationProvider>().GetConnectionString(RulesStorage.RulesStorageConnectionConfigName);
            this.RulesStorageDataContext = new RulesStoreDataContext(rulesDataStoreConnectionString);
        }

        /// <summary>
        /// Gets or sets RulesStorageDataContext
        /// </summary>
        private RulesStoreDataContext RulesStorageDataContext { get; set; }

        /// <summary>
        /// Returns a list of rules based on gameId; gameId=0 will return all rules
        /// </summary>
        /// <param name="gameId">game identifier</param>
        /// <returns>A list of rules</returns>
        public IList<Rule> GetRules(int gameId)
        {
            int retries = NumRetries;
            int? errCode = 0;
            string errMsg = null;

            ISingleResult<p_GetRulesResult> rulesResult = null;

            unchecked
            {
                do
                {
                   try
                    {
                        rulesResult = this.RulesStorageDataContext.p_GetRules(gameId, ref errCode, ref errMsg);
                        break;
                    }
                    catch (SqlException ex)
                    {
                        if (retries == 0)
                        {
                            throw;
                        }
                        else
                        {
                            Logging.TraceException(ex,"{0} Caught exception in RulesStorageDataContext.p_GetRules()",
                                ComponentName);

                            Logging.TraceError("{0} GetRules from database failed. Retrying after 30 seconds. Retries left: {1}",
                                ComponentName,
                                retries - 1);

                              Thread.Sleep(30000);
                        }
                    }
                } 
                while (retries-- > 0);
            }

            if (errCode == 0)
            {
                var rulesCollection = from rr in rulesResult
                                     select new Rule
                                     {
                                         RuleId = rr.RuleID,
                                         GameKeys = rr.GameKeys,
                                         DTStart = rr.DTStart,
                                         RuleStatement = rr.RuleStatement,
                                         ActionSet = rr.ActionSet
                                     };

                IList<Rule> ruleList = rulesCollection.ToList();

                return ruleList;
            }

            return null;
        }

        /// <summary>
        /// Returns config value from the datastore
        /// </summary>
        /// <param name="configName">Name of the configuration</param>
        /// <returns>Configurate object</returns>
        public object GetConfigValue(string configName)
        {
            int retries = NumRetries;
            int? errCode = 0;
            string errMsg = null;
            ISingleResult<p_GetConfigValueResult> configValueResult = null;

            unchecked
            {
                do
                {
                    try
                    {
                        configValueResult = this.RulesStorageDataContext.p_GetConfigValue(configName, ref errCode, ref errMsg);
                        break;
                    }
                    catch (SqlException)
                    {
                        if (retries == 0)
                        {
                            throw;
                        }
                        else
                        {
                            Logging.TraceError("{0} GetConfigValue from database failed. Retrying after 30 seconds. Retries left: {1}",
                                ComponentName,
                                retries - 1);

                            Thread.Sleep(30000);
                        }
                    }
                } 
                while (retries-- > 0);
            }

            if (errCode == 0 && configValueResult != null)
            {
                return configValueResult.First().Value;
            }

            return null;
        }

        /// <summary>
        /// Disposes object
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Disposes object
        /// </summary>
        /// <param name="isDisposing">Whether it is disposing</param>
        private void Dispose(bool isDisposing)
        {
            if (isDisposing)
            {
                this.RulesStorageDataContext.Dispose();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\IRulesStorage.cs ===
﻿
namespace Gds.DataAccess.Rules
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Interface for RulesStorage
    /// </summary>
    public interface IRulesStorage : IDisposable
    {
        /// <summary>
        /// Returns a list of rules based on gameId; gameId=0 will return all rules
        /// </summary>
        /// <param name="gameId">game identifier</param>
        /// <returns>A list of rules</returns>
        IList<Rule> GetRules(int gameId);

        /// <summary>
        /// Returns config value from the datastore
        /// </summary>
        /// <param name="configName">Name of the configuration</param>
        /// <returns>Configurate object</returns>
        object GetConfigValue(string configName);
    }

    /// <summary>
    /// Rule object
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
    public struct Rule
    {
        /// <summary>
        /// Rule identifier
        /// </summary>
        public int RuleId { get; set; }

        /// <summary>
        /// List of game keys
        /// </summary> 
        public string GameKeys {get; set;}

        /// <summary>
        /// Date of when the rules can start to be evaluated
        /// </summary>
        public DateTime DTStart { get; set; }

        /// <summary>
        /// Xml string of the rule statement
        /// </summary>
        public string RuleStatement { get; set; }

        /// <summary>
        /// Xml sting of the action set
        /// </summary>
        public string ActionSet { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rewards.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.DataAccess.Rewards.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("Gds.DataAccess.Rewards.Test")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a386d3c4-8497-4532-b27b-e68f220bde9b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\RulesStore.designer.cs ===
﻿#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Gds.DataAccess.Rules
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="RewardsDB")]
	public partial class RulesStoreDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    #endregion
		
		public RulesStoreDataContext() : 
				base(global::Gds.DataAccess.Rules.Properties.Settings.Default.RewardsDBConnectionString, mappingSource)
		{
			OnCreated();
		}
		
		public RulesStoreDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public RulesStoreDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public RulesStoreDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public RulesStoreDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		[Function(Name="GDSS.p_GetRules")]
		public ISingleResult<p_GetRulesResult> p_GetRules([Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(256)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), gameID, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(1)));
			errMsg = ((string)(result.GetParameterValue(2)));
			return ((ISingleResult<p_GetRulesResult>)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.p_GetConfigValue")]
		public ISingleResult<p_GetConfigValueResult> p_GetConfigValue([Parameter(Name="Name", DbType="VarChar(40)")] string name, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(256)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), name, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(1)));
			errMsg = ((string)(result.GetParameterValue(2)));
			return ((ISingleResult<p_GetConfigValueResult>)(result.ReturnValue));
		}
	}
	
	public partial class p_GetRulesResult
	{
		
		private int _RuleID;
		
		private string _GameKeys;
		
		private System.DateTime _DTStart;
		
		private string _RuleStatement;
		
		private string _ActionSet;
		
		public p_GetRulesResult()
		{
		}
		
		[Column(Storage="_RuleID", DbType="Int NOT NULL")]
		public int RuleID
		{
			get
			{
				return this._RuleID;
			}
			set
			{
				if ((this._RuleID != value))
				{
					this._RuleID = value;
				}
			}
		}
		
		[Column(Storage="_GameKeys", DbType="NVarChar(MAX)")]
		public string GameKeys
		{
			get
			{
				return this._GameKeys;
			}
			set
			{
				if ((this._GameKeys != value))
				{
					this._GameKeys = value;
				}
			}
		}
		
		[Column(Storage="_DTStart", DbType="DateTime NOT NULL")]
		public System.DateTime DTStart
		{
			get
			{
				return this._DTStart;
			}
			set
			{
				if ((this._DTStart != value))
				{
					this._DTStart = value;
				}
			}
		}
		
		[Column(Storage="_RuleStatement", DbType="NVarChar(MAX)")]
		public string RuleStatement
		{
			get
			{
				return this._RuleStatement;
			}
			set
			{
				if ((this._RuleStatement != value))
				{
					this._RuleStatement = value;
				}
			}
		}
		
		[Column(Storage="_ActionSet", DbType="NVarChar(MAX)")]
		public string ActionSet
		{
			get
			{
				return this._ActionSet;
			}
			set
			{
				if ((this._ActionSet != value))
				{
					this._ActionSet = value;
				}
			}
		}
	}
	
	public partial class p_GetConfigValueResult
	{
		
		private string _Value;
		
		public p_GetConfigValueResult()
		{
		}
		
		[Column(Storage="_Value", DbType="NVarChar(MAX)")]
		public string Value
		{
			get
			{
				return this._Value;
			}
			set
			{
				if ((this._Value != value))
				{
					this._Value = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "GDS", Scope = "namespace", Target = "GDS.DataAccess.UserData")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "GDS")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\IUserProfileStorage.cs ===
﻿namespace Gds.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using GDS.DataAccess.UserData;

    public interface IUserProfileStorage 
    {
        Guid InsertBlob(byte[] blob, DateTime dateUpdated);

        int UpdateBlob(Guid blobId, byte[] blob, DateTime dateUpdated);

        byte[] GetBlob(Guid blobId, ref DateTime dtUpdated, ref DateTime dtCreated);

        void DeleteBlob(Guid blobId);

        UserStatsEx GetStatisticEntry(ulong xuid, uint gameId, uint variant, uint dataGroup);

        int InsertOrUpdateStatForUser(UserStatsEx row);

        IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, uint dataGroup, IList<ulong> xuidList, string baseProperty);

        IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, uint dataGroup, IList<ulong> xuidList, string baseProperty, IDictionary<string, IUserStorageConverterFilter> converterList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Gds.DataAccess.Rules.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=SCHAU-VM01;Initial Catalog=RewardsDB;Integrated Security=True")]
        public string RewardsDBConnectionString {
            get {
                return ((string)(this["RewardsDBConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.DataAccess.Rules\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.DataAccess.Rules")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("abb26416-7bcd-45eb-9a01-dd428ee31512")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\IUserDataStorage.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using Gds.Contracts;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
    public enum UserDataOperationEnum
    {
        None = 0,
        SumProperty = 1,
        MaxProperty = 2,
        MinProperty = 3
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
    public struct UserDataError
    {
        public const int SuccessCode = 0;

        public uint ErrorCode { get; set; }

        public string ErrorMessage { get; set; }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
    public struct GameData
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public uint GameId;
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public DateTime LastPlayedDateTime;
    }

    public class StatsResult
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public ulong Xuid { get; set;  }
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
        public IList<Entry> Statistics { get; set; }
    }

    [ComVisible(false)]
    public interface IUserDataStorage : IDisposable
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Property")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        UserStat GetStatisticEntry(ulong xuid, uint gameId, uint variant, string property, uint dataGroup);

        Guid? InsertBlob(byte[] blob, DateTime dateUpdated);

        UserDataError UpdateBlob(Guid blobId, byte[] blob, DateTime dateUpdated);

        byte[] GetBlob(Guid blobId);

        UserDataError DeleteBlob(Guid blobId);

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "12#")]
        UserDataError OperateOnUserStatValueLong(
                                    UserDataOperationEnum userDataOperation,
                                    ulong xuid,
                                    uint platformId,
                                    uint gameId,
                                    uint variant,
                                    string propertyName,
                                    uint dataGroup,
                                    long value,
                                    Guid gameEventId,
                                    Guid gameSessionId,
                                    Guid? blobId,
                                    DateTime dateUpdated,
                                    ref long newValue);

        /// <summary>
        /// In a bizare twist, we require a List and not a IList,
        /// List has Linq 2 SQL support, where as IList does not. Go figure.
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="variantId"></param>
        /// <param name="property"></param>
        /// <param name="xuidList"></param>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Property")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuids")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, string property, uint dataGroup, List<long> xuidList);

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Property")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuids")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, string property, uint dataGroup, List<long> xuidList, IDictionary<string, IUserStorageConverterFilter> converterList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\IUserStorageConverterFilter.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using Gds.Contracts;

    public interface IUserStorageConverterFilter
    {
        string PropertyKey { get; set; }
        string AliasName { get; set; }
        bool IsRemoved { get; set; }

        Entry Process(string name, string value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\IUserProfileStorageSimple.cs ===
﻿// <copyright file="IUserProfileStorageSimple.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-06-07</date>
// <summary>Contains the interface definition for a simple user profile storage.</summary>

namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using GameMetadata.Common;

    /// <summary>
    /// Models a simple user profile storage provider.
    /// </summary>
    public interface IUserProfileStorageSimple
    {
        /// <summary>
        /// Gets the leaderboard blob.
        /// </summary>
        /// <param name="blobId">The blobId for which to get the blob.</param>
        /// <returns>The leaderboard blob.</returns>
        byte[] GetBlob(Guid blobId);

        /// <summary>
        /// Gets the leaderboard stats for a set of Xbox Ids.
        /// </summary>
        /// <param name="gameId">The title for which to get the stats.</param>
        /// <param name="variant">The game variant for which to get the stats.</param>
        /// <param name="dataGroupName">The datagroup for which to get the stats.</param>
        /// <param name="xuidList">The set of Xuids for which to get the stats.</param>
        /// <param name="property">The property for which to get the stats.</param>
        /// <param name="callingXuid">The xuid of the user on behalf of which the call is being made.</param>
        /// <param name="statRanking">The stat ranking for the property.</param>
        /// <returns>The leaderboard stats for the set of Xbox Ids.</returns>
        IList<StatsResult> GetStatsForXuids(
            uint gameId, uint variant, string dataGroupName, List<ulong> xuidList, string property, ulong callingXuid, StatRanking statRanking);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\ScatterGatherManager.cs ===
﻿namespace Gds.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using System.Threading;

    public class ScatterGatherManager
    {
        internal int OutstandingTaskCount = 0;

        // Due to limitations on WaitAll, must be "chunked" in sets of 64 or fewer waithandles
        private const int MaxAllowedNumberOfScattering = 64;
        private const int DefaultMaxNumberOfScattering = 20;
        private const bool DefaultFailOnAnyErrorPolicy = true;

        private static int maxNumberOfScatteringAllowed = DefaultMaxNumberOfScattering;
        private static bool failOnAnyErrorPolicy = ScatterGatherManager.DefaultFailOnAnyErrorPolicy;

        private int openHandleCount = 0;

        private int numberOfScatter = MaxNumberOfScatter;

        public ScatterGatherManager(int numberOfScatter, bool failOnError)
        {
            this.NumberOfScatter = numberOfScatter;
            this.FailOnError = failOnError;
        }

        public static int MaxNumberOfScatter
        {
            get
            {
                return maxNumberOfScatteringAllowed;
            }

            set
            {
                if (value > ScatterGatherManager.MaxAllowedNumberOfScattering)
                {
                    throw new ArgumentOutOfRangeException("You can't generate more than max default allowed number of gathering threads");
                }

                maxNumberOfScatteringAllowed = value;
            }
        }

        public static bool FailOnAnyError
        {
            get
            {
                return failOnAnyErrorPolicy;
            }

            set
            {
                failOnAnyErrorPolicy = value;
            }
        }

        public int NumberOfScatter
        {
            get
            {
                return this.numberOfScatter;
            }

            set
            {
                if (value > MaxNumberOfScatter)
                {
                    this.numberOfScatter = MaxNumberOfScatter;
                }

                this.numberOfScatter = value;
            }
        }

        public bool FailOnError { get; set; }

        private object PendingTaskList { get; set; }

        private List<WaitHandle> WaitHandleList { get; set; }

        private object FinishedTaskList { get; set; }

        public List<TScatterGatherTask> ExecuteParallel<TScatterGatherTask, TTaskContext, TResult>(List<TTaskContext> contextList)
            where TScatterGatherTask : ScatterGatherTask<TTaskContext, TResult>, new()
        {
            ValidateThread();


            // No need to process anything thing, because we weren't sent anything
            if (contextList == null)
            {
                return new List<TScatterGatherTask>(0);
            }

            int taskCount = contextList.Count;

            List<TScatterGatherTask> taskList = new List<TScatterGatherTask>(taskCount);

            if (taskCount == 0)
            {
                return taskList;
            }

            this.PendingTaskList = (object)taskList;

            List<WaitHandle> waitHandleList = new List<WaitHandle>(taskCount);
            this.WaitHandleList = waitHandleList;

            int taskIndex = 0;

            // Initialize TaskList and appropriate wait events.
            foreach (TTaskContext context in contextList)
            {
                Interlocked.Increment(ref this.openHandleCount);
                ManualResetEvent manualResetEvent = new ManualResetEvent(false);
                waitHandleList.Add(manualResetEvent);
                TScatterGatherTask scatterTask = new TScatterGatherTask();
                scatterTask.SetData(context, taskIndex++, manualResetEvent, this);
                taskList.Add(scatterTask);
            }

            TScatterGatherTask[] finishedTaskList = new TScatterGatherTask[taskCount];
            this.FinishedTaskList = (object)finishedTaskList;

            int availableScatterQuota = ScatterGatherManager.MaxNumberOfScatter;

            try
            {
                while (waitHandleList.Count > 0)
                {
                    for (int i = 0; i < availableScatterQuota && i < taskList.Count; i++)
                    {
                        // if a task is Not done and Not scheduled operate on it.
                        if (!taskList[i].IsScheduled && !taskList[i].Done)
                        {
                            taskList[i].IsScheduled = true;
                            Interlocked.Increment(ref this.OutstandingTaskCount);
                            ThreadPool.QueueUserWorkItem(taskList[i].ThreadPoolCallback, null);
                        }
                        else
                        {
                            // we have an uncleaned operation, simply bump up the quota to hide this fact AND try the next task in the list
                            // the subsequent WaitAny and CleanUp section will clean completed tasks up, 
                            // it may take multiple loops to achieve this.
                            availableScatterQuota++;
                        }
                    }

                    availableScatterQuota = 0;

                    int completedIndex = WaitHandle.WaitAny(GetWaitArray(waitHandleList));

                    availableScatterQuota += this.CleanUpTasksAndSaveResults<TScatterGatherTask, TTaskContext, TResult>(completedIndex);
                }
            }
            finally
            {
                // Ensure that there are no more pending tasks
                this.StopTasksAndWait<TScatterGatherTask, TTaskContext, TResult>();

                // Ensure we dispose all wait handles appropriately
                foreach (TScatterGatherTask unfinishedTask in taskList)
                {
                    Interlocked.Decrement(ref this.openHandleCount);
                    unfinishedTask.DoneEvent.Close();
                }

                for (int i = 0; i < finishedTaskList.Length; i++)
                {
                    if (finishedTaskList[i] != null)
                    {
                        Interlocked.Decrement(ref this.openHandleCount);
                        finishedTaskList[i].DoneEvent.Close();
                    }
                }
            }

            if (this.openHandleCount != 0)
            {
                throw new InvalidOperationException();
            }

            return finishedTaskList.ToList();
        }

        /// <summary>
        /// Cleans up completed tasks from the pendingTaskList and cleans the WaitHandle List, and 
        /// returns the count of completed tasks
        /// </summary>
        /// <typeparam name="TScatterGatherTask"></typeparam>
        /// <typeparam name="TTaskContext"></typeparam>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="completedIndex"></param>
        /// <returns></returns>
        public void StopTasksAndWait<TScatterGatherTask, TTaskContext, TResult>()
            where TScatterGatherTask : ScatterGatherTask<TTaskContext, TResult>, new()
        {
            int scheduledTaskCount = 0;
            foreach (TScatterGatherTask pendingTask in (List<TScatterGatherTask>)this.PendingTaskList)
            {
                pendingTask.Stop = true;
                if (pendingTask.IsScheduled)
                {
                    scheduledTaskCount++;
                }
            }

            if (scheduledTaskCount > 0)
            {
                WaitHandle[] scheduledTaskWaits = new WaitHandle[scheduledTaskCount];
                
                scheduledTaskCount = 0;
                foreach (TScatterGatherTask pendingTask in (List<TScatterGatherTask>)this.PendingTaskList)
                {
                    if (pendingTask.IsScheduled)
                    {
                        scheduledTaskWaits[scheduledTaskCount++] = pendingTask.DoneEvent;
                    }
                }

                WaitHandle.WaitAll(scheduledTaskWaits);
            }

            // we are still racing, spin until outstanding tasks have completed.
            while (this.OutstandingTaskCount != 0)
            {
                Thread.SpinWait(1);
            }
        }

        private static WaitHandle[] GetWaitArray(List<WaitHandle> waitList)
        {
            int count = waitList.Count < MaxNumberOfScatter ? waitList.Count : MaxNumberOfScatter;
            return waitList.GetRange(0, count).ToArray();
        }

        private static void ValidateThread()
        {
            if (Thread.CurrentThread.GetApartmentState() == ApartmentState.STA)
            {
                throw new InvalidOperationException("We do not support this operation on STA threads");
            }
        }

        private int CleanUpTasksAndSaveResults<TScatterGatherTask, TTaskContext, TResult>(int completedIndex)
            where TScatterGatherTask : ScatterGatherTask<TTaskContext, TResult>, new()
        {
            int completedTaskCount = 0;
            List<WaitHandle> waitHandleList = this.WaitHandleList;
            List<TScatterGatherTask> pendingTaskList = (List<TScatterGatherTask>)this.PendingTaskList;
            TScatterGatherTask[] finishedTaskList = (TScatterGatherTask[])this.FinishedTaskList;

            // figure out which thread(s) completed, 
            // 1- update pending operations
            // 2- make sure taskList only contains remaining tasks.
            // 3- move finished tasks to the finishedTaskList in the appropriate position.
            // 4- increment available quota
            int taskRelativeIndex = 0;
            List<int> indexesOfCompletedTasks = new List<int>(pendingTaskList.Count);

            // do a single-pass
            // it is entirely possible that more tasks may finish during this operation.
            // and we intentionally don't care 
            foreach (TScatterGatherTask pendingTask in pendingTaskList)
            {
                if (pendingTask.Done)
                {
                    indexesOfCompletedTasks.Add(taskRelativeIndex);
                }

                taskRelativeIndex++;
            }

            // it is possible that our detection failed to detect the signaled event.
            if (!indexesOfCompletedTasks.Contains(completedIndex))
            {
                int indexOfIndexFound = 0;
                foreach (int completedTaskIndex in indexesOfCompletedTasks)
                {
                    if (completedTaskIndex > completedIndex)
                    {
                        indexesOfCompletedTasks.Insert(indexOfIndexFound - 1, completedIndex);
                    }

                    indexOfIndexFound++;
                }
            }

            // start from the end, and move backwards, 
            // this way the relativeIndexes will always be accurate relative to the modified List.
            indexesOfCompletedTasks.Reverse();

            foreach (int relativeTaskIndex in indexesOfCompletedTasks)
            {
                waitHandleList.RemoveAt(relativeTaskIndex);
                TScatterGatherTask completedTask = pendingTaskList[relativeTaskIndex];

                if (!completedTask.Done)
                {
                    throw new InvalidOperationException();
                }

                // If we are asked to fail on Any error, 
                // Then check if there is an error, and throw if any.
                if (this.FailOnError && completedTask.Error != null)
                {
                    throw completedTask.Error;
                }

                finishedTaskList[completedTask.TaskIndex] = completedTask;
                pendingTaskList.RemoveAt(relativeTaskIndex);
                completedTaskCount++;
            }

            return completedTaskCount;
        }
    }

    public abstract class ScatterGatherTask<TTaskContext, TResult>
    {
        private TResult result;

        /// <summary>
        /// Has the Result object, Throws if there was an error.
        /// </summary>
        public TResult Result 
        {
            get
            {
                if (this.Error != null)
                {
                    throw this.Error;
                }

                return this.result;
            }

            private set
            {
                this.result = value;
            }
        }

        public TTaskContext Context { get; private set; }
       
        /// <summary>
        /// Has an Exception, if the task has thrown any exception
        /// </summary>
        public Exception Error { get; private set; }

        public bool Stop { get; internal set; }

        public bool Done { get; private set; }
        
        internal ManualResetEvent DoneEvent { get; private set; }

        internal int TaskIndex { get; private set; }

        internal bool IsScheduled { get; set; }
        
        private ScatterGatherManager ScatterGatherManager { get; set; }

        public abstract TResult Execute(TTaskContext input);

        internal void SetData(TTaskContext input, int index, ManualResetEvent doneEvent, ScatterGatherManager sgm)
        {
            this.TaskIndex = index;
            this.DoneEvent = doneEvent;
            this.Context = input;
            this.ScatterGatherManager = sgm;
        }

        internal void ThreadPoolCallback(object threadContext)
        {
            try
            {
                if (!this.Stop)
                {
                    this.Result = this.Execute(this.Context);
                }
            }
            catch (Exception ex)
            {
                this.Error = ex;
            }
            finally
            {
                try
                {
                    this.Done = true;
                    this.DoneEvent.Set();

                    Thread.MemoryBarrier();
                }
                catch (ObjectDisposedException)
                {
                    // Absorb this error and return. Otherwise the app will crash.
#if DBG
                    // TODO LOG this state.
                    this.DumpString();
#endif
                }

                this.IsScheduled = false;
                Interlocked.Decrement(ref this.ScatterGatherManager.OutstandingTaskCount);
            }
        }

        /// <summary>
        /// Executes the specified input.
        /// Consumers needs to overload and create an instance.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns></returns>
#if DBG
        private string DumpString()
        {
            StringBuilder sb = new StringBuilder(1024);
            sb.AppendFormat("Context is {0}\n", this.Context.ToString());
            sb.AppendFormat("DoneEvent handle is {0}\n", this.DoneEvent.SafeWaitHandle.DangerousGetHandle().ToInt64());
            sb.AppendFormat("DoneEvent handle is closed: {0}\n", this.DoneEvent.SafeWaitHandle.IsClosed);
            sb.AppendFormat("DoneEvent handle is invalid: {0}\n", this.DoneEvent.SafeWaitHandle.IsInvalid);
            
            sb.AppendFormat("TaskIndex: {0}\n", this.TaskIndex);
            sb.AppendFormat("Stopped: {0}\n", this.Stop);
            sb.AppendFormat("Done: {0}\n", this.Done);
            sb.AppendFormat("IsScheduled: {0}\n", this.IsScheduled);
            return sb.ToString();
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserDataStore.designer.cs ===
﻿#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GDS.DataAccess.UserData
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="UserProfile")]
	public partial class UserDataStoreDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void InsertStatBlob(StatBlob instance);
    partial void UpdateStatBlob(StatBlob instance);
    partial void DeleteStatBlob(StatBlob instance);
    #endregion
		
		public UserDataStoreDataContext() : 
				base(global::GDS.DataAccess.UserData.Properties.Settings.Default.UserProfileConnectionString, mappingSource)
		{
			OnCreated();
		}
		
		public UserDataStoreDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public UserDataStoreDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public UserDataStoreDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public UserDataStoreDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<StatBlob> StatBlobs
		{
			get
			{
				return this.GetTable<StatBlob>();
			}
		}
		
		public System.Data.Linq.Table<UserStat> UserStats
		{
			get
			{
				return this.GetTable<UserStat>();
			}
		}
		
		[Function(Name="GDSS.proc_GetDataBlob")]
		public int proc_GetDataBlob([Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] ref System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="DTCreated", DbType="DateTime")] ref System.Nullable<System.DateTime> dTCreated, [Parameter(Name="Blob", DbType="VarBinary(MAX)")] ref System.Data.Linq.Binary blob, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), blobID, dTUpdated, dTCreated, blob, errCode, errMsg);
			dTUpdated = ((System.Nullable<System.DateTime>)(result.GetParameterValue(1)));
			dTCreated = ((System.Nullable<System.DateTime>)(result.GetParameterValue(2)));
			blob = ((System.Data.Linq.Binary)(result.GetParameterValue(3)));
			errCode = ((System.Nullable<int>)(result.GetParameterValue(4)));
			errMsg = ((string)(result.GetParameterValue(5)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_UpdateUserStatValue")]
		public int proc_UpdateUserStatValue([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="PlatformID", DbType="Int")] System.Nullable<int> platformID, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant, [Parameter(Name="PropertyName", DbType="VarChar(255)")] string propertyName, [Parameter(Name="OldDatagroup", DbType="Int")] System.Nullable<int> oldDatagroup, [Parameter(Name="NewDatagroup", DbType="Int")] System.Nullable<int> newDatagroup, [Parameter(Name="Value", DbType="BigInt")] System.Nullable<long> value, [Parameter(Name="GameEventID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameEventID, [Parameter(Name="GameSessionID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameSessionID, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, platformID, gameID, variant, propertyName, oldDatagroup, newDatagroup, value, gameEventID, gameSessionID, blobID, dTUpdated, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(12)));
			errMsg = ((string)(result.GetParameterValue(13)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_GetRecentlyPlayedGames")]
		public ISingleResult<proc_GetRecentlyPlayedGamesResult> proc_GetRecentlyPlayedGames([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="Count", DbType="Int")] System.Nullable<int> count, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, count, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(2)));
			errMsg = ((string)(result.GetParameterValue(3)));
			return ((ISingleResult<proc_GetRecentlyPlayedGamesResult>)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_GetUserStatsForUserGameVariant")]
		public ISingleResult<proc_GetUserStatsForUserGameVariantResult> proc_GetUserStatsForUserGameVariant([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, gameID, variant);
			return ((ISingleResult<proc_GetUserStatsForUserGameVariantResult>)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_GetUserStatValue")]
		public int proc_GetUserStatValue([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant, [Parameter(Name="PropertyName", DbType="VarChar(255)")] string propertyName, [Parameter(Name="Datagroup", DbType="Int")] System.Nullable<int> datagroup, [Parameter(Name="PlatformID", DbType="Int")] ref System.Nullable<int> platformID, [Parameter(Name="Value", DbType="BigInt")] ref System.Nullable<long> value, [Parameter(Name="GameEventID", DbType="UniqueIdentifier")] ref System.Nullable<System.Guid> gameEventID, [Parameter(Name="GameSessionID", DbType="UniqueIdentifier")] ref System.Nullable<System.Guid> gameSessionID, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] ref System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] ref System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, gameID, variant, propertyName, datagroup, platformID, value, gameEventID, gameSessionID, blobID, dTUpdated, errCode, errMsg);
			platformID = ((System.Nullable<int>)(result.GetParameterValue(5)));
			value = ((System.Nullable<long>)(result.GetParameterValue(6)));
			gameEventID = ((System.Nullable<System.Guid>)(result.GetParameterValue(7)));
			gameSessionID = ((System.Nullable<System.Guid>)(result.GetParameterValue(8)));
			blobID = ((System.Nullable<System.Guid>)(result.GetParameterValue(9)));
			dTUpdated = ((System.Nullable<System.DateTime>)(result.GetParameterValue(10)));
			errCode = ((System.Nullable<int>)(result.GetParameterValue(11)));
			errMsg = ((string)(result.GetParameterValue(12)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_InsertDataBlob")]
		public int proc_InsertDataBlob([Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="Blob", DbType="VarBinary(MAX)")] System.Data.Linq.Binary blob, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] ref System.Nullable<System.Guid> blobID, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), dTUpdated, blob, blobID, errCode, errMsg);
			blobID = ((System.Nullable<System.Guid>)(result.GetParameterValue(2)));
			errCode = ((System.Nullable<int>)(result.GetParameterValue(3)));
			errMsg = ((string)(result.GetParameterValue(4)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_InsertUserStatValue")]
		public int proc_InsertUserStatValue([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="PlatformID", DbType="Int")] System.Nullable<int> platformID, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant, [Parameter(Name="PropertyName", DbType="VarChar(255)")] string propertyName, [Parameter(Name="Datagroup", DbType="Int")] System.Nullable<int> datagroup, [Parameter(Name="Value", DbType="BigInt")] System.Nullable<long> value, [Parameter(Name="GameEventID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameEventID, [Parameter(Name="GameSessionID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameSessionID, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, platformID, gameID, variant, propertyName, datagroup, value, gameEventID, gameSessionID, blobID, dTUpdated, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(11)));
			errMsg = ((string)(result.GetParameterValue(12)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_InsertUserStatValueWithoutCheck")]
		public int proc_InsertUserStatValueWithoutCheck([Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="PlatformID", DbType="Int")] System.Nullable<int> platformID, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant, [Parameter(Name="PropertyName", DbType="VarChar(255)")] string propertyName, [Parameter(Name="Datagroup", DbType="Int")] System.Nullable<int> datagroup, [Parameter(Name="Value", DbType="BigInt")] System.Nullable<long> value, [Parameter(Name="GameEventID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameEventID, [Parameter(Name="GameSessionID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameSessionID, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), xuid, platformID, gameID, variant, propertyName, datagroup, value, gameEventID, gameSessionID, blobID, dTUpdated, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(11)));
			errMsg = ((string)(result.GetParameterValue(12)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_OperateOnUserStatValue")]
		public int proc_OperateOnUserStatValue([Parameter(Name="Operation", DbType="Int")] System.Nullable<int> operation, [Parameter(Name="Xuid", DbType="BigInt")] System.Nullable<long> xuid, [Parameter(Name="PlatformID", DbType="Int")] System.Nullable<int> platformID, [Parameter(Name="GameID", DbType="Int")] System.Nullable<int> gameID, [Parameter(Name="Variant", DbType="Int")] System.Nullable<int> variant, [Parameter(Name="PropertyName", DbType="VarChar(255)")] string propertyName, [Parameter(Name="Datagroup", DbType="Int")] System.Nullable<int> datagroup, [Parameter(Name="Value", DbType="BigInt")] System.Nullable<long> value, [Parameter(Name="GameEventID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameEventID, [Parameter(Name="GameSessionID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> gameSessionID, [Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="NewValue", DbType="BigInt")] ref System.Nullable<long> newValue, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), operation, xuid, platformID, gameID, variant, propertyName, datagroup, value, gameEventID, gameSessionID, blobID, dTUpdated, newValue, errCode, errMsg);
			newValue = ((System.Nullable<long>)(result.GetParameterValue(12)));
			errCode = ((System.Nullable<int>)(result.GetParameterValue(13)));
			errMsg = ((string)(result.GetParameterValue(14)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_RemoveDataBlob")]
		public int proc_RemoveDataBlob([Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), blobID, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(1)));
			errMsg = ((string)(result.GetParameterValue(2)));
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="GDSS.proc_UpdateDataBlob")]
		public int proc_UpdateDataBlob([Parameter(Name="BlobID", DbType="UniqueIdentifier")] System.Nullable<System.Guid> blobID, [Parameter(Name="DTUpdated", DbType="DateTime")] System.Nullable<System.DateTime> dTUpdated, [Parameter(Name="Blob", DbType="VarBinary(MAX)")] System.Data.Linq.Binary blob, [Parameter(Name="ErrCode", DbType="Int")] ref System.Nullable<int> errCode, [Parameter(Name="ErrMsg", DbType="VarChar(400)")] ref string errMsg)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), blobID, dTUpdated, blob, errCode, errMsg);
			errCode = ((System.Nullable<int>)(result.GetParameterValue(3)));
			errMsg = ((string)(result.GetParameterValue(4)));
			return ((int)(result.ReturnValue));
		}
	}
	
	[Table(Name="GDSS.StatBlob")]
	public partial class StatBlob : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private System.Guid _BlobID;
		
		private short _si_HashBucket;
		
		private System.Data.Linq.Binary _Blob;
		
		private System.DateTime _DTCreated;
		
		private System.DateTime _DTUpdated;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnBlobIDChanging(System.Guid value);
    partial void OnBlobIDChanged();
    partial void Onsi_HashBucketChanging(short value);
    partial void Onsi_HashBucketChanged();
    partial void OnBlobChanging(System.Data.Linq.Binary value);
    partial void OnBlobChanged();
    partial void OnDTCreatedChanging(System.DateTime value);
    partial void OnDTCreatedChanged();
    partial void OnDTUpdatedChanging(System.DateTime value);
    partial void OnDTUpdatedChanged();
    #endregion
		
		public StatBlob()
		{
			OnCreated();
		}
		
		[Column(Storage="_BlobID", DbType="UniqueIdentifier NOT NULL", IsPrimaryKey=true)]
		public System.Guid BlobID
		{
			get
			{
				return this._BlobID;
			}
			set
			{
				if ((this._BlobID != value))
				{
					this.OnBlobIDChanging(value);
					this.SendPropertyChanging();
					this._BlobID = value;
					this.SendPropertyChanged("BlobID");
					this.OnBlobIDChanged();
				}
			}
		}
		
		[Column(Storage="_si_HashBucket", DbType="SmallInt NOT NULL")]
		public short si_HashBucket
		{
			get
			{
				return this._si_HashBucket;
			}
			set
			{
				if ((this._si_HashBucket != value))
				{
					this.Onsi_HashBucketChanging(value);
					this.SendPropertyChanging();
					this._si_HashBucket = value;
					this.SendPropertyChanged("si_HashBucket");
					this.Onsi_HashBucketChanged();
				}
			}
		}
		
		[Column(Storage="_Blob", DbType="VarBinary(MAX)", UpdateCheck=UpdateCheck.Never)]
		public System.Data.Linq.Binary Blob
		{
			get
			{
				return this._Blob;
			}
			set
			{
				if ((this._Blob != value))
				{
					this.OnBlobChanging(value);
					this.SendPropertyChanging();
					this._Blob = value;
					this.SendPropertyChanged("Blob");
					this.OnBlobChanged();
				}
			}
		}
		
		[Column(Storage="_DTCreated", DbType="DateTime NOT NULL")]
		public System.DateTime DTCreated
		{
			get
			{
				return this._DTCreated;
			}
			set
			{
				if ((this._DTCreated != value))
				{
					this.OnDTCreatedChanging(value);
					this.SendPropertyChanging();
					this._DTCreated = value;
					this.SendPropertyChanged("DTCreated");
					this.OnDTCreatedChanged();
				}
			}
		}
		
		[Column(Storage="_DTUpdated", DbType="DateTime NOT NULL")]
		public System.DateTime DTUpdated
		{
			get
			{
				return this._DTUpdated;
			}
			set
			{
				if ((this._DTUpdated != value))
				{
					this.OnDTUpdatedChanging(value);
					this.SendPropertyChanging();
					this._DTUpdated = value;
					this.SendPropertyChanged("DTUpdated");
					this.OnDTUpdatedChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="GDSS.UserStats")]
	public partial class UserStat
	{
		
		private long _Xuid;
		
		private short _si_HashBucket;
		
		private System.Nullable<int> _GameID;
		
		private int _Variant;
		
		private int _PlatformID;
		
		private string _PropertyName;
		
		private System.Nullable<long> _Value;
		
		private System.Guid _GameEventID;
		
		private System.Guid _GameSessionID;
		
		private System.DateTime _DTCreated;
		
		private System.DateTime _DTUpdated;
		
		private int _Datagroup;
		
		private System.Nullable<System.Guid> _BlobID;
		
		public UserStat()
		{
		}
		
		[Column(Storage="_Xuid", DbType="BigInt NOT NULL")]
		public long Xuid
		{
			get
			{
				return this._Xuid;
			}
			set
			{
				if ((this._Xuid != value))
				{
					this._Xuid = value;
				}
			}
		}
		
		[Column(Storage="_si_HashBucket", DbType="SmallInt NOT NULL")]
		public short si_HashBucket
		{
			get
			{
				return this._si_HashBucket;
			}
			set
			{
				if ((this._si_HashBucket != value))
				{
					this._si_HashBucket = value;
				}
			}
		}
		
		[Column(Storage="_GameID", DbType="Int")]
		public System.Nullable<int> GameID
		{
			get
			{
				return this._GameID;
			}
			set
			{
				if ((this._GameID != value))
				{
					this._GameID = value;
				}
			}
		}
		
		[Column(Storage="_Variant", DbType="Int NOT NULL")]
		public int Variant
		{
			get
			{
				return this._Variant;
			}
			set
			{
				if ((this._Variant != value))
				{
					this._Variant = value;
				}
			}
		}
		
		[Column(Storage="_PlatformID", DbType="Int NOT NULL")]
		public int PlatformID
		{
			get
			{
				return this._PlatformID;
			}
			set
			{
				if ((this._PlatformID != value))
				{
					this._PlatformID = value;
				}
			}
		}
		
		[Column(Storage="_PropertyName", DbType="VarChar(255) NOT NULL", CanBeNull=false)]
		public string PropertyName
		{
			get
			{
				return this._PropertyName;
			}
			set
			{
				if ((this._PropertyName != value))
				{
					this._PropertyName = value;
				}
			}
		}
		
		[Column(Storage="_Value", DbType="BigInt")]
		public System.Nullable<long> Value
		{
			get
			{
				return this._Value;
			}
			set
			{
				if ((this._Value != value))
				{
					this._Value = value;
				}
			}
		}
		
		[Column(Storage="_GameEventID", DbType="UniqueIdentifier NOT NULL")]
		public System.Guid GameEventID
		{
			get
			{
				return this._GameEventID;
			}
			set
			{
				if ((this._GameEventID != value))
				{
					this._GameEventID = value;
				}
			}
		}
		
		[Column(Storage="_GameSessionID", DbType="UniqueIdentifier NOT NULL")]
		public System.Guid GameSessionID
		{
			get
			{
				return this._GameSessionID;
			}
			set
			{
				if ((this._GameSessionID != value))
				{
					this._GameSessionID = value;
				}
			}
		}
		
		[Column(Storage="_DTCreated", DbType="DateTime NOT NULL")]
		public System.DateTime DTCreated
		{
			get
			{
				return this._DTCreated;
			}
			set
			{
				if ((this._DTCreated != value))
				{
					this._DTCreated = value;
				}
			}
		}
		
		[Column(Storage="_DTUpdated", DbType="DateTime NOT NULL")]
		public System.DateTime DTUpdated
		{
			get
			{
				return this._DTUpdated;
			}
			set
			{
				if ((this._DTUpdated != value))
				{
					this._DTUpdated = value;
				}
			}
		}
		
		[Column(Storage="_Datagroup", DbType="Int NOT NULL")]
		public int Datagroup
		{
			get
			{
				return this._Datagroup;
			}
			set
			{
				if ((this._Datagroup != value))
				{
					this._Datagroup = value;
				}
			}
		}
		
		[Column(Storage="_BlobID", DbType="UniqueIdentifier")]
		public System.Nullable<System.Guid> BlobID
		{
			get
			{
				return this._BlobID;
			}
			set
			{
				if ((this._BlobID != value))
				{
					this._BlobID = value;
				}
			}
		}
	}
	
	public partial class proc_GetRecentlyPlayedGamesResult
	{
		
		private System.Nullable<int> _GameID;
		
		private System.DateTime _LastPlayedDate;
		
		public proc_GetRecentlyPlayedGamesResult()
		{
		}
		
		[Column(Storage="_GameID", DbType="Int")]
		public System.Nullable<int> GameID
		{
			get
			{
				return this._GameID;
			}
			set
			{
				if ((this._GameID != value))
				{
					this._GameID = value;
				}
			}
		}
		
		[Column(Storage="_LastPlayedDate", DbType="DateTime NOT NULL")]
		public System.DateTime LastPlayedDate
		{
			get
			{
				return this._LastPlayedDate;
			}
			set
			{
				if ((this._LastPlayedDate != value))
				{
					this._LastPlayedDate = value;
				}
			}
		}
	}
	
	public partial class proc_GetUserStatsForUserGameVariantResult
	{
		
		private string _PropertyName;
		
		private System.Nullable<long> _Value;
		
		private System.DateTime _DTUpdated;
		
		private System.Nullable<System.Guid> _BlobID;
		
		public proc_GetUserStatsForUserGameVariantResult()
		{
		}
		
		[Column(Storage="_PropertyName", DbType="VarChar(255) NOT NULL", CanBeNull=false)]
		public string PropertyName
		{
			get
			{
				return this._PropertyName;
			}
			set
			{
				if ((this._PropertyName != value))
				{
					this._PropertyName = value;
				}
			}
		}
		
		[Column(Storage="_Value", DbType="BigInt")]
		public System.Nullable<long> Value
		{
			get
			{
				return this._Value;
			}
			set
			{
				if ((this._Value != value))
				{
					this._Value = value;
				}
			}
		}
		
		[Column(Storage="_DTUpdated", DbType="DateTime NOT NULL")]
		public System.DateTime DTUpdated
		{
			get
			{
				return this._DTUpdated;
			}
			set
			{
				if ((this._DTUpdated != value))
				{
					this._DTUpdated = value;
				}
			}
		}
		
		[Column(Storage="_BlobID", DbType="UniqueIdentifier")]
		public System.Nullable<System.Guid> BlobID
		{
			get
			{
				return this._BlobID;
			}
			set
			{
				if ((this._BlobID != value))
				{
					this._BlobID = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\StatisticsConstants.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GDS.DataAccess.UserData
{
    public sealed class StatisticsConstants
    {
        public const string CumulativeScore = "CumulativeScore";
        public const string CumulativeTime = "CumulativeTime";
        public const string AverageScore = "AverageScore";
        public const string AverageTime = "AverageTime";
        public const string GamesPlayed = "GamesPlayed";
        public const string LastPlayedDateTime = "LastPlayedDateTime";
        public const string BestScore = "BestScore";
        public const string BestTime = "BestTime";
        public const string Wins = "Wins";
        public const string Losses = "Losses";
        public const string BestScoreDataBlobId = "BestScoreDataBlobId";
        public const string BestTimeDataBlobId = "BestTimeDataBlobId";

        // Filtered property names:
        public const string BestHighTime = "BestHighTime";
        public const string BestLowTime = "BestLowTime";
        public const string BestHighScore = "BestHighScore";
        public const string BestLowScore = "BestLowScore";

        private StatisticsConstants() { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserDataStorage.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Data.Linq;
    using System.Data.SqlClient;
    using System.Linq;
    using System.Xml;
    using Gds.Contracts;
    using Leet.Core;
    using Leet.Core.Diagnostics;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;

    public class UserDataStorage : IUserDataStorage
    {
        private const string UserDataStoreConnectionConfigName = "lest_userprofilestore_db";
        private const string DefaultDataGroupName = "";
        private const string ComponentName = "UserDataStorage";

        private Dictionary<string, IUserStorageConverterFilter> defaultConverterFilter = new Dictionary<string, IUserStorageConverterFilter>(StringComparer.OrdinalIgnoreCase);

        public UserDataStorage()
        {
            string userDataStoreConnectionString = Container.Instance.GetComponent<IConfigurationProvider>().GetConnectionString(UserDataStorage.UserDataStoreConnectionConfigName);
            this.UserDataContext = new UserDataStoreDataContext(userDataStoreConnectionString);

            // create filters
            ConverterFilter [] filters = { new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighTime, AliasName = StatisticsConstants.BestTime, IsRemoved = false },
                                           new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowTime, IsRemoved = true},
                                           new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighScore, AliasName = StatisticsConstants.BestScore, IsRemoved = false },
                                           new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowScore, IsRemoved = true }};

            foreach (var filter in filters)
            {
                this.defaultConverterFilter.Add(filter.PropertyKey, filter);
            }
        }

        private UserDataStoreDataContext UserDataContext { get; set; }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        public static IList<Entry> FetchStatisticsForUser(long xuid, IEnumerable<UserStat> userStatsTable, string propertyToCheck, IDictionary<string, IUserStorageConverterFilter> converterFilter)
        {
            if (userStatsTable == null || userStatsTable.Count() == 0)
            {
                throw new ArgumentNullException("userStatsTable", "miniUserStatsTable is null or empty");
            }

            var statEntriesForUser = from userStatEntry in userStatsTable
                                     where userStatEntry.Xuid == xuid
                                     select userStatEntry;

            if (statEntriesForUser.Count() == 0)
            {
                return null;
            }

            List<Entry> statistics = FirstPassConvertUserStatToStatisticList(statEntriesForUser, converterFilter);
            statistics = SecondPassConvertUserStatToStatisticList(statistics, null);

            // ensure that the property, if present, does exists in the List<Entry>
            if (!string.IsNullOrEmpty(propertyToCheck))
            {
                if (!VerifyPropertyExistInStats(statistics, propertyToCheck))
                {
                    return null;
                }
            }

            return statistics;
        }

        public UserStat GetStatisticEntry(ulong xuid, uint gameId, uint variant, string property, uint dataGroup)
        {
            int? platformId = 0;
            long? value = 0;
            Guid? gameEventId = null;
            Guid? gameSessionId = null;
            Guid? blobId = null;
            DateTime? dateUpdated = null;
            int? errCode = 0;
            string errMsg = null;

            try
            {
                unchecked
                {
                    this.UserDataContext.proc_GetUserStatValue(
                                    (long)xuid,
                                    (int)gameId,
                                    (int)variant,
                                    property,
                                    (int)dataGroup,
                                    ref platformId,
                                    ref value,
                                    ref gameEventId,
                                    ref gameSessionId,
                                    ref blobId,
                                    ref dateUpdated,
                                    ref errCode,
                                    ref errMsg);
                    UserStat statEntry = new UserStat()
                    {
                        BlobID = blobId,
                        DTUpdated = dateUpdated.Value, // must exists, otherwise throws InvalidOperationException(intentionally)
                        GameEventID = gameEventId ?? Guid.Empty,
                        GameID = (int)gameId,
                        GameSessionID = gameSessionId ?? Guid.Empty,
                        PlatformID = platformId.Value, // must exists, otherwise throws InvalidOperationException(intentionally)
                        PropertyName = property,
                        si_HashBucket = 0,
                        Value = value,
                        Variant = (int)variant,
                        Xuid = (long)xuid
                    };

                    return statEntry;
                }
            }
            catch (SqlException sqlEx)
            {
               Logging.TraceException(sqlEx, ComponentName);
                // TODO should throw. This is OK for now because this is used only in InsertOrUpdateBlob() which is not used
                return null; 
            }
            catch (InvalidOperationException ex)
            {
                Logging.TraceException(ex, ComponentName);
                return null;
            }
        }

        public Guid? InsertBlob(byte[] blob, DateTime dateUpdated)
        {
            int? errCode = 0;
            string errMsg = string.Empty;
            Guid? blobId = null;

            this.UserDataContext.proc_InsertDataBlob(dateUpdated, blob, ref blobId, ref errCode, ref errMsg);

            return blobId;
        }

        public UserDataError UpdateBlob(Guid blobId, byte[] blob, DateTime dateUpdated)
        {
            int? errCode = 0;
            string errMsg = string.Empty;

            this.UserDataContext.proc_UpdateDataBlob(blobId, dateUpdated, blob, ref errCode, ref errMsg);

            return new UserDataError()
            {
                ErrorCode = (uint)errCode,
                ErrorMessage = errMsg
            };
        }

        public byte[] GetBlob(Guid blobId)
        {
            int? errorCode = 0;
            string errMsg = string.Empty;
            DateTime? dateUpdated = null;
            DateTime? dateCreated = null;
            Binary blob = null;

            this.UserDataContext.proc_GetDataBlob(blobId, ref dateUpdated, ref dateCreated, ref blob, ref errorCode, ref errMsg);

            if (errorCode == UserDataError.SuccessCode)
            {
                if (blob != null)
                {
                    return blob.ToArray();
                }
            }

            return null;
        }

        public UserDataError DeleteBlob(Guid blobId)
        {
            int? errCode = 0;
            string errMsg = string.Empty;

            this.UserDataContext.proc_RemoveDataBlob(blobId, ref errCode, ref errMsg);

            return new UserDataError()
            {
                ErrorCode = (uint)errCode,
                ErrorMessage = errMsg
            };
        }

        /// <summary>
        /// Performs the Given basic mathematical operation for the provided parameters in the UserData.
        /// </summary>
        /// <param name="userDataOperation"></param>
        /// <param name="xuid"></param>
        /// <param name="platformId"></param>
        /// <param name="gameId"></param>
        /// <param name="variant"></param>
        /// <param name="propertyName"></param>
        /// <param name="value"></param>
        /// <param name="gameEventId"></param>
        /// <param name="gameSessionId"></param>
        /// <param name="blobId"></param>
        /// <param name="dateUpdated"></param>
        /// <param name="newValue"></param>
        /// <returns></returns>
        public UserDataError OperateOnUserStatValueLong(
                                    UserDataOperationEnum userDataOperation,
                                    ulong xuid,
                                    uint platformId,
                                    uint gameId,
                                    uint variant,
                                    string propertyName,
                                    uint dataGroup,
                                    long value,
                                    Guid gameEventId,
                                    Guid gameSessionId,
                                    Guid? blobId,
                                    DateTime dateUpdated,
                                    ref long newValue)
        {
            long? refNewValue = newValue = 0;
            int? errorCode = 0;
            string errorMessage = string.Empty;

            unchecked
            {
                this.UserDataContext.proc_OperateOnUserStatValue(
                                                (int)userDataOperation,
                                                (long)xuid,
                                                (int)platformId,
                                                (int)gameId,
                                                (int)variant,
                                                propertyName,
                                                (int)dataGroup,
                                                value,
                                                gameEventId,
                                                gameSessionId,
                                                blobId,
                                                dateUpdated,
                                                ref refNewValue,
                                                ref errorCode,
                                                ref errorMessage);
            }

            newValue = refNewValue.Value;

            return new UserDataError() { ErrorCode = (uint)errorCode, ErrorMessage = errorMessage };
        }

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        public IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, string property, uint dataGroup, List<long> xuidList)
        {
            return this.GetStatsForXuids(gameId, variantId, property, dataGroup, xuidList, this.defaultConverterFilter);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        public IList<StatsResult> GetStatsForXuids(
                                        uint gameId, 
                                        uint variantId, 
                                        string property, 
                                        uint dataGroup, 
                                        List<long> xuidList, 
                                        IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            // Get all stats - for the user list
            var miniUserStatsTable = from userStatsRow in this.UserDataContext.UserStats
                                     where xuidList.Contains(userStatsRow.Xuid) &&
                                           userStatsRow.Variant == variantId &&
                                           userStatsRow.GameID == gameId &&
                                           userStatsRow.Datagroup == dataGroup
                                     select userStatsRow;

            // there is nothing noted in the list, immediately return.
            if (miniUserStatsTable.Count() == 0)
            {
                Logging.TraceInformation("UserDataStorage.GetStatsForXuids miniUserStatsTable.Count() = 0");
                return null;
            }

            // for each unique user, create a seperate List<Entry>
            List<StatsResult> userStats = new List<StatsResult>(xuidList.Count);

            foreach (long xuid in xuidList)
            {
                IList<Entry> userStat = FetchStatisticsForUser(xuid, miniUserStatsTable, property, converterList);
                if (userStat != null && userStat.Count > 0)
                {
                    StatsResult sr = new StatsResult()
                    {
                        Xuid = (ulong)xuid,
                        Statistics = userStat
                    };

                    userStats.Add(sr);
                }
            }

            Console.WriteLine("userStats table contains {0} entries", userStats.Count());

            return userStats;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.Compare(System.String,System.String,System.Boolean)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToUInt64(System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt64)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.Int64)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToInt64(System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1304:SpecifyCultureInfo", MessageId = "System.String.Compare(System.String,System.String,System.Boolean)")]
        private static List<Entry> FirstPassConvertUserStatToStatisticList(IEnumerable<UserStat> userStat, IDictionary<string, IUserStorageConverterFilter> converterFilter)
        {
            if (userStat == null && userStat.Count() == 0)
            {
                throw new ArgumentNullException("userStat", "UserStat is null or empty");
            }

            if (converterFilter == null)
            {
                throw new ArgumentNullException("converterFilter");
            }

            List<Entry> entryList = new List<Entry>();
            Entry newEntry;

            ulong gamesPlayed = 0;
            long cumulativeScore = 0;
            ulong cumulativeTime = 0;
            Guid? bestScoreBlobId = null;
            Guid? bestTimeBlobId = null;

            // Add the stats to the list
            foreach (var statRow in userStat)
            {
                // check if there is a converter/removal filter.
                IUserStorageConverterFilter filter = null;
                newEntry = null;

                converterFilter.TryGetValue(statRow.PropertyName, out filter);

                // If a filter does exists for given statistic entry, let the filter convert/process it to an Entry
                // Otherwise Add it as is - without any warranties.
                if (filter != null)
                {
                    if (!filter.IsRemoved)
                    {
                        newEntry = filter.Process(statRow.PropertyName, Convert.ToString(statRow.Value));
                    }
                }
                else
                {
                    newEntry = new Entry();
                    newEntry.Name = statRow.PropertyName;
                    newEntry.Value = Convert.ToString(statRow.Value);
                }

                if (newEntry != null)
                {
                    entryList.Add(newEntry);
                }

                // extract derived stats.
                if (String.Compare(statRow.PropertyName, StatisticsConstants.GamesPlayed, true) == 0)
                {
                    gamesPlayed = Convert.ToUInt64(statRow.Value);
                    newEntry = new Entry();
                    newEntry.Name = StatisticsConstants.LastPlayedDateTime;
                    newEntry.Value = XmlConvert.ToString(statRow.DTUpdated, XmlDateTimeSerializationMode.Utc);
                    entryList.Add(newEntry);
                }
                else if (String.Compare(statRow.PropertyName, StatisticsConstants.CumulativeScore, true) == 0)
                {
                    // score can be negative.
                    cumulativeScore = Convert.ToInt64(statRow.Value);
                }
                else if (String.Compare(statRow.PropertyName, StatisticsConstants.CumulativeTime, true) == 0)
                {
                    // time can NOT be negative.
                    cumulativeTime = Convert.ToUInt64(statRow.Value);
                }
                else if (converterFilter.ContainsKey(statRow.PropertyName, StringComparison.OrdinalIgnoreCase))
                {
                    // datablob derivation
                    if (!converterFilter[statRow.PropertyName].IsRemoved)
                    {
                        if (converterFilter[statRow.PropertyName].AliasName.Equals(StatisticsConstants.BestScore, StringComparison.OrdinalIgnoreCase))
                        {
                            bestScoreBlobId = statRow.BlobID;
                        }
                        else if (converterFilter[statRow.PropertyName].AliasName.Equals(StatisticsConstants.BestTime, StringComparison.OrdinalIgnoreCase))
                        {
                            bestTimeBlobId = statRow.BlobID;
                        }
                    }
                }
            }

            // Add average score and time to the entry list
            newEntry = new Entry();
            newEntry.Name = StatisticsConstants.AverageScore;
            newEntry.Value = Convert.ToString(GetAverage(cumulativeScore, gamesPlayed));
            entryList.Add(newEntry);

            newEntry = new Entry();
            newEntry.Name = StatisticsConstants.AverageTime;
            newEntry.Value = Convert.ToString(GetAverage(cumulativeTime, gamesPlayed));
            entryList.Add(newEntry);

            if (!bestScoreBlobId.IsNullOrEmpty())
            {
                newEntry = new Entry();
                newEntry.Name = StatisticsConstants.BestScoreDataBlobId;
                newEntry.Value = bestScoreBlobId.Value.ToString();
                entryList.Add(newEntry);
            }

            if (!bestTimeBlobId.IsNullOrEmpty())
            {
                newEntry = new Entry();
                newEntry.Name = StatisticsConstants.BestTimeDataBlobId;
                newEntry.Value = bestTimeBlobId.Value.ToString();
                entryList.Add(newEntry);
            }

            return entryList;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "converterFilter")]
        private static List<Entry> SecondPassConvertUserStatToStatisticList(List<Entry> userStatList, IDictionary<string, IUserStorageConverterFilter> converterFilter)
        {
            // Find if a list has any Loss Entry
            var lossEnumerable = from userStat in userStatList
                                 where string.Equals(userStat.Name, StatisticsConstants.Losses, StringComparison.OrdinalIgnoreCase) &&
                                       !string.IsNullOrEmpty(userStat.Value)
                                 select userStat;

            // Find if a list has any Win Entry.
            var winEnumerable = from userStat in userStatList
                                where string.Equals(userStat.Name, StatisticsConstants.Wins, StringComparison.OrdinalIgnoreCase) &&
                                      !string.IsNullOrEmpty(userStat.Value)
                                select userStat;

            // if we have any loss but no win, make sure we have at least one win entry w/ 0 as the value.
            if (lossEnumerable.Count() > 0 && winEnumerable.Count() == 0)
            { 
                long defaultNumber = 0;
                Entry newEntry = new Entry()
                {
                    Name = StatisticsConstants.Wins,
                    Value = defaultNumber.ToString()
                };

                userStatList.Add(newEntry);
            }

            return userStatList;
        }

        private static bool VerifyPropertyExistInStats(List<Entry> userStats, string property)
        {
            var userStatPropertyEntry = from userStatEntry in userStats
                                        where userStatEntry.Name.Equals(property, StringComparison.OrdinalIgnoreCase)
                                        select userStatEntry;

            if (userStatPropertyEntry.Count() > 0)
            {
                return true;
            }

            return false;
        }

        private void Dispose(bool isDisposing)
        {
            if (isDisposing)
            {
                this.UserDataContext.Dispose();
            }
        }

        /// <summary>
        /// Get the average
        /// </summary>
        /// <param name="value">The numerator</param>
        /// <param name="count">The divider</param>
        /// <returns>The average</returns>
        private static ulong GetAverage(ulong value, ulong count)
        {
            if (count == 0 || value == 0)
            {
                return 0;
            }

            ulong average = value / count;
            return average;
        }

        private static long GetAverage(long value, ulong count)
        {
            if (count == 0 || value == 0)
            {
                return 0;
            }

            long average = value / (long)count;
            return average;
        }
    }

    internal class ConverterFilter : IUserStorageConverterFilter
    {
        public string PropertyKey { get; set; }

        public string AliasName { get; set; }

        public bool IsRemoved { get; set; }

        public Entry Process(string name, string value)
        {
            if (this.IsRemoved)
            {
                throw new InvalidOperationException();
            }

            Entry current = new Entry()
            {
                Name = this.AliasName,
                Value = value
            };

            return current;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\LeaderboardUtility.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Gds.Contracts;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
    public class LeaderboardUtilityItem
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public ulong Xuid { get; set; }

        public LeaderboardItem Item { get; set; }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
    public sealed class LeaderboardUtility
    {
        private LeaderboardUtility() { } // shouldn't need to construct

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        public static IList<LeaderboardUtilityItem> ConvertStatsToLeaderboard(IList<StatsResult> statList, string property, bool isDescending)
        {
            // the caller, for the time being, guarantees that this is non-null and non-empty.
            // in case the assumption changes I shall throw here as a precaution.
            if (statList == null || statList.Count < 1)
            {
                throw new ArgumentException("parameter cannot be null or empty", "statList");
            }

            List<LeaderboardUtilityItem> itemList = new List<LeaderboardUtilityItem>(statList.Count());

            foreach (var statistic in statList)
            {
                LeaderboardUtilityItem utilityItem = new LeaderboardUtilityItem()
                {
                    Xuid = statistic.Xuid,
                    Item = ConstructLeaderboardItemFromStat(statistic.Statistics, property)
                };

                // only add it to the list, if there is a LeaderboardItem for it
                if (utilityItem.Item != null)
                {
                    itemList.Add(utilityItem);
                }
            }

            IOrderedEnumerable<LeaderboardUtilityItem> orderedCollection = null;
            
            // order the the list
            if (isDescending)
            {
                orderedCollection = from leaderboardUtilityItem in itemList
                                    orderby leaderboardUtilityItem.Item.Value descending, GetLastPlayedDateTime(leaderboardUtilityItem.Item.Statistics) ascending
                                    select leaderboardUtilityItem;
            }
            else
            {
                orderedCollection = from leaderboardUtilityItem in itemList
                                    orderby leaderboardUtilityItem.Item.Value ascending, GetLastPlayedDateTime(leaderboardUtilityItem.Item.Statistics) ascending
                                    select leaderboardUtilityItem;
            }

            List<LeaderboardUtilityItem> listOfUserStats = orderedCollection.ToList();

            return listOfUserStats;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        public static LeaderboardItem ConstructLeaderboardItemFromStat(IList<Entry> statistics, string property)
        {
            try
            {
                LeaderboardItem leaderItem = new LeaderboardItem()
                {
                    Rank = 0,
                    Statistics = statistics,
                    Value = GetPropertyValueFromStats(statistics, property),
                    User = new LeaderboardUser()
                };

                return leaderItem;
            }
            catch (InvalidOperationException ex)
            {
               Logging.TraceException(ex,"LeaderboardUtility.ConstructLeaderboardItemFromStat Caught exception: ");
               return null;
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.Parse(System.String)")]
        public static long GetPropertyValueFromStats(IList<Entry> statistics, string property)
        {
            var valueCollection = from statisticEntry in statistics
                                  where statisticEntry.Name.Equals(property, StringComparison.OrdinalIgnoreCase)
                                  select statisticEntry.Value;

            if (valueCollection.Count() == 0)
            {
                throw new InvalidOperationException("A required property does not exists in the stat list, ");
            }

            string value = valueCollection.First();
            if (string.IsNullOrEmpty(value))
            {
                return 0;
            }

            return long.Parse(value);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1307:SpecifyStringComparison", MessageId = "System.String.Compare(System.String,System.String,System.Boolean)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1304:SpecifyCultureInfo", MessageId = "System.String.Compare(System.String,System.String,System.Boolean)")]
        public static DateTime GetLastPlayedDateTime(IList<Entry> statistics)
        {
            var enumerableStatEntries = from statEntry in statistics
                                        where string.Compare(statEntry.Name, StatisticsConstants.LastPlayedDateTime, true) == 0
                                        select statEntry;

            if (enumerableStatEntries.Count() > 0)
            {
                if (enumerableStatEntries.First() != null && !string.IsNullOrEmpty(enumerableStatEntries.First().Value))
                {
                    DateTime returnDate;
                    if (DateTime.TryParse(enumerableStatEntries.First().Value, out returnDate))
                    {
                        return returnDate;
                    }
                }
            }

            // default to current time, if there were no datetime entry.
            return DateTime.UtcNow;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserDataUtilities.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;

    public static class UserDataUtilities
    {
        internal static readonly DateTime DatagroupBeginTime = DateTime.MinValue;
        internal const uint DaysPerWeek = 7;
        // Base DateTime for game timestamp validation
        private static DateTime baseDateTime = new DateTime(2010, 1, 1);

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datagroup")]
        public static uint GetDatagroupNumberForDate(DateTime dt)
        {
            if (dt == null)
            {
                throw new ArgumentNullException("DateTime");
            }

            // Make sure the timestamp is later than baseDateTime
            if (dt < baseDateTime)
            {
                throw new ArgumentOutOfRangeException("timestamp", "TimeStamp must be later than 01/01/2010");
            }

            // Calculate the week # since begining
            TimeSpan duration = dt.Subtract(UserDataUtilities.DatagroupBeginTime);

            unchecked
            {
                return (uint)(duration.TotalDays / UserDataUtilities.DaysPerWeek);
            }
        }

        public static bool ContainsKey(this IDictionary<string, IUserStorageConverterFilter> myDictionary, string key, StringComparison comparer)
        {
            foreach (string dictionaryKey in myDictionary.Keys)
            {
                if (String.Compare(dictionaryKey, key, comparer) == 0)
                {
                    return true;
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserProfileDataAccessException.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;

    public class UserProfileDataAccessException : Exception
    {
        public UserProfileDataAccessException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public UserProfileDataAccessException(string message)
            : base(message)
        {
        }
    }

    public class UserProfileDataAccessOperationException : UserProfileDataAccessException
    {
        public const int NoEntryFound = 1;

        public UserProfileDataAccessOperationException(string message, Exception innerException)
            : base(message, innerException)
        { 
        }

        public UserProfileDataAccessOperationException(string message, int errorCode, string errorMessage)
            : base(message)
        {
            this.ErrorCode = errorCode;
            this.ErrorMessage = errorMessage;
        }

        public UserProfileDataAccessOperationException(string message)
            : base(message)
        {
        }

        public int ErrorCode { get; private set; }

        public string ErrorMessage { get; private set; }
    }

    public class UserProfileDataAccessArgumentException : UserProfileDataAccessException
    {
        public UserProfileDataAccessArgumentException(string message, Exception innerException)
            : base (message, innerException)
        {
        }

        public UserProfileDataAccessArgumentException(string message)
            : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserProfileStorageWebstore.cs ===
﻿namespace Gds.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;
    using Microsoft.Webstore.WstClient;
    using Microsoft.Webstore.MetaData;
    using Gds.Contracts.Converters;

    public class UserProfileStorageWebstore : IUserProfileStorage
    {
        public const string DeploymentName = "UserProfile";

        private const string SprocFailFormatString = "Stored proc failed with the following error {0} and message {1}";
        private const string WebstoreFailFormatString = "Some Webstore operation exception has happened, check inner exception";
        private const int LongSeperatorListItemSize = 20;
        private static Dictionary<string, IUserStorageConverterFilter> defaultConverterFilter = new Dictionary<string, IUserStorageConverterFilter>(StringComparer.OrdinalIgnoreCase);

        static UserProfileStorageWebstore()
        {
            // create filters
            ConverterFilter[] filters = { new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighTime, AliasName = StatisticsConstants.BestTime, IsRemoved = false },
                                          new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowTime, AliasName = StatisticsConstants.BestTime, IsRemoved = true },
                                          new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighScore, AliasName = StatisticsConstants.BestScore, IsRemoved = false },
                                          new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowScore, AliasName = StatisticsConstants.BestScore, IsRemoved = true } };

            foreach (var filter in filters)
            {
                UserProfileStorageWebstore.defaultConverterFilter.Add(filter.PropertyKey, filter);
            }
        }

        public UserProfileStorageWebstore()
        {
            try
            {
                this.UserProfileWebstore = new UserProfileWebstore(UserProfileStorageWebstore.DeploymentName);
            }
            catch (WebstoreException ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }
        }

        private UserProfileWebstore UserProfileWebstore { get; set; }

        public Guid InsertBlob(byte[] blob, DateTime dateUpdated)
        {
            int errorCode = 0;
            string errorMessage = string.Empty;
            Guid blobId = Guid.NewGuid();

            try
            {
                this.UserProfileWebstore.proc_InsertDataBlob(blobId, this.GetPartitionId(blobId), dateUpdated, DateTime.UtcNow, blob, ref errorCode, ref errorMessage);

                if (errorCode == 0)
                {
                    return blobId;
                }

                throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errorCode, errorMessage));
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }
        }

        public int UpdateBlob(Guid blobId, byte[] blob, DateTime dateUpdated)
        {
            int errorCode = 0;
            string errorMessage = string.Empty;

            try
            {
                this.UserProfileWebstore.proc_UpdateDataBlob(blobId, this.GetPartitionId(blobId), dateUpdated, blob, ref errorCode, ref errorMessage);

                if (errorCode != 0)
                {
                    throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errorCode, errorMessage));
                }
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }

            return errorCode;
        }

        public byte[] GetBlob(Guid blobId, ref DateTime dateUpdated, ref DateTime dateCreated)
        {
            unchecked
            {
                int errorCode = 0;
                string errorMessage = string.Empty;
                byte[] blob = null;

                try
                {
                    this.UserProfileWebstore.proc_GetDataBlob(blobId, this.GetPartitionId(blobId), GameResultConverterExtension.MaximumAllowedBlobSize, ref dateUpdated, ref dateCreated, ref blob, ref errorCode, ref errorMessage);

                    if (errorCode == 0)
                    {
                        return blob;
                    }

                    throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errorCode, errorMessage), errorCode, errorMessage);
                }
                catch (UserProfileDataAccessOperationException)
                {
                    throw;
                }
                catch (Exception ex)
                {
                    throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
                }
            }
        }

        public void DeleteBlob(Guid blobId)
        {
            int errorCode = 0;
            string errorMessage = string.Empty;

            try
            {
                this.UserProfileWebstore.proc_RemoveDataBlob(blobId, this.GetPartitionId(blobId), ref errorCode, ref errorMessage);

                if (errorCode != 0)
                {
                    throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errorCode, errorMessage));
                }
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }
        }

        public UserStatsEx GetStatisticEntry(ulong xuid, uint gameId, uint variant, uint dataGroup)
        {
            int errCode = 0;
            string errMsg = string.Empty;

            try
            {
                List<UserStatsEx> listOfStats = this.UserProfileWebstore.proc_GetStatsForUsers(
                                                                            UncheckedConvert.ToInt64(xuid).ToString(),
                                                                            this.GetPartitionId(xuid),
                                                                            UncheckedConvert.ToInt32(gameId),
                                                                            UncheckedConvert.ToInt32(variant),
                                                                            UncheckedConvert.ToInt32(dataGroup),
                                                                            ref errCode,
                                                                            ref errMsg);
                if (errCode == 0)
                {
                    int resultCount = listOfStats.Count;

                    if (resultCount > 0)
                    {
#if DBG
                        if (resultCount != 1)
                        {
                            throw new UserProfileDataAccessOperationException(String.Format("Invalid DB state detected - Query resulted in {0} rows, instead of 1", resultCount);
                        }
#endif //DBG
                        return listOfStats[0];
                    }

                    return null;
                }

                throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errCode, errMsg));
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }
        }

        public int InsertOrUpdateStatForUser(UserStatsEx row)
        {
            int errCode = 0;
            string errMsg = string.Empty;

            unchecked
            {
                row.si_HashBucket = (short) this.GetPartitionId(row.Xuid);
            }

            try
            {
                this.UserProfileWebstore.proc_InsertUserStatValue(
                      row.Xuid,
                      row.si_HashBucket,
                      row.GameID,
                      row.Variant,
                      row.Datagroup,
                      row.PlatformID,
                      row.GameEventID,
                      row.GameSessionID,
                      row.DTCreated,
                      row.DTUpdated,
                      row.BlobID,
                      row.BestScore,
                      row.BestTime,
                      row.CumulativeScore,
                      row.CumulativeTime,
                      row.Wins,
                      row.Losses,
                      row.GamesPlayed,
                      row.PropertyBagId,
                      ref errCode,
                      ref errMsg);
                if (errCode != 0)
                {
                    throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errCode, errMsg));
                }
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }

            return errCode;
        }

        public IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, uint dataGroup, IList<ulong> xuidList, string baseProperty)
        {
            return this.GetStatsForXuids(gameId, variantId, dataGroup, xuidList, baseProperty, defaultConverterFilter);
        }

        public IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, uint dataGroup, IList<ulong> xuidList, string baseProperty, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            Dictionary<int, IList<long>> partitionBuckets = this.BucketizeXuidList(xuidList);

            // use default if none is provided
            if (converterList == null)
            {
                converterList = defaultConverterFilter;
            }

            List<ScatterGatherQueryTaskItem> scatterGatherTaskList = new List<ScatterGatherQueryTaskItem>(partitionBuckets.Count);

            foreach (int partitionKey in partitionBuckets.Keys)
            {
                ScatterGatherQueryTaskItem scatterItem = new ScatterGatherQueryTaskItem()
                {
                    XuidList = partitionBuckets[partitionKey],
                    GameId = UncheckedConvert.ToInt32(gameId),
                    Variant = UncheckedConvert.ToInt32(variantId),
                    Datagroup = UncheckedConvert.ToInt32(dataGroup),
                    UserDataStorageWebstore = this,
                    Partition = partitionKey
                };

                scatterGatherTaskList.Add(scatterItem);
            }

            ScatterGatherManager sgm = new ScatterGatherManager(ScatterGatherManager.MaxNumberOfScatter, true);

            List<UserProfileScatterGatherTask> resultList = sgm.ExecuteParallel<UserProfileScatterGatherTask, ScatterGatherQueryTaskItem, IList<UserStatsEx>>(scatterGatherTaskList);

            IList<UserStatsEx> combinedResults = CombineScatteredResults(resultList);

            IList<StatsResult> statResults = ConvertUserStatsEx(combinedResults, baseProperty, converterList);

            return statResults;
        }

        internal IList<UserStatsEx> GetStatsForXuids(ScatterGatherQueryTaskItem taskItem)
        {
            int errCode = 0;
            string errMsg = string.Empty;

            try
            {
                List<UserStatsEx> returnList = this.UserProfileWebstore.proc_GetStatsForUsers(
                                                        GetCommaDelimitedXuidList(taskItem.XuidList),
                                                        taskItem.Partition,
                                                        taskItem.GameId,
                                                        taskItem.Variant,
                                                        taskItem.Datagroup,
                                                        ref errCode,
                                                        ref errMsg);
                if (errCode == 0)
                {
                    return returnList;
                }

                throw new UserProfileDataAccessOperationException(string.Format(SprocFailFormatString, errCode, errMsg));
            }
            catch (UserProfileDataAccessOperationException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new UserProfileDataAccessOperationException(WebstoreFailFormatString, ex);
            }
        }

        private static string GetCommaDelimitedXuidList(IList<long> xuidList)
        {
            StringBuilder sb = new StringBuilder(UserProfileStorageWebstore.LongSeperatorListItemSize * xuidList.Count);

            if (xuidList.Count > 0)
            {
                sb.AppendFormat("{0}", xuidList[0]);
            }

            for (int i = 1; i < xuidList.Count; i++)
            {
                sb.AppendFormat(", {0}", xuidList[i]);
            }

            return sb.ToString();
        }

        private static IList<StatsResult> ConvertUserStatsEx(IList<UserStatsEx> listOfCombinedResults, string baseProperty, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            List<StatsResult> listOfStatResult = new List<StatsResult>(listOfCombinedResults.Count);

            foreach (UserStatsEx userStatRow in listOfCombinedResults)
            {
                StatsResult statResultForUser = ConvertUserStatsForUser(userStatRow, baseProperty, converterList);

                // Ensure we only add user stats that have desired property, if it is specified.
                if (statResultForUser != null)
                {
                    listOfStatResult.Add(statResultForUser);
                }
            }

            return listOfStatResult;
        }

        private static StatsResult ConvertUserStatsForUser(UserStatsEx userStatRow, string baseProperty, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            unchecked
            {
                StatsResult sr = new StatsResult()
                {
                    Xuid = (ulong)userStatRow.Xuid,
                    Statistics = WebstoreToGdsConverterUtil.CreateStatisticListForUser(userStatRow, converterList)
                };

                // ensure that the property, if present, does exists in the List<Entry> = i.e. sr.Statistics
                if (!string.IsNullOrEmpty(baseProperty))
                {
                    if (!VerifyPropertyExistInStats(sr.Statistics, baseProperty))
                    {
                        // can't find property, return empty StatResult
                        return null;
                    }
                }

                return sr;
            }
        }

        private static IList<UserStatsEx> CombineScatteredResults(IList<UserProfileScatterGatherTask> resultList)
        {
            List<UserStatsEx> combinedResults = new List<UserStatsEx>();

            foreach (UserProfileScatterGatherTask taskItem in resultList)
            {
                combinedResults.AddRange(taskItem.Result);
            }

            return combinedResults;
        }

        private static bool VerifyPropertyExistInStats(IList<Entry> userStats, string property)
        {
            Entry entryResult = userStats.FirstOrDefault((Entry entry) => entry.Name.Equals(property, StringComparison.OrdinalIgnoreCase));

            if (entryResult != null)
            {
                return true;
            }

            return false;
        }

        private int GetPartitionId(long xuid)
        {
            int hash = WstHash.GetHash(xuid, UserProfileWebstore.PartitionCount);
            return hash;
        }

        private int GetPartitionId(ulong xuid)
        {
            unchecked
            {
                long realXuid = (long)xuid;
                int hash = WstHash.GetHash(realXuid, UserProfileWebstore.PartitionCount);
                return hash;
            }
        }

        private int GetPartitionId(Guid blobId)
        {
            int hash = WstHash.GetHash(blobId, UserProfileWebstore.PartitionCount);
            return hash;
        }

        private Dictionary<int, IList<long>> BucketizeXuidList(IList<ulong> xuidList)
        {
            Dictionary<int, IList<long>> hashXuidCollection = new Dictionary<int, IList<long>>();

            int hashKey = 0;

            foreach (ulong xuid in xuidList)
            {
                hashKey = this.GetPartitionId(xuid);

                if (!hashXuidCollection.ContainsKey(hashKey))
                {
                    hashXuidCollection.Add(hashKey, new List<long>());
                }

                // NOTE: we are also converting the ulong xuid to a long xuid for later consumption
                hashXuidCollection[hashKey].Add(UncheckedConvert.ToInt64(xuid));
            }

            return hashXuidCollection;
        }
    }

    public class ScatterGatherQueryTaskItem
    {
        public IList<long> XuidList { get; set; }

        public int Partition { get; set; }

        public int GameId { get; set; }

        public int Variant { get; set; }

        public int Datagroup { get; set; }

        internal UserProfileStorageWebstore UserDataStorageWebstore { get; set; }
    }

    public class UserProfileScatterGatherTask : ScatterGatherTask<ScatterGatherQueryTaskItem, IList<UserStatsEx>>
    {
        public override IList<UserStatsEx> Execute(ScatterGatherQueryTaskItem input)
        {
            return input.UserDataStorageWebstore.GetStatsForXuids(input);
        }
    }

    public class UncheckedConvert
    {
        public static Int64 ToInt64(UInt64 number)
        {
            unchecked
            {
                Int64 converted = (Int64)number;
                return converted;
            }
        }

        public static UInt64 ToUInt64(Int64 number)
        {
            unchecked
            {
                UInt64 converted = (UInt64)number;
                return converted;
            }
        }

        public static Int32 ToInt32(UInt32 number)
        {
            unchecked
            {
                Int32 converted = (Int32)number;
                return converted;
            }
        }

        public static UInt32 ToUInt32(Int32 number)
        {
            unchecked
            {
                UInt32 converted = (UInt32)number;
                return converted;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\WebstoreToGdsConverterUtil.cs ===
﻿namespace Gds.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Xml;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;

    internal static class WebstoreToGdsConverterUtil
    {
        public static Entry ConvertToProperty(string property, UserStatsEx userStatRow)
        {
            string name = property;
            string value = FetchPropertyValue(property, userStatRow);

            if (string.IsNullOrEmpty(value))
            {
                return null;
            }

            Entry statEntry = new Entry()
            {
                Name = property,
                Value = value
            };

            return statEntry;
        }

        public static IList<Entry> CreateStatisticListForUser(UserStatsEx userStatRow, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            List<Entry> statListForUser = new List<Entry>(12);

            IUserStorageConverterFilter filter = null;
            converterList.TryGetValue(StatisticsConstants.BestTime, out filter);

            statListForUser.Add(ConvertToProperty(StatisticsConstants.GamesPlayed, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.LastPlayedDateTime, userStatRow)); // converted
            statListForUser.Add(ConvertToProperty(StatisticsConstants.CumulativeTime, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.CumulativeScore, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.BestTime, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.BestScore, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.Wins, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.Losses, userStatRow));
            statListForUser.Add(ConvertToProperty(StatisticsConstants.AverageScore, userStatRow)); // generated
            statListForUser.Add(ConvertToProperty(StatisticsConstants.AverageTime, userStatRow)); // generated
            
            if (IsTimeLeaderboard(converterList))
            {
                statListForUser.Add(ConvertToProperty(StatisticsConstants.BestTimeDataBlobId, userStatRow));
            }

            if (IsScoreLeaderboard(converterList))
            {
                statListForUser.Add(ConvertToProperty(StatisticsConstants.BestScoreDataBlobId, userStatRow));
            }

            // ensure no null Entry does exist.
            statListForUser.RemoveAll((Entry entry) => entry == null);

            return statListForUser;
        }

        private static string FetchPropertyValue(string property, UserStatsEx userStatRow)
        {
            long defaultLongValue = 0;

            if (string.Equals(property, StatisticsConstants.BestScore, StringComparison.OrdinalIgnoreCase))
            {
                return userStatRow.BestScore.ToStringOrNull();
            }
            else if (string.Equals(property, StatisticsConstants.BestTime, StringComparison.OrdinalIgnoreCase))
            {
                // time can NOT be negative
                return userStatRow.BestTime.ToStringOrNull(true);
            }
            else if (string.Equals(property, StatisticsConstants.BestScoreDataBlobId, StringComparison.OrdinalIgnoreCase) ||
                     string.Equals(property, StatisticsConstants.BestTimeDataBlobId, StringComparison.OrdinalIgnoreCase))
            {
                return userStatRow.BlobID.ToStringOrEmtpy();
            }
            else if (string.Equals(property, StatisticsConstants.CumulativeScore, StringComparison.OrdinalIgnoreCase))
            {
                return userStatRow.CumulativeScore.ToStringOrNull();
            }
            else if (string.Equals(property, StatisticsConstants.CumulativeTime, StringComparison.OrdinalIgnoreCase))
            {
                // time properties can NOT be negative.
                return userStatRow.CumulativeTime.ToStringOrNull(true);
            }
            else if (string.Equals(property, StatisticsConstants.GamesPlayed, StringComparison.OrdinalIgnoreCase))
            {
                // GamesPlayed can NOT be negative
                return userStatRow.GamesPlayed.ToStringOrNull(true);
            }
            else if (string.Equals(property, StatisticsConstants.AverageScore, StringComparison.OrdinalIgnoreCase))
            {
                if (userStatRow.CumulativeScore.HasValue)
                {
                    long cumulativeScore = userStatRow.CumulativeScore.Value;
                    long gamesPlayed = userStatRow.GamesPlayed ?? defaultLongValue;

                    return ((gamesPlayed > 0) ? (cumulativeScore / gamesPlayed) : defaultLongValue).ToString();
                }

                return null;
            }
            else if (string.Equals(property, StatisticsConstants.AverageTime, StringComparison.OrdinalIgnoreCase))
            {
                // Average Time can NOT be negative
                if (userStatRow.CumulativeTime.HasValue)
                {
                    ulong cumulativeTime = Convert.ToUInt64(userStatRow.CumulativeTime.Value);
                    ulong gamesPlayed = Convert.ToUInt64(userStatRow.GamesPlayed ?? defaultLongValue);

                    return ((gamesPlayed > 0) ? (cumulativeTime / gamesPlayed) : (ulong)defaultLongValue).ToString();
                }

                return null;
            }
            else if (string.Equals(property, StatisticsConstants.LastPlayedDateTime, StringComparison.OrdinalIgnoreCase))
            {
                return XmlConvert.ToString(userStatRow.DTUpdated, XmlDateTimeSerializationMode.Utc);
            }
            else if (string.Equals(property, StatisticsConstants.Losses, StringComparison.OrdinalIgnoreCase))
            {
                // Losses can NOT be negative
                return userStatRow.Losses.ToStringOrNull(true);
            }
            else if (string.Equals(property, StatisticsConstants.Wins, StringComparison.OrdinalIgnoreCase))
            {
                // Wins can NOT be negative
                string returnString = userStatRow.Wins.ToStringOrNull(true);

                // wins SHOULD NOT be null if there is a LOSS value
                if (string.IsNullOrEmpty(returnString) && userStatRow.Losses.HasValue)
                {
                    return defaultLongValue.ToString();
                }

                return returnString;
            }

            throw new InvalidOperationException("Invalid Property Request");
        }

        private static bool IsTimeLeaderboard(IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            return IsFilterWithAliasPresent(converterList, StatisticsConstants.BestTime, false);
        }

        private static bool IsScoreLeaderboard(IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            return IsFilterWithAliasPresent(converterList, StatisticsConstants.BestScore, false);
        }

        private static bool IsFilterWithAliasPresent(
                        IDictionary<string, IUserStorageConverterFilter> converterList,
                        string alias,
                        bool isRemoved)
        {
            IUserStorageConverterFilter returnFilter = converterList.Values.FirstOrDefault((IUserStorageConverterFilter filter) =>
                                    filter.AliasName.Equals(alias, StringComparison.OrdinalIgnoreCase) && (filter.IsRemoved == isRemoved));

            if (returnFilter != null)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Extension Method
        /// </summary>
        /// <param name="specialLong"></param>
        /// <returns></returns>
        public static string ToStringOrNull(this long? specialLong)
        {
            return specialLong.ToStringOrNull(false);
        }

        /// <summary>
        /// Extension Method
        /// </summary>
        /// <param name="specialLong"></param>
        /// <returns></returns>
        public static string ToStringOrNull(this long? specialLong, bool treatAsUnsigned)
        {
            if (specialLong.HasValue)
            {
                if (treatAsUnsigned)
                {
                    return Convert.ToUInt64(specialLong.Value).ToString();
                }

                return specialLong.ToString();
            }

            return null;
        }


        /// <summary>
        /// Extention Method.
        /// </summary>
        /// <param name="specialGuid"></param>
        /// <returns></returns>
        public static string ToStringOrEmtpy(this Guid? specialGuid)
        {
            if (specialGuid.HasValue)
            {
                return specialGuid.ToString();
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData.Test\UserDataStorageTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Data.Linq;
using Rhino.Mocks;
using GDS.DataAccess.UserData;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.TestUtilities;
using Leet.Core.Configuration;

namespace GDS.DataAccess.UserData.Test
{
    /// <summary>
    /// Summary description for UserDataTests
    /// </summary>
    [TestClass]
    public class UserDataStorageTests
    {
        public UserDataStorageTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void UserDataStorage()
        {
            // setup
            var settingName = "lest_userprofilestore_db";
            string connectionString = "Data Source=someserver;Initial Catalog=UserProfile;Integrated Security=True";
            IConfigurationProvider configProvider = new Stubber().RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(cp => cp.GetConnectionString(settingName)).Return(connectionString);

            // execute
            var target = new UserDataStorage();

            // verify
            Assert.IsInstanceOfType(target, typeof(UserDataStorage));
        }

        private IList<GameData> GetGameList()
        {
            IList<GameData> gd = new List<GameData>();
            GameData gameData = new GameData();
            gameData.GameId = 1;
            gameData.LastPlayedDateTime = Convert.ToDateTime("1/1/2009");
            gd.Add(gameData);

            GameData gameData1 = new GameData();
            gameData1.GameId = 2;
            gameData1.LastPlayedDateTime = Convert.ToDateTime("7/7/2008");
            gd.Add(gameData1);

            return gd;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GDS.DataAccess.UserData.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=SAVASGTST3;Initial Catalog=UserProfile;Integrated Security=True")]
        public string UserProfileConnectionString {
            get {
                return ((string)(this["UserProfileConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserProfileWebstore.designer.cs ===
﻿#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Gds.DataAccess.UserData
{
    using System;
    using System.Data.Linq;
    using System.Collections.Generic;
    using Microsoft.Webstore.WstClient;
    using System.Data;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using Microsoft.Webstore.MetaData;

    public class UserProfileWebstore
    {
        // proc_GetStatsForUsers datareader column positions.
        internal const int XuidGetStatsForUsersColumnPos = 0;
        internal const int si_HashBucketGetStatsForUsersColumnPos = 1;
        internal const int PlatformIDGetStatsForUsersColumnPos = 2;
        internal const int GameEventIDStatsForUsersColumnPos = 3;
        internal const int GameSessionIDGetStatsForUsersColumnPos = 4;
        internal const int DTCreatedGetStatsForUsersColumnPos = 5;
        internal const int DTUpdatedGetStatsForUsersColumnPos = 6;
        internal const int BlobIDGetStatsForUsersColumnPos = 7;
        internal const int BestScoreGetStatsForUsersColumnPos = 8;
        internal const int BestTimeGetStatsForUsersColumnPos = 9;
        internal const int CumulativeScoreGetStatsForUsersColumnPos = 10;
        internal const int CumulativeTimeGetStatsForUsersColumnPos = 11;
        internal const int WinsGetStatsForUsersColumnPos = 12;
        internal const int LossesGetStatsForUsersColumnPos = 13;
        internal const int GamesPlayedGetStatsForUsersColumnPos = 14;
        internal const int PropertyBagIdGetStatsForUsersColumnPos = 15;

        internal const int ErrorMessageSize = 400;
        // time out for WstCommand, this is the SQL time out for the stored procdure
        // this is used only for Writes
        internal const int WstCommandTimeout = 120;  

        public string DeploymentName { get; private set; }
        public int PartitionCount { get; private set; }

        public UserProfileWebstore(string deploymentName)
        {
            this.DeploymentName = deploymentName;
            this.PartitionCount = WebstoreMetaData.Instance.DefaultConfig.Deployments[this.DeploymentName].Partitions.Count;
        }

        /// <summary>
        /// This function simply constructs and performs the query for the given parameters on the partition provided.
        /// </summary>
        /// <param name="xuidList"></param>
        /// <param name="partition"></param>
        /// <param name="gameID"></param>
        /// <param name="variant"></param>
        /// <param name="datagroup"></param>
        /// <param name="errCode"></param>
        /// <param name="errMsg"></param>
        public List<UserStatsEx> proc_GetStatsForUsers(string xuidList, int partition, int gameID, int variant, int datagroup, ref int errCode, ref string errMsg)
        {
            List<UserStatsEx> returnList = new List<UserStatsEx>();
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_GetStatsForUsersString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultRead;

                    SqlParameterCollection sqlParams = command.Parameters;
                    sqlParams.AddWithValue("@XuidList", xuidList);
                    //sqlParams.AddWithValue("@si_HashBucket", partition);
                    sqlParams.AddWithValue("@GameID", gameID);
                    sqlParams.AddWithValue("@Variant", variant);
                    sqlParams.AddWithValue("@Datagroup", datagroup);

                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;

                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int, 10);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    using (WstDataReader wds = command.ExecuteReader())
                    {
                        // for each Row.
                        while(wds.Read())
                        {
                            UserStatsEx row = new UserStatsEx()
                            {
                                Xuid = wds.GetSqlInt64(UserProfileWebstore.XuidGetStatsForUsersColumnPos).Value,
                                si_HashBucket = wds.GetSqlInt16(UserProfileWebstore.si_HashBucketGetStatsForUsersColumnPos).Value,
                                GameID = gameID,
                                Variant = variant,
                                Datagroup = datagroup,
                                PlatformID = wds.GetSqlInt32(UserProfileWebstore.PlatformIDGetStatsForUsersColumnPos).Value,
                                GameEventID = wds.GetSqlGuid(UserProfileWebstore.GameEventIDStatsForUsersColumnPos).Value,
                                GameSessionID = wds.GetSqlGuid(UserProfileWebstore.GameSessionIDGetStatsForUsersColumnPos).Value,
                                DTCreated = wds.GetSqlDateTime(UserProfileWebstore.DTCreatedGetStatsForUsersColumnPos).Value,
                                DTUpdated = wds.GetSqlDateTime(UserProfileWebstore.DTUpdatedGetStatsForUsersColumnPos).Value,
                                BlobID = Converters.Convert(wds.GetSqlGuid(UserProfileWebstore.BlobIDGetStatsForUsersColumnPos)),
                                BestScore = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.BestScoreGetStatsForUsersColumnPos)),
                                BestTime = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.BestTimeGetStatsForUsersColumnPos)),
                                CumulativeScore = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.CumulativeScoreGetStatsForUsersColumnPos)),
                                CumulativeTime = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.CumulativeTimeGetStatsForUsersColumnPos)),
                                Wins = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.WinsGetStatsForUsersColumnPos)),
                                Losses = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.LossesGetStatsForUsersColumnPos)),
                                GamesPlayed = Converters.Convert(wds.GetSqlInt64(UserProfileWebstore.GamesPlayedGetStatsForUsersColumnPos)),
                                PropertyBagId = Converters.Convert(wds.GetSqlGuid(UserProfileWebstore.PropertyBagIdGetStatsForUsersColumnPos))
                            };
                            
                            returnList.Add(row);
                        }
                    }

                    errCode = (int)sqlErrCode.Value;
                    errMsg = (string)sqlErrValue.Value;
                }
            }

            return returnList;
        }

        public int proc_InsertUserStatValue(
                    long xuid,
                    short partition,
                    int gameID,
                    int variant,
                    int datagroup,
                    int platformID,
                    Guid gameEventID,
                    Guid gameSessionID,
                    DateTime dTCreated,
                    DateTime dTUpdated,
                    Nullable<Guid> blobID,
                    Nullable<long> bestScore,
                    Nullable<long> bestTime,
                    Nullable<long> cumulativeScore,
                    Nullable<long> cumulativeTime,
                    Nullable<long> wins,
                    Nullable<long> losses,
                    Nullable<long> gamesPlayed,
                    Nullable<Guid> propertyBagId,
                    ref int errCode,
                    ref string errMsg)
        {
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_InsertUserStatValueString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultWrite;
                    command.CommandTimeout = WstCommandTimeout;

                    SqlParameterCollection sqlParams = command.Parameters;

                    sqlParams.AddWithValue("@Xuid", xuid);
                    sqlParams.AddWithValue("@si_HashBucket", partition);
                    sqlParams.AddWithValue("@GameID", gameID);
                    sqlParams.AddWithValue("@Variant", variant);
                    sqlParams.AddWithValue("@Datagroup", datagroup);
                    sqlParams.AddWithValue("@PlatformID", platformID);
                    sqlParams.AddWithValue("@GameEventID", gameEventID);
                    sqlParams.AddWithValue("@GameSessionID", gameSessionID);
                    sqlParams.AddWithValue("@DTCreated", dTCreated);
                    sqlParams.AddWithValue("@DTUpdated", dTUpdated);
                    sqlParams.AddWithValue("@BlobID", blobID);
                    sqlParams.AddWithValue("@BestScore", bestScore);
                    sqlParams.AddWithValue("@BestTime", bestTime);
                    sqlParams.AddWithValue("@CumulativeScore", cumulativeScore);
                    sqlParams.AddWithValue("@CumulativeTime", cumulativeTime);
                    sqlParams.AddWithValue("@Wins", wins);
                    sqlParams.AddWithValue("@Losses", losses);
                    sqlParams.AddWithValue("@GamesPlayed", gamesPlayed);
                    sqlParams.AddWithValue("@PropertyBagId", propertyBagId);
                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;

                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int, 10);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    errCode = (int)sqlErrCode.Value;
                    errMsg = sqlErrValue.Value.ToString();
                }
            }

            return errCode;
        }

        public int proc_GetDataBlob(Guid blobID, int partition, int maxblobSize, ref DateTime dTUpdated, ref DateTime dTCreated, ref byte[] buffer, ref int errCode, ref string errMsg)
        {
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_GetDataBlobString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultRead;

                    SqlParameterCollection sqlParams = command.Parameters;

                    sqlParams.AddWithValue("@BlobID", blobID);

                    SqlParameter sqlDTUpdated = sqlParams.Add("@DTUpdated", SqlDbType.DateTime);
                    sqlDTUpdated.Direction = ParameterDirection.Output;
                    SqlParameter sqlDTCreated = sqlParams.Add("@DTCreated", SqlDbType.DateTime);
                    sqlDTCreated.Direction = ParameterDirection.Output;
                    SqlParameter sqlBlob = sqlParams.Add("@Blob", SqlDbType.VarBinary, maxblobSize);
                    sqlBlob.Direction = ParameterDirection.Output;

                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;

                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    errCode = (int)sqlErrCode.Value;
                    errMsg = sqlErrValue.Value.ToString();
                    
                    if (errCode == 0)
                    {
                        buffer = (byte[])sqlBlob.Value;
                    }
                }
            }
            
            return errCode;
        }

        public int proc_InsertDataBlob(Guid blobID, int partition, DateTime dTUpdated, DateTime dTCreated, byte[] buffer, ref int errCode, ref string errMsg)
        {
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_InsertDataBlobString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultWrite;
                    command.CommandTimeout = WstCommandTimeout;

                    SqlParameterCollection sqlParams = command.Parameters;

                    sqlParams.AddWithValue("@BlobID", blobID);
                    sqlParams.AddWithValue("@DTUpdated", dTUpdated);
                    sqlParams.AddWithValue("@si_HashBucket", (short)partition);
                    sqlParams.AddWithValue("@Blob", buffer);

                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;

                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    errCode = (int)sqlErrCode.Value;
                    errMsg = sqlErrValue.Value.ToString();
                }
            }

            return errCode;
        }

        public int proc_UpdateDataBlob(Guid blobID, int partition, DateTime dTUpdated, byte[] buffer, ref int errCode, ref string errMsg)
        {
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_UpdateDataBlobString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultWrite;
                    command.CommandTimeout = WstCommandTimeout;

                    SqlParameterCollection sqlParams = command.Parameters;

                    sqlParams.AddWithValue("@BlobID", blobID);
                    sqlParams.AddWithValue("@DTUpdated", dTUpdated);
                    sqlParams.AddWithValue("@Blob", buffer);

                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;
                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    errCode = (int)sqlErrCode.Value;
                    errMsg = sqlErrValue.Value.ToString();
                }
            }

            return errCode;
        }

        public int proc_RemoveDataBlob(Guid blobID, int partition, ref int errCode, ref string errMsg)
        {
            using (WstConnection conn = new WstConnection(this.DeploymentName))
            {
                conn.Open();
                using (WstCommand command = conn.CreateCommand())
                {
                    command.CommandText = UserProfileWebstore.proc_RemoveDataBlobString;
                    command.CommandType = CommandType.StoredProcedure;
                    command.Partition = partition;
                    command.WstFailoverMode = WstFailoverMode.DefaultWrite;
                    command.CommandTimeout = WstCommandTimeout;

                    SqlParameterCollection sqlParams = command.Parameters;

                    sqlParams.AddWithValue("@BlobID", blobID);

                    sqlParams.Add("@ErrCode", SqlDbType.Int).Direction = ParameterDirection.Output;
                    SqlParameter sqlErrValue = sqlParams.Add("@ErrMsg", SqlDbType.VarChar);
                    sqlErrValue.Size = UserProfileWebstore.ErrorMessageSize;
                    sqlErrValue.Direction = ParameterDirection.Output;

                    SqlParameter sqlErrCode = sqlParams.Add("@ErrCode", SqlDbType.Int);
                    sqlErrCode.Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    errCode = (int)sqlErrCode.Value;
                    errMsg = sqlErrValue.Value.ToString();
                }
            }

            return errCode;
        }

        private const string proc_GetStatsForUsersString = "proc_GetStatsForUsers";
        private const string proc_InsertUserStatValueString = "proc_InsertUserStatValue";
        private const string proc_GetDataBlobString = "proc_GetDataBlob";
        private const string proc_InsertDataBlobString = "proc_InsertDataBlob";
        private const string proc_UpdateDataBlobString = "proc_UpdateDataBlob";
        private const string proc_RemoveDataBlobString = "proc_RemoveDataBlob";
    }

    public partial class UserStatsEx 
    {
        public UserStatsEx()
        {
        }

        public long Xuid { get; set; }
        public short si_HashBucket { get; set; }
        public int GameID { get; set; }
        public int Variant { get; set; }
        public int Datagroup { get; set; }
        public int PlatformID { get; set; }
        public Guid GameEventID { get; set; }
        public Guid GameSessionID { get; set; }
        public DateTime DTCreated { get; set; }
        public DateTime DTUpdated { get; set; }
        public Nullable<Guid> BlobID { get; set; }
        public Nullable<long> BestScore { get; set; }
        public Nullable<long> BestTime { get; set; }
        public Nullable<long> CumulativeScore { get; set; }
        public Nullable<long> CumulativeTime { get; set; }
        public Nullable<long> Wins { get; set; }
        public Nullable<long> Losses { get; set; }
        public Nullable<long> GamesPlayed { get; set; }
        public Nullable<Guid> PropertyBagId { get; set; }
    }

    public partial class StatBlob 
    {
        public Guid BlobID { get; set; }
        public short si_HashBucket { get; set; }
        public Binary Blob { get; set; }
        public DateTime DTCreated { get; set; }
        public DateTime DTUpdated { get; set; }
    }

    public static class Converters
    {
        public static Guid? Convert(SqlGuid sqlGuid)
        {
            if (sqlGuid.IsNull)
            {
                return null;
            }

            return sqlGuid.Value;
        }

        public static long? Convert(SqlInt64 sqlLongValue)
        {
            if (sqlLongValue.IsNull)
            {
                return null;
            }

            return sqlLongValue.Value;
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\UserProfileStorageLivecache.cs ===
﻿// <copyright file="UserProfileStorageLivecache.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-06-02</date>
// <summary>Contains the implementation of the UserProfileStorageLivecache class.</summary>

namespace Gds.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Net;
    using System.Xml;
    using Contracts;
    using GameMetadata.Common;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using xonline.common.protocol;
    using xonline.common.webplatform.livecache;
    using xonline.common.xlastutil;

    /// <summary>
    /// Implementation of IUserProfileStorageSimple which uses live cache as the backend.
    /// </summary>
    public class UserProfileStorageLivecache : IUserProfileStorageSimple
    {
        /// <summary>
        /// The column id of attachment size.
        /// </summary>
        public const ushort AttachmentSizeColumnId = 65530; // -6 when it is short

        /// <summary>
        /// Array of all the mobile columnIds.
        /// </summary>
        private static readonly ushort[] ColumnIds;

        /// <summary>
        /// The format to be used for creating the storage path for attachments (blobs).
        /// </summary>
        private const string AttachmentPathFormat = "//xestats/u:{0}/{1}/{2}";

        /// <summary>
        /// Initializes static members of the UserProfileStorageLivecache class.
        /// </summary>
        static UserProfileStorageLivecache()
        {
            List<ushort> columnIdList = new List<ushort>();
            var statsColumns = MobileAndWebLeaderboardUtils.MobileColData.Keys;
            foreach (var column in statsColumns)
            {
                columnIdList.Add(MobileAndWebLeaderboardUtils.MobileColData[column].AttributeId);
            }

            // Add the attachmentSize column too.
            columnIdList.Add(AttachmentSizeColumnId);

            ColumnIds = columnIdList.ToArray();
        }

        /// <summary>
        /// Gets the blobId.
        /// </summary>
        /// <param name="ownerXuid">The xuid of the blob owner.</param>
        /// <param name="gameId">The gameId based on which to get the BlobId.</param>
        /// <param name="leaderboardId">The leaderboardId based on which to get the BlobId.</param>
        /// <returns>The blobId.</returns>
        public static string GetBlobId(ulong ownerXuid, uint gameId, int leaderboardId)
        {
            byte[] bytes;

            byte[] xuidBytes = BitConverter.GetBytes(ownerXuid);
            byte[] gameIdBytes = BitConverter.GetBytes(gameId);
            byte[] leaderboardIdBytes = BitConverter.GetBytes(leaderboardId);

            bytes = new byte[xuidBytes.Length + gameIdBytes.Length + leaderboardIdBytes.Length];

            Buffer.BlockCopy(xuidBytes, 0, bytes, 0, xuidBytes.Length);
            Buffer.BlockCopy(gameIdBytes, 0, bytes, xuidBytes.Length, gameIdBytes.Length);
            Buffer.BlockCopy(leaderboardIdBytes, 0, bytes, xuidBytes.Length + gameIdBytes.Length, leaderboardIdBytes.Length);

            Guid blobGuid = new Guid(bytes);
            return blobGuid.ToString();
        }

        /// <summary>
        /// Gets the path of the attachment.
        /// </summary>
        /// <param name="userXuid">The user's xuid.</param>
        /// <param name="gameId">The titleId for the attachment.</param>
        /// <param name="leaderboardId">The leaderboardId for the attachment.</param>
        /// <returns>The path of the attachment.</returns>
        public static string GetAttachmentPath(ulong userXuid, uint gameId, int leaderboardId)
        {
            string attachmentPath = string.Format(
                                                AttachmentPathFormat,
                                                userXuid.ToString("x"),
                                                gameId.ToString("x8"),
                                                leaderboardId.ToString("x8"));

            return attachmentPath;
        }

        /// <summary>
        /// Gets the rating column based on the property.
        /// </summary>
        /// <param name="property">The property string.</param>
        /// <returns>The rating column based on the property string.</returns>
        public static MobileAndWebRatingColumn GetRatingColumn(string property)
        {
            MobileAndWebRatingColumn ratingColumn;
            if (string.Compare(property, StatisticsConstants.BestScore, true) == 0)
            {
                ratingColumn = MobileAndWebRatingColumn.BestScore;
            }
            else
            {
                if (string.Compare(property, StatisticsConstants.BestTime, true) == 0)
                {
                    ratingColumn = MobileAndWebRatingColumn.BestTime;
                }
                else
                {
                    if (string.Compare(property, StatisticsConstants.Wins, true) == 0)
                    {
                        ratingColumn = MobileAndWebRatingColumn.MostWins;
                    }
                    else
                    {
                        throw new ArgumentOutOfRangeException("property", property, "This property is not supported.");
                    }
                }
            }

            return ratingColumn;
        }

        /// <summary>
        /// Gets the leaderboard stats for a set of Xbox Ids.
        /// </summary>
        /// <param name="gameId">The title for which to get the stats.</param>
        /// <param name="variant">The game variant for which to get the stats.</param>
        /// <param name="dataGroupName">The datagroup for which to get the stats.</param>
        /// <param name="xuidList">The set of Xuids for which to get the stats.</param>
        /// <param name="property">The property for which to get the stats.</param>
        /// <param name="callingXuid">The xuid of the user on behalf of which the call is being made.</param>
        /// <param name="statRanking">The stat ranking for the property.</param>
        /// <returns>The leaderboard stats for the set of Xbox Ids.</returns>
        public IList<StatsResult> GetStatsForXuids(
            uint gameId, uint variant, string dataGroupName, List<ulong> xuidList, string property, ulong callingXuid, StatRanking statRanking)
        {
            MobileAndWebRatingColumn ratingColumn = GetRatingColumn(property);
            MobileAndWebLeaderboardType leaderboardType = GetLeaderboardType(dataGroupName);
            int leaderboardId = MobileAndWebLeaderboardUtils.GetLeaderboardId(variant, ratingColumn, leaderboardType);

            StatsReadResponse readResponse = GetStatsReadResponse(xuidList, leaderboardId, gameId, callingXuid);

            return GetStatsFromResponse(readResponse, ratingColumn, statRanking, gameId, leaderboardId);
        }

        /// <summary>
        /// Gets the leaderboard blob.
        /// </summary>
        /// <param name="blobId">The blobId for which to get the blob.</param>
        /// <returns>The leaderboard blob.</returns>
        public byte[] GetBlob(Guid blobId)
        {
            byte[] blobGuidBytes = blobId.ToByteArray();

            ulong ownerXuid = BitConverter.ToUInt64(blobGuidBytes, 0);      // First 8 bytes are for owner's xuid.
            uint gameId = BitConverter.ToUInt32(blobGuidBytes, 8);          // Next 4 bytes are gameId.
            int leaderboardId = BitConverter.ToInt32(blobGuidBytes, 12);    // Rest of the bytes are the leaderboardId.

            ILcTitleStorage titleStorage = Container.Instance.GetComponent<ILcTitleStorage>();

            byte[] resultBytes = null;
            try
            {
                resultBytes = titleStorage.StorageRead(GetAttachmentPath(ownerXuid, gameId, leaderboardId), gameId, LivecacheClientType.LIVEn);
            }
            catch (LivecacheResponseException ex)
            {
                if (ex.HResult == xonline.common.service.HResult.XONLINE_E_STORAGE_FILE_NOT_FOUND)
                {
                    throw new UserProfileDataAccessOperationException(
                        ex.Message, UserProfileDataAccessOperationException.NoEntryFound, string.Empty);
                }
                else
                {
                    LIVEnException le = new LIVEnException(
                                            UserDataEvents.Events,
                                            UserDataEvents.LiveCacheError,
                                            HttpStatusCode.InternalServerError,
                                            ex,
                                            "GetBlob",
                                            true);

                    le.ThrowWebProtocolException();
                }
            }

            return resultBytes;
        }

        /// <summary>
        /// Gets the leaderboards stats read response for a set of users.
        /// </summary>
        /// <param name="xuidList">The list of xuids for which to get the leaderboard response.</param>
        /// <param name="leaderboardId">The leaderboardId.</param>
        /// <param name="gameId">The titleId.</param>
        /// <param name="callingXuid">The Xuid of the user who is making the request.</param>
        /// <returns>The leaderboards stats read response for a set of users.</returns>
        private static StatsReadResponse GetStatsReadResponse(IList<ulong> xuidList, int leaderboardId, uint gameId, ulong callingXuid)
        {
            StatsReadRequest request = new StatsReadRequest
                                           {
                                               TitleId = gameId,
                                               UserCount = (uint)xuidList.Count,
                                               Users = new ulong[xuidList.Count],
                                               SpecCount = 1,
                                               Specs = new StatsSpec[1]
                                           };

            for (int i = 0; i < xuidList.Count; i++)
            {
                request.Users[i] = xuidList[i];
            }

            request.Specs[0] = new StatsSpec { ViewId = (uint)leaderboardId, ColumnCount = (uint)ColumnIds.Length, ColumnIds = ColumnIds };

            ILcLeaderboards liveCacheLbds = Container.Instance.GetComponent<ILcLeaderboards>();
            StatsReadResponse statsReadResponse = liveCacheLbds.GetFriendsLeaderboardInfo(request, callingXuid);

            return statsReadResponse;
        }

        /// <summary>
        /// Gets the stats from the live cache response.
        /// </summary>
        /// <param name="statsReadResponse">The live cache stats read response.</param>
        /// <param name="ratingColumn">The rating column for the leaderboard.</param>
        /// <param name="rankingOrder">The ranking order for the rating column.</param>
        /// <param name="gameId">The titleId.</param>
        /// <param name="leaderboardId">The leaderboardId for the stats response.</param>
        /// <returns>The stats from the live cache response.</returns>
        private static IList<StatsResult> GetStatsFromResponse(
            StatsReadResponse statsReadResponse, MobileAndWebRatingColumn ratingColumn, StatRanking rankingOrder, uint gameId, int leaderboardId)
        {
            IList<StatsResult> statsResults = new List<StatsResult>();
            StatsRow[] statsRows = statsReadResponse.Results[0].Rows;

            foreach (var row in statsRows)
            {
                // If the user does not have the stat that determines ranking, do not include him/her.
                if (row.Rank == 0)
                {
                    continue;
                }

                StatsResult statsResult = new StatsResult() { Xuid = row.Puid };
                statsResult.Statistics = new List<Entry>();
                string blobId = GetBlobId(row.Puid, gameId, leaderboardId);

                foreach (var column in row.Columns)
                {
                    Entry entry = GetEntry(column, row, ratingColumn, rankingOrder, blobId);

                    if (entry != null)
                    {
                        statsResult.Statistics.Add(entry);
                    }
                }

                AddAverageStats(statsResult.Statistics);

                statsResults.Add(statsResult);
            }

            return statsResults;
        }

        /// <summary>
        /// Adds the average stats (average score/average time) to the entries.
        /// </summary>
        /// <param name="statColumns">The stats list.</param>
        private static void AddAverageStats(IList<Entry> statColumns)
        {
            const long DefaultLongValue = 0;

            long? cumulativeScoreNullable = null;
            ulong? cumulativeTimeNullable = null;
            long? gamesPlayedNullable = null;

            foreach (var statColumn in statColumns)
            {
                switch (statColumn.Name)
                {
                    case StatisticsConstants.CumulativeScore:
                        cumulativeScoreNullable = long.Parse(statColumn.Value);
                        break;
                    case StatisticsConstants.CumulativeTime:
                        cumulativeTimeNullable = ulong.Parse(statColumn.Value);
                        break;
                    case StatisticsConstants.GamesPlayed:
                        gamesPlayedNullable = long.Parse(statColumn.Value);
                        break;
                    default:
                        break;
                }
            }

            if (cumulativeScoreNullable.HasValue)
            {
                long cumulativeScore = cumulativeScoreNullable.Value;
                long gamesPlayed = gamesPlayedNullable ?? DefaultLongValue;

                long averageScore = (gamesPlayed > 0) ? (cumulativeScore / gamesPlayed) : DefaultLongValue;
                statColumns.Add(new Entry() { Name = StatisticsConstants.AverageScore, Value = averageScore.ToString() });
            }

            if (cumulativeTimeNullable.HasValue)
            {
                ulong cumulativeTime = Convert.ToUInt64(cumulativeTimeNullable.Value);
                ulong gamesPlayed = Convert.ToUInt64(gamesPlayedNullable ?? DefaultLongValue);

                ulong averageTime = (gamesPlayed > 0) ? (cumulativeTime / gamesPlayed) : (ulong) DefaultLongValue;
                statColumns.Add(new Entry() { Name = StatisticsConstants.AverageTime, Value = averageTime.ToString() });
            }
        }

        /// <summary>
        /// Get the entry based on the params.
        /// </summary>
        /// <param name="column">The column to get entry for.</param>
        /// <param name="row">The row that the column is for.</param>
        /// <param name="ratingColumn">The rating column for the row.</param>
        /// <param name="rankingOrder">The stat ranking order.</param>
        /// <param name="blobId">The blobId.</param>
        /// <returns>The entry based on the params.</returns>
        private static Entry GetEntry(StatsColumn column, StatsRow row, MobileAndWebRatingColumn ratingColumn, StatRanking rankingOrder, string blobId)
        {
            string columnName;
            string columnValue = column.Data.ToString();

            if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.BestScore].AttributeId)
            {
                // If the base column is same as rating column, ignore the base column.
                if ((rankingOrder == StatRanking.High) && (ratingColumn == MobileAndWebRatingColumn.BestScore))
                {
                    columnName = null;
                }
                else
                {
                    columnName = StatisticsConstants.BestScore;
                    columnValue = GetScoreValue(columnValue);
                }
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.BestTime].AttributeId)
            {
                // If the base column is same as rating column, ignore the base column.
                if ((rankingOrder == StatRanking.High) && (ratingColumn == MobileAndWebRatingColumn.BestTime))
                {
                    columnName = null;
                }
                else
                {
                    columnName = StatisticsConstants.BestTime;
                }
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.GamesPlayed].AttributeId)
            {
                columnName = StatisticsConstants.GamesPlayed;
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.LastPlayedDateTime].AttributeId)
            {
                columnName = StatisticsConstants.LastPlayedDateTime;

                // Change the date time to the expected format.
                DateTime lastPlayed = new DateTime((long)column.Data);
                columnValue = XmlConvert.ToString(lastPlayed, XmlDateTimeSerializationMode.Utc);
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Wins].AttributeId)
            {
                // If the base column is same as rating column, ignore the base column.
                if ((rankingOrder == StatRanking.High) && (ratingColumn == MobileAndWebRatingColumn.MostWins))
                {
                    columnName = null;
                }
                else
                {
                    columnName = StatisticsConstants.Wins;
                }
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.CumulativeScore].AttributeId)
            {
                columnName = StatisticsConstants.CumulativeScore;
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.CumulativeTime].AttributeId)
            {
                columnName = StatisticsConstants.CumulativeTime;
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Losses].AttributeId)
            {
                columnName = StatisticsConstants.Losses;
            }
            else if (column.ColumnId == AttachmentSizeColumnId && IsAttachmentSizeNonZero(column))
            {
                switch (ratingColumn)
                {
                    case MobileAndWebRatingColumn.BestScore:
                        columnName = StatisticsConstants.BestScoreDataBlobId;
                        columnValue = blobId;
                        break;

                    case MobileAndWebRatingColumn.BestTime:
                        columnName = StatisticsConstants.BestTimeDataBlobId;
                        columnValue = blobId;
                        break;

                    case MobileAndWebRatingColumn.MostWins:
                        columnName = null;
                        break;

                    default:
                        throw new ArgumentOutOfRangeException("ratingColumn", ratingColumn, "Rating column is not supported.");
                }
            }
            else if (column.ColumnId == MobileAndWebLeaderboardUtils.MobileColData[MobileAndWebLeaderboardUtils.MobileStatsColumns.Rating].AttributeId)
            {
                if (rankingOrder == StatRanking.High)
                {
                    // The rating column has zero value, hence use the value from the row.
                    columnValue = row.Rating.ToString();

                    switch (ratingColumn)
                    {
                        case MobileAndWebRatingColumn.BestScore:
                            columnName = StatisticsConstants.BestScore;
                            columnValue = GetScoreValue(columnValue);
                            break;

                        case MobileAndWebRatingColumn.BestTime:
                            columnName = StatisticsConstants.BestTime;
                            break;

                        case MobileAndWebRatingColumn.MostWins:
                            columnName = StatisticsConstants.Wins;
                            break;

                        default:
                            throw new ArgumentOutOfRangeException("ratingColumn", ratingColumn, "Rating column is not supported.");
                    }
                }
                else
                {
                    // Ignore the ranking column in case of descending order, because the other columns will have the required data.
                    columnName = null;
                }
            }
            else
            {
                // Ignore all other columns.
                columnName = null;
            }

            Entry entry;
            if (columnName == null)
            {
                entry = null;
            }
            else
            {
                entry = new Entry() { Name = columnName, Value = columnValue };
            }

            return entry;
        }

        /// <summary>
        /// Is the attachment size non-zero?
        /// </summary>
        /// <param name="attachmentSizeColumn">A stats column that is for the attachment size.</param>
        /// <returns>True if the attachment size is non-zero, false otherwise.</returns>
        private static bool IsAttachmentSizeNonZero(StatsColumn attachmentSizeColumn)
        {
            bool isAttachmentSizeNonZero;

            switch (attachmentSizeColumn.Type)
            {
                case StatParam.Null:
                    isAttachmentSizeNonZero = false;
                    break;

                case StatParam.Int32:
                    int attachmentSize = (int)attachmentSizeColumn.Data;
                    isAttachmentSizeNonZero = attachmentSize != 0;
                    break;

                default:
                    isAttachmentSizeNonZero = false;
                    break;
            }

            return isAttachmentSizeNonZero;
        }

        /// <summary>
        /// Gets the score as a string representation of a long.
        /// </summary>
        /// <param name="columnValue">The value of the column that has the score.</param>
        /// <returns>The score as a string representation of a long.</returns>
        private static string GetScoreValue(string columnValue)
        {
            long result;
            bool isLong = long.TryParse(columnValue, out result);

            // Negative score can be returned as a huge ulong, so parse and convert to long.
            if (!isLong)
            {
                ulong unsignedResult;
                bool isULong = ulong.TryParse(columnValue, out unsignedResult);

                if (isULong)
                {
                    result = (long)unsignedResult;
                }
                else
                {
                    throw new ArgumentOutOfRangeException("columnValue", columnValue, "Column value is neither a long nor a ulong!");
                }
            }

            return result.ToString();
        }

        /// <summary>
        /// Get the leaderboard type based on the datagroup.
        /// </summary>
        /// <param name="dataGroupName">The data group.</param>
        /// <returns>The leaderboard type based on the datagroup.</returns>
        private static MobileAndWebLeaderboardType GetLeaderboardType(string dataGroupName)
        {
            MobileAndWebLeaderboardType leaderboardType;

            UserStatisticsDatagroupEnum datagroupMode = (UserStatisticsDatagroupEnum)Enum.Parse(typeof(UserStatisticsDatagroupEnum), dataGroupName, true);
            switch (datagroupMode)
            {
                case UserStatisticsDatagroupEnum.Lifetime:
                    leaderboardType = MobileAndWebLeaderboardType.Lifetime;
                    break;

                case UserStatisticsDatagroupEnum.W1:
                    leaderboardType = MobileAndWebLeaderboardType.Weekly;
                    break;

                default:
                    throw new ArgumentOutOfRangeException("dataGroupName", dataGroupName, "This datagroup is not supported.");
            }

            return leaderboardType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData\Properties\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.DataAccess.UserData")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("GDS.DataAccess.UserData")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("85b0fbbb-4eef-41a4-9c72-239d575864c4")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.DataAccess.UserData.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.DataAccess.UserData.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("852e7378-a103-45c1-b360-b3bdc0b1a01e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\InMemoryQueue.cs ===
﻿namespace Gds.Mocks
{
    using System;
    using System.Collections.Generic;

    internal class InMemoryQueue
    {
        private static readonly InMemoryQueue instance = new InMemoryQueue();

        private static readonly object lockObject = new object();

        private InMemoryQueue()
        {
            this.Queue = new List<object>();
        }

        public static InMemoryQueue Instance
        {
            get
            {
                return InMemoryQueue.instance;
            }
        }

        private IList<object> Queue { get; set; }

        public void Push<Type>(Type obj)
        {
            lock (InMemoryQueue.lockObject)
            {
                this.Queue.Add(obj as object);
            }
        }

        public Type Pop<Type>()
        {
            Type returnObject = default(Type);
            lock (InMemoryQueue.lockObject)
            {
                if (this.Queue.Count > 0)
                {
                    returnObject = (Type)this.Queue[0];
                    this.Queue.RemoveAt(0);
                }
            }

            return returnObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\GdsTestUtilities.cs ===
﻿namespace Gds.Mocks
{
    using System.IO;

    public static class GdsTestUtilities
    {
        public static string FetchFileContent(string fileName)
        {
            using (StreamReader sr = new StreamReader(fileName))
            {
                return sr.ReadToEnd();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\InMemoryRewardsQueueWriter.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using Gds.Contracts;
    using Gds.Mocks;

    public class InMemoryRewardsQueueWriter : IRewardsQueueWriter
    {
        public void Write(GameEvent gameEvent)
        {
            InMemoryQueue.Instance.Push<GameEvent>(gameEvent);
        }

        public void WriteToJail(GameEvent gameEvent)
        {
            // Do nothing, we do not need to have a Jail for in memory queues.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\InMemoryRewardsQueueReader.cs ===
﻿namespace Gds.DataAccess.Rewards
{
    using System;
    using Gds.Contracts;
    using Gds.Mocks;
    using System.Data.SqlClient;

    public class InMemoryRewardsQueueReader : IRewardsQueueReader
    {
        public GameEvent Read(TimeSpan timeout)
        {
            return InMemoryQueue.Instance.Pop<GameEvent>();
        }

        public GameEvent Read()
        {
            return this.Read(TimeSpan.MaxValue);
        }

        public GameEvent Read(TimeSpan timeout, ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction)
        {
            return this.Read(TimeSpan.MaxValue);
        }

        public void Commit(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction) { }
        public void Rollback(ref SqlConnection sqlConnection, ref SqlTransaction sqlTransaction) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockAuthenticationManager.cs ===
﻿namespace Gds.Mocks
{
    using System;
    using Leet.Identity;
    using System.IdentityModel.Claims;
    public class MockAuthenticationManager : IAuthenticationManager
    {
        internal const ulong DefaultUserXuid = 7L;
        internal const ulong Friend1Xuid = 1L;
        internal const ulong Friend2Xuid = 2L;
        internal const ulong Friend3Xuid = 3L;
        internal const ulong Friend4Xuid = 4L;
        internal const ulong Friend5Xuid = 5L;

        internal const string DefaultUserGamerTag = "James Bond 007";
        internal const string Friend1GamerTag = "J. Baend 001";
        internal const string Friend2GamerTag = "J. Buend 002";
        internal const string Friend3GamerTag = "J. Beund 003";
        internal const string Friend4GamerTag = "J. Beend 004";
        internal const string Friend5GamerTag = "J. Biend 005";

        public IUserIdentity CurrentUser
        {
            get 
            {
                return new MockUserIdentity()
                {
                    Xuid = MockAuthenticationManager.DefaultUserXuid,
                    Gamertag = MockAuthenticationManager.DefaultUserGamerTag,
                    IsAuthenticated = true
                };
            }
        }

        public bool IsAuthenticated
        {
            get { return true; }
        }

        public ClaimSet GetClaims()
        {
            throw new NotImplementedException();
        }

        public IUserIdentity CreateUserIdentityFromKey(string identityKey)
        {
            throw new NotImplementedException();
        }

        public IUserIdentity CreateUserIdentityFromPuid(long puid)
        {
            throw new NotImplementedException();
        }

        public IUserIdentity CreateUserIdentityFromXuid(ulong xuid)
        {
            throw new NotImplementedException();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockConfigurationProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.Configuration;

namespace Gds.Mocks
{
    public class MockConfigurationProvider : IConfigurationProvider
    {
        public Dictionary<String, String> SettingsDictionary = new Dictionary<String, String>();
        public Dictionary<String, String[]> multiSettingsDict = new Dictionary<String, String[]>();
        public MockConfigurationProvider()
        {
            this.SettingsDictionary.Add(Settings.UdsPartnerUpdatePresenceTitleBlocklist, "1E240,1E241");
        }

        #region IConfigurationProvider Members

        public event SettingChangedEventHandler SettingChanged;

        public event MultiSettingChangedEventHandler MultiSettingChanged;

        public string GetSetting(string settingName)
        {
            String settingValue = String.Empty;
            this.SettingsDictionary.TryGetValue(settingName, out settingValue);

            return settingValue;
        }

        public bool GetBoolSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public int GetIntSetting(string settingName)
        {
            switch (settingName)
            {
                case (Settings.StsAddedTokenExpirationMinutes):
                    {
                        return 10;
                    }
                default:
                    {
                        throw new ArgumentException("settingName", "settingName");
                    }
            }
        }

        public long GetLongSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public double GetDoubleSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public string[] GetMultiSetting(string settingName)
        {
            String[] settingValue = null;
            this.multiSettingsDict.TryGetValue(settingName, out settingValue);
            return settingValue;
        }

        public string GetConnectionString(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
        {
            throw new NotImplementedException();
        }

        public string Environment
        {
            get { throw new NotImplementedException(); }
        }

        public string ComponentName
        {
            get { throw new NotImplementedException(); }
        }

        public string Server
        {
            get { throw new NotImplementedException(); }
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        #endregion

        public bool DummyMethod()
        {
            if (SettingChanged.GetInvocationList().Length > 0 && MultiSettingChanged.GetInvocationList().Length > 0)
            {
                return true;
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockProfileProvider.cs ===
﻿
namespace Gds.Mocks
{
    using System;
    using Leet.Identity;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;

    public class MockProfileProvider : IProfileProvider
    {
        private static XmlSerializableList<Profile> profileList = new XmlSerializableList<Profile>();

        internal static Profile DefaultUserProfile { get; set; }

        public Profile GetProfile(IUserIdentity callerIdentity, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            if (callerIdentity.Xuid == MockAuthenticationManager.DefaultUserXuid)
            {
                partialResult = true;

                if (MockProfileProvider.DefaultUserProfile == null)
                {
                    MockProfileProvider.InitializeDefaultUsers();
                }
                friendsInfoList = null;
                return MockProfileProvider.DefaultUserProfile;
            }

            throw new InvalidOperationException("We don't support the non-default profiles");
        }

        public Profile GetProfile(IUserIdentity callerIdentity, string gamertag, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult, out Identity targetIdentity)
        {
            throw new NotImplementedException();
        }

        public Profile GetProfile(IUserIdentity callerIdentity, ulong targetXuid, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            throw new NotImplementedException();
        }

        public Profile GetProfile(IUserIdentity callerIdentity, long cid, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            throw new NotImplementedException();
        }

        public XmlSerializableList<Profile> GetFriends(IUserIdentity callerIdentity, Network friendNetwork, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            friendsInfoList = null;
            partialResult = true;
            return new XmlSerializableList<Profile>(profileList);
        }

        public Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] GetFriendsForLeaderboard(IUserIdentity callerIdentity, Network friendNetwork, out bool partialResult)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetProfile(
            ulong callingXuid,
            ulong[] xuids)
        {
            throw new NotImplementedException();
        }

        private static void InitializeDefaultUsers()
        {
            MockProfileProvider.DefaultUserProfile = CreateUserProfile(MockAuthenticationManager.DefaultUserGamerTag, MockAuthenticationManager.DefaultUserXuid);

            MockProfileProvider.profileList.Add(CreateUserProfile(MockAuthenticationManager.Friend1GamerTag, MockAuthenticationManager.Friend1Xuid));
            MockProfileProvider.profileList.Add(CreateUserProfile(MockAuthenticationManager.Friend2GamerTag, MockAuthenticationManager.Friend2Xuid));
            MockProfileProvider.profileList.Add(CreateUserProfile(MockAuthenticationManager.Friend3GamerTag, MockAuthenticationManager.Friend3Xuid));
            MockProfileProvider.profileList.Add(CreateUserProfile(MockAuthenticationManager.Friend4GamerTag, MockAuthenticationManager.Friend4Xuid));
            MockProfileProvider.profileList.Add(CreateUserProfile(MockAuthenticationManager.Friend5GamerTag, MockAuthenticationManager.Friend5Xuid));
        }

        private static Profile CreateUserProfile(string gamerTag, ulong xuid)
        {
            Profile profile = new Profile()
            {
                ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>()
            };

            profile.ProfileProperties[ProfileProperty.GamerTag] = gamerTag;
            profile.ProfileProperties[ProfileProperty.Xuid] = xuid;

            return profile;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockServicePerformanceCounters.cs ===
﻿namespace Gds.Mocks
{
    using Leet.Utils;

    public class MockServicePerformanceCounters : IServicePerformanceCounters
    {
        public void StartRequest(object context)
        {
        }

        public long EndRequest(bool failed)
        {
            return 0;
        }

        public IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockUserDataStorage.cs ===
﻿namespace GDS.DataAccess.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Data.Linq;
    using System.Linq;
    using Gds.Contracts;
    using Gds.Mocks;
    using Leet.Core.Platforms;

    /// <summary>
    /// </summary>
    public class MockUserDataStorage : IUserDataStorage
    {
        private static readonly List<UserStat> userStatTable = new List<UserStat>();
        private static readonly List<StatBlob> datablobTable = new List<StatBlob>();

        private const string DefaultDatagroup = "W1";
        
        private static Dictionary<string, IUserStorageConverterFilter> defaultConverterFilter = new Dictionary<string, IUserStorageConverterFilter>(StringComparer.OrdinalIgnoreCase);

        static MockUserDataStorage()
        {
            InitializeUserStatTable();
        }

        public MockUserDataStorage()
        {
            if (defaultConverterFilter.Count == 0)
            {
                // create filters
                ConverterFilter[] filters = { new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighTime, AliasName = StatisticsConstants.BestTime, IsRemoved = false },
                                              new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowTime, IsRemoved = true},
                                              new ConverterFilter() { PropertyKey = StatisticsConstants.BestHighScore, AliasName = StatisticsConstants.BestScore, IsRemoved = false },
                                              new ConverterFilter() { PropertyKey = StatisticsConstants.BestLowScore, IsRemoved = true }};
                foreach (var filter in filters)
                {
                    defaultConverterFilter.Add(filter.PropertyKey, filter);
                }
            }
        }

        public UserStat GetStatisticEntry(ulong xuid, uint gameId, uint variant, string property, uint datagroup)
        {
            unchecked
            {
                var q = from userStat in userStatTable
                        where userStat.Xuid == (long)xuid &&
                              userStat.GameID == (int)gameId &&
                              userStat.Variant == (int)variant &&
                              string.Compare(userStat.PropertyName, property, true) == 0 &&
                              userStat.Datagroup == (int)datagroup
                        select userStat;
                
                if (q.Count() == 0)
                {
                    return null;
                }

                return q.First();
            }
        }

        /// <summary>
        /// Insert the given blob to the List of datablob entries.
        /// And return the Unique Identifier for it.
        /// </summary>
        /// <param name="blob">a blob</param>
        /// <param name="dateUpdated">the time when the update operation is performed</param>
        /// <returns>The identifier of the blob</returns>
        public Guid? InsertBlob(byte[] blob, DateTime dateUpdated)
        {
            StatBlob sb = new StatBlob()
            {
                Blob = new Binary(blob),
                BlobID = Guid.NewGuid(),
                DTCreated = DateTime.Now,
                DTUpdated = DateTime.Now,
                si_HashBucket = 0
            };

            datablobTable.Add(sb);

            return sb.BlobID;
        }

        /// <summary>
        /// Update the given blob for a given blobId,
        /// we simply reuse the same ID and replace the binary field that was previously noted.
        /// </summary>
        /// <param name="blobId"></param>
        /// <param name="blob"></param>
        /// <param name="dateUpdated"></param>
        /// <returns></returns>
        public UserDataError UpdateBlob(Guid blobId, byte[] blob, DateTime dateUpdated)
        {
            StatBlob sb = GetStatBlobForId(blobId);

            sb.Blob = new Binary(blob);
            sb.DTUpdated = dateUpdated;

            return new UserDataError()
            {
                ErrorCode = 0,
                ErrorMessage = string.Empty
            };
        }

        public byte[] GetBlob(Guid blobId)
        {
            StatBlob sb = GetStatBlobForId(blobId);

            return sb.Blob.ToArray();
        }

        public UserDataError DeleteBlob(Guid blobId)
        {
            StatBlob sb = GetStatBlobForId(blobId);
            datablobTable.Remove(sb);

            return new UserDataError()
            {
                ErrorCode = 0,
                ErrorMessage = string.Empty
            };
        }
        
        /// <summary>
        /// Creates a pre-canned set of statistics result; for the default 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="gameID"></param>
        /// <param name="variant"></param>
        /// <returns></returns>
        public List<Entry> GetStatisticsByXuid(ulong xuid, uint gameId, uint variant)
        {
            return this.CreateStatisticsSet();
        }

        public List<Entry> GetStatisticsByXuid(ulong xuid, uint gameId, uint variant, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            return null;
        }

        public UserDataError OperateOnUserStatValueLong(
                                UserDataOperationEnum userDataOperation, 
                                ulong xuid, 
                                uint platformId, 
                                uint gameId, 
                                uint variant, 
                                string propertyName, 
                                uint datagroup,
                                long value, 
                                Guid gameEventId, 
                                Guid gameSessionId, 
                                Guid? blobId, 
                                DateTime dateUpdated, 
                                ref long newValue)
        {
            bool performInsert = false;
            UserStat statEntry = this.GetStatisticEntry(xuid, gameId, variant, propertyName, datagroup);

            unchecked
            {
                if (statEntry == null)
                {
                    performInsert = true;
                    statEntry = new UserStat()
                    {
                        BlobID = blobId ?? Guid.Empty,
                        Datagroup = (int)datagroup,
                        DTCreated = DateTime.Now,
                        DTUpdated = dateUpdated,
                        GameEventID = gameEventId,
                        GameID = (int)gameId,
                        GameSessionID = gameSessionId,
                        PlatformID = (int)platformId,
                        PropertyName = propertyName,
                        si_HashBucket = 0,
                        Value = value,
                        Variant = (int)variant,
                        Xuid = (long)xuid
                    };
                }
            }

            switch (userDataOperation)
            {
                case UserDataOperationEnum.MaxProperty:
                    newValue = Max(statEntry, value, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
                    break;

                case UserDataOperationEnum.MinProperty:
                    newValue = Min(statEntry, value, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
                    break;

                case UserDataOperationEnum.SumProperty:
                    newValue = Sum(statEntry, value, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
                    break;
                default:
                    throw new InvalidOperationException("Invalid operation enum");
            }

            if (performInsert)
            {
                userStatTable.Add(statEntry);
            }

            return new UserDataError()
            {
                ErrorCode = 0,
                ErrorMessage = string.Empty
            };
        }

        public IList<GameData> GetRecentlyPlayedGames(ulong xuid, uint count)
        {
            IList<GameData> gd = new List<GameData>();
            GameData gameData = new GameData();
            gameData.GameId = 1;
            gameData.LastPlayedDateTime = Convert.ToDateTime("1/1/2009");
            gd.Add(gameData);

            GameData gameData1 = new GameData();
            gameData1.GameId = 2;
            gameData1.LastPlayedDateTime = Convert.ToDateTime("7/7/2008");
            gd.Add(gameData1);

            return gd;
        }

        public IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, string property, uint datagroup, List<long> xuidList)
        {
            return this.GetStatsForXuids(gameId, variantId, property, datagroup, xuidList, defaultConverterFilter);
        }

        public IList<StatsResult> GetStatsForXuids(uint gameId, uint variantId, string property, uint datagroup, List<long> xuidList, IDictionary<string, IUserStorageConverterFilter> converterList)
        {
            // Get all stats - for the user list
            var miniUserStatsTable = from userStatsRow in userStatTable
                                     where xuidList.Contains(userStatsRow.Xuid) &&
                                           userStatsRow.Variant == variantId &&
                                           userStatsRow.GameID == gameId &&
                                           userStatsRow.Datagroup == datagroup
                                     select userStatsRow;

            // there is nothing noted in the list, immediately return.
            if (miniUserStatsTable.Count() == 0)
            {
                // TODO: Add logging here to this effect.
                return null;
            }

            // for each unique user, create a seperate List<Entry>
            List<StatsResult> userStats = new List<StatsResult>(xuidList.Count);

            foreach (long xuid in xuidList)
            {
                IList<Entry> userStat = UserDataStorage.FetchStatisticsForUser(xuid, miniUserStatsTable, property, converterList);
                if (userStat != null && userStat.Count > 0)
                {
                    StatsResult sr = new StatsResult()
                    {
                        Xuid = (ulong)xuid,
                        Statistics = userStat
                    };

                    userStats.Add(sr);
                }
            }

            Console.WriteLine("userStats table contains {0} entries", userStats.Count());

            return userStats;
        }

        public void Dispose()
        {
            // Hello I am your friendly Dispose function.
            // I do nothing, but thanks for calling.
        }

        public List<Entry> CreateStatisticsSet()
        {
            List<Entry> statistics = new List<Entry>();

            Entry statisticEntry = this.CreateEntry(StatisticsConstants.BestScore, "10000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.BestTime, "20000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.CumulativeScore, "2000000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.CumulativeTime, "2000000");
            statistics.Add(statisticEntry);
            
            statisticEntry = this.CreateEntry(StatisticsConstants.GamesPlayed, "200");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.AverageScore, "1000000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.AverageTime, "3000000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.Wins, "2000");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.Losses, "4500");
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.BestScoreDataBlobId, Guid.NewGuid().ToString());
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.BestTimeDataBlobId, Guid.NewGuid().ToString());
            statistics.Add(statisticEntry);

            statisticEntry = this.CreateEntry(StatisticsConstants.LastPlayedDateTime, DateTime.UtcNow.ToString());
            statistics.Add(statisticEntry);

            return statistics;
        }

        internal void InitializeUserStatToValues(ulong xuid, uint gameId, uint variant, long bestHighScore, long bestHighTime, long cumulativeTime, long cumulativeScore, long gamesPlayed, DateTime statTime)
        {
            long newValue = 0;

            // initialize lifetime datagroup values.
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.BestHighScore, 0, bestHighScore, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.BestHighTime, 0, bestHighTime, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.CumulativeTime, 0, cumulativeTime, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.CumulativeScore, 0, cumulativeScore, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.GamesPlayed, 0, gamesPlayed, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);

            // initialize the currentWeek datagroup (i.e. datagroup=W1)
            uint dataGroupNumber = UserDataUtilities.GetDatagroupNumberForDate(DateTime.UtcNow);

            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.BestHighScore, dataGroupNumber, bestHighScore / 2, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.BestHighTime, dataGroupNumber, bestHighTime / 2, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.CumulativeTime, dataGroupNumber, cumulativeTime / 2, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.CumulativeScore, dataGroupNumber, cumulativeScore / 2, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
            this.OperateOnUserStatValueLong(UserDataOperationEnum.SumProperty, xuid, (uint)PlatformType.Mobile, gameId, variant, StatisticsConstants.GamesPlayed, dataGroupNumber, gamesPlayed / 2, Guid.NewGuid(), Guid.NewGuid(), Guid.Empty, statTime, ref newValue);
        }

        private static StatBlob GetStatBlobForId(Guid blobId)
        {
            var q = from datablobEntry in datablobTable
                    where datablobEntry.BlobID == blobId
                    select datablobEntry;

            if (q.Count() == 0)
            {
                throw new InvalidOperationException("No blob with given Id");
            }

            return q.First();
        }

        private static long Sum(UserStat statEntry, long value, uint platformId, Guid gameEventId, Guid gameSessionId, Guid? blobId, DateTime dateUpdated)
        {
            long newValue = statEntry.Value.Value + value;
            return UpdateFieldsAndReturn(statEntry, newValue, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
        }

        private static long Min(UserStat statEntry, long value, uint platformId, Guid gameEventId, Guid gameSessionId, Guid? blobId, DateTime dateUpdated)
        {
            long newValue = statEntry.Value.Value < value ? statEntry.Value.Value : value;
            return UpdateFieldsAndReturn(statEntry, newValue, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
        }

        private static long Max(UserStat statEntry, long value, uint platformId, Guid gameEventId, Guid gameSessionId, Guid? blobId, DateTime dateUpdated)
        {
            long newValue = statEntry.Value.Value > value ? statEntry.Value.Value : value;
            return UpdateFieldsAndReturn(statEntry, newValue, platformId, gameEventId, gameSessionId, blobId, dateUpdated);
        }

        private static long UpdateFieldsAndReturn(UserStat statEntry, long value, uint platformId, Guid gameEventId, Guid gameSessionId, Guid? blobId, DateTime dateUpdated)
        {
            unchecked
            {
                statEntry.Value = value;
                statEntry.PlatformID = (int)platformId;
                statEntry.GameEventID = gameEventId;
                statEntry.GameSessionID = gameSessionId;
                statEntry.BlobID = blobId;
                statEntry.DTUpdated = dateUpdated;
            }

            return statEntry.Value.Value;
        }

        private static void InitializeUserStatTable()
        {
            MockUserDataStorage userData = new MockUserDataStorage();

            userData.InitializeUserStatToValues(MockAuthenticationManager.DefaultUserXuid, 7777, 0, 1111, 22222, 33333, 44444, 5, DateTime.UtcNow);
            userData.InitializeUserStatToValues(MockAuthenticationManager.Friend1Xuid, 7777, 0, 11111, 222221, 333331, 444441, 5, DateTime.UtcNow);
            userData.InitializeUserStatToValues(MockAuthenticationManager.Friend2Xuid, 7777, 0, 11112, 222222, 333332, 444442, 5, DateTime.UtcNow);
            userData.InitializeUserStatToValues(MockAuthenticationManager.Friend3Xuid, 7777, 0, 11113, 222223, 333333, 444443, 5, DateTime.UtcNow);
            userData.InitializeUserStatToValues(MockAuthenticationManager.Friend4Xuid, 7777, 0, 11113, 222223, 333333, 444443, 5, DateTime.Parse("2/2/2010"));
            userData.InitializeUserStatToValues(MockAuthenticationManager.Friend5Xuid, 7777, 0, 11115, 222225, 333335, 444445, 5, DateTime.UtcNow);
        }

        private Entry CreateEntry(string name, string value)
        {
            return new Entry()
            {
                Name = name,
                Value = value
            };
        }
    }

    internal class ConverterFilter : IUserStorageConverterFilter
    {
        public string PropertyKey { get; set; }

        public string AliasName { get; set; }

        public bool IsRemoved { get; set; }

        public Entry Process(string name, string value)
        {
            if (this.IsRemoved)
            {
                throw new InvalidOperationException();
            }

            Entry current = new Entry()
            {
                Name = this.AliasName,
                Value = value
            };

            return current;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockWebOperationIncomingRequestHeaderReader.cs ===
﻿namespace Gds.Mocks
{
    using System;
    using Leet.Core.Utils;
    using Leet.Utils;

    public class MockWebOperationIncomingRequestHeaderReader : IWebOperationIncomingRequestHeaderReader
    {
        public string this[string headerName]
        {
            get 
            {
                if (0 == string.Compare(headerName, CustomWebHeaderNames.XLocale, true))
                {
                    return "en-US";
                }
                else if (0 == string.Compare(headerName, CustomWebHeaderNames.XPlatformType, true))
                {
                    // TODO: fix call to Enum.GetValues(typeof(PlatformType))[PlatformType.Mobile];
                    return "1";
                }

                throw new NotSupportedException("Given Web Header is NOT supported by this Mock object");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockUserIdentity.cs ===
﻿namespace Gds.Mocks
{
    using System;
    using Leet.Identity;

    public class MockUserIdentity : IUserIdentity
    {
        public long Puid { get; set; }

        public long Cid { get; set; }

        public ulong Xuid { get; set; }

        public SubscriptionTier Tier { get; set; }

        public string Gamertag { get; set; }

        public AccountType AccountType { get; set; }

        public string IdentityKey { get; set; }

        public bool IsAuthenticated { get; set; }

        public string ToString(string format, IFormatProvider formatProvider)
        {
            throw new NotImplementedException();
        }

        public bool Equals(IUserIdentity other)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.Mocks")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("Gds.Mocks")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("393d7f48-099d-406b-bb63-216b23c82a94")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Mocks\MockRulesStorage.cs ===
﻿
namespace Gds.Mocks
{
    using System;
    using System.Collections.Generic;
    using Gds.DataAccess.Rules;

    public class MockRulesStorage: IRulesStorage
    {
        public IList<Rule> GetRules(int gameId)
        {
            if (gameId == 0)
            {
                return CreateListofRules();
            }
            return null;
        }

        public object GetConfigValue(string configName)
        {
            switch (configName)
            {
                case "RulesLastUpdateTime":
                    return (object) DateTime.Now;
                default:
                    break;
            }
            return null;
        }

        public void Dispose()
        {
        }

        public List<Rule> CreateListofRules()
        {
            List<Rule> rules = new List<Rule>();

            Rule rule = new Rule
                            {
                                RuleId = 1,
                                ActionSet = "<ActionSet>&lt;Actions&gt;&lt;Action&gt;&lt;Name&gt;SumProperty&lt;/Name&gt;&amp;lt;Parameters&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;User&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/LivePuid&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Sum1&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/Property[Score]&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Sum2&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/CumulativeScore&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Store&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/CumulativeScore&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;/Parameters&amp;gt;&lt;/Action&gt;&lt;/Actions&gt;</ActionSet>",
                                DTStart = DateTime.Now,
                                GameKeys = "<GameKeyIDs><GameID>1</GameID></GameKeyIDs>",
                                RuleStatement = "<RuleStatement><RuleExpression type=\"system.int32\"><LeftOperand type=\"Event\">/Event/Property/Name</LeftOperand><Operator>EQUALTO</Operator><RightOperand type=\"Literal\">Score</RightOperand></RuleExpression></RuleStatement>"
                            };
            rules.Add(rule);

            rule = new Rule
            {
                RuleId = 2,
                ActionSet = "<ActionSet>&lt;Actions&gt;&lt;Action&gt;&lt;Name&gt;SumProperty&lt;/Name&gt;&amp;lt;Parameters&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;User&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/LivePuid&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Sum1&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/Property[Time]&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Sum2&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/CumulativeTime&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Store&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/CumulativeTime&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;/Parameters&amp;gt;&lt;/Action&gt;&lt;/Actions&gt;</ActionSet>",
                DTStart = DateTime.Now,
                GameKeys = "<GameKeyIDs><GameID>1</GameID></GameKeyIDs>",
                RuleStatement = "<RuleStatement><RuleExpression type=\"system.int32\"><LeftOperand type=\"Event\">/Event/Property/Name</LeftOperand><Operator>EQUALTO</Operator><RightOperand type=\"Literal\">Time</RightOperand></RuleExpression></RuleStatement>"
            };
            rules.Add(rule);

            rule = new Rule
            {
                RuleId = 3,
                ActionSet = "<ActionSet>&lt;Actions&gt;&lt;Action&gt;&lt;Name&gt;MaxProperty&lt;/Name&gt;&amp;lt;Parameters&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;User&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/LivePuid&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Max1&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/Property[Score]&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Max2&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/BestHighScore&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Store&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/BestHighScore&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;/Parameters&amp;gt;&lt;/Action&gt;&lt;/Actions&gt;</ActionSet>",
                DTStart = DateTime.Now,
                GameKeys = "<GameKeyIDs><GameID>1</GameID></GameKeyIDs>",
                RuleStatement = "<RuleStatement><RuleExpression type=\"system.int32\"><LeftOperand type=\"Event\">/Event/Property/Name</LeftOperand><Operator>EQUALTO</Operator><RightOperand type=\"Literal\">Score</RightOperand></RuleExpression></RuleStatement>"
            };
            rules.Add(rule);

            rule = new Rule
            {
                RuleId = 4,
                ActionSet = "<ActionSet>&lt;Actions&gt;&lt;Action&gt;&lt;Name&gt;MaxProperty&lt;/Name&gt;&amp;lt;Parameters&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;User&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/LivePuid&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Max1&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Event/Property[Time]&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Max2&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/BestHighTime&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;Parameter&amp;gt;&amp;lt;Name&amp;gt;Store&amp;lt;/Name&amp;gt;&amp;lt;Path&amp;gt;/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/BestHighTime&amp;lt;/Path&amp;gt;&amp;lt;Type&amp;gt;system.int64&amp;lt;/Type&amp;gt;&amp;lt;Value&amp;gt;&amp;lt;/Value&amp;gt;&amp;lt;/Parameter&amp;gt;&amp;lt;/Parameters&amp;gt;&lt;/Action&gt;&lt;/Actions&gt;</ActionSet>",
                DTStart = DateTime.Now,
                GameKeys = "<GameKeyIDs><GameID>1</GameID></GameKeyIDs>",
                RuleStatement = ""
            };

            rules.Add(rule);

            return rules;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\GlobalSuppressions.cs ===
//------------------------------------------------------------------------------------------------- 
// <copyright file="GlobalSuppressions.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Defines the Completed Async Result.</summary>
//-------------------------------------------------------------------------------------------------

// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2243:AttributeStringLiteralsShouldParseCorrectly", Scope = "member", Target = "RewardsFE.IRewardsFEService.#SubmitEvent(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2243:AttributeStringLiteralsShouldParseCorrectly", Scope = "member", Target = "RewardsFE.IRewardsFEService.#BeginSubmitRewardsEvent(System.String,System.AsyncCallback,System.Object)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Wgx.Services.Gds")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Services.Gds")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Wgx.Services.Gds.Services.RewardsBrokerManager.#EndSend(System.IAsyncResult)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope = "type", Target = "Wgx.Services.Gds.Services.RewardsBrokerManager")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope = "member", Target = "Wgx.Services.Gds.Services.RewardsTracer.#.cctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Json", Scope = "member", Target = "Wgx.Services.Gds.IPostGameResult.#BeginPostGameResultJson(Wgx.Services.Gds.BusinessObjects.GameResult,System.AsyncCallback,System.Object)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Json", Scope = "member", Target = "Wgx.Services.Gds.IPostGameResult.#EndPostGameResultJson(System.IAsyncResult)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1824:MarkAssembliesWithNeutralResourcesLanguage")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\IPostGameResult.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="IPostGameEvent.cs" company="Microsoft" author="Savas Guven">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Rewards Front End Service contract.</summary>
//-------------------------------------------------------------------------------------------------


namespace Gds.Services.Rewards
{
    using System;
    using System.IO;
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Gds.Contracts;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Rewards front end contract
    /// </summary>
    [ServiceContract]
    public interface IPostGameResult
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate"), OperationContract]
        [WebGet(UriTemplate="help")]
        Stream GetDocumentation();

        /// <summary>
        /// synchronous implementation of event submission
        /// </summary>
        [WebHelp(Comment = "Post game score to leaderboard service.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameResult", Method = "POST", RequestFormat = WebMessageFormat.Xml)]
        string PostGameResultDefault(GameResult gameResult);

        [WebHelp(Comment = "Post game score to leaderboard service.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GameResult?format=xml", Method = "POST", RequestFormat=WebMessageFormat.Xml)]
        string PostGameResultXml(GameResult gameResult);

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Json"), OperationContract]
        [WebHelp(Comment = "Post game score to leaderboard service.")]
        [WebInvoke(UriTemplate = "GameResult?format=json", Method = "POST", RequestFormat = WebMessageFormat.Json, BodyStyle=WebMessageBodyStyle.Bare)]
        string PostGameResultJson(GameResult gameResult);

        [WebHelp(Comment = "Post an achievement to the XBOX achievement system.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GrantAchievements?format=xml", Method = "POST", RequestFormat = WebMessageFormat.Xml)]
        void GrantAchievementsXml(GrantAchievements grantAchievements);

        [WebHelp(Comment = "Post an achievement to the XBOX achievement system.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Json"), OperationContract]
        [WebInvoke(UriTemplate = "GrantAchievements?format=json", Method = "POST", RequestFormat = WebMessageFormat.Json, BodyStyle = WebMessageBodyStyle.Bare)]
        void GrantAchievementsJson(GrantAchievements grantAchievements);

        [WebHelp(Comment = "Post avatar assets to the Xbox Live Platform.")]
        [OperationContract]
        [WebInvoke(UriTemplate = "GrantAvatarAssets", Method = "POST", RequestFormat = WebMessageFormat.Xml)]
        void GrantAvatarAssets(GrantAvatarAssets grantAvatarAssets);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AssemblyInfo.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Assembly information.</summary>
//-------------------------------------------------------------------------------------------------
using System.Reflection;
using System.Runtime.InteropServices;
using xonline.common.config;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Services.Rewards")]
[assembly: ConfigAttribute("gds_rewards")] // requires by ActiveAuth for event logging
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\Global.asax.cs ===
﻿namespace Gds.Services.Rewards
{
    using System;
    using System.Web;
    using GameMetadata.Client;
    using Gds.DataAccess.Rewards;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.TestSupport;
    using Leet.Core.Utils;
    using Leet.Core.BI;
    using Leet.Identity.ActiveAuth;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Providers;
    using Leet.Identity;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    public class Global : System.Web.HttpApplication
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            RewardsEvents.Initialize("gds_rewards");

            // This call needs to happen before any other IoCco AddService calls.
            // as many other components may have a dependency on the interfaces being registered in this step.
            RegisterBaselineInterfaces();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("gds_rewards");
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);
            Container.Instance.AddService<IPurchaseVerification, ZestPurchaseVerificationProvider>();

            // The following registers 4 interfaces to the Iocco:
            //          IEndpointConfigurator<IGameMetadataService>,
            //          IWcfProxyFactory<IGameMetadataService>,
            //          IGameMetadataService,
            //          IGameMetadataClient
            GameMetadataClient.RegisterContainerServices();
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, WebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IBILog, BILog>(); // to log business intelligence data

            // Add the game result queue submitter.
            CSubmitGameResult.RegisterInterfaces(Container.Instance);
            
            // Register locale helper
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            Logging.TraceInformation("{0}: Application Started", RewardsServiceRest.ComponentName);
            RewardsEvents.Events.TraceEvent(RewardsEvents.ServiceStarted);
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            RewardsEvents.Events.TraceEvent(RewardsEvents.ApplicationError, ex.ToString());
            Logging.TraceException(ex, 
                RewardsServiceRest.ComponentName);
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            // Proxies must treat the response as private & must not transform or cache the response.
            HttpContext.Current.Response.Headers["Cache-Control"] = "private, no-transform, no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        /// <summary>
        /// Register the required baseline interfaces
        /// </summary>
        private static void RegisterBaselineInterfaces()
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<ITestImplementationProvider, TestImplementationProvider>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
    
            Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
            ((NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", "gds_rewards");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsConstants.cs ===
﻿namespace Gds.Services.Rewards
{
    public sealed class RewardsConstants
    {
        private RewardsConstants() { }
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "NameSpace")]
        public const string EcommerceNameSpace = "http://schemas.zune.net/commerce/2009/01";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\IPurchaseVerification.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    
    public interface IPurchaseVerification
    {
        /// <summary>
        /// Retrieves a user cookie after user is authenticated
        /// </summary>
        /// <param name="xuid">User's identity</param>
        /// <param name="cookie">Cookie returned after authentication</param>
        /// <param name="errCode">Error code</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#")]
        void SignIn(string xuid, out string cookie, out uint errCode);

        /// <summary>
        /// Returns whether user has purchased title
        /// </summary>
        /// <param name="appId">User's application identity</param>
        /// <param name="titleId">Title purchased</param>
        /// <param name="xuid">User's identity</param>
        /// <param name="cookie">User's cookie</param>
        /// <param name="errCode">Error code</param>
        /// <param name="errMessage">Error message</param>
        /// <returns>Returns true if user has purchased the title</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "4#")]
        bool VerifyPurchase(Guid appId, uint titleId, string xuid, string cookie, out uint errCode, out string errMessage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsCounters.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Diagnostics;
    using Leet.Core.Utils;
    using Wgx.Services.Monitoring;
    using Leet.Utils;
    using Leet.Core.Diagnostics;

    public enum RewardsMethod
    {
        PostGameResult,
        PostGrantAchievements,
        PostGrantAvatarAssets,
        ZestSignIn,
        ZestVerifyPurchase
    }

    /// <summary>
    /// Performance counter class for RewardsCounters
    /// </summary>
    public class RewardsCounters : PerfCounterBase<RewardsCounters>
    {
        private static object lockObject = new Object();

        private PerformanceCounterCollection counters;

        private bool perfCountersInitialized;

        /// <summary>
        /// Initializes a new instance of the ProfileCounters class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public RewardsCounters()
        {
            Initialize();
        }

        private bool Initialize()
        {
            if (this.counters == null)
            {
                lock(lockObject)
                {
                    if (this.counters == null)
                    {
                        this.perfCountersInitialized = true;
                        try
                        {
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(RewardsPerfCounters));
                        }
                        catch (Exception)
                        {
                            this.perfCountersInitialized = false;
                            Logging.TraceError("RewardsCounters: RewardsPerfCounters has not been installed.");
                        }
                    }
                }
            }

            return this.perfCountersInitialized;
        }
        
        public override void StartRequest(object context)
        {
            if (this.Initialize())
            {
                base.StartRequest(context);

                RewardsMethod rewardsMethod = (RewardsMethod)context;

                switch (rewardsMethod)
                {
                    case RewardsMethod.PostGameResult:
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGameResultRequestsPerSecond);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGameResultTotalRequests);
                        break;
                    case RewardsMethod.PostGrantAchievements:
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAchievementsRequestsPerSecond);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAchievementsTotalRequests);
                        break;
                    case RewardsMethod.PostGrantAvatarAssets:
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAvatarAssetsRequestsPerSecond);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAvatarAssetsTotalRequests);
                        break;
                    case RewardsMethod.ZestSignIn:
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestSignInRequestsPerSecond);
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestSignInTotalRequests);
                        break;
                    case RewardsMethod.ZestVerifyPurchase:
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestVerifyPurchaseRequestsPerSecond);
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestVerifyPurchaseTotalRequests);
                        break;
                    default:
                        Logging.TraceError("RewardsCounters", "RewardsMethod not found.");
                        break;
                }
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;

            if (this.perfCountersInitialized)
            {
                // it is imperative that Context object be retrieved once and before the base.EndRequest() call
                RewardsMethod rewardsMethod = (RewardsMethod)RewardsCounters.Context;
                duration = base.EndRequest(failed);
                
                switch (rewardsMethod)
                {
                    case RewardsMethod.PostGameResult:
                        this.counters.SafeIncrementBy(RewardsPerfCounters.PostGameResultAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGameResultAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGameResultFailuresPerSecond);
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGameResultTotalFailures);
                        }

                        break;
                    case RewardsMethod.PostGrantAchievements:
                        this.counters.SafeIncrementBy(RewardsPerfCounters.PostGrantAchievementsAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAchievementsAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAchievementsFailuresPerSecond);
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAchievementsTotalFailures);
                        }

                        break;
                    case RewardsMethod.PostGrantAvatarAssets:
                        this.counters.SafeIncrementBy(RewardsPerfCounters.PostGrantAvatarAssetsAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAvatarAssetsAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAvatarAssetsFailuresPerSecond);
                            this.counters.SafeIncrement(RewardsPerfCounters.PostGrantAvatarAssetsTotalFailures);
                        }

                        break;
                    case RewardsMethod.ZestSignIn:
                        this.counters.SafeIncrementBy(RewardsPerfCounters.ZestSignInAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestSignInAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RewardsPerfCounters.ZestSignInFailuresPerSecond);
                            this.counters.SafeIncrement(RewardsPerfCounters.ZestSignInTotalFailures);
                        }

                        break;
                    case RewardsMethod.ZestVerifyPurchase:
                        this.counters.SafeIncrementBy(RewardsPerfCounters.ZestVerifyPurchaseAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RewardsPerfCounters.ZestVerifyPurchaseAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RewardsPerfCounters.ZestVerifyPurchaseFailuresPerSecond);
                            this.counters.SafeIncrement(RewardsPerfCounters.ZestVerifyPurchaseTotalFailures);
                        }

                        break;
                    default:
                        Logging.TraceError("RewardsCounters: RewardsMethod not found.");
                        break;
                }
            }

            return duration;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsConfig.cs ===
﻿using System;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using LIVEN.Common.Diagnostics; 
using System.Configuration;
using xonline.common.config;

namespace Gds.Services.Rewards
{
    public class RewardsConfig
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings")]
        public static string ZestUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ZestUrl);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToBoolean(System.String)")]
        public static bool ZestPurchaseVerificationEnabled
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return Convert.ToBoolean(configSettings.GetSetting(Settings.ZestPurchaseVerificationEnabled));
           }
        }

        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsPerfCounters.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class implements the Rewards PerfCounter Category
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Perf"), PerformanceCategory(CategoryName = "Gds Rewards", CategoryType = PerformanceCounterCategoryType.SingleInstance)]
    public sealed class RewardsPerfCounters
    {
        private RewardsPerfCounters()
        {
        }

        public static string Name
        {
            get
            {
                return "Gds Rewards";
            }
        }

        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }

        /// <summary>
        /// Performance counters for POST GameResult
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for POST GameResult")]
        public static int PostGameResultTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for POST GameResult")]
        public static int PostGameResultTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "POST GameResult requests per second")]
        public static int PostGameResultRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "POST GameResult failures per second")]
        public static int PostGameResultFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for POST GameResult")]
        public static int PostGameResultAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGameResultAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for POST GameResult", BasePropertyName = "PostGameResultAverageExecutionTimeBase")]
        public static int PostGameResultAverageExecutionTime;

        /// <summary>
        /// Performance counters for POST GrantAchievements
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for POST GrantAchievements")]
        public static int PostGrantAchievementsTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for POST GrantAchievements")]
        public static int PostGrantAchievementsTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "POST GrantAchievements requests per second")]
        public static int PostGrantAchievementsRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "POST GrantAchievements failures per second")]
        public static int PostGrantAchievementsFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for POST GrantAchievements")]
        public static int PostGrantAchievementsAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAchievementsAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for POST GrantAchievements", BasePropertyName = "PostGrantAchievementsAverageExecutionTimeBase")]
        public static int PostGrantAchievementsAverageExecutionTime;

        /// <summary>
        /// Performance counters for POST GrantAvatarAssets
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for POST GrantAvatarAssets")]
        public static int PostGrantAvatarAssetsTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for POST GrantAvatarAssets")]
        public static int PostGrantAvatarAssetsTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "POST GrantAvatarAssets requests per second")]
        public static int PostGrantAvatarAssetsRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "POST GrantAvatarAssets failures per second")]
        public static int PostGrantAvatarAssetsFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for POST GrantAvatarAssets")]
        public static int PostGrantAvatarAssetsAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "PostGrantAvatarAssetsAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for POST GrantAvatarAssets", BasePropertyName = "PostGrantAvatarAssetsAverageExecutionTimeBase")]
        public static int PostGrantAvatarAssetsAverageExecutionTime;

        /// <summary>
        /// Performance counters for POST ZestSignIn
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for POST ZestSignIn")]
        public static int ZestSignInTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for POST ZestSignIn")]
        public static int ZestSignInTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "POST ZestSignIn requests per second")]
        public static int ZestSignInRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "POST ZestSignIn failures per second")]
        public static int ZestSignInFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for POST ZestSignIn")]
        public static int ZestSignInAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestSignInAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for POST ZestSignIn", BasePropertyName = "ZestSignInAverageExecutionTimeBase")]
        public static int ZestSignInAverageExecutionTime;

        /// <summary>
        /// Performance counters for POST ZestVerifyPurchase
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for POST ZestVerifyPurchase")]
        public static int ZestVerifyPurchaseTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for POST ZestSignIn")]
        public static int ZestVerifyPurchaseTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "POST ZestSignIn requests per second")]
        public static int ZestVerifyPurchaseRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "POST ZestSignIn failures per second")]
        public static int ZestVerifyPurchaseFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for POST ZestSignIn")]
        public static int ZestVerifyPurchaseAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ZestVerifyPurchaseAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for POST ZestSignIn", BasePropertyName = "ZestVerifyPurchaseAverageExecutionTimeBase")]
        public static int ZestVerifyPurchaseAverageExecutionTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsServiceAdapter.cs ===
﻿namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Net;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.Live.Livecache.Logic.Avatars;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics; 

    public sealed class RewardsServiceAdapter
    {
        /// <summary>
        /// Private constructor to prevent instantiation of a class with all static methods
        /// </summary>
        private RewardsServiceAdapter() { }

        /// <summary>
        /// Method to grant achievements
        /// NOTE that caller is responsible of validating all parameters before calling into this function.
        /// </summary>
        /// <param name="gameId">Game identifier</param>
        /// <param name="xuid">User's xbox identity</param>
        /// <param name="appId">Application identifier</param>
        /// <param name="achievements">List of earned achievements</param>
        /// <param name="locale">Locale of requester</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToUInt32(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt64)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt32)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static void GrantAchievements(uint gameId, ulong xuid, string appId, IList<AchievementEarned> achievements, string locale)
        {
                Logging.TraceVerbose("{0}: GrantAchievements {1}|{2}|{3}|{4}|{5}",
                    RewardsServiceUtility.ComponentName,
                    gameId,
                    xuid,
                    appId,
                    achievements.Count,
                    locale);
            
                var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();

                ushort lcid = 0;

                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

                lcid = localeHelper.GetLCID(locale);
            
                List<IReadOnlyAchievementInfo> readOnlyAchievementInfoList = new List<IReadOnlyAchievementInfo>();

                try
                {
                    Logging.TraceVerbose("{0}: GrantAchievements: GetUserAchievements {1}|{2}|{3}",
                        RewardsServiceUtility.ComponentName,
                        xuid,
                        gameId,
                        lcid);

                    // Check if user has already unlocked an achievement for this title, else do purchase verification
                   readOnlyAchievementInfoList = achievementDataAccess.GetUserAchievements(Convert.ToUInt32(gameId), xuid, xuid, lcid);
                }
                catch (Exception e)
                {
                    string errorMessage = string.Format("Error getting GetUserAchievements- xuid:{0}, gameId:{1}, lcid:{2}", xuid, gameId, lcid);
                    RewardsServiceUtility.HandleException("POST GrantAchievements", e, HttpStatusCode.InternalServerError, RewardsEvents.LiveCacheError, errorMessage, true);
                }

                // Check to see if the achievement keys are valid else throw a BadRequest exception 
                foreach(AchievementEarned achievementEarned in achievements)
                {
                    if(!IsValidAchievement(readOnlyAchievementInfoList, achievementEarned.Key))
                    {
                        string errorMessage = string.Format(
                            "The key for the achievement is invalid- xuid:{0}, key:{1}", xuid, achievementEarned.Key);

                        LIVEnException ex = new LIVEnException(
                           RewardsEvents.Events,
                           RewardsEvents.BadGrantAchievementsPost,
                           HttpStatusCode.BadRequest,
                           null,
                           "POST GrantAchievements",
                           errorMessage,
                           true);
                        ex.ThrowWebProtocolException();
                    }
                }

                // If no achievements has been unlocked for title, do purchase verification
                if (!IsAnyAchievementUnlocked(readOnlyAchievementInfoList) && RewardsConfig.ZestPurchaseVerificationEnabled)
                {
                    // perform the purchase verification only if the title id is not found in the white list
                    if (RewardsServiceUtility.PerofrmPurchaseVerification(gameId))
                    {
                        Logging.TraceVerbose("{0}: GrantAchievement Verifying title purchase for user- xuid: {1}",
                            RewardsServiceUtility.ComponentName,
                            xuid);

                        var purchaseVerification = Container.Instance.GetComponent<IPurchaseVerification>();
                        uint errCode = LIVEnErrorCode.LIVEN_UNKNOWN_ERROR;
                        string errMessage = string.Empty;
                        string cookie = string.Empty;

                        // Must call SignIn to retrieve cookie before calling VerifyPurchase
                        purchaseVerification.SignIn(Convert.ToString(xuid), out cookie, out errCode);
                        if (string.IsNullOrEmpty(cookie))
                        {
                            string errorMessage = string.Format("Zest Sign In returned empty cookie- xuid:{0}", xuid);
                            LIVEnException ex = new LIVEnException(
                                RewardsEvents.Events,
                                RewardsEvents.ZestSignInInvalidXuid,
                                HttpStatusCode.BadRequest,
                                null,
                                "POST GrantAchievements",
                                errorMessage,
                                true);
                            ex.ThrowWebProtocolException();
                        }

                        // Verify purchase
                        bool purchased = purchaseVerification.VerifyPurchase(
                            new Guid(appId),
                            gameId,
                            Convert.ToString(xuid),
                            cookie,
                            out errCode,
                            out errMessage);

                        if (errCode != LIVEnErrorCode.S_OK || !purchased)
                        {
                            string errorMessage =
                                string.Format(
                                    "Zest VerifyPastPurchase failed- appId:{0}, gameId:{1}, xuid:{2}, cookie:{3}, ZEST errCode:{4} ZEST response:{5}",
                                    appId, gameId, xuid, cookie, errCode, errMessage);
                            int e;
                            if (errCode == LIVEnErrorCode.LIVEN_ZEST_ITEM_NOT_PURCHASED)
                            {
                                e = RewardsEvents.ZestNotPurchased;
                            }
                            else
                            {
                                e = RewardsEvents.ZestVerifyPastPurchaseRequestError;
                            }

                            LIVEnException ex = new LIVEnException(
                                RewardsEvents.Events,
                                e,
                                HttpStatusCode.BadRequest,
                                null,
                                "Post GrantAchievements",
                                errorMessage,
                                true);

                            ex.ThrowWebProtocolException();
                        }
                    }
                }

                IList<IReadOnlyAchievementInfo> achievementInfos = new List<IReadOnlyAchievementInfo>();

                DateTime syncTime = DateTime.Now;

                foreach (AchievementEarned achievement in achievements)
                {
                   Logging.TraceVerbose("{0}: GrantAchievement for: {1}|{2}|{3}",
                        RewardsServiceUtility.ComponentName,
                        xuid,
                        achievement.Key,
                        String.Format("{0:u}", achievement.EarnedDateTime));

                    IReadOnlyAchievementInfo achievementInfo = new AchievementInfo();
                    achievementInfo.AchievementId = Convert.ToUInt32(achievement.Key);
                    achievementInfo.DateUnlocked = achievement.EarnedDateTime;
                    achievementInfo.WasEarnedOnline = true;
                    achievementInfos.Add(achievementInfo);
                    syncTime = achievement.EarnedDateTime;
                }

                try
                {
                  Logging.TraceVerbose("{0}: Calling SyncTitles: {1}|{2}|{3}|{4}",
                        RewardsServiceUtility.ComponentName,
                        xuid,
                        gameId,
                        lcid,
                        String.Format("{0:u}", syncTime));
                    achievementDataAccess.SyncTitles(gameId, xuid, lcid, syncTime);
                }
                catch (Exception ex)
                {
                    string errorMessage = string.Format("Error calling SyncTitles- xuid:{0}, gameId:{1}, lcid:{2}", xuid,
                                                        gameId, lcid);
                    RewardsServiceUtility.HandleException("POST GrantAchievements", ex, HttpStatusCode.InternalServerError, RewardsEvents.LiveCacheError, errorMessage, true);
                }

                try
                {
                   Logging.TraceVerbose("{0}: Calling SyncAchievements: {1}|{2}|{3}|{4}",
                        RewardsServiceUtility.ComponentName,
                        xuid,
                        gameId,
                        lcid,
                        achievementInfos.Count);

                    achievementDataAccess.SyncAchievements(gameId, xuid, lcid, achievementInfos);
                }
                catch (Exception ex)
                {
                    string errorMessage = string.Format("Error calling SyncAchievements- xuid:{0}, gameId:{1}, lcid:{2}", xuid, gameId, lcid);
                    RewardsServiceUtility.HandleException("POST GrantAchievements", ex, HttpStatusCode.InternalServerError, RewardsEvents.LiveCacheError, errorMessage, true);
                }
            
            Logging.TraceVerbose("{0}: End GrantAchievements",
                RewardsServiceUtility.ComponentName);
        }

        /// <summary>
        /// Checks if any achievement for the title has already been unlocked
        /// </summary>
        /// <param name="readOnlyAchievementInfos">List of achievements</param>
        /// <returns>true if an achievement has been unlocked, else false</returns>
        private static bool IsAnyAchievementUnlocked(List<IReadOnlyAchievementInfo> readOnlyAchievementInfos)
        {
            foreach (IReadOnlyAchievementInfo readOnlyAchievementInfo in readOnlyAchievementInfos)
            {
                if (readOnlyAchievementInfo.IsUnlocked)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Checks if key is in the achievement list
        /// </summary>
        /// <param name="readOnlyAchievementInfos">List of achievements</param>
        /// <param name="key">Achievement key to be validated</param>
        /// <returns>true if an achievement key exists, else false</returns>
        private static bool IsValidAchievement(List<IReadOnlyAchievementInfo> readOnlyAchievementInfos, string key)
        {
            foreach (IReadOnlyAchievementInfo readOnlyAchievementInfo in readOnlyAchievementInfos)
            {
                if (readOnlyAchievementInfo.AchievementId == Convert.ToUInt32(key))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Method to grant avatar assets
        /// NOTE that caller is responsible of validating all parameters before calling into this function.
        /// </summary>
        /// <param name="gameId">Game identifier</param>
        /// <param name="xuid">User's xbox identity</param>
        /// <param name="appId">Application identifier</param>
        /// <param name="avatarAssets">List of earned avatar assets</param>
        /// <param name="locale">Locale of requester</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToUInt32(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt64)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt32)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static void GrantAvatarAssets(uint gameId, ulong xuid, string appId, IList<AvatarAssetEarned> avatarAssets, string locale)
        {
            Logging.TraceVerbose("{0}: GrantAvatarAssets {1}|{2}|{3}|{4}|{5}",
                RewardsServiceUtility.ComponentName,
                gameId,
                xuid,
                appId,
                avatarAssets.Count,
                locale);

            var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();

            ushort lcid = 0;

            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

            lcid = localeHelper.GetLCID(locale);

            // do purchase verification for this title
            if (RewardsConfig.ZestPurchaseVerificationEnabled)
            {
                // perform the purchase verification only if the title id is not found in the white list
                if (RewardsServiceUtility.PerofrmPurchaseVerification(gameId))
                {
                    Logging.TraceVerbose("{0}: GrantAchievement Verifying title purchase for user - xuid: {1}",
                        RewardsServiceUtility.ComponentName,
                        xuid);

                    var purchaseVerification = Container.Instance.GetComponent<IPurchaseVerification>();
                    uint errCode = LIVEnErrorCode.LIVEN_UNKNOWN_ERROR;
                    string errMessage = string.Empty;
                    string cookie = string.Empty;

                    // Must call SignIn to retrieve cookie before calling VerifyPurchase
                    purchaseVerification.SignIn(Convert.ToString(xuid), out cookie, out errCode);
                    if (string.IsNullOrEmpty(cookie))
                    {
                        string errorMessage = string.Format("Zest Sign In returned empty cookie- xuid:{0}", xuid);
                        LIVEnException ex = new LIVEnException(
                            RewardsEvents.Events,
                            RewardsEvents.ZestSignInInvalidXuid,
                            HttpStatusCode.BadRequest,
                            null,
                            "POST GrantAvatarAssets",
                            errorMessage,
                            true);
                        ex.ThrowWebProtocolException();
                    }

                    // Verify purchase
                    bool purchased = purchaseVerification.VerifyPurchase(
                        new Guid(appId),
                        gameId,
                        Convert.ToString(xuid),
                        cookie,
                        out errCode,
                        out errMessage);

                    if (errCode != LIVEnErrorCode.S_OK || !purchased)
                    {
                        string errorMessage =
                            string.Format(
                                "Zest VerifyPastPurchase failed- appId:{0}, gameId:{1}, xuid:{2}, cookie:{3}, ZEST errCode:{4} ZEST response:{5}",
                                appId, gameId, xuid, cookie, errCode, errMessage);
                        int e;
                        if (errCode == LIVEnErrorCode.LIVEN_ZEST_ITEM_NOT_PURCHASED)
                        {
                            e = RewardsEvents.ZestNotPurchased;
                        }
                        else
                        {
                            e = RewardsEvents.ZestVerifyPastPurchaseRequestError;
                        }

                        LIVEnException ex = new LIVEnException(
                            RewardsEvents.Events,
                            e,
                            HttpStatusCode.BadRequest,
                            null,
                            "Post GrantAvatarAssets",
                            errorMessage,
                            true);

                        ex.ThrowWebProtocolException();
                    }
                }
            }

            IList<AwardedAvatarAsset> awardedAvatarAssets = new List<AwardedAvatarAsset>();

            DateTime syncTime = DateTime.Now;

            // construct the list of AwardedAvatarAsset with necessary information to SyncAvatarAssets
            foreach (AvatarAssetEarned avatarAssetEarned in avatarAssets)
            {
                Logging.TraceVerbose("{0}: GrantAvatarAssets for: {1}|{2}|{3}",
                     RewardsServiceUtility.ComponentName,
                     xuid,
                     avatarAssetEarned.Key,
                     String.Format("{0:u}", avatarAssetEarned.EarnedDateTime));

                AwardedAvatarAsset awardedAvatarAsset = new AwardedAvatarAsset();
                awardedAvatarAsset.IsUnisexItem = avatarAssetEarned.IsUnisexItem; 
                awardedAvatarAsset.AvatarAssetOrdinal = Convert.ToUInt32(avatarAssetEarned.Key);
                awardedAvatarAsset.Awarded = avatarAssetEarned.EarnedDateTime;
                if (avatarAssetEarned.EarnedOnline)
                {
                    awardedAvatarAsset.Flags = AvatarAssetFlags.ACHIEVED_ONLINE | AvatarAssetFlags.ACHIEVED;    
                }
                else
                {
                    awardedAvatarAsset.Flags = AvatarAssetFlags.ACHIEVED;
                }
                awardedAvatarAssets.Add(awardedAvatarAsset);
                syncTime = avatarAssetEarned.EarnedDateTime;
            }

            try
            {
                Logging.TraceVerbose("{0}: Calling SyncTitles: {1}|{2}|{3}|{4}",
                      RewardsServiceUtility.ComponentName,
                      xuid,
                      gameId,
                      lcid,
                      String.Format("{0:u}", syncTime));
                achievementDataAccess.SyncTitles(gameId, xuid, lcid, syncTime);
            }
            catch (Exception ex)
            {
                string errorMessage = string.Format("Error calling SyncTitles- xuid:{0}, gameId:{1}, lcid:{2}", xuid,
                                                    gameId, lcid);
                RewardsServiceUtility.HandleException("POST GrantAvatarAssets", ex, HttpStatusCode.InternalServerError, RewardsEvents.LiveCacheError, errorMessage, true);
            }

            try
            {
                Logging.TraceVerbose("{0}: Calling SyncAvatarAssets: {1}|{2}|{3}|{4}",
                     RewardsServiceUtility.ComponentName,
                     xuid,
                     gameId,
                     lcid,
                     awardedAvatarAssets.Count);

                achievementDataAccess.SyncAvatarAssets(gameId, xuid, lcid, awardedAvatarAssets);
            }
            catch (Exception ex)
            {
                string errorMessage = string.Format("Error calling SyncAvatarAssets - xuid:{0}, gameId:{1}, lcid:{2}", xuid, gameId, lcid);
                RewardsServiceUtility.HandleException("POST GrantAvatarAssets", ex, HttpStatusCode.InternalServerError, RewardsEvents.LiveCacheError, errorMessage, true);
            }

            Logging.TraceVerbose("{0}: End GrantAvatarAssets",
                RewardsServiceUtility.ComponentName);
        }

        /// <summary>
        /// Checks if key is in the avatar asset list
        /// </summary>
        /// <param name="awardedAvatarAssetCollection">Collection of avatar assets</param>
        /// <param name="key">Avatar asset key to be validated</param>
        /// <returns>true if asset key exists, else false</returns>
        private static bool IsValidAvatarAsset(ReadOnlyCollection<AwardedAvatarAsset> awardedAvatarAssetCollection, string key)
        {
            foreach (AwardedAvatarAsset awardedAvatarAsset in awardedAvatarAssetCollection)
            {
                if (String.Compare(BitConverter.ToString(awardedAvatarAsset.AvatarAssetId), key, StringComparison.OrdinalIgnoreCase) == 0)   
                {
                    return true;
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsService.svc.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Text;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Gds.Services;
    using Leet.Core.BI;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;
    using Wgx.Services.Common;

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class RewardsServiceRest : IPostGameResult
    {
        /// <summary>
        /// Component Name
        /// </summary>
        internal const string ComponentName = "RewardsService";

        private static object lockObject = new object();
        private static RewardsCounters counters = null;
        private static RewardsCounters Counters
        {
            get
            {
                if (counters == null)
                {
                    lock (lockObject)
                    {
                        if (counters == null)
                        {
                            counters = new RewardsCounters();
                        }
                    }
                }

                return counters;
            }
        }

        public RewardsServiceRest()
        {
            WcfErrorHandler.Instance.OnHandleError += new EventHandler<WcfHandleErrorEventArgs>(this.Instance_OnHandleError);
            WcfErrorHandler.Instance.OnProvideFault += new EventHandler<WcfProvideFaultEventArgs>(this.Instance_OnProvideFault);
        }

        /// <summary>
        /// Returns the Documentation for this service.
        /// </summary>
        /// <returns></returns>
        public Stream GetDocumentation()
        {
            MemoryStream stream = new MemoryStream();

            StreamWriter writer = new StreamWriter(stream, Encoding.UTF8);
            writer.Write(Properties.Resources.Documentation);
            writer.Flush();

            stream.Position = 0;
            WebOperationContext.Current.OutgoingResponse.ContentType = "text/html";
            return stream;
        }

        public string PostGameResultDefault(GameResult gameResult)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "PostGameEventDefault");
            return this.PostGameResultXml(gameResult);
        }

        public string PostGameResultXml(GameResult gameResult)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "PostGameEventXml");
            return RewardsServiceRest.InternalPostGameResult(gameResult);
        }

        public string PostGameResultJson(GameResult gameResult)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "PostGameResultJson");
            return RewardsServiceRest.InternalPostGameResult(gameResult);
        }

        public void GrantAchievementsXml(GrantAchievements grantAchievements)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "GrantAchievementsXml");
            RewardsServiceRest.GrantAchievementsInternal(grantAchievements);
        }

        public void GrantAchievementsJson(GrantAchievements grantAchievements)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "GrantAchievementsJson");
            RewardsServiceRest.GrantAchievementsInternal(grantAchievements);
        }

        public void GrantAvatarAssets(GrantAvatarAssets grantAvatarAssets)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "GrantAvatarAssets");
            RewardsServiceRest.GrantAvatarAssetsInternal(grantAvatarAssets);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private static void GrantAchievementsInternal(GrantAchievements grantAchievements)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "GrantAchievementsInternal");
            
            bool requestFailed = false;

            // X-locale and X-PlatformType headers must exist and be valid.
            string locale;
            string platformType;

            // This call does not throw, or rather if it throws, there is no good way of handling it.
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            try
            {
                RewardsServiceRest.Counters.StartRequest(RewardsMethod.PostGrantAchievements);

                RewardsServiceUtility.ValidatePlatformTypeAgainstClaim(platformType);

                RewardsServiceUtility.ValidateTitleIDAgainstClaim(grantAchievements.GameId);

                RewardsServiceUtility.ValidatePostGrantAchievement(grantAchievements, locale, platformType);

                var callerIdentity = RewardsServiceUtility.CallerIdentity;
                ServiceParameterValidator.ValidateXuid(callerIdentity.Xuid);
                RewardsServiceAdapter.GrantAchievements(grantAchievements.GameId, callerIdentity.Xuid, grantAchievements.AppId, grantAchievements.Achievements, locale);
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, grantAchievements, locale, platformType);
                RewardsServiceUtility.RejectInput("POST GrantAchievements", RewardsEvents.BadGrantAchievementsPost, ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                RewardsServiceUtility.HandleException("POST GrantAchievements", ex, HttpStatusCode.Unauthorized, RewardsEvents.AuthenticationFailure, "Unauthorized.", true);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, grantAchievements, locale, platformType);
                RewardsServiceUtility.HandleException("POST GrantAchievements", ex, HttpStatusCode.InternalServerError, RewardsEvents.UnexpectedFailure, "Unknown Exception.", true);
            }
            finally
            {
                RewardsServiceRest.Counters.EndRequest(requestFailed);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private static void GrantAvatarAssetsInternal(GrantAvatarAssets grantAvatarAssets)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "GrantAvatarAssetsInternal");

            bool requestFailed = false;

            // X-locale and X-PlatformType headers must exist and be valid.
            string locale;
            string platformType;

            // This call does not throw, or rather if it throws, there is no good way of handling it.
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            try
            {
                RewardsServiceRest.Counters.StartRequest(RewardsMethod.PostGrantAvatarAssets);

                RewardsServiceUtility.ValidatePlatformTypeAgainstClaim(platformType);

                RewardsServiceUtility.ValidateTitleIDAgainstClaim(grantAvatarAssets.GameId);

                RewardsServiceUtility.ValidatePostGrantAvatarAssets(grantAvatarAssets, locale, platformType);

                var callerIdentity = RewardsServiceUtility.CallerIdentity;
                ServiceParameterValidator.ValidateXuid(callerIdentity.Xuid);

                RewardsServiceAdapter.GrantAvatarAssets(grantAvatarAssets.GameId, callerIdentity.Xuid, grantAvatarAssets.AppId, grantAvatarAssets.AvatarAssets, locale);
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, grantAvatarAssets, locale, platformType);
                RewardsServiceUtility.RejectInput("POST GrantAvatarAssets", RewardsEvents.BadGrantAvatarAssetsPost, ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                RewardsServiceUtility.HandleException("POST GrantAvatarAssets", ex, HttpStatusCode.Unauthorized, RewardsEvents.AuthenticationFailure, "Unauthorized.", true);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, grantAvatarAssets, locale, platformType);
                RewardsServiceUtility.HandleException("POST GrantAvatarAssets", ex, HttpStatusCode.InternalServerError, RewardsEvents.UnexpectedFailure, "Unknown Exception.", true);
            }
            finally
            {
                RewardsServiceRest.Counters.EndRequest(requestFailed);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private static string InternalPostGameResult(GameResult gameResult)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "InternalPostGameResult");

            
            bool requestFailed = false;
            // X-locale header must exist and be valid.
            string locale;

            // X-Platform-Type must exist and be valid.
            string platformType;

            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            try
            {
               RewardsServiceRest.Counters.StartRequest(RewardsMethod.PostGameResult);

               var callerIdentity = RewardsServiceUtility.CallerIdentity;

               if (gameResult == null)
               {
                   // send 400 (bad request) back
                   throw new RewardsDataAccessValidationException("GameResult is null");
               }

               // log business intelligence data, need to log before any validations
               try
               {
                   BILogging.LogBIData(
                       OriginatorIDType.Xbox,  
                       callerIdentity.Xuid,
                       platformType,
                       gameResult.GameId,
                       "GDS.Services.Rewards",
                       "PostGameResult");
               }
               catch (Exception ex)
               {
                   // None of this should throw, but take no chance
                   Logging.TraceException(ex, "{0}: {1}",
                       RewardsServiceRest.ComponentName,
                       "Unexpected exception caught while writing BI data");
               }

               RewardsServiceUtility.ValidatePlatformTypeAgainstClaim(platformType);

               RewardsServiceUtility.ValidateTitleIDAgainstClaim(gameResult.GameId);

                // Throws ArgumentException
                ISubmitGameResult submitGameResult = Container.Instance.GetComponent<ISubmitGameResult>();

                // validate the game result and submit, this call does both
                submitGameResult.Submit(
                        new CompositeGameResult()
                            {
                                GameResult = gameResult,
                                Locale = locale,
                                PlatformType = platformType,
                                Xuid = callerIdentity.Xuid
                            },
                            GameResultSubmissionEnum.RewardsServiceSubmission);

                WebOperationContext.Current.OutgoingResponse.StatusCode = HttpStatusCode.Accepted;
            }
            catch (RewardsDataAccessOperationException ex)
            {
                // Map these errors to 500, as it is indicative of an Internal Server error
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, gameResult, locale, platformType);
                RewardsServiceUtility.HandleException("POST GameResult", ex, HttpStatusCode.InternalServerError, RewardsEvents.UnexpectedFailure, null, true);
            }
            catch (RewardsDataAccessValidationException ex)
            {
                // Map these errors to 400, as it is indicative of bad game result
                requestFailed = true;
                RewardsServiceUtility.StoreCallParametersInException(ex, gameResult, locale, platformType);
                RewardsServiceUtility.RejectInput("POST GameResult", RewardsEvents.BadGameResultPost, ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                RewardsServiceUtility.HandleException("POST GameResult", ex, HttpStatusCode.Unauthorized, RewardsEvents.AuthenticationFailure, "Unauthorized.", true);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                RewardsServiceUtility.HandleException("POST GameResult", ex, HttpStatusCode.InternalServerError, RewardsEvents.UnexpectedFailure, "Unknown Exception.", true);
            }
            finally
            {
                RewardsServiceRest.Counters.EndRequest(requestFailed);
            }

            return string.Empty;
        }

        private void Instance_OnProvideFault(object sender, WcfProvideFaultEventArgs e)
        {
            bool isProcessed = true;

            if (e.Exception != null)
            {
                // Don't process LIVEnExceptions OR WebProtocolExceptions
                if (e.Exception is LIVEnException ||
                    e.Exception is WebProtocolException)
                {
                    return;
                }
                else if (e.Exception.Data.Contains(typeof(RewardsServiceRest)))
                {
                    // If we have previously processed this, don't process it, either.
                    return;
                }

                e.Exception.Data[typeof(RewardsServiceRest)] = isProcessed;

                Logging.TraceInformation("{0}: {1}", RewardsServiceRest.ComponentName, e.Exception.ToString());

                // List the exceptions that we convert into a BadRequest.
                if (e.Exception is FormatException ||
                    e.Exception is SerializationException)
                {
                    e.WebOperationContext.OutgoingResponse.StatusCode = HttpStatusCode.BadRequest;
                }
            }
        }

        private void Instance_OnHandleError(object sender, WcfHandleErrorEventArgs e)
        {
            if(e.Exception != null)
            {
                // Don't process LIVEnExceptions OR WebProtocolExceptions
                if (e.Exception is LIVEnException ||
                    e.Exception is WebProtocolException)
                {
                    return;
                }
                else if (e.Exception.Data.Contains(typeof(RewardsServiceRest)))
                {
                    // If we have previously processed this, don't process it, either.
                    return;
                }

                if (!e.Exception.Data.Contains(typeof(RewardsServiceRest)))
                {
                    Logging.TraceInformation("{0}: {1}", RewardsServiceRest.ComponentName, e.Exception.ToString());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsQueueHealth.cs ===
﻿namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Specialized;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using Leet.Health.Common;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// QueueHealth Health Page Check.
    /// We will be simulating an authenticated GameResult submission for a BVT title.
    /// Even though this data travels all the way to the DB, 
    /// No actual production Game OR actual user stat does get effected.
    /// </summary>
    public class RewardsQueueHealth : IHealthBlock
    {
        /// <summary>
        /// A bogus Xuid, this information will travel all the way to the UserData DB.
        /// </summary>
        private const long HealthXuid = 1;

        /// <summary>
        /// The English Locale, this data matches the GMS entry for relevant game.
        /// </summary>
        private const string HealthLocale = "en-us";
        
        /// <summary>
        /// This Id, is a GMS BVT title. If for whatever reasom GMS entries do change, this needs updating.
        /// </summary>
        private const uint HealthGameId = 5000;

        /// <summary>
        /// The GMS BVT title Variant setting.
        /// </summary>
        private const uint HealthVariant = 0;

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int32.ToString"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

            RewardsQueueHealthReport myReport = new RewardsQueueHealthReport();
            report.ExtendedReport = myReport;

            // Fill out report
            myReport.Component = config.ComponentName;

            try
            {
                ISubmitGameResult submitGameResult = Container.Instance.GetComponent<ISubmitGameResult>();

                CompositeGameResult cgr =  new CompositeGameResult()
                {
                    GameResult = new GameResult()
                    {
                        GameId = HealthGameId,
                        Variant = HealthVariant,
                        GameResultId = Guid.NewGuid(),
                        Outcome = "Win",
                        Score = 1,
                        Time = 1,
                        TimeStamp = DateTime.Now
                    },
                    Locale = HealthLocale,
                    PlatformType = ((int)PlatformType.Mobile).ToString(),
                    Xuid = HealthXuid
                };

                submitGameResult.Submit(cgr, GameResultSubmissionEnum.RewardsServiceSubmission);

                // Wrap it up
                myReport.Message = "Bogus GameResult submission has succeeded";
                myReport.CompositeGameResult = cgr;
                report.HealthStatus = HealthStatusEnum.Green;  // we always succeed
            }
            catch (Exception ex)
            {
                // Health pages should not crash the process. catching ALL exceptions are fine here.
                Logging.TraceException(ex, RewardsServiceRest.ComponentName);
                myReport.Message = ex.ToString();
                report.HealthStatus = HealthStatusEnum.Red;  
            }
        }
    }

    /// <summary>
    /// The extended healthport class for internal network access. 
    /// </summary>
    public class RewardsQueueHealthReport : IExtendedHealthReport
    {
        /// <summary>
        /// The component name.
        /// </summary>
        public string Component { get; set; }

        /// <summary>
        /// The extended message. 
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// The GameResult submission bogus Data
        /// </summary>
        public CompositeGameResult CompositeGameResult { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsServiceUtility.cs ===
﻿namespace Gds.Services.Rewards
{
    using System;
    using System.Web;
    using System.Net;
    using System.Text;
    using Gds.Contracts;
    using Gds.Services;
    using Leet.Core;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;

    public sealed class RewardsServiceUtility
    {
        static readonly DateTime MinGrantAchievementUTC = new DateTime(2010,01,01).ToUniversalTime();

        /// <summary>
        /// Private constructor to prevent instantiation
        /// </summary>
        private RewardsServiceUtility() { }

        /// <summary>
        /// Component Name
        /// </summary>
        public const string ComponentName = "RewardsService";


        /// <summary>
        /// Validate the platformType against the patform type in the authentication token
        /// </summary>
        /// <param name="platformTypeAsString">Platform type to be verified</param>
        ///<exception cref="WebProtocolExceptiom">If validation fails throws exception with status code HTTP 400 (Bad Request)</exception>
        public static void ValidatePlatformTypeAgainstClaim(String platformTypeAsString)
        {
            Object tokenplatformType = 0;
            Int32 platformType = 0;

            if (!Int32.TryParse(platformTypeAsString, out platformType) ||
                !ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.PlatformClaimType, out tokenplatformType) ||
                !ServiceParameterValidator.NormalizePlatformType(Convert.ToInt32(tokenplatformType)).Equals(ServiceParameterValidator.NormalizePlatformType(platformType)))
            {
                RejectInput("ValidatePlatformTypeAgainstClaim", RewardsEvents.ValidPlatformTypeNotProvided, null, platformTypeAsString);
            }
        }

        /// <summary>
        /// Validate the titleId against the titleID in the authentication token
        /// The titleID from the token comes in a HEX String format
        /// </summary>
        /// <param name="titleId">Title ID to be verified</param>
        ///<exception cref="WebProtocolExceptiom">If validation fails throws exception with status code HTTP 400 (Bad Request)</exception>
        public static void ValidateTitleIDAgainstClaim(UInt32 titleId)
        {
            Object tokenTitleID = null;
            if (!ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.TitleIdClaimType, out tokenTitleID) ||
                !Convert.ToUInt32(tokenTitleID.ToString(), 16).Equals(titleId))
            {
                RejectInput("ValidateTitleIDAgainstClaim", RewardsEvents.ValidTitleIdNotProvided, null, Convert.ToString(titleId));
            }
        }


        /// <summary>
        /// If the title id is found in the white list return false, means not to perform purchase verification
        /// The white list is stored in NPDB
        /// </summary>
        public static bool PerofrmPurchaseVerification(uint titleId)
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            String titleIdwhiteList = configProvider.GetSetting(Settings.RewardsZestTitleIDWhiteList); //get the white list from npdb

            bool performVerification = true;
            if (!String.IsNullOrEmpty(titleIdwhiteList))
            {
                String[] whiteList = titleIdwhiteList.Split(new char[] { ',' });

                if (whiteList != null && whiteList.Length != 0)
                {
                    // validate against the white list 
                    for (Int32 count = 0; count < whiteList.Length; count++)
                    {
                        UInt32 whiteListTitleId = 0;
                        if (UInt32.TryParse(whiteList[count], System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out whiteListTitleId) &&   //titleId's will be in String. Parse it to UInt32
                            whiteListTitleId == titleId)
                        {
                            performVerification = false;
                            break;
                        }
                    }
                }
            }

            return performVerification;
        }

        /// <summary>
        /// Get the current user identity from the request context
        /// </summary>
        /// <returns>Current User Identity</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public static IUserIdentity CallerIdentity
        {
            get
            {
                var authManager = Container.Instance.GetComponent<IAuthenticationManager>();

                if (!authManager.IsAuthenticated)
                {
                    throw new UnauthorizedAccessException();
                }

                return authManager.CurrentUser;
            }
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client.
        /// </summary>
        /// <param name="methodName">
        /// Name of the web method from which exception is thrown.
        /// </param>
        /// <param name="ex">Exception object.</param>
        /// <param name="httpStatusCode">Http status code.</param>
        /// <param name="eventCode">Event code.</param>
        /// <param name="additionalMessage">Additional message to log.</param>
        public static void HandleException(string methodName, Exception ex, HttpStatusCode httpStatusCode, int eventCode, string additionalMessage, bool publishEvent)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                    RewardsEvents.Events,
                    eventCode,
                    httpStatusCode,
                    ex,
                    methodName,
                    additionalMessage,
                    publishEvent);
            }

            le.ThrowWebProtocolException();
        }

        public static void RejectInput(string methodName, int errorCode, Exception ex, params string[] args)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                                RewardsEvents.Events,
                                errorCode,
                                HttpStatusCode.BadRequest,
                                ex,
                                methodName,
                                ComposeExceptionDebugMessage(methodName, ex),
                                true,
                                args);
            }

            le.ThrowWebProtocolException();
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client for bad request
        /// </summary>
        public static void RejectInput(string methodName, int errorCode, Exception ex)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                                RewardsEvents.Events,
                                errorCode,
                                HttpStatusCode.BadRequest,
                                ex,
                                methodName,
                                ComposeExceptionDebugMessage(methodName, ex),
                                true);
            }

            le.ThrowWebProtocolException();
        }

        public static string ComposeExceptionDebugMessage(Exception ex)
        {
            return ComposeExceptionDebugMessage(null, ex);
        }

        public static string ComposeExceptionDebugMessage(string methodName, Exception ex)
        {
            StringBuilder sb = new StringBuilder(1024);

            if (!string.IsNullOrEmpty(methodName))
            {
                sb.AppendFormat("Exception caught in Method: {0} \r\n", methodName);
            }

            if (ex != null)
            {
                sb.AppendFormat("\r\n Inner Exception: {0} \r\n", ex.ToString());

                if (ex.Data.Contains(typeof(GameResult)))
                {
                    string gameResult = ex.Data[typeof(GameResult)] as string;
                    if (!string.IsNullOrEmpty(gameResult))
                    {
                        sb.AppendFormat("GameResultParameters: \r\n {0}", gameResult);
                    }
                }
                else if (ex.Data.Contains(typeof(GrantAchievements)))
                {
                    string grantAchievements = ex.Data[typeof(GrantAchievements)] as string;
                    if (!string.IsNullOrEmpty(grantAchievements))
                    {
                        sb.AppendFormat("GrantAchievementsParameters: \r\n {0}", grantAchievements);
                    }
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// <summary>
        /// When validation fails, ArgumentException or a derived type will bubble up.
        /// When a GMS call fails for whatever reason, we do throw InvalidOperationException, 
        /// with the InnerException set to the actual exception
        /// </summary>
        /// </summary>
        /// <param name="grantAchievements">GrantAchievement request body.</param>
        /// <param name="locale">Locale of the request.</param>
        /// <param name="platformType">Platform type of the request.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.Parse(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "System.Guid")]
        public static void ValidatePostGrantAchievement(GrantAchievements grantAchievements, string locale, string platformType)
        {
            // a non-null game Result must exist.
            if (grantAchievements == null)
            {
                throw new ArgumentNullException("grantAchievements", "GrantAchievements object not set to an instance");
            }
            else
            {
                Logging.TraceVerbose("{0}: ValidatePostGrantAchievement {1} | {2}", ComponentName, grantAchievements.GameId, grantAchievements.AppId);
            }


            // Throws ArgumentNullException for null and FormatException for empty AppId, which we are ok with.
            // All other exceptions are converted to WebProtocolException per agreement of this inteface.
            try
            {
                new Guid(grantAchievements.AppId);
            }
            catch (OverflowException ex)
            {
                throw new ArgumentException("AppId", ex);
            }
            catch (FormatException ex)
            {
                throw new ArgumentException("AppId", ex);
            }

            ServiceParameterValidator.ValidateAgainstGmsBasic(grantAchievements.GameId, locale, platformType);
            uint platformTypeNum = uint.Parse(platformType);

            // Throw AccessViolationException if platform type is not mobile
            if (platformTypeNum != (uint)Leet.Core.Platforms.PlatformType.Mobile)
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest, "PlatformType validation failed", null);
            }

            if (grantAchievements.Achievements == null || grantAchievements.Achievements.Count == 0)
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest,"No achievements found", null);
            }

            foreach (AchievementEarned achievementEarned in grantAchievements.Achievements)
            {
                uint result;
                if (!uint.TryParse(achievementEarned.Key, out result))
                {
                    throw new  WebProtocolException(HttpStatusCode.BadRequest,"Invalid Achievement key", null);
                }

                //Earned achivement time should be less than 01/01/2010 and greater than 24 hours + the current server time
                DateTime universalTime = achievementEarned.EarnedDateTime.ToUniversalTime();
                if (universalTime < MinGrantAchievementUTC ||
                    universalTime > DateTime.UtcNow.AddHours(24.00))
                {
                    throw new WebProtocolException(HttpStatusCode.BadRequest, String.Format(System.Globalization.CultureInfo.CurrentUICulture, "Invalid EarnedDateTime for achievement with key {0}", achievementEarned.Key), null);
                }
            }
        }

        /// <summary>
        /// <summary>
        /// When validation fails, ArgumentException or a derived type will bubble up.
        /// When a GMS call fails for whatever reason, we do throw InvalidOperationException, 
        /// with the InnerException set to the actual exception
        /// </summary>
        /// </summary>
        /// <param name="grantAvatarAssets">GrantAvatarAssets request body.</param>
        /// <param name="locale">Locale of the request.</param>
        /// <param name="platformType">Platform type of the request.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.Parse(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "System.Guid")]
        public static void ValidatePostGrantAvatarAssets(GrantAvatarAssets grantAvatarAssets, string locale, string platformType)
        {
            // a non-null grantAvatarAssets must exist.
            if (grantAvatarAssets == null)
            {
                throw new ArgumentNullException("grantAvatarAssets", "GrantAvatarAssets object not set to an instance");
            }
            else
            {
                Logging.TraceVerbose("{0}: ValidatePostGrantAvatarAssets {1} | {2}", ComponentName, grantAvatarAssets.GameId, grantAvatarAssets.AppId);
            }


            // Throws ArgumentNullException for null and FormatException for empty AppId, which we are ok with.
            // All other exceptions are converted to WebProtocolException per agreement of this inteface.
            try
            {
                new Guid(grantAvatarAssets.AppId);
            }
            catch (OverflowException ex)
            {
                throw new ArgumentException("AppId", ex);
            }
            catch (FormatException ex)
            {
                throw new ArgumentException("AppId", ex);
            }

            ServiceParameterValidator.ValidateAgainstGmsBasic(grantAvatarAssets.GameId, locale, platformType);
            uint platformTypeNum = uint.Parse(platformType);

            // Throw AccessViolationException if platform type is not mobile
            if (platformTypeNum != (uint)Leet.Core.Platforms.PlatformType.Mobile)
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest, "PlatformType validation failed", null);
            }

            if (grantAvatarAssets.AvatarAssets == null || grantAvatarAssets.AvatarAssets.Count == 0)
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest, "No avatar assets found", null);
            }

            foreach (AvatarAssetEarned avatarAssetEarned in grantAvatarAssets.AvatarAssets)
            {
                uint result;
                if (!uint.TryParse(avatarAssetEarned.Key, out result))
                {
                    throw new WebProtocolException(HttpStatusCode.BadRequest, "Invalid AvatarAsset key", null);
                }

                //Earned avatar asset time should be less than 01/01/2010 and greater than 24 hours + the current server time
                DateTime universalTime = avatarAssetEarned.EarnedDateTime.ToUniversalTime();
                if (universalTime < MinGrantAchievementUTC ||
                    universalTime > DateTime.UtcNow.AddHours(24.00))
                {
                    throw new WebProtocolException(HttpStatusCode.BadRequest, String.Format(System.Globalization.CultureInfo.CurrentUICulture, "Invalid EarnedDateTime for avatarAssetEarned with key {0}", avatarAssetEarned.Key), null);
                }
            }
        }

        public static string DumpGameResultParameters(GameResult gameResult, string locale, string platformType)
        {
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat("Locale: '{0}'. \r\n", locale);
            sb.AppendFormat("Platform: '{0}'. \r\n", platformType);

            if (gameResult != null)
            {
                sb.AppendFormat("GameResult.GameId: '{0}'. \r\n", gameResult.GameId);
                sb.AppendFormat("GameResult.Variant: '{0}'. \r\n", gameResult.Variant);
                sb.AppendFormat("GameResult.Score: '{0}'. \r\n", gameResult.Score);
                sb.AppendFormat("GameResult.Time: '{0}'. \r\n", gameResult.Time);
                sb.AppendFormat("GameResult.Outcome: '{0}'. \r\n", gameResult.Outcome);
                sb.AppendFormat("GameResult.TimeStamp: '{0}'. \r\n", gameResult.TimeStamp);
                sb.AppendFormat("GameResult.GameResultId: '{0}'. \r\n", gameResult.GameResultId);

                if (gameResult.Blob != null)
                {
                    sb.AppendFormat("Blob Length: '{0}'. \r\n", gameResult.Blob.Length);
                }
            }

            return sb.ToString();
        }

        public static string DumpGrantAchievementsParameters(GrantAchievements grantAchievements, string locale, string platformType)
        {
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat("Locale: '{0}'. \r\n", locale);
            sb.AppendFormat("Platform: '{0}'. \r\n", platformType);

            if (grantAchievements != null)
            {
                sb.AppendFormat("GrantAchievements.GameId: '{0}'. \r\n", grantAchievements.GameId);
                sb.AppendFormat("GrantAchievements.AppId: '{0}'. \r\n", grantAchievements.AppId);

                if (grantAchievements.Achievements != null && grantAchievements.Achievements.Count > 0)
                {
                    int index = 0;
                    foreach (AchievementEarned achievement in grantAchievements.Achievements)
                    {
                        sb.AppendFormat("Achievements[{0}].Key: '{1}'. \r\n", index, achievement.Key);
                        sb.AppendFormat("Achievements[{0}].EarnedOnline: '{1}'. \r\n", index, achievement.EarnedOnline);
                        sb.AppendFormat("Achievements[{0}].EarnedDateTime: '{1}'. \r\n", index, achievement.EarnedDateTime);
                        index++;
                    }
                }
            }

            return sb.ToString();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public static void ValidateXuid(ulong xuid)
        {
            if (xuid == 0)
            {
                throw new ArgumentException("xuid cannot be fetched for user");
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "object")]
        public static void StoreCallParametersInException(Exception ex, object callObject, string locale, string platformType)
        {
            string storeParam = null;

            if (callObject != null)
            {
                if (ex != null)
                {
                    if (callObject.GetType() == typeof(GrantAchievements))
                    {
                        storeParam = DumpGrantAchievementsParameters(callObject as GrantAchievements, locale, platformType);
                    }
                    else if (callObject.GetType() == typeof(GameResult))
                    {
                        storeParam = DumpGameResultParameters(callObject as GameResult, locale, platformType);
                    }
                }

                if (!ex.Data.Contains(callObject.GetType()))
                {
                    ex.Data.Add(callObject.GetType(), storeParam);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\SubmitEventOperationContext.cs ===
﻿namespace Gds.Services.Rewards
{
    using System;
    using Gds.Contracts;

    public class SubmitEventOperationContext
    {
        public SubmitEventOperationContext(GameEvent ge)
        {
            this.GameEvent = ge;
        }

        public GameEvent GameEvent { get; set; }
        public Exception Exception { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\AcquisitionInfoRequest.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    [DataContract(Name = "AcquisitionInfoRequest", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class AcquisitionInfoRequest
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly"), DataMember(Name = "AppAcquisitionInfoInputs", IsRequired = true)]
        public List<AppAcquisitionInfoInput> AppAcquisitionInfoInputs { get; set; }
    }

    [DataContract(Name = "AppAcquisitionInfoInput", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class AppAcquisitionInfoInput
    {
        [DataMember(Name = "AppID", IsRequired = true)]
        public Guid AppId { get; set; }

        [DataMember(Name = "LiveEngagementID", IsRequired = false)]
        public string LiveEngagementId { get; set; }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\BaseResponse.cs ===
﻿namespace Gds.Services.Rewards
{
    using System.Runtime.Serialization;

    /// <summary>
    /// Base class for the Response DataContract objects.
    /// This includes the <Error> element.
    /// Note: The data member elements in this base class will be first in the ordering of the serialized XML.
    /// </summary>
    [DataContract(Name = "BaseResponse", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class BaseResponse
    {
        [DataMember(Name = "Error", Order = 10, EmitDefaultValue = false)]
        public Error Error { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestPurchaseVerificationProvider.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Xml;
    using Gds.Contracts;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// ZestPurchaseVerificationProvider class
    /// </summary>
    public class ZestPurchaseVerificationProvider : IPurchaseVerification
    {
        private const string ZEST_ERROR_E_ASSET_ITEM_NOT_PURCHASED = "C101A7D1";
        private const string ZEST_ERROR_E_ASSET_ITEM_PURCHASED_LIVEENGAGEMENTID_MISMATCH = "C101A7DC";
        private const string ZEST_TOS_REACCEPT_REQUIRED = "C101A24F";
        private const string ZEST_TOS_ACCEPT_REQUIRED = "C101A21B";
        private string zestBaseUrl;

        private RewardsCounters Counters { get; set; } 

        /// <summary>
        /// Initializes a new instance of the ZestPurchaseVerificationProvider class
        /// </summary>
        public ZestPurchaseVerificationProvider()
        {
            this.zestBaseUrl = RewardsConfig.ZestUrl;
            this.Counters = new RewardsCounters();
        }

        /// <summary>
        /// Sign in request
        /// </summary>
        /// <param name="xuid">User's identity</param>
        /// <param name="cookie">Cookie retrieved after authentication</param>
        /// <param name="errCode">Error code</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public void SignIn(string xuid, out string cookie, out uint errCode)
        {
            
            bool requestFailed = false;
            string signInUrl = string.Empty;
            string postData = string.Empty;
            string response = string.Empty;
            try
            {
                this.Counters.StartRequest(RewardsMethod.ZestSignIn);

                errCode = LIVEnErrorCode.S_OK;
                cookie = string.Empty;
                signInUrl = this.zestBaseUrl + "/v2/account/signin";

                SignInRequest request = new SignInRequest
                {
                    TunerInfo = new TunerInfo
                    {
                        TunerId = "324b6709-a1b5-4111-b0ea-cdc23d6d1905",
                        Name = "Live Engagement",
                        Type = "zuneMobile",
                        Version = "7.0"
                    }
                };
                
                postData = SerializerDeserializer.SerializeToString(request);
                IDictionary<string, string> headers = new Dictionary<string, string>();
                headers.Add("Authorization", "ZTRUST1.0 XboxLiveId=" + xuid);

                response = ZestPurchaseVerificationProvider.PostRequest(signInUrl, postData, headers, "ZuneECommerce", out cookie);

                if (string.IsNullOrEmpty(cookie))
                {
                    errCode = LIVEnErrorCode.LIVEN_ZEST_SIGNIN_INVALID_XUID;
                }
            }
            catch (Exception e)
            {
                string errorMessage = string.Format("Error on ZEST SignIn: signInUrl:{0}, xuid:{1}, postData:{2}\n\n Zest response data: \n {3}", signInUrl, xuid, postData, response);

                cookie = string.Empty;
                errCode = LIVEnErrorCode.LIVEN_ZEST_UNKNOWN_REQUEST_ERROR;
                requestFailed = true;

                if (IsValidError(response))
                {
                    RewardsServiceUtility.HandleException(
                        "SignIn",
                        e,
                        HttpStatusCode.InternalServerError,
                        RewardsEvents.ZestSignInRequestError,
                        errorMessage,
                        true);
                }
                else
                {
                    RewardsServiceUtility.HandleException(
                       "SignIn",
                       e,
                       HttpStatusCode.InternalServerError,
                       RewardsEvents.ZestSignInRequestError,
                       errorMessage,
                       false);
                }
            }
            finally
            {
                this.Counters.EndRequest(requestFailed);
            }
        }

        /// <summary>
        /// Verify that purchase has been made on the title
        /// </summary>
        /// <param name="appId">User's application identifier</param>
        /// <param name="titleId">User's title id</param>
        /// <param name="xuid">User's identity</param>
        /// <param name="cookie">Cookie required for making Zest call</param>
        /// <param name="errCode">Error code</param>
        /// <param name="errMessage">Zest error response</param>
        /// <returns>Returns whether the user has purchasd the title</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public bool VerifyPurchase(Guid appId, uint titleId, string xuid, string cookie, out uint errCode, out string errMessage)
        {
            bool requestFailed = false;
            bool purchasedResponse = false;
            errCode = LIVEnErrorCode.S_OK;
            errMessage = string.Empty;
            string verifyPastPurchaseUrl = string.Empty;
            string postData = string.Empty;
            string response = string.Empty;
            try
            {
                this.Counters.StartRequest(RewardsMethod.ZestVerifyPurchase);
                verifyPastPurchaseUrl = this.zestBaseUrl + "/v2/billing/verifypastpurchase";

                List<AppAcquisitionInfoInput> list = new List<AppAcquisitionInfoInput>();
                AppAcquisitionInfoInput infoInput = new AppAcquisitionInfoInput
                {
                    AppId = appId,
                    LiveEngagementId = titleId.ToString("X")
                };

                list.Add(infoInput);
                
                AcquisitionInfoRequest request = new AcquisitionInfoRequest
                {
                    AppAcquisitionInfoInputs = list
                };

                postData = SerializerDeserializer.SerializeToString(request);

                IDictionary<string, string> headers = new Dictionary<string, string>();
                headers.Add("Authorization", "ZTRUST1.0 XboxLiveId=" + xuid);

                response = ZestPurchaseVerificationProvider.PostRequest(verifyPastPurchaseUrl, postData, headers, cookie);

                AcquisitionInfoResponse acquisitionInfo = (AcquisitionInfoResponse)ZestPurchaseVerificationProvider.SerializeFromXml(response, typeof(AcquisitionInfoResponse));

                purchasedResponse = ZestPurchaseVerificationProvider.ParseResponse(acquisitionInfo, out errCode);
                errMessage = response;
            }
            catch (Exception e)
            {
                string errorMessage =
                    string.Format(
                        "Error on ZEST SignIn- verifyPastPurchaseUrl:{0}, appId:{1}, titleId:{2}, xuid:{3}, cookie:{4}, postData:{5}, response:{6}",
                        verifyPastPurchaseUrl, appId, titleId, xuid, cookie, postData, response);
                requestFailed = true;
                errCode = LIVEnErrorCode.LIVEN_ZEST_UNKNOWN_REQUEST_ERROR;
                RewardsServiceUtility.HandleException(
                    "VerifyPurchase",
                    e,
                    HttpStatusCode.InternalServerError,
                    RewardsEvents.ZestVerifyPastPurchaseRequestError,
                    errorMessage,
                    true);
            }
            finally
            {
                this.Counters.EndRequest(requestFailed);
            }

            return purchasedResponse;
        }


        /// <summary>
        /// Parses SignInResponse and determine correct error code.
        /// Since Zest returns an HTTP 500 for all errors including when the user has not accepted or needs to accept the TOS,
        /// we need to filter out these codes so that unnecesary alerts will not be fired for these error codes.
        /// </summary>
        /// <param name="signInResponse">SignInResponse response</param>
        /// <returns>Returns whether the response is a valid error</returns>
        private static bool IsValidError(string signInResponse)
        {
            try
            {
                SignInResponse signIn = (SignInResponse)ZestPurchaseVerificationProvider.SerializeFromXml(signInResponse, typeof(SignInResponse));
                if (signIn.Error == null)
                {
                    return true;
                }

                // 500 Errors to be ignored
                if (signIn.Error.ErrorCode == ZEST_TOS_ACCEPT_REQUIRED
                    || signIn.Error.ErrorCode == ZEST_TOS_REACCEPT_REQUIRED)
                {
                    return false;
                }
            }
            catch (Exception)
            {
                // Log and absorb exception
                Logging.TraceWarning("Error parsing ZEST Sign In: {0}", signInResponse);
            }

            return true;
        }

        /// <summary>
        /// Parses AcquisitionInfoResponse and determine correct error code
        /// </summary>
        /// <param name="acquisitionInfo">Acquistion info response</param>
        /// <param name="errCode">Error code of the response</param>
        /// <returns>Returns whether user has purchase the title</returns>
        private static bool ParseResponse(AcquisitionInfoResponse acquisitionInfo, out uint errCode)
        {
            AppAcquisitionInfoOutput output = acquisitionInfo.AppAcquisitionInfoOutputs[0];
            errCode = LIVEnErrorCode.LIVEN_ZEST_UNKNOWN_REQUEST_ERROR;
            
            if (output.Error == null)
            {
                errCode = LIVEnErrorCode.S_OK; 
                return true;
            }

            if (output.Error.ErrorCode == ZEST_ERROR_E_ASSET_ITEM_NOT_PURCHASED)
            {
                errCode = LIVEnErrorCode.LIVEN_ZEST_ITEM_NOT_PURCHASED;
            }
            else if (output.Error.ErrorCode == ZEST_ERROR_E_ASSET_ITEM_PURCHASED_LIVEENGAGEMENTID_MISMATCH)
            {
                errCode = LIVEnErrorCode.LIVEN_ZEST_ITEM_PURCHASED_TITLEID_MISMATCHED;
            }

            return false;
        }

        /// <summary>
        /// Post a request and retrieves cookie
        /// </summary>
        /// <param name="url">Request url</param>
        /// <param name="postData">Post request data</param>
        /// <param name="headers">Request header</param>
        /// <param name="cookieName">Name of cookie to be retrieved</param>
        /// <param name="responseCookie">Cookie returned in response</param>
        /// <returns>Response data</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.Object)")]
        private static string PostRequest(string url, string postData, IDictionary<string, string> headers, string cookieName, out string responseCookie)
        {
            byte[] postdatabytes = Encoding.ASCII.GetBytes(postData);

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.Method = "POST";
            request.ContentType = "text/xml";
            string proxyAddress = RewardsConfig.ProxyAddress;
            if(!string.IsNullOrEmpty(proxyAddress))
            {
                request.Proxy = new WebProxy(proxyAddress);
            }

            ZestPurchaseVerificationProvider.AddStandardHeaders(request, headers);
            string responseData = string.Empty;
            responseCookie = string.Empty;
            CookieContainer cookieContainer = new CookieContainer();
            request.CookieContainer = cookieContainer;

            try
            {
                Stream newStream = request.GetRequestStream();
                newStream.Write(postdatabytes, 0, postdatabytes.Length);
                newStream.Close();

                using (WebResponse response = request.GetResponse())
                {
                    using (Stream objStream = response.GetResponseStream())
                    {
                        StreamReader objReader = new StreamReader(objStream);
                        responseData = objReader.ReadToEnd();

                        CookieCollection cookieCollection = cookieContainer.GetCookies(response.ResponseUri);
                        responseCookie = Convert.ToString(cookieCollection[cookieName]);
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }

            return responseData;
        }

        /// <summary>
        /// Post a http request with a cookie
        /// </summary>
        /// <param name="url">Request url</param>
        /// <param name="postData">Post request data</param>
        /// <param name="headers">Request header</param>
        /// <param name="requestCookie">Cookie added to request</param>
        /// <returns>Response string</returns>
        private static string PostRequest(string url, string postData, IDictionary<string, string> headers, string requestCookie)
        {
            byte[] postdatabytes = Encoding.ASCII.GetBytes(postData);
    
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.Method = "POST";
            request.ContentType = "text/xml";
            string proxyAddress = RewardsConfig.ProxyAddress;
            if (!string.IsNullOrEmpty(proxyAddress))
            {
                request.Proxy = new WebProxy(proxyAddress);
            }

            ZestPurchaseVerificationProvider.AddStandardHeaders(request, headers);
            string responseData = string.Empty;

            request.CookieContainer = new CookieContainer();
            request.CookieContainer.SetCookies(request.RequestUri, requestCookie);
            WebResponse response = null;
            StreamReader objReader = null;
            try
            {
                Stream newStream = request.GetRequestStream();
                newStream.Write(postdatabytes, 0, postdatabytes.Length);
                newStream.Close();

                using (response = request.GetResponse())
                {
                    using (Stream objStream = response.GetResponseStream())
                    {
                        objReader = new StreamReader(objStream);
                        responseData = objReader.ReadToEnd();
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }

            return responseData;
        }

        /// <summary>
        /// Adding standard headers to http request
        /// </summary>
        /// <param name="hwrRequest">Http request</param>
        /// <param name="headers">Dictionary of headers</param>
        private static void AddStandardHeaders(HttpWebRequest hwrRequest, IDictionary<string, string> headers)
        {
            foreach (KeyValuePair<string, string> keyValuePair in headers)
            {
                hwrRequest.Headers.Add(keyValuePair.Key, keyValuePair.Value);
            }
        }

        /// <summary>
        /// Creates an object from an XML string
        /// </summary>
        /// <param name="xml">XML string</param>
        /// <param name="objType">Object type</param>
        /// <returns>Serialized object</returns>
        private static object SerializeFromXml(string xml, System.Type objType)
        {
            StringReader stringReader = new StringReader(xml);
            XmlTextReader xmlReader = new XmlTextReader(stringReader);

            DataContractSerializer dcs = new DataContractSerializer(objType);
            object obj = dcs.ReadObject(xmlReader);
            xmlReader.Close();
            stringReader.Close();

            return obj;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Gds.Services.Rewards.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Gds.Services.Rewards.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
        ///&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en-US&quot; lang=&quot;en-US&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;title&gt;Rewards Service Front End - Documentation&lt;/title&gt;
        ///    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        ///    &lt;style type=&quot;text/css&quot;&gt;
        ///        body {margin: 0px;padding: 0px;font-family: Calibri, Tahoma, Arial;}
        ///        .banner {padding: 5px 5px 5px 15px;background-color: Gray;color: W [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Documentation {
            get {
                return ResourceManager.GetString("Documentation", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\AcquisitionInfoResponse.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    
    [DataContract(Name = "AcquisitionInfoResponse", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class AcquisitionInfoResponse : BaseResponse
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly"), DataMember(Name = "AppAcquisitionInfoOutputs", IsRequired = false)]
        public List<AppAcquisitionInfoOutput> AppAcquisitionInfoOutputs { get; set; }
    }

    [DataContract(Name = "AppAcquisitionInfoOutput", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class AppAcquisitionInfoOutput : BaseResponse
    {
        [DataMember(Name = "AppID", Order = 20, IsRequired = true)]
        public Guid AppId { get; set; }

        [DataMember(Name = "LiveEngagementID", Order = 30, IsRequired = false)]
        public string LiveEngagementId { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\Error.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System.Runtime.Serialization;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Error"), DataContract(Name = "Error", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class Error
    {
        [DataMember(Name = "ErrorCode", IsRequired = true)]
        public string ErrorCode { get; set; }

        [DataMember(Name = "Description", IsRequired = true)]
        public string Description { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\SignInRequest.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System.Runtime.Serialization;

    [DataContract(Name = "SignInRequest", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class SignInRequest
    {
        public SignInRequest() : base()
        {
        }

        [DataMember(Name = "TunerInfo", IsRequired = true)]
        public TunerInfo TunerInfo { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\RewardsServiceProxy\RewardsServiceProxy.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wgx.Services.Gds.RewardsService
{


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "GameEvent", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class GameEvent : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string CategoryField;

        private string CultureField;

        private System.Guid EventIdField;

        private System.Guid EventTypeField;

        private uint GameIdField;

        private System.Guid MessageIdField;

        private Wgx.Services.Gds.RewardsService.Property[] PropertiesField;

        private ulong PuidField;

        private System.Guid SessionIdField;

        private System.DateTime TimeStampField;

        private string TypeKeyNameField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                if ((object.ReferenceEquals(this.CategoryField, value) != true))
                {
                    this.CategoryField = value;
                    this.RaisePropertyChanged("Category");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string Culture
        {
            get
            {
                return this.CultureField;
            }
            set
            {
                if ((object.ReferenceEquals(this.CultureField, value) != true))
                {
                    this.CultureField = value;
                    this.RaisePropertyChanged("Culture");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public System.Guid EventId
        {
            get
            {
                return this.EventIdField;
            }
            set
            {
                if ((this.EventIdField.Equals(value) != true))
                {
                    this.EventIdField = value;
                    this.RaisePropertyChanged("EventId");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public System.Guid EventType
        {
            get
            {
                return this.EventTypeField;
            }
            set
            {
                if ((this.EventTypeField.Equals(value) != true))
                {
                    this.EventTypeField = value;
                    this.RaisePropertyChanged("EventType");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public uint GameId
        {
            get
            {
                return this.GameIdField;
            }
            set
            {
                if ((this.GameIdField.Equals(value) != true))
                {
                    this.GameIdField = value;
                    this.RaisePropertyChanged("GameId");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public System.Guid MessageId
        {
            get
            {
                return this.MessageIdField;
            }
            set
            {
                if ((this.MessageIdField.Equals(value) != true))
                {
                    this.MessageIdField = value;
                    this.RaisePropertyChanged("MessageId");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public Wgx.Services.Gds.RewardsService.Property[] Properties
        {
            get
            {
                return this.PropertiesField;
            }
            set
            {
                if ((object.ReferenceEquals(this.PropertiesField, value) != true))
                {
                    this.PropertiesField = value;
                    this.RaisePropertyChanged("Properties");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public ulong Puid
        {
            get
            {
                return this.PuidField;
            }
            set
            {
                if ((this.PuidField.Equals(value) != true))
                {
                    this.PuidField = value;
                    this.RaisePropertyChanged("Puid");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public System.Guid SessionId
        {
            get
            {
                return this.SessionIdField;
            }
            set
            {
                if ((this.SessionIdField.Equals(value) != true))
                {
                    this.SessionIdField = value;
                    this.RaisePropertyChanged("SessionId");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                if ((this.TimeStampField.Equals(value) != true))
                {
                    this.TimeStampField = value;
                    this.RaisePropertyChanged("TimeStamp");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string TypeKeyName
        {
            get
            {
                return this.TypeKeyNameField;
            }
            set
            {
                if ((object.ReferenceEquals(this.TypeKeyNameField, value) != true))
                {
                    this.TypeKeyNameField = value;
                    this.RaisePropertyChanged("TypeKeyName");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Property", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class Property : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string NameField;

        private string PropertyTypeField;

        private string ValueField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                if ((object.ReferenceEquals(this.NameField, value) != true))
                {
                    this.NameField = value;
                    this.RaisePropertyChanged("Name");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string PropertyType
        {
            get
            {
                return this.PropertyTypeField;
            }
            set
            {
                if ((object.ReferenceEquals(this.PropertyTypeField, value) != true))
                {
                    this.PropertyTypeField = value;
                    this.RaisePropertyChanged("PropertyType");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                if ((object.ReferenceEquals(this.ValueField, value) != true))
                {
                    this.ValueField = value;
                    this.RaisePropertyChanged("Value");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ResultOptions", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class ResultOptions : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private uint CountField;

        private Wgx.Services.Gds.RewardsService.SortOption[] SortOptionsField;

        private uint StartIndexField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public uint Count
        {
            get
            {
                return this.CountField;
            }
            set
            {
                if ((this.CountField.Equals(value) != true))
                {
                    this.CountField = value;
                    this.RaisePropertyChanged("Count");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public Wgx.Services.Gds.RewardsService.SortOption[] SortOptions
        {
            get
            {
                return this.SortOptionsField;
            }
            set
            {
                if ((object.ReferenceEquals(this.SortOptionsField, value) != true))
                {
                    this.SortOptionsField = value;
                    this.RaisePropertyChanged("SortOptions");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public uint StartIndex
        {
            get
            {
                return this.StartIndexField;
            }
            set
            {
                if ((this.StartIndexField.Equals(value) != true))
                {
                    this.StartIndexField = value;
                    this.RaisePropertyChanged("StartIndex");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SortOption", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class SortOption : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string SortDirectionField;

        private string SortEnumField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true, EmitDefaultValue = false)]
        public string SortDirection
        {
            get
            {
                return this.SortDirectionField;
            }
            set
            {
                if ((object.ReferenceEquals(this.SortDirectionField, value) != true))
                {
                    this.SortDirectionField = value;
                    this.RaisePropertyChanged("SortDirection");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true, EmitDefaultValue = false)]
        public string SortEnum
        {
            get
            {
                return this.SortEnumField;
            }
            set
            {
                if ((object.ReferenceEquals(this.SortEnumField, value) != true))
                {
                    this.SortEnumField = value;
                    this.RaisePropertyChanged("SortEnum");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RewardResult", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class RewardResult : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string[] MessagesField;

        private Wgx.Services.Gds.RewardsService.Reward[] RewardsField;

        private uint TotalResultsField;

        private bool WonNewRewardField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public string[] Messages
        {
            get
            {
                return this.MessagesField;
            }
            set
            {
                if ((object.ReferenceEquals(this.MessagesField, value) != true))
                {
                    this.MessagesField = value;
                    this.RaisePropertyChanged("Messages");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public Wgx.Services.Gds.RewardsService.Reward[] Rewards
        {
            get
            {
                return this.RewardsField;
            }
            set
            {
                if ((object.ReferenceEquals(this.RewardsField, value) != true))
                {
                    this.RewardsField = value;
                    this.RaisePropertyChanged("Rewards");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public uint TotalResults
        {
            get
            {
                return this.TotalResultsField;
            }
            set
            {
                if ((this.TotalResultsField.Equals(value) != true))
                {
                    this.TotalResultsField = value;
                    this.RaisePropertyChanged("TotalResults");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(IsRequired = true)]
        public bool WonNewReward
        {
            get
            {
                return this.WonNewRewardField;
            }
            set
            {
                if ((this.WonNewRewardField.Equals(value) != true))
                {
                    this.WonNewRewardField = value;
                    this.RaisePropertyChanged("WonNewReward");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Reward", Namespace = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects")]
    [System.SerializableAttribute()]
    public partial class Reward : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged
    {

        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string CategoryField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string CultureField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string CurrencyTypeField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime DateAwardedField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string DescriptionField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint GameIdField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint IdField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string KeyNameTypeField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string NameField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private Wgx.Services.Gds.RewardsService.Property[] PropertiesField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string RewardUrlField;

        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint ValueField;

        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                if ((object.ReferenceEquals(this.CategoryField, value) != true))
                {
                    this.CategoryField = value;
                    this.RaisePropertyChanged("Category");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Culture
        {
            get
            {
                return this.CultureField;
            }
            set
            {
                if ((object.ReferenceEquals(this.CultureField, value) != true))
                {
                    this.CultureField = value;
                    this.RaisePropertyChanged("Culture");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CurrencyType
        {
            get
            {
                return this.CurrencyTypeField;
            }
            set
            {
                if ((object.ReferenceEquals(this.CurrencyTypeField, value) != true))
                {
                    this.CurrencyTypeField = value;
                    this.RaisePropertyChanged("CurrencyType");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DateAwarded
        {
            get
            {
                return this.DateAwardedField;
            }
            set
            {
                if ((this.DateAwardedField.Equals(value) != true))
                {
                    this.DateAwardedField = value;
                    this.RaisePropertyChanged("DateAwarded");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                if ((object.ReferenceEquals(this.DescriptionField, value) != true))
                {
                    this.DescriptionField = value;
                    this.RaisePropertyChanged("Description");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint GameId
        {
            get
            {
                return this.GameIdField;
            }
            set
            {
                if ((this.GameIdField.Equals(value) != true))
                {
                    this.GameIdField = value;
                    this.RaisePropertyChanged("GameId");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                if ((this.IdField.Equals(value) != true))
                {
                    this.IdField = value;
                    this.RaisePropertyChanged("Id");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string KeyNameType
        {
            get
            {
                return this.KeyNameTypeField;
            }
            set
            {
                if ((object.ReferenceEquals(this.KeyNameTypeField, value) != true))
                {
                    this.KeyNameTypeField = value;
                    this.RaisePropertyChanged("KeyNameType");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                if ((object.ReferenceEquals(this.NameField, value) != true))
                {
                    this.NameField = value;
                    this.RaisePropertyChanged("Name");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Wgx.Services.Gds.RewardsService.Property[] Properties
        {
            get
            {
                return this.PropertiesField;
            }
            set
            {
                if ((object.ReferenceEquals(this.PropertiesField, value) != true))
                {
                    this.PropertiesField = value;
                    this.RaisePropertyChanged("Properties");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RewardUrl
        {
            get
            {
                return this.RewardUrlField;
            }
            set
            {
                if ((object.ReferenceEquals(this.RewardUrlField, value) != true))
                {
                    this.RewardUrlField = value;
                    this.RaisePropertyChanged("RewardUrl");
                }
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                if ((this.ValueField.Equals(value) != true))
                {
                    this.ValueField = value;
                    this.RaisePropertyChanged("Value");
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void RaisePropertyChanged(string propertyName)
        {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null))
            {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(ConfigurationName = "RewardsService.IRewardsService")]
    public interface IRewardsService
    {

        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/IRewardsService/SubmitEvent", ReplyAction = "http://tempuri.org/IRewardsService/SubmitEventResponse")]
        Wgx.Services.Gds.RewardsService.RewardResult SubmitEvent(Wgx.Services.Gds.RewardsService.GameEvent gameEvent, Wgx.Services.Gds.RewardsService.ResultOptions resultOptions);
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface IRewardsServiceChannel : Wgx.Services.Gds.RewardsService.IRewardsService, System.ServiceModel.IClientChannel
    {
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class RewardsServiceClient : System.ServiceModel.ClientBase<Wgx.Services.Gds.RewardsService.IRewardsService>, Wgx.Services.Gds.RewardsService.IRewardsService
    {

        public RewardsServiceClient()
        {
        }

        public RewardsServiceClient(string endpointConfigurationName) :
            base(endpointConfigurationName)
        {
        }

        public RewardsServiceClient(string endpointConfigurationName, string remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }

        public RewardsServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }

        public RewardsServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
            base(binding, remoteAddress)
        {
        }

        public Wgx.Services.Gds.RewardsService.RewardResult SubmitEvent(Wgx.Services.Gds.RewardsService.GameEvent gameEvent, Wgx.Services.Gds.RewardsService.ResultOptions resultOptions)
        {
            return base.Channel.SubmitEvent(gameEvent, resultOptions);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\SignInResponse.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Web;

    [DataContract(Name = "SignInResponse", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class SignInResponse : BaseResponse
    {
        #region Properties

        // Account State Flags
        [DataContract(Name = "AccountState", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class AccountStateClass
        {
            [DataMember(Order = 10)]
            public uint SignInErrorCode { get; set; }
            [DataMember(Order = 20)]
            public bool TagChangeRequired { get; set; }
            [DataMember(Order = 30)]
            public bool AcceptedTermsOfService { get; set; }
            [DataMember(Order = 40)]
            public bool AccountSuspended { get; set; }
            [DataMember(Order = 50)]
            public bool SubscriptionLapsed { get; set; }
            [DataMember(Order = 60)]
            public bool BillingUnavailable { get; set; }
            [DataMember(Order = 70)]
            public string AccountType { get; set; }
        }
        [DataMember(Order = 10)]
        public AccountStateClass AccountState = new AccountStateClass();

        // Account Info
        [DataContract(Name = "AccountInfo", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class AccountInfoClass
        {
            [DataMember(Order = 10)]
            public string ZuneTag { get; set; }
            [DataMember(Order = 20)]
            public UInt64 Xuid { get; set; } // Xbox Live XUID
            [DataMember(Order = 30)]
            public string Locale { get; set; } // like "EN-US"
            [DataMember(Order = 40)]
            public bool ParentallyControlled { get; set; }
            [DataMember(Order = 50)]
            public bool ExplicitPrivilege { get; set; }
            [DataMember(Order = 60)]
            public bool Lightweight { get; set; }

            // Usage IDs
            [DataMember(Order = 70)]
            public Guid UserWriteID { get; set; } // AKA "secret", "Reporting ID"
            [DataMember(Order = 80)]
            public Guid UserReadID { get; set; }  // AKA "memberId", "Social ID"
            [DataMember(Order = 90)]
            public bool UsageCollectionAllowed { get; set; }
        }
        [DataMember(Order = 20)]
        public AccountInfoClass AccountInfo = new AccountInfoClass();

        [DataContract(Name = "Balances", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class BalancesClass
        {
            [DataMember(Order = 10)]
            public uint PointsBalance { get; set; }
            [DataMember(Order = 20)]
            public uint SongCreditBalance { get; set; }
            [DataMember(Order = 30, EmitDefaultValue = false)]
            public DateTime SongCreditRenewalDate { get; set; }
        }
        [DataMember(Order = 30)]
        public BalancesClass Balances = new BalancesClass();

        [DataContract(Name = "SubscriptionInfo", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class SubscriptionInfoClass
        {
            // Subscription Info
            [DataMember(Order = 10)]
            public UInt64 SubscriptionOfferID { get; set; }
            [DataMember(Order = 20)]
            public UInt64 SubscriptionRenewalOfferID { get; set; }
            [DataMember(Order = 30)]
            public bool SubscriptionEnabled { get; set; }
            [DataMember(Order = 40)]
            public bool SubscriptionBillingViolation { get; set; }
            [DataMember(Order = 50)]
            public bool SubscriptionPendingCancel { get; set; }
            [DataMember(Order = 60, EmitDefaultValue = false)]
            public DateTime SubscriptionStartDate { get; set; }
            [DataMember(Order = 70, EmitDefaultValue = false)]
            public DateTime SubscriptionEndDate { get; set; }
            [DataMember(Order = 80)]
            public string SubscriptionMeteringCertificate { get; set; }
        }
        [DataMember(Order = 50)]
        public SubscriptionInfoClass SubscriptionInfo = new SubscriptionInfoClass();

        // Tuner-specific Sub info
        [DataContract(Name = "MediaTypeTunerRegisterInfo", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class MediaTypeTunerRegisterInfoClass : BaseResponse
        {
            [DataMember(Order = 10)]
            public MediaTypeEnum RegisterType { get; set; }
            [DataMember(Order = 20)]
            public bool Activated { get; set; }
            [DataMember(Order = 30)]
            public bool Activable { get; set; }
        }
        [DataMember(Order = 60)]
        public List<MediaTypeTunerRegisterInfoClass> TunerRegisterInfo = new List<MediaTypeTunerRegisterInfoClass>();

        [DataContract(Name = "PaymentInstrumentInfo", Namespace = RewardsConstants.EcommerceNameSpace)]
        public class PaymentInstrumentInfoClass : BaseResponse
        {
            public enum PaymentTypeEnum
            {
                CreditCard,
                MO
            }

            [DataMember(Order = 10)]
            public PaymentTypeEnum PaymentType { get; set; }
            [DataMember(Order = 20)]
            public string LastUsedPaymentInstrumentID { get; set; }
            [DataMember(Order = 30)]
            public string PartialAccountID { get; set; }
            [DataMember(Order = 40)]
            public string SubType { get; set; }

            public PaymentInstrumentInfoClass(PaymentTypeEnum paymentType, string lastUsedPaymentInstrumentID, string partialAccountID, string subType)
            {
                PaymentType = paymentType;
                LastUsedPaymentInstrumentID = lastUsedPaymentInstrumentID;
                PartialAccountID = partialAccountID;
                SubType = subType;
            }

            public PaymentInstrumentInfoClass(PaymentTypeEnum paymentType, Error error)
            {
                PaymentType = paymentType;
                base.Error = error;
            }
        }
        [DataMember(Order = 70)]
        public List<PaymentInstrumentInfoClass> PaymentInstrumentInfoSet = new List<PaymentInstrumentInfoClass>();

        #endregion

        public SignInResponse()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.Rewards\ZestDataContracts\TunerInfo.cs ===
﻿
namespace Gds.Services.Rewards
{
    using System;
    using System.Runtime.Serialization;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
    public enum MediaTypeEnum
    {
        Subscription,
        AppStore
    }

    [DataContract(Name = "TunerInfo", Namespace = RewardsConstants.EcommerceNameSpace)]
    public class TunerInfo
    {
        [DataMember(Name = "ConsoleID", IsRequired = false)]
        public string ConsoleId { get; set; }

        [DataMember(Name = "ID", IsRequired = true)]
        public string TunerId { get; set; }

        [DataMember(Name = "LegacyID", IsRequired = false)]
        public string LegacyId { get; set; }

        [DataMember(Name = "RegistrationDate", IsRequired = false, EmitDefaultValue = false)]
        public DateTime RegistrationDate { get; set; }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods"), DataMember(Name = "Type", IsRequired = true)]
        public string Type { get; set; }

        [DataMember(Name = "Version", IsRequired = false)]
        public string Version { get; set; }

        [DataMember(Name = "Name", IsRequired = false)]
        public string Name { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\Diagnostics.cs ===
﻿
namespace GDS.Services.SecurityTokens
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public static class StsDiagnostics
    {
        internal static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public class StsStarted : BaseEvent
    {
        public StsStarted()
            : base(50000, TraceEventType.Start, "Security Token Service started.")
        {
        }
    }
    public class StsStopped : BaseEvent
    {
        public StsStopped()
            : base(50001, TraceEventType.Stop, "Security Token Service stopped.")
        {
        }
    }
    public class StsLiveCacheError : BaseEvent
    {
        public StsLiveCacheError()
            : base(50002, TraceEventType.Warning, "A LiveCache request has return an error.")
        {
        }
    }

    public class StsUnknownError : BaseEvent
    {
        public StsUnknownError()
            : base(50003, TraceEventType.Warning, "An unknown error occurred.")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.Rewards.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.Services.Rewards.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft IT")]
//[assembly: AssemblyProduct("Gds.Services.Rewards.Test")]
//[assembly: AssemblyCopyright("Copyright © Microsoft IT 2010")]
//[assembly: AssemblyTrademark("")]
//[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("406d2ad9-0390-43a2-a337-3a4e9b6bd78a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.Rewards.Test\PostGameResultTest.cs ===
﻿namespace Gds.Services.Rewards.Test
{
    using GameMetadata.Client;
    using Gds.DataAccess.Rewards;
    using Leet.Core.IoCCo;
    using Leet.Utils;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Gds.Mocks;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics;
    using Leet.Core.Configuration;
    using Microsoft.ServiceModel.Web;
    using System.Net;
    using Leet.TestUtilities;

    [TestClass]
    public class PostGameResultTest
    {
        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            Container.UseLocalContainer(new Container());

            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<IRewardsQueueReader, InMemoryRewardsQueueReader>();
            Container.Instance.AddService<ISubmitGameResult, CSubmitGameResult>();
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();

            RewardsEvents.Initialize("gds_rewards");
        }

        // Use ClassCleanup to run code after all tests in a class have run
        [ClassCleanup()]
        public static void MyClassCleanup() { }


        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void RewardsSubmitNullGameResult()
        {
            try
            {
                RewardsServiceRest rsr = new RewardsServiceRest();
                rsr.PostGameResultXml(null);
            }
            catch (WebProtocolException wpe)
            {
                Assert.IsTrue(wpe.StatusCode == HttpStatusCode.BadRequest);
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\Global.asax.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using Leet.Identity.WindowsLiveAuth;
using Leet.Core; 
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics; 
using Leet.Core.IO;
using Leet.Core.Utils; 
using Leet.Utils; 

namespace GDS.Services.SecurityTokens
{
    public class Global : System.Web.HttpApplication
    {

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Start(object sender, EventArgs e)
        {
            string componentName = "gds_securitytokens";
            string configurationSet = "LEET";
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider(componentName, configurationSet);
            RegisterInterfaces();
            Leet.Live.Livecache.LeetLivecacheClient.RegisterWebInterfacesAndInitialize(componentName);
            StsDiagnostics.Logging.LogEvent(new StsStarted());
        }

        private static void RegisterInterfaces()
        {
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Session_Start(object sender, EventArgs e)
        {

        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_BeginRequest(object sender, EventArgs e)
        {

        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_AuthenticateRequest(object sender, EventArgs e)
        {

        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            StsDiagnostics.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, ex);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Session_End(object sender, EventArgs e)
        {

        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_End(object sender, EventArgs e)
        {
            StsDiagnostics.Logging.LogEvent(new StsStopped());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.Rewards.Test\GrantAchievementsTests.cs ===
﻿
namespace Gds.Services.Rewards.Test
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts;
    using Gds.Mocks;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.TestUtilities;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Rhino.Mocks;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Summary description for GrantAchievementsTests
    /// </summary>
    [TestClass]
    public class GrantAchievementsTests
    {
        public class FakePurchaseVerification : IPurchaseVerification
        {
            public void SignIn(string xuid, out string cookie, out uint errCode)
            {
                cookie = "some cookie";
                errCode = 0;
            }

            public bool VerifyPurchase(Guid appId, uint titleId, string xuid, string cookie, out uint errCode, out string errMessage)
            {
                errCode = 0;
                errMessage = "this is an error";
                return true;
            }
        }

        public GrantAchievementsTests()
        {
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }

            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //

        private IAchievementDataAccess achievementProvider;
        private IConfigurationProvider configProvider;
        private List<IReadOnlyAchievementInfo> achievements;
        private IReadOnlyAchievementInfo achievement;

        [TestInitialize()]
        public void Initialize()
        {
            // Create stubs
            var stubber = new Stubber();
            this.achievementProvider =
                stubber.RegisterWithContainer<IAchievementDataAccess>();
            this.configProvider =
                stubber.RegisterWithContainer<IConfigurationProvider>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IPurchaseVerification, FakePurchaseVerification>();
            this.achievement =
                MockRepository.GenerateStub<IReadOnlyAchievementInfo>();
            this.achievements = new List<IReadOnlyAchievementInfo>
                                    {
                                        this.achievement
                                    };
            RewardsEvents.Initialize("gds_rewards");
        }

        #endregion

        [TestMethod]
        public void GrantAchievementsValid()
        {
            // Arrange
            this.ArrangeForGrantAchievementReturnsExpectedValues();

            // Act
            AchievementEarned achievementEarned = new AchievementEarned
                                                      {
                                                          EarnedOnline = true,
                                                          EarnedDateTime = DateTime.UtcNow,
                                                          Key = "0"
                                                      };

            IList<AchievementEarned> achievementEarneds = new List<AchievementEarned>
                                                              {
                                                                  achievementEarned
                                                              };
            RewardsServiceAdapter.GrantAchievements(123, 7, "a34b5ba7-c104-4707-b6f0-07638169a586", achievementEarneds, "en-US");

            // Assert
            // Nothing to assert here because GrantAchievments returns void
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GrantAchievementDateTimeEarlier()
        {
            //achivement time should be less than 01/01/2010 and greater than 24 hours + the current server time 
            AchievementEarned achievementEarned = new AchievementEarned
            {
                
                EarnedOnline = true,
                EarnedDateTime = new DateTime(2010,1,1).AddHours(-1).ToUniversalTime(),
                Key = "0"
            };

            GrantAchievements grantAchievements = new GrantAchievements();
            grantAchievements.Achievements = new List<AchievementEarned>
                                                              {
                                                                  achievementEarned,

                                                              };
            grantAchievements.AppId = Guid.NewGuid().ToString();

            RewardsServiceUtility.ValidatePostGrantAchievement(grantAchievements, "en-us", "5");
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GrantAchievementsDateTimeLater()
        {
            //achivement time should be less than 01/01/2010 and greater than 24 hours + the current server time 
            AchievementEarned achievementEarned = new AchievementEarned
            {

                EarnedOnline = true,
                EarnedDateTime = DateTime.UtcNow.AddDays(2),
                Key = "0"
            };

            GrantAchievements grantAchievements = new GrantAchievements();
            grantAchievements.Achievements = new List<AchievementEarned>
                                                              {
                                                                  achievementEarned,

                                                              };
            grantAchievements.AppId = Guid.NewGuid().ToString();

            RewardsServiceUtility.ValidatePostGrantAchievement(grantAchievements, "en-us", "5");
        }

        [TestMethod]
        public void GrantAchievementsValidDateTime()
        {
            //achivement time should be less than 01/01/2010 and greater than 24 hours + the current server time 
            AchievementEarned achievementEarned = new AchievementEarned
            {

                EarnedOnline = true,
                EarnedDateTime = DateTime.UtcNow.AddHours(5),
                Key = "0"
            };

            GrantAchievements grantAchievements = new GrantAchievements();
            grantAchievements.Achievements = new List<AchievementEarned>
                                                              {
                                                                  achievementEarned,

                                                              };
            grantAchievements.AppId = Guid.NewGuid().ToString();

            RewardsServiceUtility.ValidatePostGrantAchievement(grantAchievements, "en-us", "5");
        }

        [TestMethod]
        [ExpectedException(typeof(NullReferenceException))]
        public void GrantAchievementsNullAchievements()
        {
            // Arrange
            this.ArrangeForGrantAchievementReturnsExpectedValues();

            // Act
            RewardsServiceAdapter.GrantAchievements(123, 7, "a34b5ba7-c104-4707-b6f0-07638169a586", null, "en-US");

            // Assert
        }

        [TestMethod]
        public void GrantAchievementWithPurchaseVerification()
        {
            // Arrange
            this.configProvider.Stub(cp => cp.GetBoolSetting(Settings.ZestPurchaseVerificationEnabled)).Return(true);
            this.ArrangeForGrantAchievementReturnsExpectedValues();

            // Act
            AchievementEarned achievementEarned = new AchievementEarned
            {
                EarnedOnline = true,
                EarnedDateTime = DateTime.UtcNow,
                Key = "0"
            };

            IList<AchievementEarned> achievementEarneds = new List<AchievementEarned>
                                                              {
                                                                  achievementEarned
                                                              };
            RewardsServiceAdapter.GrantAchievements(123, 7, "a34b5ba7-c104-4707-b6f0-07638169a586", achievementEarneds, "en-US");

            // Assert
            // Nothing to assert here because GrantAchievments returns void
        }

        private void ArrangeForGrantAchievementReturnsExpectedValues()
        {
            this.achievementProvider.Stub(ap => ap.GetUserAchievements(0, 0, 0, 0))
                .IgnoreArguments()
                .Return(this.achievements);
            this.achievement.Stub(a => a.IsUnlocked)
                .Return(false);
            this.achievement.Stub(a => a.Title)
                .Return("Successful test!");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "GDS", Scope = "namespace", Target = "GDS.Services.SecurityTokens", Justification = "Maintaining existing naming standard for GDS projects")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "GDS", Justification = "Maintaining existing naming standard for GDS projects")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion", Justification="The build system will add assembly version information")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\SecurityTokensConfig.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace GDS.Services.SecurityTokens
{
    public class SecurityTokensConfig
    {
        private static IConfigurationProvider ConfigSettings
        {
            get
            {
                return Container.Instance.GetComponent<IConfigurationProvider>();
            }
        }

        public static string WebStsClientCertificateSubject
        {
            get
            {
                return ConfigSettings.GetSetting(Settings.WebStsClientCertificateSubject);
            }
        }

        public static string WebStsClientCertificateIssuer
        {
            get
            {
                return ConfigSettings.GetSetting(Settings.WebStsClientCertificateIssuer);
            }
        }

        public static bool WebStsEnabled
        {
            get
            {
                return ConfigSettings.GetBoolSetting(Settings.WebStsEnabled);
            }
        }

        public static bool WebStsForWplcEnabled
        {
            get
            {
                return ConfigSettings.GetBoolSetting(Settings.WebStsForWplcEnabled);
            }
        }

        public static UInt32[] BlockedTitles
        {
            get
            {
                string[] list= ConfigSettings.GetMultiSetting(MultiSettings.WebStsBlockedTitles);
                UInt32[] titles = new uint[list.Length];
                int i = 0;
                foreach (string l in list)
                {
                    titles[i++] = UInt32.Parse(l, System.Globalization.NumberStyles.HexNumber);
                    
                }
                return titles;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Services.SecurityTokens")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// Not targeting the exposing of types to non-C# languages
[assembly: CLSCompliant(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\Global.asax.cs ===
﻿namespace Gds.Services.UserData
{
    using System;
    using System.Web;
    using GameMetadata.Client;
    using GDS.DataAccess.UserData;
    using Gds.Services.UserData.Library;
    using Leet.Utils;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics; 
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.TestSupport;
    using Leet.Core.Utils;
    using Leet.Core.BI;
    using Leet.FriendManager;
    using Leet.Identity.ActiveAuth;
    using Leet.Identity;
    using Leet.Live.Livecache.Providers;
    using Leet.Live.Livecache;
    using Leet.Profile;
    using LIVEN.Common.Diagnostics;
    using Gds.DataAccess.UserData;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    public class Global : System.Web.HttpApplication
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            UserDataEvents.Initialize("gds_userdata");
            RegisterBaselineInterfaces();
            Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
            ((NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", "gds_userdata");
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("gds_userdata");
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);
            ProfileProvider.RegisterWithIocContainer(Container.Instance, "gds_userdata");
            FriendManager.RegisterWithIocContainer(Container.Instance);

            ScatterGatherManager.MaxNumberOfScatter = Global.UserDataScatterFactor;
            Logging.TraceInformation("UserDataService: ScatterGather factor is {0}", ScatterGatherManager.MaxNumberOfScatter);
            Container.Instance.AddEmulatableService<IUserProfileStorageSimple, UserProfileStorageLivecache>();

            // This call registers 4 interfaces to the Iocco:
            //          IEndpointConfigurator<IGameMetadataService>,
            //          IWcfProxyFactory<IGameMetadataService>,
            //          IGameMetadataService,
            //          IGameMetadataClient
            GameMetadataClient.RegisterContainerServices();

            Container.Instance.AddService<IServicePerformanceCounters, PerformanceCounterSelector>();
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, WebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IBILog, BILog>(); // to log business intelligence data
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            Logging.TraceInformation("UserDataService: Application Started.");
            UserDataEvents.Events.TraceEvent(UserDataEvents.ServiceStarted);
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            UserDataEvents.Events.TraceEvent(UserDataEvents.ApplicationError, ex.ToString());
            Logging.TraceException(ex,
                "UserDataService");
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            // Proxies must treat the response as private & must not transform or cache the response.
            HttpContext.Current.Response.Headers["Cache-Control"] = "private, no-transform, no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        /// <summary>
        /// Register the required baseline interfaces
        /// </summary>
        private static void RegisterBaselineInterfaces()
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<ITestImplementationProvider, TestImplementationProvider>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
        }


        public static int UserDataScatterFactor
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.UserDataScatterFactor);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\Profiles.svc.cs ===
﻿
namespace Gds.Services.UserData
{
    using System;
    using System.Net;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Profiles service
    /// </summary>
    /// TODO:  Determine if next version of ActiveAuth will require AspNetCompatibility enabled, or if they will support WCF
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public class Profiles : IProfiles
    {
        private const string ComponentName = "UserDataService";

        #region IProfiles Members

        public Leet.UserGameData.DataContracts.Profile GetProfileAsXml(long sectionFlags, string gamertag)
        {
            Logging.TraceVerbose("{0}:{1}", ComponentName, "GetProfileAsXml");

            return InternalProfile(sectionFlags, gamertag);
        }

        public Leet.UserGameData.DataContracts.Profile GetProfileAsJson(long sectionFlags, string gamertag)
        {
            Logging.TraceVerbose("{0}:{1}", ComponentName, "GetProfileAsJson");

            return InternalProfile(sectionFlags, gamertag);
        }

        #endregion IProfiles Members

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private static Leet.UserGameData.DataContracts.Profile InternalProfile(long sectionFlags, string gamertag)
        {
            Leet.UserGameData.DataContracts.Profile profile = null;
            try
            {
                string locale, platformType;

                ServiceParameterValidator.FetchHeaders(out locale, out platformType);
                
                ValidatePlatformTypeAgainstClaim(platformType);

                profile = GetProfile(locale, sectionFlags, gamertag, "platform", "version");
            }
            catch (UnauthorizedAccessException ex)
            {
                HandleException("GET Profile", ex, HttpStatusCode.Unauthorized, UserDataEvents.AuthenticationFailure);
            }
            catch (NotSupportedException nse)
            {
                HandleException("GET Profile", nse, HttpStatusCode.BadRequest, UserDataEvents.InvalidArgument);
            }
            catch (ArgumentException argumentException)
            {
                HandleException("GET Profile", argumentException, HttpStatusCode.BadRequest, UserDataEvents.InvalidArgument);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception exception)
            {
                HandleException("GET Profile", exception, HttpStatusCode.InternalServerError, UserDataEvents.UnexpectedFailure);
            }

            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return profile;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "version")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "platform")]
        private static Leet.UserGameData.DataContracts.Profile GetProfile(string displayLocale, long sectionFlags, string gamertag, string platform, string version)
        {
            bool partialResult;

            var authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                throw new UnauthorizedAccessException();
            }

            var callerIdentity = authManager.CurrentUser;
            var provider = Container.Instance.GetComponent<IProfileProvider>();
            Leet.UserGameData.DataContracts.Profile profile;
            Identity targetIdentity = null;
            IReadOnlyFriendInfo[] readOnlyFriendsInfos = null;
            // if gamertag is set, use it to find the target user
            // otherwise the target user is the calling user
            if (!string.IsNullOrEmpty(gamertag))
            {
                profile = provider.GetProfile(callerIdentity, gamertag, displayLocale, sectionFlags, out readOnlyFriendsInfos, out partialResult, out targetIdentity);
            }
            else
            {
                profile = provider.GetProfile(callerIdentity, displayLocale, sectionFlags, out readOnlyFriendsInfos, out partialResult);
            }

            // TODO: Use partialResult to return appropriate status code

            return profile;
        }

        private static void ValidatePlatformTypeAgainstClaim(String platformTypeAsString)
        {
            Object tokenplatformType = 0;
            Int32 platformType = 0;

            if (!Int32.TryParse(platformTypeAsString, out platformType) ||
                !ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.PlatformClaimType, out tokenplatformType) ||
                !ServiceParameterValidator.NormalizePlatformType(Convert.ToInt32(tokenplatformType)).Equals(ServiceParameterValidator.NormalizePlatformType(platformType)))
            {
                throw new WebProtocolException(HttpStatusCode.BadRequest, "PlatformType validation failed", null);
            }
        }

        public static void HandleException(string methodName, Exception ex, HttpStatusCode httpStatusCode, int eventCode)
        {
            LIVEnException le = ex as LIVEnException;

            Logging.TraceException(ex,"{0}:{1} {2}",
                ComponentName,
                "Exception caught in method: ",
                methodName);

            if (le == null)
            {
                le = new LIVEnException(
                    UserDataEvents.Events,
                    eventCode,
                    httpStatusCode,
                    ex,
                    methodName,
                    true,
                    ex.ToString());
            }

            le.ThrowWebProtocolException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "GDS")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using xonline.common.config;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Services.UserData")]
[assembly: ConfigAttribute("gds_userdata")] // requires by ActiveAuth for event logging
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corporation")]
//[assembly: AssemblyProduct("GDS.Services.UserData")]
//[assembly: AssemblyCopyright("Copyright ©  2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

//// Setting ComVisible to false makes the types in this assembly not visible 
//// to COM components.  If you need to access a type in this assembly from 
//// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

//// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d8613c4c-be4f-4c12-9989-5150c7fa4e9b")]

//// Version information for an assembly consists of the following four values:
////
////      Major Version
////      Minor Version 
////      Build Number
////      Revision
////
//// You can specify all the values or you can default the Revision and Build Numbers 
//// by using the '*' as shown below:
//// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GameDataAdapter.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Net;
    using System.ServiceModel;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Core.BI;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.Live.Livecache.Logic.Avatars;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics; 
    using Microsoft.ServiceModel.Web;
    using Leet.Identity;

    /// <summary>
    /// Server implementation of the IGameRewards interface
    /// </summary>
    public sealed class GameDataAdapter
    {
        private GameDataAdapter() { }

        private static object lockObject = new object();

        private static IServicePerformanceCounters perfLeaderboardCounters = null;
        private static IServicePerformanceCounters PerfLeaderboardCounters 
        {
            get
            {
                if (perfLeaderboardCounters == null)
                {
                    lock (lockObject)
                    {
                        if (perfLeaderboardCounters == null)
                        {
                            perfLeaderboardCounters = Container.Instance.GetComponent<IServicePerformanceCounters>().RetrievePerformanceCounters(PerformanceCounterSet.Leaderboard);
                        }
                    }
                }

                return perfLeaderboardCounters;
            }

            set
            {
                perfLeaderboardCounters = value;
            }
        }

        private static IServicePerformanceCounters perfAchievementCounters = null;
        private static IServicePerformanceCounters PerfAchievementCounters
        {
            get
            {
                if (perfAchievementCounters == null)
                {
                    lock (lockObject)
                    {
                        if (perfAchievementCounters == null)
                        {
                            perfAchievementCounters = Container.Instance.GetComponent<IServicePerformanceCounters>().RetrievePerformanceCounters(PerformanceCounterSet.Achievements);
                        }
                    }
                }

                return perfAchievementCounters;
            }

            set
            {
                perfAchievementCounters = value;
            }
        }

        private static IServicePerformanceCounters perfAvatarAwardAssetCounters = null;
        private static IServicePerformanceCounters PerfAvatarAwardAssetCounters
        {
            get
            {
                if (perfAvatarAwardAssetCounters == null)
                {
                    lock (lockObject)
                    {
                        if (perfAvatarAwardAssetCounters == null)
                        {
                            perfAvatarAwardAssetCounters = Container.Instance.GetComponent<IServicePerformanceCounters>().RetrievePerformanceCounters(PerformanceCounterSet.AvatarAwardAssets);
                        }
                    }
                }

                return perfAvatarAwardAssetCounters;
            }

            set
            {
                perfAvatarAwardAssetCounters = value;
            }
        }

        /// <summary>
        /// Returns a set of users based on leaderboard ranking
        /// </summary>
        /// <param name="gameId">Game idenitifer</param>
        /// <param name="variant">Variant of the game</param>
        /// <param name="property">Name of property for filter</param>
        /// <param name="dataGroup">Filter of the datagroup</param>
        /// <param name="numRows">Max number of rows to be returned</param>
        /// <param name="rankStart">Start of the leaderboard</param>
        /// <param name="socialGraph">Filter socialGraph where socialGraph= “1” – All graphs, “2” – XBOX friends, “3” – MSN friends </param>
        /// <returns>The calling user's leaderboard with statistics associated to each user</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")] 
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static LeaderboardResult GetLeaderboard(uint gameId, uint variant, string property, string dataGroup, uint numberOfRows, uint rankStart, uint socialGraph)
        {
            IServicePerformanceCounters counters = GameDataAdapter.PerfLeaderboardCounters;
            bool requestFailed = false;

            string locale, platformType;
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            // lets tidy up all these parameters into a nice class.
            LeaderboardParams parameters = new LeaderboardParams()
                {
                    GameId = gameId,
                    Variant = variant,
                    Property = property,
                    DataGroup = dataGroup,
                    NumRows = numberOfRows,
                    RankStart = rankStart,
                    SocialGraph = socialGraph,
                    Locale = locale,
                    PlatformType = platformType
                };
            LeaderboardResult result = new LeaderboardResult();

            try
            {
                counters.StartRequest(null);

                var callerIdentity = UserDataAdapterUtility.GetCallerIdentity();
                parameters.Xuid = (ulong)callerIdentity.Xuid;

                // log business intelligence data, need to log before any validations
                try
                {
                    BILogging.LogBIData(
                        OriginatorIDType.Xbox,
                        callerIdentity.Xuid, 
                        platformType, 
                        gameId, 
                        "GDS.Services.UserData", 
                        "GetLeaderboard");  
                }
                catch (Exception ex)
                {
                    // None of this should throw, but take no chance
                    Logging.TraceException(ex, "{0} Unexpected exception caught while writing BI data", UserDataAdapterUtility.ComponentName);
                }

                ValidatePlatformTypeAgainstClaim(platformType);

                ValidateTitleIDAgainstClaim(gameId);


                // throws either ArgumentException or a derived type.
                LeaderboardParameterValidator.ValidateCall(parameters);

                ServiceParameterValidator.ValidateXuid(parameters.Xuid);
                Logging.TraceVerbose("{0}: GetLeaderboard {1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}",
                    UserDataAdapterUtility.ComponentName,
                    parameters.Xuid,
                    gameId,
                    variant,
                    property,
                    dataGroup,
                    numberOfRows,
                    rankStart,
                    socialGraph);

                IProfileProvider provider = Container.Instance.GetComponent<IProfileProvider>();

                bool partialResult;
                // retrieve the friends list required to process the leadeboard
                Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendsInfo = provider.GetFriendsForLeaderboard(callerIdentity, Network.XboxLive, out partialResult);

                result = GameDataAdapterLeaderboard.ProcessLeaderboardRequest(parameters, parameters.Xuid, friendsInfo);
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                // make sure we note the parameters down with the exception.
                if (!ex.Data.Contains(typeof(LeaderboardParams)))
                {
                    ex.Data.Add(typeof(LeaderboardParams), UserDataAdapterUtility.DumpLeaderboardParameters(parameters));
                }

                UserDataAdapterUtility.RejectInput("GET Leaderboard", ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET Leaderboard", ex, HttpStatusCode.Unauthorized, UserDataEvents.AuthenticationFailure);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET Leaderboard", ex, HttpStatusCode.InternalServerError, UserDataEvents.UnexpectedFailure);
            }
            finally
            {
                counters.EndRequest(requestFailed);
            }

            return result;
        }

        /// <summary>
        /// Returns a list of achievements for a specific game
        /// </summary>
        /// <param name="gameId">Game identifier</param>
        /// <returns>A set of Achievements for the game title</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt32)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static AchievementsResult GetAchievements(uint gameId)
        {
            IServicePerformanceCounters counters = GameDataAdapter.PerfAchievementCounters;
            bool requestFailed = false;

            string locale, platformType;
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            AchievementsResult result = new AchievementsResult();

            try
            {
                counters.StartRequest(null);

                var callerIdentity = UserDataAdapterUtility.GetCallerIdentity();
                ulong xuid = callerIdentity.Xuid;

                // log business intelligence data, need to log before any validations
                try
                {
                    BILogging.LogBIData(
                        OriginatorIDType.Xbox,
                        callerIdentity.Xuid,
                        platformType,
                        gameId,
                        "GDS.Services.UserData",
                        "GetAchievements");
                }
                catch (Exception ex)
                {
                    // None of this should throw, but take no chance
                    Logging.TraceException(ex, "{0} Unexpected exception caught while writing BI data",
                         UserDataAdapterUtility.ComponentName);
                }

                ValidatePlatformTypeAgainstClaim(platformType);

                ValidateTitleIDAgainstClaim(gameId);

                // validates caller Identity
                ServiceParameterValidator.ValidateXuid(xuid);

                ushort lcid = 0;
                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

                // Locale is validated by the time we reach this code.
                lcid = localeHelper.GetLCID(locale);
                var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();
                List<IReadOnlyAchievementInfo> readOnlyAchievementInfoList = null;

                try
                {
                    Logging.TraceVerbose("{0}:GetAchievements {1}|{2}|{3}",
                        UserDataAdapterUtility.ComponentName,
                        callerIdentity.Xuid,
                        gameId,
                        lcid);
                    readOnlyAchievementInfoList = achievementDataAccess.GetUserAchievements(gameId, callerIdentity.Xuid, callerIdentity.Xuid, lcid);
                }
                catch (Exception ex)
                {
                    UserDataAdapterUtility.HandleException("GET Achievements", ex, HttpStatusCode.InternalServerError, UserDataEvents.LiveCacheError);
                }

                if (readOnlyAchievementInfoList != null)
                {
                    var achievement = from readOnlyAchievementInfo in readOnlyAchievementInfoList
                                      select new Achievement
                                      {
                                          GameId = gameId,
                                          Description = readOnlyAchievementInfo.Description,
                                          DisplayBeforeEarned = !readOnlyAchievementInfo.IsHidden,
                                          EarnedDateTime = readOnlyAchievementInfo.DateUnlocked,
                                          EarnedOnline = readOnlyAchievementInfo.WasEarnedOnline,
                                          Gamerscore = readOnlyAchievementInfo.GamerscoreValue,
                                          HowToEarn = readOnlyAchievementInfo.HowTo,
                                          IsEarned = readOnlyAchievementInfo.IsUnlocked,
                                          Key = Convert.ToString(readOnlyAchievementInfo.AchievementId),
                                          Name = readOnlyAchievementInfo.Title,
                                          PictureUrl = readOnlyAchievementInfo.ImageHref.AbsoluteUri
                                      };

                    result = new AchievementsResult
                    {
                        Achievements = achievement.ToList()
                    };
                }
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.RejectInput("GET Achievements", ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET Achievements", ex, HttpStatusCode.Unauthorized, UserDataEvents.AuthenticationFailure);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET Achievements", ex, HttpStatusCode.InternalServerError, UserDataEvents.UnexpectedFailure);
            }
            finally
            {
                counters.EndRequest(requestFailed);
            }

            return result;
        }

        /// <summary>
        /// Returns a list of avatar awards assets for a specific game
        /// </summary>
        /// <param name="gameId">Game identifier</param>
        /// <returns>A set of avatar awards assets for the game title</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToString(System.UInt32)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static AvatarAwardsAssetResult GetAvatarAwardsAssets(uint gameId)
        {
            IServicePerformanceCounters counters = GameDataAdapter.PerfAvatarAwardAssetCounters;
            bool requestFailed = false;

            string locale, platformType;
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            AvatarAwardsAssetResult result = new AvatarAwardsAssetResult();
            result.GameId = gameId;

            try
            {
                counters.StartRequest(null);

                var callerIdentity = UserDataAdapterUtility.GetCallerIdentity();
                ulong xuid = callerIdentity.Xuid;

                // log business intelligence data, need to log before any validations
                try
                {
                    BILogging.LogBIData(
                        OriginatorIDType.Xbox,
                        callerIdentity.Xuid,
                        platformType,
                        gameId,
                        "GDS.Services.UserData",
                        "GetAvatarAwardsAssets");
                }
                catch (Exception ex)
                {
                    // None of this should throw, but take no chance
                    Logging.TraceException(ex, "{0} Unexpected exception caught while writing BI data",
                         UserDataAdapterUtility.ComponentName);
                }

                ValidatePlatformTypeAgainstClaim(platformType);

                ValidateTitleIDAgainstClaim(gameId);

                // validates caller Identity
                ServiceParameterValidator.ValidateXuid(xuid);

                ushort lcid = 0;
                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

                // Locale is validated by the time we reach this code.
                lcid = localeHelper.GetLCID(locale);

                ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
                ReadOnlyCollection<AwardedAvatarAsset> awardedAvatarAssetCollection = null;

                try
                {
                    Logging.TraceVerbose("{0}:GetUserAvatarAwards {1}|{2}|{3}",
                        UserDataAdapterUtility.ComponentName,
                        callerIdentity.Xuid,
                        gameId,
                        lcid);
                    awardedAvatarAssetCollection = settingsDataAccess.GetUserAvatarAwards(xuid, lcid, gameId);
                }
                catch (Exception ex)
                {
                    UserDataAdapterUtility.HandleException("GET AvatarAwardsAssets", ex, HttpStatusCode.InternalServerError, UserDataEvents.LiveCacheError);
                }

                if (awardedAvatarAssetCollection != null)
                {
                    var avatarAwardsAssets = from awardedAvatarAsset in awardedAvatarAssetCollection
                                      select new AvatarAwardsAsset
                                      {
                                          GameId = gameId,
                                          Key = Convert.ToString(awardedAvatarAsset.AvatarAssetOrdinal),
                                          Description = awardedAvatarAsset.Description,
                                          EarnedDateTime = awardedAvatarAsset.Awarded,
                                          EarnedOnline = AvatarAssetFlags.AchievedOnline(awardedAvatarAsset.Flags),
                                          HowToEarn = awardedAvatarAsset.HowTo,
                                          IsEarned = AvatarAssetFlags.Achieved(awardedAvatarAsset.Flags),
                                          Name = awardedAvatarAsset.Title
                                      };


                    result.AvatarAwardsAssets = avatarAwardsAssets.ToList();
                }
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.RejectInput("GET AvatarAwardsAssets", ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET AvatarAwardsAssets", ex, HttpStatusCode.Unauthorized, UserDataEvents.AuthenticationFailure);
            }
            catch (WebProtocolException)
            {
                throw;
            }
            catch (Exception ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.HandleException("GET AvatarAwardsAssets", ex, HttpStatusCode.InternalServerError, UserDataEvents.UnexpectedFailure);
            }
            finally
            {
                counters.EndRequest(requestFailed);
            }

            return result;
        }

        private static void ValidatePlatformTypeAgainstClaim(String platformTypeAsString)
        {
            Object tokenplatformType = 0;
            Int32 platformType = 0;

            if (!Int32.TryParse(platformTypeAsString, out platformType) ||
                !ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.PlatformClaimType, out tokenplatformType) ||
                !ServiceParameterValidator.NormalizePlatformType(Convert.ToInt32(tokenplatformType)).Equals(ServiceParameterValidator.NormalizePlatformType(platformType)))
            {
                UserDataAdapterUtility.RejectInput("ValidatePlatformTypeAgainstClaim", null, HttpStatusCode.BadRequest, UserDataEvents.ValidPlatformTypeNotProvided, platformTypeAsString);
            }
        }

        private static void ValidateTitleIDAgainstClaim(UInt32 titleId)
        {
            Object tokenTitleID = null;

            if (!ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.TitleIdClaimType, out tokenTitleID) ||
                !Convert.ToUInt32(tokenTitleID.ToString(), 16).Equals(titleId))
            {
                UserDataAdapterUtility.RejectInput("ValidateTitleIDAgainstClaim", null, HttpStatusCode.BadRequest, UserDataEvents.ValidTitleIdNotProvided, Convert.ToString(titleId));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.SecurityTokens\Tokens.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using Leet.Core.Diagnostics;
using Microsoft.ServiceModel.Web;
using System.ServiceModel.Activation;
using System.Net;
using Gds.Contracts;
using Leet.Core.IoCCo;
using Leet.Core.Utils;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using xonline.common.webplatform.livecache;
using System.ServiceModel.Channels;
using Leet.Identity.WindowsLiveAuth;
using System.IdentityModel.Claims;
using System.Security.Cryptography.X509Certificates;
using xonline.common.service;
using System.Runtime.InteropServices;
using System.Diagnostics;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "GDS.Services.SecurityTokens")]

namespace GDS.Services.SecurityTokens
{
    
    public class WebStsUserIdentity : UserIdentity
    {
        public WebStsUserIdentity(ulong Puid, ulong Cid, ulong Xuid)
        {
            this.Puid = (long)Puid;
            this.Cid = (long)Cid;
            this.Xuid = Xuid;
        }
    };

    public class TokenWebProtocolException : WebProtocolException
    {
        public TokenWebProtocolException(HttpStatusCode statusCode, string message, Exception innerException)
            : base(statusCode, message,innerException)
        {
            WebOperationContext.Current.OutgoingResponse.StatusCode = statusCode;
        }
    }

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single,
                     ConcurrencyMode = ConcurrencyMode.Multiple)]
    public class Tokens : ISecurityTokens
    {
        struct TokenParameters
        {
            public ulong Puid;
            public ulong Cid;
            public ulong Xuid;
            public DateTime IssueInstant;
            public DateTime NotAfter;
            public String ClientIp;
        }
        private const string RpsAuthPolicySsl = "MBI_SSL";

        #region ISecurityTokens Members

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt64.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt16.ToString")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.ToString")]
        
        /// <summary>
        /// Get the user token 
        /// </summary>
        /// <param name="gameId">The title id of the game. </param>
        /// <param name="gameVersion">The version of the title. </param>
        /// <returns>The token </returns>
        public TokenResult GetUserTokenXml(uint gameId, ushort gameVersion)
        {
            string userToken = string.Empty;
            TokenParameters tokenParams;
            TokenResult token = new TokenResult();

            try
            {


                if (!GetTokenParameters(out tokenParams))
                {
                    throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "Not Allowed", null);
                }

                if (IsTitleBlocked(gameId))
                {
                    throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "Title Blocked", null);
                }

                try
                {
                    IStsDataAccess sts = Container.Instance.GetComponent<IStsDataAccess>();

                    token.User = sts.GetSecurityTicket(tokenParams.Xuid,
                                                       tokenParams.Puid,
                                                       gameId,
                                                       (ushort) gameVersion,
                                                       tokenParams.ClientIp,
                                                       tokenParams.Cid,
                                                       tokenParams.IssueInstant,
                                                       tokenParams.NotAfter);

                    WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
                    return token;
                }
                catch (LivecacheResponseException ex)
                {
                    HandleLiveCacheException(gameId, tokenParams, gameVersion, ex);
                    return null;
                }
            }
                
            catch (Exception ex)
            {
                if (typeof(TokenWebProtocolException) != ex.GetType())
                {
                    WebOperationContext.Current.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;
                    StsDiagnostics.Logging.LogEvent(new StsUnknownError(), ex,
                                                    "GetUserTokenXml Parameters: GameId={0},GameVersion={1}",
                                                    gameId, gameVersion);
                }
            }
            return null; 
        }

     
        /// <summary>
        /// Get partner token 
        /// </summary>
        /// <param name="gameId">The title id. </param>
        /// <param name="gameVersion">The version id of the game title. </param>
        /// <param name="audienceUri">Targe service</param>
        /// <returns>Token result with only partner token. </returns>
        public TokenResult GetPartnerTokenXml(uint gameId, ushort gameVersion, string audienceUri)
        {
            TokenParameters tokenParams;
            TokenResult result = new TokenResult();
            string audience = "http://xboxlive.com";

            try
            {

                if (!String.IsNullOrEmpty(audienceUri))
                {
                    audience = audienceUri;
                    StsDiagnostics.Logging.LogTrace(TraceLevel.Info,"AudienceURI was not specified");
                }

                if (!GetTokenParameters(out tokenParams))
                {
                    throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "Not Allowed", null);
                }

                if (IsTitleBlocked(gameId))
                {
                    throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "Title Blocked", null);
                }

                try
                {
                    IStsDataAccess sts = Container.Instance.GetComponent<IStsDataAccess>();

                    string userToken = sts.GetSecurityTicket(tokenParams.Xuid,
                                                             tokenParams.Puid,
                                                             gameId,
                                                             (ushort) gameVersion,
                                                             tokenParams.ClientIp,
                                                             tokenParams.Cid,
                                                             tokenParams.IssueInstant,
                                                             tokenParams.NotAfter);

                    string partnerToken = sts.GetPartnerSecurityTicket(tokenParams.Xuid,
                                                                       gameId,
                                                                       (ushort) gameVersion,
                                                                       tokenParams.ClientIp,
                                                                       userToken,
                                                                       audience);


                    result.Partner = partnerToken;
                    WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
                    return result;
                }
                catch (LivecacheResponseException ex)
                {
                    HandleLiveCacheException(gameId, tokenParams, gameVersion, ex);
                    return null;
                }
            }
            catch (Exception ex)
            {
                if (typeof(TokenWebProtocolException) != ex.GetType())
                {
                    WebOperationContext.Current.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;
                    StsDiagnostics.Logging.LogEvent(new StsUnknownError(), ex,
                                                    "GetPartnerTokenXml Parameters: GameId={0},GameVersion={1}",
                                                    gameId, gameVersion);
                }

            }
            return null;
        }

        [Flags]
        enum WebStsParamsParsed 
        { 
            None            = 0x00, 
            Puid            = 0x01, 
            Cid             = 0x02, 
            IssueInstant    = 0x04, 
            NotAfter        = 0x08, 
            ClientIp        = 0x10,
            All             = 0x1f };

        private bool GetTokenParameters(out TokenParameters tokenParams)
        {
            bool isAuthorized = false;
            var authManager = Container.Instance.GetComponent<IWebsiteAuthenticationManager>();
            IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
            String WebStsRpsParametersHeader = request.Headers[CustomWebHeaderNames.XWebStsRpsParameters];

            OperationContext ctx = OperationContext.Current;

            tokenParams = new TokenParameters();

            if (!String.IsNullOrEmpty(WebStsRpsParametersHeader))
            {
                if (!SecurityTokensConfig.WebStsForWplcEnabled)
                {
                    WebOperationContext.Current.OutgoingResponse.Headers.Add("X-Err", HResult.XONLINE_E_LOGON_SERVERS_TOO_BUSY.ToString());
                    throw new TokenWebProtocolException(HttpStatusCode.InternalServerError, "WebStsForWplc disabled", null);
                }
                
                ValidateCertificate();
                
                WebStsParamsParsed paramsParsed = WebStsParamsParsed.None;
                String[] WebStsRpsParameters = WebStsRpsParametersHeader.Split(',');

                foreach (String WebStsRpsParameter in WebStsRpsParameters)
                {
                    DateTime dt;
                    String[] ParamKV = WebStsRpsParameter.Split('=');

                    if (ParamKV.Length != 2)
                    {
                        throw new TokenWebProtocolException(
                                        HttpStatusCode.BadRequest, 
                                        String.Format("Parameters should be Key=Value you gave {0}", WebStsRpsParameter),
                                        null);
                    }

                    switch (ParamKV[0].Trim().ToLowerInvariant())
                    {
                        case "puid":
                            if (!UInt64.TryParse(ParamKV[1], out tokenParams.Puid))
                            {
                                throw new TokenWebProtocolException(HttpStatusCode.BadRequest, "Couldn't parse PUID", null);
                            }
                            paramsParsed |= WebStsParamsParsed.Puid;
                            break;

                        case "cid":
                            if (!UInt64.TryParse(ParamKV[1], out tokenParams.Cid))
                            {
                                throw new TokenWebProtocolException(HttpStatusCode.BadRequest, "Couldn't parse CID", null);
                            }
                            paramsParsed |= WebStsParamsParsed.Cid;
                            break;

                        case "issueinstant":
                            if (!DateTime.TryParse(ParamKV[1], out dt))
                            {
                                throw new TokenWebProtocolException(HttpStatusCode.BadRequest, "Couldn't parse IssueInstant", null);
                            }
                            tokenParams.IssueInstant = dt.ToUniversalTime();
                            paramsParsed |= WebStsParamsParsed.IssueInstant;
                            break;

                        case "notafter":
                            if (!DateTime.TryParse(ParamKV[1], out dt))
                            {
                                throw new TokenWebProtocolException(HttpStatusCode.BadRequest, "Couldn't parse NotAfter", null);
                            }
                            tokenParams.NotAfter = dt.ToUniversalTime();
                            paramsParsed |= WebStsParamsParsed.NotAfter;
                            break;

                        case "clientip":
                            IPAddress ipAddress;
                            if (!IPAddress.TryParse(ParamKV[1], out ipAddress))
                            {
                                throw new TokenWebProtocolException(HttpStatusCode.BadRequest, "Couldn't parse IpAddress", null);
                            }
                            tokenParams.ClientIp = ParamKV[1];
                            paramsParsed |= WebStsParamsParsed.ClientIp;
                            break;

                        default:
                            throw new TokenWebProtocolException(HttpStatusCode.BadRequest, String.Format("Unknown parameter {0}", ParamKV[0]), null);
                    }
                }
            
                if (paramsParsed != WebStsParamsParsed.All)
                {
                    throw new WebProtocolException(HttpStatusCode.BadRequest, String.Format("Not all params were passed {0}", (int)paramsParsed), null);
                }

                IXCacheDataAccess xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
                String GamerTag;

                if (!xcache.LookupWebID(tokenParams.Puid, out tokenParams.Xuid, out GamerTag))
                {
                    WebOperationContext.Current.OutgoingResponse.Headers.Add("X-Err", HResult.XONLINE_E_NO_USER.ToString());
                    throw new TokenWebProtocolException(HttpStatusCode.InternalServerError, "Couldn't get Xuid", null);
                }

                authManager.SetCurrentUser(new WebStsUserIdentity(tokenParams.Puid, tokenParams.Cid, tokenParams.Xuid));
                isAuthorized = true;
            }
            else
            {
                if (!SecurityTokensConfig.WebStsEnabled)
                {
                    WebOperationContext.Current.OutgoingResponse.Headers.Add("X-Err", HResult.XONLINE_E_LOGON_SERVERS_TOO_BUSY.ToString());
                    throw new TokenWebProtocolException(HttpStatusCode.InternalServerError, "WebSts disabled!", null);
                }

                IWindowsLiveIdentityAdapter wlidadaptor = Container.Instance.GetComponent<IWindowsLiveIdentityAdapter>();

                // Require RPSSectAuth cookie
                wlidadaptor.Authenticate(RpsAuthPolicySsl);

                isAuthorized = authManager.IsAuthenticated;

                if (isAuthorized)
                {
                    tokenParams.Puid = (ulong)authManager.CurrentUser.Puid;
                    tokenParams.Cid = (ulong)authManager.CurrentUser.Cid;
                    tokenParams.Xuid = authManager.CurrentUser.Xuid;
                    tokenParams.ClientIp = GetClientIp();

                    IWindowsLiveIdentity wlidIdentity = Container.Instance.GetComponent<IWindowsLiveIdentity>();
                    tokenParams.IssueInstant = wlidIdentity.IssueInstant;
                    tokenParams.NotAfter = wlidIdentity.NotAfter;
                }
            }
            return isAuthorized;
        }

        private static string GetClientIp()
        {
            string clientIp = "0.0.0.0";
            OperationContext context = OperationContext.Current;
            if (context != null)
            {
                MessageProperties messageProperties = context.IncomingMessageProperties;

                if (messageProperties != null)
                {
                    RemoteEndpointMessageProperty endpointProperty = messageProperties[RemoteEndpointMessageProperty.Name] as RemoteEndpointMessageProperty;

                    if (endpointProperty != null)
                    {
                        clientIp = endpointProperty.Address;
                    }
                }
            }
            return clientIp;
        }


        private static bool IsTitleBlocked(UInt32 titleId)
        {
            for (int i=0;i<SecurityTokensConfig.BlockedTitles.Length ;i++)
            {
                if(SecurityTokensConfig.BlockedTitles[i] == titleId)
                {
                    return true;
                }
            }
            return false;
        }

        private String GetValueFromDistinguishedName(X500DistinguishedName distinguishedName, String part)
        {
            String value = String.Empty;
            String[] NameParts = distinguishedName.Name.Split(',');

            foreach (String NamePart in NameParts)
            {
                String[] NameValue = NamePart.Split('=');

                if ((NameValue.Length == 2) && (String.Equals(NameValue[0].Trim(), part, StringComparison.InvariantCultureIgnoreCase)))
                {
                    value = NameValue[1].Trim();
                    break;
                }
            }

            return value;
        }

        private void ValidateCertificate()
        {
            X509Certificate2 clientCertificate = null;
            ServiceSecurityContext securityContext = OperationContext.Current.ServiceSecurityContext;

            if (securityContext.PrimaryIdentity.AuthenticationType.CompareTo("X509") != 0)
            {
                throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "Certificate required", null);
            }

            foreach (ClaimSet claimSet in securityContext.AuthorizationContext.ClaimSets)
            {
                X509CertificateClaimSet certificateClaimSet = claimSet as X509CertificateClaimSet;

                if (certificateClaimSet != null)
                {
                    clientCertificate = certificateClaimSet.X509Certificate;
                    break;
                }
            }

            if (clientCertificate == null)
            {
                throw new TokenWebProtocolException(HttpStatusCode.Unauthorized, "No certificate claims", null);
            }

            String subjectCN = GetValueFromDistinguishedName(clientCertificate.SubjectName, "CN");
            if (!String.Equals(subjectCN, SecurityTokensConfig.WebStsClientCertificateSubject, 
                               StringComparison.InvariantCultureIgnoreCase))
            {
                throw new TokenWebProtocolException(
                    HttpStatusCode.Unauthorized,
                    String.Format("Subject not trusted - expecting {0} got {1}", 
                                  SecurityTokensConfig.WebStsClientCertificateSubject,
                                  subjectCN), 
                    null);
            }

            String issuerCN = GetValueFromDistinguishedName(clientCertificate.IssuerName, "CN");
            if (!String.Equals(issuerCN, SecurityTokensConfig.WebStsClientCertificateIssuer,
                               StringComparison.InvariantCultureIgnoreCase))
            {
                throw new TokenWebProtocolException(
                    HttpStatusCode.Unauthorized,
                    String.Format("Issuer not trusted - expecting {0} got {1}",
                                  SecurityTokensConfig.WebStsClientCertificateIssuer,
                                  issuerCN),
                    null);
            }
        }

        private static void HandleLiveCacheException(uint gameId, TokenParameters tokenParams, ushort gameVersion, LivecacheResponseException ex)
        {
            WebOperationContext.Current.OutgoingResponse.Headers.Add("X-Err", Marshal.GetHRForException(ex).ToString());
            WebOperationContext.Current.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;

            // Don't log this if error is due to invalid titleID
            if (ex.HResult.ToString().Trim() != "0x80151912")
            {
                StsDiagnostics.Logging.LogEvent(new StsLiveCacheError(), ex,
                                                "Parameters: GameId={0},GameVersion={1},Puid={2},Xuid={3}",
                                                gameId, gameVersion, tokenParams.Puid, tokenParams.Xuid);
            }
            else
            {
                StsDiagnostics.Logging.LogTrace(TraceLevel.Info, ex, " Parameters: GameId={0},GameVersion={1},Puid={2},Xuid={3}",
                                                gameId, gameVersion, tokenParams.Puid, tokenParams.Xuid);

            }
        }


        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\GameData.svc.cs ===
﻿namespace Gds.Services.UserData
{
    using System;
    using System.Net;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using Gds.Contracts;
    using Gds.Services.UserData.Library;
    using Leet.Core.Utils;
    using Microsoft.ServiceModel.Web;
    using Wgx.Services.Common;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Members of GameData
    /// </summary>
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public class GameData : IGameData
    {
        private const string Component = "UserData";
        private static object lockObject = new object();
        private static bool initialized = false; // variable to track the initialization of the object

        public GameData()
        {
            if (initialized == false)
            {
                lock (lockObject)
                {
                    if (initialized == false)
                    {
                        // BUG: 8171 - subsribe only once to these events, else these will get executed multiple times
                        WcfErrorHandler.Instance.OnHandleError += new System.EventHandler<WcfHandleErrorEventArgs>(this.Instance_OnHandleError);
                        WcfErrorHandler.Instance.OnProvideFault += new System.EventHandler<WcfProvideFaultEventArgs>(this.Instance_OnProvideFault);
                        initialized = true;
                    }
                }
            }
        }

        public LeaderboardResult GetLeaderboardXml(uint gameId, uint variant, string property, string dataGroup, uint numRows, uint rankStart, uint socialGraph)
        {
            LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(gameId, variant, property, dataGroup, numRows, rankStart, socialGraph);
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return leaderboardResult;
        }

        public LeaderboardResult GetLeaderboardJson(uint gameId, uint variant, string property, string dataGroup, uint numRows, uint rankStart, uint socialGraph)
        {
            LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(gameId, variant, property, dataGroup, numRows, rankStart, socialGraph);
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return leaderboardResult;
        }

        public AchievementsResult GetAchievementsXml(uint gameId)
        {
            AchievementsResult achievementsResult = GameDataAdapter.GetAchievements(gameId);
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return achievementsResult;
        }

        public AchievementsResult GetAchievementsJson(uint gameId)
        {
            AchievementsResult achievementsResult = GameDataAdapter.GetAchievements(gameId);
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return achievementsResult;
        }

        public DatablobResult GetDatablobXml(string datablobId)
        {
            return GameStatisticsAdapter.GetDatablob(datablobId);
        }

        public DatablobResult GetDatablobJson(string datablobId)
        {
            return GameStatisticsAdapter.GetDatablob(datablobId);
        }

        public AvatarAwardsAssetResult GetAvatarAwardsAssets(uint gameId)
        {
            AvatarAwardsAssetResult avatarAwardsAssetResult = GameDataAdapter.GetAvatarAwardsAssets(gameId);
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
            return avatarAwardsAssetResult;
        }

        private void Instance_OnHandleError(object sender, WcfHandleErrorEventArgs e)
        {
            if (e.Exception != null)
            {
                // Don't process LIVEnExceptions OR WebProtocolExceptions
                if (e.Exception is LIVEnException ||
                    e.Exception is WebProtocolException)
                {
                    return;
                }
                else if (e.Exception.Data.Contains(typeof (GameData)))
                {
                    // If we have previously processed this, don't process it, either.
                    return;
                }

                if (!e.Exception.Data.Contains(typeof (GameData)))
                {
                    Logging.TraceInformation("{0}: {1}", GameData.Component, e.Exception.ToString());
                }
            }
        }

        private void Instance_OnProvideFault(object sender, WcfProvideFaultEventArgs e)
        {
            bool isProcessed = true;

            if (e.Exception != null)
            {
                // Don't process LIVEnExceptions OR WebProtocolExceptions
                if (e.Exception is LIVEnException ||
                    e.Exception is WebProtocolException)
                {
                    return;
                }
                else if (e.Exception.Data.Contains(typeof(GameData)))
                {
                    // If we have previously processed this, don't process it, either.
                    return;
                }

                e.Exception.Data[typeof(GameData)] = isProcessed;

                Logging.TraceInformation("{0}: {1}", GameData.Component, e.Exception.ToString());

                // List the exceptions that we convert into a BadRequest.
                if (e.Exception is FormatException)
                {
                    e.WebOperationContext.OutgoingResponse.StatusCode = HttpStatusCode.BadRequest;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData\UserStoreHealth.cs ===
﻿namespace Gds.Services.UserData
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using GameMetadata.Common;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Health.Common;
    using Gds.DataAccess.UserData;

    public class UserStoreHealth : IHealthBlock
    {
        /// <summary>
        /// A bogus Xuid, this information will travel all the way to the UserData DB.
        /// </summary>
        private const long HealthXuid = 1;

        /// <summary>
        /// This Id, is a GMS BVT title. If for whatever reasom GMS entries do change, this needs updating.
        /// </summary>
        private const uint HealthGameId = 5000;

        /// <summary>
        /// The GMS BVT title Variant setting.
        /// </summary>
        private const uint HealthVariant = 0;

        /// <summary>
        /// The LifeTime datagroup for the Health Page.
        /// </summary>
        private const UserStatisticsDatagroupEnum HealthDataGroup = UserStatisticsDatagroupEnum.Lifetime;

        /// <summary>
        /// The GMS BVT title stat ranking.
        /// </summary>
        private const StatRanking HealthStatRanking = StatRanking.High;

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            UserStoreHealthReport myReport = new UserStoreHealthReport();
            report.ExtendedReport = myReport;

            // Fill out report
            myReport.Component = config.ComponentName;

            try
            {
                // Get statistics for the given list of users, including callers.
                IUserProfileStorageSimple userDataStorageSimple = Container.Instance.GetComponent<IUserProfileStorageSimple>();

                List<ulong> listOfXuid = new List<ulong>();
                listOfXuid.Add((ulong)HealthXuid);

                IList<StatsResult> listOfFriendStats = userDataStorageSimple.GetStatsForXuids(
                    HealthGameId, HealthVariant, HealthDataGroup.ToString(), listOfXuid, StatisticsConstants.BestScore, (ulong)HealthXuid, HealthStatRanking);

                if (listOfFriendStats != null && listOfFriendStats.Count > 0)
                {
                    myReport.Xuid = listOfFriendStats[0].Xuid;
                    myReport.StatEntries = new List<Entry>(listOfFriendStats[0].Statistics);
                }

                myReport.Message = "Retrieving UserData did succeed.";
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                myReport.Message = ex.ToString();
            }
        }
    }

    public class UserStoreHealthReport : IExtendedHealthReport
    {
        /// <summary>
        /// The Xuid of the User.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public ulong Xuid { get; set; }

        /// <summary>
        /// StatsResult
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
        public List<Entry> StatEntries { get; set; }

        /// <summary>
        /// The component name;
        /// </summary>
        public string Component { get; set; }

        /// <summary>
        /// The extended message. 
        /// </summary>
        public string Message { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Gds.Services")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Gds.Services")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Gds.Services.UserData.Library")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GetDatablobCounters.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System;
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Performance counter class for GET Datablob
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
    public class GetDatablobCounters
    {
        private long startTicks;

        private PerformanceCounterCollection counters;

        public GetDatablobCounters()
        {
            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(UserDataPerfCounters));
        }

        public void StartRequest()
        {
            this.startTicks = Stopwatch.GetTimestamp();
            this.counters.SafeIncrement(UserDataPerfCounters.GetDatablobRequestsPerSecond);
            this.counters.SafeIncrement(UserDataPerfCounters.GetDatablobTotalRequests);
        }

        public void EndRequest(bool failed)
        {
            long duration = Stopwatch.GetTimestamp() - this.startTicks;
            this.counters.SafeIncrementBy(UserDataPerfCounters.GetDatablobAverageExecutionTime, duration);
            this.counters.SafeIncrement(UserDataPerfCounters.GetDatablobAverageExecutionTimeBase);
            if (failed)
            {
                this.counters.SafeIncrement(UserDataPerfCounters.GetDatablobFailuresPerSecond);
                this.counters.SafeIncrement(UserDataPerfCounters.GetDatablobTotalFailures);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GetAvatarAwardAssetCounters.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System;
    using System.Diagnostics;
    using Wgx.Services.Monitoring;
    using Leet.Utils;

    /// <summary>
    /// Performance counter class for GET AvatarAwardAssets
    /// </summary>
    public class GetAvatarAwardAssetCounters : PerfCounterBase<GetAvatarAwardAssetCounters>
    {
        private PerformanceCounterCollection counters;

        private static object lockObject = new Object();
        private bool perfCountersInitialized;

        public GetAvatarAwardAssetCounters()
        {
            this.Initialize();
        }

        private bool Initialize()
        {
            if (this.counters == null)
            {
                lock (lockObject)
                {
                    if (this.counters == null)
                    {
                        try
                        {
                            perfCountersInitialized = true;
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(UserDataPerfCounters));
                        }
                        catch (Exception)
                        {
                            perfCountersInitialized = false;
                        }
                    }
                }
            }

            return this.perfCountersInitialized;
        }

        public override void StartRequest(object context)
        {
            if (Initialize())
            {
                base.StartRequest(context);

                this.counters.SafeIncrement(UserDataPerfCounters.GetAvatarAwardAssetsRequestsPerSecond);
                this.counters.SafeIncrement(UserDataPerfCounters.GetAvatarAwardAssetsTotalRequests);
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;
            
            if (this.perfCountersInitialized)
            {
                duration = base.EndRequest(failed);

                this.counters.SafeIncrementBy(UserDataPerfCounters.GetAvatarAwardAssetsAverageExecutionTime, duration);
                this.counters.SafeIncrement(UserDataPerfCounters.GetAvatarAwardAssetsAverageExecutionTimeBase);
                if (failed)
                {
                    this.counters.SafeIncrement(UserDataPerfCounters.GetAvatarAwardAssetsFailuresPerSecond);
                    this.counters.SafeIncrement(UserDataPerfCounters.GetAvatarAwardAssetsTotalFailures);
                }
            }

            return duration;
        }

        public override IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            throw new NotImplementedException("Use the conainer from Iocco");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\LeaderboardPagination.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using GDS.DataAccess.UserData;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    internal class LeaderboardPagination
    {
        internal const uint MaximumNumRowsAllowed = 10000;
        internal const uint MaxiumumRankStartAllowed = 10000;

        /// <summary>
        /// Note that rankStart is 1 based, and not 0 based.
        /// </summary>
        /// <param name="leaderboardItemResults"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        internal static IList<LeaderboardUtilityItem> PaginateLeaderboardItems(IList<LeaderboardUtilityItem> leaderboardItemResults, LeaderboardParams parameters)
        {
#if DEBUG
            // Caller is supposed to have called this before us.
            // lets assert the proper ranges for these values.
            VerifyPageParameters(parameters.RankStart, parameters.NumRows);
#endif
            
            // we picked signed arithmetic here, because it is much easier to detect the roll over if it happens.
            int rankStartActual = 0;

            // this would throw, if NumRows is allowed to be larger than int.MaxValue
            int numRowsActual = (int)parameters.NumRows;

            // see if we want a result set pivoted around the current user.
            if (parameters.RankStart == 0)
            {
                // if the requested rows is less than count, calculate the optimum start location.
                // our aim is to try center the result set around the current users rank.
                if (leaderboardItemResults.Count > numRowsActual)
                {
                    // lets get the current users rank location.
                    rankStartActual = (int)GetRankOfCurrentUser(leaderboardItemResults, parameters.Xuid);

                    // if the current user does NOT exists in the ranked Collection,
                    // simply set the start to 1.
                    if (rankStartActual == 0)
                    {
                        rankStartActual = 1;
                    }
                    else
                    {
                        // check if currentUser is too close to the end of list
                        if (rankStartActual + numRowsActual - 1 > leaderboardItemResults.Count())
                        {
                            rankStartActual = (int)leaderboardItemResults.Count() - numRowsActual + 1;
                        }
                        else
                        {
                            // by now, current user exists and has a rank that is not close to the end.
                            // well then try to center the result around current user.
                            int midPointRange = numRowsActual / 2;
                            rankStartActual -= midPointRange;
                        }
                    }

                    // ensure that rankStartActual is never smaller than 1.
                    if (rankStartActual < 1)
                    {
                        rankStartActual = 1;
                    }
                }
                // if the requested rows is larger than count, simply set the start to 1
                else
                {
                    rankStartActual = 1;
                }
            }
            else
            {
                rankStartActual = (int)parameters.RankStart;
            }

            // if the start rank is somewhere in lala land, immediately return null.
            if (rankStartActual > leaderboardItemResults.Count())
            {
                return null;
            }

            // since rankStart is 1 based, ensure we don't make an off by 1 error here:
            int rankEnd = rankStartActual + numRowsActual - 1;

            // if the rankEnd is too far away, then reset it to a more sensible upper bound.
            if (rankEnd > leaderboardItemResults.Count())
            {
                rankEnd = leaderboardItemResults.Count();

#if DEBUG
                // we can only return this many rows from rankStart.
                numRowsActual = (int)rankEnd - rankStartActual + 1;
#endif
            }

            // select all entries between rankStart and rankEnd, inclusively.
            var pageCollection = from Entry in leaderboardItemResults
                                 where Entry.Item.Rank >= (uint)rankStartActual &&
                                       Entry.Item.Rank <= (uint)rankEnd
                                 select Entry;

#if DEBUG
            if (pageCollection.Count() != numRowsActual)
            {
                throw new InvalidOperationException("ASSERT: these two numbers should be equal");
            }
#endif

            return pageCollection.ToList();
        }

        public static void VerifyPageParameters(uint rankStart, uint numRows)
        {
            // Out of paranoia lets ensure our assumptions. The calling stack is required to make a similar check
            if (numRows < 1)
            {
                throw new ArgumentOutOfRangeException("numRows", "numRows can not be less than 1");
            }

            // Removal of the following next two line would require change into the logic in paging,
            // as we would have different ways of overflowing.
            if (numRows > LeaderboardPagination.MaximumNumRowsAllowed)
            {
                throw new ArgumentOutOfRangeException("numRows", "NumRows is way too large for this operation.");
            }

            if (rankStart > LeaderboardPagination.MaxiumumRankStartAllowed)
            {
                throw new ArgumentOutOfRangeException("rankStart", "RankStart is way too large for this operation" );
            }
        }

        /// <summary>
        /// Note that it is NOT guaranteed that we are in this list.
        /// </summary>
        /// <param name="leaderboardItemResults"></param>
        /// <param name="xuid"></param>
        /// <returns>0 if it does not exists, actual rank if the xuid exists.</returns>
        private static uint GetRankOfCurrentUser(IList<LeaderboardUtilityItem> leaderboardItemResults, ulong xuid)
        {
            var rankCollection = from leaderboardEntry in leaderboardItemResults
                                 where leaderboardEntry.Xuid == xuid
                                 select leaderboardEntry.Item.Rank;

            if (rankCollection.Count() == 1)
            {
                return rankCollection.First();
            }
            else if (rankCollection.Count() > 1)
            {
                // log this bizare occurence
                // this should NOT happen.
                Logging.TraceError("LeaderboardPagination.GetRankOfCurrentUser rankCollection.Count() > 1 for user with xuid {0} ", xuid.ToString());
            }
            
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GetLeaderboardCounters.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System;
    using System.Diagnostics;
    using Leet.Core.Utils;
    using Wgx.Services.Monitoring;
    using Leet.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Performance counter class for GET Leaderboard
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
    public class GetLeaderboardCounters : PerfCounterBase<GetLeaderboardCounters>
    {
        private bool perfCountersInitialized;

        private PerformanceCounterCollection counters;

        private static object lockObject = new Object();

        public GetLeaderboardCounters()
        {
            Initialize();
        }

        private bool Initialize()
        {
            if (this.counters == null)
            {
                lock (lockObject)
                {
                    if (this.counters == null)
                    {
                        this.perfCountersInitialized = true;
                        try
                        {
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(UserDataPerfCounters));
                        }
                        catch (Exception ex)
                        {
                           this.perfCountersInitialized = false;
                           Logging.TraceException(ex, "GetLeaderboardCounters: ProfilePerfCounters has not been installed");
                        }
                    }
                }
            }

            return this.perfCountersInitialized;
        }

        public override void StartRequest(object context)
        {
            if (this.Initialize())
            {
                base.StartRequest(context);
                
                this.counters.SafeIncrement(UserDataPerfCounters.GetLeaderboardRequestsPerSecond);
                this.counters.SafeIncrement(UserDataPerfCounters.GetLeaderboardTotalRequests);
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;

            if (this.perfCountersInitialized)
            {
                duration = base.EndRequest(failed);
                this.counters.SafeIncrementBy(UserDataPerfCounters.GetLeaderboardAverageExecutionTime, duration);
                this.counters.SafeIncrement(UserDataPerfCounters.GetLeaderboardAverageExecutionTimeBase);
                if (failed)
                {
                    this.counters.SafeIncrement(UserDataPerfCounters.GetLeaderboardFailuresPerSecond);
                    this.counters.SafeIncrement(UserDataPerfCounters.GetLeaderboardTotalFailures);
                }
            }

            return duration;
        }

        public override IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            throw new NotImplementedException("Use the conainer from Iocco");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GetAchievementsCounters.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System;
    using System.Diagnostics;
    using Wgx.Services.Monitoring;
    using Leet.Utils;

    /// <summary>
    /// Performance counter class for GET Achievements
    /// </summary>
    public class GetAchievementsCounters : PerfCounterBase<GetAchievementsCounters>
    {
        private PerformanceCounterCollection counters;

        private static object lockObject = new Object();
        private bool perfCountersInitialized;

        public GetAchievementsCounters()
        {
            this.Initialize();
        }

        private bool Initialize()
        {
            if (this.counters == null)
            {
                lock (lockObject)
                {
                    if (this.counters == null)
                    {
                        try
                        {
                            perfCountersInitialized = true;
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(UserDataPerfCounters));
                        }
                        catch (Exception)
                        {
                            perfCountersInitialized = false;
                        }
                    }
                }
            }

            return this.perfCountersInitialized;
        }

        public override void StartRequest(object context)
        {
            if (Initialize())
            {
                base.StartRequest(context);

                this.counters.SafeIncrement(UserDataPerfCounters.GetAchievementsRequestsPerSecond);
                this.counters.SafeIncrement(UserDataPerfCounters.GetAchievementsTotalRequests);
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;
            
            if (this.perfCountersInitialized)
            {
                duration = base.EndRequest(failed);

                this.counters.SafeIncrementBy(UserDataPerfCounters.GetAchievementsAverageExecutionTime, duration);
                this.counters.SafeIncrement(UserDataPerfCounters.GetAchievementsAverageExecutionTimeBase);
                if (failed)
                {
                    this.counters.SafeIncrement(UserDataPerfCounters.GetAchievementsFailuresPerSecond);
                    this.counters.SafeIncrement(UserDataPerfCounters.GetAchievementsTotalFailures);
                }
            }

            return duration;
        }

        public override IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            throw new NotImplementedException("Use the conainer from Iocco");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GameStatisticsAdapter.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using Gds.Contracts;
    using Gds.DataAccess.UserData;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;

    /// <summary>
    /// Server implementation of the IGameStatistics interface
    /// </summary>
    public sealed class GameStatisticsAdapter
    {
        internal const int TestGameID = 5;
        internal const int TestGameVariant = 1;

        private GameStatisticsAdapter() { }

        private static IUserProfileStorageSimple UserProfileStorageSimple { get; set; }

        static GameStatisticsAdapter()
        {
            GameStatisticsAdapter.UserProfileStorageSimple = Container.Instance.GetComponent<IUserProfileStorageSimple>();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")] 
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "datablob")]
        static public DatablobResult GetDatablob(string datablobId)
        {
            GetDatablobCounters counters = new GetDatablobCounters();
            bool requestFailed = false;
            DatablobResult result = new DatablobResult();
            DateTime dtUpdated = DateTime.Now, dtCreated = DateTime.Now;

            string locale, platformType;
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);

            try
            {
                counters.StartRequest();

                // throws ArgumentException or a derivative if fails.
                CustomHeaderValidator.ValidateServiceHttpHeaders(locale, platformType);

                Guid blobId = ValidateBlobId(datablobId);
                byte[] dataBlob = null;
                // Get blob for the given blobId.
                try
                {
                    dataBlob = UserProfileStorageSimple.GetBlob(blobId);
                }
                catch (UserProfileDataAccessOperationException ex)
                {
                    if (ex.ErrorCode != UserProfileDataAccessOperationException.NoEntryFound)
                    {
                        throw;
                    }
                }

                result = new DatablobResult
                {
                    DatablobId = blobId,
                    Blob = dataBlob
                };
            }
            catch (FormatException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.RejectInput("GET DataBlob", ex);
            }
            catch (OverflowException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.RejectInput("GET DataBlob", ex);
            }
            catch (ArgumentException ex)
            {
                requestFailed = true;
                UserDataAdapterUtility.RejectInput("GET DataBlob", ex);
            }
            finally
            {
                counters.EndRequest(requestFailed);
            }

            return result;
        }

        private static Guid ValidateBlobId(string datablobId)
        {
            if (string.IsNullOrEmpty(datablobId))
            {
                UserDataAdapterUtility.RejectInput("GET DataBlob", new InvalidOperationException("datablobId is not defined"));
            }

            Guid blobId = new Guid(datablobId);

            if (blobId == Guid.Empty)
            {
                throw new FormatException("BlobID as Guid.Empty is not allowed");
            }

            return blobId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\LeaderboardParameterValidator.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;

    internal static class LeaderboardParameterValidator
    {
        /// <summary>
        /// Gets all the leaderboard call parameters pre-filled, except the Xuid
        /// </summary>
        /// <param name="parameters"></param>
        public static void ValidateCall(LeaderboardParams parameters)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters", "leaderboard parameters not defined");
            }

            ServiceParameterValidator.ValidateAgainstGmsBasic(parameters.GameId, parameters.Locale, parameters.PlatformType);
            LeaderboardParameterValidator.ValidateGameVariantProperty(parameters);
            LeaderboardParameterValidator.ValidateSocialGraph(parameters.SocialGraph);
            LeaderboardParameterValidator.ValidateDatagroup(parameters.DataGroup);
            LeaderboardPagination.VerifyPageParameters(parameters.RankStart, parameters.NumRows);
        }

        public static void ValidateGameVariantProperty(LeaderboardParams parameters)
        {
            // Ensure GameId and VariantId is in sync.
            try
            {
                if (parameters == null)
                {
                    throw new ArgumentNullException("parameters", "No leaderboard parameters provided");
                }

                // If no property string is defined throw ArgumentNullException
                if (string.IsNullOrEmpty(parameters.Property))
                {
                    throw new ArgumentNullException("parameters", "No parameters.Property: No leaderboard stat/property is defined");
                }

                IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();

                // previously validated to exist.
                GameVariantComposite gmsGameVariantComposite = gmsProxy.GetGameVariant(parameters.GameId, parameters.Variant);

                // a DataContract serialized Dictionary does not retain any IEqualityComparer feature.
                // we would like to perform Ordinal case insensitive lookups.
                Dictionary<string, StatRanking> ranking = new Dictionary<string, StatRanking>(gmsGameVariantComposite.StatRankings, StringComparer.OrdinalIgnoreCase);

                // If GMS does not know of this property for this Game/Variant, throw Argument exception.
                if (!ranking.ContainsKey(parameters.Property))
                {
                    throw new ArgumentException("given property is not defined for this GameVariant in GMS");
                }
            }
            catch (ArgumentException)
            {
                throw;
            }
            catch (Exception ex)
            {
                // Some failure in GMS, 
                // Per our agreement, this function only throws ArgumentException
                // convert the exception but retain the information:
                throw new ArgumentException("a GMS call has failed, check inner exception for further detail", ex);
            }
        }

        public static void ValidateSocialGraph(uint socialGraph)
        {
            if (!Enum.IsDefined(typeof(LeetSocialGraphs), socialGraph))
            {
                throw new ArgumentOutOfRangeException("socialGraph");
            }

            if (LeetSocialGraphs.XboxLiveFriends != (LeetSocialGraphs)socialGraph)
            {
                throw new ArgumentException("Invalid Social Graph Selection, we only support XboxLiveFriends in this version of leaderboard");
            }
        }

        public static void ValidateDatagroup(string datagroupName)
        {
            try
            {
                // This call may throw ArgumentNullException OR ArgumentException, which by definition of Validate calls is acceptable to throw.
                // We convert other exceptions to a suitable ArgumentException derived exception type.
                UserStatisticsDatagroupEnum datagroupMode = (UserStatisticsDatagroupEnum)Enum.Parse(typeof(UserStatisticsDatagroupEnum), datagroupName, true);
            }
            catch (OverflowException ex)
            {
                throw new ArgumentOutOfRangeException("datagroupName", ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\GameDataAdapterLeaderboard.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Gds.Contracts;
    using Gds.DataAccess.UserData;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Profile;
    using Leet.Core.Diagnostics;
    public class LeaderboardParams
    {
        public uint GameId { get; set; }

        public uint Variant { get; set; }

        public string Property { get; set; }

        public string DataGroup { get; set; }

        public uint NumRows { get; set; }

        public uint RankStart { get; set; }

        public uint SocialGraph { get; set; }

        public ulong Xuid { get; set; }

        public string Locale { get; set; }

        public string PlatformType { get; set; }
    }

    public class GameDataAdapterLeaderboard
    {
        private const string ComponentName = "Leaderboard";

        private static IUserProfileStorageSimple UserProfileStorageSimple { get; set; }

        static GameDataAdapterLeaderboard()
        {
            GameDataAdapterLeaderboard.UserProfileStorageSimple = Container.Instance.GetComponent<IUserProfileStorageSimple>();
        }

        /// <summary>
        /// Process the leaderboard request for given parameters
        /// </summary>
        /// <param name="parameters"></param>
        /// <param name="callingXuid">Calling user</param>
        /// <param name="friendsInfo">List of relevant friends, some of them may not have stats</param>
        /// <returns></returns>
        internal static LeaderboardResult ProcessLeaderboardRequest(
            LeaderboardParams parameters, 
            ulong callingXuid,
            Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendsInfo)
        {
            IList<LeaderboardUtilityItem> leaderboardFullCollection = null;
            IList<LeaderboardUtilityItem> pagedLeaderboard = null;

            // initialize a non-null but otherwise empty result object.
            // for any failure, this is the response message we will be returning.
            LeaderboardResult leaderboardResult = new LeaderboardResult()
            {
                TotalNumberOfRows = 0
            };

            // create the xuid list from friends and add calling xuid to it
            List<ulong> friendXuidList = new List<ulong>();

            if (friendsInfo != null)
            {
                for (int index = 0; index < friendsInfo.Length; index++)
                {
                    friendXuidList.Add(friendsInfo[index].LivePuid);
                }
            }

            friendXuidList.Add(callingXuid); // we always have at least the caller in the list


            StatRanking statRanking = GetStatRanking(parameters); // Already validated to exist.
            IList<StatsResult> listOfFriendStats = UserProfileStorageSimple.GetStatsForXuids(
                                                                                                    parameters.GameId,
                                                                                                    parameters.Variant,
                                                                                                    parameters.DataGroup,
                                                                                                    friendXuidList,
                                                                                                    parameters.Property,
                                                                                                    callingXuid,
                                                                                                    statRanking);

            if (listOfFriendStats != null && listOfFriendStats.Count > 0)
            {
                // convert the list of statistics, into an ordered list of LeaderboardItems.
                leaderboardFullCollection = LeaderboardUtility.ConvertStatsToLeaderboard(listOfFriendStats, parameters.Property, statRanking == StatRanking.High);

                // Fetch profile info for only friends with stats (including the caller)
                ulong[] friendsWithStats = new ulong[listOfFriendStats.Count];
                for (int index = 0; index < listOfFriendStats.Count; index++)
                {
                    friendsWithStats[index] = listOfFriendStats[index].Xuid;  
                }

                IProfileProvider provider = Container.Instance.GetComponent<IProfileProvider>();
                Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfile = provider.GetProfile(callingXuid, friendsWithStats);

                // populate LeaderboardItems with relevant Profile info.
                PopulateLeaderboardItemsProfile(leaderboardFullCollection, callingXuid, friendsInfo, gamerProfile);

                // At this point we do know how many ranked entries the Leaderboard does have.
                // Ensure that total number of rows in the non-paged leaderboard is recorded in the result object.
                leaderboardResult.TotalNumberOfRows = (uint)leaderboardFullCollection.Count();

                // Create the paged view 
                pagedLeaderboard = LeaderboardPagination.PaginateLeaderboardItems(leaderboardFullCollection, parameters);

                // convert the paged entries into the list in the result object.
                if (pagedLeaderboard != null)
                {
                    // initialize 
                    leaderboardResult.Leaderboard = new List<LeaderboardItem>(pagedLeaderboard.Count());

                    // conserving the order, copy it over to the result object.
                    foreach (LeaderboardUtilityItem item in pagedLeaderboard)
                    {
                        leaderboardResult.Leaderboard.Add(item.Item);
                    }
                }
                else
                {
                    Logging.TraceError("{0} : pagedLeaderboard is null in GameDataAdapterLeaderboard.ProcessLeaderboardRequest() {1}",
                        ComponentName,
                        callingXuid.ToString());
                }
            }
            else
            {
                Logging.TraceVerbose("{0}: listOfFriendStats is empty in LeaderboardResult GameDataAdapterLeaderboard.ProcessLeaderboardRequest() {1}",
                    ComponentName,
                    callingXuid.ToString());
            }

            return leaderboardResult;
        }

        /// <summary>
        /// Populate the list of leaderboard items with profile information
        /// </summary>
        /// <param name="leaderboardItemResults"></param>
        /// <param name="callingXuid">calling user</param>
        /// <param name="friendsInfo">friendsInfo that contains gamerTag</param>
        /// <param name="gamerProfile">gamerProfile that contains GamerPicURL and DisplayName</param>
        private static void PopulateLeaderboardItemsProfile(
                   IList<LeaderboardUtilityItem> leaderboardItemResults, 
                   ulong callingXuid,
                   Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendsInfo,
                   Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfile)
        {
            uint i = 1;
            foreach (LeaderboardUtilityItem item in leaderboardItemResults)
            {
                item.Item.Rank = i++;
                if (item.Xuid == callingXuid)
                {
                    // we didn't call the GetProfile for the calling user, so this is a light-weight call to get the GamerTag
                    PopulateLeaderboardItemGamerTag(item);
                }
                else
                {
                    // for others it exists in friendsInfo
                    PopulateLeaderboardItemGamerTag(item, friendsInfo);
                }
                PopulateLeaderboardItemProfile(item, gamerProfile);
            }
        }

        /// <summary>
        /// Populate the GamerTag for the given item
        /// </summary>
        /// <param name="item"></param>
        /// <param name="friendsInfo"></param>
        private static void PopulateLeaderboardItemGamerTag(
                    LeaderboardUtilityItem item, 
                    Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendsInfo)
        {
            if (friendsInfo != null)
            {
                for (int index = 0; index < friendsInfo.Length; index++)
                {
                    if (item.Xuid == friendsInfo[index].LivePuid)
                    {
                        item.Item.User.GamerTag = friendsInfo[index].Gamertag;
                        return;
                    }
                }
            }
            else
            {
                // this shouldn't happen, log anyway
                Logging.TraceError("{0} : friendsInfo is null in GameDataAdapterLeaderboard.PopulateLeaderboardItemGamerTag() | {1}",
                    ComponentName,
                    item.Xuid.ToString());
            }
        }

        /// <summary>
        /// Populate the GamerTage for the given item using GetGamertagByPuid
        /// </summary>
        /// <param name="item"></param>
        private static void PopulateLeaderboardItemGamerTag(LeaderboardUtilityItem item)
        {
            string gamerTag;
            IXCacheDataAccess xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
            xCacheDataAccess.GetGamertagByPuid(item.Xuid, out gamerTag);
            item.Item.User.GamerTag = gamerTag;
        }

        /// <summary>
        /// Populate GamerPicURL, DisplayName and Cid for the given item
        /// </summary>
        /// <param name="item"></param>
        /// <param name="gamerProfile"></param>
        private static void PopulateLeaderboardItemProfile(
                    LeaderboardUtilityItem item,
                    Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfile)
        {
            if (gamerProfile != null)
            {
                for (int index = 0; index < gamerProfile.Length; index++)
                {
                    if (item.Xuid == gamerProfile[index].LivePuid)
                    {
                        item.Item.User.PictureUrl = gamerProfile[index].GamerTileUrl;
                        item.Item.User.DisplayName = gamerProfile[index].Name;
                        // this is a temporary debug help. Need to populate Cid at some point when needed
                        item.Item.User.Cid = gamerProfile[index].LivePuid;
                        return;
                    }
                }
            }
            else
            {
                // this shouldn't happen, log anyway
                Logging.TraceError("{0} gamerProfile is null in GameDataAdapterLeaderboard.PopulateLeaderboardItemProfile() | {1}",
                    ComponentName,
                    item.Xuid.ToString());
            }
        }

        private static uint GetDatagroupNumber(string datagroupName)
        {
            UserStatisticsDatagroupEnum datagroupMode = (UserStatisticsDatagroupEnum)Enum.Parse(typeof(UserStatisticsDatagroupEnum), datagroupName, true);

            if (datagroupMode == UserStatisticsDatagroupEnum.W1)
            {
                return UserDataUtilities.GetDatagroupNumberForDate(DateTime.UtcNow);
            }

            return 0;
        }

        /// <summary>
        /// TODO: Consider creating a local cache out of these, keyed off of GameId/Variant
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        private static IDictionary<string, IUserStorageConverterFilter> GetStatConverterFromGmsSettings(LeaderboardParams parameters)
        {
            Dictionary<string, IUserStorageConverterFilter> converterFilter = null;

            // At this point of the code, the gmsProxy MUST exist. No need for null check. (*)
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();

            // Again, it must be guaranteed that this gvc exists at this point. (*)
            GameVariantComposite gvc = gmsProxy.GetGameVariant(parameters.GameId, parameters.Variant);

            converterFilter = new Dictionary<string, IUserStorageConverterFilter>(gvc.StatRankings.Count, StringComparer.OrdinalIgnoreCase);

            // create filters
            UserDataConverterFilter[] filters = new UserDataConverterFilter[4]
                                         { 
                                            new UserDataConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestHighTime, 
                                                    AliasName = StatisticsConstants.BestTime, 
                                                    IsRemoved = StatRemoved(gvc.StatRankings, StatisticsConstants.BestTime, StatRanking.High)
                                                },
                                            new UserDataConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestLowTime, 
                                                    AliasName = StatisticsConstants.BestTime,
                                                    IsRemoved = StatRemoved(gvc.StatRankings, StatisticsConstants.BestTime, StatRanking.Low)
                                                },
                                            new UserDataConverterFilter() 
                                                { 
                                                    PropertyKey = StatisticsConstants.BestHighScore, 
                                                    AliasName = StatisticsConstants.BestScore, 
                                                    IsRemoved = StatRemoved(gvc.StatRankings, StatisticsConstants.BestScore, StatRanking.High) 
                                                },
                                            new UserDataConverterFilter() 
                                                {
                                                    PropertyKey = StatisticsConstants.BestLowScore, 
                                                    AliasName = StatisticsConstants.BestScore, 
                                                    IsRemoved = StatRemoved(gvc.StatRankings, StatisticsConstants.BestScore, StatRanking.Low) 
                                                }
                                         };
            foreach (var filter in filters)
            {
                converterFilter.Add(filter.PropertyKey, filter);
            }

            return converterFilter;
        }

        private static StatRanking GetStatRanking(LeaderboardParams parameters)
        {
            // At this point of the code, the gmsProxy MUST exist. No need for null check. (*)
            IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();

            // Again, it must be guaranteed that this gvc exists at this point. (*)
            GameVariantComposite gvc = gmsProxy.GetGameVariant(parameters.GameId, parameters.Variant);

            // a DataContract serialized Dictionary does not retain any IEqualityComparer feature.
            // we would like to perform Ordinal case insensitive lookups.
            Dictionary<string, StatRanking> ranking = new Dictionary<string, StatRanking>(gvc.StatRankings, StringComparer.OrdinalIgnoreCase);

            return ranking[parameters.Property];
        }

        /// <summary>
        /// If given statName does exists and ranking type does match return "do not remove" i.e. false.
        /// Otherwise return true, indicating that stat should be removed from final reported statistic list.
        /// </summary>
        /// <param name="rankings">GMS provided Dictionary of statNames and ranking/ordering</param>
        /// <param name="statName">UDS provided statName</param>
        /// <param name="statRanking">UDS provided HIGH or LOW stat name</param>
        /// <returns></returns>
        private static bool StatRemoved(IDictionary<string, StatRanking> rankings, string statName, StatRanking statRanking)
        {
            var q = from ranking in rankings.AsQueryable()
                    where ranking.Key.Equals(statName, StringComparison.OrdinalIgnoreCase) &&
                          ranking.Value == statRanking
                    select ranking;
            if (q.Count() > 0)
            {
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\UserDataAdapterUtility.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using System.Net;
    using System.Text;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics; 

    internal class UserDataAdapterUtility
    {
        private UserDataAdapterUtility() { }
        /// <summary>
        /// Component Name
        /// </summary>
        public const string ComponentName = "UserDataService";

        /// <summary>
        /// Get the current user identity from the request context
        /// </summary>
        /// <returns>Current User Identity</returns>
        public static IUserIdentity GetCallerIdentity()
        {
            var authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                throw new UnauthorizedAccessException();
            }

            return authManager.CurrentUser;
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client.
        /// </summary>
        /// <param name="methodName">
        /// Name of the web method from which exception is thrown.
        /// </param>
        /// <param name="ex">Exception object.</param>
        /// <param name="httpStatusCode">Http status code for the response</param>
        /// <param name="eventCode">Event identifier</param>
        public static void HandleException(string methodName, Exception ex, HttpStatusCode httpStatusCode, int eventCode)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                    UserDataEvents.Events,
                    eventCode,
                    httpStatusCode,
                    ex,
                    methodName,
                    ComposeExceptionDebugMessage(methodName, ex),
                    true);
            }

            le.ThrowWebProtocolException();
        }

        public static void RejectInput(string methodName, Exception ex, HttpStatusCode httpStatusCode, int eventCode, params string[] args)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                    UserDataEvents.Events,
                    eventCode,
                    httpStatusCode,
                    ex,
                    methodName,
                    ComposeExceptionDebugMessage(methodName, ex),
                    true,
                    args);
            }

            le.ThrowWebProtocolException();
        }

        public static void RejectInput(string methodName, Exception ex)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                                UserDataEvents.Events,
                                UserDataEvents.InvalidArgument,
                                HttpStatusCode.BadRequest, 
                                ex, 
                                methodName,
                                ComposeExceptionDebugMessage(methodName, ex),
                                true);
            }

            le.ThrowWebProtocolException();
        }

        public static string ComposeExceptionDebugMessage(Exception ex)
        {
            return ComposeExceptionDebugMessage(null, ex);
        }

        public static string ComposeExceptionDebugMessage(string methodName, Exception ex)
        {
            StringBuilder sb = new StringBuilder(1024);

            if (!string.IsNullOrEmpty(methodName))
            {
                sb.AppendFormat("Exception caught in Method: {0} \r\n", methodName);
            }

            if (ex != null)
            {
                sb.AppendFormat("\r\n inner Exception: {0} \r\n", ex.ToString());

                if (ex.Data.Contains(typeof(LeaderboardParams)))
                {
                    string leaderboardParams = ex.Data[typeof(LeaderboardParams)] as string;
                    if (!string.IsNullOrEmpty(leaderboardParams))
                    {
                        sb.AppendFormat("LeaderboadCallParameters: \r\n {0}", leaderboardParams);
                    }
                }
            }

            return sb.ToString();
        }

        public static string DumpLeaderboardParameters(LeaderboardParams leaderboardParams)
        {
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat("Xuid: '{0}'. \r\n", leaderboardParams.Xuid);
            sb.AppendFormat("GameId: '{0}'. \r\n", leaderboardParams.GameId);
            sb.AppendFormat("Variant: '{0}'. \r\n", leaderboardParams.Variant);
            sb.AppendFormat("Property: '{0}'. \r\n", leaderboardParams.Property);
            sb.AppendFormat("RankStart: '{0}'. \r\n", leaderboardParams.RankStart);
            sb.AppendFormat("NumRows: '{0}'. \r\n", leaderboardParams.NumRows);
            sb.AppendFormat("SocialGraph: '{0}'. \r\n", leaderboardParams.SocialGraph);
            sb.AppendFormat("PlatformType: '{0}'. \r\n", leaderboardParams.PlatformType);
            sb.AppendFormat("Locale: '{0}'.\r\n", leaderboardParams.Locale);

            return sb.ToString();
        }
    }

    // TODO: Move class out to a Converter class.
    internal class UserDataConverterFilter : IUserStorageConverterFilter
    {
        public string PropertyKey { get; set; }

        public string AliasName { get; set; }

        public bool IsRemoved { get; set; }

        public Entry Process(string name, string value)
        {
            if (this.IsRemoved)
            {
                throw new InvalidOperationException();
            }

            Entry current = new Entry()
            {
                Name = this.AliasName,
                Value = value
            };

            return current;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\PerformanceCounterSelector.cs ===
﻿namespace Gds.Services.UserData.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Leet.Utils;

    public class PerformanceCounterSelector : PerfCounterBase<PerformanceCounterSelector>
    {
        public override void StartRequest(Object context)
        {
            throw new NotImplementedException("Use the selector to get the actual implementation");
        }

        public override long EndRequest(bool failed)
        {
            throw new NotImplementedException("Use the selector to get the actual implementation");
        }

        public override IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            switch (enumSet)
            {
                case PerformanceCounterSet.Achievements:
                    return new GetAchievementsCounters();

                case PerformanceCounterSet.Leaderboard:
                    return new GetLeaderboardCounters();

                case PerformanceCounterSet.AvatarAwardAssets:
                    return new GetAvatarAwardAssetCounters();

                default:
                    throw new InvalidOperationException("Please provide a valid enumerator value.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Services.UserData.Library")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("GDS.Services.UserData.Library")]
//[assembly: AssemblyCopyright("Copyright ©  2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("978a97c7-f526-4b56-a5ac-82e9593923cd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\ServiceParameterValidator.cs ===
﻿namespace Gds.Services
{
    using System;
    using System.Collections.Generic;
    using System.IdentityModel.Claims;
    using System.Linq;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Utils;
    using Leet.Identity;

    public static class ServiceParameterValidator
    {
        // Base DateTime for game timestamp validation
        private static DateTime baseDateTime = new DateTime(2010, 1, 1);

        /// <summary>
        /// Basic Validation against GMS occurs
        /// a) Http Headers given: locale and platformType
        /// b) Validates that given GameId exists in GMS
        /// c) Validates game metadata lists platform as supported platform.
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Gms")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.UInt32.Parse(System.String)")]
        public static void ValidateAgainstGmsBasic(uint gameId, string locale, string platformType)
        {
            try
            {
                // throws ArgumentException or a derivative if fails.
                CustomHeaderValidator.ValidateServiceHttpHeaders(locale, platformType);

                // Ensure GameId and VariantId is in sync.
                // and verify that this game is actually is send from the correct platform type.
                IGameMetadataClient gmsProxy = Container.Instance.GetComponent<IGameMetadataClient>();
                if (!gmsProxy.CheckIsValidGameId(gameId))
                {
                    throw new ArgumentOutOfRangeException("gameId", "GameId is not valid");
                }

                // Check if platformType given for this POST is actually supported by the title in the GMS.
                GameMetadataComposite gmsComposite = gmsProxy.GetGameMetadata(gameId, locale);
                if (gmsComposite != null &&
                    gmsComposite.SupportedPlatforms != null &&
                    gmsComposite.SupportedPlatforms.Count > 0)
                {
                    // uint.Parse is guaranteed to succeed because it is validated prior to here.
                    var q = from platform in gmsComposite.SupportedPlatforms
                            where platform == uint.Parse(platformType)
                            select platform;
                    if (q.Count() == 0)
                    {
                        throw new ArgumentOutOfRangeException("platformType", "platformType provided does not match the titles supported platforms in GMS");
                    }
                }
                else
                {
                    throw new ArgumentException("Game has no metadata and/or supported platform defined");
                }
            }
            catch (ArgumentException)
            {
                throw;
            }
            catch (Exception ex)
            {
                // Some failure in GMS, 
                throw new InvalidOperationException("a GMS call has failed, check inner exception for further detail", ex);
            }
        }

        /// <summary>
        /// This function will default the locale per our defaulting logic spec.
        /// The defaulting logic is activated only if there is a locale header value provided.
        /// if null or empty is passed in, we shall not default, but leave the value intact
        /// This will guarantee that no regression on API behavior while achieving parity with other services.
        /// NOTE: the major difference is w/ the old non-defaulting behavior
        ///       an invalid (not just unsupported) locale did fail w/ 400 - Bad Request. Not anymore.
        ///       We simply default to en-US.
        /// </summary>
        /// <param name="localeHeaderValue"></param>
        /// <param name="platformHeaderValue"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "0#")]
        public static void FetchHeaders(out string localeHeaderValue, out string platformHeaderValue)
        {
            IWebOperationIncomingRequestHeaderReader headers = Container.Instance.GetComponent<IWebOperationIncomingRequestHeaderReader>();

            // X-locale header must exist and be valid.
            localeHeaderValue = headers[CustomWebHeaderNames.XLocale];

            // Ensure we get the default locale if it is unsupported.
            if (!string.IsNullOrEmpty(localeHeaderValue))
            {
                ILocaleHelper localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
                localeHeaderValue = localeHelper.GetSupportedLocale(localeHeaderValue);
            }

            // X-Platform-Type must exist and be valid.
            platformHeaderValue = headers[CustomWebHeaderNames.XPlatformType];
        }

        /// <summary>
        /// Normalized platformType based fixed mappings
        /// </summary>
        /// <param name="titleID"></param>
        /// <returns></returns>
        public static Int32 NormalizePlatformType(Int32 platformType)
        {
            switch (platformType)
            {
                case 5:
                case 15:
                    {
                        return 5;
                    }
                case 6:
                case 16:
                    {
                        return 6;
                    }
                default:
                    {
                        return platformType;
                    }
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")] 
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid")]
        public static void ValidateXuid(ulong xuid)
        {
            if (xuid == 0)
            {
                throw new ArgumentException("xuid cannot be fetched for user");
            }
        }

        /// <summary>
        /// Validate the game timestamp
        /// </summary>
        /// <param name="timeStamp"></param>
        public static void ValidateGameTimestamp(DateTime timestamp)
        {
            // Make sure the timestamp is later than baseDateTime
            if (timestamp < baseDateTime)
            {
                throw new ArgumentOutOfRangeException("timestamp", "TimeStamp must be later than 01/01/2010");
            }
        }

        /// <summary>
        /// Gets the claim value for a specified claim type from the Authnetication token CliamSet
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="claimType"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool TryGetClaimValueFromAuthenticationToken(String claimType, out Object value)
        {
            if (String.IsNullOrEmpty(claimType))
            {
                throw new ArgumentNullException("claimType");
            }

            IAuthenticationManager authenticationmanager = Container.Instance.GetComponent<IAuthenticationManager>();
            if (!authenticationmanager.IsAuthenticated ||
                authenticationmanager.CurrentUser == null ||
                !authenticationmanager.CurrentUser.IsAuthenticated)
            {
                throw new UnauthorizedAccessException();
            }

            ClaimSet claimSet = authenticationmanager.GetClaims();
            if(claimSet != null)
            {
                IList<Claim> claims = new List<Claim>(claimSet.FindClaims(claimType, Rights.PossessProperty));
                if (claims != null && claims.Count > 0)
                {
                    value = claims[0].Resource;
                    return true;
                }
            }
            
            value = null;
            return false;
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Library\UserDataPerfCounters.cs ===
﻿
namespace Gds.Services.UserData.Library
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class implements the UserData PerfCounter Category
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Perf")]
    [PerformanceCategory(CategoryName = "Gds UserData", CategoryType = PerformanceCounterCategoryType.SingleInstance)]
    public sealed class UserDataPerfCounters
    {
        private UserDataPerfCounters()
        {
        }

        public static string Name
        {
            get
            {
                return "Gds UserData";
            }
        }

        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }

        /// <summary>
        /// Performance counters for GET Leaderboard
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GET Leaderboard")]
        public static int GetLeaderboardTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GET Leaderboard")]
        public static int GetLeaderboardTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GET Leaderboard requests per second")]
        public static int GetLeaderboardRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GET Leaderboard failures per second")]
        public static int GetLeaderboardFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GET Leaderboard")]
        public static int GetLeaderboardAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leaderboard")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetLeaderboardAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GET Leaderboard", BasePropertyName = "GetLeaderboardAverageExecutionTimeBase")]
        public static int GetLeaderboardAverageExecutionTime;

        /// <summary>
        /// Performance counters for GET Achievements
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GET Achievements")]
        public static int GetAchievementsTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GET Achievements")]
        public static int GetAchievementsTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GET Achievements requests per second")]
        public static int GetAchievementsRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GET Achievements failures per second")]
        public static int GetAchievementsFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GET Achievements")]
        public static int GetAchievementsAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAchievementsAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GET Achievements", BasePropertyName = "GetAchievementsAverageExecutionTimeBase")]
        public static int GetAchievementsAverageExecutionTime;

        /// <summary>
        /// Performance counters for GET AvatarAwardAssets
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GET AvatarAwardAssets")]
        public static int GetAvatarAwardAssetsTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GET AvatarAwardAssets")]
        public static int GetAvatarAwardAssetsTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GET AvatarAwardAssets requests per second")]
        public static int GetAvatarAwardAssetsRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GET AvatarAwardAssets failures per second")]
        public static int GetAvatarAwardAssetsFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GET AvatarAwardAssets")]
        public static int GetAvatarAwardAssetsAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetAvatarAwardAssetsAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GET AvatarAwardAssets", BasePropertyName = "GetAvatarAwardAssetsAverageExecutionTimeBase")]
        public static int GetAvatarAwardAssetsAverageExecutionTime;

        /// <summary>
        /// Performance counters for GET Datablob
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GET Datablob")]
        public static int GetDatablobTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GET Datablob")]
        public static int GetDatablobTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GET Datablob requests per second")]
        public static int GetDatablobRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GET Datablob failures per second")]
        public static int GetDatablobFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GET Datablob")]
        public static int GetDatablobAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Datablob")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "GetDatablobAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GET Datablob", BasePropertyName = "GetDatablobAverageExecutionTimeBase")]
        public static int GetDatablobAverageExecutionTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Presence.svc.cs ===
﻿
namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Net;
    using Gds.Contracts;
    using Gds.Services.UserData.Partner.Library;
    using Leet.Identity;
   
    using LIVEN.Common.Diagnostics;
    using System.ServiceModel;
    using System.ServiceModel.Activation;

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class Presence : IPresence
    {
        public void UpdatePresence()
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            //Validate TitleID in the authentication token against a block list of title ID's
            uint tokenTitleID = 0;
            if (!TokenClaimsHelper.TryGetTokenTitleID(out tokenTitleID) || tokenTitleID == 0 || PresenceProvider.IsTitleBlocked(tokenTitleID))
            { 
                UserDataUtility.HandleException("TitleID in the sts token is invalid or blocked.", null, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            PresenceProvider.UpdatePresence(currentUser.Xuid, tokenTitleID);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Message.svc.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Message.svc.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  Message class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using Gds.Contracts;
    using Gds.Services.UserData.Partner.Library;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class MessageService : IMessageService
    {
        static readonly Int32 MAX_RECIPIENTS = 100;
        static readonly Int32 MAX_MESSAGE_LENGTH = 250;

        /// <summary>
        /// Get the message summary list. 
        /// </summary>
        /// <param name="hashCode">An optional hash code of the original message. </param>
        /// <returns>Message summary response object. </returns>
        public Contracts.MessageSummariesResponse GetMessageSummaries(string hashCode)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            MessageSummariesResponse response = new MessageSummariesResponse();
            try
            {
                response = MessageAdapter.EnumerateMessages(currentUser.Xuid, hashCode); 
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error getting message summaries.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }
            return response;
        }

        /// <summary>
        /// Get the message details. 
        /// </summary>
        /// <param name="messageId">The message id. </param>
        /// <returns>The message detail object. </returns>
        public Contracts.MessageDetails GetMessageDetails(uint messageId)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);
            
            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            MessageDetails messageDetails = null;
            try
            {
                messageDetails = MessageAdapter.GetMessageDetails(currentUser.Xuid, messageId, true);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error getting message details.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            System.Diagnostics.Debug.Assert(messageDetails != null, "messageDetails");
            return messageDetails;
        }

        /// <summary>
        /// Send a new message. 
        /// </summary>
        /// <param name="request">The message request. </param>
        public Contracts.ResponseWithErrorCode SendMessage(SendMessageRequest request)
        {
            ResponseWithErrorCode response = new ResponseWithErrorCode(); 
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            // This line also checks if user is already authenticated so needs to be before other checks
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            //Check if we have any recipients in the request or
            //Check if max recipients limit is crossed
            if (request == null || request.Recipients == null || request.Recipients.Count == 0 || request.Recipients.Count > MAX_RECIPIENTS)
            {
                UserDataUtility.HandleException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "SendMessageRequest should contain at least 1 recipient and no more than {0} recipients", MAX_RECIPIENTS),
                    null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }
            
            //check message length
            if (String.IsNullOrEmpty(request.MessageText) || request.MessageText.Length > MAX_MESSAGE_LENGTH)
            {
                UserDataUtility.HandleException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "SendMessageRequest message length should not be greater than {0} and less than 1", MAX_MESSAGE_LENGTH),
                    null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's in NPDB
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }


            try
            {
                MessageAdapter.SendMessage(currentUser.Xuid, currentUser.Gamertag, request);
            }
            catch (WebProtocolException wpex)
            {
                //We already have a WebProtocolException here. We will log it and rethrow with the same status code and message
                UserDataUtility.HandleException(wpex.Message, wpex, wpex.StatusCode, UserDataPartnerEvents.InvalidArgument);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error sending a message.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            return response; 
        }

        /// <summary>
        /// Delete a message. 
        /// </summary>
        /// <param name="messageId">The message Id. </param>
        public Contracts.ResponseWithErrorCode DeleteMessage(uint messageId)
        {
            ResponseWithErrorCode response = new ResponseWithErrorCode(); 
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);
            
            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            try
            {
                MessageAdapter.DeleteMessage(currentUser.Xuid, messageId, false);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error deleting a message.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            return response; 
        }

        /// <summary>
        /// Delete a message and block the sender
        /// </summary>
        /// <param name="messageId">The message Id. </param>
        public Contracts.ResponseWithErrorCode DeleteMessageAndBlockGamertag(uint messageId)
        {
            ResponseWithErrorCode response = new ResponseWithErrorCode(); 
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;
            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            try
            {
                MessageAdapter.DeleteMessage(currentUser.Xuid, messageId, true);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error getting sending a deleting message and blocking user.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }
            return response; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\GameData.svc.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GameData.svc.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameData class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using Gds.Contracts;
    using Gds.Services.UserData.Partner.Library;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics;
    
    /// <summary>
    /// GameData class
    /// </summary>
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class GameData : IGameDataPartner
    {
        /// <summary>
        /// Default games page start
        /// </summary>
        private const uint DefaultGamesPageStart = 0;

        /// <summary>
        /// Default games page count
        /// </summary>
        private const uint DefaultGamesPageCount = 500;

        /// <summary>
        /// Component name
        /// </summary>
        private const string ComponentName = "GameData";

        /// <summary>
        /// Comma character array
        /// </summary>
        private static char[] CommaCharSeparators = new char[] { ',' };

        /// <summary>
        /// Implements GetGames
        /// </summary>
        /// <param name="gamertag">Gamertag of the friend</param>
        /// <param name="pageStart">Index of the page</param>
        /// <param name="pageCount">Number of items to be returned</param>
        /// <returns>Games object</returns>
        public Games GetGames(string gamertags, string pageStart, string pageCount)
        {
            Logging.TraceVerbose("{0}: GetGames | {1} | {2} | {3}", ComponentName, gamertags, pageStart, pageCount);

            uint start = DefaultGamesPageStart;
            uint count = DefaultGamesPageCount;
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user, platform, and locale
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }


            // Validate parameters
            if (string.IsNullOrEmpty(gamertags))
            {
                UserDataUtility.HandleException("Gamertag cannot be null or empty.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }
            
            string[] gamertagsArray = gamertags.Split(CommaCharSeparators, StringSplitOptions.RemoveEmptyEntries);

            if (gamertagsArray.Length > 2 || gamertagsArray.Length == 0)
            {
                UserDataUtility.HandleException("Number of gamertags must be between 1-2.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            if (!string.IsNullOrEmpty(pageStart))
            {
                if (!uint.TryParse(pageStart, out start))
                {
                    UserDataUtility.HandleException("pageStart", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
                }
            }

            if (!string.IsNullOrEmpty(pageCount))
            {
                if (!uint.TryParse(pageCount, out count))
                {
                    UserDataUtility.HandleException("pageCount", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
                }
            }

            // Bug 7895 - validate the pageStart for overflow, this scenario is unlikely but user may pass it by mistake
            if ((int)start * (int)count < 0 || (int)start + (int)count < 0)
            {
                UserDataUtility.HandleException("pageStart or pageCount", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // start and count should be <= 1000
            if (count > 1000 || start > 1000)
            {
                UserDataUtility.HandleException("pageStart or pageCount", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Get LCID
            ushort lcid = 0;
            try
            {
                lcid = UserDataUtility.GetLcid(locale);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("X-Locale is invalid.", ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Retrieve games
            Games games = new Games();
            try
            {
                games = GameDataPartnerAdapter.GetGames(currentUser, lcid, gamertagsArray, start, count);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error retrieving games.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            return games;
        }

        /// <summary>
        /// Implements GetAchievements
        /// </summary>
        /// <param name="gameId">Game Identifier</param>
        /// <param name="gamertags">Gamer tag</param>
        /// <returns>Achievements object</returns>
        public Achievements GetAchievements(string gameId, string gamertags)
        {

            Logging.TraceVerbose("{0}: GetAchievements | {1} | {2}", ComponentName, gameId, gamertags);

            IUserIdentity currentUser = null;
            string platformType = null;
            string locale = null;
            Achievements achievements = new Achievements();

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }


            uint gId = 0;

            if (!uint.TryParse(gameId, out gId))
            {
                UserDataUtility.HandleException("GameId", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Validate parameters
            if (gId <= 0)
            {
                UserDataUtility.HandleException("GameId is invalid.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            if (string.IsNullOrEmpty(gamertags))
            {
                UserDataUtility.HandleException("Gamertag cannot be null or empty.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            string[] gamertagsArray = gamertags.Split(CommaCharSeparators, StringSplitOptions.RemoveEmptyEntries);

            if (gamertagsArray.Length > 4 ||
                gamertagsArray.Length == 0)
            {
                UserDataUtility.HandleException("Number of gamertags must be between 1-4.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }
           
            List<string> gamertagList = new List<string>();

            foreach (string gt in gamertagsArray)
            {
                gamertagList.Add(gt);
            }

            // Get LCID
            ushort lcid = 0;
            try
            {
                lcid = UserDataUtility.GetLcid(locale);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("X-Locale is invalid.", ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Retrieve achievements for each user
            try
            {
                achievements = GameDataPartnerAdapter.GetAchievements(currentUser, lcid, gamertagList, gId);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error retrieving achievements.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            return achievements;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Global.asax.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GameDataPartnerAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameDataPartnerAdapter class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Web;
    using GameMetadata.Client;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.TestSupport;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Providers;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Profile;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;

    public class Global : System.Web.HttpApplication
    {
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            UserDataPartnerEvents.Initialize("gds_uds_part");

            RegisterBaselineInterfaces();
            Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
            ((NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", "gds_uds_part");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("gds_uds_part");
            
            Container.Instance.AddEmulatableService<IStringServerDataAccess, StringServerDataAccess>();
            ProfileProvider.RegisterWithIocContainer(Container.Instance, "gds_uds_part");
            GameMetadataClient.RegisterContainerServices();

            Container.Instance.AddEmulatableService<IAudienceUriProvider, UdsPartAudienceUriProvider>();
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, WebOperationIncomingRequestHeaderReader>();

            Leet.Identity.PartnerAuth.AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

           Logging.TraceInformation("UserDataPartnerService: Application Started.");
            UserDataPartnerEvents.Events.TraceEvent(UserDataPartnerEvents.ServiceStarted);
        }

        /// <summary>
        /// Register the required baseline interfaces
        /// </summary>
        private static void RegisterBaselineInterfaces()
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<ITestImplementationProvider, TestImplementationProvider>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
        }

        protected void Session_Start(object sender, EventArgs e)
        {

        }

        protected void Application_BeginRequest(object sender, EventArgs e)
        {

        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            // Proxies must treat the response as private & must not transform or cache the response.
            HttpContext.Current.Response.Headers["Cache-Control"] = "private, no-transform, no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        protected void Application_AuthenticateRequest(object sender, EventArgs e)
        {

        }

        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            UserDataEvents.Events.TraceEvent(UserDataEvents.ApplicationError, ex.ToString());
            Logging.TraceException(ex,
                 "UserDataPartnerService");
        }

        protected void Session_End(object sender, EventArgs e)
        {

        }

        protected void Application_End(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Friend.svc.cs ===
﻿
namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.Text.RegularExpressions;
    using Gds.Contracts;
    using Gds.Services.UserData.Partner.Library;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using LIVEN.Common.Diagnostics;
    using xonline.common.webplatform.livecache;

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class Friend : IFriend
    {
        public static string ComponentName = "Friend";

        /// <summary>
        /// gamertag format.
        /// </summary>
        private static Regex gamerTagPattern = new Regex(@"^[A-Za-z](?:[A-Za-z0-9]|\ (?!\ |$)){0,14}$", RegexOptions.Compiled);

        /// <summary>
        /// Check the if the gamertag is valid. this function is mostly duplicate of xonline.common.user.NameUtil.VerifyGamerTag
        /// </summary>
        /// <param name="name">gamertag to check</param>
        /// <returns>true if the gamertag is valid, false if invalid</returns>
        private static bool IsGamertagPatternValid(string name)
        {
            return (name != null) && gamerTagPattern.IsMatch(name);
        }

        public void AddFriend(string gamertag)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user, platform, and locale
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            // Validate parameters
            if (string.IsNullOrEmpty(gamertag) || !IsGamertagPatternValid(gamertag))
            {
                string errorMessage = string.Format("Error adding friend- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ulong targetXuid;
            var xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
            xCacheDataAccess.GetPuidByGamerTag(gamertag, out targetXuid);

            if (targetXuid == 0)
            {
                string errorMessage = string.Format("Error adding friend; gamertag does not exist- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.GamertagDoesNotExist);
            }

            try
            {
                FriendAdapter.AddFriend(currentUser, targetXuid);
            }
            catch (LivecacheUserThrottledException ex)
            {
                string errorMessage = string.Format("Error adding friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheUserThrottledException);
            }
            catch (LivecacheResponseException ex)
            {
                string errorMessage = string.Format("Error adding friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheResponseException);
            }

            return;
        }

        public void AcceptFriend(string gamertag)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user, platform, and locale
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }
            
            // Validate parameters
            if (string.IsNullOrEmpty(gamertag) || !IsGamertagPatternValid(gamertag))
            {
                string errorMessage = string.Format("Error accepting friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ulong targetXuid;
            var xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
            xCacheDataAccess.GetPuidByGamerTag(gamertag, out targetXuid);

            if (targetXuid == 0)
            {
                string errorMessage = string.Format("Error accepting friend request; gamertag does not exist- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.GamertagDoesNotExist);
            }

            bool response = false;
            try
            {
                response = FriendAdapter.AcceptFriend(currentUser, targetXuid);
            }
            catch (LivecacheUserThrottledException ex)
            {
                string errorMessage = string.Format("Error accepting friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheUserThrottledException);
            }
            catch (LivecacheResponseException ex)
            {
                string errorMessage = string.Format("Error accepting friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheResponseException);
            }

            if(!response)
            {
                UserDataUtility.HandleException("User does not have privilege to accept a friend.", null, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            return;
        }

        public void DeclineFriendRequest(string gamertag)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user, platform, and locale
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            // Validate parameters
            if (string.IsNullOrEmpty(gamertag) || !IsGamertagPatternValid(gamertag))
            {
                string errorMessage = string.Format("Error declining friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ulong targetXuid;
            var xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
            xCacheDataAccess.GetPuidByGamerTag(gamertag, out targetXuid);

            if (targetXuid == 0)
            {
                string errorMessage = string.Format("Error declining friend request; gamertag does not exist- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.GamertagDoesNotExist);
            }

            try
            {
                FriendAdapter.DeclineFriendRequest(currentUser, targetXuid);
            }
            catch (LivecacheUserThrottledException ex)
            {
                string errorMessage = string.Format("Error declining friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheUserThrottledException);
            }
            catch (LivecacheResponseException ex)
            {
                string errorMessage = string.Format("Error declining friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheResponseException);
            }

            return;
        }

        public void RemoveFriend(string gamertag)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user, platform, and locale
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            // Validate parameters
            if (string.IsNullOrEmpty(gamertag) || !IsGamertagPatternValid(gamertag))
            {
                string errorMessage = string.Format("Error removing friend- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ulong targetXuid;
            var xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
            xCacheDataAccess.GetPuidByGamerTag(gamertag, out targetXuid);

            if (targetXuid == 0)
            {
                string errorMessage = string.Format("Error removing friend; gamertag does not exist- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, null, HttpStatusCode.BadRequest, UserDataPartnerEvents.GamertagDoesNotExist);
            }

            try
            {
                FriendAdapter.RemoveFriend(currentUser, targetXuid);
            }
            catch (LivecacheUserThrottledException ex)
            {
                string errorMessage = string.Format("Error removing friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheUserThrottledException);
            }
            catch (LivecacheResponseException ex)
            {
                string errorMessage = string.Format("Error removing friend request- caller:{0}, gamertag:{1}", currentUser.Gamertag, gamertag);
                UserDataUtility.HandleException(errorMessage, ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.LivecacheResponseException);
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\GameDataPartnerAdapter.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GameDataPartnerAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameDataPartnerAdapter class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Core.Configuration;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.Live.Livecache.Logic.Games;
    using Leet.Live.Tiles;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;

    /// <summary>
    /// GameDataPartnerAdapter class
    /// </summary>
    public class GameDataPartnerAdapter
    {
        /// <summary>
        /// Default max games page count
        /// </summary>
        public const int MaxGamesPerPageAllowed = 500;

        /// <summary>
        /// Retrieves a list of games
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="lcid">The locale</param>
        /// <param name="gamertags">Comma-delimited gamertag array</param>
        /// <param name="pageStart">Index of the page</param>
        /// <param name="pageCount">Number of items returned in page</param>
        /// <returns>A list of games for the caller (and gamertag's list of games)</returns>
        public static Games GetGames(IUserIdentity callerIdentity, ushort lcid, string[] gamertags, uint pageStart, uint pageCount)
        {
            List<UserGames> userGameses = new List<UserGames>();

            foreach (string gt in gamertags)
            {
                if (!string.IsNullOrEmpty(gt))
                {
                    ulong targetUserXuid = GetXuid(callerIdentity, gt);

                    UserGames targetUserGames = GetUserGames(gt, callerIdentity.Xuid, targetUserXuid, lcid);
                    userGameses.Add(targetUserGames);
                }
            }

            uint totalUniqueGames = 0;

            if (userGameses.Count > 1)
            {
                // Do sorting
                totalUniqueGames = SortGameList(userGameses);
            }
            else if(userGameses.Count == 1 
                && userGameses[0].GameList != null)
            {
                totalUniqueGames = (uint) userGameses[0].GameList.Count;
            }

            int index = (int) pageStart;
            int count = (int) pageCount;

            if (count > MaxGamesPerPageAllowed)
            {
                count = MaxGamesPerPageAllowed;
            }

            // Check to see if page start index is out of range; set to the end of the list if it is
            if (index*count > userGameses[0].GameList.Count)
            {
                index = userGameses[0].GameList.Count;
            }
            else
            {
                index = index*count;
            }

            // Check to see if count is out range; set to the length of list - pageIndex
            if (index + count > userGameses[0].GameList.Count)
            {
                count = userGameses[0].GameList.Count - index;
            }

            foreach (var gamer in userGameses)
            {
                gamer.GameList = gamer.GameList.GetRange(index, count);
                gamer.GameList.RemoveAll(EmptyGameInfo);
            }

            Games result = new Games
            {
                UserGamesCollection = userGameses,
                TotalUniqueGames = totalUniqueGames
            };

            return result; 
        }

        /// <summary>
        /// Returns the Achievements object
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="lcid">Locale of the results</param>
        /// <param name="gamertags">List of gamertags</param>
        /// <param name="gameId">GameId of achievements to be returned</param>
        /// <returns>Achievements object</returns>
        public static Achievements GetAchievements(IUserIdentity callerIdentity, ushort lcid, List<string> gamertags, uint gameId)
        {
            List<UserAchievements> userAchievementses = new List<UserAchievements>();
            foreach (string gamertag in gamertags)
            {
                ulong targetXuid = GetXuid(callerIdentity, gamertag);
                if (targetXuid == 0)
                {
                    continue;
                }

                var achievementDataAccess = Container.Instance.GetComponent<IAchievementDataAccess>();
                List<IReadOnlyAchievementInfo> readOnlyAchievementInfoList = null;
                readOnlyAchievementInfoList = achievementDataAccess.GetUserAchievements(gameId, callerIdentity.Xuid, targetXuid, lcid);
                List<Achievement> achievementList = new List<Achievement>();
                if (readOnlyAchievementInfoList != null)
                {
                    var achievements = from readOnlyAchievementInfo in readOnlyAchievementInfoList
                                       select new Achievement
                                                  {
                                                      GameId = gameId,
                                                      Description = readOnlyAchievementInfo.Description,
                                                      DisplayBeforeEarned = !readOnlyAchievementInfo.IsHidden,
                                                      EarnedDateTime = readOnlyAchievementInfo.DateUnlocked,
                                                      EarnedOnline = readOnlyAchievementInfo.WasEarnedOnline,
                                                      Gamerscore = readOnlyAchievementInfo.GamerscoreValue,
                                                      HowToEarn = readOnlyAchievementInfo.HowTo,
                                                      IsEarned = readOnlyAchievementInfo.IsUnlocked,
                                                      Key = Convert.ToString(readOnlyAchievementInfo.AchievementId),
                                                      Name = readOnlyAchievementInfo.Title,
                                                      PictureUrl = readOnlyAchievementInfo.ImageHref.AbsoluteUri
                                                  };
                    achievementList = achievements.ToList();
                }

                ulong gamerscore = 0;
                ulong totalAchievementsEarned = 0;
                ulong totalPossibleGamerscore = 0;
                GetAchievementInfo(achievementList, out gamerscore, out totalAchievementsEarned, out totalPossibleGamerscore);
                UserAchievements userAchievements = new UserAchievements
                                                        {
                                                            AchievementList = achievementList,
                                                            Gamerscore = gamerscore,
                                                            Gamertag = gamertag,
                                                            TotalAchievementsEarned = totalAchievementsEarned,
                                                            TotalPossibleAchievements = (uint) achievementList.Count,
                                                            TotalPossibleGamerscore = totalPossibleGamerscore
                                                        };
                userAchievementses.Add(userAchievements);
            }
            
            Achievements result = new Achievements
                                      {
                                          UserAchievementsCollection = userAchievementses
                                      };

            return result;
        }

        /// <summary>
        /// Calculates and returns achievement data
        /// </summary>
        /// <param name="achievementList">List of achievements</param>
        /// <param name="gamerscore">Total gamerscore</param>
        /// <param name="totalAchievementsEarned">Total achievements earned</param>
        /// <param name="totalPossibleGamerscore">Total possible gamescore</param>
        private static void GetAchievementInfo(List<Achievement> achievementList, out ulong gamerscore, out ulong totalAchievementsEarned, out ulong totalPossibleGamerscore)
        {
            gamerscore = 0;
            totalAchievementsEarned = 0;
            totalPossibleGamerscore = 0;

            foreach (var achievement in achievementList)
            {
                if (achievement.IsEarned)
                {
                    gamerscore += (ulong) achievement.Gamerscore;
                    totalAchievementsEarned += 1;
                }

                totalPossibleGamerscore += (ulong) achievement.Gamerscore;
            }
        }

        /// <summary>
        /// Retrieves the xuid based on the gamertag
        /// </summary>
        /// <param name="gamertag">Gamertag to be looked up</param>
        /// <returns>The gamertag's xuid</returns>
        private static ulong GetXuid(IUserIdentity callerIdentity, string gamertag)
        {
            if (string.Compare(callerIdentity.Gamertag, gamertag, true) == 0)
            {
                return callerIdentity.Xuid;
            }

            ulong xuid = 0;
            var xCache = Container.Instance.GetComponent<IXCacheDataAccess>();

            xCache.GetPuidByGamerTag(gamertag, out xuid);
            return xuid;
        }

        // Search predicate returns true if gameId == 0
        private static bool EmptyGameInfo(Contracts.GameInfo gameInfo)
        {
            if (gameInfo.Id == 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Retrieves a list of games for the gamertag and sorts it by last played date and time in descending order
        /// </summary>
        /// <param name="gamertag">Gamertag to be looked up</param>
        /// <param name="callingUserPuid">Caller's xuid</param>
        /// <param name="targetUserXuid">Target's xuid</param>
        /// <param name="lcid">Locale of the results</param>
        /// <returns>A list of sorted games by last played date in descending order for the gamertag</returns>
        private static UserGames GetUserGames(string gamertag, ulong callingUserPuid, ulong targetUserXuid, ushort lcid)
        {
            var provider = Container.Instance.GetComponent<IAchievementDataAccess>();
            List<IReadOnlyUserTitle> userTitles = provider.GetUserTitles(callingUserPuid, targetUserXuid, lcid, 0, ushort.MaxValue);

            // get gamescore and total possible gamerscore
            uint totalPossibleGamerscore = 0;
            uint gamerscore = GetGamerscores(userTitles, out totalPossibleGamerscore);

            var sortedUserTitles = from usertitle in userTitles
                                     orderby usertitle.LastPlayed descending
                                     select usertitle;

            userTitles = sortedUserTitles.ToList();

            UserGames userGames = new UserGames
            {
                GameList = GetGameList(userTitles, lcid),
                Gamerscore = gamerscore,
                Gamertag = gamertag,
                TotalGamesPlayed = (uint)userTitles.Count,
                TotalPossibleGamerscore = totalPossibleGamerscore
            };

            return userGames;
        }

        /// <summary>
        /// Creates a list of GameInfoPartner based on the UserTitles
        /// </summary>
        /// <param name="userTitles">User titles list</param>
        /// <param name="lcid">Locale of the titles</param>
        /// <returns>A list of GameInfoPartner</returns>
        private static List<Contracts.GameInfo> GetGameList(List<IReadOnlyUserTitle> userTitles, ushort lcid)
        {
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            List<Contracts.GameInfo> gameInfoPartners = null;
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            if (userTitles != null)
            {
                string locale = null;
                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
                locale = localeHelper.GetLocale(lcid);

                gameInfoPartners = new List<Contracts.GameInfo>();
                for (int i = 0; i < userTitles.Count; i++)
                {
                    GameMetadataComposite gameData = gmsClient.GetGameMetadata(userTitles[i].TitleId, locale);

                    string imageUrl = TileLocator.Instance.TitleTileUrl(userTitles[i].TitleId);

                    // set the default gameUrl
                    string gameUrl = String.Format(configProvider.GetSetting(Settings.DefaultGameUrl), locale, userTitles[i].TitleId);
                    uint gameType = (uint)PlatformBitMask.None;

                    // if game data is available, populate URL, image URL, and type
                    // else use the image URL which we got using userTitle.TitleId
                    if (gameData != null)
                    {
                        gameUrl = gameData.GameRedirectionUrl;
                        if (gameData.Images.ContainsKey(ImageType.GameTile_WebLarge)
                            && String.IsNullOrEmpty(gameData.Images[ImageType.GameTile_WebLarge].ImageUrl) == false)
                        {
                            imageUrl = gameData.Images[ImageType.GameTile_WebLarge].ImageUrl;
                        }
                        gameType = gameData.SupportedPlatformsBitMask;
                    }

                    Contracts.GameInfo gameInfoPartner = new Contracts.GameInfo
                    {
                        AchievementsEarned = userTitles[i].EarnedAchievements,
                        Gamerscore = userTitles[i].EarnedGamerscore,
                        GameUrl = gameUrl,
                        Id = userTitles[i].TitleId,
                        ImageUrl = imageUrl,
                        LastPlayed = userTitles[i].LastPlayed,
                        Name = userTitles[i].TitleName,
                        TotalAchievements = userTitles[i].TotalAchievements,
                        TotalPossibleGamerscore = userTitles[i].TotalGamerscore,
                        Type = gameType
                    };
                    gameInfoPartners.Add(gameInfoPartner);
                }
            }

            return gameInfoPartners;
        }

        /// <summary>
        /// Sorting only the first two gamertags in the list
        /// </summary>
        /// <param name="userGames">List of usergames</param>
        /// <param name="firstGameDictionary">Dictionary for the first gamer's games</param>
        /// <param name="secondGameDictionary">Dictionary for the second gamer's games</param>
        /// <returns>A merged ordered queue of the first two gamertags most recently played games</returns>
        private static Queue<uint> CreateSortedQueue(List<UserGames> userGames, Dictionary<uint, Contracts.GameInfo> firstGameDictionary, Dictionary<uint, Contracts.GameInfo> secondGameDictionary)
        {
            Queue<uint> sortedByRecentlyPlayed = new Queue<uint>();

            int firstIndex = 0;
            int secondIndex = 0;

            // Merge list by most recently played and add to queue
            while (firstIndex < userGames[0].GameList.Count || secondIndex < userGames[1].GameList.Count)
            {
                if (firstIndex >= userGames[0].GameList.Count)
                {
                    if (!sortedByRecentlyPlayed.Contains(userGames[1].GameList[secondIndex].Id))
                    {
                        sortedByRecentlyPlayed.Enqueue(userGames[1].GameList[secondIndex].Id);
                    }
                    secondGameDictionary.Add(userGames[1].GameList[secondIndex].Id, userGames[1].GameList[secondIndex]);
                    secondIndex++;
                    continue;
                }

                if (secondIndex >= userGames[1].GameList.Count)
                {
                    if (!sortedByRecentlyPlayed.Contains(userGames[0].GameList[firstIndex].Id))
                    {
                        sortedByRecentlyPlayed.Enqueue(userGames[0].GameList[firstIndex].Id);
                    }
                    firstGameDictionary.Add(userGames[0].GameList[firstIndex].Id, userGames[0].GameList[firstIndex]);
                    firstIndex++;
                    continue;
                }

                if (userGames[0].GameList[firstIndex].LastPlayed > userGames[1].GameList[secondIndex].LastPlayed)
                {
                    if (!sortedByRecentlyPlayed.Contains(userGames[0].GameList[firstIndex].Id))
                    {
                        sortedByRecentlyPlayed.Enqueue(userGames[0].GameList[firstIndex].Id);
                    }
                    firstGameDictionary.Add(userGames[0].GameList[firstIndex].Id, userGames[0].GameList[firstIndex]);
                    firstIndex++;
                }
                else
                {
                    if (!sortedByRecentlyPlayed.Contains(userGames[1].GameList[secondIndex].Id))
                    {
                        sortedByRecentlyPlayed.Enqueue(userGames[1].GameList[secondIndex].Id);
                    }
                    secondGameDictionary.Add(userGames[1].GameList[secondIndex].Id, userGames[1].GameList[secondIndex]);
                    secondIndex++;
                }
            }

            return sortedByRecentlyPlayed;
        }

        /// <summary>
        /// Returns a sorted list of recently played games for two gamers
        /// </summary>
        /// <param name="userGames">List of gamer's game list</param>
        private static uint SortGameList(List<UserGames> userGames)
        {
            Dictionary<uint, Contracts.GameInfo> firstGameDictionary = new Dictionary<uint, Contracts.GameInfo>();
            Dictionary<uint, Contracts.GameInfo> secondGameDictionary = new Dictionary<uint, Contracts.GameInfo>();
            Queue<uint> sortedByRecentlyPlayed = CreateSortedQueue(userGames, firstGameDictionary, secondGameDictionary);
            uint totalUniqueGames = (uint) sortedByRecentlyPlayed.Count;


            uint gameId;
            List<Contracts.GameInfo> firstList = new List<Contracts.GameInfo>();
            List<Contracts.GameInfo> secondList = new List<Contracts.GameInfo>();

            while (sortedByRecentlyPlayed.Count > 0)
            {
                gameId = sortedByRecentlyPlayed.Dequeue();

                if (firstGameDictionary.ContainsKey(gameId))
                {
                    firstList.Add(firstGameDictionary[gameId]);
                    firstGameDictionary.Remove(gameId);
                }
                else
                {
                    firstList.Add(new Contracts.GameInfo());
                }

                if (secondGameDictionary.ContainsKey(gameId))
                {
                    secondList.Add(secondGameDictionary[gameId]);
                    secondGameDictionary.Remove(gameId);
                }
                else
                {
                    secondList.Add(new Contracts.GameInfo());
                }
            }

            userGames[0].GameList = firstList;
            userGames[1].GameList = secondList;

            return totalUniqueGames;
        }

        /// <summary>
        /// Retrieves Gamerscore and TotalPossibleGamerscore based on the list of user titles
        /// </summary>
        /// <param name="userTitles">List of user titles</param>
        /// <param name="totalPossibleGamerscore">TotalPossibleGamerscore to be returned</param>
        /// <returns>Summation of the gamerscore</returns>
        private static uint GetGamerscores(List<IReadOnlyUserTitle> userTitles, out uint totalPossibleGamerscore)
        {
            uint gamerscore = 0;
            totalPossibleGamerscore = 0;
            if (userTitles != null)
            {
                foreach (Leet.Live.Livecache.Logic.Games.IReadOnlyUserTitle userTitle in userTitles)
                {
                    gamerscore += userTitle.EarnedGamerscore;
                    totalPossibleGamerscore += userTitle.TotalGamerscore;
                }
            }

            return gamerscore;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using xonline.common.config;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.Services.UserData.Partner")]
[assembly: ConfigAttribute("gds_uds-part")] // requires by ActiveAuth for event logging
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f4dd2817-1928-4fb0-b2af-548758e4866f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\UserDataUtility.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GameDataUtility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameDataUtility class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Net;
    using System.Text;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// GameDataUtility class
    /// </summary>
    public class UserDataUtility
    {
        /// <summary>
        /// Component Name
        /// </summary>
        public const string ComponentName = "UserDataPartnerService";


        /// <summary>
        /// Validates that the titleID in the authentication token is present in a white list of titleID's
        /// The white list is stored in NPDB
        /// </summary>
        /// <exception cref="UnAuthorizedAccessException">If validation fails</exception>
        public static void ValidateTitleID()
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            String titleIDwhiteList = configProvider.GetSetting(Settings.UdsPartnerTitleIDWhiteList); //get the white list from npdb

            if(!String.IsNullOrEmpty(titleIDwhiteList))
            {
                String[] whiteList = titleIDwhiteList.Split(new char[]{','});

                if (whiteList != null && whiteList.Length != 0)
                {
                    //we have a white list here
                    Object titleIDClaimValue = null;
                    UInt32 tokenTitleID = 0;

                    if (ServiceParameterValidator.TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.TitleIdClaimType, out titleIDClaimValue)
                        && UInt32.TryParse(titleIDClaimValue as String, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out tokenTitleID)) //we get the token titleID as UInt32 from the claims here
                    {
                        //validate against the white list 
                        UInt32 whiteListTitleID = 0;
                        for (Int32 count = 0; count < whiteList.Length; count++)
                        {
                            if (UInt32.TryParse(whiteList[count], System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out whiteListTitleID) &&   //titleID's will be in String. Parse it to UInt32
                                whiteListTitleID == tokenTitleID)
                            {
                                return;
                            }
                        }
                    }
                }
            }
            throw new UnauthorizedAccessException();
        }


        /// <summary>
        /// Retrieves header info from the http header and authenticates user
        /// </summary>
        /// <param name="currentUser">Current user</param>
        /// <param name="platformType">Platform type of the request</param>
        /// <param name="locale">Locale of the request</param>
        public static void GetUserHeaderInfo(out IUserIdentity currentUser, out string platformType, out string locale)
        {
            currentUser = null;
            try
            {
                // Authenticate and get current user
                currentUser = UserDataUtility.GetCallerIdentity();
                ServiceParameterValidator.ValidateXuid(currentUser.Xuid);
            }
            catch (ArgumentException argumentException)
            {
                HandleException("Can't fetch Xuid.", argumentException, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthenticationFailure);
            }
            catch (UnauthorizedAccessException accessException)
            {
                HandleException("Authentication failed.", accessException, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthenticationFailure);
            }

            // Fetch http headers
            locale = null;
            platformType = null;
            ServiceParameterValidator.FetchHeaders(out locale, out platformType);
            if (String.IsNullOrEmpty(locale))
            {
                RejectInput("GetUserHeaderInfo", UserDataPartnerEvents.ValidLocaleNotProvided, new ArgumentException("X-Locale is missing or invalid"), locale);
            }

            if (String.IsNullOrEmpty(platformType))
            {
                RejectInput("GetUserHeaderInfo", UserDataPartnerEvents.ValidPlatformTypeNotProvided, new ArgumentException("X-PlatformType is missing or invalid"), locale);
            }
        }

        /// <summary>
        /// Get the current user identity from the request context
        /// </summary>
        /// <returns>Current User Identity</returns>
        public static IUserIdentity GetCallerIdentity()
        {
            var authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                throw new UnauthorizedAccessException();
            }

            return authManager.CurrentUser;
        }

        /// <summary>
        /// Getting the Lcid from the locale
        /// </summary>
        /// <param name="locale">Locale to fetch the lcid</param>
        /// <returns>The Lcid found</returns>
        public static ushort GetLcid(string locale)
        {
            ushort lcid = 0;
            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
            lcid = localeHelper.GetLCID(locale);
            return lcid;
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client.
        /// </summary>
        /// <param name="message">Message included with exception that is thrown.</param>
        /// <param name="ex">The exception to be handled</param>
        /// <param name="httpStatusCode">The http status code returned to caller.</param>
        /// <param name="eventCode">Event code</param>
        public static void HandleException(string message, Exception ex, HttpStatusCode httpStatusCode, int eventCode)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                    UserDataPartnerEvents.Events,
                    eventCode,
                    httpStatusCode,
                    ex,
                    null,
                    ComposeExceptionDebugMessage(message, ex),
                    true);
            }

            le.ThrowWebProtocolException();
        }

        public static void RejectInput(string methodName, int errorCode, Exception ex, params string[] args)
        {
            LIVEnException le = ex as LIVEnException;

            if (le == null)
            {
                le = new LIVEnException(
                                UserDataPartnerEvents.Events,
                                errorCode,
                                HttpStatusCode.BadRequest,
                                ex,
                                methodName,
                                ComposeExceptionDebugMessage(methodName, ex),
                                true,
                                args);
            }

            le.ThrowWebProtocolException();
        }

        /// <summary>
        /// Composes debug message with exception's InnerException
        /// </summary>
        /// <param name="message">Message to be included</param>
        /// <param name="ex">The exception</param>
        /// <returns>Debug message</returns>
        public static string ComposeExceptionDebugMessage(string message, Exception ex)
        {
            StringBuilder sb = new StringBuilder(1024);

            if (!string.IsNullOrEmpty(message))
            {
                sb.AppendFormat(message);
            }

            if (ex != null)
            {
                sb.AppendFormat("\r\n Inner Exception: {0} \r\n", ex.ToString());
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\UdsPartAudienceUriProvider.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="GameDataAudienceUriProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameDataAudienceUriProvider class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace Gds.Services.UserData.Partner
{
    using System;
    using Leet.Identity;

    public class UdsPartAudienceUriProvider: IAudienceUriProvider
    {
        private string[] audienceUriList;
        public string[] AudienceUriList
        {
            get
            {
                if (audienceUriList == null)
                {
                    string audienceSetting = "http://xboxlive.com/userdata";
                    if (!String.IsNullOrEmpty(audienceSetting))
                    {
                        audienceUriList = audienceSetting.Split(',');
                    }
                }

                return audienceUriList;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\FriendAdapter.cs ===
﻿

namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic;
    using xonline.common.protocol;
    using xonline.common.service;

    public class FriendAdapter
    {
        public static void AddFriend(IUserIdentity currentUser, ulong targetXuid)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            presenceDataAccess.AddFriend(currentUser.Xuid, targetXuid);
        }

        public static bool AcceptFriend(IUserIdentity currentUser, ulong targetXuid)
        {
            uint[] lcPrivileges = null;
            byte lcParentalControlGroup;
            uint lcTier;
            DateTime lcLastActivity;
            bool lcIsLightAcct;
            bool lcIsProvisioned;
            byte lcAccountType;
            bool isFreeGamertagChangeEligible;
            bool isParentallyControlled;

            IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();
            acda.GetUserWebInfo(currentUser.Xuid, ServiceTypeEnum.XboxLive, out lcTier, out lcPrivileges,
                                out lcLastActivity, out lcParentalControlGroup, out lcIsLightAcct,
                                out lcIsProvisioned, out lcAccountType, out isFreeGamertagChangeEligible, out isParentallyControlled);

            if (LivePrivilegeSet.Test(lcPrivileges, XOn.XPRIVILEGE_ADD_FRIEND))
            {
                // Let LiveCache exceptions bubble up since they are handled up there
                IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
                presenceDataAccess.AcceptFriendRequest(currentUser.Xuid, targetXuid);
                return true;
            }
            else
            {
                return false;
            }
        }

        public static void DeclineFriendRequest(IUserIdentity currentUser, ulong targetXuid)
        {
            // Let LiveCache exceptions bubble up since they are handled up there
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            presenceDataAccess.RejectFriendRequest(currentUser.Xuid, targetXuid);

        }

        public static void RemoveFriend(IUserIdentity currentUser, ulong targetXuid)
        {
            // Let LiveCache exceptions bubble up since they are handled up there
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            presenceDataAccess.DeleteFriend(currentUser.Xuid, targetXuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner\Profile.svc.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Profile.svc.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  ProfilePartner
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner
{
    using System;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using Gds.Contracts;
    using Gds.Services.UserData.Partner.Library;
    using Leet.Identity;
    using Leet.UserGameData.DataContracts;
    using LIVEN.Common.Diagnostics;

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple,
                     InstanceContextMode = InstanceContextMode.Single)]
    public class ProfilePartner : IProfile
    {
        /// <summary>
        /// Component name
        /// </summary>
        private const string ComponentName = "Profile";

        public ProfileEx GetProfile(string sectionFlags, string friendsSectionFlags, string targetGamertag)
        {
            ulong sectFlags = 0;

            // Validate parameters
            if (string.IsNullOrEmpty(sectionFlags) || !ulong.TryParse(sectionFlags, out sectFlags))
            {
                UserDataUtility.HandleException("sectionFlags", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Both Friends and FriendsList cannot both be requested
            if (ProfileAdapter.FlagIsSet(sectFlags, ProfileSections.Friends) && ProfileAdapter.FlagIsSet(sectFlags, ProfileSections.FriendsList))
            {
                UserDataUtility.HandleException("sectionFlags", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ulong friendsSecflags = 0;
            if (!string.IsNullOrEmpty(friendsSectionFlags) && !ulong.TryParse(friendsSectionFlags, out friendsSecflags))
            {
                UserDataUtility.HandleException("friendsSectionFlags", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Bug 6858 - Calling GetProfile with both friendsSectionflags and gamertag should not succeed
            if (friendsSecflags != 0 && !String.IsNullOrEmpty(targetGamertag))
            {
                UserDataUtility.HandleException("friendsSectionFlags", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            // Bug 8520 - When sectionflags include “Friends”(4), only values allowed in FriendsSectionFlag are “XboxLiveproperties”(1) and “PresenceInfo”(32)
            if (ProfileAdapter.FlagIsSet(sectFlags, ProfileSections.Friends))
            {
                if (ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.Friends) ||
                    ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.PrivacySettings) ||
                    ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.RecentAchievements) ||
                    ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.RecentGames) ||
                    ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.WindowsLiveProperties) ||
                    ProfileAdapter.FlagIsSet(friendsSecflags, ProfileSections.AccountInformation))
                {
                    UserDataUtility.HandleException("friendsSectionFlags", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
                }
            }

            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            // Get LCID
            ushort lcid = 0;
            try
            {
                lcid = UserDataUtility.GetLcid(locale);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("X-Locale is invalid.", ex, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            ProfileEx profile = null;
            ulong targetXuid = 0;
            try
            {
                profile = ProfileAdapter.GetProfileEx(currentUser, locale, sectFlags, friendsSecflags, targetGamertag, out targetXuid);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error getting profile.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            if(!string.IsNullOrEmpty(targetGamertag) && targetXuid == 0)
            {
                UserDataUtility.HandleException("Gamertag does not exist.", null, HttpStatusCode.NotFound, UserDataPartnerEvents.GamertagDoesNotExist);
            }

            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");

            return profile;
        }

        public void UpdateProfile(ProfileEx profileEx)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }


            try
            {
                ProfileAdapter.UpdateProfile(currentUser, locale, profileEx);
            }
            catch (ArgumentException ae)
            {
                UserDataUtility.HandleException("ArgumentException", ae, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error updating profile.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            return;
        }

        public string[] ChangeGamertag(string gamertag)
        {
            string platformType = null;
            string locale = null;
            IUserIdentity currentUser = null;

            // Get current user and lcid
            UserDataUtility.GetUserHeaderInfo(out currentUser, out platformType, out locale);

            try
            {
                //Validate TitleID in the authentication token against a white list of title ID's
                UserDataUtility.ValidateTitleID();
            }
            catch (UnauthorizedAccessException ex)
            {
                UserDataUtility.HandleException("TitleID in the sts token is invalid.", ex, HttpStatusCode.Unauthorized, UserDataPartnerEvents.AuthorizationFailure);
            }

            string[] reservedName = null;
            ProfileAdapter.ChangeGamertagState state = ProfileAdapter.ChangeGamertagState.Succeeded;
            if (string.IsNullOrEmpty(gamertag))
            {
                UserDataUtility.HandleException("Gamertag cannot be null or empty.", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }

            try
            {
                reservedName = ProfileAdapter.ChangeGamertag(currentUser, gamertag, out state);
            }
            catch (ArgumentException ae)
            {
                UserDataUtility.HandleException("ArgumentException", ae, HttpStatusCode.BadRequest, UserDataPartnerEvents.InvalidArgument);
            }
            catch (Exception ex)
            {
                UserDataUtility.HandleException("Error changing gamertag.", ex, HttpStatusCode.InternalServerError, UserDataPartnerEvents.ApplicationError);
            }

            if (state == ProfileAdapter.ChangeGamertagState.Succeeded)
            {
                return reservedName;
            }
            else if (state == ProfileAdapter.ChangeGamertagState.NotEligible)
            {
                UserDataUtility.HandleException("NotEligible", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.ChangeGamertagNotEligible);
            }
            else if (state == ProfileAdapter.ChangeGamertagState.InvalidGamertagPattern)
            {
                UserDataUtility.HandleException("InvalidGamertagPattern", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.ChangeGamertagInvalidPattern);
            }
            else if (state == ProfileAdapter.ChangeGamertagState.GamertagNotAvailable)
            {
                return reservedName;
            }
            else if (state == ProfileAdapter.ChangeGamertagState.GamertagChangeError)
            {
                UserDataUtility.HandleException("GamertagChangeError", null, HttpStatusCode.BadRequest, UserDataPartnerEvents.ChangeGamertagError);
            }

            return reservedName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\PresenceProvider.cs ===
﻿
namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Identity;

    public class PresenceProvider
    {
        public static void UpdatePresence(ulong callerXuid, uint titleId)
        {
            var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            presenceDataAccess.SendWebAlive2(callerXuid, titleId);
        }

        public static bool IsTitleBlocked(uint tokenTitleID)
        {
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            String blockListString = configProvider.GetSetting(Settings.UdsPartnerUpdatePresenceTitleBlocklist); //get the block list from npdb
            if (!String.IsNullOrEmpty(blockListString))
            {
                String[] blockList = blockListString.Split(new char[] { ',' });

                //validate against the block list 
                UInt32 blockedTitleID = 0;
                for (Int32 count = 0; count < blockList.Length; count++)
                {
                    if (UInt32.TryParse(blockList[count], System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out blockedTitleID) &&   //titleID's will be in String. Parse it to UInt32
                        blockedTitleID == tokenTitleID)
                    {
                        //block list found
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\MessageAdapter.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="MessageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  MessageAdapter class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/16/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using System.Collections.Generic;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Messaging;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.UserGameData.DataContracts;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;
    using Microsoft.ServiceModel.Web;
    using Leet.Core.Diagnostics;

    public class MessageAdapter
    {
        /// <summary>
        /// The static Xcache access object. 
        /// </summary>
        private static ILcXCache DaXCache = new LcXCache();

        /// <summary>
        /// Enumerate all the message summaries. 
        /// </summary>
        /// <param name="userPuid">The livepuid of the requester. </param>
        /// <param name="hashCode">the optional hash code. </param>
        /// <returns>a message summary response object. </returns>
        public static Gds.Contracts.MessageSummariesResponse EnumerateMessages(ulong userPuid, string hashCode)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            MessageSummary2[] summaries = presenceDataAccess.EnumerateMessages(userPuid);
            
            //We are ignoring the hashCode for now. Will implement in later releases

            Gds.Contracts.MessageSummariesResponse response = new MessageSummariesResponse();
            response.Summaries = new List<Gds.Contracts.MessageSummary>();
            List<ulong> xuids = new List<ulong>();

            foreach (MessageSummary2 summary in summaries)
            {
                if (MessageShouldBeDisplayedOnLiveApp(summary))
                {
                    if (!xuids.Contains(summary.qwSenderID))
                    {
                        xuids.Add(summary.qwSenderID);
                    }
                }
            }
            ulong[] senderXuids = xuids.ToArray();

            // call GetGamerProfilesBySetting to retrieve profile settings        
            uint[] settings = new uint[1];
            settings[0] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY; //gamerTileURL, SmallGamerTileURL
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();

            // We don't need the gamerTag (false) in this call 
            Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfiles =
                settingsDataAccess.GetGamerProfilesBySetting(userPuid, senderXuids, settings, false);

            // Add to hash table for faster look up
            Dictionary<ulong, IGamerProfile> profiles = new Dictionary<ulong, IGamerProfile>();
            foreach(IGamerProfile gamerProfile in gamerProfiles)
            {
                if(!profiles.ContainsKey(gamerProfile.LivePuid))
                {
                    profiles.Add(gamerProfile.LivePuid, gamerProfile);
                }
            }

            foreach (MessageSummary2 summary in summaries)
            {
                if (MessageShouldBeDisplayedOnLiveApp(summary))
                {
                    Gds.Contracts.MessageSummary gdsSummary = CreateGdsMessageSummary(summary);
                    gdsSummary.SenderGamerPicUrl = profiles[summary.qwSenderID].GamerTileUrl;
                    response.Summaries.Add(gdsSummary);
                }
            }

            return response;
        }

        /// <summary>
        /// Get the message details of the given messageId. 
        /// </summary>
        /// <param name="userPuid">The xuid of the caller. </param>
        /// <param name="messageId">The messageId. </param>
        /// <param name="setReadFlag">Whether to set the read flag of the message. </param>
        /// <returns>Returns Gds.Contracts.MessageDetails. </returns>
        public static Gds.Contracts.MessageDetails GetMessageDetails(ulong userPuid, uint messageId, bool setReadFlag)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            IReadOnlyMessage message = presenceDataAccess.GetMessageDetails(userPuid, messageId, (setReadFlag ? MsgDefs.XONLINE_MSG_FLAG_READ : 0), 0);
            
            Gds.Contracts.MessageDetails messageDetails = new Gds.Contracts.MessageDetails();
            if (message != null)
            {
                messageDetails.MessageBody = message.Text;
                messageDetails.MessageId = message.Header.MessageId;
                messageDetails.SenderGamerTag = message.Header.SenderGamertag;
                messageDetails.SentTime = message.Header.SentTime;
                
            }
            
            return messageDetails;
        }

        /// <summary>
        /// Delete one message
        /// </summary>
        /// <param name="userPuid">The livepuid of the requster. </param>
        /// <param name="messageId">The id of the message to be deleted. </param>
        /// <param name="blockUser">Whether to block the user. </param>
        /// <returns>the status of the operation. </returns>
        public static bool DeleteMessage(ulong userPuid, uint messageId, bool blockUser)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            return presenceDataAccess.DeleteMessage(userPuid, messageId, (blockUser ? MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER : 0));
        }

        /// <summary>
        /// Send a personal text message. 
        /// </summary>
        /// <param name="userPuid">The livepuid of the sender. </param>
        /// <param name="senderGamertag">The gamertag of the sender. </param>
        /// <param name="sendRequest">The gds.contracts send message request. </param>
        public static void SendMessage(ulong userPuid, string senderGamertag, SendMessageRequest sendRequest)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            ulong[] recipients = GetRecipientLivePuids(sendRequest.Recipients);

            if (recipients == null || recipients.Length == 0)
            {
                //In this case we are not able to get Live PUIDs for the gamertags and so the gamertags are invalid. We will return a bad request
                throw new WebProtocolException(System.Net.HttpStatusCode.BadRequest, "SendMessageRequest contains invalid recipients", null);
            }

            // first create an xonline message details. set the property to text. and set flags
            xonline.common.protocol.MessageDetails details = new xonline.common.protocol.MessageDetails();
            CMessage cMessage = new CMessage();
            uint flags = 0;
            if (!string.IsNullOrEmpty(sendRequest.MessageText))
            {
                cMessage.AddProperty(MsgDefs.XONLINE_MSG_PROP_TEXT, sendRequest.MessageText);
                flags |= MsgDefs.XONLINE_MSG_FLAG_HAS_TEXT;
            }
            cMessage.SetDetails(ref details);

            //43200 is 30 days in minutes 30*24*60
            ushort timeout = 43200;

            presenceDataAccess.SendMessage(userPuid,
                senderGamertag,
                0,
                flags,
                timeout,
                (byte)MessageTypeEnum.PersonalMessage,
                recipients,
                details);
        }

        /// <summary>
        /// Flag the message as been read. 
        /// </summary>
        /// <param name="userPuid">The livepuid of the request. </param>
        /// <param name="messageId">The message id. </param>
        /// <returns>status of the operation. </returns>
        public static bool FlagMessageAsRead(ulong userPuid, uint messageId)
        {
            IPresenceDataAccess presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            return presenceDataAccess.SetMessageFlags(userPuid, messageId, MsgDefs.XONLINE_MSG_FLAG_READ, 0);
        }

        /// <summary>
        /// TODO: extend this method for specific platform types. 
        /// This method filters the messages that should be displayed on the liveapp. 
        /// </summary>
        /// <param name="summary">The summary of the message. </param>
        /// <returns>True of false that this message should be displayed on the live app. </returns>
        private static bool MessageShouldBeDisplayedOnLiveApp(MessageSummary2 summary)
        {
            MessageTypeEnum messageType = (MessageTypeEnum)summary.bMessageType;
            // if the message is allowed to display on web and not the fllowing types and not from Zune
            if ((summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE) == 0
                && messageType != MessageTypeEnum.LiveMessage
                && messageType != MessageTypeEnum.CompetitionReminder
                && messageType != MessageTypeEnum.CompetitionRequest
                && messageType != MessageTypeEnum.TeamRecruit
                && summary.dwSenderTitleID != XOn.ZUNE_TITLE_ID
                )
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// A helper method to create Gds.Contract.MessageSummary from internal MessageSummary2 object. 
        /// The reason we didn't put this in the constructor is to avoid exposing livecache specific MessageSummary2 in the contract. 
        /// </summary>
        /// <param name="summary">The summary returned from Live Cache. </param>
        /// <returns>A new wrapped Gds.Contracts.MessageSummary object. </returns>
        private static Gds.Contracts.MessageSummary CreateGdsMessageSummary(MessageSummary2 summary)
        {
            Gds.Contracts.MessageSummary gdsSummary = new Gds.Contracts.MessageSummary();

            // set the necessary properties. 
            gdsSummary.MessageId = summary.dwMessageID;
            gdsSummary.MessageType = summary.bMessageType;
            gdsSummary.SenderGamertag = summary.szSenderName;
            gdsSummary.SenderTitleId = summary.dwSenderTitleID;
            gdsSummary.SentTime = MsgDefs.MsgTimeToDateTime(summary.mtSentTime);
            gdsSummary.Subject = summary.szSubject;

            // set the flags. 
            gdsSummary.HasImage = (summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_PHOTO) > 0;
            gdsSummary.HasVoice = (summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_VOICE) > 0;
            gdsSummary.HasText = (summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_TEXT) > 0;
            gdsSummary.HasBeenRead = (summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_READ) > 0;
            gdsSummary.IsFromFriend = (summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND) > 0;

            // set if the message can be deleted. 
            gdsSummary.CanDelete = (gdsSummary.MessageType == (uint)MessageTypeEnum.PersonalMessage) ||
                                   (gdsSummary.MessageType == (uint)MessageTypeEnum.TitleCustom) ||
                                   (gdsSummary.MessageType == (uint)MessageTypeEnum.VideoMessage);

            // set if the message can set read flag. 
            gdsSummary.CanSetReadFlag = !(gdsSummary.MessageType == (uint)MessageTypeEnum.TitleCustom ||
                    gdsSummary.MessageType == (uint)MessageTypeEnum.GameInvite ||
                    gdsSummary.MessageType == (uint)MessageTypeEnum.VideoMessage ||
                    gdsSummary.MessageType == (uint)MessageTypeEnum.QuickChatInvite ||
                    gdsSummary.MessageType == (uint)MessageTypeEnum.VideoChatInvite ||
                    gdsSummary.HasImage ||
                    gdsSummary.HasVoice);

            return gdsSummary;
        }

        /// <summary>
        /// A helper method to convert the input gamertags to livepuids. This is used for calling send message. 
        /// </summary>
        /// <param name="recipientsGamerTags">The list of gamertags for recipients</param>
        /// <returns>an array of livepuids of valid gamertags. </returns>
        private static ulong[] GetRecipientLivePuids(List<string> recipientsGamerTags)
        {
            List<ulong> livePuids = new List<ulong>();
            ulong livePuid;
            foreach (string gamerTag in recipientsGamerTags)
            {
                try
                {
                    if (DaXCache.GetPuidByGamerTag(gamerTag, out livePuid))
                    {
                        livePuids.Add(livePuid);
                    }
                    else
                    {
                        Logging.TraceWarning("gds_uds_part: GetRecipientLivePuids failed for gamertag: {0}", gamerTag); 
                    }
                }
                catch
                {
                }
            }

            // TODO: need to limit the number of recipients to MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS;
            return livePuids.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\ProfileProvider.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="ProfileProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  ProfileProvider class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/26/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.UserGameData.DataContracts;

    public class ProfileProvider
    {
        public static ProfileEx GetProfile(IUserIdentity callerIdentity, ushort lcid, string gamertag, ulong sectionFlags, ulong friendsSectionFlags)
        {
            ProfileEx profileEx = new ProfileEx();
            PopulateProfile(profileEx, callerIdentity, lcid, sectionFlags, gamertag, friendsSectionFlags);
            return profileEx;
        }

        /// <summary>
        /// Populates profile
        /// </summary>
        /// <param name="profile">Profile to be poulated</param>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="lcid">Locale of the strings</param>
        /// <param name="gamertag">Gamertag of friend</param>
        /// <param name="sectionFlags">Specifies which profile sections to return</param>
        /// <param name="friendsSectionFlags">Section flag of friend(s)</param>
        private static void PopulateProfile(
            ProfileEx profile,
            IUserIdentity callerIdentity,
            ushort lcid,
            ulong sectionFlags,
            string gamertag,
            ulong friendsSectionFlags)
        {
            profile.SectionFlags = (long)sectionFlags;

            if (FlagIsSet(sectionFlags, ProfileSections.XboxLiveProperties))
            {
                profile.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();

                profile.ProfileProperties.Add(ProfileProperty.GamerTag, "RewardsHead");
                profile.ProfileProperties.Add(ProfileProperty.GamerScore, 123);
                profile.ProfileProperties.Add(ProfileProperty.HasAvatar, false);
                profile.ProfileProperties.Add(ProfileProperty.AvatarImageUrl, "http://avatar.storax.xboxlive.com/avatar/RewardsHead/avatar-body.png");
                profile.ProfileProperties.Add(ProfileProperty.Bio, "some bio");
                profile.ProfileProperties.Add(ProfileProperty.GamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/2000c");
                profile.ProfileProperties.Add(ProfileProperty.SmallGamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/1000c");
                profile.ProfileProperties.Add(ProfileProperty.Location, "seattle");
                profile.ProfileProperties.Add(ProfileProperty.Motto, "i'm the best!");
                profile.ProfileProperties.Add(ProfileProperty.Name, "poohbear");
                profile.ProfileProperties.Add(ProfileProperty.MembershipLevel, GamerTier.Gold.ToString());
                profile.ProfileProperties.Add(ProfileProperty.GamerZone, GamercardZone.Pro.ToString());
                profile.ProfileProperties.Add(ProfileProperty.Reputation, 54.23);
            }

            if (FlagIsSet(sectionFlags, ProfileSections.WindowsLiveProperties))
            {
                throw new NotSupportedException("ProfileSections.WindowsLiveProperties section flag is not supported.");
            }

            if (FlagIsSet(sectionFlags, ProfileSections.Friends))
            {
                profile.Friends = new XmlSerializableList<Profile>();
                profile.Friends.Add(GetFriend(gamertag, friendsSectionFlags));
            }

            if (FlagIsSet(sectionFlags, ProfileSections.RecentGames))
            {
                profile.RecentGames = new XmlSerializableList<Leet.UserGameData.DataContracts.GameInfo>();
                Leet.UserGameData.DataContracts.GameInfo gameInfo = new Leet.UserGameData.DataContracts.GameInfo
                {
                    AchievementsEarned = 18,
                    GameUrl = "http://redirect.storax.xboxlive.com/g/1297287391/0/",
                    Id = 12131231,
                    ImageUrl =
                        "http://zone.msn.com/images/v9/en-us/game/test/AppTesting/AppIconHexic_64x64.png",
                    LastPlayed = DateTime.Now,
                    Name = "Hexic rush",
                    TotalAchievements = 20,
                    Type = 0
                };
                profile.RecentGames.Add(gameInfo);
            }

            if (FlagIsSet(sectionFlags, ProfileSections.RecentAchievements))
            {
                profile.RecentAchievements = new XmlSerializableList<Achievement>();
                Achievement achievement = new Achievement
                {
                    Description = "some game",
                    DisplayBeforeEarned = true,
                    EarnedDateTime = DateTime.Now,
                    EarnedOnline = true,
                    GameName = "Hexic Rush",
                    Gamerscore = 5,
                    HowToEarn = "asf",
                    IsEarned = true,
                    Key = "19",
                    GameId = 123213,
                    PictureUrl =
                        "http://tiles.test.xbox.com/tiles/xy/Q5/0YCLiGJhbC9GCxt0GltTWURGL2FjaC8wLzEyAAAAAOfn5-4WJNs=.jpg"
                };
                profile.RecentAchievements.Add(achievement);
            }

            if (FlagIsSet(sectionFlags, ProfileSections.PresenceInfo))
            {
                profile.PresenceInfo = GetPresence(callerIdentity.Xuid, callerIdentity.Xuid, lcid);
            }

            if (FlagIsSet(sectionFlags, ProfileSections.PrivacySettings))
            {
                profile.PrivacySettings = new XmlSerializableDictionary<PrivacySetting, uint>();
                profile.PrivacySettings.Add(PrivacySetting.VoiceAndText, 0);
                profile.PrivacySettings.Add(PrivacySetting.Voice, 0);
                profile.PrivacySettings.Add(PrivacySetting.GamerProfile, 1);
                profile.PrivacySettings.Add(PrivacySetting.OnlineStatus, 2);
                profile.PrivacySettings.Add(PrivacySetting.MemberContent, 1);
                profile.PrivacySettings.Add(PrivacySetting.PlayedGames, 0);
                profile.PrivacySettings.Add(PrivacySetting.FriendsList, 1);
            }
        }

        private static Presence GetPresence(ulong callerXuid, ulong targetXuid, ushort lcid)
        {
            var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            IReadOnlyPresenceInfo presenceInfo = presenceDataAccess.GetPresenceInfo(callerXuid, targetXuid);

            var stringServerDataAccess = Container.Instance.GetComponent<IStringServerDataAccess>();
            DateTime cacheTTL;
            string titleName = stringServerDataAccess.LookupString(presenceInfo.TitleId, 0, lcid, out cacheTTL);

            Presence presence = new Presence
                                    {
                                        DetailedPresence = presenceInfo.PresenceString,
                                        LastSeenDateTime = presenceInfo.LastSeen,
                                        LastSeenTitleId = presenceInfo.TitleId,
                                        LastSeenTitleName = titleName,
                                        OnlineState = (uint) presenceInfo.State
                                    };

            return presence;
        }

        /// <summary>
        /// Determines if the specified bit is set in the provided bitmap
        /// </summary>
        /// <param name="bitMap">Selects which section to be included</param>
        /// <param name="section">Profile section</param>
        /// <returns>Whether to flag is set</returns>
        private static bool FlagIsSet(ulong bitMap, ProfileSections section)
        {
            bool flagIsSet =
                (bitMap & ((ulong)section)) != 0;

            return flagIsSet;
        }

        private static ProfileEx GetFriend(string gamertag, ulong friendsectionflag)
        {
            ProfileEx profile = new ProfileEx();

            if (FlagIsSet(friendsectionflag, ProfileSections.XboxLiveProperties))
            {
                profile.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();

                profile.ProfileProperties.Add(ProfileProperty.GamerTag, gamertag);
                profile.ProfileProperties.Add(ProfileProperty.GamerScore, 123);
                profile.ProfileProperties.Add(ProfileProperty.HasAvatar, false);
                profile.ProfileProperties.Add(ProfileProperty.AvatarImageUrl, "http://avatar.storax.xboxlive.com/avatar/RewardsHead/avatar-body.png");
                profile.ProfileProperties.Add(ProfileProperty.Bio, "some bio");
                profile.ProfileProperties.Add(ProfileProperty.GamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/2000c");
                profile.ProfileProperties.Add(ProfileProperty.SmallGamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/1000c");
                profile.ProfileProperties.Add(ProfileProperty.Location, "seattle");
                profile.ProfileProperties.Add(ProfileProperty.Motto, "i'm the best!");
                profile.ProfileProperties.Add(ProfileProperty.Name, "poohbear");
                profile.ProfileProperties.Add(ProfileProperty.MembershipLevel, GamerTier.Gold.ToString());
                profile.ProfileProperties.Add(ProfileProperty.GamerZone, GamercardZone.Pro.ToString());
                profile.ProfileProperties.Add(ProfileProperty.Reputation, 54.23);
            }

            if (FlagIsSet(friendsectionflag, ProfileSections.RecentGames))
            {
                profile.RecentGames = new XmlSerializableList<Leet.UserGameData.DataContracts.GameInfo>();
                Leet.UserGameData.DataContracts.GameInfo gameInfo = new Leet.UserGameData.DataContracts.GameInfo
                {
                    AchievementsEarned = 18,
                    GameUrl = "http://redirect.storax.xboxlive.com/g/1297287391/0/",
                    Id = 12131231,
                    ImageUrl =
                        "http://zone.msn.com/images/v9/en-us/game/test/AppTesting/AppIconHexic_64x64.png",
                    LastPlayed = DateTime.Now,
                    Name = "Hexic rush",
                    TotalAchievements = 20,
                    Type = 0
                };
                profile.RecentGames.Add(gameInfo);
            }

            if (FlagIsSet(friendsectionflag, ProfileSections.RecentAchievements))
            {
                profile.RecentAchievements = new XmlSerializableList<Achievement>();
                Achievement achievement = new Achievement
                {
                    Description = "some game",
                    DisplayBeforeEarned = true,
                    EarnedDateTime = DateTime.Now,
                    EarnedOnline = true,
                    GameName = "Hexic Rush",
                    Gamerscore = 5,
                    HowToEarn = "asf",
                    IsEarned = true,
                    Key = "19",
                    GameId = 123213,
                    PictureUrl =
                        "http://tiles.test.xbox.com/tiles/xy/Q5/0YCLiGJhbC9GCxt0GltTWURGL2FjaC8wLzEyAAAAAOfn5-4WJNs=.jpg"
                };
                profile.RecentAchievements.Add(achievement);
            }

            return profile;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.Services.UserData.Partner.Library")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("dd601aa7-04fe-4666-bc19-dcdd3827fb1e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\GetAchievementsTests.cs ===
﻿
namespace Gds.Services.UserData.Partner.Tests
{
    using GameMetadata.Client;
    using Gds.Contracts;
    using Gds.Mocks;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;
    using Microsoft.VisualStudio.TestTools.UnitTesting;

    /// <summary>
    /// Summary description for GetAchievementsTests
    /// </summary>
    [TestClass]
    public class GetAchievementsTests
    {
        public GetAchievementsTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //

        [TestInitialize()]
        public void Initialize()
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>()
            ;

            Container.Instance.AddService<IXCacheDataAccess, FakeXCache>();
            Container.Instance.AddService<IAchievementDataAccess, TestAchievementDataAccess>();
            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();
            UserDataPartnerEvents.Initialize("gds_udspart");
        }

        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void GetAchievementsValid()
        {
            // Arrange
            string gamertag = "rewardstest";
            string gameId = "54321";

            // Act
            GameData gameData = new GameData();
            Achievements achievements = gameData.GetAchievements(gameId, gamertag);

            // Assert
            Assert.AreEqual(1, achievements.UserAchievementsCollection.Count);
            Assert.AreEqual(1, achievements.UserAchievementsCollection[0].AchievementList.Count);
        }

        [TestMethod]
        public void GetTwoGamerAchievementsValid()
        {
            // Arrange
            string gamertag = "rewardstest,rewardsplay1";
            string gameId = "54321";

            // Act
            GameData gameData = new GameData();
            Achievements achievements = gameData.GetAchievements(gameId, gamertag);

            // Assert
            Assert.AreEqual(2, achievements.UserAchievementsCollection.Count);
            Assert.AreEqual(1, achievements.UserAchievementsCollection[0].AchievementList.Count);
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GetAchievementsInvalidGameId()
        {
            string gamertag = "rewardstest,rewardsplay1";
            string gameId = "asdf";

            // Act
            GameData gameData = new GameData();
            Achievements achievements = gameData.GetAchievements(gameId, gamertag);

            // Assert
            // Exception is thrown for invalid game id
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GetAchievementsInvalidNumberGamertags()
        {
            string gamertag = "rewardstest,rewardsplay1,rewardsplay2,rewardplay3,rewardsplay4";
            string gameId = "54321";

            // Act
            GameData gameData = new GameData();
            Achievements achievements = gameData.GetAchievements(gameId, gamertag);

            // Assert
            // Exception is thrown for exceeding number of gamertags
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GetAchievementsNullGamertags()
        {
            string gamertag = "";
            string gameId = "54321";

            // Act
            GameData gameData = new GameData();
            Achievements achievements = gameData.GetAchievements(gameId, gamertag);

            // Assert
            // Exception is thrown for no gamertags
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Library\ProfileAdapter.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="ProfileAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="schau">
//     Stacey Chau
// </author>
//
// <summary>
//  GameDataPartnerAdapter class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/7/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace Gds.Services.UserData.Partner.Library
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.RegularExpressions;
    using Gds.Contracts;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Account;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic;
    using Leet.Live.Livecache.Logic.Games;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Live.Livecache.Providers;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.offer;
    using xonline.common.webplatform.livecache;
    
    /// <summary>
    /// ProfileAdapter class
    /// </summary>
    public class ProfileAdapter
    {
        /// <summary>
        /// No game rating restriction const
        /// </summary>
        private const int NoGameRatingRestriction = 0x3F00;

        /// <summary>
        /// Free gamertag change offer Id
        /// </summary>
        private const ulong FreeGamertagChangeOfferId = 0xFFFE07D10AA00002;

        /// <summary>
        /// gamertag format.
        /// </summary>
        private static Regex gamerTagPattern = new Regex(@"^[A-Za-z](?:[A-Za-z0-9]|\ (?!\ |$)){0,14}$", RegexOptions.Compiled);

        /// <summary>
        /// Retriever user's profile information based on section flags
        /// </summary>
        /// <param name="currentUser">Current user</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">Sections to be returned</param>
        /// <param name="friendsSectionFlags">Friends sections to be returned</param>
        /// <param name="targetGamertag">Gamertag of profile to be retrieved</param>
        /// <param name="targetXuid">Target xuid</param>
        /// <returns>ProfileEx object</returns>
        public static ProfileEx GetProfileEx(IUserIdentity currentUser, string locale, ulong sectionFlags, ulong friendsSectionFlags, string targetGamertag, out ulong targetXuid)
        {
            IProfileProvider profileProvider = Container.Instance.GetComponent<IProfileProvider>();

            bool partialResult = false;
            Profile profile;
            Identity targetIdentity = null;
            IReadOnlyFriendInfo[] friendsListInfo = null;
            XmlSerializableList<Profile> friendsEx = null;
            targetXuid = 0;

            if (string.IsNullOrEmpty(targetGamertag))
            {
                profile = profileProvider.GetProfile(currentUser, locale, (long)sectionFlags, out friendsListInfo, out partialResult);
            }
            else
            {
                profile = profileProvider.GetProfile(currentUser, targetGamertag, locale, (long)sectionFlags, out friendsListInfo, out partialResult, out targetIdentity);
                targetXuid = targetIdentity.Xuid;
                if(targetXuid == 0)
                {
                    return null;
                }
            }

            if (FlagIsSet((ulong)sectionFlags, ProfileSections.FriendsList))
            {
                if (string.IsNullOrEmpty(targetGamertag))
                {
                    friendsEx = ProfileProvider.GetXboxEntireFriendsList(currentUser, currentUser.Xuid, false, out friendsListInfo, ref partialResult);
                }
            }

            ProfileEx profileEx = GetProfile(profile, friendsEx);
            PopulateProfile(
                profileEx,
                currentUser,
                targetIdentity,
                locale,
                sectionFlags,
                targetGamertag,
                friendsSectionFlags,
                friendsListInfo);

            return profileEx;
        }

        public static void UpdateProfile(IUserIdentity currentUser, string locale, ProfileEx profileEx)
        {
            if (FlagIsSet((ulong)profileEx.SectionFlags, ProfileSections.XboxLiveProperties) && profileEx.ProfileProperties != null)
            {
                UpdateXboxLiveProperties(profileEx.ProfileProperties, locale, currentUser.Xuid);
            }

            if (FlagIsSet((ulong)profileEx.SectionFlags, ProfileSections.PrivacySettings) && profileEx.PrivacySettings != null)
            {
                UpdatePrivacySettings(profileEx.PrivacySettings, currentUser.Xuid, currentUser.Gamertag, locale);
            }

            return;
        }

        public static string[] ChangeGamertag(IUserIdentity currentUser, string newGamertag, out ChangeGamertagState changeGamertagState)
        {
            string[] reservedNames = null;
            if(IsFreeGamertagChangeEligible(currentUser.Xuid))
            {
                if (IsGamertagPatternValid(newGamertag))
                {
                    ulong machinePuid = GetRandomWM7MachineUid();

                    var accountCreationDataAccess = Container.Instance.GetComponent<IAccountCreationDataAccess>();
                    Account account = accountCreationDataAccess.GetAccount(currentUser.Xuid);

                    ReserveNameSuggestedName[] reserveNameSuggestedNames = accountCreationDataAccess.ReserveGamerTag(machinePuid, account.CountryId, newGamertag);

                    if (reserveNameSuggestedNames == null || reserveNameSuggestedNames.Length == 0)
                    {
                        // Enumerate the free offer
                        IBillingOfferingDataAccess billingOfferingDataAccess = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                        ContentEnumerateRequest request = new ContentEnumerateRequest();

                        request.userPuid = account.Xuid;
                        request.countryID = (byte)account.CountryId;
                        request.languageID = account.LanguageId;
                        request.gameRating = NoGameRatingRestriction;
                        request.offerType = (uint)OfferingTypeEnum.GamertagChange;
                        request.paymentType = (uint)PaymentTypeEnum.Points;
                        request.tierRequired = (byte)account.Tier;
                        request.titleID = XOn.XENON_DASH_TITLE_ID;
                        request.titleCategories = UInt32.MaxValue;
                        request.genreID = 0;
                        request.startingIndex = 0;
                        request.maxResults = 99;

                        ContentEnumerateResponse response = billingOfferingDataAccess.EnumerateContent(request);

                        if(response.offersReturned == 1 && response.offersTotal == 1 && response.infos[0].offerID == FreeGamertagChangeOfferId)
                        {

                            DefaultLivecacheLocaleProvider.countryId = (uint)account.CountryId;
                            DefaultLivecacheLocaleProvider.langId = account.LanguageId;

                            XeOfferPurchaseGamertagRequest req = new XeOfferPurchaseGamertagRequest();
                            req.userPuid = account.Xuid;
                            req.gamertag = newGamertag;
                            req.languageID = account.LanguageId;
                            req.countryID = (byte)account.CountryId;
                            req.machinePuid = machinePuid;
                            req.offerID = FreeGamertagChangeOfferId;
                            req.tier = (byte)account.Tier;
                            req.paymentType = (uint)PaymentTypeEnum.Points;

                            uint hr = billingOfferingDataAccess.PurchaseGamertag(req);
                            if (hr != 0)
                            {
                                // Log error
                                changeGamertagState = ChangeGamertagState.GamertagChangeError;
                            }
                            else
                            {
                                changeGamertagState = ChangeGamertagState.Succeeded;
                            }
                        }
                        else
                        {
                            changeGamertagState = ChangeGamertagState.GamertagChangeError;
                        }
                    }
                    else
                    {
                        reservedNames = new string[reserveNameSuggestedNames.Length];
                        for (int i = 0; i < reserveNameSuggestedNames.Length; i++ )
                        {
                            reservedNames[i] = reserveNameSuggestedNames[i].name;
                        }
                        changeGamertagState = ChangeGamertagState.GamertagNotAvailable;
                    }
                }
                else
                {
                    changeGamertagState = ChangeGamertagState.InvalidGamertagPattern;
                }
            }
            else
            {
                changeGamertagState = ChangeGamertagState.NotEligible;
            }
            return reservedNames;
        }

        public enum ChangeGamertagState
        {
            Succeeded,
            NotEligible,
            InvalidGamertagPattern,
            GamertagNotAvailable,
            GamertagChangeError
        }

        #region ChangeGamertag

        /// <summary>
        /// Check the if the gamertag is valid. this function is mostly duplicate of xonline.common.user.NameUtil.VerifyGamerTag
        /// </summary>
        /// <param name="name">gamertag to check</param>
        /// <returns>true if the gamertag is valid, false if invalid</returns>
        private static bool IsGamertagPatternValid(string name)
        {
            return (name != null) && gamerTagPattern.IsMatch(name);
        }

        /// <summary>
        /// Create a random mchine id with the format 0xfc00000000000000
        /// </summary>
        /// <returns>a random mchine id</returns>
        private static ulong GetRandomWM7MachineUid()
        {
            return GetRandomULong() & 0x0000ffffffffffff | 0xfc00000000000000;
        }

        /// <summary>
        /// Create a random ulong
        /// </summary>
        /// <returns> value of a random ulong</returns>
        private static ulong GetRandomULong()
        {
            Random rnd = new Random();
            int i = rnd.Next();
            int j = rnd.Next();
            return (((ulong)i) << 32) + (ulong)j;
        }

        /// <summary>
        /// check if the current login user is eligible for the free gamertag change offer
        /// </summary>
        /// <param name="xuid">xuid of the user</param>
        /// <returns>true if the user is eligible for the free offer, otherwise false</returns>
        private static bool IsFreeGamertagChangeEligible(ulong xuid)
        {
            uint[] privileges = null;
            byte parentalControlGroup;
            uint tier = 0;
            DateTime lastActivity;
            bool isLightAcct;
            bool isProvisioned;
            byte accountType;
            bool isFreeGamertagChangeEligible;
            bool isParentallyControlled;

            IAccountCreationDataAccess accountCreationAccess = Container.Instance.GetComponent<IAccountCreationDataAccess>();
            accountCreationAccess.GetUserWebInfo(xuid, ServiceTypeEnum.XboxLive, out tier, out privileges, out lastActivity, out parentalControlGroup, out isLightAcct, out isProvisioned, out accountType, out isFreeGamertagChangeEligible, out isParentallyControlled);

            return isFreeGamertagChangeEligible;
        }

        #endregion ChangeGamertag

        private static ProfileEx GetProfile(Profile profile, XmlSerializableList<Profile> friendsExList)
        {
            ProfileEx profileEx = new ProfileEx
                                      {
                                          ProfileProperties = profile.ProfileProperties,
                                          RecentAchievements = profile.RecentAchievements,
                                          RecentGames = profile.RecentGames
                                      };

            if(profile.Friends != null)
            {
                profileEx.Friends = new XmlSerializableList<ProfileEx>();
                foreach(var friend in profile.Friends)
                {
                    ProfileEx friendProfile = new ProfileEx
                                                  {
                                                      ProfileProperties = friend.ProfileProperties
                                                  };
                    profileEx.Friends.Add(friendProfile);
                }
            }

            if(friendsExList != null)
            {
                profileEx.FriendList = new XmlSerializableList<Friend>();
                foreach (var friend in friendsExList)
                {
                    Friend fd = new Friend();
                    fd.ProfileEx = new ProfileEx
                    {
                        ProfileProperties = friend.ProfileProperties
                    };
                    profileEx.FriendList.Add(fd);
                }                
            }

            return profileEx;
        }

        /// <summary>
        /// Populates profile
        /// </summary>
        /// <param name="profile">Profile to be poulated</param>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetIdentity">Target's identity</param>
        /// <param name="locale">Locale of the strings</param>
        /// <param name="targetGamertag">Gamertag of friend</param>
        /// <param name="sectionFlags">Specifies which profile sections to return</param>
        /// <param name="friendsSectionFlags">Section flag of friend(s)</param>
        private static void PopulateProfile(
            ProfileEx profile,
            IUserIdentity callerIdentity,
            Identity targetIdentity,
            string locale,
            ulong sectionFlags,
            string targetGamertag,
            ulong friendsSectionFlags,
            IReadOnlyFriendInfo[] friendsInfoList)
        {
            profile.SectionFlags = (long)sectionFlags;

            uint[] lcPrivileges = null;
            byte lcParentalControlGroup;
            uint lcTier;
            DateTime lcLastActivity;
            bool lcIsLightAcct;
            bool lcIsProvisioned;
            byte lcAccountType;
            bool isFreeGamertagChangeEligible;
            bool isParentallyControlled;

            if (FlagIsSet(sectionFlags, ProfileSections.XboxLiveProperties) )
            {
                if (string.IsNullOrEmpty(targetGamertag))
                {
                    IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();
                    acda.GetUserWebInfo(callerIdentity.Xuid, ServiceTypeEnum.XboxLive, out lcTier, out lcPrivileges,
                                        out lcLastActivity, out lcParentalControlGroup, out lcIsLightAcct,
                                        out lcIsProvisioned, out lcAccountType, out isFreeGamertagChangeEligible, out isParentallyControlled);

                    profile.ProfileProperties.Add(
                        Leet.UserGameData.DataContracts.ProfileProperty.FreeGamertagChangeEligible,
                        isFreeGamertagChangeEligible);
                    profile.ProfileProperties.Add(Leet.UserGameData.DataContracts.ProfileProperty.ParentalControlGroup,
                                                  lcParentalControlGroup);
                    profile.ProfileProperties.Add(Leet.UserGameData.DataContracts.ProfileProperty.IsParentallyControlled,
                                                  isParentallyControlled);
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.WindowsLiveProperties))
            {
                throw new NotSupportedException("ProfileSections.WindowsLiveProperties section flag is not supported.");
            }

            if (FlagIsSet(sectionFlags, ProfileSections.Friends))
            {
                IReadOnlyFriendInfo friendInfo = null;
                foreach (ProfileEx friend in profile.Friends)
                {
                    if (friendsInfoList != null)
                    {
                        for (int i = 0; i < friendsInfoList.Count(); i++)
                        {
                            if (string.Compare(friendsInfoList[i].Gamertag, (string)friend.ProfileProperties[Leet.UserGameData.DataContracts.ProfileProperty.GamerTag], true) == 0)
                            {
                                friendInfo = friendsInfoList[i];
                                break;
                            }
                        }
                    }

                    PopulateFriendProfile(friend, callerIdentity, locale, friendsSectionFlags, friendInfo);
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.PresenceInfo))
            {
                ushort lcid = GetLcid(locale);
                if (string.IsNullOrEmpty(targetGamertag))
                {
                    profile.PresenceInfo = GetPresence(callerIdentity.Xuid, callerIdentity.Xuid, lcid);
                }
                else if (targetIdentity.Xuid != 0)
                {
                    profile.PresenceInfo = GetPresence(callerIdentity.Xuid, targetIdentity.Xuid, lcid);
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.PrivacySettings))
            {
                if (string.IsNullOrEmpty(targetGamertag))
                {
                    if (lcPrivileges == null)
                    {
                        IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();
                        acda.GetUserWebInfo(callerIdentity.Xuid, ServiceTypeEnum.XboxLive, out lcTier, out lcPrivileges, out lcLastActivity, out lcParentalControlGroup, out lcIsLightAcct, out lcIsProvisioned, out lcAccountType, out isFreeGamertagChangeEligible, out isParentallyControlled);
                    }

                    profile.PrivacySettings = GetPrivacySettings(callerIdentity.Xuid, lcPrivileges);
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.FriendsList))
            {
                IReadOnlyFriendInfo friendInfo = null;
                if (profile.FriendList == null || !string.IsNullOrEmpty(targetGamertag))
                {
                    return;
                }

                foreach (Friend friend in profile.FriendList)
                {
                    if (friendsInfoList != null)
                    {
                        for (int i = 0; i < friendsInfoList.Count(); i++)
                        {
                            if (string.Compare(friendsInfoList[i].Gamertag, (string)friend.ProfileEx.ProfileProperties[Leet.UserGameData.DataContracts.ProfileProperty.GamerTag], true) == 0)
                            {
                                friendInfo = friendsInfoList[i];
                                break;
                            }
                        }
                    }

                    PopulateFriendProfile(friend.ProfileEx, callerIdentity, locale, (ulong)ProfileSections.PresenceInfo, friendInfo);

                    if (friendInfo != null)
                    {
                        friend.FriendState = (uint)friendInfo.FriendState;
                    }
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.AccountInformation))
            {
                if(string.IsNullOrEmpty(targetGamertag))
                {
                    AccountInformation accountInformation = new AccountInformation();
                    IBillingOfferingDataAccess billingOfferingDataAccess = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
                    accountInformation.MsftPointsBalance =
                        billingOfferingDataAccess.GetPointsBalance(callerIdentity.Xuid);
                    profile.AccountInformation = accountInformation;
                }
            }
        }

        private static ProfileEx PopulateFriendProfile(
            ProfileEx profileEx,
            IUserIdentity callerIdentity,
            string locale,
            ulong friendsSectionFlags,
            IReadOnlyFriendInfo friendsInfo)
        {
            ulong xuid = 0;
            if (profileEx.ProfileProperties.ContainsKey(Leet.UserGameData.DataContracts.ProfileProperty.Xuid))
            {
                xuid = (ulong)profileEx.ProfileProperties[Leet.UserGameData.DataContracts.ProfileProperty.Xuid];
            }
            else
            {
                string gamertag = (string)profileEx.ProfileProperties[Leet.UserGameData.DataContracts.ProfileProperty.GamerTag];
                var xCacheDataAccess = Container.Instance.GetComponent<IXCacheDataAccess>();
                xCacheDataAccess.GetPuidByGamerTag(gamertag, out xuid);
            }

            ushort lcid = GetLcid(locale);
            bool partialResult = false;
            List<IReadOnlyUserTitle> userTitles = null;

            if (FlagIsSet(friendsSectionFlags, ProfileSections.RecentGames))
            {
                var provider = Container.Instance.GetComponent<IAchievementDataAccess>();
                userTitles = provider.GetUserTitles(callerIdentity.Xuid, (ulong)xuid, lcid, 0, 6);
                profileEx.RecentGames = ProfileProvider.GetRecentGames(userTitles, lcid, ref partialResult);
            }

            if (FlagIsSet(friendsSectionFlags, ProfileSections.RecentAchievements))
            {
                if (userTitles == null && FlagIsSet(friendsSectionFlags, ProfileSections.RecentGames) == false)
                {
                    // the case where provider.GetUserTitles was not invoked because this flag was not set
                    var provider = Container.Instance.GetComponent<IAchievementDataAccess>();
                    userTitles = provider.GetUserTitles(callerIdentity.Xuid, (ulong) xuid, lcid, 0, 6);
                }

                // userTitles = null case is handled inside GetRecentAchievements method
                profileEx.RecentAchievements =
                        ProfileProvider.GetRecentAchievements(userTitles, callerIdentity.Xuid, (ulong)xuid, lcid, ref partialResult);
            }

            if (FlagIsSet(friendsSectionFlags, ProfileSections.PresenceInfo))
            {
                if (friendsInfo != null)
                {
                    profileEx.PresenceInfo = GetPresence(friendsInfo, lcid);
                }
                else
                {
                    Logging.TraceWarning("ProfileAdapter: Cannot find friend in friendslist: {0}", xuid);
                }
            }

            return profileEx;
        }

        private static Presence GetPresence(IReadOnlyFriendInfo friendsInfo, ushort lcid)
        {
            string titleName = string.Empty;

            if (friendsInfo.TitleId != 0)
            {
                var stringServerDataAccess = Container.Instance.GetComponent<IStringServerDataAccess>();
                DateTime cacheTTL;
                titleName = stringServerDataAccess.LookupString(friendsInfo.TitleId, 0, lcid, out cacheTTL);
            }

            Presence presence = new Presence
            {
                DetailedPresence = friendsInfo.PresenceString,
                LastSeenDateTime = friendsInfo.LastSeen,
                LastSeenTitleId = friendsInfo.TitleId,
                LastSeenTitleName = titleName,
                OnlineState = (uint)friendsInfo.State
            };

            return presence;
        }

        private static Presence GetPresence(ulong callerXuid, ulong targetXuid, ushort lcid)
        {
            var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
            IReadOnlyPresenceInfo presenceInfo = presenceDataAccess.GetPresenceInfo(callerXuid, targetXuid);
            string titleName = string.Empty;
            if (presenceInfo.TitleId != 0)
            {
                var stringServerDataAccess = Container.Instance.GetComponent<IStringServerDataAccess>();
                DateTime cacheTTL;
                titleName = stringServerDataAccess.LookupString(presenceInfo.TitleId, 0, lcid, out cacheTTL);
            }

            Presence presence = new Presence
            {
                DetailedPresence = presenceInfo.PresenceString,
                LastSeenDateTime = presenceInfo.LastSeen,
                LastSeenTitleId = presenceInfo.TitleId,
                LastSeenTitleName = titleName,
                OnlineState = (uint)presenceInfo.State
            };

            return presence;
        }

        private static XmlSerializableDictionary<PrivacySetting, uint> GetPrivacySettings(ulong xuid, uint[] lcPrivileges)
        {
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            IGamerProfile profile = settingsDataAccess.GetGamerProfile(xuid, xuid);

            Dictionary<Privilege, PrivilegeValue> privileges = ProfilePrivileges.Parse(lcPrivileges);

            XmlSerializableDictionary<PrivacySetting, uint> privacySetting = new XmlSerializableDictionary<PrivacySetting, uint>();

            foreach (Privilege key in privileges.Keys)
            {
                switch (key)
                {
                    case Privilege.Communication:
                        privacySetting.Add(PrivacySetting.VoiceAndText, (uint)privileges[key]);
                        break;

                    case Privilege.VideoCommunication:
                        privacySetting.Add(PrivacySetting.Video, (uint)privileges[key]);
                        break;

                    case Privilege.OnlineStatus:
                        privacySetting.Add(PrivacySetting.OnlineStatus, (uint)privileges[key]);
                        break;

                    case Privilege.MemberContent:
                        privacySetting.Add(PrivacySetting.MemberContent, (uint)privileges[key]);
                        break;

                    case Privilege.FriendsListSharing:
                        privacySetting.Add(PrivacySetting.FriendsList, (uint)privileges[key]);
                        break;

                    default:
                        break;
                }
            }

            // GamerProfile and PlayedGames privacy settings are set using Profile object properties
            // This is how they are saved in LiveCache, we have no control in changing this
            privacySetting.Add(PrivacySetting.GamerProfile, (uint) profile.ProfileUserCreatedContentPrivilege);
            privacySetting.Add(PrivacySetting.PlayedGames, (uint)profile.ProfileActivityPrivilege);

            return privacySetting;
        }

        private static void UpdateXboxLiveProperties(XmlSerializableDictionary<Leet.UserGameData.DataContracts.ProfileProperty, object> profileProperties, string locale, ulong xuid)
        {
            // load the existing gamer profile that would load all the existing properties
            // some privacy settings are stored in profile when we save we need to retain old privacy settings
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            IGamerProfile profile = settingsDataAccess.GetGamerProfile(xuid, xuid);

            foreach (Leet.UserGameData.DataContracts.ProfileProperty key in profileProperties.Keys)
            {
                switch (key)
                {
                    case Leet.UserGameData.DataContracts.ProfileProperty.Name:
                        profile.Name = (string)profileProperties[key];
                        break;
                    case Leet.UserGameData.DataContracts.ProfileProperty.Motto:
                        profile.Motto = (string)profileProperties[key];
                        break;
                    case Leet.UserGameData.DataContracts.ProfileProperty.Location:
                        profile.Location = (string)profileProperties[key];
                        break;
                    case Leet.UserGameData.DataContracts.ProfileProperty.Bio:
                        profile.Bio = (string)profileProperties[key];
                        break;
                    case Leet.UserGameData.DataContracts.ProfileProperty.GamerZone:
                        profile.Zone = (GamercardZone)Enum.Parse(typeof(GamercardZone), (string)profileProperties[key]);
                        break;
                    default:
                        break;
                }
            }
            
            settingsDataAccess.SaveGamerProfile(profile, locale);
        }

        private static void UpdatePrivacySettings(XmlSerializableDictionary<PrivacySetting, uint> privacySettings, ulong xuid, string gamertag, string locale)
        {
            Dictionary<Privilege, PrivilegeValue> privileges = new Dictionary<Privilege, PrivilegeValue>();

            foreach (PrivacySetting key in privacySettings.Keys)
            {
                switch (key)
                {
                    case PrivacySetting.VoiceAndText:
                        ValidatePriviledgeValue("Invalid PrivacySetting: VoiceAndText", privacySettings[key]); 
                        privileges.Add(Privilege.Communication, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.Video:
                        ValidatePriviledgeValue("Invalid PrivacySetting: Video", privacySettings[key]); 
                        privileges.Add(Privilege.VideoCommunication, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.GamerProfile:
                        ValidatePriviledgeValue("Invalid PrivacySetting: GamerProfile", privacySettings[key]); 
                        privileges.Add(Privilege.ProfileCustomization, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.OnlineStatus:
                        ValidatePriviledgeValue("Invalid PrivacySetting: OnlineStatus", privacySettings[key]); 
                        privileges.Add(Privilege.OnlineStatus, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.MemberContent:
                        ValidatePriviledgeValue("Invalid PrivacySetting: MemberContent", privacySettings[key]); 
                        privileges.Add(Privilege.MemberContent, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.PlayedGames:
                        ValidatePriviledgeValue("Invalid PrivacySetting: PlayedGames", privacySettings[key]); 
                        privileges.Add(Privilege.ProfileSharing, (PrivilegeValue)privacySettings[key]);
                        break;
                    case PrivacySetting.FriendsList:
                        ValidatePriviledgeValue("Invalid PrivacySetting: FriendsList", privacySettings[key]); 
                        privileges.Add(Privilege.FriendsListSharing, (PrivilegeValue)privacySettings[key]);
                        break;
                    default:
                        break;
                }
            }

            SavePrivacySettings(xuid, gamertag, locale, privileges);
        }

        /// <summary>
        /// Throw ArgumentException if priviledge value is not validated
        /// </summary>
        /// <param name="message"></param>
        /// <param name="priviledgeValue"></param>
        private static void ValidatePriviledgeValue(string message, uint priviledgeValue)
        {
            if (!Enum.IsDefined(typeof(PrivilegeValue), (PrivilegeValue) priviledgeValue))
            {
                throw new ArgumentException(message);
            }
        }

        private static void SavePrivacySettings(ulong xuid, string gamertag, string locale, Dictionary<Privilege, PrivilegeValue> privileges)
        {

            // the dictionary will only contain values we set (or left the same) on the page viewed
            // so this method called from the vela page will only contain vela values, etc.
            System.Collections.ArrayList addPrivileges = new System.Collections.ArrayList();
            System.Collections.ArrayList revokePrivileges = new System.Collections.ArrayList();

            // get profile permission setting
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            IGamerProfile profile = settingsDataAccess.GetGamerProfile(xuid, xuid);
            int profilePermission = profile.ProfilePermissions;

            // translate from our enums to the xonline enums
            foreach (KeyValuePair<Privilege, PrivilegeValue> kvp in privileges)
            {
                switch (kvp.Key)
                {
                    case Privilege.Communication:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
                                break;
                        }

                        break;
                    case Privilege.VideoCommunication:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
                                break;
                        }

                        break;
                    case Privilege.ExplicitContent:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT);
                                break;
                        }

                        break;
                    case Privilege.MemberContent:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
                                break;
                        }

                        break;
                    case Privilege.OnlineFriends:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_ADD_FRIEND);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_ADD_FRIEND);
                                break;
                        }

                        break;
                    case Privilege.OnlineGamePlay:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
                                break;
                        }

                        break;
                    case Privilege.OnlineStatus:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
                                break;
                        }

                        break;
                    case Privilege.OriginalXboxLiveGames:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
                                break;
                        }

                        break;
                    case Privilege.PremiumContent:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PURCHASE_CONTENT);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PURCHASE_CONTENT);
                                break;
                        }

                        break;
                    case Privilege.ProfileViewing:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
                                break;
                        }

                        break;
                    case Privilege.GamesForWindowsMultiplayer:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                throw new ArgumentException();
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER);
                                break;
                        }

                        break;
                    case Privilege.ProfileSharing:
                        int profileSharingMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                profilePermission = profilePermission & profileSharingMask;
                                break;
                            case PrivilegeValue.Deny:
                                profilePermission = (profilePermission & profileSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE;
                                break;
                            case PrivilegeValue.FriendsOnly:
                                profilePermission = (profilePermission & profileSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS;
                                break;
                        }

                        break;
                    case Privilege.ProfileCustomization:
                        int profileCustomizeMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                profilePermission = profilePermission & profileCustomizeMask;
                                break;
                            case PrivilegeValue.Deny:
                                profilePermission = (profilePermission & profileCustomizeMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE;
                                break;
                            case PrivilegeValue.FriendsOnly:
                                profilePermission = (profilePermission & profileCustomizeMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS;
                                break;
                        }

                        break;
                    case Privilege.FriendsListSharing:
                        switch (kvp.Value)
                        {
                            case PrivilegeValue.Allow:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
                                break;
                            case PrivilegeValue.FriendsOnly:
                                addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
                                break;
                            case PrivilegeValue.Deny:
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
                                revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
                                break;
                        }

                        break;
                }
            }

            if (addPrivileges.Count > 0 || revokePrivileges.Count > 0)
            {
                // convert the arraylists to arrays of uints
                uint[] add = new uint[8];
                uint[] revoke = new uint[8];
                for (int i = 0; i < 8; i++)
                {
                    add[i] = 0;
                    revoke[i] = 0;
                }

                foreach (uint ui in addPrivileges)
                {
                    LivePrivilegeSet.Set(add, (int)ui);
                }

                foreach (uint ui in revokePrivileges)
                {
                    LivePrivilegeSet.Set(revoke, (int)ui);
                }

                IAccountCreationDataAccess accountCreationDataAccess =
                    Container.Instance.GetComponent<IAccountCreationDataAccess>();
                accountCreationDataAccess.UpdateParentalControls(xuid, add, revoke, "Web-" + "WebSubProperty.Xbox");
             }

            // update profile permission settings
            SaveGamerProfilePermission(xuid, gamertag, locale, profilePermission);
        }

        private static void SaveGamerProfilePermission(ulong xuid, string gamertag, string locale, int permissions)
        {
            if (xuid == 0)
            {
                throw new ArgumentNullException("xuid");
            }

            GamerProfile profile = new GamerProfile(xuid, gamertag);
            profile.ProfilePermissions = permissions;

            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            settingsDataAccess.SaveGamerProfile(profile, locale);
        }

        /// <summary>
        /// Determines if the specified bit is set in the provided bitmap
        /// </summary>
        /// <param name="bitMap">Selects which section to be included</param>
        /// <param name="section">Profile section</param>
        /// <returns>Whether to flag is set</returns>
        public static bool FlagIsSet(ulong bitMap, ProfileSections section)
        {
            bool flagIsSet =
                (bitMap & ((ulong)section)) != 0;

            return flagIsSet;
        }

        /// <summary>
        /// Getting the Lcid from the locale
        /// </summary>
        /// <param name="locale">Locale to fetch the lcid</param>
        /// <returns>The Lcid found</returns>
        private static ushort GetLcid(string locale)
        {
            ushort lcid = 0;
            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
            lcid = localeHelper.GetLCID(locale);
            return lcid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\GetGamesTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using GameMetadata.Client;
using Gds.Contracts;
using Gds.Mocks;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using Leet.Utils;
using LIVEN.Common.Diagnostics;
using Microsoft.ServiceModel.Web;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Gds.Services.UserData.Partner.Tests
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class GetGamesTests
    {
        public GetGamesTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //

        [TestInitialize()]
        public void Initialize()
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>()
            ;

            Container.Instance.AddService<IXCacheDataAccess, FakeXCache>();
            Container.Instance.AddService<IAchievementDataAccess, TestAchievementDataAccess>();
            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();
            UserDataPartnerEvents.Initialize("gds_udspart");
        }
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void GetGamesTest()
        {
            // Arrange
            
            // Act
            GameData gameData = new GameData();
            string gamertag = "player1";
            string pageCount = "1";
            string pageStart = "0";
            var games = gameData.GetGames(gamertag, pageStart, pageCount);

            // Assert
            Assert.AreEqual(1, games.UserGamesCollection.Count);
            Assert.AreEqual(1, games.UserGamesCollection[0].GameList.Count);
        }

        [TestMethod]
        public void GetTwoGamerGamesValid()
        {
            GameData gameData = new GameData();
            string gamertag = "player1,player2";
            string pageCount = "1";
            string pageStart = "0";
            var games = gameData.GetGames(gamertag, pageStart, pageCount);

            // Assert
            Assert.AreEqual(2, games.UserGamesCollection.Count);
            Assert.AreEqual(1, games.UserGamesCollection[0].GameList.Count);
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GetGamesInvalidNumberGamertags()
        {
            string pageCount = "1";
            string pageStart = "0";
            string gamertag = "rewardstest,rewardsplay1,rewardsplay2";


            // Act
            GameData gameData = new GameData();
            var games = gameData.GetGames(gamertag, pageStart, pageCount);

            // Assert
            // Exception is thrown for exceeding number of gamertags
        }


        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void GetGamesNullGamertags()
        {
            string pageCount = "1";
            string pageStart = "0";
            string gamertag = "";

            // Act
            GameData gameData = new GameData();
            var games = gameData.GetGames(gamertag, pageStart, pageCount);

            // Assert
            // Exception is thrown for no gamertags returned
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\FakeXCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;

namespace Gds.Services.UserData.Partner.Tests
{
    public class FakeXCache : IXCacheDataAccess
    {
        public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
        {
            gamertag = "TestGamertag";

            return true;
        }

        public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
        {
            livePuid = 10;
            officialGamertag = "TestOfficialGamertag";

            return true;
        }

        public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
        {
            livePuid = 10;

            return true;
        }

        public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
        {
            livePuid = 10;
            gamertag = "TestGamertag";

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\TestAchievementDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Achievements;
using Leet.Live.Livecache.Logic.Games;

namespace Gds.Services.UserData.Partner.Tests
{
    public class TestAchievementDataAccess : IAchievementDataAccess
    {
        public List<IReadOnlyAchievementInfo> GetUserAchievements(uint gameTitleId, ulong callingUserPuid, ulong targetUserPuid, ushort localeId)
        {
            List<IReadOnlyAchievementInfo> readOnlyAchievementInfos = new List<IReadOnlyAchievementInfo>();
            readOnlyAchievementInfos.Add(new TestReadOnlyAchievementInfo());
            return readOnlyAchievementInfos;
        }


        public List<IReadOnlyUserTitle> GetUserTitles(ulong callingUserPuid, ulong targetUserPuid, ushort localeId,
            ushort startingIndex, ushort maxTitles)
        {
            List<IReadOnlyUserTitle> readOnlyUserTitles = new List<IReadOnlyUserTitle>();
            readOnlyUserTitles.Add(new TestReadOnlyUserTitle());
            return readOnlyUserTitles;
        }


        public List<IReadOnlyUserTitle> GetPublicUserTitles(ulong targetUserPuid, ushort localeId,
            ushort startingIndex, ushort maxTitles, out DateTime responseTTL)
        {

            throw new NotImplementedException();
        }

        public void SyncAchievements(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<IReadOnlyAchievementInfo> readOnlyAchievementInfos)
        {
            throw new NotImplementedException();
            // Update achievements here
        }

        public void SyncTitles(uint gameTitleId, ulong targetUserPuid, ushort localeId, DateTime lastPlayedTime)
        {
            throw new NotImplementedException();
            // Update last played time here
        }

        public void SyncAvatarAssets(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<AwardedAvatarAsset> readOnlyAchievementInfos)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\TestReadOnlyUserTitle.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Games;

namespace Gds.Services.UserData.Partner.Tests
{
    public class TestReadOnlyUserTitle : IReadOnlyUserTitle
    {
        public DateTime LastPlayed { get { return DateTime.Now; } }
        public ushort EarnedAchievements { get { return 1; } }
        public uint EarnedGamerscore { get { return 20; } }
        public uint Reserved { get { return 1; } }
        public uint Sequence { get { return 12; } }
        public uint TitleId { get { return 12;} }
        public string TitleName { get { return "Hexic Rush"; } }
        public ushort TotalAchievements { get { return 10; } }
        public uint TotalGamerscore { get { return 100; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\UpdatePresenceTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Gds.Services.UserData.Partner.Library;
using Gds.Mocks;

namespace Gds.Services.UserData.Partner.Tests
{
    /// <summary>
    /// Summary description for UpdatePresence
    /// </summary>
    [TestClass]
    public class UpdatePresenceTests
    {
        MockConfigurationProvider configProviderMock;
        public UpdatePresenceTests()
        {
            this.configProviderMock = new MockConfigurationProvider();
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(configProviderMock);
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TestTitleBlocklist()
        {
            Assert.IsTrue(PresenceProvider.IsTitleBlocked(123456), "PresenceProvider.IsTitleBlocked(123456) failed to return true");
            Assert.IsTrue(PresenceProvider.IsTitleBlocked(123457), "PresenceProvider.IsTitleBlocked(123457) failed to return true");
            Assert.IsFalse(PresenceProvider.IsTitleBlocked(123458), "PresenceProvider.IsTitleBlocked(123457) failed to return true");

            String blockListStringOriginal = this.configProviderMock.SettingsDictionary[Settings.UdsPartnerUpdatePresenceTitleBlocklist];
            this.configProviderMock.SettingsDictionary[Settings.UdsPartnerUpdatePresenceTitleBlocklist] = String.Empty;
            Assert.IsFalse(PresenceProvider.IsTitleBlocked(123456), "PresenceProvider.IsTitleBlocked(123457) failed to return true");
            Assert.IsFalse(PresenceProvider.IsTitleBlocked(123457), "PresenceProvider.IsTitleBlocked(123457) failed to return true");
            Assert.IsFalse(PresenceProvider.IsTitleBlocked(123458), "PresenceProvider.IsTitleBlocked(123457) failed to return true");

            this.configProviderMock.SettingsDictionary[Settings.UdsPartnerUpdatePresenceTitleBlocklist] = blockListStringOriginal + ",1E242";


            Assert.IsTrue(PresenceProvider.IsTitleBlocked(123456), "PresenceProvider.IsTitleBlocked(123456) failed to return true");
            Assert.IsTrue(PresenceProvider.IsTitleBlocked(123457), "PresenceProvider.IsTitleBlocked(123457) failed to return true");
            Assert.IsTrue(PresenceProvider.IsTitleBlocked(123458), "PresenceProvider.IsTitleBlocked(123457) failed to return true");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Test\GetAchievementsTests.cs ===
﻿using Gds.Services.UserData.Library;

namespace GDS.Services.UserData.Test
{
    using System;
    using System.Collections.Generic;
    using GameMetadata.Client;
    using Gds.Contracts;
    using Gds.Mocks;
    using Gds.Services.UserData;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Identity.ActiveAuth;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.TestUtilities;
    using Leet.Utils;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Rhino.Mocks;

    /// <summary>
    /// Summary description for GetAchievementsTests
    /// </summary>
    [TestClass]
    public class GetAchievementsTests
    {
        public GetAchievementsTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        [TestInitialize()]
        public void MyTestInitialize()
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
        }

        private void InitializeMocksWithStubber(Stubber stubber)
        {
            stubber.RegisterWithContainer<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            stubber.RegisterWithContainer<IAuthenticationManager, MockAuthenticationManager>();
            stubber.RegisterWithContainer<ILocaleHelper, LocaleHelperProvider>();
            stubber.RegisterWithContainer<IServicePerformanceCounters, MockServicePerformanceCounters>();
            stubber.RegisterWithContainer<IGameMetadataClient, FakeGameMetadataClient>();
            stubber.RegisterWithContainer<IConfigurationProvider, AppSettingsConfigurationProvider>();
        }

        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void GetAchievementsEmptyTest()
        {
            // Arrange
            Container.Instance.AddService<IActiveAuthAdapter, ActiveAuthAdapter>();
            Stubber stubber = new Stubber();
            IAuthenticationManager authenticationManager = stubber.RegisterWithContainer<IAuthenticationManager>();
            authenticationManager.Stub(c => c.IsAuthenticated).Return(true);

            InitializeMocksWithStubber(stubber);

            IUserIdentity userIdentity = new UserIdentity
                                             {
                                                 Xuid = 1233324234
                                             };

            authenticationManager.Stub(c => c.CurrentUser).Return(userIdentity);

            var callingUserPuid = 1233324234;
            var lcid = 1033;
            var gameId = 1111556096;

            List<IReadOnlyAchievementInfo> readOnlyAchievementInfos = GetAchievements(0);

            IAchievementDataAccess achievementDataAccess = stubber.RegisterWithContainer<IAchievementDataAccess>();
            achievementDataAccess.Stub(
                c =>
                c.GetUserAchievements(Convert.ToUInt32(gameId), Convert.ToUInt64(callingUserPuid),
                                      Convert.ToUInt64(callingUserPuid),
                                      Convert.ToUInt16(lcid))).Return(readOnlyAchievementInfos);

            // Act
            AchievementsResult achievementResult = GameDataAdapter.GetAchievements(Convert.ToUInt32(gameId));

            // Assert
            Assert.IsNotNull(achievementResult);
        }

        [TestMethod]
        public void GetAchievementsTest()
        {
            // Arrange
            Container.Instance.AddService<IActiveAuthAdapter, ActiveAuthAdapter>();
            Stubber stubber = new Stubber();
            IAuthenticationManager authenticationManager = stubber.RegisterWithContainer<IAuthenticationManager>();
            authenticationManager.Stub(c => c.IsAuthenticated).Return(true);

            InitializeMocksWithStubber(stubber);

            IUserIdentity userIdentity = new UserIdentity
            {
                Xuid = 1233324234
            };

            authenticationManager.Stub(c => c.CurrentUser).Return(userIdentity);

            var callingUserPuid = 1233324234;
            var lcid = 1033;
            var gameId = 1111556096;

            List<IReadOnlyAchievementInfo> readOnlyAchievementInfos = GetAchievements(3);

            IAchievementDataAccess achievementDataAccess = stubber.RegisterWithContainer<IAchievementDataAccess>();
            achievementDataAccess.Stub(
                c =>
                c.GetUserAchievements(Convert.ToUInt32(gameId), Convert.ToUInt64(callingUserPuid),
                                      Convert.ToUInt64(callingUserPuid),
                                      Convert.ToUInt16(lcid))).Return(readOnlyAchievementInfos);

            // Act
            AchievementsResult achievementResult = GameDataAdapter.GetAchievements(Convert.ToUInt32(gameId));

            // Assert
            Assert.IsNotNull(achievementResult);
            Assert.AreEqual(3, achievementResult.Achievements.Count);
        }


        private static List<IReadOnlyAchievementInfo> GetAchievements(int count)
        {
            List<IReadOnlyAchievementInfo> readOnlyAchievementInfos = new List<IReadOnlyAchievementInfo>();

            for (int i = 0; i < count; i++)
            {
                IReadOnlyAchievementInfo readOnlyAchievementInfo = new TestReadOnlyAchievmentInfo();
                readOnlyAchievementInfos.Add(readOnlyAchievementInfo);
            }

            return readOnlyAchievementInfos;
        }

    }

    public class TestReadOnlyAchievmentInfo : IReadOnlyAchievementInfo
    {
        private DateTime _dateUnlocked;
        private uint _achievementId;
        public DateTime DateUnlocked
        {
            get
            {
                _dateUnlocked = DateTime.Now;
                return _dateUnlocked;
            }
            set { value = _dateUnlocked; }
        }
        public uint AchievementId
        {
            get
            {
                _achievementId = 32;
                return _achievementId;
            }
            set { value = _achievementId; }
        }
        public int GamerscoreValue { get { return 20; } }
        public string Description { get { return "Win a race without using a Fiesta Missile, Colored Water Bomb, or Smoke Bomb."; } }
        public string HowTo { get { return "You must win a race without using a Fiesta Missile, Colored Water Bomb, or Smoke Bomb."; } }
        public int Flags { get { return 23; } }
        public uint ImageId { get { return 30; } }
        public Uri ImageHref
        {
            get
            {
                return
                    new Uri("http://tiles.xbox.com/tiles/FW/+5/14CLiGJhbC9NCxt0GltTWTE5L2FjaC8wLzE5AAAAAOfn5-iWbwk=.jpg");
            }
        }
        public Uri SecureImageHref { get { return new Uri("http://tiles.xbox.com/tiles/FW/+5/14CLiGJhbC9NCxt0GltTWTE5L2FjaC8wLzE5AAAAAOfn5-iWbwk=.jpg"); } }
        public string Title { get { return "Some Game"; } }
        public byte Type { get { return new byte(); } }
        public bool IsHidden { get { return false; } }
        public bool IsUnlocked { get { return false; } }
        private bool _wasEarnedOnline;
        public bool WasEarnedOnline { get { _wasEarnedOnline = false;
            return _wasEarnedOnline; } set { value = _wasEarnedOnline; } }
        public bool WasEarnedOffline { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\TestReadOnlyAchievementInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Achievements;

namespace Gds.Services.UserData.Partner.Tests
{
    public class TestReadOnlyAchievementInfo : IReadOnlyAchievementInfo
    {
        private DateTime _dateUnlocked;
        private uint _achievementId;
        public DateTime DateUnlocked
        {
            get
            {
                _dateUnlocked = DateTime.Now;
                return _dateUnlocked;
            }
            set { value = _dateUnlocked; }
        }
        public uint AchievementId
        {
            get
            {
                _achievementId = 32;
                return _achievementId;
            }
            set { value = _achievementId; }
        }
        public int GamerscoreValue { get { return 20; } }
        public string Description { get { return "Win a race without using a Fiesta Missile, Colored Water Bomb, or Smoke Bomb."; } }
        public string HowTo { get { return "You must win a race without using a Fiesta Missile, Colored Water Bomb, or Smoke Bomb."; } }
        public int Flags { get { return 23; } }
        public uint ImageId { get { return 30; } }
        public Uri ImageHref
        {
            get
            {
                return
                    new Uri("http://tiles.xbox.com/tiles/FW/+5/14CLiGJhbC9NCxt0GltTWTE5L2FjaC8wLzE5AAAAAOfn5-iWbwk=.jpg");
            }
        }
        public Uri SecureImageHref { get { return new Uri("http://tiles.xbox.com/tiles/FW/+5/14CLiGJhbC9NCxt0GltTWTE5L2FjaC8wLzE5AAAAAOfn5-iWbwk=.jpg"); } }
        public string Title { get { return "Some Game"; } }
        public byte Type { get { return new byte(); } }
        public bool IsHidden { get { return false; } }
        public bool IsUnlocked { get { return false; } }
        private bool _wasEarnedOnline;
        public bool WasEarnedOnline
        {
            get
            {
                _wasEarnedOnline = false;
                return _wasEarnedOnline;
            }
            set { value = _wasEarnedOnline; }
        }
        public bool WasEarnedOffline { get { return true; } }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Gds.Services.UserData.Partner.Tests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("12eeccb8-0052-4ad4-8e88-c740b9a71348")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Gds.Services.UserData.Partner.Tests\ValidationTests.cs ===
﻿using System;
using System.Text;
using System.IdentityModel;
using System.IdentityModel.Claims;
using System.IdentityModel.Policy;
using System.Collections.Generic;
using System.Linq;
using GameMetadata.Client;
using Gds.Contracts;
using Gds.Services.UserData.Partner;
using Gds.Mocks;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Identity;
using Leet.Identity.PartnerAuth;
using Leet.Live.Livecache.DataAccess;
using Leet.Utils;
using LIVEN.Common.Diagnostics;
using Microsoft.ServiceModel.Web;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Gds.Services.UserData.Partner.Tests
{
    /// <summary>
    /// Summary description for ValidationTests
    /// </summary>
    [TestClass]
    public class ValidationTests
    {
        static ValidationTests()
        {
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new CustomConfigurationProvider());
            Container.Instance.AddServiceWithInstance<IAuthenticationManager>(new CustomAuthenticationManager());
        }

        public ValidationTests()
        {
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void ValidateTitleIDAcceptingTest()
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            ((CustomConfigurationProvider)(config)).TitleIDsToReturn = new String[] { "4D5308EC", "4D5308EA" };

            UserDataUtility.ValidateTitleID();
        }

        [TestMethod]
        [ExpectedException(typeof(UnauthorizedAccessException))]
        public void ValidateTitleIDRejectingTest()
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            ((CustomConfigurationProvider)(config)).TitleIDsToReturn = new String[] { "0x4D5308EA" };

            UserDataUtility.ValidateTitleID();
        }

        [TestMethod]
        [ExpectedException(typeof(UnauthorizedAccessException))]
        public void ValidateTitleIDNullWhiteList()
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            ((CustomConfigurationProvider)(config)).TitleIDsToReturn = null;
            UserDataUtility.ValidateTitleID();
        }

        [TestMethod]
        [ExpectedException(typeof(UnauthorizedAccessException))]
        public void ValidateTitleIDUserUnAuthenticated()
        {
            CustomAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>() as CustomAuthenticationManager;
            authManager.SetAuthentication(false);
            UserDataUtility.ValidateTitleID();
        }


        class CustomConfigurationProvider : IConfigurationProvider
        {
            public String[] TitleIDsToReturn;
            #region IConfigurationProvider Members

            public event SettingChangedEventHandler SettingChanged;

            public event MultiSettingChangedEventHandler MultiSettingChanged;

            public string GetSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public bool GetBoolSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public int GetIntSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public long GetLongSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public double GetDoubleSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public string[] GetMultiSetting(string settingName)
            {
                switch (settingName)
                {
                    case "UdsPartnerTitleIDWhiteList":
                        {
                            return this.TitleIDsToReturn;
                        }
                    default:
                        {
                            return null;
                        }
                }

            }

            public string GetConnectionString(string interfaceName)
            {
                throw new NotImplementedException();
            }

            public string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
            {
                throw new NotImplementedException();
            }

            public string Environment
            {
                get { throw new NotImplementedException(); }
            }

            public string ComponentName
            {
                get { throw new NotImplementedException(); }
            }

            public string Server
            {
                get { throw new NotImplementedException(); }
            }

            public IInterfaceInfo GetSingleInterface(string interfaceName)
            {
                throw new NotImplementedException();
            }

            public IInterfaceInfo GetInterface(string computerName, string interfaceName)
            {
                throw new NotImplementedException();
            }

            public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
            {
                throw new NotImplementedException();
            }

            public string GetSingleServerForInterface(string interfaceName)
            {
                throw new NotImplementedException();
            }

            #endregion

            public bool DummyMethod()
            {
                if (SettingChanged.GetInvocationList().Length > 0 && MultiSettingChanged.GetInvocationList().Length > 0)
                {
                    return true;
                }

                return false;
            }
        }

        class CustomAuthenticationManager : IAuthenticationManager
        {
            UserIdentity ui = new UserIdentity((ulong)4234523523);

            public CustomAuthenticationManager()
            {
                ui.IsAuthenticated = true;
            }


            public void SetAuthentication(bool isAuthenticated)
            {
                ui.IsAuthenticated = isAuthenticated;
            }

            #region IAuthenticationManager Members

            public IUserIdentity CurrentUser
            {
                get { return ui; }
            }

            public bool IsAuthenticated
            {
                get { return ui.IsAuthenticated; }
            }

            public ClaimSet GetClaims()
            {
                List<Claim> claims = new List<Claim>();
                Claim titleIDClaim = new Claim(LiveNTokenClaimTypes.TitleIdClaimType, "4D5308EC", Rights.PossessProperty);
                claims.Add(titleIDClaim);

                return new DefaultClaimSet(claims);
            }

            #endregion

            #region IIdentityManager Members

            public IUserIdentity CreateUserIdentityFromKey(string identityKey)
            {
                throw new NotImplementedException();
            }

            public IUserIdentity CreateUserIdentityFromPuid(long puid)
            {
                throw new NotImplementedException();
            }

            public IUserIdentity CreateUserIdentityFromXuid(ulong xuid)
            {
                throw new NotImplementedException();
            }

            #endregion
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Test\GetLeaderboardUnitTest.cs ===
﻿namespace GDS.Services.UserData.Test
{
    using System;
    using System.Diagnostics;
    using System.Net;
    using GameMetadata.Client;
    using Gds.Contracts;
    using Gds.Mocks;
    using Gds.Services.UserData.Library;
    using GDS.DataAccess.UserData;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Profile;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics; 
    using Microsoft.ServiceModel.Web;
    using Microsoft.VisualStudio.TestTools.UnitTesting;

    /// <summary>
    /// Summary description for GetLeaderboardUnitTest
    /// </summary>
    [TestClass]
    public class GetLeaderboardUnitTest
    {
        private const int DefaultUserLeaderboardTotalItems = 6;

        private const uint ValidGameIdToUse = 7777;
        private const uint ValidVariantForValidGameId = 0;

        private TestContext testContextInstance;

        public GetLeaderboardUnitTest()
        {
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        // You can use the following additional attributes as you write your tests:
        // use classinitialize to run code before running the first test in the class
        // [classinitialize()]
        // public static void myclassinitialize(testcontext testcontext)
        // { }
        
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        [TestInitialize()]
        public void MyTestInitialize() 
        {
            Container.UseLocalContainer(new Container());
            Container.Instance.AddService<IUserDataStorage, MockUserDataStorage>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            Container.Instance.AddService<IServicePerformanceCounters, MockServicePerformanceCounters>();
            Container.Instance.AddService<IWebOperationIncomingRequestHeaderReader, MockWebOperationIncomingRequestHeaderReader>();
            Container.Instance.AddService<IAuthenticationManager, MockAuthenticationManager>();
            Container.Instance.AddService<IProfileProvider, MockProfileProvider>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();

            UserDataEvents.Initialize("gds_userdata");
        }

        [TestCleanup]
        public void MyTestCleanup()
        {
        }

        [TestMethod]
        public void MakeBasicValidLeaderboardCall()
        {
            LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(ValidGameIdToUse, ValidVariantForValidGameId, "BestScore", "Lifetime", 100, 0, 2);
            Assert.IsNotNull(leaderboardResult);
            Assert.IsTrue(leaderboardResult.TotalNumberOfRows > 0, "The real-list should have at least 1 entry");
            Assert.IsTrue(leaderboardResult.TotalNumberOfRows == DefaultUserLeaderboardTotalItems, "We expect at least one entry");
            Assert.IsTrue(leaderboardResult.Leaderboard.Count == DefaultUserLeaderboardTotalItems, "Actual Leaderboard should have been empty");
            Assert.IsTrue(AllEntriesAreDescending(leaderboardResult));
        }

        [TestMethod]
        public void InvalidRankStartLeaderboard()
        {
            LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(ValidGameIdToUse, ValidVariantForValidGameId, "BestScore", "Lifetime", 100, 200, 2);
            Assert.IsNotNull(leaderboardResult);
            
            Debug.Write(leaderboardResult.TotalNumberOfRows);
            Assert.IsTrue(leaderboardResult.TotalNumberOfRows == DefaultUserLeaderboardTotalItems, "The real-list should have at least 1 entry");
            Assert.IsNull(leaderboardResult.Leaderboard, "Actual Leaderboard should have been empty");
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void InvalidSocialGroupLeaderboard()
        {
            try
            {
                LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(ValidGameIdToUse, ValidVariantForValidGameId, "BestScore", "Lifetime", 100, 200, 1);
            }
            catch (WebProtocolException wpe)
            {
                Assert.IsTrue(wpe.StatusCode == HttpStatusCode.BadRequest);
                throw;
            }
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void InvalidDataGroupLeaderboard()
        {
            try
            {
                LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(ValidGameIdToUse, ValidVariantForValidGameId, "BestScore", "InvalidDataGroup", 100, 200, 2);
            }
            catch (WebProtocolException wpe)
            {
                Assert.IsTrue(wpe.StatusCode == HttpStatusCode.BadRequest);
                throw;
            }
        }

        [TestMethod]
        [ExpectedException(typeof(WebProtocolException))]
        public void InvalidPropertyLeaderboard()
        {
            try
            {
                LeaderboardResult leaderboardResult = GameDataAdapter.GetLeaderboard(ValidGameIdToUse, ValidVariantForValidGameId, "InvalidProperty", "W1", 100, 200, 2);
            }
            catch (WebProtocolException wpe)
            {
                Assert.IsTrue(wpe.StatusCode == HttpStatusCode.BadRequest);
                throw;
            }
        }

        private static bool AllEntriesAreDescending(LeaderboardResult leaderboardResult)
        {
            uint lastRank = 0;
            long lastValue = 0;

            for (int i = 0; i < leaderboardResult.Leaderboard.Count; i++)
            {
                uint currentRank = leaderboardResult.Leaderboard[i].Rank;
                long currentValue = leaderboardResult.Leaderboard[i].Value;

                if (i > 0)
                {
                    // ranks are always increasing, ascending
                    if (currentRank < lastRank)
                    {
                        Debug.Write(String.Format("At position {0}, the ranks are in the wrong order", i));
                        return false;
                    }

                    // values are decreasing, descending (if it high values are considered better), 
                    // for this test case they are.
                    if (currentValue > lastValue)
                    {
                        Debug.Write(String.Format("At position {0}, the values are in the wrong order i={1}, i-1={2}", i, currentValue, lastValue));
                        return false;
                    }

                    // if two value are equal, the higher ranked entry should be either earlier dated or same.
                    if (currentValue == lastValue)
                    {
                        DateTime currentPlayTime = LeaderboardUtility.GetLastPlayedDateTime(leaderboardResult.Leaderboard[i].Statistics);
                        DateTime lastPlayTime = LeaderboardUtility.GetLastPlayedDateTime(leaderboardResult.Leaderboard[i - 1].Statistics);

                        if (currentPlayTime < lastPlayTime)
                        {
                            Debug.Write(String.Format("At position {0}, the dates are in the wrong order i={1}, i-1={2}", i, currentPlayTime, lastPlayTime));
                            return false;
                        }
                    }
                }

                lastRank = currentRank;
                lastValue = currentValue;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\GDS.Services.UserData.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GDS.Services.UserData.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("1ad700ac-8c56-4796-a806-05bed10f62a6")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess\RewardsDAInterfaces.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using Common.Sql;

namespace RewardsDataAccess
{
    public interface IRewardsDA
    {
        DataTable GetRules(int gameKeyID);

        DataTable GetConfigValue(string configName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Parser.Test\EventContextTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Wgx.Gds.Parser;

namespace Parser.Text
{
    /// <summary>
    /// Summary description for ContextBaseTests
    /// </summary>
    [TestClass]
    public class EventContextTests
    {
        public EventContextTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void EventContextConstructorTest()
        {
            EventContext eventContext = new EventContext("<xml></xml>");
            Assert.IsNotNull(eventContext);
        }

        [TestMethod]
        public void EventLookupTest()
        {
            EventContext eventContext = new EventContext(@"<?xml version='1.0' encoding='utf-8'?><event><standard><locale>en-US</locale></standard></event>");
            Assert.IsNotNull(eventContext);
            PathExpression pathExpression = new PathExpression();
            pathExpression.Load("/Event/Locale");
            string actual = eventContext.Lookup(pathExpression);
            Assert.AreEqual("en-US", actual);
        }

        [TestMethod]
        public void EventLookupPropertyValueTest()
        {
            EventContext eventContext = new EventContext(@"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>100</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>");
            Assert.IsNotNull(eventContext);
            string expression = "/Event/Property[Score]";
            string actual = eventContext.LookupPropertyValue(expression);
            Assert.AreEqual("100", actual);           
        }

        [TestMethod]
        public void GetPropertyNameTest()
        {
            EventContext eventContext = new EventContext(@"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>100</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>");

            string propertyName = eventContext.GetPropertyName();
            Assert.AreEqual("Score", propertyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess\RewardsDAImpl.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Data;
using Common.Sql;
using System.Configuration;

namespace RewardsDataAccess
{
    /// <summary>
    /// Default implementation of IRewardsDA
    /// </summary>
    public class RewardsDA: IRewardsDA
    {
        private static string AppInstanceName;

        /// <summary>
        /// The object of SqlWrapper
        /// </summary>
        private SqlManager sqlManager;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="appInstanceName"></param>
        public RewardsDA(string appInstanceName)
        {
            AppInstanceName = appInstanceName;
        }

        public void Initialize(string sqlConnectionString)
        {
            this.sqlManager = new SqlManager(sqlConnectionString);
        }


        #region IRewardsDA Members

        public DataTable GetRules(int gameKeyID)
        {
            string methodName = "RewardsDA:GetRules";

            try
            {
                SqlResult sqlResult = null;
                sqlResult = this.sqlManager.GetRules(gameKeyID);

                if (sqlResult != null)
                {
                    CheckError(methodName, sqlResult);
                    return sqlResult.DataSet.Tables[0];
                }
            }
            catch (SqlException)
            {
                throw;
            }
            return null;
        }

        public DataTable GetConfigValue(string configName)
        {
            string methodName = "RewardsDA:GetConfigValue";

            try
            {
                SqlResult sqlResult = null;
                sqlResult = this.sqlManager.GetConfigValue(configName);

                if (sqlResult != null)
                {
                    CheckError(methodName, sqlResult);
                    return sqlResult.DataSet.Tables[0];
                }
            }
            catch (SqlException)
            {
                throw;
            }
            return null;
        }

        #endregion

        #region Private Methods

        private void CheckError(string source, SqlResult sqlResult)
        {
            int errCode = (int)sqlResult.Params["@ErrCode"].Value;
            if (0 != errCode)
            {
                // Stored procedure returned error. Throw Exception
                string errMsg = sqlResult.Params["@ErrMsg"].Value.ToString();
                string msg = source + " stored procedure returned error";
                throw new Exception(msg + errMsg); // TODO: throw more meaningful exception here
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess\RewardsDASqlManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using Common.Sql;

namespace RewardsDataAccess
{
    /// <summary>
    /// Interface for SqlManager
    /// </summary>
    public interface ISqlManager
    {
        SqlResult GetRules(int gameId);

        SqlResult GetConfigValue(string configName);
    }

    /// <summary>
    /// Implementation of ISqlManager
    /// </summary>
    public sealed class SqlManager : ISqlManager
    {
        private string ConnectionString;

        private SqlWrapper SqlWrapper;
        public SqlManager(string connectionString)
        {
            this.ConnectionString = connectionString;
            this.SqlWrapper = new SqlWrapper(this.ConnectionString, true);
        }

#region ISqlManager Members

        public SqlResult GetRules(int gameId)
        {
            SqlResult sqlResult = null;

            sqlResult = this.SqlWrapper.RunStoredProcQuery(
                "GDSS.p_GetRules",
                new SqlParameter("@GameID", gameId));

            return sqlResult;
        }

        public SqlResult GetConfigValue(string configName)
        {
            SqlResult sqlResult = null;

            sqlResult = this.SqlWrapper.RunStoredProcQuery(
                "GDSS.p_GetConfigValue",
                new SqlParameter("@Name", configName)
                );
        
            return sqlResult;
        }
    }
#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess\RewardsDAFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace RewardsDataAccess
{
    /// <summary>
    /// Creates the RewardsDA instances
    /// </summary>
    public sealed class RewardsDAFactory
    {
        private static IRewardsDA RewardInstance;

        /// <summary>
        /// Private constructor
        /// To prevent the compiler to create a default public constructor
        /// </summary>
        private RewardsDAFactory() { }

        public static IRewardsDA CreateInstance(string applicationName, string sqlConnectionString)
        {
            // Make sure appInstance name is valid
            if (applicationName == null)
            {
                throw new ArgumentNullException("applicationName");
            }

            if (applicationName.Length == 0)
            {
                throw new ArgumentException("Required parameter is empty.", "applicationName");
            }

            if (RewardInstance == null)
            {
                // Create the instance if it does not created yet
                RewardsDA instance = new RewardsDA(applicationName);
                // Initialize it
                instance.Initialize(sqlConnectionString);
                // Save the instance
                RewardInstance = instance;
            }

            return RewardInstance;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RewardsDataAccess")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("575049f8-2b91-45ca-a75c-bf918e754c3c")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Parser.Test\PathExpressionTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Wgx.Gds.Parser;

namespace Parser.Text
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class PathExpressionTests
    {
        public PathExpressionTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void PathExpressionConstructorTest()
        {
            PathExpression pathExpression = new PathExpression();
            Assert.IsNotNull(pathExpression);
        }

        [TestMethod]
        public void PathExpressionLocalTest()
        {
            PathExpression pathExpression = new PathExpression();
            string path = "/Event/Locale";
            pathExpression.Load(path);
            Assert.AreEqual(path, pathExpression.Expression);
            Assert.AreEqual(pathExpression.PathType, PathType.Event);
            Assert.AreEqual(pathExpression.Property, "Locale");
        }

        [TestMethod]
        public void PathExpressionEventTest()
        {
            string path = "/Store/LivePuid[ID=713191278440650]/GameID[ID=117]/HighScore";
            PathExpression pathExpression = new PathExpression();
            pathExpression.Load(path);
            Assert.AreEqual(path, pathExpression.Expression);
            Assert.AreEqual(pathExpression.PathType, PathType.Store);
            ulong livePuid = Convert.ToUInt64("713191278440650");
            Assert.AreEqual(pathExpression.LivePuid, livePuid);
            Assert.AreEqual(pathExpression.GameID, "117");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsService.Test\GlobalSuppressions.cs ===
//------------------------------------------------------------------------------------------------- 
// <copyright file="GlobalSuppressions.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Defines the rules not to be used in RewardsService Test class.</summary>
//-------------------------------------------------------------------------------------------------
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "RewardsService.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Wgx.Services.Gds")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Services.Gds")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsService.Test\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AssemblyInfo.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Defines the  type.</summary>
//-------------------------------------------------------------------------------------------------
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RewardsService.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("1831d900-9ab9-468c-8b01-ed6f16728899")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\Constants.cs ===
﻿
namespace Gds.RulesLibrary
{
    internal class Constants
    {
        public const string Store = "Store";
        public const string Event = "Event";
        public const string LivePuid = "LivePuid";
        public const string GameID = "GameID";
        public const string ID = "ID";
        public const string Property = "Property";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsService.Test2\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RewardsService.Test2")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3dafb61d-a051-4e91-b428-bc5ff2382c47")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsDataAccess.Test\RewardsDAImplTests.cs ===
﻿using System;
using System.Diagnostics;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using RewardsDataAccess;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Configuration;

namespace RewardsDataAccess.Test
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class RewardsDAImplTests
    {
        private IRewardsDA target;
        public RewardsDAImplTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        
         //Use TestInitialize to run code before running each test 
         [TestInitialize()]
         public void MyTestInitialize()
        {
            string connectionString = ConfigurationManager.ConnectionStrings["RewardsDBSQLConnection"].ConnectionString;
            this.target = RewardsDAFactory.CreateInstance("RewardsDATest", connectionString);
         }
        
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void AddRuleTest()
        {
            int actual;
            string gameKeyID = "1";
            DateTime start = DateTime.Now;
            DateTime end = DateTime.MaxValue;
            actual = this.target.AddRule(null, 1, "comment", start, end);
            Assert.IsTrue(actual >= 0);

            actual = this.target.AddRule(gameKeyID, 1, null, start, end);
            Assert.IsTrue(actual >= 0);
        }

        [TestMethod]
        public void AddExpressionTest()
        {
            int ruleID;
            string gameKey = "1";
            DateTime start = DateTime.Now;
            DateTime end = DateTime.MaxValue;

            ruleID = this.target.AddRule(gameKey, 1,"comment", start, end);
            Assert.IsTrue(ruleID >= 0);

            string leftOperand = "/Event/Score";
            string rightOperand = "1000";


            this.target.AddRuleExpression(ruleID, "System.int32", "EQUALTO", leftOperand, "Event", rightOperand,
                                          "Literal");

            bool actual = false;
            try
            {
                this.target.AddRuleExpression(ruleID, "System.int32", "EQUALTO", null, "Event", rightOperand,
                                          "Literal");
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);

            actual = false;
            try
            {
                this.target.AddRuleExpression(ruleID, "System.int32", "EQUALSTO", leftOperand, "Event", null,
                                          "Literal");
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);

            actual = false;
            try
            {
                this.target.AddRuleExpression(-1, "System.int32", "EQUALSTO", leftOperand, "Event", rightOperand,
                                          "Literal");
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);
        }

        [TestMethod]
        public void UpdateRuleTest()
        {
            int ruleID;
            string gameKey = "1";
            DateTime start = DateTime.Now;
            DateTime end = DateTime.MaxValue;
            ruleID = this.target.AddRule(gameKey, 1, null, start, end);
            Assert.IsTrue(ruleID >= 0);

            this.target.UpdateRule(ruleID, "1", 1, start, DateTime.Now, "new comment");

            bool actual = false;
            try
            {
                this.target.UpdateRule(-1, "1", 1, start, DateTime.Now, "new comment");
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);
        }

        [TestMethod]
        public void DeleteRuleTest()
        {
            int ruleID;
            string gameKey = "1";
            DateTime start = DateTime.Now;
            DateTime end = DateTime.MaxValue;
            ruleID = this.target.AddRule(gameKey, 1, null, start, end);
            Assert.IsTrue(ruleID >= 0);

            this.target.DeleteRule(ruleID);

            bool actual = false;
            try
            {
                this.target.UpdateRule(-1, "aaaaa", 0, start, DateTime.Now, "new comment");
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);
        }

        //[TestMethod]
        //public void AddActionTest()
        //{
        //    string actionTypeName = "CreateAndSubmitEvent";
        //    string actionContextXSD = "<?xml version='1.0'?>";

        //    this.target.AddActionType(actionTypeName, actionContextXSD);

        //    int ruleID;
        //    string gameKey = "DinerDash";
        //    DateTime start = DateTime.Now;
        //    DateTime end = DateTime.MaxValue;
        //    ruleID = this.target.AddRule(gameKey, 0, null, start, end);
        //    Assert.IsTrue(ruleID >= 0);

        //    int actionID = this.target.AddAction(ruleID, "<?xml version='1.0'?><Action></Action>", 0, 0);
        //    Assert.IsTrue(actionID >= 0);


        //    bool actual = false;
        //    try
        //    {
        //        this.target.AddAction(-1, "<?xml version='1.0'?><Action></Action>", 0, 0);
        //    }
        //    catch (ArgumentException)
        //    {
        //        actual = true;
        //    }

        //    Assert.IsTrue(actual);

        //    actual = false;
        //    try
        //    {
        //        this.target.AddAction(ruleID, null, 0, 0);
        //    }
        //    catch (ArgumentException)
        //    {
        //        actual = true;
        //    }

        //    Assert.IsTrue(actual);
        //}

        //[TestMethod]
        //public void UpdateActionTest()
        //{
        //    int ruleID;
        //    string gameKey = "DinerDash";
        //    DateTime start = DateTime.Now;
        //    DateTime end = DateTime.MaxValue;
        //    ruleID = this.target.AddRule(gameKey, 0, null, start, end);
        //    Assert.IsTrue(ruleID >= 0);

        //    int actionID = this.target.AddAction(ruleID, "<?xml version='1.0'?><Action></Action>", 0, 0);

        //    this.target.UpdateAction(actionID, "<?xml version='1.0'?><Action><ActionName>CreateMastery</ActionName></Action>");
            
        //    bool actual = false;
        //    try
        //    {
        //        this.target.AddAction(-1, "<?xml version='1.0'?><Action></Action>", 0, 0);
        //    }
        //    catch (ArgumentException)
        //    {
        //        actual = true;
        //    }

        //    Assert.IsTrue(actual);

        //    actual = false;
        //    try
        //    {
        //        this.target.AddAction(ruleID, null, 0, 0);
        //    }
        //    catch (ArgumentException)
        //    {
        //        actual = true;
        //    }

        //    Assert.IsTrue(actual);
        //}

        [TestMethod]
        public void GetRulesTest()
        {
            DataTable dataTable = this.target.GetRules(7);
            Assert.IsNotNull(dataTable);
        }

        [TestMethod]
        public void AddRewardCategoryTest()
        {
            string rewardCategoryName = "new category";

            this.target.AddRewardCategory(rewardCategoryName);

            bool actual = false;
            try
            {
                this.target.AddRewardCategory(null);
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);
        }
        [TestMethod]
        public void AddRewardTest()
        {
            int rewardCategoryID = 1;
            int rewardTypeID = 1;
            string rewardValue = "1";
            string gameKey = "1";
            int lcid = 1033;
            string locRewardName = "loc reward name";
            string locRewardDescription = "loc rewward descrio";
            DateTime startTime = DateTime.Now;
            DateTime endTime = DateTime.MaxValue;

            int rewardID = this.target.AddReward(rewardCategoryID, rewardTypeID, rewardValue, gameKey, lcid, locRewardName,
                                  locRewardDescription, startTime, endTime);

            Assert.IsTrue(rewardID >= 0);
        }

        [TestMethod]
        public void AddRewardTypeTest()
        {
            string rewardTypeName = "new type";

            this.target.AddRewardType(rewardTypeName);

            bool actual = false;
            try
            {
                this.target.AddRewardType(null);
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);
        }

        [TestMethod]
        public void AddLocaleTest()
        {
            string locale = "fr-FR";
            string collation = "SQL_french_collation";
            int lcid = 2033;

            this.target.AddLocale(lcid, locale, collation);

            bool actual = false;
            try
            {
                this.target.AddLocale(lcid, null, collation);
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);

            actual = false;
            try
            {
                this.target.AddLocale(lcid, locale, null);
            }
            catch (ArgumentException)
            {
                actual = true;
            }

            Assert.IsTrue(actual);

        }

        [TestMethod]
        public void GetAllRewardCategoriesTest()
        {
            DataTable dataTable = this.target.GetAllRewardCategories();
            Assert.IsNotNull(dataTable);

        }

        [TestMethod]
        public void GetAllRewardTypesTest()
        {
            DataTable dataTable = this.target.GetAllRewardTypes();
            Assert.IsNotNull(dataTable);
        }

        [TestMethod]
        public void GetRewardsTest()
        {
            string gameKey = "1";
            int lcid = 1033;

            DataTable dataTable = this.target.GetRewards(gameKey, lcid);
            Assert.IsNotNull(dataTable);
        }

        [TestMethod]
        public void UpdateRewardTest()
        {
            int rewardID;
            int rewardCategoryID = 1;
            int rewardTypeID = 1;
            string rewardValue = "1";
            string gameKey = "1";
            int lcid = 1033;
            string locRewardName = "loc reward name";
            string locRewardDescription = "loc rewward descrio";
            DateTime startTime = DateTime.Now;
            DateTime endTime = DateTime.MaxValue;

            rewardID = this.target.AddReward(rewardCategoryID, rewardTypeID, rewardValue, gameKey, lcid, locRewardName,
                                  locRewardDescription, startTime, endTime);

            this.target.UpdateReward(rewardID, rewardCategoryID, rewardTypeID, rewardValue, gameKey, lcid, locRewardName,
                                  locRewardDescription, startTime, endTime);
        }

        [TestMethod]
        public void DeleteRewardTest()
        {
            int rewardID;
            int rewardCategoryID = 1;
            int rewardTypeID = 1;
            string rewardValue = "0";
            string gameKey = "1";
            int lcid = 1033;
            string locRewardName = "loc reward name";
            string locRewardDescription = "loc rewward descrio";
            DateTime startTime = DateTime.Now;
            DateTime endTime = DateTime.MaxValue;

            rewardID = this.target.AddReward(rewardCategoryID, rewardTypeID, rewardValue, gameKey, lcid, locRewardName,
                                  locRewardDescription, startTime, endTime);

            this.target.DeleteReward(rewardID);
        }

        [TestMethod]
        public void AddRewardLocaleTest()
        {
            int rewardID;
            int rewardCategoryID = 1;
            int rewardTypeID = 1;
            string rewardValue = "0";
            string gameKey = "1";
            int lcid = 1033;
            string locRewardName = "loc reward name";
            string locRewardDescription = "loc rewward descrio";
            DateTime startTime = DateTime.Now;
            DateTime endTime = DateTime.MaxValue;

            rewardID = this.target.AddReward(rewardCategoryID, rewardTypeID, rewardValue, gameKey, lcid, locRewardName,
                                  locRewardDescription, startTime, endTime);

            this.target.AddRewardLocale(rewardID, lcid, locRewardName, locRewardDescription);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsService.Test\RewardsService.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="RewardsService.cs" company="Microsoft" author="Atin Jain">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Defines the Test class for RewardsService type.</summary>
//-------------------------------------------------------------------------------------------------
namespace RewardsService.Test
{
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Wgx.Services.Gds.RewardsService;

    /// <summary>
    /// RewardsService Test class
    /// </summary>
    [TestClass]
    public class RewardsService
    {
        /// <summary>
        /// TestContext Instance
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// Initializes a new instance of the RouterService class .. Public autogenerated constructor
        /// </summary>
        public RewardsService()
        {
            // TODO: Add constructor logic here
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// SubmitEvent API returns zero TotalResults
        /// </summary>
        [TestMethod]
        public void SubmitEventReturnsZeroResults()
        {
            RewardsServiceClient rfec = new RewardsServiceClient();
            RewardResult result = rfec.SubmitEvent(new GameEvent(), new ResultOptions());
            Assert.AreEqual<uint>(result.TotalResults, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RewardsService.Test2\Program.cs ===
﻿namespace RewardsService.Test2
{
    using System;
    using Wgx.Services.Gds;
    using Wgx.Services.Gds.BusinessObjects;
    using BusinessObject.Test;

    class Program
    {
        static void Main(string[] args)
        {
            GameEvent ge = TestGameEvent.ConstructScoreEvent(1, 120);
            string str = SerializerDeserializer.SerializeToString(ge);

            RewardsBrokerManager bm = new RewardsBrokerManager();
            //bm.Send(str);

            IAsyncResult ar = bm.BeginSend(new SubmitEventOperationContext(ge, null), null, null);
            bm.EndSend(ar);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\ContextBase.cs ===
﻿namespace Gds.RulesLibrary
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Xml;
    using System.Xml.Linq;
    using System.Xml.XPath;

    public class EventContext 
    {
        private const string DefaultNamespaceString = "http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects";
        private const string XsdNamespaceString = "http://www.w3.org/2001/XMLSchema-instance";

        private XPathDocument xpathDocument;
        private XPathNavigator xpathNavigator;

        public EventContext(string xmlEvent)
        {
            this.GameEvent = xmlEvent;
            StringReader rdr = new StringReader(xmlEvent);
            this.xpathDocument = new XPathDocument(rdr);
            this.Root = XElement.Parse(xmlEvent);
            this.DefaultNamespace = EventContext.DefaultNamespaceString;

            this.xpathNavigator = this.xpathDocument.CreateNavigator();
            this.XmlnsManager = new XmlNamespaceManager(this.xpathNavigator.NameTable);

            // xmlns="http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects" 
            this.XmlnsManager.AddNamespace("ge", EventContext.DefaultNamespaceString);

            // xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
            this.XmlnsManager.AddNamespace("i", EventContext.XsdNamespaceString);
        }
        
        public string GameEvent { get; set; }

        private XElement Root { get; set; }

        private XNamespace DefaultNamespace { get; set; }

        private XmlNamespaceManager XmlnsManager { get; set; }

        public string Lookup(string expression)
        {
            PathExpression pathExpression = new PathExpression();
            pathExpression.Load(expression);
            string xpathExpression = EventContext.GetXPathExpression(pathExpression);

            XPathNodeIterator iterator = this.xpathNavigator.Select(xpathExpression, this.XmlnsManager);
            iterator.MoveNext();
            return iterator.Current.Value;
        }

        public string LookupPropertyValue(string expression)
        {
            string propertyName = EventContext.GetPropertyNameFromExpression(expression);

            return this.GetPropertyValueFromGameEvent(propertyName);
        }

        /// <summary>
        /// For the GameEvent this object is constructed w/ this function returns the list of property names that exists in it.
        /// </summary>
        /// <returns>A Collection of strings</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public IList<string> GetPropertyNames()
        {
            List<string> propertyList = new List<string>();

            string pathExpression = "/ge:GameEvent/ge:Properties/ge:Property/ge:Name";
            XPathNodeIterator iterator = this.xpathNavigator.Select(pathExpression, this.XmlnsManager);
            while (iterator.MoveNext())
            {
                if (!string.IsNullOrEmpty(iterator.Current.Value))
                {
                    propertyList.Add(iterator.Current.Value);
                }
            }

            return propertyList;
        }

        private static string GetXPathExpression(PathExpression expression)
        {
            if (expression.PathType == PathType.Event && !string.IsNullOrEmpty(expression.Property))
            {
                return "/ge:GameEvent/ge:" + expression.Property;
            }

            return null;
        }

        private static string GetPropertyNameFromExpression(string expression)
        {
            // get property name
            char[]forwardSlash = { '/' };
            char[]endAngleBracket = { ']' };
            string[] tokens = expression.Split(forwardSlash);
            string value = null;
            foreach (string token in tokens)
            {
                if (token.Contains("["))
                {
                    value = token.Remove(0, 9);
                    value = value.TrimEnd(endAngleBracket);
                }
            }

            return value;
        }

        // TODO: ugly lookup
        // Convert to GameEvent xml to GameEvent object, to get rid of all these unnecessary xpath and/or Linq2xml lookups.
        private string GetPropertyValueFromGameEvent(string propertyName)
        {
            try
            {
                var targetPropertyValue = from properties in this.Root.Elements(this.DefaultNamespace + "Properties").Elements(this.DefaultNamespace + "Property")
                                          where (from name in properties.Elements(this.DefaultNamespace + "Name")
                                                 where name.Value.Equals(propertyName, StringComparison.OrdinalIgnoreCase)
                                                 select name).Any()
                                          select properties;
                if (targetPropertyValue.Count() > 0)
                {
                    XElement propertyElement = targetPropertyValue.First();
                    if (propertyElement != null)
                    {
                        var propertyElementValues = propertyElement.Elements(this.DefaultNamespace + "Value");
                        if (propertyElementValues.Count() > 0)
                        {
                            return propertyElementValues.First().Value;
                        }
                    }
                }
            }
            catch (InvalidOperationException)
            {
                // not a serious issue, the said property does not exists in the GameEvent.
                // absorb and return.
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\IDecisionTree.cs ===
﻿
namespace Gds.RulesLibrary
{
    public interface IDecisionTree
    {
        bool Evaluate(string gameEvent);

        string ToString();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\DiagnosticData.cs ===
﻿

namespace Gds.RulesLibrary
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public static class RulesLibraryDiag
    {
        internal static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public class RefreshDecisionTreeFailed : BaseEvent
    {
        public RefreshDecisionTreeFailed() : base(30100, TraceEventType.Error, "Refreshing decision tree failed.")
        {
        }
    }

    public class RulesLibraryPerfCountersNotInstalled : BaseEvent
    {
        public RulesLibraryPerfCountersNotInstalled() : base(30101, System.Diagnostics.TraceEventType.Error, "RulesLibraryPerfCounters has not been installed.")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\RuleExpression.cs ===
﻿using System.Globalization;

namespace Gds.RulesLibrary
{
    using System;
    
    /// <summary>
    /// Operand type
    /// </summary>
    public enum OperandType
    {
        /// <summary>
        /// Signed 32-bit integer
        /// </summary>
        Int32,

        /// <summary>
        /// Signed 64-bit integer
        /// </summary>
        Int64,

        /// <summary>
        /// String type
        /// </summary>
        String
    }

    /// <summary>
    /// Operand Property
    /// </summary>
    public enum OperandProperty
    {
        /// <summary>
        /// Event property
        /// </summary>
        Event,

        /// <summary>
        /// Literal property
        /// </summary>
        Literal
    }

    /// <summary>
    /// Operand class
    /// </summary>
    public class Operand
    {
        /// <summary>
        /// Name of operand
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public string Name;

        /// <summary>
        /// Name of value
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public object Value;

        /// <summary>
        /// Operand property
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public OperandProperty OperandProperty;
    }

    /// <summary>
    /// Boolean expession class
    /// </summary>
    internal abstract class BooleanExpression
    {
        /// <summary>
        /// Gets or sets left operand
        /// </summary>
        public Operand LeftOperand { get; set; }

        /// <summary>
        /// Gets or sets right operand
        /// </summary>
        public Operand RightOperand { get; set; }

        /// <summary>
        /// Gets or sets operand type
        /// </summary>
        public OperandType OperandType { get; set; }

        /// <summary>
        /// Evaluates based on event context
        /// </summary>
        /// <param name="eventContext">Event context to be evaluated</param>
        /// <returns>Whether the event context is evaluated to true</returns>
        public abstract bool Evaluate(EventContext eventContext);

        /// <summary>
        /// Whether left operand exists
        /// </summary>
        /// <param name="operandProperty">Operand property</param>
        /// <param name="operandValue">Operand value</param>
        /// <param name="rightOperandValue">Right operand value</param>
        /// <returns>Returns true if left operand exists</returns>
        public bool LeftOperandExists(OperandProperty operandProperty, string operandValue, out string rightOperandValue)
        {
            rightOperandValue = null;
            if (this.LeftOperand.OperandProperty == operandProperty && (string.Compare(this.LeftOperand.Name, operandValue, StringComparison.OrdinalIgnoreCase) == 0))
            {
                rightOperandValue = (string) this.RightOperand.Value;
                return true;
            }

            return false;
        }
    }

    /// <summary>
    /// Equals expression that overrides BooleanExpression
    /// </summary>
    internal class EqualExpression : BooleanExpression
    {
        /// <summary>
        /// Evaluates based on == operator
        /// </summary>
        /// <param name="eventContext">Event context to be evaluated</param>
        /// <returns>Whether the event context is evaluated to true</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToInt32(System.Object)")]
        public override bool Evaluate(EventContext eventContext)
        {
            if (LeftOperand.Name.Contains("Name"))
            {
                return true;
            }

            // Replace values as needed
            if (LeftOperand.OperandProperty == OperandProperty.Event)
            {
                if (LeftOperand.Name.Contains("Property["))
                {
                    LeftOperand.Value = eventContext.LookupPropertyValue(LeftOperand.Name);
                }
                else
                {
                    LeftOperand.Value = eventContext.Lookup(LeftOperand.Name);
                }
            }

            if (RightOperand.OperandProperty == OperandProperty.Event)
            {
                RightOperand.Value = eventContext.Lookup(RightOperand.Name);
            }

            if (string.IsNullOrEmpty((string)LeftOperand.Value) || string.IsNullOrEmpty((string)RightOperand.Value))
            {
                // throw exception here
                return false;
            }

            // Do comparison and return results
            if (OperandType == OperandType.Int32)
            {
                int leftOp = Convert.ToInt32(LeftOperand.Value);
                int rightOp = Convert.ToInt32(RightOperand.Value);
                return leftOp == rightOp;
            }
            else
            {
                // Do string comparison
                return string.Compare((string)LeftOperand.Value, (string)RightOperand.Value, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }
    }

    /// <summary>
    /// Greater than or equal expression that overrides BooleanExpression
    /// </summary>
    internal class GreaterOrEqualExpression : BooleanExpression
    {
        /// <summary>
        /// Evaluates based on >= operator
        /// </summary>
        /// <param name="eventContext">Event context to be evaluated</param>
        /// <returns>Whether the event context is evaluated to true</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToInt32(System.Object)")]
        public override bool Evaluate(EventContext eventContext)
        {
            // TODO: dummy hack
            // Replace values as needed
            if (LeftOperand.OperandProperty == OperandProperty.Event)
            {
                if (LeftOperand.Name.Contains("Property["))
                {
                    LeftOperand.Value = eventContext.LookupPropertyValue(LeftOperand.Name);
                }
                else
                {
                    LeftOperand.Value = eventContext.Lookup(LeftOperand.Name);
                }
            }

            if (RightOperand.OperandProperty == OperandProperty.Event)
            {
                RightOperand.Value = eventContext.Lookup(RightOperand.Name);
            }

            if (string.IsNullOrEmpty((string)LeftOperand.Value) || string.IsNullOrEmpty((string)RightOperand.Value))
            {
                // throw exception here
                return false;
            }

            // Do comparison and return results
            if (OperandType == OperandType.Int32)
            {
                int leftOp = Convert.ToInt32(LeftOperand.Value);
                int rightOp = Convert.ToInt32(RightOperand.Value);
                return leftOp >= rightOp;
            }
            else
            {
                // No string compares for less than or equal to operator
                int leftOp = Convert.ToInt32(LeftOperand.Value);
                int rightOp = Convert.ToInt32(RightOperand.Value);
                return leftOp >= rightOp;
            }
        }
    }

    /// <summary>
    /// Less than or equal expression that overrides BooleanExpression
    /// </summary>
    internal class LessOrEqualExpression : BooleanExpression
    {
        /// <summary>
        /// Evaluates based on less than operator
        /// </summary>
        /// <param name="eventContext">Event context to be evaluated</param>
        /// <returns>Whether the event context is evaluated to true</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToInt32(System.Object)")]
        public override bool Evaluate(EventContext eventContext)
        {
            // Replace values as needed
            if (LeftOperand.OperandProperty == OperandProperty.Event)
            {
                if (LeftOperand.Name.Contains("Property["))
                {
                    LeftOperand.Value = eventContext.LookupPropertyValue(LeftOperand.Name);
                }
                else
                {
                    LeftOperand.Value = eventContext.Lookup(LeftOperand.Name);
                }
            }

            if (RightOperand.OperandProperty == OperandProperty.Event)
            {
                RightOperand.Value = eventContext.Lookup(RightOperand.Name);
            }

            if (string.IsNullOrEmpty((string)LeftOperand.Value) || string.IsNullOrEmpty((string)RightOperand.Value))
            {
                // throw exception here
                return false;
            }

            // Do comparison and return results
            if (OperandType == OperandType.Int32)
            {
                int leftOp = Convert.ToInt32(LeftOperand.Value);
                int rightOp = Convert.ToInt32(RightOperand.Value);
                return leftOp <= rightOp;
            }
            else
            {
                // No string compares for less than or equal to operator
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\Rule.cs ===
﻿using System;

namespace Gds.RulesLibrary
{
    using System.Collections.Generic;
    using System.Xml;

    /// <summary>
    /// Rule class which contains a rule statement and an action set
    /// </summary>
    public class Rule
    {
        /// <summary>
        /// Rule statement
        /// </summary>
        private List<BooleanExpression> ruleStatement;

        /// <summary>
        /// Initializes a new instance of the Rule class
        /// </summary>
        /// <param name="ruleStatementXml">Rule statement xml</param>
        /// <param name="actionSetXML">Action set xml</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "XML")]
        public Rule(XmlDocument ruleStatementXml, XmlDocument actionSetXml)
        { 
            this.ActionSetXml = actionSetXml;
            this.ruleStatement = new List<BooleanExpression>();
            if (ruleStatementXml != null)
            {
                this.DeserializeRuleStatement(ruleStatementXml);
            }
        }

        /// <summary>
        /// Gets or sets action set xml
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode")]
        public XmlDocument ActionSetXml { get; set; }

        /// <summary>
        /// Returns if left operand exists
        /// </summary>
        /// <param name="operandProperty">Operator property</param>
        /// <param name="operandValue">Operand value</param>
        /// <param name="value">Left operand value</param>
        /// <returns>True or false if the left operand exists</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#")]
        public bool LeftOperandExists(OperandProperty operandProperty, string operandValue, out string value)
        {
            value = null;
            foreach (BooleanExpression be in this.ruleStatement)
            {
                if (be.LeftOperandExists(operandProperty, operandValue, out value))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns if property exists
        /// </summary>
        /// <param name="operandProperty">Operator property</param>
        /// <param name="operandValue">Operand value</param>
        /// <param name="value">Property value</param>
        /// <returns>True or false if the property exists</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#")]
        public bool PropertyExists(OperandProperty operandProperty, string operandValue, out string value)
        {
            value = null;
            foreach (BooleanExpression be in this.ruleStatement)
            {
                if (be.LeftOperandExists(operandProperty, operandValue, out value))
                {
                    return true;
                }

                if (be.LeftOperand.Name.Contains("Property["))
                {
                    // get value
                    value = be.LeftOperand.Name.Remove(0, 16);
                    char[] angle = { ']' };
                    value = value.TrimEnd(angle);
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Evaluates the event context with the rule
        /// </summary>
        /// <param name="eventContext">Event context</param>
        /// <returns>Where the event context evaluated to true for a rule</returns>
        public bool Evaluate(EventContext eventContext)
        {
            if (this.ruleStatement == null)
            {
                return false;
            }

            foreach (BooleanExpression re in this.ruleStatement)
            {
                if (!re.Evaluate(eventContext))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Returns whether a rule has rule expressions
        /// </summary>
        /// <returns>Returns true if rule has more than 0 rule expressions</returns>
        public bool HasExpressions()
        {
            return this.ruleStatement != null && this.ruleStatement.Count > 0;
        }

        //public List<BooleanExpression> GetPropertyExpressions()
        //{
        //    List<BooleanExpression> boolExpression = new List<BooleanExpression>();
        //    foreach (BooleanExpression expression in this.ruleStatement)
        //    {
        //        if(expression.LeftOperand.Name.Contains("Property"))
        //            boolExpression.Add(expression);
        //    }
        //    return boolExpression;
        //}

        /// <summary>
        /// Returns a string of the rule
        /// </summary>
        /// <returns>String of the rule</returns>
        public override string ToString()
        {
            string returnString = null;
            if (this.ruleStatement != null && this.ruleStatement.Count > 0)
            {
                foreach (BooleanExpression re in this.ruleStatement)
                {
                    returnString += re.LeftOperand.Name + " " + Rule.GetOperatorSymbol(re.GetType().ToString()) + " " +
                                    re.RightOperand.Value +
                                    " && ";
                }

                returnString = returnString.TrimEnd(' ', '&');
                returnString = returnString + "\n";
            }

            if (this.ActionSetXml != null)
            {
                returnString += this.ActionSetXml.OuterXml.ToString();
            }

            return returnString;
        }

        /// <summary>
        /// Get operator symbol based on expression string
        /// </summary>
        /// <param name="expressionString">Expression string</param>
        /// <returns>Operator string</returns>
        private static string GetOperatorSymbol(string expressionString)
        {
            switch (expressionString)
            {
                case "RulesLibrary.EqualExpression":
                   return "==";
                case "RulesLibrary.GreaterOrEqualExpression":
                    return ">=";
                case "RulesLibrary.LessOrEqualExpression":
                    return "<=";
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        /// Deserializes the rules statement
        /// </summary>
        /// <param name="ruleXml">Rule xml object</param>
        private void DeserializeRuleStatement(XmlDocument ruleXml)
        {
            // Check if ruleXml is null or does not have child nodes
            if (ruleXml == null)
            {
                return;
            }

            BooleanExpression expression = null;

            foreach (XmlNode node in ruleXml.DocumentElement.ChildNodes)
            {
                string oper = node.SelectSingleNode("Operator").InnerText;

                if (string.Compare("GREATERTHANOREQUALTO", oper, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression = new GreaterOrEqualExpression();
                }
                else if (string.Compare("EQUALTO", oper, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression = new EqualExpression();
                }
                else if (string.Compare("LESSERTHANOREQUALTO", oper, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression = new LessOrEqualExpression();
                }

                // Set the datatype for the expression (string or int)
                string operandDataType = node.Attributes["type"].InnerText;
                if (string.Compare("system.int32", operandDataType, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression.OperandType = OperandType.Int32;
                }
                else
                {
                    expression.OperandType = OperandType.String;
                }

                // Setting the left operand
                expression.LeftOperand = new Operand();
                string operandType = node.SelectSingleNode("LeftOperand").Attributes["type"].InnerText;

                if (string.Compare("Event", operandType, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression.LeftOperand.OperandProperty = OperandProperty.Event;
                    expression.LeftOperand.Name = node.SelectSingleNode("LeftOperand").InnerText;
                }
                else
                {
                    expression.LeftOperand.OperandProperty = OperandProperty.Literal;
                    expression.LeftOperand.Value = node.SelectSingleNode("LeftOperand").InnerText;
                }

                // Setting the right operand 
                expression.RightOperand = new Operand();
                operandType = node.SelectSingleNode("RightOperand").Attributes["type"].InnerText;

                if (string.Compare("Event", operandType, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    expression.RightOperand.OperandProperty = OperandProperty.Event;
                    expression.RightOperand.Name = node.SelectSingleNode("RightOperand").InnerText;
                }
                else
                {
                    expression.RightOperand.OperandProperty = OperandProperty.Literal;
                    expression.RightOperand.Value = node.SelectSingleNode("RightOperand").InnerText;
                }

                expression.RightOperand.Value = node.SelectSingleNode("RightOperand").InnerText;
                this.ruleStatement.Add(expression);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\RulesLibraryCounters.cs ===
﻿
namespace Gds.RulesLibrary
{
    using System;
    using System.Diagnostics;
    using Wgx.Services.Monitoring;
    using Leet.Utils;

    public enum RulesLibraryMethod
    {
        EvaluateEvent,
        ExecuteAction
    }

    /// <summary>
    /// Performance counter class for RulesLibraryCounters
    /// </summary>
    public class RulesLibraryCounters : PerfCounterBase<RulesLibraryCounters>
    {
        private PerformanceCounterCollection counters;

        private bool perfCountersInitialized;
        private static object lockObject = new Object();

        /// <summary>
        /// Initializes a new instance of the RulesLibraryCounters class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public RulesLibraryCounters()
        {
            Initialize();
        }

        private bool Initialize()
        {
            if (this.counters == null)
            {
                lock (lockObject)
                {
                    if (this.counters == null)
                    {
                        this.perfCountersInitialized = true;
                        try
                        {
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(RulesLibraryPerfCounters));
                        }
                        catch (Exception ex)
                        {
                            this.perfCountersInitialized = false;
                            RulesLibraryDiag.Logging.LogEvent(new RulesLibraryPerfCountersNotInstalled(), ex);
                        }
                    }
                }
            }

            return this.perfCountersInitialized;
        }

        public override void StartRequest(object context)
        {
            if (this.Initialize())
            {
                base.StartRequest(context);

                RulesLibraryMethod rulesLibraryMethod = (RulesLibraryMethod)context;
                switch (rulesLibraryMethod)
                {
                    case RulesLibraryMethod.EvaluateEvent:
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.CurrentEvents);
                        break;
                    case RulesLibraryMethod.ExecuteAction:

                        this.counters.SafeIncrement(RulesLibraryPerfCounters.CurrentActions);
                        break;
                    default:
                        break;
                }
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;

            if (this.perfCountersInitialized)
            {
                // it is imperative that Context object be retrieved once and before the base.EndRequest() call
                RulesLibraryMethod rulesLibraryMethod = (RulesLibraryMethod)RulesLibraryCounters.Context;

                duration = base.EndRequest(failed);

                switch (rulesLibraryMethod)
                {
                    case RulesLibraryMethod.EvaluateEvent:
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.EvaluateEventRequestsPerSecond);
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.EvaluateEventTotalRequests);
                        this.counters.SafeIncrementBy(RulesLibraryPerfCounters.EvaluateEventAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.EvaluateEventAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RulesLibraryPerfCounters.EvaluateEventFailuresPerSecond);
                            this.counters.SafeIncrement(RulesLibraryPerfCounters.EvaluateEventTotalFailures);
                        }

                        this.counters.SafeDecrement(RulesLibraryPerfCounters.CurrentEvents);
                        break;
                    case RulesLibraryMethod.ExecuteAction:
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.ExecuteActionRequestsPerSecond);
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.ExecuteActionTotalRequests);
                        this.counters.SafeIncrementBy(RulesLibraryPerfCounters.ExecuteActionAverageExecutionTime, duration);
                        this.counters.SafeIncrement(RulesLibraryPerfCounters.ExecuteActionAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(RulesLibraryPerfCounters.ExecuteActionFailuresPerSecond);
                            this.counters.SafeIncrement(RulesLibraryPerfCounters.ExecuteActionTotalFailures);
                        }

                        this.counters.SafeDecrement(RulesLibraryPerfCounters.CurrentActions);
                        break;
                    default:
                        break;
                }
            }

            return duration;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\DecisionTree.cs ===
﻿
namespace Gds.RulesLibrary
{
    using System;
    using System.Collections.Generic;
    using System.Xml;
    using Gds.ActionEngine;
    using Gds.DataAccess.Rules;
    using Leet.Core.IoCCo;
    
    /// <summary>
    /// A node value of the tree
    /// </summary>
    public class RulesNodeValue
    {
        /// <summary>
        /// Initializes a new instance of the RulesNodeValue class
        /// </summary>
        /// <param name="nameOfRulesNodeValue">Name of the node value</param>
        public RulesNodeValue(string nameOfRulesNodeValue)
        {
            this.Name = nameOfRulesNodeValue;
            this.TableOfNodes = new Dictionary<string, TreeNode<RulesNodeValue>>();
            this.ListOfRules = new List<Rule>();
        }

        /// <summary>
        /// Gets or sets name of node
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets table of nodes
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
        public Dictionary<string, TreeNode<RulesNodeValue>> TableOfNodes { get; set; }

        /// <summary>
        /// Gets or sets list of rules
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
        public List<Rule> ListOfRules { get; set; }
    }

    /// <summary>
    /// The rules decision tree class
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    public class RulesDecisionTree : IDecisionTree
    {
        /// <summary>
        /// Array of standard levels
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        public static string[] StandardLevels;

        /// <summary>
        /// Name of the component
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public string ComponentName = "RulesDecisionTree";

        /// <summary>
        /// Root of the tree
        /// </summary>
        private TreeNode<RulesNodeValue> root;

        /// <summary>
        /// Action engine
        /// </summary>
        private IActionEngine actionEngine;

        /// <summary>
        /// Property section
        /// </summary>
        private string[] propertySection = { "/Event/Property/Name" };

        private RulesLibraryCounters Counters { get; set; }
        
        /// <summary>
        /// Initializes a new instance of the RulesDecisionTree class
        /// </summary>
        /// <returns>Rules decision tree</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToDouble(System.String)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
        public RulesDecisionTree()
        {
            this.actionEngine = Container.Instance.GetComponent<IActionEngine>();
            string treeName = null;
            StandardLevels = RulesLibraryConfig.GetDecisionTreeConfigurationSettings(out treeName);

            // Fetch rules from the database to build decision tree
            this.RefreshDecisionTreeFromDB();
            RulesDecisionTree.DecisionRefreshTimeInSeconds = Convert.ToDouble(RulesLibraryConfig.GetDecisionTreeRefreshTimeInSeconds());

            this.Counters = new RulesLibraryCounters();
        }

        /// <summary>
        /// Gets or sets number of seconds to refresh the tree
        /// </summary>
        public static double DecisionRefreshTimeInSeconds { get; set; }

        /// <summary>
        /// Gets or sets last time the rules were updated from the database
        /// </summary>
        public DateTime LastUpdatedTS { get; set; }

        /// <summary>
        /// Gets or sets time the rules have expired
        /// </summary>
        public DateTime ExpiredTS { get; set; }

        /// <summary>
        /// Evaluate the game event by traversing the tree using BFS
        /// </summary>
        /// <param name="gameEvent">Game event</param>
        /// <returns>True if the rule is satisfied, else false</returns>
        public bool Evaluate(string gameEvent)
        {
            bool requestFailed = false;

            try
            {
                this.Counters.StartRequest(RulesLibraryMethod.EvaluateEvent);

                // check to see if we need to refresh the decision tree
                if (this.ExpiredTS <= DateTime.UtcNow)
                {
                    // refresh the tree
                    DateTime decisionTreeLastUpdateTime = RulesDecisionTree.GetDecisionTreeLastUpdate();
                    if (decisionTreeLastUpdateTime >= this.LastUpdatedTS)
                    {
                        // update tree
                        this.RefreshDecisionTreeFromDB();
                    }

                    this.ExpiredTS = DateTime.UtcNow.AddSeconds(RulesDecisionTree.DecisionRefreshTimeInSeconds);
                }

                Queue<TreeNode<RulesNodeValue>> queue = new Queue<TreeNode<RulesNodeValue>>();
                EventContext eventContext = new EventContext(gameEvent);
                queue.Enqueue(this.root);

                // traverse tree
                while (queue.Count > 0)
                {
                    TreeNode<RulesNodeValue> node = queue.Dequeue();

                    // evaluate list of rules
                    this.EvaluateRules(node.Value.ListOfRules, eventContext);
                    foreach (TreeNode<RulesNodeValue> child in node.Children)
                    {
                        string value = null;
                        List<string> keyNames = new List<string>();

                        if (child.Value.Name.Contains("Property"))
                        {
                            IList<string> propList = eventContext.GetPropertyNames();
                            keyNames.AddRange(propList);
                        }
                        else
                        {
                            value = eventContext.Lookup(child.Value.Name);
                            if (!string.IsNullOrEmpty(value))
                            {
                                keyNames.Add(value);
                            }
                        }

                        foreach (string keyName in keyNames)
                        {
                            if (child.Value.TableOfNodes.ContainsKey(keyName))
                            {
                                queue.Enqueue(child.Value.TableOfNodes[keyName]);
                            }
                        }
                    }
                }
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.Counters.EndRequest(requestFailed);
            }

            return false;
        }

        /// <summary>
        /// Override method to get string of the Rules decision tree
        /// </summary>
        /// <returns>A string of the rules decision tree</returns>
        public override string ToString()
        {
            return this.GetString(this.root, 0, null);
        }

        /// <summary>
        /// Sanitizes xml string
        /// </summary>
        /// <param name="xmlString">Xml string</param>
        /// <returns>Sanitized string</returns>
        private static string CleanXml(string xmlString)
        {
            if (!string.IsNullOrEmpty(xmlString))
            {
                xmlString = xmlString.Replace("&amp;", "&");
                xmlString = xmlString.Replace("&lt;", "<");
                xmlString = xmlString.Replace("&gt;", ">");
            }

            return xmlString;
        }

        /// <summary>
        /// Insert the rule into the rules decision tree
        /// </summary>
        /// <param name="rule">Rule to be inserted</param>
        private void InsertRule(Rule rule)
        {
            // TODO: get this automagically
            int count = 2;
            TreeNode<RulesNodeValue> currentNode = this.root;

            // if Rule has no expressions then added to the root node's list of Rules
            if (!rule.HasExpressions())
            {
                currentNode.Value.ListOfRules.Add(rule);
                return;
            }

            string key = string.Empty;

            TreeNode<RulesNodeValue> tempNode = null;
            RulesNodeValue newRulesNodeValue = null;

            // iterate through the tree for the standard sections
            for (int i = 0; i < count; i++)
            {
                // scan downwards but if none go to the children
                if (rule.LeftOperandExists(OperandProperty.Event, StandardLevels[i], out key))
                {
                    // find children that has standardLevel
                    tempNode = RulesDecisionTree.GetChild(currentNode.Children, StandardLevels[i]);

                    if (tempNode == null)
                    {
                        // add new child node to currentNode
                        tempNode = new TreeNode<RulesNodeValue>();
                        newRulesNodeValue = new RulesNodeValue(StandardLevels[i]);
                        tempNode.Value = newRulesNodeValue;
                        currentNode.Children.Add(tempNode);
                    }

                    currentNode = tempNode;

                    if (!currentNode.Value.TableOfNodes.ContainsKey(key))
                    {
                        currentNode.Value.TableOfNodes[key] = new TreeNode<RulesNodeValue>();
                        currentNode.Value.TableOfNodes[key].Value = new RulesNodeValue(StandardLevels[i]);
                    }

                    currentNode = currentNode.Value.TableOfNodes[key];
                }
            }

            // List<BooleanExpression> propertyList = rule.GetPropertyExpressions();
            // foreach (BooleanExpression expression in propertyList)
            // {
            //     if(!currentNode.Value.hashtable.ContainsKey(expression.RightOperand.Value))
            //     {
            //         currentNode.Value.hashtable[key] = new TreeNode<RulesNodeValue>();
            //         currentNode.Value.hashtable[key].Value = new RulesNodeValue(expression.RightOperand.Value);
            //     }
            // }

            count = 1;

            // iterate through the tree for the standard sections
            for (int j = 0; j < count; j++)
            {
                // scan downwards but if none go to the children
                if (rule.PropertyExists(OperandProperty.Event, this.propertySection[j], out key))
                {
                    // find children that has standardLevel
                    tempNode = RulesDecisionTree.GetChild(currentNode.Children, this.propertySection[j]);

                    if (tempNode == null)
                    {
                        // add new child node to currentNode
                        tempNode = new TreeNode<RulesNodeValue>();
                        newRulesNodeValue = new RulesNodeValue(this.propertySection[j]);
                        tempNode.Value = newRulesNodeValue;
                        currentNode.Children.Add(tempNode);
                    }

                    currentNode = tempNode;

                    if (!currentNode.Value.TableOfNodes.ContainsKey(key))
                    {
                        currentNode.Value.TableOfNodes[key] = new TreeNode<RulesNodeValue>();
                        currentNode.Value.TableOfNodes[key].Value = new RulesNodeValue(this.propertySection[j]);
                    }

                    currentNode = currentNode.Value.TableOfNodes[key];
                }
            }

            currentNode.Value.ListOfRules.Add(rule);
        }

        /// <summary>
        /// Get the child node with the specified name
        /// </summary>
        /// <param name="nodelist">The tree node list</param>
        /// <param name="name">Name of the node</param>
        /// <returns>Returns the child of the nodelist</returns>
        private static TreeNode<RulesNodeValue> GetChild(TreeNodeList<RulesNodeValue> nodelist, string name)
        {
            for (int i = 0; i < nodelist.Count; i++)
            {
                if (string.Compare(nodelist[i].Value.Name, name, StringComparison.OrdinalIgnoreCase) == 0)
                {
                    return nodelist[i];
                }
            }

            return null;
        }

        /// <summary>
        /// Returns the string value of the tree
        /// </summary>
        /// <param name="subtree">The nod of the tree</param>
        /// <param name="level">The number of levels</param>
        /// <param name="key">The key of the node</param>
        /// <returns>A string of the Rules decision tree</returns>
        private string GetString(TreeNode<RulesNodeValue> subtree, int level, string key)
        {
            string indent = string.Empty.PadLeft(level * 3);
            string rstring = null;

            rstring = indent + subtree.Value.Name + " == " + key + ", Level: " + level + "\r\n";

            if (subtree.Value.ListOfRules != null)
            {
                foreach (Rule r in subtree.Value.ListOfRules)
                {
                    rstring += indent + "RULE: " + r.ToString() + "\r\n";
                }
            }

            level++;
            foreach (TreeNode<RulesNodeValue> node in subtree.Children)
            {
                foreach (KeyValuePair<string, TreeNode<RulesNodeValue>> tn in node.Value.TableOfNodes)
                {
                    TreeNode<RulesNodeValue> nn = node.Value.TableOfNodes[tn.Key];
                    rstring += this.GetString(nn, level, tn.Key);
                }
            }

            return rstring;
        }

        /// <summary>
        /// Returns when the rules were last updated
        /// </summary>
        /// <returns>The date and time of when the rules were updated in the database</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToDateTime(System.Object)")]
        private static DateTime GetDecisionTreeLastUpdate()
        {
            IRulesStorage rulesStorage = Container.Instance.GetComponent<IRulesStorage>();
            DateTime lastUpdated = Convert.ToDateTime(rulesStorage.GetConfigValue("RulesLastUpdateTime"));
            return lastUpdated;
        }

        /// <summary>
        /// Refreshings the rules decision tree from database
        /// </summary>
        private void RefreshDecisionTreeFromDB()
        {
            try
            {
                IRulesStorage rulesStorage = Container.Instance.GetComponent<IRulesStorage>();

                // Retrieve all rules in the database
                IList<DataAccess.Rules.Rule> rules = rulesStorage.GetRules(0);
                this.root = new TreeNode<RulesNodeValue>();
                this.root.Value = new RulesNodeValue("root");

                if (rules != null && rules.Count != 0)
                {
                    foreach (DataAccess.Rules.Rule aRule in rules)
                    {
                        XmlDocument ruleStatement = null;
                        XmlDocument actionSet = null;
                        if (!string.IsNullOrEmpty(aRule.RuleStatement))
                        {
                            ruleStatement = new XmlDocument();
                            ruleStatement.LoadXml(aRule.RuleStatement);
                        }

                        if (!string.IsNullOrEmpty(aRule.ActionSet))
                        {
                            string actionSetString = RulesDecisionTree.CleanXml(aRule.ActionSet);
                            actionSet = new XmlDocument();
                            actionSet.LoadXml(actionSetString);
                        }

                        Rule rule = new Rule(ruleStatement, actionSet);
                        this.InsertRule(rule);
                    }
                }

                this.ExpiredTS = DateTime.UtcNow.AddSeconds(RulesDecisionTree.DecisionRefreshTimeInSeconds);
                this.LastUpdatedTS = DateTime.UtcNow;

            }
            catch (Exception ex)
            {
                RulesLibraryDiag.Logging.LogEvent(new RefreshDecisionTreeFailed(), ex);
                throw;
            }
        }

        /// <summary>
        /// Evaluate the event against a list of rules
        /// </summary>
        /// <param name="rules">List of rules</param>
        /// <param name="eventContext">Event context</param>
        private void EvaluateRules(List<Rule> rules, EventContext eventContext)
        {
            if (rules != null)
            {
                foreach (Rule r in rules)
                {
                    if (r.Evaluate(eventContext))
                    {
                        bool requestFailed = false;

                        try
                        {
                            this.Counters.StartRequest(RulesLibraryMethod.ExecuteAction);

                            // Execute action
                            this.actionEngine.Execute(r.ActionSetXml.OuterXml.ToString(), eventContext.GameEvent);
                        }
                        catch (Exception)
                        {
                            requestFailed = true;
                            throw;
                        }
                        finally
                        {
                            this.Counters.EndRequest(requestFailed);
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\RulesLibraryConfig.cs ===
﻿namespace Gds.RulesLibrary
{
    using System;
    using System.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Configuration;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    public sealed class RulesLibraryConfig
    {
        private const string ComponentName = "RulesLibraryConfig";
        private RulesLibraryConfig() { }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "0#")]
        public static string[] GetDecisionTreeConfigurationSettings(out string treeName)
        {
            try
            {
                StandardLevelsSection standardLevelSection =
                    ConfigurationManager.GetSection("StandardLevels") as StandardLevelsSection;
                treeName = standardLevelSection.Name;
                string[] standardLevels = new string[standardLevelSection.StandardLevels.Count];
                for (int i = 0; i < standardLevelSection.StandardLevels.Count; i++)
                {
                    StandardLevelElement standardLevelElement = standardLevelSection.StandardLevels[i];
                    string name = standardLevelElement.Name;
                    standardLevels[i] = name;
                }
                return standardLevels;
            }
            catch (Exception ex)
            {
                Logging.TraceException(ex, "{0}: GetDecisionTreeConfigurationSettings",
                    ComponentName);

                throw new InvalidOperationException("Unable to load decision tree configuration values.", ex);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public static string GetDecisionTreeRefreshTimeInSeconds()
        {
            return ConfigurationManager.AppSettings["DecisionTreeRefreshTimeInSecs"];
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public static string GetHealthCheckHighPort()
        {
            return ConfigurationManager.AppSettings["HealthCheck_HighPort"];
        }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    public class StandardLevelsSection : ConfigurationSection
    {
        #region Constructors
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static StandardLevelsSection()
        {
            propertyName = new ConfigurationProperty(
                "name",
                typeof(string),
                null,
                ConfigurationPropertyOptions.IsRequired);

            standardLevels = new ConfigurationProperty(
                "",
                typeof(StandardLevelElementCollection),
                null,
                ConfigurationPropertyOptions.IsRequired | ConfigurationPropertyOptions.IsDefaultCollection);

            properties = new ConfigurationPropertyCollection();

            properties.Add(propertyName);
            properties.Add(standardLevels);
        }
        #endregion

        #region Fields
        private static ConfigurationPropertyCollection properties;
        private static ConfigurationProperty propertyName;
        private static ConfigurationProperty standardLevels;
        #endregion

        #region Properties
        public string Name
        {
            get { return (string)base[propertyName]; }
        }

        public StandardLevelElementCollection StandardLevels
        {
            get { return (StandardLevelElementCollection)base[standardLevels]; }
        }

        protected override ConfigurationPropertyCollection Properties
        {
            get
            {
                return properties;
            }
        }
        #endregion
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    public class StandardLevelElement : ConfigurationElement
    {
        #region Static Fields

        private static ConfigurationProperty level;
        private static ConfigurationProperty name;

        private static ConfigurationPropertyCollection properties;
        #endregion

        #region Constructors
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static StandardLevelElement()
        {
            level = new ConfigurationProperty("level", typeof(int), null, ConfigurationPropertyOptions.IsRequired);
            name = new ConfigurationProperty("name", typeof(string), null, ConfigurationPropertyOptions.IsRequired);

            properties = new ConfigurationPropertyCollection();
            properties.Add(level);
            properties.Add(name);
        }
        #endregion

        #region Properties

        [ConfigurationProperty("level", IsRequired = true)]
        public int Level
        {
            get { return (int)base[level]; }
        }

        [ConfigurationProperty("name", IsRequired = true)]
        public string Name
        {
            get { return (string)base[name]; }
        }

        /// <summary>
        /// Override the properties collection and return custom one
        /// </summary>
        protected override ConfigurationPropertyCollection Properties
        {
            get
            {
                return properties;
            }
        }

        #endregion Properties
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface")]
    public class StandardLevelElementCollection : ConfigurationElementCollection
    {
        #region Constructors
        public StandardLevelElementCollection()
        {
        }
        #endregion

        #region Fields
        #endregion

        #region Properties
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.BasicMap;
            }
        }
        protected override string ElementName
        {
            get
            {
                return "StandardLevel";
            }
        }

        #endregion

        #region Indexers

        public StandardLevelElement this[int index]
        {
            get { return (StandardLevelElement)base.BaseGet(index); }
        }


        #endregion

        #region Overrides
        protected override ConfigurationElement CreateNewElement()
        {
            return new StandardLevelElement();
        }

        protected override object GetElementKey(ConfigurationElement element) 
        {
            return (element as StandardLevelElement).Name;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\PathExpression.cs ===
﻿namespace Gds.RulesLibrary
{
    using System;

    /// <summary>
    /// Path type
    /// </summary>
    public enum PathType
    {
        /// <summary>
        /// From store
        /// </summary>
        Store,

        /// <summary>
        /// From event
        /// </summary>
        Event
    }

    /// <summary>
    /// PathExpression class
    /// </summary>
    public class PathExpression
    {
        /// <summary>
        /// Initializes a new instance of the PathExpression class
        /// </summary>
        public PathExpression()
        {
        }

        /// <summary>
        /// Gets or sets the gameId
        /// </summary>
        public string GameId { get; set; }

        /// <summary>
        /// Gets or sets the LivePuid
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid")]
        public ulong LivePuid { get; set; }

        /// <summary>
        /// Gets or sets the expression
        /// </summary>
        public string Expression { get; set; }

        /// <summary>
        /// Gets or sets the property
        /// </summary>
        public string Property { get; set; }

        /// <summary>
        /// Gets or sets the pathtype
        /// </summary>
        public PathType PathType { get; set; }

        /// <summary>
        /// Gets or sets the pathitem
        /// </summary>
        public PathItem Value { get; set; }

        /// <summary>
        /// Loads the pathExpression and parses it into properties
        /// </summary>
        /// <param name="pathExpression">Path expression</param>
        public void Load(string pathExpression)
        {
            if (!string.IsNullOrEmpty(pathExpression))
            {
                char[] forwardSlash = { '/' };
                this.Expression = pathExpression;
                string[] exp = pathExpression.Split(forwardSlash);
                foreach (string token in exp)
                {
                    this.SetProperty(token);
                }
            }
        }

        /// <summary>
        /// Sets the property
        /// </summary>
        /// <param name="token">Token string</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Convert.ToUInt64(System.String)")]
        internal void SetProperty(string token)
        {
            if (!string.IsNullOrEmpty(token))
            {
                if (token.Contains(Constants.Store))
                {
                    this.PathType = PathType.Store;
                }
                else if (token.Contains(Constants.Event))
                {
                    this.PathType = PathType.Event;
                }
                else if (token.Contains(Constants.LivePuid))
                {
                    // Get puid if there is
                    this.LivePuid = Convert.ToUInt64(PathExpression.GetIDElement(token));
                }
                else if (token.Contains(Constants.GameID))
                {
                    // Get gameID if there is
                    this.GameId = PathExpression.GetIDElement(token);
                    this.Property = Constants.GameID;
                }
                else if (token.Contains(Constants.Property) && token.Contains("["))
                {
                    // Get property
                    char[] leftAngleBracket = { '[' };
                    char[] rightAngleBracket = { ']' };
                    string[] tokenized = token.Split(leftAngleBracket);
                    tokenized[1] = tokenized[1].TrimEnd(rightAngleBracket);
                    this.Property = tokenized[1];
                }
                else if (!token.Contains("Name"))
                {
                    this.Property = token;
                }
            }
        }

        /// <summary>
        /// Gets the id element
        /// </summary>
        /// <param name="token">Token string</param>
        /// <returns>Id element string</returns>
        private static string GetIDElement(string token)
        {
            if (!string.IsNullOrEmpty(token))
            {
                if (token.Contains(Constants.ID))
                {
                    if (token.Contains("'"))
                    {
                        // do something since it's an expression within an expression
                    }
                    else if (token.Contains("="))
                    {
                        char[] equalsSymbol = { '=' };
                        char[] angleBracket = { ']' };
                        string[] tokenized = token.Split(equalsSymbol);
                        tokenized[1] = tokenized[1].TrimEnd(angleBracket);
                        return tokenized[1];
                    }
                }
            }

            return null;
        }
    }

    /// <summary>
    /// PathItem class
    /// </summary>
    public class PathItem
    {
        /// <summary>
        /// Initializes a new instance of the PathItem class
        /// </summary>
        public PathItem()
        {
        }

        /// <summary>
        /// Gets or sets the value
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Gets or sets the valuetype
        /// </summary>
        public Type ValueType { get; set; }

        /// <summary>
        /// Gets the Value as
        /// </summary>
        /// <param name="returnType">Return type</param>
        /// <returns>Empty object</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "returnType")]
        public static object ValueAs(Type returnType)
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\TreeNodeList.cs ===
﻿
namespace Gds.RulesLibrary
{
    using System.Collections.Generic;
    
    /// <summary>
    /// Tree Node List class
    /// </summary>
    /// <typeparam name="T">Type of the tree node</typeparam>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    public class TreeNodeList<T> : List<TreeNode<T>>
    {
        /// <summary>
        /// Parent of the tree
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public TreeNode<T> Parent;

        /// <summary>
        /// Initializes a new instance of the TreeNodeList class
        /// </summary>
        /// <param name="parent"></param>
        public TreeNodeList(TreeNode<T> parent)
        {
            this.Parent = parent;
        }

        /// <summary>
        /// Adds a node to the tree
        /// </summary>
        /// <param name="node">A new node</param>
        /// <returns>New tree node</returns>
        public new TreeNode<T> Add(TreeNode<T> node)
        {
            base.Add(node);
            node.Parent = this.Parent;
            return node;
        }

        /// <summary>
        /// Returns the number elements
        /// </summary>
        /// <returns>Number of elements</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int32.ToString")]
        public override string ToString()
        {
            return "Count=" + Count.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\RulesLibraryPerfCounters.cs ===
﻿
namespace Gds.RulesLibrary
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class implements the RulesService PerfCounter Category
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Perf"), PerformanceCategory(CategoryName = "Gds RulesService", CategoryType = PerformanceCounterCategoryType.SingleInstance)]
    public sealed class RulesLibraryPerfCounters
    {
        private RulesLibraryPerfCounters() { }

        public static string Name
        {
            get
            {
                return "Gds RulesService";
            }
        }

        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }

        /// <summary>
        /// Performance counters for Evaluate Event
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total Evaluate Event calls")]
        public static int EvaluateEventTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for Evaluate Event")]
        public static int EvaluateEventTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "Evaluate Event calls per second")]
        public static int EvaluateEventRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "Evaluate Event failures per second")]
        public static int EvaluateEventFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for Evaluate Event")]
        public static int EvaluateEventAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "EvaluateEventAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for Evaluate Event", BasePropertyName = "EvaluateEventAverageExecutionTimeBase")]
        public static int EvaluateEventAverageExecutionTime;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "CurrentEvents", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "Current events being processed.")]
        public static int CurrentEvents;

        /// <summary>
        /// Performance counters for Execute Action 
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total Execute Action calls")]
        public static int ExecuteActionTotalRequests;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for Execute Action")]
        public static int ExecuteActionTotalFailures;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "Execute Action calls per second")]
        public static int ExecuteActionRequestsPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "Execute Action failures per second")]
        public static int ExecuteActionFailuresPerSecond;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for Execute Action")]
        public static int ExecuteActionAverageExecutionTimeBase;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "ExecuteActionAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for Execute Action", BasePropertyName = "ExecuteActionAverageExecutionTimeBase")]
        public static int ExecuteActionAverageExecutionTime;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible")]
        [PerformanceCounterAttribute(CounterName = "CurrentActions", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "Current actions being processed.")]
        public static int CurrentActions;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\TreeNode.cs ===
﻿
namespace Gds.RulesLibrary
{
    using System;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly")]
    public class TreeNode<T> : IDisposable
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public TreeNode<T> ParentNode;

        public TreeNode()
        {
            Parent = null;
            Children = new TreeNodeList<T>(this);
        }

        public TreeNode(T value)
        {
            this.Value = value;
            Children = new TreeNodeList<T>(this);
        }

        public TreeNode(TreeNode<T> parent)
        {
            this.Parent = parent;
            Children = new TreeNodeList<T>(this);
        }

        public TreeNode<T> Parent
        {
            get { return ParentNode; }
            set
            {
                if (value == ParentNode)
                {
                    return;
                }

                if (ParentNode != null)
                {
                    ParentNode.Children.Remove(this);
                }

                if (value != null && !value.Children.Contains(this))
                {
                    value.Children.Add(this);
                }

                ParentNode = value;
            }
        }

        public TreeNode<T> Root
        {
            get
            {
                TreeNode<T> node = this;
                while (node.Parent != null)
                {
                    node = node.Parent;
                }

                return node;
            }
        }

        private TreeNodeList<T> children;
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
        public TreeNodeList<T> Children
        {
            get { return children; }
            private set { children = value; }
        }

        private T val;
        public T Value
        {
            get { return val; }
            set { val = value; }
        }

        #region IDisposable

        private bool _IsDisposed;
        public bool IsDisposed
        {
            get { return _IsDisposed; }
        }

        // TODO: update this to dispose value of node if it is disposable
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1816:CallGCSuppressFinalizeCorrectly")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly")]
        public virtual void Dispose()
        {
            CheckDisposed();

            foreach (TreeNode<T> node in Children)
            {
                node.Dispose();
            }

            OnDisposing();

            _IsDisposed = true; 
        }

        public event EventHandler Disposing;

        protected void OnDisposing()
        {
            if (Disposing != null)
            {
                Disposing(this, EventArgs.Empty);
            }
        }

        protected void CheckDisposed()
        {
            if (IsDisposed)
            {
                throw new ObjectDisposedException(GetType().Name);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RewardLibrary")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]


// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5458828e-19e8-43de-ac92-ee12e2339d93")]

// To keep production code and unit tests seperate that uses "internal" classes
[assembly: InternalsVisibleTo("RulesLibrary.Test")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\RuleExpressionsTest.cs ===
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Gds.RulesLibrary;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace RulesLibrary.Test
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class RuleExpressionsTest
    {
        public RuleExpressionsTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void EqualExpressionTest()
        {
            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>20000</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            EventContext eventContext = new EventContext(eventXml);

            //Hashtable eventContext = new Hashtable();
            //eventContext["/Event/PublisherID"] = "Oberon";
            //eventContext["/Event/GameID"] = "Hexic";
            //eventContext["/Event/Property[Score]"] = "20000";

            // Do string comparison
            EqualExpression equalExp = new EqualExpression();
            equalExp.OperandType = OperandType.String;
            equalExp.LeftOperand = new Operand();
            equalExp.LeftOperand.OperandProperty = OperandProperty.Event;
            equalExp.LeftOperand.Name = "/Event/GameKey";

            equalExp.RightOperand = new Operand();
            equalExp.RightOperand.OperandProperty = OperandProperty.Literal;
            equalExp.RightOperand.Value = "1";

            bool target = equalExp.Evaluate(eventContext);
            Assert.IsTrue(target);

            // Do int comparison
            equalExp = new EqualExpression();
            equalExp.OperandType = OperandType.Int32;
            equalExp.LeftOperand = new Operand();
            equalExp.LeftOperand.OperandProperty = OperandProperty.Event;
            equalExp.LeftOperand.Name = "/Event/Property[Score]";

            equalExp.RightOperand = new Operand();
            equalExp.RightOperand.OperandProperty = OperandProperty.Literal;
            equalExp.RightOperand.Value = "20000";

            target = equalExp.Evaluate(eventContext);
            Assert.IsTrue(target);
        }


        [TestMethod]
        public void GreaterThanExpressionTest()
        {
            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>1100</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            EventContext eventContext = new EventContext(eventXml);

            // Do string comparison
            GreaterOrEqualExpression greaterThanExp = new GreaterOrEqualExpression();
            greaterThanExp.OperandType = OperandType.String;
            greaterThanExp.LeftOperand = new Operand();
            greaterThanExp.LeftOperand.OperandProperty = OperandProperty.Event;
            greaterThanExp.LeftOperand.Name = "/Event/GameKey";

            greaterThanExp.RightOperand = new Operand();
            greaterThanExp.RightOperand.OperandProperty = OperandProperty.Literal;
            greaterThanExp.RightOperand.Value = "2";

            bool target = greaterThanExp.Evaluate(eventContext);
            Assert.IsFalse(target);

            // Do int comparison
            greaterThanExp = new GreaterOrEqualExpression();
            greaterThanExp.OperandType = OperandType.Int32;
            
            greaterThanExp.LeftOperand = new Operand();
            greaterThanExp.LeftOperand.OperandProperty = OperandProperty.Event;
            greaterThanExp.LeftOperand.Name = "/Event/Property[Score]";

            greaterThanExp.RightOperand = new Operand();
            greaterThanExp.RightOperand.OperandProperty = OperandProperty.Literal;
            greaterThanExp.RightOperand.Value = "1000";

            target = greaterThanExp.Evaluate(eventContext);
            Assert.IsTrue(target);
        }

        [TestMethod]
        public void LessThanExpressionTest()
        {
            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>10</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            EventContext eventContext = new EventContext(eventXml);

            // Do string comparison
            LessOrEqualExpression lessThanExp = new LessOrEqualExpression();
            lessThanExp.OperandType = OperandType.String;
            
            lessThanExp.LeftOperand = new Operand();
            lessThanExp.LeftOperand.OperandProperty = OperandProperty.Event;
            lessThanExp.LeftOperand.Name = "/Event/GameKey";

            lessThanExp.RightOperand = new Operand();
            lessThanExp.RightOperand.OperandProperty = OperandProperty.Literal;
            lessThanExp.RightOperand.Value = "2";

            bool target = lessThanExp.Evaluate(eventContext);
            Assert.IsFalse(target);

            // Do int comparison
            lessThanExp = new LessOrEqualExpression();
            lessThanExp.OperandType = OperandType.Int32;

            lessThanExp.LeftOperand = new Operand();
            lessThanExp.LeftOperand.OperandProperty = OperandProperty.Event;
            lessThanExp.LeftOperand.Name = "/Event/Property[Score]";

            lessThanExp.RightOperand = new Operand();
            lessThanExp.RightOperand.OperandProperty = OperandProperty.Literal;
            lessThanExp.RightOperand.Value = "1000";

            target = lessThanExp.Evaluate(eventContext);
            Assert.IsTrue(target);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\DecisionTreeTests.cs ===
﻿namespace RulesLibrary.Test
{
    using System;
    using System.Threading;
    using GameMetadata.Client;
    using Gds.ActionEngine;
    using Gds.DataAccess.Rewards;
    using Gds.DataAccess.Rules;
    using GDS.DataAccess.UserData;
    using Gds.Mocks;
    using Gds.RulesLibrary;
    using Leet.Core.IoCCo;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Leet.Core.Configuration;

    /// <summary>
    /// Summary description for DecisionTreeTests
    /// </summary>
    [TestClass]
    public class DecisionTreeTests
    {
        public DecisionTreeTests()
        {
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext) 
        {
            Console.WriteLine("MyClassInitialize");
            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();
            Container.Instance.AddService<IUserDataStorage, MockUserDataStorage>();
            Container.Instance.AddService<IRewardsQueueReader, InMemoryRewardsQueueReader>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<IActionEngine, TestActionEngine>();
            Container.Instance.AddService<IRulesStorage, MockRulesStorage>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
        }

        //
        // Use ClassCleanup to run code after all tests in a class have run
        [ClassCleanup()]
        public static void MyClassCleanup() 
        { 
        }


        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void DecisionTreeTest()
        {
            RulesDecisionTree decisionTree = new RulesDecisionTree();
            Assert.IsNotNull(decisionTree);
        }

        [TestMethod]
        public void DecisionTreeToStringTest()
        {
            RulesDecisionTree decisionTree = new RulesDecisionTree();
            Assert.IsNotNull(decisionTree);

            string decisionTreeString = decisionTree.ToString();
            Assert.IsNotNull(decisionTreeString);
        }

        [TestMethod]
        public void RefreshDataFromDBTest()
        {
            RulesDecisionTree decisionTree = new RulesDecisionTree();
            Assert.IsNotNull(decisionTree);

            Thread.Sleep(65000);

            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameId>1</GameId>
                                  <PlatformId>1</PlatformId>
                                  <UserId>1</UserId>
                                  <GameSessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</GameSessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Variant</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>0</Value>
                                    </Property>
                                    <Property>
                                      <Name>LifeTimeScore</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>1000</Value>
                                    </Property>
                                    <Property>
                                      <Name>Time</Name>
                                      <PropertyType>System.Int64</PropertyType>
                                      <Value>1000</Value>
                                    </Property>
                                    <Property>
                                      <Name>Outcome</Name>
                                      <PropertyType>System.string</PropertyType>
                                      <Value>Win</Value>
                                    </Property>
                                    <Property>
                                      <Name>Blob</Name>
                                      <PropertyType>System.string</PropertyType>
                                      <Value>YmxvYg==</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            bool booleanValue = decisionTree.Evaluate(eventXml);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\RulesLibraryConfigTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Gds.RulesLibrary;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Configuration;

namespace RulesLibrary.Test
{
    /// <summary>
    /// Summary description for RulesLibraryConfigTests
    /// </summary>
    [TestClass]
    public class RulesLibraryConfigTests
    {
        public RulesLibraryConfigTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void GetDecisionTreeConfigurationSettingsTest()
        {
            string treeName = null;
            string[] standardlevels = RulesLibraryConfig.GetDecisionTreeConfigurationSettings(out treeName);
            int expected = 2;
            Assert.AreEqual(expected, standardlevels.Count());
            Assert.AreEqual("DecisionTree1", treeName);
        }

        [TestMethod]
        public void StandardLevelsSectionConstructorTest()
        {
            StandardLevelsSection section = new StandardLevelsSection();
            Assert.IsNotNull(section);
            Assert.IsTrue(string.IsNullOrEmpty(section.Name));
            Assert.IsNotNull(section.StandardLevels);
        }

        [TestMethod]
        public void StandardLevelsSectionPropertiesTest()
        {
            StandardLevelsSection standardLevelSection = 
                ConfigurationManager.GetSection("StandardLevels") as StandardLevelsSection;
            Assert.IsNotNull(standardLevelSection);
            Assert.AreEqual(2, standardLevelSection.StandardLevels.Count);

            // test ordering

            for (int i = 0; i < standardLevelSection.StandardLevels.Count; i++)
            {
                StandardLevelElement standardLevelElement = standardLevelSection.StandardLevels[i];
                int level = standardLevelElement.Level;
                Assert.AreEqual(i+1, level);
            }

            Assert.AreEqual("/Event/Culture", standardLevelSection.StandardLevels[0].Name);
            Assert.AreEqual("/Event/GameKey", standardLevelSection.StandardLevels[1].Name);
        }

        [TestMethod]
        public void StandardLevelElementConstructorTest()
        {
            StandardLevelElement standardLevelElement = new StandardLevelElement();
            Assert.IsNotNull(standardLevelElement);
            Assert.IsTrue(string.IsNullOrEmpty(standardLevelElement.Name));
        }

        [TestMethod]
        public void StandardLevelElementPropertiesTest()
        {
            StandardLevelsSection standardLevelSection =
                ConfigurationManager.GetSection("StandardLevels") as StandardLevelsSection;
            Assert.IsNotNull(standardLevelSection);
            Assert.AreEqual(2, standardLevelSection.StandardLevels.Count);

            // test ordering

            for (int i = 0; i < standardLevelSection.StandardLevels.Count; i++)
            {
                StandardLevelElement standardLevelElement = standardLevelSection.StandardLevels[i];
                int level = standardLevelElement.Level;
                Assert.AreEqual(i + 1, level);
            }
            StandardLevelElement standardLevelElem = standardLevelSection.StandardLevels[0];
            Assert.IsNotNull(standardLevelElem.Name);
            Assert.IsNotNull(standardLevelElem.Level);
        }

        [TestMethod]
        public void StandardLevelElementCollectionConstructorTest()
        {
            StandardLevelElementCollection standardLevelElementCollection = new StandardLevelElementCollection();
            Assert.IsNotNull(standardLevelElementCollection);
        }

        [TestMethod]
        public void StandardLevelElementCollectionPropertiesTest()
        {
            StandardLevelElementCollection standardLevelElementCollection = new StandardLevelElementCollection();
            Assert.AreEqual(0, standardLevelElementCollection.Count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RulesLibrary.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7dbf6dd3-23a2-48c7-a99f-ce6f0aa2cc44")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1824:MarkAssembliesWithNeutralResourcesLanguage")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\DiagnosticData.cs ===
﻿

namespace Gds.RulesService
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public static class RulesServiceDiag
    {
        internal static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

    public class RulesServiceStarted : BaseEvent
    {
        public RulesServiceStarted()
            : base(30000, TraceEventType.Start, "Rules service leaderboard stats processing started.")
        {
        }
    }

    public class RulesServiceStartupFailure : BaseEvent
    {
        public RulesServiceStartupFailure()
            : base(30001, TraceEventType.Error, "An exception occurred while starting the service.")
        {
        }
    }

    public class RulesServiceStopped : BaseEvent
    {
        public RulesServiceStopped()
            : base(30002, TraceEventType.Stop, "Rules service leaderboard stats processing stopped.")
        {
        }
    }

    public class RulesServiceStoppedFailure : BaseEvent
    {
        public RulesServiceStoppedFailure()
            : base(30003, TraceEventType.Error, "An exception occurred while stopping Rules service.")
        {
        }
    }

    public class SqlExceptionError : BaseEvent
    {
        public SqlExceptionError()
            : base(30004, TraceEventType.Error, "A Sql exception has occurred.")
        {
        }
    }

    public class QueueDisabledError : BaseEvent
    {
        public QueueDisabledError()
            : base(30005, TraceEventType.Error, "The SQL service broker queue is disabled.")
        {
        }
    }

    public class RulesDriverInitializationFailed : BaseEvent
    {
        public RulesDriverInitializationFailed()
            : base(30006, TraceEventType.Error, "The Rules driver failed to initialize.")
        {
        }
    }

    public class BadMessageRetrieved : BaseEvent
    {
        public BadMessageRetrieved()
            : base(30007, TraceEventType.Error, "A bad message was retrieved from the SQL broker queue.")
        {
        }
    }

    public class EvaluateGameEventFailed : BaseEvent
    {
        public EvaluateGameEventFailed()
            : base(30008, TraceEventType.Error, "An exception occurred while evaluating a game event.")
        {
        }
    }

    public class UnknownExceptionFromQueueRead : BaseEvent
    {
        public UnknownExceptionFromQueueRead()
            : base(30009, System.Diagnostics.TraceEventType.Error, "An unknown exception occurred while reading from the SQL broker queue")
        {
        }
    }

    public class RetriableExceptionFromEvaluateGameEvent : BaseEvent
    {
        public RetriableExceptionFromEvaluateGameEvent()
            : base(30010, System.Diagnostics.TraceEventType.Warning, "Retriable exception is caught in EvaluateGameEvent function")
        {
        }
    }

    public class NonRetriableExceptionFromEvaluateGameEvent : BaseEvent
    {
        public NonRetriableExceptionFromEvaluateGameEvent()
            : base(30011, System.Diagnostics.TraceEventType.Error, "Non-Retriable exception is caught in EvaluateGameEvent function")
        {
        }
    }

    public class SqlConnectionLeakedError : BaseEvent
    {
        public SqlConnectionLeakedError()
            : base(30301, TraceEventType.Error, "A SqlConnection leaked, it may cause the service to hang/become unresponsive.")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\TreeNodeListTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Gds.RulesLibrary;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace RulesLibrary.Test
{
    /// <summary>
    /// Summary description for TreeNodeListTests
    /// </summary>
    [TestClass]
    public class TreeNodeListTests
    {
        public TreeNodeListTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TreeNodeListConstructorTest()
        {
            string parentString = "parent";
            TreeNode<string> parent = new TreeNode<string>(parentString);
            TreeNodeList<string> nodeList = new TreeNodeList<string>(parent);
            Assert.IsNotNull(nodeList);
            Assert.IsNotNull(nodeList.Parent);
        }

        [TestMethod]
        public void TreeNodeListAddTest()
        {
            string parentString = "parent";
            TreeNode<string> parent = new TreeNode<string>(parentString);
            TreeNodeList<string> nodeList = new TreeNodeList<string>(parent);
            Assert.IsNotNull(nodeList);
            Assert.IsNotNull(nodeList.Parent);
            nodeList.Add(new TreeNode<string>("child1"));
            Assert.IsTrue(nodeList.Count == 1);
        }

        [TestMethod]
        public void TreeNodeListToStringTest()
        {
            string parentString = "parent";
            TreeNode<string> parent = new TreeNode<string>(parentString);
            TreeNodeList<string> nodeList = new TreeNodeList<string>(parent);
            Assert.IsNotNull(nodeList);
            Assert.IsNotNull(nodeList.Parent);
            TreeNode<string> child = new TreeNode<string>("child1");
            nodeList.Add(child);
            string toString = nodeList.ToString();
            Assert.IsNotNull(toString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\RuleTest.cs ===
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Gds.RulesLibrary;
using Microsoft.VisualStudio.TestTools.UnitTesting;


namespace RulesLibrary.Test
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class RuleTest
    {
        public RuleTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void RuleConstructorTest()
        {
            XmlDocument ruleStatementXML = null;
            XmlDocument actionStatementXML = null;
            Rule rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);

            ruleStatementXML = new XmlDocument();
            actionStatementXML = new XmlDocument();
            ruleStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUALTO</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>");
            actionStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?><ActionContext></ActionContext>");
            rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);
        }

        [TestMethod]
        public void RuleConstructor1Test()
        {
            XmlDocument ruleStatementXML = null;
            XmlDocument actionStatementXML = null;
            Rule rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);

            ruleStatementXML = new XmlDocument();
            actionStatementXML = new XmlDocument();
            ruleStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>LESSERTHANOREQUALTO</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>");
            actionStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?><ActionContext></ActionContext>");
            rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);
            string toString = rule.ToString();
            Assert.IsNotNull(toString);
        }

        [TestMethod]
        public void EvaluateFalseTest()
        {
            string xmlString = @"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUALTO</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>";

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);

            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>LifeTimeScore</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>1000</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            EventContext eventContext = new EventContext(eventXml);

            XmlDocument actionContextXML = new XmlDocument();

            Rule rule = new Rule(xmlDoc, actionContextXML);
            bool target = rule.Evaluate(eventContext);

            Assert.IsFalse(target);
        }

        [TestMethod]
        public void EvaluateTrueTest()
        {
            string xmlString = @"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='System.String'>
                                        <LeftOperand type='Event'>/Event/Culture</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>en-US</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='System.String'>
                                        <LeftOperand type='Event'>/Event/GameKey</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>1</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='System.Int32'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>20000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>";

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);

            string eventXml = @"<GameEvent 
  xmlns='http://schemas.datacontract.org/2004/07/Wgx.Services.Gds.BusinessObjects' 
  xmlns:i='http://www.w3.org/2001/XMLSchema-instance'>

                                  <Culture>en-US</Culture>
                                  <GameKey>1</GameKey>
                                  <Platform>MSN</Platform>
                                  <LivePuid>1</LivePuid>
                                  <SessionId>5abf78f0-05f7-40c7-bc78-a167c3d70b5a</SessionId>
                                  <GameEventId>e4646ea1-edbf-4581-a6a7-a748db74b5b6</GameEventId>
                                  <EventCategory>Score</EventCategory>
                                  <PropertySchemaName>MSN.StandardScore</PropertySchemaName>
                                  <TimeStamp>2009-04-09T14:52:49.7108901-07:00</TimeStamp>
                                  <Properties>
                                    <Property>
                                      <Name>Score</Name>
                                      <PropertyType>System.Int32</PropertyType>
                                      <Value>20000</Value>
                                    </Property>
                                  </Properties>
                                </GameEvent>";
            EventContext eventContext = new EventContext(eventXml);

            XmlDocument actionContextXML = new XmlDocument();

            Rule rule = new Rule(xmlDoc, actionContextXML);
            bool target = false;
            try
            {
                target = rule.Evaluate(eventContext);
            }
            catch (Exception)
            {
                
                throw;
            }
            Assert.IsTrue(target);
        }

        [TestMethod]
        public void ToStringTest()
        {
            string xmlString = @"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='System.String'>
                                        <LeftOperand type='Event'>/Event/Culture</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>en-US</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='System.String'>
                                        <LeftOperand type='Event'>/Event/GameKey</LeftOperand>
                                        <Operator>EQUALTO</Operator>
                                        <RightOperand type='Literal'>1</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='System.Int32'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUALTO</Operator>
                                        <RightOperand type='Literal'>20000</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='System.Int32'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>LESSTHANOREQUALTO</Operator>
                                        <RightOperand type='Literal'>100000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>";

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);

            XmlDocument actionContextXML = new XmlDocument();

            Rule rule = new Rule(xmlDoc, actionContextXML);

            string toString = rule.ToString();
            Assert.IsNotNull(toString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\RuleTests.cs ===
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using RulesLibrary;


namespace RulesLibrary.Test
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class RuleTest
    {
        public RuleTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void RuleConstructorTest()
        {
            XmlDocument ruleStatementXML = null;
            XmlDocument actionStatementXML = null;
            Rule rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);

            ruleStatementXML = new XmlDocument();
            actionStatementXML = new XmlDocument();
            ruleStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUAL</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>");
            actionStatementXML.LoadXml(@"<?xml version='1.0' encoding='utf-8'?><ActionContext></ActionContext>");
            rule = new Rule(ruleStatementXML, actionStatementXML);
            Assert.IsNotNull(rule);
        }

        [TestMethod]
        public void EvaluateFalseTest()
        {
            string xmlString = @"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUAL</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>";

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);

            Hashtable eventContext = new Hashtable();
            eventContext["/Event/PublisherID"] = "Oberon";
            eventContext["/Event/GameID"] = "Hexic";
            eventContext["/Event/Property[Score]"] = "111";
            XmlDocument actionContextXML = new XmlDocument();

            Rule rule = new Rule(xmlDoc, actionContextXML);
            bool target = rule.Evaluate(eventContext);

            Assert.IsFalse(target);
        }

        [TestMethod]
        public void EvaluateTrueTest()
        {
            string xmlString = @"<?xml version='1.0' encoding='utf-8'?>
                                    <RuleStatement>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/PublisherID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Oberon</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='string'>
                                        <LeftOperand type='Event'>/Event/GameID</LeftOperand>
                                        <Operator>EQUALS</Operator>
                                        <RightOperand type='Literal'>Hexic</RightOperand>
                                      </RuleExpression>
                                      <RuleExpression type='int'>
                                        <LeftOperand type='Event'>/Event/Property[Score]</LeftOperand>
                                        <Operator>GREATERTHANOREQUAL</Operator>
                                        <RightOperand type='Literal'>1000</RightOperand>
                                      </RuleExpression>
                                    </RuleStatement>";

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);

            Hashtable eventContext = new Hashtable();
            eventContext["/Event/PublisherID"] = "Oberon";
            eventContext["/Event/GameID"] = "Hexic";
            eventContext["/Event/Property[Score]"] = "20000";
            XmlDocument actionContextXML = new XmlDocument();

            Rule rule = new Rule(xmlDoc, actionContextXML);
            bool target = rule.Evaluate(eventContext);

            Assert.IsTrue(target);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesLibrary.Test\TreeNodeTests.cs ===
﻿

namespace RulesLibrary.Test
{
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Gds.RulesLibrary;

    /// <summary>
    /// Summary description for TreeNodeUnitTests
    /// </summary>
    [TestClass]
    public class TreeNodeTests
    {
        public TreeNodeTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TreeNodeConstructorTest()
        {
            TreeNode<string> node = new TreeNode<string>();
            Assert.IsNotNull(node);
        }

        [TestMethod]
        public void TreeNodeConstructor1Test()
        {
            string tValue = "expected";
            TreeNode<string> node = new TreeNode<string>(tValue);
            Assert.IsNotNull(node);
            Assert.AreEqual(tValue, node.Value.ToString());
        }

        [TestMethod]
        public void TreeNodeConstructor2Test()
        {
            string tValue = "parent";
            TreeNode<string> parentNode = new TreeNode<string>(tValue);
            TreeNode<string> node = new TreeNode<string>(parentNode);
            Assert.AreEqual(1, parentNode.Children.Count);
        }

        [TestMethod]
        public void TreeNodeGetRootTest()
        {
            string tValue = "parent";
            TreeNode<string> parentNode = new TreeNode<string>(tValue);
            TreeNode<string> node = new TreeNode<string>(parentNode);
            Assert.AreEqual(1, parentNode.Children.Count);
            TreeNode<string> root = node.Root;
            Assert.IsNotNull(root);
            Assert.AreEqual("parent", root.Value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\ProjectInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;

namespace Gds.RulesService
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible"), RunInstaller(true)]
    public partial class ProjectInstaller : Installer
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily")]
        public ProjectInstaller()
        {
            this.InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesEvents.cs ===
﻿using System.Diagnostics;
using Wgx.Services.Monitoring;

namespace Gds.RulesService
{
    // This class implements all the core rewards events
    [EventCategory(MessageIdBase = 30000, IncrementAmount = 10)]
    public static class RulesEvents
    {
        public static void Initialize(string eventSource)
        {
            // Initialize Event Source
            rulesTraceSource = new WgxTraceSource(eventSource);
            Events = rulesTraceSource.GetEventsCollection(typeof(RulesEvents));
        }

        public static EventsCollection Events
        {
            get { return rulesEventsCollection; }
            set { rulesEventsCollection = value; }
        }

        private static WgxTraceSource rulesTraceSource;
        private static EventsCollection rulesEventsCollection;

        #region RulesEvents

        /// <summary>
        /// Notification Service Started
        /// </summary>
        [Event(MessageId = -1, Message = "Rules service started.", TraceEventType = TraceEventType.Information)]
        public static int ServiceStarted = 0;

        /// <summary>
        /// Notification Service Stopped
        /// </summary>
        [Event(MessageId = -1, Message = "Rules service stopped.", TraceEventType = TraceEventType.Information)]
        public static int ServiceStopped = 1;

        /// <summary>
        /// Loaded Configuration provider
        /// </summary>
        [Event(MessageId = -1, Message = "Loaded configuration provider: {0}", TraceEventType = TraceEventType.Information)]
        public static int LoadedConfigProviderEvent = 2;

        /// <summary>
        /// Set updated warned event
        /// </summary>
        [Event(MessageId = -1, Message = "Setting value has been updated and change has been vetoed. Restart the service to apply new setting\n" +
            "Setting Name: {0}\nSetting Value (old): {1}\nSetting Value (new): {2}", TraceEventType = TraceEventType.Warning)]
        public static int SettingUpdatedWarningEvent = 3;

        /// <summary>
        /// Exception in loading config
        /// </summary>
        [Event(MessageId = -1, Message = "Critical Exception during configuration provider setup: {0}\n{1}", TraceEventType = TraceEventType.Error)]
        public static int LoadConfigProviderExceptionEvent = 4;

        /// <summary>
        /// Sql exception
        /// </summary>
        [Event(MessageId = -1, Message = "Sql Exception Error: {0}\n", TraceEventType = TraceEventType.Error)]
        public static int SqlExceptionError = 5;

        /// <summary>
        /// Unexpected failure
        /// </summary>
        [Event(MessageId = -1, Message = "Unexpected failure.", TraceEventType = TraceEventType.Error)]
        public static int UnexpectedFailure = 6;

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesDriver.cs ===
﻿
namespace Gds.RulesService
{
    using System;
    using System.Diagnostics;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Threading;
    using Gds.ActionEngine;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Gds.RulesLibrary;
    using Leet.Core.IoCCo;
    using Leet.Health.Common;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable")]
    internal class RulesDriver
    {
        /// <summary>
        /// Rules driver instance
        /// </summary>
        private static RulesDriver instance;
        
        /// <summary>
        /// Notifies one or more waiting threads that an event has occurred
        /// </summary>
        private ManualResetEvent shutdownEvent;

        int delay, nextVal;
        public static int messagesProcessing; // the number of messages processing at a given instance
        public static long messagesProcessed; // the number of messages processed
        public static long messagesFailed; // the number of messages failed
        bool doShutdown;

        private static List<Type> retriableExceptionList; // list of retriable exceptions

        // delegates for transaction handling/retrying
        private static Action<IActionEngine, GameEvent> retryDelegate;
        private static Action<SqlConnection, SqlTransaction> commitDelegate;
        private static Action<SqlConnection, SqlTransaction, GameEvent> rollbackDelegate;
        private static Action<string, Exception, bool> exceptionLogger;
        private int maxConcurrentThreads;

        // Retry Controller settings
        private const int RetryMax = 1200;           // retry for 1200 times
        private const int RetryFrequency = 30;    // wait for 30 seconds before next retry

        public static RulesLibraryCounters RulesLibraryCounters { get; set; }

        /// <summary>
        /// Prevents a default instance of the RulesDriver class from being created.
        /// </summary>
        private RulesDriver()
        {
            this.delay = 0;
            this.nextVal = 1;
            this.doShutdown = false;
            RulesDriver.messagesProcessing = 0;
            this.shutdownEvent = new ManualResetEvent(false);
            this.maxConcurrentThreads = RulesServiceConfig.RulesServiceMaxConcurrentThreads;
            RulesDriver.RulesLibraryCounters = new RulesLibraryCounters();
            RulesService.TraceThreads();
        }

        /// <summary>
        /// Gets an instance of the rules driver
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static RulesDriver Instance
        {
            get
            {
                if (RulesDriver.instance == null)
                {
                    RulesDriver.Initialize();
                }

                return RulesDriver.instance;
            }
        }

        /// <summary>
        /// Returns true if instance is alreade created
        /// </summary>
        /// <returns></returns>
        public static bool IsInstanceCreated()
        {
            if (RulesDriver.instance == null)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Gets rewards queue where events are read from
        /// </summary>
        private static IRewardsQueueReader RewardsQueueReader
        {
            get
            {
                return Container.Instance.GetComponent<IRewardsQueueReader>();
            }
        }

        /// <summary>
        /// Gets rewards jail queue where problematic events are written to.
        /// </summary>
        private static IRewardsQueueWriter RewardsJailQueueWriter
        {
            get
            {
                return Container.Instance.GetComponent<IRewardsQueueWriter>();
            }
        }

        private static IActionEngine ActionEngine { get; set; }

        /// <summary>
        /// Reads events from the queue and evaluates them against rules
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public void Run()
        {
            GameEvent gameEvent = null;

            SqlConnection sqlConnection = null;
            try
            {
                SqlTransaction sqlTransaction = null;

                bool resetDelay = true;
                // Retrieve a message from the queue
                try
                {
                    gameEvent = RulesDriver.RewardsQueueReader.Read(new TimeSpan(0, 0, 1), ref sqlConnection, ref sqlTransaction);
                }
                catch (SqlException sqlException)
                {
                    RulesService.HandleSqlException("RulesDriver.Run()", sqlException);
                    this.UpdateDelay();
                    resetDelay = false;
                }
                catch (RewardsDataAccessOperationException rdaoe)
                {
                    // A bad message was returned in the queue
                    RulesServiceDiag.Logging.LogEvent(new BadMessageRetrieved(), rdaoe);
                }
                catch (Exception ex)
                {
                    RulesServiceDiag.Logging.LogEvent(new UnknownExceptionFromQueueRead(), ex);
                    throw new RewardsDataAccessException("An unknown exception ocurred while reading from the queue", ex);
                }
                finally
                {
                    this.DispatchProcessorThread();
                }

                try
                {
                    if (gameEvent != null)
                    {
                        Interlocked.Increment(ref RulesDriver.messagesProcessing);

                        // Use the generic transaction handler for retrying transactions
                        // Retrying RetryMax times with RetryFrequency seconds
                        GdsRetryController.Retry(
                            RetryMax,
                            RetryFrequency,
                            retriableExceptionList,
                            (Exception ex, bool retriable) => exceptionLogger("ActionEngine.Execute()", ex, retriable),
                            () => retryDelegate(RulesDriver.ActionEngine, gameEvent),
                            () => commitDelegate(sqlConnection, sqlTransaction),
                            () => rollbackDelegate(sqlConnection, sqlTransaction, gameEvent));
                    }
                    else
                    {
                        // No exceptions from QueueReader.Read
                        CommitSQLTransaction(sqlConnection, sqlTransaction);
                    }

                    // Reset delay upon success
                    if (resetDelay)
                    {
                        this.delay = 0;
                        this.nextVal = 1;
                    }
                }
                catch (Exception ex)
                {
                    RulesServiceDiag.Logging.LogEvent(new EvaluateGameEventFailed(), ex);
                    this.UpdateDelay();
                }
                finally
                {
                    if (gameEvent != null)
                    {
                        Interlocked.Decrement(ref RulesDriver.messagesProcessing);
                    }
                }
            }
            catch (RewardsDataAccessException ex)
            {
                // recoverable (SQL timeout) or nonrecoverable exception is caught in a thread
                // we are simply going to log and stay alive
                // if the exception is non-recoverable (like SQL going down) alert will notify OPS to investigate
                RulesServiceDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, ex);
            }
            finally
            {
                try
                {
                    // Log errors if SQL connection are NOT closed.
                    if (sqlConnection != null)
                    {
                        if (sqlConnection.State != System.Data.ConnectionState.Closed)
                        {
                            string gameEventId = (gameEvent != null) ? gameEvent.GameEventId.ToString() : "(null)";
                            string sqlConnDetails = string.Format(
                                                            "Connection String: {0} | Connection State: {1} | GameId: {2}", 
                                                            sqlConnection.ConnectionString,
                                                            sqlConnection.State,
                                                            (gameEvent != null) ? gameEvent.GameId.ToString() : "(null)");
                            RulesServiceDiag.Logging.LogEvent(
                                new SqlConnectionLeakedError(), "The leak happened when GameEvent: {0} was being processed. Details: {1}", gameEventId, sqlConnDetails);
                        }
                    }
                }
                catch (Exception)
                {
                    // Ignore all exceptions.
                }

                if (this.doShutdown && RulesDriver.messagesProcessing == 0)
                {
                    // Signal shudownEvent
                    this.shutdownEvent.Set();
                }
            }
        }

        private void DispatchProcessorThread()
        {
            if (this.delay > 0)
            {
                int whatsLeft = this.delay;

                while (whatsLeft > 0)
                {
                    int sleepVal;

                    sleepVal = whatsLeft > 15 ? 15 : whatsLeft;

                    if (this.doShutdown)
                    {
                        break;
                    }

                    if (sleepVal > 0)
                    {
                        Thread.Sleep(sleepVal * 1000);
                    }

                    whatsLeft = whatsLeft - 15;
                }
            }

            if (!this.doShutdown)
            {
                ThreadPool.QueueUserWorkItem(
                    delegate(object obj)
                    {
                        try
                        {
                            RulesDriver.Instance.Run();
                        }
                        catch (Exception ex)
                        {
                            RulesServiceDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, ex);
                            System.Console.WriteLine("OnStart: " + ex.ToString());

                            // this can happen only if we cannot initialize the RulesDriver.Instance
                            // stop the service and abort the thread (throwing here doesn't do anything)
                            this.Stop();
                            Thread.CurrentThread.Abort();
                        }
                    },
                    null);
            }
        }

        /// <summary>
        /// Signals that the service is stopping
        /// </summary>
        public void Stop()
        {
            this.shutdownEvent.Reset();
            this.doShutdown = true;
            GdsRetryController.StopRetrying();
            this.shutdownEvent.WaitOne();
        }

        /// <summary>
        /// Initializes decision tree
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private static void Initialize()
        {
            try
            {
                RulesDriver rd = new RulesDriver();

                if (Interlocked.CompareExchange(ref RulesDriver.instance, rd, null) == null)
                {
                    IActionEngine actionEngine = Container.Instance.GetComponent<IActionEngine>();
                    RulesDriver.ActionEngine = actionEngine;
                }

                // create the list of retriable exceptions
                retriableExceptionList = new List<Type>();
                retriableExceptionList.Add(typeof(Gds.DataAccess.Rewards.RewardsDataAccessException));
                retriableExceptionList.Add(typeof(System.Data.SqlClient.SqlException));
                retriableExceptionList.Add(typeof(Gds.ActionEngine.ActionEngineException));
                retriableExceptionList.Add(typeof(Gds.ActionEngine.ActionEngineOperationException));

                // initialize the delegates
                retryDelegate = EvaluateGameEvent;
                commitDelegate = CommitSQLTransaction;
                rollbackDelegate = PutMessageOnJailQueue;
                exceptionLogger = HandleDecisionTreeException;

                // initialize the health listner
                try
                {
                    string healthCheckPort = RulesLibraryConfig.GetHealthCheckHighPort();
                    // invoke the health listner only when port can be found in app.config
                    if (String.IsNullOrEmpty(healthCheckPort))
                    {
                        RulesServiceDiag.Logging.LogTrace(TraceLevel.Error, "healthCheckPort is empty", null);
                    }
                    else
                    {
                        ushort listnerPort = UInt16.Parse(healthCheckPort);
                        HealthListener.InitializeHealthListener(RulesServiceConfig.ServiceName, listnerPort);
                    }
                }
                catch (Exception ex)
                {
                    // we should let the Rules Service run
                    // any exception caught here can only be due to bad configuration which should not happen
                    RulesServiceDiag.Logging.LogTrace(TraceLevel.Error, ex, "healthCheckPort is empty", null);
                }
            }
            catch (SqlException sqlEx)
            {
                RulesService.HandleSqlException("RulesDriver.Initialize()", sqlEx);
                throw;
            }
            catch (Exception ex)
            {
                RulesServiceDiag.Logging.LogEvent(new RulesDriverInitializationFailed(), ex);
                throw;
            }
        }

        public static void CommitSQLTransaction(SqlConnection sqlConnection, SqlTransaction sqlTransaction)
        {
            // it is possible to get exceptions here (for example SQL server going down) catch them, don't throw
            try
            {
                RulesDriver.RewardsQueueReader.Commit(ref sqlConnection, ref sqlTransaction);
            }
            catch (SqlException sqlException)
            {
                RulesService.HandleSqlException("CommitSQLTransaction", sqlException);
            }
        }

        public static void RollbackSQLTransaction(SqlConnection sqlConnection, SqlTransaction sqlTransaction)
        {
            // it is possible to get exceptions here (for example SQL server going down) catch them, don't throw
            try
            {
                RulesDriver.RewardsQueueReader.Rollback(ref sqlConnection, ref sqlTransaction);
            }
            catch (SqlException sqlException)
            {
                RulesService.HandleSqlException("RollbackSQLTransaction", sqlException);
            }
        }

        public static void PutMessageOnJailQueue(SqlConnection sqlConnection, SqlTransaction sqlTransaction, GameEvent gameEvent)
        {
            // it is possible to get exceptions here (for example SQL server going down) catch them, don't throw
            try
            {
                // Put the message onto the jail queue and commit the transcation on the primary queue.
                RulesDriver.RewardsJailQueueWriter.WriteToJail(gameEvent);
                RulesDriver.RewardsQueueReader.Commit(ref sqlConnection, ref sqlTransaction);
            }
            catch (SqlException sqlException)
            {
                RulesService.HandleSqlException("PutMessageOnJailQueue", sqlException);
            }
        }

        public static void EvaluateGameEvent(IActionEngine decisionTree, GameEvent ge)
        {
            bool requestFailed = false;

            try
            {
                RulesDriver.RulesLibraryCounters.StartRequest(RulesLibraryMethod.ExecuteAction); 

                string geString = SerializerDeserializer.SerializeToString(ge);
                RulesDriver.ActionEngine.Execute(string.Empty, geString);
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                RulesDriver.RulesLibraryCounters.EndRequest(requestFailed);

                // update messagesFailed and messagesProcessed
                if (requestFailed)
                {
                    Interlocked.Increment(ref RulesDriver.messagesFailed);
                }
                else
                {
                    Interlocked.Increment(ref RulesDriver.messagesProcessed);
                }
            }
        }

        private void UpdateDelay()
        {
            if (this.delay < 120)
            {
                int tmp = this.nextVal;
                this.nextVal = this.delay + this.nextVal;
                this.delay = tmp;
            }
        }

        public static void HandleDecisionTreeException(string methodName, Exception exception, bool retriable)
        {
            if (retriable)
            {
                RulesServiceDiag.Logging.LogEvent(new RetriableExceptionFromEvaluateGameEvent(), exception);
            }
            else
            {
                RulesServiceDiag.Logging.LogEvent(new NonRetriableExceptionFromEvaluateGameEvent(), exception);
            }

            RulesServiceDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, exception);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesService.cs ===
﻿

namespace Gds.RulesService
{
    using System;
    using System.Data.SqlClient;
    using System.ServiceProcess;
    using System.Threading;
    using GameMetadata.Client;
    using Gds.ActionEngine;
    using Gds.DataAccess.Rewards;
    using Gds.DataAccess.Rules;
    using GDS.DataAccess.UserData;
    using Gds.RulesLibrary;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.TestSupport;
    using Leet.Live.Livecache;
    using Leet.Utils;
    using Gds.DataAccess.UserData;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// Rules service class
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Interoperability", "CA1405:ComVisibleTypeBaseTypesShouldBeComVisible")]
    public partial class RulesService : ServiceBase
    {
#if DEBUG
        private static bool isBeingDebugged = true;
#endif

        // Error coming from SQL exception when queue is disabled
        private const int QueueDisabledSQLError = 9617;

        /// <summary>
        /// Component name of RulesService
        /// </summary>
        public const string ComponentName = "RulesService";

        /// <summary>
        /// The event source to use.
        /// </summary>
        public const string EventSource = "gds_rules";

        /// <summary>
        /// The service base. This pointer is used for stopping the service gracefully. 
        /// </summary>
        private static System.ServiceProcess.ServiceBase serviceBase = null;

        /// <summary>
        /// Gets or sets the service base of RulesService. 
        /// </summary>
        public static System.ServiceProcess.ServiceBase ServiceBase
        {
            get { return RulesService.serviceBase; }
            set { RulesService.serviceBase = value; }
        }

        /// <summary>
        /// Constructor of Rules service
        /// </summary>
        public RulesService()
        {
            this.InitializeComponent();
        }

        /// <summary>
        /// The main entry point for the application
        /// </summary>
        /// <param name="args">Arguments of the main application</param>
        static void Main(string[] args)
        {
            try
            {
                if (args.Length == 0)
                {
                    // Run as a service
                    ServiceBase[] servicesToRun;
                    RulesService.ServiceBase = new RulesService();
                    servicesToRun = new ServiceBase[] { RulesService.ServiceBase };
                    ServiceBase.Run(servicesToRun);
                }
                else
                {
                    System.Console.WriteLine("Starting rules service...");

                    // Run as a console application
                    RulesService rulesService = new RulesService();

                    rulesService.OnStart(null);
#if DEBUG
                    LoopWhileDebugging();
#endif
                    // Wait for a keypress to kill the service
                    Console.WriteLine("Hit 'Enter' To Kill The Service");
                    Console.ReadLine();

                    rulesService.OnStop();
                }
            }
            catch (Exception ex)
            {
                RulesServiceDiag.Logging.LogEvent(new RulesServiceStartupFailure(), ex);
            }
        }

#if DEBUG
        private static void LoopWhileDebugging()
        {
            do
            {
                Thread.Sleep(10);
            } 
            while (RulesService.isBeingDebugged);
        }
#endif
        /// <summary>
        /// The overrided OnStart method that intializes the threadpool
        /// </summary>
        /// <param name="args">Argument list</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected override void OnStart(string[] args)
        {
            try
            {
                Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
                Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();

                // Initialize event system.
                RulesEvents.Initialize(EventSource);

                InitializeLiveCacheInterfaces();
                RegisterGameMetadataInterfaces();
                RulesService.RegisterRewardsQueueInterfaces();
                RulesService.RegisterActionEngineInterfaces();
                RulesService.RegisterRulesInterface();

                // Start the queue work item in thread pool
                ThreadPool.SetMinThreads(RulesServiceConfig.RulesServiceMinIdleThreads, RulesServiceConfig.RulesServiceMinIdleThreads);
                ThreadPool.SetMaxThreads(RulesServiceConfig.RulesServiceMaxConcurrentThreads, RulesServiceConfig.RulesServiceMaxConcurrentThreads);

                RulesServiceDiag.Logging.LogEvent(new RulesServiceStarted());

                ThreadPool.QueueUserWorkItem(
                    delegate(object obj)
                    {
                        try
                        {
                            RulesDriver.Instance.Run();
                        }
                        catch (Exception ex)
                        {
                            RulesServiceDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Error, ex);
                            System.Console.WriteLine("OnStart: " + ex.ToString());
                            
                            // this can happen only if we cannot initialize the RulesDriver.Instance
                            // stop the service and abort the thread (throwing here doesn't do anything)
                            this.Stop(); 
                            Thread.CurrentThread.Abort();
                        }
                    }, 
                    null);
            }
            catch (Exception ex)
            {
                RulesServiceDiag.Logging.LogEvent(new RulesServiceStartupFailure(), ex);
                throw;
            }
        }


        /// <summary>
        /// Provide a way to gracefully stop the service. 
        /// </summary>
        public static void StopService()
        {
            RulesService.ServiceBase.Stop();
        }

        /// <summary>
        /// The overrided OnStop method
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected override void OnStop()
        {
            try
            {
                // We need to call RulesDriver.Instance.Stop() only if the instance is created sucessfully
                // Otherwise RulesDriver.Instance will try to reinitialize and we will get into a loop
                if (RulesDriver.IsInstanceCreated() == true)
                {
                    RulesDriver.Instance.Stop();
                }
                RulesServiceDiag.Logging.LogEvent(new RulesServiceStopped());
                RulesService.TraceThreads();
            }
            catch (SqlException sqlException)
            {
                HandleSqlException("RulesService.OnStop()", sqlException);
            }
            catch (Exception ex)
            {
                RulesServiceDiag.Logging.LogEvent(new RulesServiceStoppedFailure(), ex);
                throw;
            }
        }

        public static void TraceThreads()
        {
            int maxThreads, maxIOThreads, availableThreads, availableIOThreads, minThreads, minIOThreads;

            ThreadPool.GetMaxThreads(out maxThreads, out maxIOThreads);
            ThreadPool.GetAvailableThreads(out availableThreads, out availableIOThreads);
            ThreadPool.GetMinThreads(out minThreads, out minIOThreads);

            string message = string.Format(
                                    "ThreadStats: MaxThreads: {0}, MinThreads: {1}, AvailableThreads: {2}, ThreadsInUse: {3} AvailableIOThreads: {4}",
                                    maxThreads,
                                    minThreads,
                                    availableThreads,
                                    maxThreads - availableThreads,
                                    availableIOThreads);

            RulesServiceDiag.Logging.LogTrace(System.Diagnostics.TraceLevel.Verbose, message);
        }

        /// <summary>
        /// Handles exceptions by tracing and eventlogging
        /// </summary>
        /// <param name="methodName">
        /// Name of the method from which exception is thrown.
        /// </param>
        /// <param name="sqlException">SqlException object</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        public static void HandleSqlException(string methodName, SqlException sqlException)
        {
            if (sqlException.Errors[0].Number == QueueDisabledSQLError)
            {
                RulesServiceDiag.Logging.LogEvent(new QueueDisabledError(), sqlException);
            }
            else
            {
                RulesServiceDiag.Logging.LogEvent(new SqlExceptionError(), sqlException);
            }
        }

        private static void InitializeLiveCacheInterfaces()
        {
            Leet.Core.IoCCo.Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Leet.Core.IoCCo.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Leet.Core.IoCCo.Container.Instance.AddService<IFileSystem, FileSystem>();
            Leet.Core.IoCCo.Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
            Leet.Core.IoCCo.Container.Instance.AddService<ITestImplementationProvider, TestImplementationProvider>();
            ((NpdbConfigurationProvider)Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", "gds_rules");
            LeetLivecacheClient.RegisterServiceInterfacesAndInitialize("gds_rules");
        }

        /// <summary>
        /// Register the required baseline interfaces - These are required by the Action Engine
        /// </summary>
        private static void RegisterGameMetadataInterfaces()
        {
            // This call registers 4 interfaces to the Iocco:
            //          IEndpointConfigurator<IGameMetadataService>,
            //          IWcfProxyFactory<IGameMetadataService>,
            //          IGameMetadataService,
            //          IGameMetadataClient
            GameMetadataClient.RegisterContainerServices();
        }

        private static void RegisterRewardsQueueInterfaces()
        {
            ActionEngineFactory.RegisterActionEngineInterfaces();
        }

        private static void RegisterRulesInterface()
        {
            Leet.Core.IoCCo.Container.Instance.AddEmulatableService<IRulesStorage, RulesStorage>();
            Leet.Core.IoCCo.Container.Instance.AddService<IUserProfileStorageSimple, UserProfileStorageLivecache>();
        }

        private static void RegisterActionEngineInterfaces()
        {
            Leet.Core.IoCCo.Container.Instance.AddService<IRewardsQueueReader, RewardsQueueReader>();
            Leet.Core.IoCCo.Container.Instance.AddService<IRewardsQueueWriter, RewardsQueueWriter>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RewardService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3ef9ca49-a07b-4fa9-a705-3c81f00f5a99")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\ProjectInstaller.Designer.cs ===
﻿namespace Gds.RulesService
{
    partial class ProjectInstaller
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (this.components != null))
            {
                this.components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
            this.serviceInstaller1 = new System.ServiceProcess.ServiceInstaller();
            // 
            // serviceProcessInstaller1
            // 
            this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
            this.serviceProcessInstaller1.Password = null;
            this.serviceProcessInstaller1.Username = null;
            // 
            // serviceInstaller1
            // 
            this.serviceInstaller1.DisplayName = "Rules Service";
            this.serviceInstaller1.ServiceName = "Rules Service";
            this.serviceInstaller1.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            // 
            // ProjectInstaller
            // 
            this.Installers.AddRange(new System.Configuration.Install.Installer[] {
            this.serviceProcessInstaller1,
            this.serviceInstaller1});

        }

        #endregion

        private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
        private System.ServiceProcess.ServiceInstaller serviceInstaller1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesServiceHealth.cs ===
﻿namespace Gds.RulesService
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using Gds.Contracts;
    using GDS.DataAccess.UserData;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Health.Common;
    using Gds.DataAccess.UserData;
    using Gds.RulesLibrary;

    public class RulesServiceHealth : IHealthBlock
    {
        public static long totalMessagesProcessed;
        public static long totalMessagesFailed;

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            RulesServiceHealthReport myReport = new RulesServiceHealthReport();
            report.ExtendedReport = myReport;

            // Fill out report
            myReport.Component = config.ComponentName;

            try
            {
                myReport.MessagesProcessing = RulesDriver.messagesProcessing;
                myReport.TotalMessagesProcessed = RulesDriver.messagesProcessed;
                myReport.TotalMessagesFailedOrRetried = RulesDriver.messagesFailed;

                if (myReport.TotalMessagesProcessed > totalMessagesProcessed)
                {
                    // if we have at least 1 success since last refresh time, assume success
                    // here we need to just show some events are getting processed
                    myReport.Message = "Message processing is successful in Rules Service.";
                    report.HealthStatus = HealthStatusEnum.Green;
                }
                else if (myReport.TotalMessagesFailedOrRetried > totalMessagesFailed)
                {
                    // this means successes didn't increase and we have at least 1 failure which maybe retried
                    myReport.Message = "Some messages are failing or retried in Rules Service.";
                    report.HealthStatus = HealthStatusEnum.Red;
                }
                else
                {
                    // this means either no messages are posted or all the threads are retrying
                    // since we cannot definitely confirm this is a bad state show this as healthy
                    myReport.Message = "Rules Service is healthy.";
                    report.HealthStatus = HealthStatusEnum.Green;
                }

                totalMessagesProcessed = myReport.TotalMessagesProcessed;
                totalMessagesFailed = myReport.TotalMessagesFailedOrRetried;
            }
            catch (Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                myReport.Message = ex.ToString();
            }
        }
    }

    public class RulesServiceHealthReport : IExtendedHealthReport
    {
        /// <summary>
        /// The component name;
        /// </summary>
        public string Component { get; set; }

        /// <summary>
        /// The extended message. 
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// The number of messages getting processed
        /// </summary>
        public int MessagesProcessing { get; set; }

        /// <summary>
        /// The total messages processed
        /// </summary>
        public long TotalMessagesProcessed { get; set; }

        /// <summary>
        /// The total messages failed
        /// </summary>
        public long TotalMessagesFailedOrRetried { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesServiceConfig.cs ===
﻿using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Gds.RulesService
{
    public class RulesServiceConfig
    {
        public static int RulesServiceMinIdleThreads
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.RulesServiceMinIdleThreads);
            }
        }

        public static int RulesServiceMaxConcurrentThreads
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.RulesServiceMaxConcurrentThreads);
            }
        }

        public static string ServiceName
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.ComponentName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\RulesService\RulesService.Designer.cs ===
﻿namespace Gds.RulesService
{
    partial class RulesService
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (this.components != null))
            {
                this.components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>;
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            this.ServiceName = "Rules Service";
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DecisionTreeTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("26687bbc-b4f0-4f39-9044-770bb073b928")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\frmMain.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using System.Windows.Forms;
using RulesLibrary;
using Rule=RulesLibrary.Rule;

namespace DecisionTreeTool
{
    public partial class frmMain : Form
    {
        public frmMain()
        {
            InitializeComponent();
        }

        private void btnFindFile_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = Environment.CurrentDirectory;
            openFileDialog1.Filter = "xml files (*.xml)|*.xml|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = true;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    txtFile.Text = openFileDialog1.FileName;
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Error: Could not read file from disk. Original error: " + ex.Message);
                }
            }

        }

        private void btnReload_Click(object sender, EventArgs e)
        {
            string filePath = txtFile.Text;
            XmlDocument objDoc = new XmlDocument();
            objDoc.Load(filePath);
            txtRuleSet.Text = FormatXml(objDoc.DocumentElement);

            XmlNode node = objDoc.DocumentElement;
            XmlNodeList nodeList = node.SelectNodes("/RuleSet/Rule");
            string nodestring = null;
            Rule rule;
            XmlDocument ruleStatement = new XmlDocument();
            RulesDecisionTree rdt = new RulesDecisionTree();
            for (int x = 0; x < nodeList.Count; x++)
            {
             //   nodestring += nodeList.Item(x).SelectNodes("/RuleStatement") + " ";
                //nodestring += nodeList.Item(x).SelectSingleNode("RuleStatement").OuterXml;
                ruleStatement.LoadXml(nodeList.Item(x).SelectSingleNode("RuleStatement").OuterXml);
                rule = new Rule(ruleStatement, new XmlDocument() );
                rdt.InsertRule(rule);
            }
            txtDecisionTree.Text = rdt.ToString();
        }

         protected string FormatXml(XmlNode xmlNode)    
         {
             StringBuilder sb = new StringBuilder();
             // We will use stringWriter to push the formated xml into our StringBuilder sb.
             using (StringWriter stringWriter = new StringWriter(sb))        
             {            // We will use the Formatting of our xmlTextWriter to provide our indentation.
                 using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter))
                 {
                     xmlTextWriter.Formatting = Formatting.Indented;               
                     xmlNode.WriteTo(xmlTextWriter);
                 }       
             }
             return sb.ToString();   
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DecisionTreeTool.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DecisionTreeTool.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DecisionTreeTool.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace DecisionTreeTool
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new frmMain());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\Tools\DecisionTreeTool\DecisionTreeTool\frmMain.Designer.cs ===
﻿namespace DecisionTreeTool
{
    partial class frmMain
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.btnReload = new System.Windows.Forms.Button();
            this.txtRuleSet = new System.Windows.Forms.TextBox();
            this.txtDecisionTree = new System.Windows.Forms.TextBox();
            this.lblRuleSet = new System.Windows.Forms.Label();
            this.lblDecisionTree = new System.Windows.Forms.Label();
            this.txtFile = new System.Windows.Forms.TextBox();
            this.btnFindFile = new System.Windows.Forms.Button();
            this.btnEvent = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // btnReload
            // 
            this.btnReload.Location = new System.Drawing.Point(554, 549);
            this.btnReload.Name = "btnReload";
            this.btnReload.Size = new System.Drawing.Size(105, 38);
            this.btnReload.TabIndex = 0;
            this.btnReload.Text = "Reload";
            this.btnReload.UseVisualStyleBackColor = true;
            this.btnReload.Click += new System.EventHandler(this.btnReload_Click);
            // 
            // txtRuleSet
            // 
            this.txtRuleSet.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtRuleSet.ForeColor = System.Drawing.Color.Blue;
            this.txtRuleSet.Location = new System.Drawing.Point(48, 25);
            this.txtRuleSet.Multiline = true;
            this.txtRuleSet.Name = "txtRuleSet";
            this.txtRuleSet.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtRuleSet.Size = new System.Drawing.Size(729, 253);
            this.txtRuleSet.TabIndex = 1;
            // 
            // txtDecisionTree
            // 
            this.txtDecisionTree.Location = new System.Drawing.Point(48, 303);
            this.txtDecisionTree.Multiline = true;
            this.txtDecisionTree.Name = "txtDecisionTree";
            this.txtDecisionTree.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtDecisionTree.Size = new System.Drawing.Size(729, 231);
            this.txtDecisionTree.TabIndex = 2;
            // 
            // lblRuleSet
            // 
            this.lblRuleSet.AutoSize = true;
            this.lblRuleSet.Location = new System.Drawing.Point(46, 11);
            this.lblRuleSet.Name = "lblRuleSet";
            this.lblRuleSet.Size = new System.Drawing.Size(45, 13);
            this.lblRuleSet.TabIndex = 3;
            this.lblRuleSet.Text = "RuleSet";
            // 
            // lblDecisionTree
            // 
            this.lblDecisionTree.AutoSize = true;
            this.lblDecisionTree.Location = new System.Drawing.Point(46, 289);
            this.lblDecisionTree.Name = "lblDecisionTree";
            this.lblDecisionTree.Size = new System.Drawing.Size(73, 13);
            this.lblDecisionTree.TabIndex = 4;
            this.lblDecisionTree.Text = "Decision Tree";
            // 
            // txtFile
            // 
            this.txtFile.Location = new System.Drawing.Point(48, 559);
            this.txtFile.Name = "txtFile";
            this.txtFile.Size = new System.Drawing.Size(372, 20);
            this.txtFile.TabIndex = 5;
            // 
            // btnFindFile
            // 
            this.btnFindFile.Location = new System.Drawing.Point(440, 549);
            this.btnFindFile.Name = "btnFindFile";
            this.btnFindFile.Size = new System.Drawing.Size(103, 38);
            this.btnFindFile.TabIndex = 6;
            this.btnFindFile.Text = "Find...";
            this.btnFindFile.UseVisualStyleBackColor = true;
            this.btnFindFile.Click += new System.EventHandler(this.btnFindFile_Click);
            // 
            // btnEvent
            // 
            this.btnEvent.Location = new System.Drawing.Point(670, 549);
            this.btnEvent.Name = "btnEvent";
            this.btnEvent.Size = new System.Drawing.Size(105, 36);
            this.btnEvent.TabIndex = 7;
            this.btnEvent.Text = "Event";
            this.btnEvent.UseVisualStyleBackColor = true;
            // 
            // frmMain
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(827, 591);
            this.Controls.Add(this.btnEvent);
            this.Controls.Add(this.btnFindFile);
            this.Controls.Add(this.txtFile);
            this.Controls.Add(this.lblDecisionTree);
            this.Controls.Add(this.lblRuleSet);
            this.Controls.Add(this.txtDecisionTree);
            this.Controls.Add(this.txtRuleSet);
            this.Controls.Add(this.btnReload);
            this.Name = "frmMain";
            this.Text = "Form1";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button btnReload;
        private System.Windows.Forms.TextBox txtRuleSet;
        private System.Windows.Forms.TextBox txtDecisionTree;
        private System.Windows.Forms.Label lblRuleSet;
        private System.Windows.Forms.Label lblDecisionTree;
        private System.Windows.Forms.TextBox txtFile;
        private System.Windows.Forms.Button btnFindFile;
        private System.Windows.Forms.Button btnEvent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\AstoriaTry1\Default.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace AstoriaTry1
{
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\AstoriaTry1\Default.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AstoriaTry1
{


    public partial class _Default
    {

        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\BadgeCreatePage.xaml.cs ===
﻿namespace RulesBadgeAuthoring
{
    using System;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Documents;
    using System.Windows.Ink;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Animation;
    using System.Windows.Shapes;
    using RulesBadgeAuthoring.RewardsDataService;
    using System.Data.Services.Client;
    using System.Linq;
    using RulesBadgeAuthoring.Model;

	public partial class BadgeCreatePage : UserControl
	{
        public BadgeCreatePage()
		{
			// Required to initialize variables
			InitializeComponent();
            Loaded += new RoutedEventHandler(BadgeCreatePage_Loaded);
            this.InitializeEvents();
		}

        public event EventHandler<EventArgs> PopupClose;

        void BadgeCreatePage_Loaded(object sender, RoutedEventArgs e)
        {
            using (DebugTextLogger.EnterFunction("Page::Page"))
            {
                try
                {
                    // initialize location of the pop-up window.
                    theBack.Width = App.Current.Host.Content.ActualWidth;
                    theBack.Height = App.Current.Host.Content.ActualHeight;

                }
                catch (Exception ex)
                {
                    DebugTextLogger.Log(ex.ToString());
                    throw;
                }
            }
        }

        /// <summary>
        /// NOTE: For the time being we use hard coded GameKey, this should be fixed once we have a list of Games and names.
        /// </summary>
        private void PopulateGameKey()
        {
            if (this.GameKeyListBox.Items.Count > 0)
            {
                this.GameKeyListBox.SelectedIndex = 0;
            }
        }

        void CheckboxHasRanged_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (CheckboxHasRanged.IsChecked ?? false)
                {
                    StartDatePicker.IsEnabled = true;
                    EndDatePicker.IsEnabled = true;
                    return;
                }

                StartDatePicker.IsEnabled = false;
                EndDatePicker.IsEnabled = false;
            }
        }

        void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        void SubmitOrUpdateButton_Click(object sender, RoutedEventArgs e)
        {
            // prevent subsequent click.
            this.SubmitOrUpdateButton.IsEnabled = false;

            // create path
            if (this.DataContext == null)
            {
                CreateReward();
            }
            else
            {
                UpdatedReward();
            }
        }

        private void UpdatedReward()
        {
            Reward currentReward = this.DataContext as Reward;
            PopulateRewardFromPage(currentReward);

            RewardLocale rewardLocale = currentReward.RewardLocale[0];
            PopulateRewardLocaleFromPage(rewardLocale);
            currentReward.InvalidateLocale = true;

            RewardManager.ServiceContext.UpdateObject(currentReward);
            RewardManager.ServiceContext.UpdateObject(rewardLocale);

            RewardManager.SaveComplete += new EventHandler<SaveDataEventArgs>(RewardManager_SaveComplete);
            RewardManager.SaveAsync();
        }

        private void CreateReward()
        {
            Reward newReward = new Reward();
            this.PopulateRewardFromPage(newReward);
            
            // find the constants
            RewardCategory rewCategory = this.RewardCategoryListBox.SelectedItem as RewardCategory;
            RewardType rewType = this.RewardTypeListBox.SelectedItem as RewardType;
            GameKeys rewGameKey = this.GameKeyListBox.SelectedItem as GameKeys;


            RewardLocale newRewardLocale = new RewardLocale();
            this.PopulateRewardLocaleFromPage(newRewardLocale);

            Locale locale = RewardManager.LocaleList[0];

            RewardManager.ServiceContext.AddToReward(newReward);
            RewardManager.ServiceContext.AddToRewardLocale(newRewardLocale);

            // Set the FK relationship for reward object
            newReward.RewardLocale.Add(newRewardLocale);
            //RewardManager.ServiceContext.SetLink(newReward, "RewardCategory", rewCategory);
            //RewardManager.ServiceContext.SetLink(newReward, "RewardType", rewType);
            //RewardManager.ServiceContext.SetLink(newReward, "GameKeys", rewGameKey);
            newReward.SetLink("RewardCategory", rewCategory);
            newReward.SetLink("RewardType", rewType);
                
            //newReward.SetLink("GameKeys", rewGameKey);
            
            // Set the FK relationship for the RewardLocale object
            //RewardManager.ServiceContext.SetLink(newRewardLocale, "Reward", newReward);
            //RewardManager.ServiceContext.SetLink(newRewardLocale, "Locale", locale);
            newRewardLocale.SetLink("Reward", newReward);
            newRewardLocale.SetLink("Locale", locale);

            RewardManager.SaveComplete += new EventHandler<SaveDataEventArgs>(RewardManager_SaveComplete);
            RewardManager.SaveAsync();
        }

        private void PopulateRewardFromPage(Reward currentReward)
        {
            currentReward.Comment = this.RewardCommentTextBox.Text;
            currentReward.Comment = this.RewardCommentTextBox.Text;
            currentReward.DTCreated = DateTime.UtcNow;
            currentReward.DTStart = this.StartDatePicker.SelectedDate != null ? this.StartDatePicker.SelectedDate.Value : DateTime.UtcNow;
            currentReward.DTEnd = this.EndDatePicker.SelectedDate != null ? this.EndDatePicker.SelectedDate.Value : DateTime.UtcNow;
            currentReward.DTModified = DateTime.UtcNow;
            currentReward.RewardValue = this.RewardValueTextBox.Text;
        }

        private void PopulateRewardLocaleFromPage(RewardLocale newRewardLocale)
        {
            newRewardLocale.LocRewardName = this.NameTextBox.Text;
            newRewardLocale.LocRewardDescription = this.DescriptionTextBox.Text;
            newRewardLocale.DTModified = DateTime.UtcNow;
            // the following fields are links that should be updated through the SetLink method.
            //Locale
            //Reward
        }

        void RewardManager_SaveComplete(object sender, RulesBadgeAuthoring.Model.SaveDataEventArgs e)
        {
            DebugTextLogger.Log("operation completed w/ {0}", e.Succeeded);
            RewardManager.SaveComplete -= RewardManager_SaveComplete;
            if (this.DataContext != null)
                (this.DataContext as Reward).InvalidateLocale = true;
            this.Close();
        }

        public void InitializeEvents()
        {
            this.SubmitOrUpdateButton.Click += new RoutedEventHandler(SubmitOrUpdateButton_Click);
            this.CancelButton.Click += new RoutedEventHandler(CancelButton_Click);
            this.CheckboxHasRanged.Click += new RoutedEventHandler(CheckboxHasRanged_Click);

            // 
            this.NameTextBox.TextChanged += new TextChangedEventHandler(FieldsChanged);
            this.DescriptionTextBox.TextChanged +=new TextChangedEventHandler(FieldsChanged);
            this.RewardValueTextBox.TextChanged +=new TextChangedEventHandler(FieldsChanged);
            this.RewardCommentTextBox.TextChanged += new TextChangedEventHandler(FieldsChanged);

            this.CheckboxHasRanged_Click(null, null);

            App.Current.Host.Content.Resized += (s, f) =>
            {
                theBack.Width = App.Current.Host.Content.ActualWidth;
                theBack.Height = App.Current.Host.Content.ActualHeight;
            };
        }

        void FieldsChanged(object sender, TextChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (CanEnableSubmitUpdateButton())
                {
                    this.SubmitOrUpdateButton.IsEnabled = true;
                    return;
                }
                this.SubmitOrUpdateButton.IsEnabled = false;
            }
        }

        private bool CanEnableSubmitUpdateButton()
        {
            if (string.IsNullOrEmpty(this.NameTextBox.Text)) return false;
            if (string.IsNullOrEmpty(this.DescriptionTextBox.Text)) return false;
            if (string.IsNullOrEmpty(this.RewardCommentTextBox.Text)) return false;
            if (string.IsNullOrEmpty(this.RewardValueTextBox.Text)) return false;

            // if there is a data context, check for any changes in fields.
            if (DataContext != null)
            {
                Reward currentReward = DataContext as Reward;
                // if any of the fields are different, then there is a change, update.
                if (!string.Equals(this.NameTextBox.Text, currentReward.Name, StringComparison.OrdinalIgnoreCase)) return true;
                if (!string.Equals(this.DescriptionTextBox.Text, currentReward.Description, StringComparison.OrdinalIgnoreCase)) return true;
                if (!string.Equals(this.RewardCommentTextBox.Text, currentReward.Comment, StringComparison.OrdinalIgnoreCase)) return true;
                if (!string.Equals(this.RewardValueTextBox.Text, currentReward.RewardValue, StringComparison.OrdinalIgnoreCase)) return true;
                if (this.StartDatePicker.SelectedDate != currentReward.DTStart) return true;
                if (this.EndDatePicker.SelectedDate != currentReward.DTEnd) return true;
                // if there is no change, return false.
                return false;
            }

            return true;
        }

        public void Clean()
        {
            this.NameTextBox.Text = string.Empty;
            this.DescriptionTextBox.Text = string.Empty;
            this.RewardCommentTextBox.Text = string.Empty;
            this.RewardValueTextBox.Text = string.Empty;
            this.StartDatePicker.SelectedDate = DateTime.UtcNow;
            this.EndDatePicker.SelectedDate = DateTime.MaxValue;
        }

        public void Close() 
        { 
            popMessage.IsOpen = false;
            //this.Clean();
            this.Visibility = Visibility.Collapsed;
            this.PopupClose(this, new EventArgs());
        } 

        public void Show() 
        {
            using (DebugTextLogger.EnterFunction("Query:PopulateCategory:Delegate"))
            {
                try
                {
                    // BUGBUG: Fetch Type and Category properly.
                    if (RewardManager.RewardTypeList.Count > 0)
                    {
                        this.RewardTypeListBox.ItemsSource = RewardManager.RewardTypeList;
                        this.RewardTypeListBox.SelectedIndex = 0;
                    }

                    if (RewardManager.RewardCategoryList.Count > 0)
                    {
                        this.RewardCategoryListBox.ItemsSource = RewardManager.RewardCategoryList;
                        this.RewardCategoryListBox.SelectedIndex = 0;
                    }

                    if (RewardManager.GameKeyList.Count > 0)
                    {
                        this.GameKeyListBox.ItemsSource = RewardManager.GameKeyList;
                        this.GameKeyListBox.SelectedIndex = 0;
                    }

                    this.PopulateGameKey();

                    popMessage.IsOpen = true;
                    this.Visibility = Visibility.Visible;
                    this.SubmitOrUpdateButton.IsEnabled = false;

                    // determine the text in the SubmitUpdateButton
                    if (DataContext != null)
                    {
                        (DataContext as Reward).UpdateAllFields();
                        this.SubmitOrUpdateButton.Content = "Update";
                    }
                    else
                    {
                        this.SubmitOrUpdateButton.Content = "Submit";
                    }
                    
                    CancelButton.Focus();
                    this.UpdateLayout();
                    this.UpdateLayout();
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\AstoriaTry1\RewardsDataService.svc.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.Services;
using System.Linq;
using System.ServiceModel.Web;
using System.ServiceModel;
using System.Web;

namespace AstoriaTry1
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = true)]
    public class RewardsDataService : DataService<AstoriaTry1.RewardsDBEntities>
    {
        // This method is called only once to initialize service-wide policies.
        public static void InitializeService(IDataServiceConfiguration config)
        {
            // TODO: set rules to indicate which entity sets and service operations are visible, updatable, etc.
            // Examples:
            // config.SetEntitySetAccessRule("MyEntityset", EntitySetRights.AllRead);
            // config.SetServiceOperationAccessRule("MyServiceOperation", ServiceOperationRights.All);
            config.SetEntitySetAccessRule("*", EntitySetRights.All);
            config.UseVerboseErrors = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\AstoriaTry1\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AstoriaTry1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\ActionEditPopup.xaml.cs ===
﻿namespace RulesBadgeAuthoring
{
    using System;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.RewardsDataService;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;
    using RulesBadgeAuthoring.View;

    public partial class ActionEditPopup : UserControl
    {
        internal RuleEditPopup RuleEditPage { get; set; }
        internal Action Action { get; set; }
        internal bool IsUpdate { get; set; }

        private IActionEditPage CurrentActionControl { get; set; }

        const string CreateBadgeActionName = "CreateBadge";
        const string SumPropertyActionName = "SumProperty";
        const string CreateAndSubmitEventActionName = "CreateAndSubmitEvent";

        public ActionEditPopup()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ActionEditPopup_Loaded);

            this.InitializeEvents();
        }

        void ActionEditPopup_Loaded(object sender, RoutedEventArgs e)
        {
            // initialize cover area of the pop-up window.
            theBack.Width = App.Current.Host.Content.ActualWidth;
            theBack.Height = App.Current.Host.Content.ActualHeight;
        }

        private void InitializeEvents()
        {
            App.Current.Host.Content.Resized += (s, f) =>
            {
                theBack.Width = App.Current.Host.Content.ActualWidth;
                theBack.Height = App.Current.Host.Content.ActualHeight;
            };

            this.CreateOrUpdateButton.Click += new RoutedEventHandler(CreateOrUpdateButton_Click);
            this.Cancel.Click += new RoutedEventHandler(Cancel_Click);

            this.ActionTypeSelectionCmbBx.SelectionChanged += new SelectionChangedEventHandler(ActionTypeSelectionCmbBx_SelectionChanged);

            this.mySumPropertyEditPage.OnCreateOrUpdateable += new EventHandler<EventArgs>(ActionEditPage_OnCreateOrUpdateable);
            this.myCreateBadgeEditPage.OnCreateOrUpdateable += new EventHandler<EventArgs>(ActionEditPage_OnCreateOrUpdateable);
            this.myCreateAndSubmitEventPage.OnCreateOrUpdateable += new EventHandler<EventArgs>(ActionEditPage_OnCreateOrUpdateable);
        }

        void ActionEditPage_OnCreateOrUpdateable(object sender, EventArgs e)
        {
            this.CreateOrUpdateButton.IsEnabled  = (bool)sender;
        }

        private void InitializeShowState()
        {
            this.CreateOrUpdateButton.IsEnabled = false;
            this.ActionTypeSelectionCmbBx.IsEnabled = false;

            // ensure the ItemsSource is set at least once.
            if (this.ActionTypeSelectionCmbBx.ItemsSource == null)
            {
                this.ActionTypeSelectionCmbBx.ItemsSource = RewardManager.ActionDefinitionList;
                this.ActionTypeSelectionCmbBx.UpdateLayout();
            }

            if (this.DataContext != null)
            {
                this.CreateOrUpdateButton.Content = "Update";
                Action action = this.DataContext as Action;
                if (action != null)
                {
                    this.Action = action;
                    this.IsUpdate = true;

                    this.ActionTypeSelectionCmbBx.IsEnabled = false;

                    this.Action.OnInitializeComplete += new EventHandler<EventArgs>(Action_OnInitializeComplete);
                    this.Action.BeginInitialize();
                }
            }
            else
            {
                this.CreateOrUpdateButton.Content = "Create";
                this.IsUpdate = false;
                Action_OnInitializeComplete(null, null);
            }
        }

        void Cancel_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        void CreateOrUpdateButton_Click(object sender, RoutedEventArgs e)
        {
            this.CreateOrUpdateButton.IsEnabled = false;

            Action action = this.CurrentActionControl.ConstructActionFromPage();
            action.Rule = this.RuleEditPage.Rule;
            
            this.RuleEditPage.Rule.InsertCreatedAction(action);

            this.Close();
        }

        void Action_OnInitializeComplete(object sender, EventArgs e)
        {
            if (this.Action != null)
            {
                this.Action.OnInitializeComplete -= Action_OnInitializeComplete;
            }

            DebugTextLogger.Log("Action_OnInitializeComplete");
            if (this.IsUpdate)
            {
                // determine the ActionType from Action object and set the Combobox.
                if (this.ActionTypeSelectionCmbBx.SelectedItem == this.Action.GetDefinition())
                {
                    ActionTypeSelectionCmbBx_SelectionChanged(null, null);
                }
                else
                {
                    this.ActionTypeSelectionCmbBx.SelectedItem = this.Action.GetDefinition();
                }
                this.ActionTypeSelectionCmbBx.UpdateLayout();
            }
            else
            {
                // we are in create mode, hence, ensure that the ActionType selection is allowed.
                this.ActionTypeSelectionCmbBx.IsEnabled = true;
                if (RewardManager.ActionDefinitionList.Count > 0)
                {
                    if (this.ActionTypeSelectionCmbBx.SelectedIndex == 0)
                    {
                        ActionTypeSelectionCmbBx_SelectionChanged(null, null);
                    }
                    else
                    {
                        this.ActionTypeSelectionCmbBx.SelectedIndex = 0;
                    }
                    this.ActionTypeSelectionCmbBx.UpdateLayout();
                }
            }
        }

        bool selectionChanging;

        void ActionTypeSelectionCmbBx_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            bool didIChangeTheSelection = false;
            try
            {
                if (!this.selectionChanging)
                {
                    didIChangeTheSelection = true;
                    this.selectionChanging = true;
                }
                else
                {
                    return;
                }

                DebugTextLogger.Log("ActionTypeSelectionCmbBx_SelectionChanged");

                ActionDefinition actDef = this.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition;
                if (actDef != null)
                {
                    if (CreateAndSubmitEventActionName.Equals(actDef.Name))
                    {
                        this.SwapControl(this.myCreateAndSubmitEventPage as IActionEditPage);
                    }
                    else if (CreateBadgeActionName.Equals(actDef.Name))
                    {
                        this.SwapControl(this.myCreateBadgeEditPage as IActionEditPage);
                    }
                    else if (SumPropertyActionName.Equals(actDef.Name))
                    {
                        this.SwapControl(this.mySumPropertyEditPage as IActionEditPage);
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
            }
            finally
            {
                if (didIChangeTheSelection)
                {
                    this.selectionChanging = false;
                }
            }
        }

        internal void SwapControl(IActionEditPage currentControl)
        {
            if (this.CurrentActionControl != null)
            {
                this.CurrentActionControl.Close(null);
            }

            this.CurrentActionControl = currentControl;
            this.CurrentActionControl.ActionEditPopup = this;

            if (this.CurrentActionControl != null)
            {
                this.CurrentActionControl.Show(this.DataContext);
            }
        }

        internal void Show()
        {
            this.InitializeShowState();
            popMessage.IsOpen = true;
            this.Visibility = Visibility.Visible;
        }

        internal void Close()
        {
            this.Action = null;
            popMessage.IsOpen = false;
            this.Visibility = Visibility.Collapsed;
            this.CurrentActionControl.Close(null);
            this.CurrentActionControl = null;

            try
            {
                selectionChanging = true;

                //this.ActionTypeSelectionCmbBx.ItemsSource = null;
                this.ActionTypeSelectionCmbBx.IsEnabled = true;
            }
            finally
            {
                selectionChanging = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\App.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;

namespace RulesBadgeAuthoring
{
    public partial class App : Application
    {

        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            this.RootVisual = new Page();
        }

        private void Application_Exit(object sender, EventArgs e)
        {

        }
        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {

                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { ReportErrorToDOM(e); });
            }
        }
        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 2 Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\CreateAndSubmitEventEditPage.xaml.cs ===
﻿namespace RulesBadgeAuthoring
{
    using System;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.Model;
    using RulesBadgeAuthoring.RewardsDataService;
    using RulesBadgeAuthoring.View;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;

    public partial class CreateAndSubmitEventEditPage : UserControl, IActionEditPage
    {
        private const string ParamValuePathFormatString = "/Store/User[ID=’/Event/LivePuid’]/Game[ID=’/Event/GameKey’]/{0}";
        private const string PropertyPathFormatString = "/Event/Property[{0}]";
        private const string GamaEventTypeString = "GDS.GameEvent";

        public ActionEditPopup ActionEditPopup { get; set; }
        public event EventHandler<EventArgs> OnCreateOrUpdateable;

        private Action Action { get; set; }
        private bool IsCreated { get; set; }
        private bool DontUpdateTextBoxes { get; set; }

        public CreateAndSubmitEventEditPage()
        {
            InitializeComponent();
            this.InitializeEvents();
            this.Loaded += new RoutedEventHandler(CreateAndSubmitEventEditPage_Loaded);
        }

        private void InitializeEvents()
        {
            this.StatSelector.SelectionChanged += new SelectionChangedEventHandler(StatSelector_SelectionChanged);
        }

        void CreateAndSubmitEventEditPage_Loaded(object sender, RoutedEventArgs e)
        {
        }

        void StatSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.DontUpdateTextBoxes)
                {
                    StatDescription statDesc = this.StatSelector.SelectedItem as StatDescription;
                    if (statDesc != null)
                    {
                        string resultString = string.Format(CreateAndSubmitEventEditPage.ParamValuePathFormatString,
                                                            (this.StatSelector.SelectedItem as StatDescription).Name);
                        this.ParameterNameParamEditBox.Text = statDesc.Name;
                        this.ParameterNameParamEditBoxToolTip.Text = statDesc.Name;
                        this.ParamValueParamEditBox.Text = resultString;
                        this.ParamValueParamEditBoxToolTip.Text = resultString;
                        this.GameEventParamEditBox.Text = CreateAndSubmitEventEditPage.GamaEventTypeString;
                        this.GameEventParamEditBoxToolTip.Text = CreateAndSubmitEventEditPage.GamaEventTypeString;

                        this.OnCreateOrUpdateable(this.IsCreateable, null);
                    }
                }
            }
        }

        public Action ConstructActionFromPage()
        {
            Action action = this.Action;

            if (action.IsCreated && action.ActionParameterList.Count == 0)
            {
                ActionParameter userParam = this.ConstructUserParam();
                action.CreateParameter(userParam);

                ActionParameter propertyNameParam = this.ConstructPropertyNameParam();
                action.CreateParameter(propertyNameParam);

                ActionParameter propertyValueParam = this.ConstructPropertyValueParam();
                action.CreateParameter(propertyValueParam);

                ActionParameter gameEventParam = this.ConstructGameEventParam();
                action.CreateParameter(gameEventParam);
            }
            else
            {
                ActionParameter param;

                param = this.GetUserParamFromAction();
                param.Path = this.UserParamEditBox.Text;
                param.IsModified = true;

                param = this.GetPropertyNameParamFromAction();
                param.Path = this.ParameterNameParamEditBox.Text;
                param.IsModified = true;

                param = this.GetPropertyValueParamFromAction();
                param.Path = this.ParamValueParamEditBox.Text;
                param.IsModified = true;

                param = this.GetGameEventParamFromAction();
                param.Path = this.GameEventParamEditBox.Text;
                param.IsModified = true;

                action.IsModified = true;
            }

            return action;
        }

        private ActionParameter ConstructUserParam()
        {
            ActionParameter userParam = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "User"),
                Path = this.UserParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return userParam;
        }

        private ActionParameter ConstructPropertyNameParam()
        {
            ActionParameter sum1Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "PropertyName"),
                Value = this.ParameterNameParamEditBox.Text,
                Path = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum1Param;
        }

        private ActionParameter ConstructPropertyValueParam()
        {
            ActionParameter sum2Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "PropertyValue"),
                Path = this.ParamValueParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum2Param;
        }

        private ActionParameter ConstructGameEventParam()
        {
            ActionParameter sum2Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "GameEvent"),
                Path = this.GameEventParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum2Param;
        }

        private ActionParameterDefinition FetchActionParameterDefinition(ActionDefinition definition, string paramName)
        {
            var paramDefinition = from parDef in definition.ActionParameterDefinition
                                  where parDef.Name.Equals(paramName)
                                  select parDef;

            return paramDefinition.First<ActionParameterDefinition>();
        }

        public bool IsCreateable
        {
            get
            {
                if (this.DataContext != null)
                {
                    return this.CheckIfModified();
                }

                return true;
            }
        }

        private bool CheckIfModified()
        {
            if (!this.UserParamEditBox.Text.Equals(this.GetUserParamFromAction().Path))
            {
                return true;
            }

            if (!this.ParameterNameParamEditBox.Text.Equals(this.GetPropertyNameParamFromAction().Path))
            {
                return true;
            }

            if (!this.ParamValueParamEditBox.Text.Equals(this.GetPropertyValueParamFromAction().Path))
            {
                return true;
            }

            if (!this.GameEventParamEditBox.Text.Equals(this.GetGameEventParamFromAction().Path))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// A bug in Combobox is preventing the change of ItemsSource
        /// </summary>
        private void PopulateStatList()
        {
            try
            {
                this.StatSelector.SelectionChanged -= StatSelector_SelectionChanged;
                while (this.StatSelector.Items.Count > 0)
                {
                    this.StatSelector.Items.RemoveAt(0);
                }
                // this.StatSelector.Items.Clear(); for some reason this is buggy.
                this.StatSelector.UpdateLayout();

                StatDescriptionCollection gameStatList = this.ActionEditPopup.RuleEditPage.Rule.GetGameKey().StatList;
                foreach (StatDescription sd in gameStatList)
                {
                    this.StatSelector.Items.Add(sd);
                }

                this.StatSelector.UpdateLayout();
            }
            finally
            {
                this.StatSelector.SelectionChanged += new SelectionChangedEventHandler(StatSelector_SelectionChanged);
            }


            if (this.Action.IsCreated)
            {
                if (this.StatSelector.SelectedIndex != 0)
                {
                    this.StatSelector.SelectedIndex = 0;
                }
            }
            else
            {
                StatDescription sd = this.GetStatFromAction();
                var statDesc = ((from statdesc in this.StatSelector.Items
                                 where (statdesc as StatDescription).StatDescriptionID == sd.StatDescriptionID
                                 select statdesc).First<object>() as StatDescription);
                this.StatSelector.SelectedItem = statDesc;
            }
        }

        private ActionParameter GetUserParamFromAction()
        {
            ActionParameter paramUser = (from par in this.Action.ActionParameterList
                                         where par.ActionParameterDefinition.Name.Equals("User")
                                         select par).First<ActionParameter>();
            return paramUser;
        }

        private ActionParameter GetPropertyNameParamFromAction()
        {
            ActionParameter paramPropertyName = (from par in this.Action.ActionParameterList
                                                 where par.ActionParameterDefinition.Name.Equals("PropertyName")
                                                 select par).First<ActionParameter>();
            return paramPropertyName;
        }

        private ActionParameter GetPropertyValueParamFromAction()
        {
            ActionParameter paramPropertyValue = (from par in this.Action.ActionParameterList
                                                  where par.ActionParameterDefinition.Name.Equals("PropertyValue")
                                                  select par).First<ActionParameter>();
            return paramPropertyValue;
        }

        private ActionParameter GetGameEventParamFromAction()
        {
            ActionParameter param = (from par in this.Action.ActionParameterList
                                     where par.ActionParameterDefinition.Name.Equals("GameEvent")
                                     select par).First<ActionParameter>();
            return param;
        }

        public StatDescription GetStatFromAction()
        {
            ActionParameter paramPropertyName = this.GetPropertyNameParamFromAction();

            string statName = paramPropertyName.Value;

            var stat = (from statDesc in this.Action.Rule.GetGameKey().StatList
                        where statDesc.Name.Equals(statName)
                        select statDesc).First<StatDescription>();
            return stat;
        }

        void Action_OnInitializeComplete(object sender, EventArgs e)
        {
            this.Action.OnInitializeComplete -= Action_OnInitializeComplete;

            bool shouldUpdateTextBoxes = true;

            if (!this.IsCreated && this.Action.HasInitialized)
            {
                shouldUpdateTextBoxes = false;

                this.UserParamEditBox.Text = this.GetUserParamFromAction().Path;
                this.ParameterNameParamEditBox.Text = this.GetPropertyNameParamFromAction().Value;
                this.ParamValueParamEditBox.Text = this.GetPropertyValueParamFromAction().Path;
                this.GameEventParamEditBox.Text = this.GetGameEventParamFromAction().ActionParameterDefinition.DataType.DataTypeString;
            }

            try
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = true;
                }

                this.PopulateStatList();
            }
            finally
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = false;
                }
            }

        }

        public void Show(Object dataContext)
        {
            this.DataContext = dataContext;
            this.Visibility = Visibility.Visible;

            this.Action = this.DataContext as Action;
            if (this.Action == null)
            {
                this.IsCreated = true;
                this.Action = new Action();
                this.Action.DTModified = DateTime.UtcNow;
                this.Action.IsCreated = true;
                this.Action.ActionDefinition = (this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition);
                this.Action.ExecuteOrder = this.ActionEditPopup.RuleEditPage.Rule.ActionList.Count;
            }
            else
            {
                // this must be a CreateAndSubmitEventAction
                if (!this.Action.ActionDefinition.Name.Equals("CreateAndSubmitEvent"))
                {
                    throw new InvalidOperationException();
                }

                if (this.Action.ActionParameterList.Count != 4)
                {
                    throw new InvalidOperationException();
                }
            }

            this.Action.OnInitializeComplete += new EventHandler<EventArgs>(Action_OnInitializeComplete);
            this.Action.BeginInitialize();
        }

        public void Close(Object dataContext)
        {
            this.Visibility = Visibility.Collapsed;
            this.DataContext = dataContext;
            this.IsCreated = false;
            this.Action = dataContext as Action;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\AstoriaTry1\Model1.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4918
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Data.Objects.DataClasses.EdmSchemaAttribute()]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.ZeroOrOne, typeof(AstoriaTry1.ActionDefinition), "Action", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Action))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKAction_Rule_RuleID", "Rule", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Rule), "Action", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Action))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionParameter_Action_ActionID", "Action", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Action), "ActionParameter", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionParameter))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionSettings_Action_ActionID", "Action", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Action), "ActionSettings", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionSettings))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.ActionDefinition), "ActionParameterDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionParameterDefinition))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.ActionDefinition), "ActionSettingsDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionSettingsDefinition))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionParameter_ActionParameterDefinition_ActionParameterDefinitionID", "ActionParameterDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.ActionParameterDefinition), "ActionParameter", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionParameter))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionParameterDefinition_DataType_DataTypeID", "DataType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.DataType), "ActionParameterDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionParameterDefinition))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.ActionSetExecutionType), "Rule", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Rule))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinitionID", "ActionSettingsDefinition", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.ActionSettingsDefinition), "ActionSettings", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.ActionSettings))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKGameSchemaProperties_DataType_DataTypeID", "DataType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.DataType), "GameSchemaProperties", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.GameSchemaProperties))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRuleExpression_DataType_DataTypeID", "DataType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.DataType), "RuleExpression", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RuleExpression))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKStatDescription_DataType_DataTypeID", "DataType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.DataType), "StatDescription", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.StatDescription))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKGameKeys_Platforms_PlatformID", "Platforms", global::System.Data.Metadata.Edm.RelationshipMultiplicity.ZeroOrOne, typeof(AstoriaTry1.Platforms), "GameKeys", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.GameKeys))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.GameKeys), "GameSchemaNames", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.GameSchemaNames))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKReward_GameKeys_GameKeyID", "GameKeys", global::System.Data.Metadata.Edm.RelationshipMultiplicity.ZeroOrOne, typeof(AstoriaTry1.GameKeys), "Reward", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Reward))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRule_GameKeys_GameKeyID", "GameKeys", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.GameKeys), "Rule", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Rule))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKStatDescription_GameKeys_GameKeyID", "GameKeys", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.GameKeys), "StatDescription", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.StatDescription))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.GameSchemaNames), "GameSchemaProperties", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.GameSchemaProperties))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRewardLocale_Locale_LCID", "Locale", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Locale), "RewardLocale", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RewardLocale))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FK_Rule_Reward_RewardID", "Reward", global::System.Data.Metadata.Edm.RelationshipMultiplicity.ZeroOrOne, typeof(AstoriaTry1.Reward), "Rule", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Rule))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKReward_RewardCategory_RewardCategoryID", "RewardCategory", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.RewardCategory), "Reward", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Reward))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKReward_RewardType_RewardTypeID", "RewardType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.RewardType), "Reward", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.Reward))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRewardLocale_Reward_RewardID", "Reward", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Reward), "RewardLocale", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RewardLocale))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRuleExpression_Rule_RuleID", "Rule", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.Rule), "RuleExpression", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RuleExpression))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.RuleOperandType), "RuleExpression", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RuleExpression))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.RuleOperandType), "RuleExpression", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RuleExpression))]
[assembly: global::System.Data.Objects.DataClasses.EdmRelationshipAttribute("RewardsDBModel", "FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator", global::System.Data.Metadata.Edm.RelationshipMultiplicity.One, typeof(AstoriaTry1.RuleOperator), "RuleExpression", global::System.Data.Metadata.Edm.RelationshipMultiplicity.Many, typeof(AstoriaTry1.RuleExpression))]

// Original file name:
// Generation date: 6/12/2009 5:09:42 PM
namespace AstoriaTry1
{
    
    /// <summary>
    /// There are no comments for RewardsDBEntities in the schema.
    /// </summary>
    public partial class RewardsDBEntities : global::System.Data.Objects.ObjectContext
    {
        /// <summary>
        /// Initializes a new RewardsDBEntities object using the connection string found in the 'RewardsDBEntities' section of the application configuration file.
        /// </summary>
        public RewardsDBEntities() : 
                base("name=RewardsDBEntities", "RewardsDBEntities")
        {
            this.OnContextCreated();
        }
        /// <summary>
        /// Initialize a new RewardsDBEntities object.
        /// </summary>
        public RewardsDBEntities(string connectionString) : 
                base(connectionString, "RewardsDBEntities")
        {
            this.OnContextCreated();
        }
        /// <summary>
        /// Initialize a new RewardsDBEntities object.
        /// </summary>
        public RewardsDBEntities(global::System.Data.EntityClient.EntityConnection connection) : 
                base(connection, "RewardsDBEntities")
        {
            this.OnContextCreated();
        }
        partial void OnContextCreated();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<Action> Action
        {
            get
            {
                if ((this._Action == null))
                {
                    this._Action = base.CreateQuery<Action>("[Action]");
                }
                return this._Action;
            }
        }
        private global::System.Data.Objects.ObjectQuery<Action> _Action;
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionDefinition> ActionDefinition
        {
            get
            {
                if ((this._ActionDefinition == null))
                {
                    this._ActionDefinition = base.CreateQuery<ActionDefinition>("[ActionDefinition]");
                }
                return this._ActionDefinition;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionDefinition> _ActionDefinition;
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionParameter> ActionParameter
        {
            get
            {
                if ((this._ActionParameter == null))
                {
                    this._ActionParameter = base.CreateQuery<ActionParameter>("[ActionParameter]");
                }
                return this._ActionParameter;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionParameter> _ActionParameter;
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                if ((this._ActionParameterDefinition == null))
                {
                    this._ActionParameterDefinition = base.CreateQuery<ActionParameterDefinition>("[ActionParameterDefinition]");
                }
                return this._ActionParameterDefinition;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionParameterDefinition> _ActionParameterDefinition;
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionSetExecutionType> ActionSetExecutionType
        {
            get
            {
                if ((this._ActionSetExecutionType == null))
                {
                    this._ActionSetExecutionType = base.CreateQuery<ActionSetExecutionType>("[ActionSetExecutionType]");
                }
                return this._ActionSetExecutionType;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionSetExecutionType> _ActionSetExecutionType;
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionSettings> ActionSettings
        {
            get
            {
                if ((this._ActionSettings == null))
                {
                    this._ActionSettings = base.CreateQuery<ActionSettings>("[ActionSettings]");
                }
                return this._ActionSettings;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionSettings> _ActionSettings;
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<ActionSettingsDefinition> ActionSettingsDefinition
        {
            get
            {
                if ((this._ActionSettingsDefinition == null))
                {
                    this._ActionSettingsDefinition = base.CreateQuery<ActionSettingsDefinition>("[ActionSettingsDefinition]");
                }
                return this._ActionSettingsDefinition;
            }
        }
        private global::System.Data.Objects.ObjectQuery<ActionSettingsDefinition> _ActionSettingsDefinition;
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<DataType> DataType
        {
            get
            {
                if ((this._DataType == null))
                {
                    this._DataType = base.CreateQuery<DataType>("[DataType]");
                }
                return this._DataType;
            }
        }
        private global::System.Data.Objects.ObjectQuery<DataType> _DataType;
        /// <summary>
        /// There are no comments for GameCategories in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<GameCategories> GameCategories
        {
            get
            {
                if ((this._GameCategories == null))
                {
                    this._GameCategories = base.CreateQuery<GameCategories>("[GameCategories]");
                }
                return this._GameCategories;
            }
        }
        private global::System.Data.Objects.ObjectQuery<GameCategories> _GameCategories;
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<GameKeys> GameKeys
        {
            get
            {
                if ((this._GameKeys == null))
                {
                    this._GameKeys = base.CreateQuery<GameKeys>("[GameKeys]");
                }
                return this._GameKeys;
            }
        }
        private global::System.Data.Objects.ObjectQuery<GameKeys> _GameKeys;
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<GameSchemaNames> GameSchemaNames
        {
            get
            {
                if ((this._GameSchemaNames == null))
                {
                    this._GameSchemaNames = base.CreateQuery<GameSchemaNames>("[GameSchemaNames]");
                }
                return this._GameSchemaNames;
            }
        }
        private global::System.Data.Objects.ObjectQuery<GameSchemaNames> _GameSchemaNames;
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                if ((this._GameSchemaProperties == null))
                {
                    this._GameSchemaProperties = base.CreateQuery<GameSchemaProperties>("[GameSchemaProperties]");
                }
                return this._GameSchemaProperties;
            }
        }
        private global::System.Data.Objects.ObjectQuery<GameSchemaProperties> _GameSchemaProperties;
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<Locale> Locale
        {
            get
            {
                if ((this._Locale == null))
                {
                    this._Locale = base.CreateQuery<Locale>("[Locale]");
                }
                return this._Locale;
            }
        }
        private global::System.Data.Objects.ObjectQuery<Locale> _Locale;
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<Platforms> Platforms
        {
            get
            {
                if ((this._Platforms == null))
                {
                    this._Platforms = base.CreateQuery<Platforms>("[Platforms]");
                }
                return this._Platforms;
            }
        }
        private global::System.Data.Objects.ObjectQuery<Platforms> _Platforms;
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<Reward> Reward
        {
            get
            {
                if ((this._Reward == null))
                {
                    this._Reward = base.CreateQuery<Reward>("[Reward]");
                }
                return this._Reward;
            }
        }
        private global::System.Data.Objects.ObjectQuery<Reward> _Reward;
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RewardCategory> RewardCategory
        {
            get
            {
                if ((this._RewardCategory == null))
                {
                    this._RewardCategory = base.CreateQuery<RewardCategory>("[RewardCategory]");
                }
                return this._RewardCategory;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RewardCategory> _RewardCategory;
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RewardLocale> RewardLocale
        {
            get
            {
                if ((this._RewardLocale == null))
                {
                    this._RewardLocale = base.CreateQuery<RewardLocale>("[RewardLocale]");
                }
                return this._RewardLocale;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RewardLocale> _RewardLocale;
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RewardType> RewardType
        {
            get
            {
                if ((this._RewardType == null))
                {
                    this._RewardType = base.CreateQuery<RewardType>("[RewardType]");
                }
                return this._RewardType;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RewardType> _RewardType;
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<Rule> Rule
        {
            get
            {
                if ((this._Rule == null))
                {
                    this._Rule = base.CreateQuery<Rule>("[Rule]");
                }
                return this._Rule;
            }
        }
        private global::System.Data.Objects.ObjectQuery<Rule> _Rule;
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RuleExpression> RuleExpression
        {
            get
            {
                if ((this._RuleExpression == null))
                {
                    this._RuleExpression = base.CreateQuery<RuleExpression>("[RuleExpression]");
                }
                return this._RuleExpression;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RuleExpression> _RuleExpression;
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RuleOperandType> RuleOperandType
        {
            get
            {
                if ((this._RuleOperandType == null))
                {
                    this._RuleOperandType = base.CreateQuery<RuleOperandType>("[RuleOperandType]");
                }
                return this._RuleOperandType;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RuleOperandType> _RuleOperandType;
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<RuleOperator> RuleOperator
        {
            get
            {
                if ((this._RuleOperator == null))
                {
                    this._RuleOperator = base.CreateQuery<RuleOperator>("[RuleOperator]");
                }
                return this._RuleOperator;
            }
        }
        private global::System.Data.Objects.ObjectQuery<RuleOperator> _RuleOperator;
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public global::System.Data.Objects.ObjectQuery<StatDescription> StatDescription
        {
            get
            {
                if ((this._StatDescription == null))
                {
                    this._StatDescription = base.CreateQuery<StatDescription>("[StatDescription]");
                }
                return this._StatDescription;
            }
        }
        private global::System.Data.Objects.ObjectQuery<StatDescription> _StatDescription;
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public void AddToAction(Action action)
        {
            base.AddObject("Action", action);
        }
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public void AddToActionDefinition(ActionDefinition actionDefinition)
        {
            base.AddObject("ActionDefinition", actionDefinition);
        }
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public void AddToActionParameter(ActionParameter actionParameter)
        {
            base.AddObject("ActionParameter", actionParameter);
        }
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public void AddToActionParameterDefinition(ActionParameterDefinition actionParameterDefinition)
        {
            base.AddObject("ActionParameterDefinition", actionParameterDefinition);
        }
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        public void AddToActionSetExecutionType(ActionSetExecutionType actionSetExecutionType)
        {
            base.AddObject("ActionSetExecutionType", actionSetExecutionType);
        }
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public void AddToActionSettings(ActionSettings actionSettings)
        {
            base.AddObject("ActionSettings", actionSettings);
        }
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public void AddToActionSettingsDefinition(ActionSettingsDefinition actionSettingsDefinition)
        {
            base.AddObject("ActionSettingsDefinition", actionSettingsDefinition);
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public void AddToDataType(DataType dataType)
        {
            base.AddObject("DataType", dataType);
        }
        /// <summary>
        /// There are no comments for GameCategories in the schema.
        /// </summary>
        public void AddToGameCategories(GameCategories gameCategories)
        {
            base.AddObject("GameCategories", gameCategories);
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public void AddToGameKeys(GameKeys gameKeys)
        {
            base.AddObject("GameKeys", gameKeys);
        }
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public void AddToGameSchemaNames(GameSchemaNames gameSchemaNames)
        {
            base.AddObject("GameSchemaNames", gameSchemaNames);
        }
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public void AddToGameSchemaProperties(GameSchemaProperties gameSchemaProperties)
        {
            base.AddObject("GameSchemaProperties", gameSchemaProperties);
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        public void AddToLocale(Locale locale)
        {
            base.AddObject("Locale", locale);
        }
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        public void AddToPlatforms(Platforms platforms)
        {
            base.AddObject("Platforms", platforms);
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public void AddToReward(Reward reward)
        {
            base.AddObject("Reward", reward);
        }
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        public void AddToRewardCategory(RewardCategory rewardCategory)
        {
            base.AddObject("RewardCategory", rewardCategory);
        }
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public void AddToRewardLocale(RewardLocale rewardLocale)
        {
            base.AddObject("RewardLocale", rewardLocale);
        }
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        public void AddToRewardType(RewardType rewardType)
        {
            base.AddObject("RewardType", rewardType);
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public void AddToRule(Rule rule)
        {
            base.AddObject("Rule", rule);
        }
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public void AddToRuleExpression(RuleExpression ruleExpression)
        {
            base.AddObject("RuleExpression", ruleExpression);
        }
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        public void AddToRuleOperandType(RuleOperandType ruleOperandType)
        {
            base.AddObject("RuleOperandType", ruleOperandType);
        }
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        public void AddToRuleOperator(RuleOperator ruleOperator)
        {
            base.AddObject("RuleOperator", ruleOperator);
        }
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public void AddToStatDescription(StatDescription statDescription)
        {
            base.AddObject("StatDescription", statDescription);
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Action in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="Action")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Action : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new Action object.
        /// </summary>
        /// <param name="actionID">Initial value of ActionID.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Action CreateAction(int actionID, global::System.DateTime dTModified)
        {
            Action action = new Action();
            action.ActionID = actionID;
            action.DTModified = dTModified;
            return action;
        }
        /// <summary>
        /// There are no comments for Property ActionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionID
        {
            get
            {
                return this._ActionID;
            }
            set
            {
                this.OnActionIDChanging(value);
                this.ReportPropertyChanging("ActionID");
                this._ActionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionID");
                this.OnActionIDChanged();
            }
        }
        private int _ActionID;
        partial void OnActionIDChanging(int value);
        partial void OnActionIDChanged();
        /// <summary>
        /// There are no comments for Property ExecuteOrder in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<int> ExecuteOrder
        {
            get
            {
                return this._ExecuteOrder;
            }
            set
            {
                this.OnExecuteOrderChanging(value);
                this.ReportPropertyChanging("ExecuteOrder");
                this._ExecuteOrder = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ExecuteOrder");
                this.OnExecuteOrderChanged();
            }
        }
        private global::System.Nullable<int> _ExecuteOrder;
        partial void OnExecuteOrderChanging(global::System.Nullable<int> value);
        partial void OnExecuteOrderChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionDefinition ActionDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionDefinition> ActionDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionDefinition>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "ActionDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKAction_Rule_RuleID", "Rule")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Rule Rule
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKAction_Rule_RuleID", "Rule").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKAction_Rule_RuleID", "Rule").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Rule> RuleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKAction_Rule_RuleID", "Rule");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Rule>("RewardsDBModel.FKAction_Rule_RuleID", "Rule", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameter_Action_ActionID", "ActionParameter")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionParameter> ActionParameter
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionParameter>("RewardsDBModel.FKActionParameter_Action_ActionID", "ActionParameter");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionParameter>("RewardsDBModel.FKActionParameter_Action_ActionID", "ActionParameter", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettings_Action_ActionID", "ActionSettings")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionSettings> ActionSettings
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionSettings>("RewardsDBModel.FKActionSettings_Action_ActionID", "ActionSettings");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionSettings>("RewardsDBModel.FKActionSettings_Action_ActionID", "ActionSettings", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionDefinitionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionDefinition")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionDefinition : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionDefinition object.
        /// </summary>
        /// <param name="actionDefinitionID">Initial value of ActionDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        /// <param name="assemblyName">Initial value of AssemblyName.</param>
        public static ActionDefinition CreateActionDefinition(int actionDefinitionID, string name, global::System.DateTime dTModified, string assemblyName)
        {
            ActionDefinition actionDefinition = new ActionDefinition();
            actionDefinition.ActionDefinitionID = actionDefinitionID;
            actionDefinition.Name = name;
            actionDefinition.DTModified = dTModified;
            actionDefinition.AssemblyName = assemblyName;
            return actionDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionDefinitionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionDefinitionID
        {
            get
            {
                return this._ActionDefinitionID;
            }
            set
            {
                this.OnActionDefinitionIDChanging(value);
                this.ReportPropertyChanging("ActionDefinitionID");
                this._ActionDefinitionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionDefinitionID");
                this.OnActionDefinitionIDChanged();
            }
        }
        private int _ActionDefinitionID;
        partial void OnActionDefinitionIDChanging(int value);
        partial void OnActionDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property AssemblyName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string AssemblyName
        {
            get
            {
                return this._AssemblyName;
            }
            set
            {
                this.OnAssemblyNameChanging(value);
                this.ReportPropertyChanging("AssemblyName");
                this._AssemblyName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("AssemblyName");
                this.OnAssemblyNameChanged();
            }
        }
        private string _AssemblyName;
        partial void OnAssemblyNameChanging(string value);
        partial void OnAssemblyNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKAction_ActionDefinition_ActionDefinitionID", "Action")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Action> Action
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Action>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "Action");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Action>("RewardsDBModel.FKAction_ActionDefinition_ActionDefinitionID", "Action", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionParameterDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionParameterDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionParameterDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionParameterDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionParameterDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionSettingsDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionSettingsDefinition> ActionSettingsDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionSettingsDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionSettingsDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionSettingsDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionSettingsDefinition", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionParameter in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionParameterID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionParameter")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionParameter : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionParameter object.
        /// </summary>
        /// <param name="actionParameterID">Initial value of ActionParameterID.</param>
        public static ActionParameter CreateActionParameter(int actionParameterID)
        {
            ActionParameter actionParameter = new ActionParameter();
            actionParameter.ActionParameterID = actionParameterID;
            return actionParameter;
        }
        /// <summary>
        /// There are no comments for Property ActionParameterID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionParameterID
        {
            get
            {
                return this._ActionParameterID;
            }
            set
            {
                this.OnActionParameterIDChanging(value);
                this.ReportPropertyChanging("ActionParameterID");
                this._ActionParameterID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionParameterID");
                this.OnActionParameterIDChanged();
            }
        }
        private int _ActionParameterID;
        partial void OnActionParameterIDChanging(int value);
        partial void OnActionParameterIDChanged();
        /// <summary>
        /// There are no comments for Property Path in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Path
        {
            get
            {
                return this._Path;
            }
            set
            {
                this.OnPathChanging(value);
                this.ReportPropertyChanging("Path");
                this._Path = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Path");
                this.OnPathChanged();
            }
        }
        private string _Path;
        partial void OnPathChanging(string value);
        partial void OnPathChanged();
        /// <summary>
        /// There are no comments for Property Value in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Value
        {
            get
            {
                return this._Value;
            }
            set
            {
                this.OnValueChanging(value);
                this.ReportPropertyChanging("Value");
                this._Value = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Value");
                this.OnValueChanged();
            }
        }
        private string _Value;
        partial void OnValueChanging(string value);
        partial void OnValueChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameter_Action_ActionID", "Action")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Action Action
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionParameter_Action_ActionID", "Action").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionParameter_Action_ActionID", "Action").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Action> ActionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionParameter_Action_ActionID", "Action");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Action>("RewardsDBModel.FKActionParameter_Action_ActionID", "Action", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameter_ActionParameterDefinition_ActionParameterDefinitionID", "ActionParameterDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionParameterDefinition ActionParameterDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionParameterDefinition>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                        "ionID", "ActionParameterDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionParameterDefinition>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                        "ionID", "ActionParameterDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionParameterDefinition> ActionParameterDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionParameterDefinition>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                        "ionID", "ActionParameterDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionParameterDefinition>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                            "ionID", "ActionParameterDefinition", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionParameterDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionParameterDefinitionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionParameterDefinition")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionParameterDefinition : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionParameterDefinition object.
        /// </summary>
        /// <param name="actionParameterDefinitionID">Initial value of ActionParameterDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="type">Initial value of Type.</param>
        /// <param name="parameterOrder">Initial value of ParameterOrder.</param>
        public static ActionParameterDefinition CreateActionParameterDefinition(int actionParameterDefinitionID, string name, string type, int parameterOrder)
        {
            ActionParameterDefinition actionParameterDefinition = new ActionParameterDefinition();
            actionParameterDefinition.ActionParameterDefinitionID = actionParameterDefinitionID;
            actionParameterDefinition.Name = name;
            actionParameterDefinition.Type = type;
            actionParameterDefinition.ParameterOrder = parameterOrder;
            return actionParameterDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionParameterDefinitionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionParameterDefinitionID
        {
            get
            {
                return this._ActionParameterDefinitionID;
            }
            set
            {
                this.OnActionParameterDefinitionIDChanging(value);
                this.ReportPropertyChanging("ActionParameterDefinitionID");
                this._ActionParameterDefinitionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionParameterDefinitionID");
                this.OnActionParameterDefinitionIDChanged();
            }
        }
        private int _ActionParameterDefinitionID;
        partial void OnActionParameterDefinitionIDChanging(int value);
        partial void OnActionParameterDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Type in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Type
        {
            get
            {
                return this._Type;
            }
            set
            {
                this.OnTypeChanging(value);
                this.ReportPropertyChanging("Type");
                this._Type = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Type");
                this.OnTypeChanged();
            }
        }
        private string _Type;
        partial void OnTypeChanging(string value);
        partial void OnTypeChanged();
        /// <summary>
        /// There are no comments for Property ParameterOrder in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ParameterOrder
        {
            get
            {
                return this._ParameterOrder;
            }
            set
            {
                this.OnParameterOrderChanging(value);
                this.ReportPropertyChanging("ParameterOrder");
                this._ParameterOrder = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ParameterOrder");
                this.OnParameterOrderChanged();
            }
        }
        private int _ParameterOrder;
        partial void OnParameterOrderChanging(int value);
        partial void OnParameterOrderChanged();
        /// <summary>
        /// There are no comments for Property PathRequired in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<bool> PathRequired
        {
            get
            {
                return this._PathRequired;
            }
            set
            {
                this.OnPathRequiredChanging(value);
                this.ReportPropertyChanging("PathRequired");
                this._PathRequired = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("PathRequired");
                this.OnPathRequiredChanged();
            }
        }
        private global::System.Nullable<bool> _PathRequired;
        partial void OnPathRequiredChanging(global::System.Nullable<bool> value);
        partial void OnPathRequiredChanged();
        /// <summary>
        /// There are no comments for Property ValueRequired in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<bool> ValueRequired
        {
            get
            {
                return this._ValueRequired;
            }
            set
            {
                this.OnValueRequiredChanging(value);
                this.ReportPropertyChanging("ValueRequired");
                this._ValueRequired = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ValueRequired");
                this.OnValueRequiredChanged();
            }
        }
        private global::System.Nullable<bool> _ValueRequired;
        partial void OnValueRequiredChanging(global::System.Nullable<bool> value);
        partial void OnValueRequiredChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionDefinition ActionDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionDefinition> ActionDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionDefinition>("RewardsDBModel.FKActionParameterDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameter_ActionParameterDefinition_ActionParameterDefinitionID", "ActionParameter")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionParameter> ActionParameter
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionParameter>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                        "ionID", "ActionParameter");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionParameter>("RewardsDBModel.FKActionParameter_ActionParameterDefinition_ActionParameterDefinit" +
                            "ionID", "ActionParameter", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameterDefinition_DataType_DataTypeID", "DataType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public DataType DataType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "DataType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "DataType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<DataType> DataTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "DataType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<DataType>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "DataType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSetExecutionType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSetExecutionTypeID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionSetExecutionType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionSetExecutionType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionSetExecutionType object.
        /// </summary>
        /// <param name="actionSetExecutionTypeID">Initial value of ActionSetExecutionTypeID.</param>
        /// <param name="executionType">Initial value of ExecutionType.</param>
        public static ActionSetExecutionType CreateActionSetExecutionType(int actionSetExecutionTypeID, string executionType)
        {
            ActionSetExecutionType actionSetExecutionType = new ActionSetExecutionType();
            actionSetExecutionType.ActionSetExecutionTypeID = actionSetExecutionTypeID;
            actionSetExecutionType.ExecutionType = executionType;
            return actionSetExecutionType;
        }
        /// <summary>
        /// There are no comments for Property ActionSetExecutionTypeID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionSetExecutionTypeID
        {
            get
            {
                return this._ActionSetExecutionTypeID;
            }
            set
            {
                this.OnActionSetExecutionTypeIDChanging(value);
                this.ReportPropertyChanging("ActionSetExecutionTypeID");
                this._ActionSetExecutionTypeID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionSetExecutionTypeID");
                this.OnActionSetExecutionTypeIDChanged();
            }
        }
        private int _ActionSetExecutionTypeID;
        partial void OnActionSetExecutionTypeIDChanging(int value);
        partial void OnActionSetExecutionTypeIDChanged();
        /// <summary>
        /// There are no comments for Property ExecutionType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string ExecutionType
        {
            get
            {
                return this._ExecutionType;
            }
            set
            {
                this.OnExecutionTypeChanging(value);
                this.ReportPropertyChanging("ExecutionType");
                this._ExecutionType = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("ExecutionType");
                this.OnExecutionTypeChanged();
            }
        }
        private string _ExecutionType;
        partial void OnExecutionTypeChanging(string value);
        partial void OnExecutionTypeChanged();
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "Rule")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Rule> Rule
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Rule>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "Rule");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Rule>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "Rule", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSettings in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSettingsID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionSettings")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionSettings : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionSettings object.
        /// </summary>
        /// <param name="actionSettingsID">Initial value of ActionSettingsID.</param>
        /// <param name="settingXml">Initial value of SettingXml.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static ActionSettings CreateActionSettings(int actionSettingsID, string settingXml, global::System.DateTime dTModified)
        {
            ActionSettings actionSettings = new ActionSettings();
            actionSettings.ActionSettingsID = actionSettingsID;
            actionSettings.SettingXml = settingXml;
            actionSettings.DTModified = dTModified;
            return actionSettings;
        }
        /// <summary>
        /// There are no comments for Property ActionSettingsID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionSettingsID
        {
            get
            {
                return this._ActionSettingsID;
            }
            set
            {
                this.OnActionSettingsIDChanging(value);
                this.ReportPropertyChanging("ActionSettingsID");
                this._ActionSettingsID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionSettingsID");
                this.OnActionSettingsIDChanged();
            }
        }
        private int _ActionSettingsID;
        partial void OnActionSettingsIDChanging(int value);
        partial void OnActionSettingsIDChanged();
        /// <summary>
        /// There are no comments for Property SettingXml in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string SettingXml
        {
            get
            {
                return this._SettingXml;
            }
            set
            {
                this.OnSettingXmlChanging(value);
                this.ReportPropertyChanging("SettingXml");
                this._SettingXml = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("SettingXml");
                this.OnSettingXmlChanged();
            }
        }
        private string _SettingXml;
        partial void OnSettingXmlChanging(string value);
        partial void OnSettingXmlChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettings_Action_ActionID", "Action")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Action Action
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionSettings_Action_ActionID", "Action").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionSettings_Action_ActionID", "Action").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Action> ActionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Action>("RewardsDBModel.FKActionSettings_Action_ActionID", "Action");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Action>("RewardsDBModel.FKActionSettings_Action_ActionID", "Action", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinitionID", "ActionSettingsDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionSettingsDefinition ActionSettingsDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSettingsDefinition>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                        "ID", "ActionSettingsDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSettingsDefinition>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                        "ID", "ActionSettingsDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionSettingsDefinition> ActionSettingsDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSettingsDefinition>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                        "ID", "ActionSettingsDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionSettingsDefinition>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                            "ID", "ActionSettingsDefinition", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSettingsDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSettingsDefinitionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="ActionSettingsDefinition")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class ActionSettingsDefinition : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new ActionSettingsDefinition object.
        /// </summary>
        /// <param name="actionSettingsDefinitionID">Initial value of ActionSettingsDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="settingSchema">Initial value of SettingSchema.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static ActionSettingsDefinition CreateActionSettingsDefinition(int actionSettingsDefinitionID, string name, string settingSchema, global::System.DateTime dTModified)
        {
            ActionSettingsDefinition actionSettingsDefinition = new ActionSettingsDefinition();
            actionSettingsDefinition.ActionSettingsDefinitionID = actionSettingsDefinitionID;
            actionSettingsDefinition.Name = name;
            actionSettingsDefinition.SettingSchema = settingSchema;
            actionSettingsDefinition.DTModified = dTModified;
            return actionSettingsDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionSettingsDefinitionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int ActionSettingsDefinitionID
        {
            get
            {
                return this._ActionSettingsDefinitionID;
            }
            set
            {
                this.OnActionSettingsDefinitionIDChanging(value);
                this.ReportPropertyChanging("ActionSettingsDefinitionID");
                this._ActionSettingsDefinitionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("ActionSettingsDefinitionID");
                this.OnActionSettingsDefinitionIDChanged();
            }
        }
        private int _ActionSettingsDefinitionID;
        partial void OnActionSettingsDefinitionIDChanging(int value);
        partial void OnActionSettingsDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property SettingSchema in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string SettingSchema
        {
            get
            {
                return this._SettingSchema;
            }
            set
            {
                this.OnSettingSchemaChanging(value);
                this.ReportPropertyChanging("SettingSchema");
                this._SettingSchema = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("SettingSchema");
                this.OnSettingSchemaChanged();
            }
        }
        private string _SettingSchema;
        partial void OnSettingSchemaChanging(string value);
        partial void OnSettingSchemaChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionDefinition ActionDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionDefinition> ActionDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionDefinition>("RewardsDBModel.FKActionSettingsDefinition_ActionDefinition_ActionDefinitionID", "ActionDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinitionID", "ActionSettings")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionSettings> ActionSettings
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionSettings>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                        "ID", "ActionSettings");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionSettings>("RewardsDBModel.FKActionSettings_ActionSettingsDefinition_ActionSettingsDefinition" +
                            "ID", "ActionSettings", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.DataType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// DataTypeID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="DataType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class DataType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new DataType object.
        /// </summary>
        /// <param name="dataTypeID">Initial value of DataTypeID.</param>
        /// <param name="dataTypeString">Initial value of DataTypeString.</param>
        public static DataType CreateDataType(int dataTypeID, string dataTypeString)
        {
            DataType dataType = new DataType();
            dataType.DataTypeID = dataTypeID;
            dataType.DataTypeString = dataTypeString;
            return dataType;
        }
        /// <summary>
        /// There are no comments for Property DataTypeID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int DataTypeID
        {
            get
            {
                return this._DataTypeID;
            }
            set
            {
                this.OnDataTypeIDChanging(value);
                this.ReportPropertyChanging("DataTypeID");
                this._DataTypeID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DataTypeID");
                this.OnDataTypeIDChanged();
            }
        }
        private int _DataTypeID;
        partial void OnDataTypeIDChanging(int value);
        partial void OnDataTypeIDChanged();
        /// <summary>
        /// There are no comments for Property DataTypeString in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string DataTypeString
        {
            get
            {
                return this._DataTypeString;
            }
            set
            {
                this.OnDataTypeStringChanging(value);
                this.ReportPropertyChanging("DataTypeString");
                this._DataTypeString = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("DataTypeString");
                this.OnDataTypeStringChanged();
            }
        }
        private string _DataTypeString;
        partial void OnDataTypeStringChanging(string value);
        partial void OnDataTypeStringChanged();
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKActionParameterDefinition_DataType_DataTypeID", "ActionParameterDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<ActionParameterDefinition>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "ActionParameterDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<ActionParameterDefinition>("RewardsDBModel.FKActionParameterDefinition_DataType_DataTypeID", "ActionParameterDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaProperties_DataType_DataTypeID", "GameSchemaProperties")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<GameSchemaProperties>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "GameSchemaProperties");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<GameSchemaProperties>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "GameSchemaProperties", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_DataType_DataTypeID", "RuleExpression")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RuleExpression> RuleExpression
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "RuleExpression");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "RuleExpression", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKStatDescription_DataType_DataTypeID", "StatDescription")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<StatDescription> StatDescription
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<StatDescription>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "StatDescription");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<StatDescription>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "StatDescription", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameCategories in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameCategoryID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="GameCategories")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class GameCategories : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new GameCategories object.
        /// </summary>
        /// <param name="gameCategoryID">Initial value of GameCategoryID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameCategories CreateGameCategories(int gameCategoryID, string name, global::System.DateTime dTModified)
        {
            GameCategories gameCategories = new GameCategories();
            gameCategories.GameCategoryID = gameCategoryID;
            gameCategories.Name = name;
            gameCategories.DTModified = dTModified;
            return gameCategories;
        }
        /// <summary>
        /// There are no comments for Property GameCategoryID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int GameCategoryID
        {
            get
            {
                return this._GameCategoryID;
            }
            set
            {
                this.OnGameCategoryIDChanging(value);
                this.ReportPropertyChanging("GameCategoryID");
                this._GameCategoryID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("GameCategoryID");
                this.OnGameCategoryIDChanged();
            }
        }
        private int _GameCategoryID;
        partial void OnGameCategoryIDChanging(int value);
        partial void OnGameCategoryIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameKeys in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameKeyID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="GameKeys")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class GameKeys : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new GameKeys object.
        /// </summary>
        /// <param name="gameKeyID">Initial value of GameKeyID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameKeys CreateGameKeys(int gameKeyID, string name, global::System.DateTime dTModified)
        {
            GameKeys gameKeys = new GameKeys();
            gameKeys.GameKeyID = gameKeyID;
            gameKeys.Name = name;
            gameKeys.DTModified = dTModified;
            return gameKeys;
        }
        /// <summary>
        /// There are no comments for Property GameKeyID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int GameKeyID
        {
            get
            {
                return this._GameKeyID;
            }
            set
            {
                this.OnGameKeyIDChanging(value);
                this.ReportPropertyChanging("GameKeyID");
                this._GameKeyID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("GameKeyID");
                this.OnGameKeyIDChanged();
            }
        }
        private int _GameKeyID;
        partial void OnGameKeyIDChanging(int value);
        partial void OnGameKeyIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameKeys_Platforms_PlatformID", "Platforms")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Platforms Platforms
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Platforms>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "Platforms").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Platforms>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "Platforms").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Platforms> PlatformsReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Platforms>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "Platforms");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Platforms>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "Platforms", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaNames_GameKeys_GameKeyID", "GameSchemaNames")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<GameSchemaNames> GameSchemaNames
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<GameSchemaNames>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameSchemaNames");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<GameSchemaNames>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameSchemaNames", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_GameKeys_GameKeyID", "Reward")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Reward> Reward
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Reward>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "Reward");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Reward>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "Reward", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRule_GameKeys_GameKeyID", "Rule")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Rule> Rule
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Rule>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "Rule");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Rule>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "Rule", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKStatDescription_GameKeys_GameKeyID", "StatDescription")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<StatDescription> StatDescription
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<StatDescription>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "StatDescription");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<StatDescription>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "StatDescription", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameSchemaNames in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameSchemaNameID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="GameSchemaNames")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class GameSchemaNames : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new GameSchemaNames object.
        /// </summary>
        /// <param name="gameSchemaNameID">Initial value of GameSchemaNameID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="ordered">Initial value of Ordered.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameSchemaNames CreateGameSchemaNames(int gameSchemaNameID, string name, bool ordered, global::System.DateTime dTModified)
        {
            GameSchemaNames gameSchemaNames = new GameSchemaNames();
            gameSchemaNames.GameSchemaNameID = gameSchemaNameID;
            gameSchemaNames.Name = name;
            gameSchemaNames.Ordered = ordered;
            gameSchemaNames.DTModified = dTModified;
            return gameSchemaNames;
        }
        /// <summary>
        /// There are no comments for Property GameSchemaNameID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int GameSchemaNameID
        {
            get
            {
                return this._GameSchemaNameID;
            }
            set
            {
                this.OnGameSchemaNameIDChanging(value);
                this.ReportPropertyChanging("GameSchemaNameID");
                this._GameSchemaNameID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("GameSchemaNameID");
                this.OnGameSchemaNameIDChanged();
            }
        }
        private int _GameSchemaNameID;
        partial void OnGameSchemaNameIDChanging(int value);
        partial void OnGameSchemaNameIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Ordered in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public bool Ordered
        {
            get
            {
                return this._Ordered;
            }
            set
            {
                this.OnOrderedChanging(value);
                this.ReportPropertyChanging("Ordered");
                this._Ordered = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("Ordered");
                this.OnOrderedChanged();
            }
        }
        private bool _Ordered;
        partial void OnOrderedChanging(bool value);
        partial void OnOrderedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public GameKeys GameKeys
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<GameKeys> GameKeysReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<GameKeys>("RewardsDBModel.FKGameSchemaNames_GameKeys_GameKeyID", "GameKeys", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaProperties")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<GameSchemaProperties>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaProperties");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<GameSchemaProperties>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaProperties", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameSchemaProperties in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameSchemaPropertyID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="GameSchemaProperties")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class GameSchemaProperties : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new GameSchemaProperties object.
        /// </summary>
        /// <param name="gameSchemaPropertyID">Initial value of GameSchemaPropertyID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="order">Initial value of Order.</param>
        /// <param name="required">Initial value of Required.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameSchemaProperties CreateGameSchemaProperties(int gameSchemaPropertyID, string name, int order, bool required, global::System.DateTime dTModified)
        {
            GameSchemaProperties gameSchemaProperties = new GameSchemaProperties();
            gameSchemaProperties.GameSchemaPropertyID = gameSchemaPropertyID;
            gameSchemaProperties.Name = name;
            gameSchemaProperties.Order = order;
            gameSchemaProperties.Required = required;
            gameSchemaProperties.DTModified = dTModified;
            return gameSchemaProperties;
        }
        /// <summary>
        /// There are no comments for Property GameSchemaPropertyID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int GameSchemaPropertyID
        {
            get
            {
                return this._GameSchemaPropertyID;
            }
            set
            {
                this.OnGameSchemaPropertyIDChanging(value);
                this.ReportPropertyChanging("GameSchemaPropertyID");
                this._GameSchemaPropertyID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("GameSchemaPropertyID");
                this.OnGameSchemaPropertyIDChanged();
            }
        }
        private int _GameSchemaPropertyID;
        partial void OnGameSchemaPropertyIDChanging(int value);
        partial void OnGameSchemaPropertyIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Order in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int Order
        {
            get
            {
                return this._Order;
            }
            set
            {
                this.OnOrderChanging(value);
                this.ReportPropertyChanging("Order");
                this._Order = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("Order");
                this.OnOrderChanged();
            }
        }
        private int _Order;
        partial void OnOrderChanging(int value);
        partial void OnOrderChanged();
        /// <summary>
        /// There are no comments for Property Required in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public bool Required
        {
            get
            {
                return this._Required;
            }
            set
            {
                this.OnRequiredChanging(value);
                this.ReportPropertyChanging("Required");
                this._Required = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("Required");
                this.OnRequiredChanged();
            }
        }
        private bool _Required;
        partial void OnRequiredChanging(bool value);
        partial void OnRequiredChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaProperties_DataType_DataTypeID", "DataType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public DataType DataType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "DataType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "DataType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<DataType> DataTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "DataType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<DataType>("RewardsDBModel.FKGameSchemaProperties_DataType_DataTypeID", "DataType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public GameSchemaNames GameSchemaNames
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameSchemaNames>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameSchemaNames>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<GameSchemaNames> GameSchemaNamesReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameSchemaNames>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<GameSchemaNames>("RewardsDBModel.FKGameSchemaProperties_GameSchemaName_GameSchemaNameID", "GameSchemaNames", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Locale in the schema.
    /// </summary>
    /// <KeyProperties>
    /// LCID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="Locale")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Locale : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new Locale object.
        /// </summary>
        /// <param name="lCID">Initial value of LCID.</param>
        /// <param name="locale1">Initial value of Locale1.</param>
        /// <param name="collation">Initial value of Collation.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Locale CreateLocale(int lCID, string locale1, string collation, global::System.DateTime dTModified)
        {
            Locale locale = new Locale();
            locale.LCID = lCID;
            locale.Locale1 = locale1;
            locale.Collation = collation;
            locale.DTModified = dTModified;
            return locale;
        }
        /// <summary>
        /// There are no comments for Property LCID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int LCID
        {
            get
            {
                return this._LCID;
            }
            set
            {
                this.OnLCIDChanging(value);
                this.ReportPropertyChanging("LCID");
                this._LCID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("LCID");
                this.OnLCIDChanged();
            }
        }
        private int _LCID;
        partial void OnLCIDChanging(int value);
        partial void OnLCIDChanged();
        /// <summary>
        /// There are no comments for Property Locale1 in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Locale1
        {
            get
            {
                return this._Locale1;
            }
            set
            {
                this.OnLocale1Changing(value);
                this.ReportPropertyChanging("Locale1");
                this._Locale1 = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Locale1");
                this.OnLocale1Changed();
            }
        }
        private string _Locale1;
        partial void OnLocale1Changing(string value);
        partial void OnLocale1Changed();
        /// <summary>
        /// There are no comments for Property Collation in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Collation
        {
            get
            {
                return this._Collation;
            }
            set
            {
                this.OnCollationChanging(value);
                this.ReportPropertyChanging("Collation");
                this._Collation = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Collation");
                this.OnCollationChanged();
            }
        }
        private string _Collation;
        partial void OnCollationChanging(string value);
        partial void OnCollationChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRewardLocale_Locale_LCID", "RewardLocale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RewardLocale> RewardLocale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RewardLocale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "RewardLocale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RewardLocale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "RewardLocale", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Platforms in the schema.
    /// </summary>
    /// <KeyProperties>
    /// PlatformID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="Platforms")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Platforms : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new Platforms object.
        /// </summary>
        /// <param name="platformID">Initial value of PlatformID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Platforms CreatePlatforms(int platformID, string name, global::System.DateTime dTModified)
        {
            Platforms platforms = new Platforms();
            platforms.PlatformID = platformID;
            platforms.Name = name;
            platforms.DTModified = dTModified;
            return platforms;
        }
        /// <summary>
        /// There are no comments for Property PlatformID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int PlatformID
        {
            get
            {
                return this._PlatformID;
            }
            set
            {
                this.OnPlatformIDChanging(value);
                this.ReportPropertyChanging("PlatformID");
                this._PlatformID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("PlatformID");
                this.OnPlatformIDChanged();
            }
        }
        private int _PlatformID;
        partial void OnPlatformIDChanging(int value);
        partial void OnPlatformIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKGameKeys_Platforms_PlatformID", "GameKeys")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<GameKeys> GameKeys
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<GameKeys>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "GameKeys");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<GameKeys>("RewardsDBModel.FKGameKeys_Platforms_PlatformID", "GameKeys", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Reward in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="Reward")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Reward : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new Reward object.
        /// </summary>
        /// <param name="rewardID">Initial value of RewardID.</param>
        /// <param name="dTStart">Initial value of DTStart.</param>
        /// <param name="dTEnd">Initial value of DTEnd.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Reward CreateReward(int rewardID, global::System.DateTime dTStart, global::System.DateTime dTEnd, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            Reward reward = new Reward();
            reward.RewardID = rewardID;
            reward.DTStart = dTStart;
            reward.DTEnd = dTEnd;
            reward.DTCreated = dTCreated;
            reward.DTModified = dTModified;
            return reward;
        }
        /// <summary>
        /// There are no comments for Property RewardID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RewardID
        {
            get
            {
                return this._RewardID;
            }
            set
            {
                this.OnRewardIDChanging(value);
                this.ReportPropertyChanging("RewardID");
                this._RewardID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RewardID");
                this.OnRewardIDChanged();
            }
        }
        private int _RewardID;
        partial void OnRewardIDChanging(int value);
        partial void OnRewardIDChanged();
        /// <summary>
        /// There are no comments for Property RewardValue in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string RewardValue
        {
            get
            {
                return this._RewardValue;
            }
            set
            {
                this.OnRewardValueChanging(value);
                this.ReportPropertyChanging("RewardValue");
                this._RewardValue = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("RewardValue");
                this.OnRewardValueChanged();
            }
        }
        private string _RewardValue;
        partial void OnRewardValueChanging(string value);
        partial void OnRewardValueChanged();
        /// <summary>
        /// There are no comments for Property DTStart in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTStart
        {
            get
            {
                return this._DTStart;
            }
            set
            {
                this.OnDTStartChanging(value);
                this.ReportPropertyChanging("DTStart");
                this._DTStart = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTStart");
                this.OnDTStartChanged();
            }
        }
        private global::System.DateTime _DTStart;
        partial void OnDTStartChanging(global::System.DateTime value);
        partial void OnDTStartChanged();
        /// <summary>
        /// There are no comments for Property DTEnd in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTEnd
        {
            get
            {
                return this._DTEnd;
            }
            set
            {
                this.OnDTEndChanging(value);
                this.ReportPropertyChanging("DTEnd");
                this._DTEnd = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTEnd");
                this.OnDTEndChanged();
            }
        }
        private global::System.DateTime _DTEnd;
        partial void OnDTEndChanging(global::System.DateTime value);
        partial void OnDTEndChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this.ReportPropertyChanging("DTCreated");
                this._DTCreated = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTCreated");
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_GameKeys_GameKeyID", "GameKeys")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public GameKeys GameKeys
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "GameKeys").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "GameKeys").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<GameKeys> GameKeysReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "GameKeys");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<GameKeys>("RewardsDBModel.FKReward_GameKeys_GameKeyID", "GameKeys", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FK_Rule_Reward_RewardID", "Rule")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Rule> Rule
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Rule>("RewardsDBModel.FK_Rule_Reward_RewardID", "Rule");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Rule>("RewardsDBModel.FK_Rule_Reward_RewardID", "Rule", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_RewardCategory_RewardCategoryID", "RewardCategory")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public RewardCategory RewardCategory
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardCategory>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "RewardCategory").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardCategory>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "RewardCategory").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<RewardCategory> RewardCategoryReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardCategory>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "RewardCategory");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<RewardCategory>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "RewardCategory", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_RewardType_RewardTypeID", "RewardType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public RewardType RewardType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardType>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "RewardType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardType>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "RewardType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<RewardType> RewardTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RewardType>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "RewardType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<RewardType>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "RewardType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRewardLocale_Reward_RewardID", "RewardLocale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RewardLocale> RewardLocale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RewardLocale>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "RewardLocale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RewardLocale>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "RewardLocale", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardCategory in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardCategoryID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RewardCategory")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RewardCategory : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RewardCategory object.
        /// </summary>
        /// <param name="rewardCategoryID">Initial value of RewardCategoryID.</param>
        /// <param name="rewardCategoryName">Initial value of RewardCategoryName.</param>
        public static RewardCategory CreateRewardCategory(int rewardCategoryID, string rewardCategoryName)
        {
            RewardCategory rewardCategory = new RewardCategory();
            rewardCategory.RewardCategoryID = rewardCategoryID;
            rewardCategory.RewardCategoryName = rewardCategoryName;
            return rewardCategory;
        }
        /// <summary>
        /// There are no comments for Property RewardCategoryID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RewardCategoryID
        {
            get
            {
                return this._RewardCategoryID;
            }
            set
            {
                this.OnRewardCategoryIDChanging(value);
                this.ReportPropertyChanging("RewardCategoryID");
                this._RewardCategoryID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RewardCategoryID");
                this.OnRewardCategoryIDChanged();
            }
        }
        private int _RewardCategoryID;
        partial void OnRewardCategoryIDChanging(int value);
        partial void OnRewardCategoryIDChanged();
        /// <summary>
        /// There are no comments for Property RewardCategoryName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string RewardCategoryName
        {
            get
            {
                return this._RewardCategoryName;
            }
            set
            {
                this.OnRewardCategoryNameChanging(value);
                this.ReportPropertyChanging("RewardCategoryName");
                this._RewardCategoryName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("RewardCategoryName");
                this.OnRewardCategoryNameChanged();
            }
        }
        private string _RewardCategoryName;
        partial void OnRewardCategoryNameChanging(string value);
        partial void OnRewardCategoryNameChanged();
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_RewardCategory_RewardCategoryID", "Reward")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Reward> Reward
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Reward>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "Reward");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Reward>("RewardsDBModel.FKReward_RewardCategory_RewardCategoryID", "Reward", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardLocale in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardLocaleID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RewardLocale")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RewardLocale : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RewardLocale object.
        /// </summary>
        /// <param name="rewardLocaleID">Initial value of RewardLocaleID.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RewardLocale CreateRewardLocale(int rewardLocaleID, global::System.DateTime dTModified)
        {
            RewardLocale rewardLocale = new RewardLocale();
            rewardLocale.RewardLocaleID = rewardLocaleID;
            rewardLocale.DTModified = dTModified;
            return rewardLocale;
        }
        /// <summary>
        /// There are no comments for Property RewardLocaleID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RewardLocaleID
        {
            get
            {
                return this._RewardLocaleID;
            }
            set
            {
                this.OnRewardLocaleIDChanging(value);
                this.ReportPropertyChanging("RewardLocaleID");
                this._RewardLocaleID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RewardLocaleID");
                this.OnRewardLocaleIDChanged();
            }
        }
        private int _RewardLocaleID;
        partial void OnRewardLocaleIDChanging(int value);
        partial void OnRewardLocaleIDChanged();
        /// <summary>
        /// There are no comments for Property LocRewardName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string LocRewardName
        {
            get
            {
                return this._LocRewardName;
            }
            set
            {
                this.OnLocRewardNameChanging(value);
                this.ReportPropertyChanging("LocRewardName");
                this._LocRewardName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("LocRewardName");
                this.OnLocRewardNameChanged();
            }
        }
        private string _LocRewardName;
        partial void OnLocRewardNameChanging(string value);
        partial void OnLocRewardNameChanged();
        /// <summary>
        /// There are no comments for Property LocRewardDescription in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string LocRewardDescription
        {
            get
            {
                return this._LocRewardDescription;
            }
            set
            {
                this.OnLocRewardDescriptionChanging(value);
                this.ReportPropertyChanging("LocRewardDescription");
                this._LocRewardDescription = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("LocRewardDescription");
                this.OnLocRewardDescriptionChanged();
            }
        }
        private string _LocRewardDescription;
        partial void OnLocRewardDescriptionChanging(string value);
        partial void OnLocRewardDescriptionChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRewardLocale_Locale_LCID", "Locale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Locale Locale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "Locale").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "Locale").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Locale> LocaleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "Locale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Locale>("RewardsDBModel.FKRewardLocale_Locale_LCID", "Locale", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRewardLocale_Reward_RewardID", "Reward")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Reward Reward
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "Reward").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "Reward").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Reward> RewardReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "Reward");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Reward>("RewardsDBModel.FKRewardLocale_Reward_RewardID", "Reward", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardTypeID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RewardType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RewardType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RewardType object.
        /// </summary>
        /// <param name="rewardTypeID">Initial value of RewardTypeID.</param>
        /// <param name="rewardTypeName">Initial value of RewardTypeName.</param>
        public static RewardType CreateRewardType(int rewardTypeID, string rewardTypeName)
        {
            RewardType rewardType = new RewardType();
            rewardType.RewardTypeID = rewardTypeID;
            rewardType.RewardTypeName = rewardTypeName;
            return rewardType;
        }
        /// <summary>
        /// There are no comments for Property RewardTypeID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RewardTypeID
        {
            get
            {
                return this._RewardTypeID;
            }
            set
            {
                this.OnRewardTypeIDChanging(value);
                this.ReportPropertyChanging("RewardTypeID");
                this._RewardTypeID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RewardTypeID");
                this.OnRewardTypeIDChanged();
            }
        }
        private int _RewardTypeID;
        partial void OnRewardTypeIDChanging(int value);
        partial void OnRewardTypeIDChanged();
        /// <summary>
        /// There are no comments for Property RewardTypeName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string RewardTypeName
        {
            get
            {
                return this._RewardTypeName;
            }
            set
            {
                this.OnRewardTypeNameChanging(value);
                this.ReportPropertyChanging("RewardTypeName");
                this._RewardTypeName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("RewardTypeName");
                this.OnRewardTypeNameChanged();
            }
        }
        private string _RewardTypeName;
        partial void OnRewardTypeNameChanging(string value);
        partial void OnRewardTypeNameChanged();
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKReward_RewardType_RewardTypeID", "Reward")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Reward> Reward
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Reward>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "Reward");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Reward>("RewardsDBModel.FKReward_RewardType_RewardTypeID", "Reward", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Rule in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="Rule")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Rule : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new Rule object.
        /// </summary>
        /// <param name="ruleID">Initial value of RuleID.</param>
        /// <param name="dTStart">Initial value of DTStart.</param>
        /// <param name="dTEnd">Initial value of DTEnd.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Rule CreateRule(int ruleID, global::System.DateTime dTStart, global::System.DateTime dTEnd, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            Rule rule = new Rule();
            rule.RuleID = ruleID;
            rule.DTStart = dTStart;
            rule.DTEnd = dTEnd;
            rule.DT