teIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;

using xonline.tools.sqlcrawler;
using xonline.tools.sqlcrawler.data;
using xonline.tools.sqlcrawler.manifest.dependency;
using xonline.tools.sqlcrawler.manifest;
using xonline.tools.sqlcrawler.manifest.element;
using xonline.tools.sqlcrawler.schema;

namespace SQLCrawler
{
    enum ExtractionFlags
    {
        None = 0
    }

    class Program
    {
        const int ReturnCodeForHelp = 1;
        const int ReturnCodeForSuccess = 0;
        const int ReturnCodeForInvalidArguments = 2;
        const int ReturnCodeForFailure = 3;

        static StringDictionary ReadParameters(string[] args, int start, params string[] expected)
        {
            var collection = new StringDictionary();

            for (int c = start; c < args.Length; c++)
            {
                string arg = args[c];
                string[] pair;

                if (!arg.StartsWith("/"))
                {
                    Console.WriteLine("Invalid argument specification at " + c);
                    return null;
                }

                pair = arg.Substring(1).Split(
                    new char[] { ':' },
                    2,
                    StringSplitOptions.RemoveEmptyEntries);

                if (pair.Length != 2)
                {
                    Console.WriteLine("Argument missing value at " + c);
                    return null;
                }

                if (!Array.Exists(expected, n => string.Compare(pair[0], n, true) == 0))
                {
                    Console.WriteLine("Unexpected argument name at " + c);
                    return null;
                }

                collection[pair[0]] = pair[1];
            }

            return collection;
        }

        static int Main(string[] args)
        {
            var comparison = StringComparison.CurrentCultureIgnoreCase;

            if (args.Length < 1 || string.Equals(args[0], "/help", comparison))
            {
                MainHelp();
                return ReturnCodeForHelp;
            }

            if (string.Equals(args[0], "extract", comparison))
            {
                if (args.Length == 2 && string.Equals(args[1], "/help", comparison))
                {
                    ExtractDatabaseHelp();
                    return ReturnCodeForHelp;
                }

                var parameters = ReadParameters(args, 1, "config", "server", "db", "ver", "out");
                
                if (parameters == null || parameters.Count != 5)
                {
                    Console.WriteLine("Invalid argument specification.");
                    ExtractDatabaseHelp();
                    return ReturnCodeForInvalidArguments;
                }

                return ExtractDatabase(
                    parameters["config"],
                    parameters["server"],
                    parameters["db"],
                    parameters["ver"],
                    parameters["out"],
                    ExtractionFlags.None);
            }

            if (string.Equals(args[0], "manisort", comparison))
            {
                if (args.Length == 2 && string.Equals(args[1], "/help", comparison))
                {
                    ManifestSortHelp();
                    return ReturnCodeForHelp;
                }

                var parameters = ReadParameters(args, 1, "in", "out");

                if (parameters == null || parameters.Count != 2)
                {
                    Console.WriteLine("Invalid argument specification.");
                    ExtractDatabaseHelp();
                    return ReturnCodeForInvalidArguments;
                }

                return ManifestSort(parameters["in"], parameters["out"]);
            }

            if (string.Equals(args[0], "debug", comparison))
            {
                return ExtractDatabase(
                    "X:\\Example.xml",
                    "jojohnxbl001",
                    "npdb",
                    "1.2.3.4",
                    "X:\\Temp\\Crawler\\" + Guid.NewGuid() + "\\npdb",
                    ExtractionFlags.None);
            }

            Console.WriteLine("Unexpected arguments specified.");
            MainHelp();

            return ReturnCodeForFailure;
        }

        static void ConvertConfigurationFile()
        {
            throw new NotImplementedException();
        }

        static void GenerateConfigurationFile()
        {
            throw new NotImplementedException();
        }

        static void IntegrateExtraction()
        {
            throw new NotImplementedException();
        }

        static int ManifestSort(string input, string output)
        {
            XmlDocument doc = new XmlDocument();
            XmlNamespaceManager xnm;

            try
            {
                Console.WriteLine("Loading " + Path.GetFullPath(input) + "...");
                doc.Load(input);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error loading document:");
                Console.WriteLine(e.Message);
                return ReturnCodeForFailure;
            }


            xnm = new XmlNamespaceManager(doc.NameTable);
            xnm.AddNamespace("ws", "urn:WebstoreManifestSchema.xsd");

            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Tables", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Triggers", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Sprocs", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Views", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Functions", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Scripts", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:Jobs", xnm));
            Sort(doc.SelectSingleNode("/ws:Webstore/ws:Manifest/ws:SqlObjects/ws:SecurityRoles", xnm));

            using (XmlTextWriter xtr = new XmlTextWriter(output, Encoding.Unicode))
            {
                xtr.Formatting = Formatting.Indented;
                xtr.Indentation = 4;
                xtr.IndentChar = ' ';
                xtr.QuoteChar = '"';

                Console.WriteLine("Saving " + Path.GetFullPath(input) + "...");
                try
                {
                    doc.Save(xtr);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error saving document:");
                    Console.WriteLine(e.Message);
                    return ReturnCodeForFailure;
                }
            }

            return ReturnCodeForSuccess;
        }

        static void Sort(XmlNode node)
        {
            if (null != node)
            {
                List<XmlNode> nodes = new List<XmlNode>();

                Console.WriteLine("Sorting " + node.Name);

                foreach (XmlNode child in node.SelectNodes("child::*"))
                {
                    nodes.Add(child);
                    node.RemoveChild(child);
                }

                nodes.Sort((a, b) => a.Attributes["Name"].Value.CompareTo(b.Attributes["Name"].Value));

                Console.WriteLine("   " + nodes.Count + " elements sorted");

                foreach (XmlNode child in nodes)
                {
                    node.AppendChild(child);
                }
            }
        }

        static int ExtractDatabase(
            string configurationFile,
            string serverName,
            string databaseName,
            string version,
            string outputDirectory,
            ExtractionFlags flags)
        {
            ExtractionEnvironment environment;
            SchemaExtractorFactory schemaExtractor;
            DataExtractionEngine dataExtractor = null;
            ManifestBuilder manifestGenerator;
            WebstoreManifest manifest;
            string connection;

            try
            {
                environment = new ExtractionEnvironment();
                environment.LoadConfiguration(configurationFile);

                connection = string.Format("Server={0};Integrated Security=SSPI;Database={1}", serverName, databaseName);

                schemaExtractor = new SchemaExtractorFactory(outputDirectory);

                dataExtractor = new DataExtractionEngine(outputDirectory, connection);

                manifestGenerator = new ManifestBuilder(
                    serverName,
                    databaseName,
                    environment.Configuration,
                    schemaExtractor,
                    dataExtractor);

                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine(" > Creating Webstore Manifest...");
                Console.ResetColor();
                manifest = manifestGenerator.CreateManifest(new Version(version));

                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine(" > Saving Manifest...");
                Console.ResetColor();
                manifest.Save(Path.Combine(outputDirectory, "manifest.xml"));

                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine(" > Saving Configuration File...");
                Console.ResetColor();
                environment.Configuration.Save(Path.Combine(outputDirectory, "configuration.xml"));
            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected error: ");
                Console.WriteLine(e);
                return ReturnCodeForFailure;
            }
            finally
            {
                if (null != dataExtractor)
                    dataExtractor.Dispose();
            }

            return ReturnCodeForSuccess;
        }

        static void MainHelp()
        {
            Console.WriteLine("SqlCrawler assists in database extractions.");

            Console.WriteLine("OPTIONS:");
            Console.WriteLine("SqlCrawler.exe extract /help");
            Console.WriteLine("   Provides help info on database extractions.");
        }

        static void ManifestSortHelp()
        {
            Console.WriteLine("USAGE:");
            Console.WriteLine("SqlCrawler.exe extract /in:manifest /out:manifest");
            Console.WriteLine();
            Console.WriteLine("PARAMETERS:");
            Console.WriteLine("    in   path to input manifest file.");
            Console.WriteLine("    out  path to output manifest file.");
        }

        static void ExtractDatabaseHelp()
        {
            Console.WriteLine("USAGE:");
            Console.WriteLine("SqlCrawler.exe extract /config:file /server:name /db:name /ver:x.y.z.w /out:path");
            Console.WriteLine();
            Console.WriteLine("PARAMETERS:");
            Console.WriteLine("    config  path to configuration file.");
            Console.WriteLine("    server  SQL Server 2005, 2008 machine name.");
            Console.WriteLine("    db      name of database to extract.");
            Console.WriteLine("    ver     version of the manifest.");
            Console.WriteLine("    out     directory to output to.");
            Console.WriteLine("");
            Console.WriteLine("REMARKS:");
            Console.WriteLine("    Configuration File: minimize the amount of manual changes you require with your extraction by refining your configuration file.");
            Console.WriteLine("    Server: SQL Server 2003 is not supported, it is not compatible with the current version of SMO.");
            Console.WriteLine("    Database: the database name pushed into the manifest will be the one specified in the configuration file.");
            Console.WriteLine("    Version: this should correspond to the version of the build that went to production.");
            Console.WriteLine("    Output Directory: the manifest, config, ddl, and dml files will be written to this directory.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\ExtractionEnvironment.cs ===
﻿using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler {
   public class ExtractionEnvironment {
      public static ExtractionEnvironment Active {
         get {
            if (null == active) {
               active = new ExtractionEnvironment();
               active.Arguments = new StringDictionary();
            }

            return active;
         }
      }

      public void LoadConfiguration(string path) {
         XmlDocument configuration = new XmlDocument();

         if (string.IsNullOrEmpty(path))
            throw new ArgumentNullException("path");

         configuration.Load(path);

         NamespaceManager = new XmlNamespaceManager(configuration.NameTable);
         NamespaceManager.AddNamespace("action", "urn:Actions.xsd");

         Configuration = configuration;
      }

      public StringDictionary Arguments;
      public WebstoreManifest WebstoreManifest;
      public XmlDocument Configuration;
      public ExtractionFlags Flags;
      public string ConnectionString;
      public string TargetDirectory;
      public XmlNamespaceManager NamespaceManager;

      private static ExtractionEnvironment active;
   }

   [Flags]
   public enum ExtractionFlags {
      Default = 0,
      ExcludeManifest = 1,
      ExcludeSchema = 2,
      ExcludeData = 4
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\data\ColumnSerializer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;

namespace xonline.tools.sqlcrawler.data {
    public delegate string SerializationFunction(SqlDataReader reader, int column);

    public class ColumnSerializer {
        private static string serHexadecimal(byte[] array) {
            StringBuilder Builder;
            Builder = new StringBuilder(array.Length * 2 + 2);
            Builder.Append("0x");
            for (int c = 0; c < array.Length; c++)
                Builder.AppendFormat("{0:X2}", array[c]);
            return Builder.ToString();
        }
        private static string serNumeric(object value) {
            return value.ToString();
        }
        private static string serSimpleString(object value) {
            return "'" + value.ToString() + "'";
        }
        private static string serString(object value) {
            return serSimpleString(value.ToString().Replace("'", "''"));
        }
        private static string serUnicodeString(object value) {
            return "N" + serString(value);
        }
        private static string serDateTime(DateTime value) { 
            return serSimpleString(value.ToString("yyyy-MM-dd HH:mm:ss.FFFFFFF")); 
        }

        private static string serSqlBinary(SqlBinary value) { return serHexadecimal(value.Value); }
        private static string serSqlBoolean(SqlBoolean value) { return serSimpleString(value.Value); }
        private static string serSqlByte(SqlByte value) { return serNumeric(value.Value); }
        private static string serSqlDateTime(SqlDateTime value) { return serDateTime(value.Value); }
        private static string serSqlDecimal(SqlDecimal value) { return serNumeric(value.Value); }
        private static string serSqlDouble(SqlDouble value) { return serNumeric(value.Value); }
        private static string serSqlGuid(SqlGuid value) { return serSimpleString(value.Value); }
        private static string serSqlInt16(SqlInt16 value) { return serNumeric(value.Value); }
        private static string serSqlInt32(SqlInt32 value) { return serNumeric(value.Value); }
        private static string serSqlInt64(SqlInt64 value) { return serNumeric(value.Value); }
        private static string serSqlMoney(SqlMoney value) { return serNumeric(value.Value); }
        private static string serSqlSingle(SqlSingle value) { return serNumeric(value.Value); }
        private static string serSqlString(SqlString value) { return serString(value.Value); }
        private static string serUnicodeSqlString(SqlString value) { return serUnicodeString(value.Value); }
        private static string serSqlXml(SqlXml value) { return serString(value.Value); }

        private static bool isNull(object value) {
            if (value is DBNull)
                return true;
            if (value is INullable && ((INullable)value).IsNull)
                return true;

            return false;
        }

        private static string serSqlBinary(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlBinary((SqlBinary)value); 
        }

        private static string serSqlBoolean(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlBoolean((SqlBoolean)value); 
        }

        private static string serSqlByte(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlByte((SqlByte)value); 
        }

        private static string serSqlDateTime(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            if (value != null && value is DateTime)
                return serDateTime((DateTime)value);
            return isNull(value) ? "NULL" : serSqlDateTime((SqlDateTime)value); 
        }

        private static string serSqlDecimal(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlDecimal((SqlDecimal)value); 
        }

        private static string serSqlDouble(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlDouble((SqlDouble)value); 
        }

        private static string serSqlGuid(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlGuid((SqlGuid)value); 
        }

        private static string serSqlInt16(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlInt16((SqlInt16)value); 
        }

        private static string serSqlInt32(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlInt32((SqlInt32)value); 
        }

        private static string serSqlInt64(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlInt64((SqlInt64)value); 
        }

        private static string serSqlMoney(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlMoney((SqlMoney)value); 
        }

        private static string serSqlSingle(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlSingle((SqlSingle)value); 
        }

        private static string serSqlString(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlString((SqlString)value);
        }

        private static string serUnicodeSqlString(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serUnicodeSqlString((SqlString)value); 
        }

        private static string serSqlXml(SqlDataReader reader, int column) {
            object value = reader.GetSqlValue(column);
            return isNull(value) ? "NULL" : serSqlXml((SqlXml)value); 
        }

        public static SerializationFunction GetSerializationFunction(string type) {
            switch (type) {
                // Exact Numerics
                case "bigint":
                    return serSqlInt64;
                case "bit":
                    return serSqlBoolean;
                case "decimal":
                    return serSqlDecimal;
                case "int":
                    return serSqlInt32;
                case "money":
                    return serSqlMoney;
                case "numeric":
                    return serSqlDecimal;
                case "smallint":
                    return serSqlInt16;
                case "smallmoney":
                    return serSqlMoney;
                case "tinyint":
                    return serSqlByte;

                // Approximate Numerics
                case "float":
                    return serSqlDouble;
                case "real":
                    return serSqlSingle;

                // Date and Time
                case "date":
                case "datetime2":
                case "datetime":
                case "datetimeoffset":
                case "smalldatetime":
                case "time":
                case "timestamp":
                    return serSqlDateTime;

                // Character Strings
                case "text":
                case "varchar":
                case "char":
                    return serSqlString;

                // Unicode Character Strings
                case "ntext":
                case "nvarchar":
                case "nchar":
                    return serUnicodeSqlString;
                
                // Binary Strings
                case "binary":
                case "image":
                case "varbinary":
                    return serSqlBinary;

                // Misc
                case "xml":
                    return serSqlXml;
                case "uniqueidentifier":
                    return serSqlGuid;

                // Missed one?
                default:
                    throw new InvalidOperationException("Unexpected type '" + type + "'");
            }
        }

        public static string SerializeSqlType(SqlDataReader reader, int column, string type) {
            return GetSerializationFunction(type)(reader, column);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\config\Configurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;

namespace xonline.tools.sqlcrawler.config
{
    public abstract class Configurator
    {
        public Configurator(XmlElement configFragment)
        {
            if (null == configFragment)
                throw new ArgumentNullException("configFragment");

            this.configFragment = configFragment;
        }

        public abstract void Configure();

        protected string ReadAttribute(XmlNode node, string name, bool checkParent, object @default)
        {
            XmlAttribute attribute = node.Attributes[name];

            if (null == attribute)
                return checkParent ? ReadAttribute(node.ParentNode, name, false, @default) : Convert.ToString(@default);

            return attribute.Value;
        }

        protected string ReadAttribute(string name, bool checkParent, object @default)
        {
            return ReadAttribute(configFragment, name, checkParent, @default);
        }

        protected string ReadAttribute(XmlNode node, string name)
        {
            return node.Attributes[name].Value;
        }

        protected string ReadAttribute(string name)
        {
            return ReadAttribute(configFragment, name);
        }

        protected void EnforceFragmentName(params string[] names)
        {
            if (!Array.Exists(names, n => configFragment.Name == n))
                throw new ArgumentException("Invalid node the <" + configFragment.Name + "> element is unexpected.");
        }

        public XmlElement ConfigFragment
        {
            get { return configFragment; }
        }

        private XmlElement configFragment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\IManifestElement.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.sqlcrawler.manifest {
   public interface IManifestElement {
      IEnumerable<ManifestProperty> ReadProperties();
   }

   public enum PropertyPlacement {
      Element,
      Attribute
   }

   public struct ManifestProperty {
      public string Name;
      public object Value;
      public PropertyPlacement Placement;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\Enums.cs ===
﻿namespace xonline.tools.sqlcrawler.manifest {
   public enum SetupSteps {
      BeforeTables,
      AfterTables,
      AfterViews,
      AfterStoredProcedures
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\Extensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Reflection;

using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.extensions {
   public static class ManifestExtensions {
      public static ManifestProperty CreateElementProperty(this object value, string name) {
         return CreateProperty(value, name, PropertyPlacement.Element);
      }

      public static ManifestProperty CreateAttributeProperty(this object value, string name) {
         return CreateProperty(value, name, PropertyPlacement.Attribute);
      }

      public static ManifestProperty CreateProperty(this object value, string name, PropertyPlacement placement) {
         ManifestProperty property = new ManifestProperty();

         if (string.IsNullOrEmpty(name))
            throw new ArgumentNullException("name");

         property.Name = name;
         property.Value = value;
         property.Placement = placement;

         return property;
      }

      public static ManifestProperty[] CreateProperties(this IManifestElement self, ManifestProperty[] baseProperties, params ManifestProperty[] manifestProperties) {
         List<ManifestProperty> properties = new List<ManifestProperty>(baseProperties ?? new ManifestProperty[0]);
         properties.AddRange(manifestProperties ?? new ManifestProperty[0]);
         return properties.ToArray();
      }

      public static ManifestProperty[] CreateProperties(this IManifestElement self, params ManifestProperty[] manifestProperties) {
         return manifestProperties ?? new ManifestProperty[0];
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreManifestConfigurator.cs ===
﻿using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreManifestConfigurator : Configurator
    {
        public WebstoreManifestConfigurator(XmlElement objectsFragment, WebstoreManifest manifest)
            : base(objectsFragment)
        {
            if (null == manifest)
                throw new ArgumentNullException("manifest");

            EnforceFragmentName(FragmentName);

            this.manifest = manifest;
        }

        public override void Configure()
        {
            manifest.Name = ReadAttribute("name");
            manifest.LogicalPartitionColumn = ReadAttribute("partitionColumn", false, manifest.LogicalPartitionColumn);
            manifest.LogicalPartitionCount = int.Parse(ReadAttribute("partitions", false, manifest.LogicalPartitionCount));
            manifest.MinimumSQLVersion = new Version(ReadAttribute("minSQLVersion", false, manifest.MinimumSQLVersion));
            manifest.Description = ReadAttribute("description", false, manifest.Description);
            manifest.MultiMaster = bool.Parse(ReadAttribute("multiMaster", false, manifest.MultiMaster));
            manifest.PartitionType = (PartitionType)Enum.Parse(typeof(PartitionType), ReadAttribute("partitionType", false, manifest.PartitionType));
        }

        private const string FragmentName = "manifest";

        private WebstoreManifest manifest;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\data\DataExtractionEngine.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;

using xonline.tools.sqlcrawler.manifest;
using xonline.tools.sqlcrawler.manifest.dependency;

namespace xonline.tools.sqlcrawler.data
{
    public sealed class DataExtractionEngine : IDisposable
    {
        private delegate string SearchExpressionBuilder(SqlDataReader reader);
        private delegate string ValueExpressionBuilder(SqlDataReader reader);
        private const int QueueProcessors = 4;
        private const int MaximumTables = 1024;

        public DataExtractionEngine(string outputDirectory, string connectionString)
        {
            if (string.IsNullOrEmpty(outputDirectory))
                throw new ArgumentNullException("outputDirectory");
            if (string.IsNullOrEmpty(connectionString))
                throw new ArgumentNullException("connectionString");

            this.outputDirectory = outputDirectory;
            this.connectionString = connectionString;
            this.queueEvent = new AutoResetEvent(false);
            this.waitFinishEvent = new ManualResetEvent(false);
            this.completionEvents = new WaitHandle[QueueProcessors];
            this.extractionQueue = new Queue<ExtractionJob>();

            Directory.CreateDirectory(TargetDirectory);

            for (int c = 0; c < QueueProcessors; c++)
            {
                QueueInformation info = new QueueInformation();

                info.Connection = new SqlConnection(ConnectionString);
                info.Identifier = c + 1;

                this.completionEvents[c] = new ManualResetEvent(false);

                ThreadPool.QueueUserWorkItem(QueueProcessor, info);
            }
        }

        public void Dispose()
        {
            this.queueEvent.Close();
            this.waitFinishEvent.Close();

            Array.ForEach(
               this.completionEvents,
               delegate(WaitHandle e) { e.Close(); }
            );
        }

        public string ExtractTableData(string schema, string name, XmlNode configuration)
        {
            ExtractionJob job = new ExtractionJob();

            job.Schema = schema;
            job.TableName = name;
            job.CommandText = GetQueryString(schema, name, configuration);

            QueueJob(job);

            return GetOutputPath(job);
        }

        public void WaitForCompletion()
        {
            waitFinishEvent.Set();
            queueEvent.Set(); // wake the sleepers

            ManualResetEvent.WaitAll(completionEvents);

            Dispose();
        }

        private TableMetadata GetTableMetadata(string tableSchema, string tableName, string[] keys, DataTable schema)
        {
            TableMetadata result = new TableMetadata();

            if (0 != string.Compare(tableSchema, "dbo", true))
                result.Name = string.Format("[{0}].{1}", tableSchema, tableName);
            else
                result.Name = tableName;

            result.Columns = new string[schema.Rows.Count];

            for (int c = 0; c < schema.Rows.Count; c++)
            {
                DataRow row = schema.Rows[c];
                string name = (string)row["ColumnName"];

                if (string.IsNullOrEmpty(name))
                    throw new ArgumentException("column name missing.", "column " + c);

                result.Columns[c] = name;
                result.HasIdentityColumn |= (bool)row["IsIdentity"];
            }

            result.KeyColumns = (keys.Length == 0) ? result.Columns : keys;

            return result;
        }

        public static string GetManifestPath(string tablename)
        {
            return string.Format("dml\\data\\{0}_000.sql", tablename);
        }

        private string GetOutputPath(ExtractionJob job)
        {
            return Path.Combine(TargetDirectory, job.TableName + "_000.sql");
        }

        private void QueueProcessor(object state)
        {
            QueueInformation info = (QueueInformation)state;
            ExtractionJob job = new ExtractionJob();
            ManualResetEvent resetEvent = (ManualResetEvent)completionEvents[info.Identifier - 1];

            Thread.CurrentThread.Name = "QueueProcessor[" + info.Identifier + "]";

            try
            {
                info.Connection.Open();
                Console.WriteLine(info.Identifier + "> Connection Established");

                try
                {
                    while (WaitForJob(ref job))
                    {
                        string[] keys;

                        using (SqlDataReader reader = QueryTable(info.Connection, job, out keys))
                        {
                            TableMetadata metadata = GetTableMetadata(job.Schema, job.TableName, keys, reader.GetSchemaTable());
                            string path = GetOutputPath(job);

                            Console.WriteLine(info.Identifier + "> Extracting data for " + job.TableName);

                            using (StreamWriter writer = new StreamWriter(path, false, Encoding.UTF8))
                            {
                                WriteTableContent(reader, writer, metadata);
                            }
                        }
                    }
                }
                finally
                {
                    info.Connection.Close();
                    Console.WriteLine(info.Identifier + "> Connection Closed");
                }
            }
            finally
            {
                resetEvent.Set();
                queueEvent.Set(); // wake up the resting threads
                Console.WriteLine(info.Identifier + "> Event Set");
            }
        }

        #region DML Writer Methods
        private enum TransactionState
        {
            OutsideOfTransaction,
            InsideOfTransaction
        }

        private void WriteTableContent(SqlDataReader reader, TextWriter writer, TableMetadata metadata)
        {
            DataTable schema = reader.GetSchemaTable();
            TransactionState state = TransactionState.OutsideOfTransaction;
            string columns = "( " + string.Join(", ", metadata.Columns) + " )";
            SearchExpressionBuilder searchBuilder;
            ValueExpressionBuilder valueBuilder;
            int transactions = 0;
            int records = 0;

            // enable identity insert if neccessary
            if (metadata.HasIdentityColumn)
                writer.WriteLine("SET IDENTITY_INSERT {0} ON", metadata.Name);

            searchBuilder = ConstructSearchBuilder(reader, schema, metadata);
            valueBuilder = ConstructValueBuilder(reader, schema, metadata);

            while (reader.Read())
            {
                // write open transaction block
                if (state == TransactionState.OutsideOfTransaction)
                {
                    state = TransactionState.InsideOfTransaction;
                    writer.WriteLine("BEGIN TRANSACTION");
                    writer.WriteLine();
                }

                // write table row
                writer.WriteLine(GetTableRow(reader, columns, searchBuilder, valueBuilder, metadata));
                records++;
                transactions++;

                // write close transaction block
                if (1000 == transactions)
                {
                    transactions = 0;
                    state = TransactionState.OutsideOfTransaction;
                    writer.WriteLine("COMMIT TRANSACTION");
                    writer.WriteLine("GO");
                }
            }

            // write close transaction block
            if (state != TransactionState.OutsideOfTransaction)
            {
                state = TransactionState.OutsideOfTransaction;
                writer.WriteLine("COMMIT TRANSACTION");
                writer.WriteLine("GO");
            }

            // disable identity insert if neccessary
            if (metadata.HasIdentityColumn)
                writer.WriteLine("SET IDENTITY_INSERT {0} OFF", metadata.Name);
        }

        private string GetTableRow(SqlDataReader reader, string columns, SearchExpressionBuilder search, ValueExpressionBuilder value, TableMetadata metadata)
        {
            StringBuilder output = new StringBuilder(512);

            output.AppendFormat("IF NOT EXISTS(SELECT NULL FROM {0} WHERE {1})", metadata.Name, search(reader));
            output.AppendLine();
            output.AppendLine("BEGIN");
            output.AppendFormat("  INSERT INTO {0} {1}", metadata.Name, columns);
            output.AppendLine();
            output.AppendFormat("  VALUES ({0})", value(reader));
            output.AppendLine();
            output.AppendLine("END");

            return output.ToString();
        }

        private SearchExpressionBuilder DaisyChain(SearchExpressionBuilder root, string name, SerializationFunction func, int column)
        {
            return delegate(SqlDataReader dr)
            {
                return root(dr) + " AND " + name + "=" + func(dr, column);
            };
        }

        private SearchExpressionBuilder ConstructSearchBuilder(SqlDataReader reader, DataTable schema, TableMetadata metadata)
        {
            List<KeyValuePair<string, string>> allColumns = new List<KeyValuePair<string, string>>();
            List<KeyValuePair<string, string>> searchColumns = new List<KeyValuePair<string, string>>();
            List<int> allMaps = new List<int>();
            List<int> searchMaps = new List<int>();
            List<SerializationFunction> serializers = new List<SerializationFunction>();

            // build column list
            for (int c = 0; c < reader.FieldCount; c++)
            {
                KeyValuePair<string, string> columnData; // columnName, typeName

                columnData = new KeyValuePair<string, string>(
                    (string)schema.Rows[c]["ColumnName"],
                    (string)schema.Rows[c]["DataTypeName"]);

                allColumns.Add(columnData);
                allMaps.Add(c);

                if (Array.IndexOf(metadata.KeyColumns, columnData.Key) > -1)
                {
                    searchColumns.Add(columnData);
                    searchMaps.Add(c);
                }
            }

            // no primary keys, we need to use all columns
            if (searchColumns.Count == 0)
            {
                searchColumns = allColumns;
                searchMaps = allMaps;
            }

            // build serializer list
            for (int c = 0; c < searchColumns.Count; c++)
                serializers.Add(ColumnSerializer.GetSerializationFunction(searchColumns[c].Value));

            // build search expression
            return delegate(SqlDataReader dr)
            {
                string[] items = new string[serializers.Count];

                for (int c = 0; c < serializers.Count; c++)
                    items[c] = searchColumns[c].Key + "=" + serializers[c](dr, searchMaps[c]);

                return string.Join(" AND ", items);
            };
        }

        private ValueExpressionBuilder ConstructValueBuilder(SqlDataReader reader, DataTable schema, TableMetadata metadata)
        {
            List<SerializationFunction> serializers = new List<SerializationFunction>();

            // build serializer list
            for (int c = 0; c < reader.FieldCount; c++)
                serializers.Add(ColumnSerializer.GetSerializationFunction((string)schema.Rows[c]["DataTypeName"]));

            // build search expression
            return delegate(SqlDataReader dr)
            {
                string[] items = new string[serializers.Count];

                for (int c = 0; c < serializers.Count; c++)
                    items[c] = serializers[c](dr, c);

                return string.Join(", ", items);
            };
        }
        #endregion

        #region Job Methods
        private void QueueJob(ExtractionJob job)
        {
            lock (extractionQueue)
            {
                extractionQueue.Enqueue(job);
                queueEvent.Set();
            }
        }

        private string GetQueryString(string schema, string name, XmlNode configuration)
        {
            XmlElement customQuery = (null == configuration) ? null : configuration["custom-query"];

            if (null == customQuery)
                return string.Format("SELECT * FROM [{0}].[{1}]", schema, name);

            return customQuery.InnerText;
        }

        private SqlDataReader QueryTable(SqlConnection connection, ExtractionJob job, out string[] keys)
        {
            // enumerate the primary keys
            using (SqlCommand command = connection.CreateCommand())
            {
                List<string> keyList = new List<string>();

                command.CommandText =
                   "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu " +
                   "INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ON kcu.CONSTRAINT_NAME=tc.CONSTRAINT_NAME " +
                   "WHERE kcu.TABLE_NAME='" + job.TableName + "' " +
                   "AND tc.CONSTRAINT_TYPE='PRIMARY KEY'";

                command.CommandType = CommandType.Text;

                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        keyList.Add(reader.GetString(0));
                    }
                }

                keys = keyList.ToArray();
            }

            using (SqlCommand command = connection.CreateCommand())
            {
                command.CommandText = job.CommandText;
                command.CommandType = CommandType.Text;

                return command.ExecuteReader();
            }
        }

        private bool WaitForJob(ref ExtractionJob job)
        {
            while (true)
            {
                lock (extractionQueue)
                {
                    if (extractionQueue.Count != 0)
                    {
                        job = extractionQueue.Dequeue();
                        queueEvent.Set(); // free up someone
                        break;
                    }
                }

                if (waitFinishEvent.WaitOne(0, false))
                    return false;

                // wait for something to happen to the queue
                queueEvent.WaitOne();
            }

            return true;
        }
        #endregion

        public string TargetDirectory
        {
            get { return Path.Combine(outputDirectory, "dml\\data"); }
        }

        public string ConnectionString
        {
            get { return connectionString; }
        }

        private string outputDirectory;
        private string connectionString;
        private AutoResetEvent queueEvent;
        private ManualResetEvent waitFinishEvent;
        private WaitHandle[] completionEvents;
        private Queue<ExtractionJob> extractionQueue;

        #region Nested Types
        private struct ExtractionJob
        {
            public string Schema { get; set; }
            public string TableName;
            public string CommandText;
        }

        private struct QueueInformation
        {
            public SqlConnection Connection;
            public int Identifier;
        }

        private struct TableMetadata
        {
            public string Name;
            public string[] Columns;
            public bool HasIdentityColumn;
            public string[] KeyColumns;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\ManfestPropertyGroup.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest {
   public class ManifestPropertyGroup : IManifestElement {
      public ManifestPropertyGroup() {
         manifestProperties = new List<ManifestProperty>();
      }

      public void Add(ManifestProperty property) {
         manifestProperties.Add(property);
      }

      public void AddAttribute(string name, string value) {
         Add(value.CreateAttributeProperty(name));
      }

      public void AddElement(string name, object value) {
         Add(value.CreateElementProperty(name));
      }

      public void AddEmptyElements(params string[] names) {
         foreach (string name in names)
            AddElement(name, "");
      }

      IEnumerable<ManifestProperty> IManifestElement.ReadProperties() {
         return manifestProperties.ToArray();
      }

      public List<ManifestProperty> ManifestProperties {
         get { return manifestProperties; }
      }

      private List<ManifestProperty> manifestProperties; 
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreJobConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreJobConfigurator : WebstoreReplicatedObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreJobConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreJob job = new WebstoreJob();

            AssignCreationValues(job);
            ConfigureJob(job);

            return job;
        }

        public override void Configure()
        {
            WebstoreJob job = WebstoreManifest.Jobs.Find(Name);

            if (null == job)
                throw new ArgumentException("Cannot find job with name " + Name);

            ConfigureJob(job);
        }

        private void ConfigureJob(WebstoreJob job)
        {
            ConfigureObject(job);
        }

        private const string FragmentName = "job";
        private const string ContainerName = "jobs";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreFunctionConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreFunctionConfigurator : WebstoreReplicatedObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreFunctionConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreFunction function = new WebstoreFunction();

            AssignCreationValues(function);
            ConfigureFunction(function);

            return function;
        }

        public override void Configure()
        {
            WebstoreFunction function = WebstoreManifest.Functions.Find(Name);

            if (null == function)
                throw new ArgumentException("Cannot find function with name " + Name);

            ConfigureFunction(function);
        }

        private void ConfigureFunction(WebstoreFunction function)
        {
            ConfigureObject(function);
            function.SetupStep = (SetupSteps)Enum.Parse(typeof(SetupSteps), ReadAttribute("setupStep", true, function.SetupStep));
        }

        private const string FragmentName = "function";
        private const string ContainerName = "functions";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreFileGroupConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreFileGroupConfigurator : WebstoreObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreFileGroupConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreFileGroup fileGroup = new WebstoreFileGroup();

            ConfigureFileGroup(fileGroup);

            return fileGroup;
        }

        public override void Configure()
        {
            WebstoreFileGroup fileGroup = WebstoreManifest.FileGroups.Find(Name);

            if (null == fileGroup)
                throw new ArgumentException("Cannot find function with name " + Name);

            ConfigureFileGroup(fileGroup);
        }

        private void ConfigureFileGroup(WebstoreFileGroup fileGroup)
        {
            fileGroup.Name = ReadAttribute("name", false, fileGroup.Name);
            fileGroup.LogicalFileName = ReadAttribute("logicalFileName", false, fileGroup.LogicalFileName);
        }

        private const string FragmentName = "fileGroup";
        private const string ContainerName = "fileGroups";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreObjectConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public abstract class WebstoreObjectConfigurator : Configurator
    {
        public WebstoreObjectConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(objectsFragment)
        {
            if (null == manifest)
                throw new ArgumentNullException("manifest");

            this.manifest = manifest;
            this.Name = ReadAttribute("name",false,null);
        }

        public abstract WebstoreObject CreateObject();

        protected virtual void AssignCreationValues(WebstoreObject target)
        {
            XmlElement add = ConfigFragment["add"];

            if (null == target)
                throw new ArgumentNullException("target");

            if (null == add)
                throw new ArgumentException("configuration fragment missing <add> child element.");

            target.Name = Name;
            target.SourceFile = ReadAttribute(add, "source");
            target.InstallOrder = int.Parse(ReadAttribute(add, "installOrder"));
        }

        public WebstoreManifest WebstoreManifest
        {
            get { return manifest; }
        }

        public string Name { get; set; }

        private WebstoreManifest manifest;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\ManifestBuilder.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Xml;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using xonline.tools.graph;
using xonline.tools.sqlcrawler.data;
using xonline.tools.sqlcrawler.manifest.dependency;
using xonline.tools.sqlcrawler.manifest.element;
using xonline.tools.sqlcrawler.manifest.config;
using xonline.tools.sqlcrawler.schema;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;
using Dependency = xonline.tools.sqlcrawler.manifest.dependency.DependencyExplorer.Dependency;

namespace xonline.tools.sqlcrawler.manifest
{
    public class ManifestBuilder
    {
        private const string XPathForFileGroup = "/sqlcrawler/configuration/manifest/objects/fileGroups/fileGroup";
        private const string XPathForFunction = "/sqlcrawler/configuration/manifest/objects/functions/function";
        private const string XPathForJob = "/sqlcrawler/configuration/manifest/objects/jobs/job";
        private const string XPathForScript = "/sqlcrawler/configuration/manifest/objects/scripts/script";
        private const string XPathForRole = "/sqlcrawler/configuration/manifest/objects/roles/role";
        private const string XPathForSproc = "/sqlcrawler/configuration/manifest/objects/sprocs/sproc";
        private const string XPathForTable = "/sqlcrawler/configuration/manifest/objects/tables/table";
        private const string XPathForTrigger = "/sqlcrawler/configuration/manifest/objects/triggers/trigger";
        private const string XPathForView = "/sqlcrawler/configuration/manifest/objects/views/view";
        private const string InjectionPath = "/add/..";

        private const string XPathForManifest = "/sqlcrawler/configuration/manifest";

        public ManifestBuilder(string serverName, string databaseName, XmlDocument configuration)
            : this(serverName, databaseName, configuration, null, null)
        {

        }

        public ManifestBuilder(string serverName, string databaseName, XmlDocument configuration, SchemaExtractorFactory schemaFactory, DataExtractionEngine dataExtractionEngine)
        {
            if (string.IsNullOrEmpty(serverName))
                throw new ArgumentNullException("serverName");
            if (string.IsNullOrEmpty(databaseName))
                throw new ArgumentNullException("databaseName");
            if (null == configuration)
                throw new ArgumentNullException("configuration");

            this.dataExtractor = dataExtractionEngine;
            this.schemaFactory = schemaFactory;
            this.dependencyExplorer = new DependencyExplorer(serverName, databaseName);
            this.configuration = configuration;
            this.serverName = serverName;
            this.databaseName = databaseName;
        }

        public WebstoreManifest CreateManifest(Version version)
        {
            WebstoreManifest manifest;
            WebstoreManifestConfigurator configurator;
            IAsyncResult explorerResult;
            OrderCache<string, Dependency> dependencyOrdering;
            Server server;

            // start generating the dependency graph
            Console.WriteLine(" > Starting dependency exploration...");
            explorerResult = DependencyExplorer.BeginExplore();

            manifest = new WebstoreManifest();

            configurator = new WebstoreManifestConfigurator((XmlElement)configuration.SelectSingleNode(XPathForManifest), manifest);

            // configure the manifest
            configurator.Configure();
            manifest.Version = version;

            // inject all manifest inserts
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForFileGroup + InjectionPath), typeof(WebstoreFileGroupConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForFunction + InjectionPath), typeof(WebstoreFunctionConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForJob + InjectionPath), typeof(WebstoreJobConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForScript + InjectionPath), typeof(WebstoreScriptConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForRole + InjectionPath), typeof(WebstoreSecurityRoleConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForSproc + InjectionPath), typeof(WebstoreStoredProcedureConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForTable + InjectionPath), typeof(WebstoreTableConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForTrigger + InjectionPath), typeof(WebstoreTriggerConfigurator));
            InjectManifestObjects(manifest, configuration.SelectNodes(XPathForView + InjectionPath), typeof(WebstoreViewConfigurator));

            // wait for the dependency graph to finish
            Console.WriteLine(" > Waiting for dependency exploration to complete...");
            DependencyExplorer.EndExplore(explorerResult);

            // calculating install orders
            Console.WriteLine(" > Calculating install orders...");
            dependencyOrdering = DependencyExplorer.GetPartialOrdering();

            // create smo server
            Console.WriteLine(" > Creating SMO connecttion to " + ServerName);
            server = new Server(ServerName);

            // configure the objects already present in
            foreach (OrderedNode<string, Dependency> orderNode in dependencyOrdering.AllNodes)
            {
                Dependency dependency = orderNode.Node.Value;
                XmlNode element;

                if (IsSchemaObjectAccepted(dependency, configuration, out element))
                {
                    WebstoreObject wso;
                    WebstoreObjectConfigurator wsoc;
                    string path;

                    CreateManifestObject(manifest, orderNode, (XmlElement)element, out wso, out wsoc);
                    manifest.AddWebstoreObject(wso);

                    if (null != wsoc)
                    {
                        Console.WriteLine(" > Loading configuration for " + wso.Name);
                        wsoc.Configure();
                    }

                    if (null != schemaFactory)
                    {
                        var extractor = schemaFactory.GetExtractor(dependency.Urn, out path);

                        Console.WriteLine(" > Extracting Schema for " + wso.Name);
                        extractor.ExtractSchema(server, dependency.Urn, path);
                    }
                }

                if ("Table" == dependency.Urn.Type && IsDataObjectAccepted(dependency, configuration, out element))
                {
                    WebstoreObject wso;

                    wso = new WebstoreScript();
                    wso.Name = dependency.Name;
                    wso.InstallOrder = GetInstallOrder(orderNode);
                    wso.SourceFile = DataExtractionEngine.GetManifestPath(dependency.Name);

                    manifest.AddWebstoreObject(wso);

                    // data extraction engine may override name
                    if (dataExtractor != null)
                        dataExtractor.ExtractTableData(dependency.Urn.GetAttribute("Schema"), dependency.Name, element);
                }
            }

            // wait for extractor finish writing
            Console.WriteLine(" > Waiting for data extraction to complete...");
            dataExtractor.WaitForCompletion();

            return manifest;
        }

        private int GetInstallOrder(OrderedNode<string, Dependency> orderNode)
        {
            return orderNode.Rank * 100 + 1000;
        }

        private bool IsDataObjectAccepted(Dependency dependency, XmlDocument configuration, out XmlNode element)
        {
            return IsObjectAccepted(dependency, configuration, "extract:data", out element);
        }

        private bool IsSchemaObjectAccepted(Dependency dependency, XmlDocument configuration, out XmlNode element)
        {
            return IsObjectAccepted(dependency, configuration, "extract:schema", out element);
        }

        private bool IsObjectAccepted(Dependency dependency, XmlDocument configuration, string attributeName, out XmlNode element)
        {
            XmlNode item, container;
            XmlNamespaceManager xnm;

            xnm = new XmlNamespaceManager(configuration.NameTable);
            xnm.AddNamespace("extract", "urn:Extraction.xsd");

            element = null;

            if (GetObjectElement(dependency, configuration, out item, out container))
            {
                XmlNode attribute = null;

                if (null == attribute && null != item)
                {
                    attribute = item.SelectSingleNode("@" + attributeName, xnm);
                    element = item;
                }

                if (null == attribute && null != container)
                {
                    attribute = container.SelectSingleNode("@" + attributeName, xnm);
                    element = element ?? container;
                }

                if (null != attribute)
                    return bool.Parse(attribute.Value);
            }

            // objects are accepted by default
            return true;
        }

        private bool IsSpecialTableOrDependent(Dependency dependency)
        {
            if ((dependency.Flags & DependencyExplorer.DependencyFlags.SpecialTable) == DependencyExplorer.DependencyFlags.SpecialTable)
                return true;

            if ((dependency.Flags & DependencyExplorer.DependencyFlags.SpecialTableDependent) == DependencyExplorer.DependencyFlags.SpecialTableDependent)
                return true;

            return false;
        }

        private void CreateManifestObject(
           WebstoreManifest manifest,
           OrderedNode<string, Dependency> orderedDependency,
           XmlElement fragment,
           out WebstoreObject wso,
           out WebstoreObjectConfigurator wsoc)
        {
            Dependency dependency = orderedDependency.Node.Value;

            switch (dependency.Urn.Type)
            {
                case DependencyExplorer.TableType:
                    if (IsSpecialTableOrDependent(dependency))
                    {
                        var script = new WebstoreScript();

                        script.SetupStep = SetupSteps.BeforeTables;
                        script.Name = "schema.";
                        
                        wso = script;
                        
                        wsoc = (fragment == null) ? null : new WebstoreScriptConfigurator(manifest, fragment);
                    }
                    else
                    {
                        wso = new WebstoreTable();
                        wsoc = (fragment == null) ? null : new WebstoreTableConfigurator(manifest, fragment);
                    }

                    wso.SourceFile = "ddl\\table\\" + dependency.Name;
                    
                    break;
                case DependencyExplorer.ViewType:
                    wso = new WebstoreView();
                    wso.SourceFile = "ddl\\view\\" + dependency.Name;
                    wsoc = (fragment == null) ? null : new WebstoreViewConfigurator(manifest, fragment);
                    break;
                case DependencyExplorer.FunctionType:
                    wso = new WebstoreFunction();
                    wso.SourceFile = "ddl\\function\\" + dependency.Name;
                    wsoc = (fragment == null) ? null : new WebstoreFunctionConfigurator(manifest, fragment);
                    break;
                case DependencyExplorer.SprocType:
                    wso = new WebstoreStoredProcedure();
                    wso.SourceFile = "ddl\\sproc\\" + dependency.Name;
                    wsoc = (fragment == null) ? null : new WebstoreStoredProcedureConfigurator(manifest, fragment);
                    break;
                case DependencyExplorer.RoleType:
                    wso = new WebstoreSecurityRole();
                    wso.SourceFile = "ddl\\role\\" + dependency.Name;
                    wsoc = (fragment == null) ? null : new WebstoreSecurityRoleConfigurator(manifest, fragment);
                    break;
                case DependencyExplorer.TriggerType:
                    wso = new WebstoreTrigger();
                    wso.SourceFile = "ddl\\trigger\\" + dependency.Name;
                    wsoc = (fragment == null) ? null : new WebstoreTriggerConfigurator(manifest, fragment);
                    break;
                default:
                    throw new InvalidOperationException("unrecognized urn type: " + dependency.Urn.Type);
            }

            wso.Name += dependency.Name;
            wso.InstallOrder = GetInstallOrder(orderedDependency);
            wso.SourceFile += ".sql";

            if (null != wsoc)
                wsoc.Name = wso.Name;
        }

        private bool GetObjectElement(Dependency dependency, XmlDocument configuration, out XmlNode item, out XmlNode container)
        {
            string basePath;
            string itemPath;
            string containerPath;

            switch (dependency.Urn.Type)
            {
                case DependencyExplorer.TableType:
                    basePath = XPathForTable; break;
                case DependencyExplorer.ViewType:
                    basePath = XPathForView; break;
                case DependencyExplorer.FunctionType:
                    basePath = XPathForFunction; break;
                case DependencyExplorer.SprocType:
                    basePath = XPathForSproc; break;
                case DependencyExplorer.RoleType:
                    basePath = XPathForRole; break;
                case DependencyExplorer.TriggerType:
                    basePath = XPathForTrigger; break;
                default:
                    throw new InvalidOperationException("unrecognized urn type: " + dependency.Urn.Type);
            }

            itemPath = basePath + string.Format("[@name='{0}']", dependency.Name);
            containerPath = basePath.Substring(0, basePath.LastIndexOf('/'));

            item = configuration.SelectSingleNode(itemPath);
            container = configuration.SelectSingleNode(containerPath);

            return item != null || container != null;
        }

        private void InjectManifestObjects(WebstoreManifest manifest, XmlNodeList nodes, Type configuratorType)
        {
            WebstoreObjectConfigurator configurator;

            foreach (XmlNode node in nodes)
            {
                WebstoreObject wso;
                
                configurator = (WebstoreObjectConfigurator)Activator.CreateInstance(configuratorType, manifest, (XmlElement)node);
                wso = configurator.CreateObject();
                manifest.AddWebstoreObject(wso);

                Console.WriteLine(" > " + wso.Name + " added to manifest.");
            }

            configurator = null;
        }

        public DataExtractionEngine DataExtractionEngine
        {
            get { return dataExtractor; }
        }

        public string ServerName
        {
            get { return serverName; }
        }

        public string DatabaseName
        {
            get { return databaseName; }
        }

        public DependencyExplorer DependencyExplorer
        {
            get { return dependencyExplorer; }
        }

        private DataExtractionEngine dataExtractor;
        private SchemaExtractorFactory schemaFactory;
        private DependencyExplorer dependencyExplorer;
        private XmlDocument configuration;
        private string serverName;
        private string databaseName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreReplicatedObjectConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public abstract class WebstoreReplicatedObjectConfigurator : WebstoreObjectConfigurator
    {
        public WebstoreReplicatedObjectConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment) { }

        protected override void AssignCreationValues(WebstoreObject target)
        {
            WebstoreReplicatedObject rep = (WebstoreReplicatedObject)target;

            base.AssignCreationValues(target);

            rep.InstallOnPrimary = bool.Parse(ReadAttribute("installOnPrimary", true, rep.InstallOnPrimary));
            rep.InstallOnSecondary = bool.Parse(ReadAttribute("installOnSecondary", true, rep.InstallOnSecondary));
        }

        protected virtual void ConfigureObject(WebstoreReplicatedObject target)
        {
            target.InstallOnPrimary = bool.Parse(ReadAttribute("installOnPrimary", true, target.InstallOnPrimary));
            target.InstallOnSecondary = bool.Parse(ReadAttribute("installOnSecondary", true, target.InstallOnSecondary));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreScriptConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreScriptConfigurator : WebstoreReplicatedObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreScriptConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName, "table", "tables");
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreScript script = new WebstoreScript();

            AssignCreationValues(script);
            ConfigureScript(script);

            return script;
        }

        public override void Configure()
        {
            WebstoreScript script = WebstoreManifest.Scripts.Find(Name);

            if (null == script)
                throw new ArgumentException("Cannot find script with name " + Name);

            ConfigureScript(script);
        }

        private void ConfigureScript(WebstoreScript script)
        {
            ConfigureObject(script);
            script.SetupStep = (SetupSteps)Enum.Parse(typeof(SetupSteps), ReadAttribute("setupStep", true, script.SetupStep));

            // dealing with a special table, it needs to be added before tables
            if (ConfigFragment.Name == "table" || ConfigFragment.Name == "tables")
                script.SetupStep = SetupSteps.BeforeTables;
        }

        private const string FragmentName = "script";
        private const string ContainerName = "scripts";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreViewConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreViewConfigurator : WebstoreReplicatedObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreViewConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreView view = new WebstoreView();

            AssignCreationValues(view);
            ConfigureView(view);

            return view;
        }

        public override void Configure()
        {
            WebstoreView view = WebstoreManifest.Views.Find(Name);

            if (null == view)
                throw new ArgumentException("Cannot find view with name " + Name);

            ConfigureView(view);
        }

        private void ConfigureView(WebstoreView view)
        {
            ConfigureObject(view);
        }

        private const string FragmentName = "view";
        private const string ContainerName = "views";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreTriggerConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreTriggerConfigurator : WebstoreObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreTriggerConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreTrigger trigger = new WebstoreTrigger();

            AssignCreationValues(trigger);
            ConfigureTrigger(trigger);

            return trigger;
        }

        public override void Configure()
        {
            WebstoreTrigger trigger = WebstoreManifest.Triggers.Find(Name);

            if (null == trigger)
                throw new ArgumentException("Cannot find trigger with name " + Name);

            ConfigureTrigger(trigger);
        }

        private void ConfigureTrigger(WebstoreTrigger trigger)
        {

        }

        private const string FragmentName = "trigger";
        private const string ContainerName = "triggers";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreStoredProcedureConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreStoredProcedureConfigurator : WebstoreReplicatedObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreStoredProcedureConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreStoredProcedure sproc = new WebstoreStoredProcedure();

            AssignCreationValues(sproc);
            ConfigureStoredProcedure(sproc);

            return sproc;
        }

        public override void Configure()
        {
            WebstoreStoredProcedure sproc = WebstoreManifest.StoredProcedures.Find(Name);

            if (null == sproc)
                throw new ArgumentException("Cannot find sproc with name " + Name);

            ConfigureStoredProcedure(sproc);
        }

        private void ConfigureStoredProcedure(WebstoreStoredProcedure sproc)
        {
            ConfigureObject(sproc);
        }

        private const string FragmentName = "sproc";
        private const string ContainerName = "sprocs";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreSecurityRoleConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreSecurityRoleConfigurator : WebstoreObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreSecurityRoleConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreSecurityRole securityRole = new WebstoreSecurityRole();

            AssignCreationValues(securityRole);
            ConfigureSecurityRole(securityRole);

            return securityRole;
        }

        public override void Configure()
        {
            WebstoreSecurityRole securityRole = WebstoreManifest.SecurityRoles.Find(Name);

            if (null == securityRole)
                throw new ArgumentException("Cannot find security role with name " + Name);

            ConfigureSecurityRole(securityRole);
        }

        private void ConfigureSecurityRole(WebstoreSecurityRole role)
        {
            role.FunctionExecutePermission = bool.Parse(ReadAttribute("functionExecute", true, role.FunctionExecutePermission));
            role.SprocExecutePermission = bool.Parse(ReadAttribute("sprocExecute", true, role.SprocExecutePermission));
            role.TablePermissions = (PermissionFlags)Enum.Parse(typeof(PermissionFlags), ReadAttribute("tablePermissions", true, role.TablePermissions));
            role.ViewPermissions = (PermissionFlags)Enum.Parse(typeof(PermissionFlags), ReadAttribute("viewPermissions", true, role.ViewPermissions));
        }

        private const string FragmentName = "role";
        private const string ContainerName = "roles";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\config\WebstoreTableConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

using xonline.tools.sqlcrawler.config;
using xonline.tools.sqlcrawler.manifest.element;

namespace xonline.tools.sqlcrawler.manifest.config
{
    public class WebstoreTableConfigurator : WebstoreObjectConfigurator
    {
        public static bool IsFragmentMine(XmlElement objectFragment)
        {
            if (objectFragment == null)
                throw new ArgumentNullException("objectFragment");

            return objectFragment.Name == FragmentName;
        }

        public WebstoreTableConfigurator(WebstoreManifest manifest, XmlElement objectsFragment)
            : base(manifest, objectsFragment)
        {
            EnforceFragmentName(FragmentName, ContainerName);
        }

        public override WebstoreObject CreateObject()
        {
            WebstoreTable table = new WebstoreTable();

            AssignCreationValues(table);
            ConfigureTable(table);

            return table;
        }

        public override void Configure()
        {
            WebstoreTable table = WebstoreManifest.Tables.Find(Name);

            if (null == table)
                throw new ArgumentException("Cannot find table with name " + Name);

            ConfigureTable(table);
        }

        private void ConfigureTable(WebstoreTable table)
        {
            table.DeleteSproc = ReadAttribute("deleteSproc", true, table.DeleteSproc);
            table.InsertSproc = ReadAttribute("insertSproc", true, table.InsertSproc);
            table.UpdateSproc = ReadAttribute("updateSproc", true, table.UpdateSproc);
            table.Partitioned = bool.Parse(ReadAttribute("partitioned", true, table.Partitioned));
            table.UpgradeOnly = bool.Parse(ReadAttribute("upgradeOnly", true, table.UpgradeOnly));
        }

        private const string FragmentName = "table";
        private const string ContainerName = "tables";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DependencyEvaluator.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public class DependencyEvaluator<TKey, TValue> {
      public DependencyEvaluator(DirectedGraph<TKey, TValue> graph) {
         if (null == graph)
            throw new ArgumentNullException("graph");

         this.graph = graph;
      }

      public OrderCache<TKey, TValue> Evaluate() {
         return Evaluate(null, null, true);
      }

      private void generateDegreeLists(
         Dictionary<Node<TKey, TValue>, bool> excludedNodes,
         Dictionary<Edge<TKey, TValue>, bool> excludedEdges,
         out List<LinkedList<Node<TKey, TValue>>> degreeLists,
         out Dictionary<Node<TKey, TValue>, int> nodeDegreeLookup)
      {
         degreeLists = new List<LinkedList<Node<TKey, TValue>>>();
         nodeDegreeLookup = new Dictionary<Node<TKey, TValue>, int>();

         foreach (Node<TKey, TValue> node in graph.Nodes) {
            int DegreeBias;
            int BiasedDegree;

            if (excludedNodes.ContainsKey(node))
               continue;

            DegreeBias = 0;
            foreach (Edge<TKey, TValue> edge in node.InEdges) {
               if (excludedEdges.ContainsKey(edge))
                  DegreeBias++;
               else if (excludedNodes.ContainsKey(edge.TailNode))
                  DegreeBias++;
            }

            BiasedDegree = node.InDegree - DegreeBias;
            nodeDegreeLookup.Add(node, BiasedDegree);
            while (degreeLists.Count <= BiasedDegree)
               degreeLists.Add(new LinkedList<Node<TKey, TValue>>());

            degreeLists[BiasedDegree].AddFirst(node);
         }
      }

      private List<OrderedNode<TKey, TValue>> generatePartialOrdering(
         Dictionary<Edge<TKey, TValue>, bool> excludedEdges,
         List<LinkedList<Node<TKey, TValue>>> degreeLists,
         Dictionary<Node<TKey, TValue>, int> nodeDegreeLookup)
      {
         List<OrderedNode<TKey, TValue>> PartialOrdering;
         int Index = 0;
         int Rank = 0;

         PartialOrdering = new List<OrderedNode<TKey, TValue>>();
         while (Index < degreeLists.Count) {
            if (degreeLists[0].Count > 0) {
               int StartCount;

               // Add the ordering
               StartCount = PartialOrdering.Count;
               foreach (Node<TKey, TValue> node in degreeLists[0]) {
                  PartialOrdering.Add(new OrderedNode<TKey, TValue>(
                     node,
                     Rank,
                     PartialOrdering.Count));
               }

               Rank++;

               // Resolve dependencies
               degreeLists[0].Clear();
               while (StartCount < PartialOrdering.Count) {
                  foreach (Edge<TKey, TValue> edge in PartialOrdering[StartCount].Node.OutEdges) {
                     int BiasedDegree;

                     if (excludedEdges.ContainsKey(edge))
                        continue;
                     if (!nodeDegreeLookup.ContainsKey(edge.HeadNode))
                        continue;

                     BiasedDegree = nodeDegreeLookup[edge.HeadNode];
                     degreeLists[BiasedDegree].Remove(edge.HeadNode);
                     nodeDegreeLookup[edge.HeadNode] = BiasedDegree - 1;
                     degreeLists[BiasedDegree - 1].AddFirst(edge.HeadNode);
                  }

                  StartCount++;
               }
            }
            else {
               // The remaining nodes are not satisfiable
               for (Index = 0; Index < degreeLists.Count; Index++) {
                  foreach (Node<TKey, TValue> node in degreeLists[Index])
                     PartialOrdering.Add(new OrderedNode<TKey, TValue>(node));
               }
            }
         }

         return PartialOrdering;
      }

      public OrderCache<TKey, TValue> Evaluate(
         IEnumerable<Node<TKey, TValue>> excludedNodes,
         IEnumerable<Edge<TKey, TValue>> excludedEdges,
         bool allowPartialSolution) 
      {
         Dictionary<Node<TKey, TValue>, bool> ExcludedNodes;
         Dictionary<Edge<TKey, TValue>, bool> ExcludedEdges;
         List<LinkedList<Node<TKey, TValue>>> DegreeLists;
         Dictionary<Node<TKey, TValue>, int> NodeDegreeLookup;
         

         ExcludedNodes = new Dictionary<Node<TKey, TValue>, bool>();
         ExcludedEdges = new Dictionary<Edge<TKey, TValue>, bool>();
         
         if (null != excludedNodes) {
            foreach (Node<TKey, TValue> node in excludedNodes)
               ExcludedNodes[node] = true;
         }

         if (null != excludedEdges) {
            foreach (Edge<TKey, TValue> edge in excludedEdges)
               ExcludedEdges[edge] = true;
         }

         generateDegreeLists(
            ExcludedNodes, 
            ExcludedEdges,
            out DegreeLists,
            out NodeDegreeLookup);

         if (!allowPartialSolution) {
            bool IsSubsetAcyclic;

            IsSubsetAcyclic = graph.IsSubsetAcyclic(
               ExcludedNodes.Keys, 
               ExcludedEdges.Keys);

            if (!IsSubsetAcyclic)
               throw new UnsatisfiableDependencyException();
         }

         return new OrderCache<TKey, TValue>(
            generatePartialOrdering(
               ExcludedEdges,
               DegreeLists,
               NodeDegreeLookup));

      }

      public IEnumerable<Node<TKey, TValue>> EnumerateDependents(Node<TKey, TValue> node) {
         return EnumerateDependents(new Node<TKey, TValue>[] { node });
      }

      public IEnumerable<Node<TKey, TValue>> EnumerateDependents(IEnumerable<Node<TKey, TValue>> nodes) {
         Dictionary<TKey, bool> NodeHistory;
         LinkedList<Node<TKey, TValue>> NodeList;

         NodeHistory = new Dictionary<TKey, bool>();
         NodeList = new LinkedList<Node<TKey, TValue>>();
         foreach (Node<TKey, TValue> node in nodes) {
            if (null != node && node.Owner == graph) {
               NodeHistory[node.Key] = false;
               NodeList.AddLast(node);
            }
         }

         while (NodeList.Count > 0) {
            Node<TKey, TValue> Node;
            
            Node = NodeList.First.Value;
            NodeList.RemoveFirst();

            if (!NodeHistory.ContainsKey(Node.Key))
               yield return Node;
            else {
               if (NodeHistory[Node.Key] == false) {
                  NodeHistory[Node.Key] = true;
                  foreach (Edge<TKey, TValue> edge in Node.OutEdges) {
                     if (!NodeHistory.ContainsKey(edge.HeadNode.Key)) {
                        NodeHistory[edge.HeadNode.Key] = false;
                        NodeList.AddLast(edge.HeadNode);
                        yield return edge.HeadNode;
                     }
                  }
               }
            }
         }
      }

      public DirectedGraph<TKey, TValue> Graph {
         get { return graph; }
      }

      private DirectedGraph<TKey, TValue>   graph;
   }

   [Serializable]
   public class UnsatisfiableDependencyException : Exception {
      public UnsatisfiableDependencyException() { }
      public UnsatisfiableDependencyException(string message) : base(message) { }
      public UnsatisfiableDependencyException(string message, Exception inner) : base(message, inner) { }
      protected UnsatisfiableDependencyException(
         System.Runtime.Serialization.SerializationInfo info,
         System.Runtime.Serialization.StreamingContext context)
         : base(info, context) { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\DependencyExplorer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using xonline.tools.graph;
using xonline.tools.sqlcrawler.manifest.element;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.manifest.dependency
{
    public class DependencyExplorer
    {
        private delegate void Explorer();

        public const string TableType = "Table";
        public const string ViewType = "View";
        public const string FunctionType = "UserDefinedFunction";
        public const string SprocType = "StoredProcedure";
        public const string RoleType = "Role";
        public const string TriggerType = "Trigger";

        private const string TableBaseKey = "/schema/table/";
        private const string ViewBaseKey = "/schema/view/";
        private const string FunctionBaseKey = "/schema/function/";
        private const string SprocBaseKey = "/schema/sproc/";
        private const string RoleBaseKey = "/schema/role/";
        private const string TriggerBaseKey = "/schema/trigger/";

        public static string GetName(Urn urn)
        {
            if (null == urn)
                throw new ArgumentNullException("urn");

            return urn.GetAttribute("Name");
        }

        public static string GetSchema(Urn urn)
        {
            if (null == urn)
                throw new ArgumentNullException("urn");

            return urn.GetAttribute("Schema");
        }

        public static string GetKey(Urn urn)
        {
            StringBuilder result;
            string schema;

            if (null == urn)
                throw new ArgumentNullException("urn");

            result = new StringBuilder();

            switch (urn.Type)
            {
                case TableType:
                    result.Append(TableBaseKey);
                    break;
                case ViewType:
                    result.Append(ViewBaseKey);
                    break;
                case FunctionType:
                    result.Append(FunctionBaseKey);
                    break;
                case SprocType:
                    result.Append(SprocBaseKey);
                    break;
                case RoleType:
                    result.Append(RoleBaseKey);
                    break;
                case TriggerType:
                    result.Append(TriggerBaseKey);
                    break;

                default:
                    throw new InvalidOperationException("unrecognized urn type: " + urn.Type);
            }

            if (null != (schema = GetSchema(urn)))
            {
                result.Append(schema + "/");
            }

            result.Append(GetName(urn));

            return result.ToString();
        }

        public DependencyExplorer(string serverName, string databaseName)
        {
            if (string.IsNullOrEmpty(serverName))
                throw new ArgumentNullException("serverName");
            if (string.IsNullOrEmpty(databaseName))
                throw new ArgumentNullException("databaseName");

            this.serverName = serverName;
            this.databaseName = databaseName;
            this.graph = new DirectedGraph<string, Dependency>();
            this.explorer = Explore;
        }

        public IAsyncResult BeginExplore(AsyncCallback callback, object state)
        {
            return explorer.BeginInvoke(callback, state);
        }

        public IAsyncResult BeginExplore()
        {
            return explorer.BeginInvoke(null, null);
        }

        public void EndExplore(IAsyncResult asyncResult)
        {
            explorer.EndInvoke(asyncResult);
        }

        private bool IsSpecialTable(Server server, Urn urn)
        {
            Table table = server.GetSmoObject(urn) as Table;
            
            if (table != null)
            {
                bool result = true;

                foreach (Column column in table.Columns)
                {
                    if (column.Identity == true)
                        return true;

                    if (column.InPrimaryKey)
                        result = false;
                }

                return result;
            }

            
            return false;
        }

        private bool IsSystemObject(Server server, Urn urn)
        {
            return IsSystemObject(server.GetSmoObject(urn));
        }

        private bool IsSystemObject(SqlSmoObject obj)
        {
            if (obj is Table)
                return ((Table)obj).IsSystemObject;
            if (obj is UserDefinedFunction)
                return ((UserDefinedFunction)obj).IsSystemObject;
            if (obj is StoredProcedure)
                return ((StoredProcedure)obj).IsSystemObject;
            if (obj is View)
                return ((View)obj).IsSystemObject;

            return false;
        }

        private void FlagSpecialTableDependents(Node<string, Dependency> node, List<string> visited)
        {
            foreach (var dependent in node.InAdjacentNodes)
            {
                if (!visited.Contains(dependent.Key))
                {
                    dependent.Value.Flags |= DependencyFlags.SpecialTableDependent;
                    visited.Add(dependent.Key);
                    FlagSpecialTableDependents(dependent, visited);
                }
            }
        }

        private void FlagSpecialTableDependents(Node<string, Dependency> node)
        {
            List<string> visited = new List<string>();
            visited.Add(node.Key);
            FlagSpecialTableDependents(node, visited);
        }

        public void Explore()
        {
            Server server;
            Database database;
            DependencyTreeNode parent;
            DependencyWalker walker;
            DependencyTree tree;
            List<Urn> urns;
            List<Urn> roles;
            List<Urn> tables;
            int urnWalk = 0;
            int walkSize = 500;

            Console.WriteLine("d> Enumerating Sql Objects...");

            server = new Server(serverName);
            database = server.Databases[databaseName];
            walker = new DependencyWalker(server);
            urns = EnumerateObjects(database, out roles, out tables);

            // create dependency nodes
            foreach (Urn urn in urns)
                AddDependency(new Dependency(urn));
            foreach (Urn urn in roles)
                AddDependency(new Dependency(urn));

            // remove urns which cant have dependencies
            PruneUrns(ref urns);

            while (urnWalk < urns.Count)
            {
                Urn[] urnBatch;
                int count;

                count = Math.Min(walkSize, urns.Count - urnWalk);
                urnBatch = new Urn[count];
                urns.CopyTo(urnWalk, urnBatch, 0, count);

                Console.WriteLine("d> Exploring dependencies for Sql Objects batch " + urnWalk + " to " + (urnWalk + count - 1));

                // connect dependency nodes
                tree = walker.DiscoverDependencies(urnBatch, DependencyType.Children);
                parent = tree.FirstChild;

                while (parent != null)
                {
                    DependencyTreeNode child = parent.FirstChild;

                    while (child != null)
                    {
                        // only map dependencies between like types
                        if (parent.Urn.Type == child.Urn.Type)
                            MapDependency(parent.Urn, child.Urn);

                        // get the next child of the current parent
                        child = child.NextSibling;
                    }

                    // next parent in the original urns array
                    parent = parent.NextSibling;
                }

                urnWalk += count;
            }

            // mark special tables
            foreach (Urn urn in tables)
            {
                if (IsSpecialTable(server, urn))
                {
                    var node = graph[GetKey(urn)];
                    var dependency = node.Value;

                    dependency.Flags |= DependencyFlags.SpecialTable;

                    FlagSpecialTableDependents(node);
                }
            }
        }

        #region Exploration Helper Methods
        private bool IsValidObject(Server server, Urn urn)
        {
            string schema = urn.GetAttribute("Schema");
            string name = GetName(urn);

            switch (schema)
            {
                case "sys":
                case "INFORMATION_SCHEMA":
                    return false;
                default:
                    // exclude this specific webstore table
                    if (urn.Type == TableType && name.ToLower().StartsWith("webstore"))
                        return false;

                    // exclude the public role
                    if (urn.Type == RoleType)
                    {
                        if (name == "public")
                            return false;
                        else
                        {
                            DatabaseRole role = (DatabaseRole)server.GetSmoObject(urn);
                            return !role.IsFixedRole;
                        }
                    }

                    // exclude sprocs that start with wst or wsp
                    if (urn.Type == SprocType)
                    {
                        if (name.ToLower().StartsWith("wst") || name.ToLower().StartsWith("wsp"))
                            return false;
                    }

                    return !IsSystemObject(server, urn);
            }
        }

        private List<Urn> EnumerateObjects(Database database, out List<Urn> roles, out List<Urn> tables)
        {
            DatabaseObjectTypes flags;
            DataTable objectTable;
            List<Urn> results;

            flags = DatabaseObjectTypes.Table |
               DatabaseObjectTypes.View |
               DatabaseObjectTypes.UserDefinedFunction |
               DatabaseObjectTypes.StoredProcedure |
               DatabaseObjectTypes.DatabaseRole;

            objectTable = database.EnumObjects(flags);
            results = new List<Urn>();
            roles = new List<Urn>();
            tables = new List<Urn>();

            foreach (DataRow row in objectTable.Rows)
            {
                Urn urn = new Urn((string)row[3]);

                if (IsValidObject(database.Parent, urn))
                {
                    if (urn.Type == RoleType)
                        roles.Add(urn);
                    else
                        results.Add(urn);

                    if (urn.Type == TableType)
                        tables.Add(urn);

                    EnumerateObjectTriggers(database.Parent, urn, results);
                }
            }

            return results;
        }

        private void EnumerateObjectTriggers(Server server, Urn urn, List<Urn> target)
        {
            TriggerCollection collection = null;

            switch (urn.Type)
            {
                case "View":
                    collection = ((View)server.GetSmoObject(urn)).Triggers;
                    break;
                case "Table":
                    collection = ((Table)server.GetSmoObject(urn)).Triggers;
                    break;
            }

            if (null != collection)
            {
                foreach (Trigger trigger in collection)
                    target.Add(trigger.Urn);
            }
        }
        #endregion

        public void PruneUrns(ref List<Urn> urns)
        {
            int c = 0;

            while (c < urns.Count)
            {
                if (urns[c].Type == TriggerType)
                    urns.RemoveAt(c);
                else
                    c++;
            }
        }

        public void AddDependency(Dependency dependency)
        {
            if (null == dependency)
                throw new ArgumentNullException("dependency");

            lock (graph)
            {
                if (graph.Nodes.Contains(dependency.Key))
                    throw new ArgumentException("already present in collection", "dependency:" + dependency.Key);

                graph.Nodes.Add(dependency.Key, dependency);
            }
        }

        public bool RemoveDependency(string key)
        {
            if (string.IsNullOrEmpty(key))
                throw new ArgumentNullException("key");

            lock (graph)
            {
                return graph.Nodes.Remove(key);
            }
        }

        public void MapDependency(string targetKey, string dependentKey)
        {
            if (string.IsNullOrEmpty(targetKey))
                throw new ArgumentNullException("targetKey");
            if (string.IsNullOrEmpty(dependentKey))
                throw new ArgumentNullException("dependentKey");

            lock (graph)
            {
                graph.Edges.Add(targetKey, dependentKey);
            }
        }

        public void MapDependency(Urn targetUrn, Urn dependentUrn)
        {
            if (null == targetUrn)
                throw new ArgumentNullException("targetUrn");
            if (null == dependentUrn)
                throw new ArgumentNullException("dependentUrn");

            MapDependency(GetKey(targetUrn), GetKey(dependentUrn));
        }

        public void MapDependency(Dependency target, Dependency dependent)
        {
            if (null == target)
                throw new ArgumentNullException("target");
            if (null == dependent)
                throw new ArgumentNullException("dependent");

            MapDependency(target.Key, dependent.Key);
        }

        public OrderCache<string, Dependency> GetPartialOrdering()
        {
            DependencyEvaluator<string, Dependency> evaluator;

            lock (graph)
            {
                evaluator = graph.CreateEvalulator();
                return evaluator.Evaluate();
            }
        }

        public List<Dependency> GetDependencies()
        {
            List<Dependency> dependencies = new List<Dependency>();

            lock (graph)
            {
                foreach (Node<string, Dependency> node in graph.Nodes)
                {
                    dependencies.Add(node.Value);
                }
            }

            return dependencies;
        }

        public DirectedGraph<string, Dependency> Graph
        {
            get { return graph; }
        }

        private DirectedGraph<string, Dependency> graph;
        private Explorer explorer;
        private string serverName;
        private string databaseName;

        #region Nested Types
        public class Dependency
        {
            public Dependency(Urn urn)
            {
                if (string.IsNullOrEmpty(urn))
                    throw new ArgumentNullException("urn");

                this.key = GetKey(urn);
                this.name = GetName(urn);
                this.urn = urn;
            }

            public Dependency(string key, string name, Urn urn)
            {
                if (string.IsNullOrEmpty(key))
                    throw new ArgumentNullException("key");
                if (string.IsNullOrEmpty(name))
                    throw new ArgumentNullException("name");
                if (null == urn)
                    throw new ArgumentNullException("urn");

                this.key = key;
                this.name = name;
                this.urn = urn;
                this.Flags = DependencyFlags.None;
            }

            public string Key
            {
                get { return key; }
            }

            public string Name
            {
                get { return name; }
            }

            public DependencyFlags Flags { get; set; }

            public Urn Urn
            {
                get { return urn; }
                set { urn = value; }
            }

            private string key;
            private string name;
            private Urn urn;
        }

        [Flags]
        public enum DependencyFlags
        {
            SpecialTable            = 0x00000001,
            SpecialTableDependent   = 0x00000002,
            None                    = 0x00000000
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public partial class DirectedGraph<TKey, TValue> {
      public DirectedGraph() : this(null) { }

      public DirectedGraph(IEqualityComparer<TKey> comparer) {
         this.nodes = new Dictionary<TKey, Node<TKey, TValue>>(comparer);
      }

      public void Clear() { 
         Nodes.Clear(); 
      }

      public DependencyEvaluator<TKey, TValue> CreateEvalulator() {
         return new DependencyEvaluator<TKey, TValue>(this);
      }

      public virtual bool IgnoreLoops {
         get { return ignoreSelfLoops; }
         set { ignoreSelfLoops = value; }
      }

      public virtual bool IsSubsetAcyclic(IEnumerable<Node<TKey, TValue>> excludedNodes, IEnumerable<Edge<TKey, TValue>> excludedEdges) {
         if (IsAcyclic)
            return true;

         return containsCycles(excludedNodes, excludedEdges);
      }

      public bool IsAcyclic {
         get { return !((!IgnoreLoops && ContainsLoops) || ContainsCycles); }
      }

      public virtual bool ContainsLoops {
         get { return loopCount != 0; }
      }

      public virtual bool ContainsCycles {
         get {
            if (!cycleResultCache.HasValue)
               cycleResultCache = containsCycles(null, null);

            return cycleResultCache.Value;
         }
      }

      public Node<TKey, TValue> this[TKey key] {
         get { return nodes[key]; } 
      }

      public IEnumerable<TKey> Keys { 
         get { return nodes.Keys; } 
      }

      public NodeCollection Nodes {
         get {
            return null == nCol ?
               nCol = new NodeCollection(this, nodes) :
               nCol;
         }
      }

      public EdgeCollection Edges {
         get { 
            return null == eCol ? 
               eCol = new EdgeCollection(this, nodes) : 
               eCol; 
         }
      }

      public IEqualityComparer<TKey> KeyComparer { 
         get { return nodes.Comparer; } 
      }

      public    event EventHandler<EdgeEventArgs> OnEdgeUpdate;
      protected event EventHandler<EdgeEventArgs> internalOnEdgeUpdate;

      private bool                     ignoreSelfLoops;
      protected Dictionary<TKey, Node<TKey, TValue>> nodes;

      protected NodeCollection         nCol;
      protected EdgeCollection         eCol;
      
      private int                      loopCount;
      private bool?                    cycleResultCache;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.Edge.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public class Edge<TKey, TValue> {
      public Edge(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode) {
         Attach(tailNode, headNode);
      }

      public bool IsAttached {
         get { return (headNode != null) && (tailNode != null); }
      }

      public DirectedGraph<TKey, TValue> Owner {
         get { return IsAttached ? tailNode.Owner : null; }
      }

      public void Detach() {
         if (null != Owner) Owner.edgeDeleted(this);

         if (null != this.tailNode) this.tailNode.delTail(this);
         if (null != this.headNode) this.headNode.delHead(this);
         this.tailNode = null;
         this.headNode = null;
      }

      public void Attach(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode) {
         if ((null == tailNode) ^ (null == headNode))
            throw new ArgumentException("only one Node<TKey, TValue> is null");
         
         Detach();
         attach(tailNode, headNode);

         if (null != Owner) Owner.edgeAdded(this);
      }

      public void Reverse() {
         attach(headNode, tailNode);
      }

      public Edge<TKey, TValue> CreateReverse() {
         return createInstance(headNode, tailNode);
      }

      public override string ToString() {
         return IsAttached ?
            string.Format("edge[{0} -> {1}]", tailNode, headNode) :
            "edge[deteched]";
      }

      public Node<TKey, TValue> HeadNode { get { return headNode; } }
      public Node<TKey, TValue> TailNode { get { return tailNode; } }

      #region Helper Methods
      protected virtual Edge<TKey, TValue> createInstance(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode) {
         return new Edge<TKey, TValue>(tailNode, headNode);
      }

      private void attach(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode) {
         if (null != tailNode && null != HeadNode) {
            if (tailNode.Owner != headNode.Owner)
               throw new ArgumentException("nodes must have the same owner");
         }

         this.tailNode = tailNode;
         this.headNode = headNode;

         if (null != this.tailNode) this.tailNode.addTail(this);
         if (null != this.headNode) this.headNode.addHead(this);
      }
      #endregion

      private Node<TKey, TValue> headNode;
      private Node<TKey, TValue> tailNode;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.EdgeCollection.Enumerator.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public partial class DirectedGraph<TKey, TValue> {
      public partial class EdgeCollection {
         public sealed class Enumerator : IEnumerator<Edge<TKey, TValue>> {
            public Enumerator(IEnumerator<Node<TKey, TValue>> nodeEnumerator) {
               if (null == nodeEnumerator)
                  throw new ArgumentNullException("nodeEnumerator");

               this.nodeEnumerator = nodeEnumerator;
               softReset();
            }

            public void Dispose() {
               if (nodeEnumerator is IDisposable)
                  ((IDisposable)nodeEnumerator).Dispose();
            }

            public bool MoveNext() {
               if (!finished) {
                  if (-1 == currentIndex) {
                     if (!nodeEnumerator.MoveNext()) {
                        finished = true;
                        return false;
                     }

                     currentIndex = 0;
                  }
                  
                  while (nodeEnumerator.Current.OutDegree <= currentIndex) {
                     currentIndex = 0;
                     if (!nodeEnumerator.MoveNext()) {
                        finished = true;
                        return false;
                     }
                  }

                  current = nodeEnumerator.Current.OutEdges[currentIndex++];
                  return true;
               }

               return false;
            }

            private void softReset() {
               currentIndex = -1;
               current = null;
               finished = false;
            }

            public void Reset() {
               nodeEnumerator.Reset();
               softReset();
            }

            public Edge<TKey, TValue> Current { get { return current; } }

            #region Interface Implementation
            object IEnumerator.Current { get { return ((IEnumerator<Edge<TKey, TValue>>)this).Current; } }
            #endregion

            private IEnumerator<Node<TKey, TValue>> nodeEnumerator;
            private int currentIndex;
            private Edge<TKey, TValue> current;
            private bool finished;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.Node.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public class Node<TKey, TValue> {
      public Node(TKey key, TValue value, DirectedGraph<TKey, TValue> owner) {
         this.key = key;
         this.value = value;
         this.owner = owner;
         this.tailAdjacencies = new List<Edge<TKey, TValue>>();
         this.headAdjacencies = new List<Edge<TKey, TValue>>();
      }

      #region New Method
      public void Clear() {
         if (InDegree > 0)
            InEdges.Clear();
         if (OutDegree > 0)
            OutEdges.Clear();
      }
      #endregion
      
      public override string ToString() {
         return string.Format(
            "node({0}, {1})",
            null == key ? "(null)" : key.ToString(),
            null == value ? "(null)" : value.ToString());
      }

      #region Member Properties
      public DirectedGraph<TKey, TValue>.NodeEdgeCollection InEdges {
         get {
            return null == headEdges ?
               headEdges = new DirectedGraph<TKey, TValue>.NodeEdgeCollection(
                  this, headAdjacencies, NodeCategory.HeadNode) :
               headEdges;
         }
      }

      public DirectedGraph<TKey, TValue>.NodeEdgeCollection OutEdges {
         get {
            return null == tailEdges ?
               tailEdges = new DirectedGraph<TKey, TValue>.NodeEdgeCollection(this, tailAdjacencies, NodeCategory.TailNode) :
               tailEdges;
         }
      }

      public IEnumerable<Node<TKey, TValue>> InAdjacentNodes {
         get {
            if (null != headAdjacencies) {
               for (int c = 0; c < headAdjacencies.Count; c++)
                  yield return headAdjacencies[c].TailNode;
            }
         }
      }

      public IEnumerable<Node<TKey, TValue>> OutAdjacencyNodes {
         get {
            if (null != tailAdjacencies) {
               for (int c = 0; c < tailAdjacencies.Count; c++)
                  yield return tailAdjacencies[c].HeadNode;
            }
         }
      }

      public TKey Key { 
         get { return key; } 
      }

      public TValue Value { 
         get { return value; } set { this.value = value; } 
      }

      public int InDegree { 
         get { return null == headAdjacencies ? 0 : headAdjacencies.Count; } 
      }

      public int OutDegree { 
         get { return null == tailAdjacencies ? 0 : tailAdjacencies.Count; } 
      }

      public DirectedGraph<TKey, TValue> Owner { 
         get { return owner; } 
      }
      #endregion

      internal void addTail(Edge<TKey, TValue> edge) { this.tailAdjacencies.Add(edge); }
      internal void addHead(Edge<TKey, TValue> edge) { this.headAdjacencies.Add(edge); }

      internal void delTail(Edge<TKey, TValue> edge) { this.tailAdjacencies.Remove(edge); }
      internal void delHead(Edge<TKey, TValue> edge) { this.headAdjacencies.Remove(edge); }

      private List<Edge<TKey, TValue>> tailAdjacencyList {
         get {
            if (null == tailAdjacencies)
               tailAdjacencies = new List<Edge<TKey, TValue>>();
            return tailAdjacencies;
         }
         set { tailAdjacencies = value; }
      }

      private List<Edge<TKey, TValue>> headAdjacencyList {
         get {
            if (null == headAdjacencies)
               headAdjacencies = new List<Edge<TKey, TValue>>();
            return headAdjacencies;
         }
         set { headAdjacencies = value; }
      }

      private TKey         key;
      private TValue       value;
      private List<Edge<TKey, TValue>> tailAdjacencies;
      private List<Edge<TKey, TValue>> headAdjacencies;
      private DirectedGraph<TKey, TValue>.NodeEdgeCollection tailEdges;
      private DirectedGraph<TKey, TValue>.NodeEdgeCollection headEdges;
      private DirectedGraph<TKey, TValue> owner;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.EdgeCollection.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public partial class DirectedGraph<TKey, TValue> {
      public partial class EdgeCollection : ICollection<Edge<TKey, TValue>>, ICollection {
         public EdgeCollection(
            DirectedGraph<TKey, TValue> owner, 
            Dictionary<TKey, Node<TKey, TValue>> dictionary) 
         {
            if (null == owner)
               throw new ArgumentNullException("owner");
            if (null == dictionary)
               throw new ArgumentNullException("dictionary");

            this.dictionary = dictionary;
            this.owner = owner;
         }
         
         public void Clear() {
            foreach (Node<TKey, TValue> node in dictionary.Values)
               node.Clear();
         }
         
         public bool Contains(Edge<TKey, TValue> item) {
            if (null == item)
               throw new ArgumentNullException("item");

            return item.IsAttached ?
               item.TailNode.Owner == owner :
               false;
         }

         public Edge<TKey, TValue> Add(TKey tailNodeKey, TKey headNodeKey) {
            if (null == dictionary)
               throw new NotSupportedException();
            return Add(dictionary[tailNodeKey], dictionary[headNodeKey]);
         }

         public Edge<TKey, TValue> Add(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode) {
            if (null == dictionary)
               throw new NotSupportedException();
            return Add(tailNode, headNode, true)[0];
         }

         public Edge<TKey, TValue>[] Add(TKey tailNodeKey, TKey headNodeKey, bool isDirected) {
            if (null == dictionary)
               throw new NotSupportedException();
            return Add(dictionary[tailNodeKey], dictionary[headNodeKey], isDirected);
         }

         public Edge<TKey, TValue>[] Add(Node<TKey, TValue> tailNode, Node<TKey, TValue> headNode, bool isDirected) {
            if (null == dictionary)
               throw new NotSupportedException();
            if (null == tailNode)
               throw new ArgumentNullException("tailNode");
            if (null == headNode)
               throw new ArgumentNullException("headNode");

            return isDirected ?
               new Edge<TKey, TValue>[] { new Edge<TKey, TValue>(tailNode, headNode) } :
               new Edge<TKey, TValue>[] { new Edge<TKey, TValue>(tailNode, headNode), new Edge<TKey, TValue>(headNode, tailNode) };
         }

         public bool Remove(Edge<TKey, TValue> item) {
            bool Contained;
            if (null == item)
               throw new ArgumentNullException("item");

            Contained = Contains(item);
            item.Detach();
            return Contained;
         }

         public IEnumerator<Edge<TKey, TValue>> GetEnumerator() {
            return new Enumerator(dictionary.Values.GetEnumerator());
         }

         public void CopyTo(Edge<TKey, TValue>[] array, int arrayIndex) {
            IEnumerator<Edge<TKey, TValue>> Enumerator;

            if (null == array)
               throw new ArgumentNullException("array");
            if (arrayIndex < 0 || array.Length < arrayIndex)
               throw new ArgumentOutOfRangeException("arrayIndex");

            using (Enumerator = GetEnumerator()) {
               while (Enumerator.MoveNext()) {
                  if (array.Length <= arrayIndex)
                     throw new ArgumentException("too small for given offset", "array");

                  array[arrayIndex++] = Enumerator.Current;
               }
            }
         }

         public int Count {
            get {
               int Sum = 0;
               foreach (Node<TKey, TValue> node in dictionary.Values)
                  Sum += node.OutDegree;
               return Sum;
            }
         }

         #region Explicit Interface Implementation
         void ICollection<Edge<TKey, TValue>>.Add(Edge<TKey, TValue> item) { }
         bool ICollection<Edge<TKey, TValue>>.IsReadOnly { get { return null == dictionary; } }

         IEnumerator IEnumerable.GetEnumerator() {
            return new Enumerator(dictionary.Values.GetEnumerator());
         }

         void ICollection.CopyTo(Array array, int index) {
            IEnumerator<Edge<TKey, TValue>> Enumerator;

            if (null == array)
               throw new ArgumentNullException("array");
            if (array.Rank != 1)
               throw new ArgumentException("rank must be 1", "array");
            if (array.GetLowerBound(0) != 0)
               throw new ArgumentException("lower bound must be 0", "array");
            if (index < 0 || array.Length < index)
               throw new ArgumentOutOfRangeException("arrayIndex");

            using (Enumerator = GetEnumerator()) {
               while (Enumerator.MoveNext()) {
                  if (array.Length <= index)
                     throw new ArgumentException("too small for given offset", "array");

                  array.SetValue(Enumerator.Current, index++);
               }
            }
         }
         int ICollection.Count { get { return Count; } }
         bool ICollection.IsSynchronized { get { return false; } }
         object ICollection.SyncRoot { get { return ((ICollection)dictionary).SyncRoot; } }
         #endregion

         private Dictionary<TKey, Node<TKey, TValue>> dictionary;
         private DirectedGraph<TKey, TValue> owner;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.privates.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Diagnostics;
   #endregion

   public partial class DirectedGraph<TKey, TValue> {
      public enum EdgeEventType {
         EdgeAdded      = 1,
         EdgeDeleted    = 2
      }

      private enum VisitedState {
         Exploring,
         Explored
      }

      public delegate void EdgeEventHandler(object sender, EdgeEventArgs e);

      public class EdgeEventArgs : EventArgs {
         public EdgeEventArgs(Edge<TKey, TValue> edge, EdgeEventType eventType) {
            if (edge == null)
               throw new ArgumentNullException("edge");

            this.edge = edge;
            this.eventType = eventType;
         }

         public Edge<TKey, TValue> Edge { get { return edge; } }
         public EdgeEventType EventType { get { return eventType; } }

         private Edge<TKey, TValue> edge;
         private EdgeEventType eventType;
      }

      internal void edgeDeleted(Edge<TKey, TValue> edge) {
         if (edge.HeadNode == edge.TailNode) {
            loopCount--;
            Debug.Assert(loopCount >= 0, "loopCount cannot be less than 0");
         }
         else if (cycleResultCache.HasValue && cycleResultCache.Value)
            cycleResultCache = null;

         raiseEdgeUpdate(edge, EdgeEventType.EdgeDeleted);
      }

      internal virtual void edgeAdded(Edge<TKey, TValue> edge) {
         if (edge.TailNode == edge.HeadNode)
            loopCount++;
         else
            cycleResultCache = null;

         raiseEdgeUpdate(edge, EdgeEventType.EdgeAdded);
      }

      private void raiseEdgeUpdate(Edge<TKey, TValue> edge, EdgeEventType eventType) {
         EdgeEventArgs Args;
         Args = new EdgeEventArgs(edge, eventType);
         
         if (null != internalOnEdgeUpdate)
            internalOnEdgeUpdate(this, Args);
         if (null != OnEdgeUpdate)
            OnEdgeUpdate(this, Args);
      }

      protected bool containsCycles(IEnumerable<Node<TKey, TValue>> excludedNodes, IEnumerable<Edge<TKey, TValue>> excludedEdges) {
         Dictionary<Node<TKey, TValue>, bool> ExcludedNodes;
         Dictionary<Edge<TKey, TValue>, bool> ExcludedEdges;
         Dictionary<Node<TKey, TValue>, VisitedState> VisitedCache;

         ExcludedNodes = new Dictionary<Node<TKey, TValue>, bool>();
         ExcludedEdges = new Dictionary<Edge<TKey, TValue>, bool>();

         VisitedCache = new Dictionary<Node<TKey, TValue>, VisitedState>();

         if (null != excludedNodes) {
            foreach (Node<TKey, TValue> node in excludedNodes) {
               if (node.Owner == this)
                  ExcludedNodes[node] = true;
            }
         }

         if (null != excludedEdges) {
            foreach (Edge<TKey, TValue> edge in excludedEdges) {
               if (edge.Owner == this)
                  ExcludedEdges[edge] = true;
            }
         }

         foreach (Node<TKey, TValue> node in Nodes) {
            bool HasCycle;

            if (ExcludedNodes.Count > 0 || ExcludedEdges.Count > 0) {
               HasCycle = recursiveContainsCycles(
                  ExcludedNodes,
                  ExcludedEdges,
                  VisitedCache,
                  node);
            }
            else
               HasCycle = recursiveContainsCycles(
                  VisitedCache,
                  node);

            if (HasCycle)
               return true;
         }

         return false;
      }

      private bool recursiveContainsCycles(
         Dictionary<Node<TKey, TValue>, VisitedState> visitedCache,
         Node<TKey, TValue> current)
      {
         if (visitedCache.ContainsKey(current)) {
            VisitedState State;

            State = visitedCache[current];
            if (State == VisitedState.Exploring)
               return true;
            if (State == VisitedState.Explored)
               return false;
         }

         visitedCache[current] = VisitedState.Exploring;

         foreach (Edge<TKey, TValue> edge in current.OutEdges) {
            bool HasCycle;

            // Loops are not counted as cycles
            if (edge.HeadNode == edge.TailNode)
               continue;

            HasCycle = recursiveContainsCycles(
               visitedCache,
               edge.HeadNode);

            if (HasCycle)
               return true;
         }

         visitedCache[current] = VisitedState.Explored;

         return false;
      }

      private bool recursiveContainsCycles(
         Dictionary<Node<TKey, TValue>, bool> excludedNodes,
         Dictionary<Edge<TKey, TValue>, bool> excludedEdges,
         Dictionary<Node<TKey, TValue>, VisitedState> visitedCache,
         Node<TKey, TValue> current)
      {
         if (excludedNodes.ContainsKey(current))
            return false;

         if (visitedCache.ContainsKey(current)) {
            VisitedState State;

            State = visitedCache[current];
            if (State == VisitedState.Exploring)
               return true;
            if (State == VisitedState.Explored)
               return false;
         }

         visitedCache[current] = VisitedState.Exploring;

         foreach (Edge<TKey, TValue> edge in current.OutEdges) {
            bool HasCycle;

            // Loops are not counted as cycles
            if (edge.HeadNode == edge.TailNode)
               continue;
            if (excludedEdges.ContainsKey(edge))
               continue;

            HasCycle = recursiveContainsCycles(
                  excludedNodes,
                  excludedEdges,
                  visitedCache,
                  edge.HeadNode);

            if (HasCycle)
               return true;
         }

         visitedCache[current] = VisitedState.Explored;

         return false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.NodeCollection.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public partial class DirectedGraph<TKey, TValue> {
      public sealed class NodeCollection : ICollection<Node<TKey, TValue>>, ICollection {
         public NodeCollection(DirectedGraph<TKey, TValue> graph, Dictionary<TKey, Node<TKey, TValue>> dictionary) {
            if (null == dictionary)
               throw new ArgumentNullException("dictionary");
            if (null == graph)
               throw new ArgumentNullException("graph");

            this.dictionary = dictionary;
            this.graph = graph;
         }

         public Node<TKey, TValue> Duplicate(Node<TKey, TValue> item) {
            if (item == null)
               throw new ArgumentNullException("item");

            return Add(item.Key, item.Value);
         }

         public Node<TKey, TValue>[] Duplicate(IEnumerable<Node<TKey, TValue>> items) {
            List<Node<TKey, TValue>> Nodes;
            
            Nodes = new List<Node<TKey, TValue>>();
            foreach (Node<TKey, TValue> item in items)
               Nodes.Add(Duplicate(item));
            
            return Nodes.ToArray();
         }

         public Node<TKey, TValue> Add(TKey key, TValue value) {
            return addNode(new Node<TKey, TValue>(key, value, graph));
         }

         public void Clear() {
            dictionary.Clear();
         }
         
         public bool Remove(TKey key) {
            if (dictionary.ContainsKey(key)) {
               dictionary[key].Clear();
               dictionary.Remove(key);
               return true;
            }
            return false;
         }

         public bool Remove(Node<TKey, TValue> item) {
            if (null == item)
               throw new ArgumentNullException("item");

            return Remove(item.Key);
         }

         public bool Contains(TKey key) {
            return dictionary.ContainsKey(key);
         }

         public bool Contains(Node<TKey, TValue> item) {
            if (null == item)
               throw new ArgumentNullException("item");

            return dictionary.ContainsValue(item);
         }

         public Node<TKey, TValue>[] Select(Predicate<Node<TKey, TValue>> selector) {
            List<Node<TKey, TValue>> Results;

            if (null == selector)
               throw new ArgumentNullException("selector");

            Results = new List<Node<TKey, TValue>>();
            foreach (Node<TKey, TValue> node in dictionary.Values)
               if (selector(node))
                  Results.Add(node);

            return Results.ToArray();
         }

         public void CopyTo(Node<TKey, TValue>[] array, int index) {
            if (null == array)
               throw new ArgumentNullException("array");
            if ((index < 0) || (index > array.Length))
               throw new IndexOutOfRangeException("index");
            if ((array.Length - index) < dictionary.Count)
               throw new ArgumentException("too small for given offset", "array");

            foreach (Node<TKey, TValue> node in dictionary.Values)
               array[index++] = node;
         }

         public IEnumerator<Node<TKey, TValue>> GetEnumerator() { return dictionary.Values.GetEnumerator(); }

         public int Count { get { return dictionary.Count; } }
         public Node<TKey, TValue> this[TKey key] { get { return dictionary[key]; } }

         private Node<TKey, TValue> addNode(Node<TKey, TValue> item) {
            dictionary[item.Key] = item;
            return item;
         }

         #region Explicit Interface Implementations
         // ICollection<Node<TKey, TValue>>
         void ICollection<Node<TKey, TValue>>.Add(Node<TKey, TValue> item) {
            if (null == item)
               throw new ArgumentNullException("item");
            if (item.Owner != graph)
               throw new ArgumentException("owner mismatch", "item");

            addNode(item);
         }

         bool ICollection<Node<TKey, TValue>>.IsReadOnly { get { return false; } }

         // IEnumerable
         IEnumerator IEnumerable.GetEnumerator() { return dictionary.Values.GetEnumerator(); }
         
         // ICollection
         void ICollection.CopyTo(Array array, int index) {
            if (null == array)
               throw new ArgumentNullException("array");
            if (array.Rank != 1)
               throw new ArgumentException("rank must be 1", "array");
            if (array.GetLowerBound(0) != 0)
               throw new ArgumentException("lower bound must be 0", "array");
            if ((index < 0) || (index > array.Length))
               throw new IndexOutOfRangeException("index");
            if ((array.Length - index) < dictionary.Count)
               throw new ArgumentException("too small for given offset", "array");

            foreach (Node<TKey, TValue> node in dictionary.Values)
               array.SetValue(node, index++);
         }
         bool ICollection.IsSynchronized { get { return false; } }
         object ICollection.SyncRoot { get { return ((ICollection)dictionary).SyncRoot; } }
         int ICollection.Count { get { return Count; } }
         #endregion

         private Dictionary<TKey, Node<TKey, TValue>> dictionary;
         private DirectedGraph<TKey, TValue> graph;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\OrderCache.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion

   public class OrderCache<TKey, TValue> {
      public const int UnsatisfiedRank = OrderedNode<TKey, TValue>.UnsatisfiedRank;

      public OrderCache(IEnumerable<OrderedNode<TKey, TValue>> orderedNodes) {
         this.cache = new List<OrderedNode<TKey, TValue>>();
         this.rankLookup = new Dictionary<int, int>();
         this.ranks = 0;

         CacheNodes(orderedNodes, false);
      }

      private void generateRankLookup() {
         int CurrentRank;

         this.rankLookup.Clear();
         this.ranks = 0;
         CurrentRank = UnsatisfiedRank - 1;

         for (int c = 0; c < cache.Count; c++) {
            if (cache[c].Rank != CurrentRank) {
               CurrentRank = cache[c].Rank;
               rankLookup[CurrentRank] = c;
               this.ranks = CurrentRank + 1;
            }
         }
      }

      public void Clear() {
         this.cache.Clear();
         this.rankLookup.Clear();
         this.ranks = 0;
      }

      public void CacheNodes(IEnumerable<OrderedNode<TKey, TValue>> orderedNodes) {
         CacheNodes(orderedNodes, true);
      }

      public void CacheNodes(IEnumerable<OrderedNode<TKey, TValue>> orderedNodes, bool clearCache) {
         if (clearCache)
            Clear();

         if (null != orderedNodes) {
            foreach (OrderedNode<TKey, TValue> orderedNode in orderedNodes)
               cache.Add(orderedNode);

            cache.Sort(
               delegate(OrderedNode<TKey, TValue> x, OrderedNode<TKey, TValue> y) {
                  return x.PartialOrder - y.PartialOrder;
               }
            );

            generateRankLookup();
         }
      }

      public IEnumerable<OrderedNode<TKey, TValue>> this[int rank] {
         get { return GetNodes(rank); }
      }

      public IEnumerable<OrderedNode<TKey, TValue>> GetNodes() {
         return GetNodes(0, Ranks);
      }

      public IEnumerable<OrderedNode<TKey, TValue>> GetNodes(int rank) {
         return GetNodes(rank, rank);
      }

      public IEnumerable<OrderedNode<TKey, TValue>> GetNodes(int minRank, int maxRank) {
         minRank = Math.Max(minRank, UnsatisfiedRank);
         maxRank = Math.Min(maxRank + 1, ranks);
         while (minRank < maxRank) {
            if (rankLookup.ContainsKey(minRank)) {
               for (int c = rankLookup[minRank]; c < cache.Count && cache[c].Rank == minRank; c++)
                  yield return cache[c];
            }
            minRank++;
         }
      }

      public IEnumerable<OrderedNode<TKey, TValue>> GetUnsatisfiableNodes() {
         return GetNodes(UnsatisfiedRank, UnsatisfiedRank);
      }

      public OrderedNode<TKey, TValue>[] ToArray() {
         return getArray(GetNodes());
      }

      public OrderedNode<TKey, TValue>[] ToArray(int rank) {
         return getArray(GetNodes(rank));
      }

      public OrderedNode<TKey, TValue>[] ToArray(int minRank, int maxRank) {
         return getArray(GetNodes(minRank, maxRank));
      }

      private OrderedNode<TKey, TValue>[] getArray(IEnumerable<OrderedNode<TKey, TValue>> array) {
         return new List<OrderedNode<TKey, TValue>>(array).ToArray();
      }

      public IEnumerable<OrderedNode<TKey, TValue>> AllNodes {
         get { return GetNodes(-1, Ranks); }
      }

      public IEnumerable<OrderedNode<TKey, TValue>> AllSatisfiableNodes {
         get { return GetNodes(); }
      }

      public bool Satisfiable {
         get {
            return cache.Count > 0 ? cache[0].Rank >= 0 : true;
         }
      }

      public int Ranks {
         get { return ranks; }
      }

      private List<OrderedNode<TKey, TValue>> cache;
      private Dictionary<int, int> rankLookup;
      private int ranks;
   }

   public class OrderedNode<TKey, TValue> {
      public const int UnsatisfiedRank = -1;

      public OrderedNode(Node<TKey, TValue> node)
         : this(node, UnsatisfiedRank, UnsatisfiedRank) { }

      public OrderedNode(Node<TKey, TValue> node, int rank, int partialOrder) {
         if (null == node)
            throw new ArgumentNullException("node");
         if (-1 > rank)
            throw new ArgumentOutOfRangeException("rank");
         if (-1 > partialOrder)
            throw new ArgumentOutOfRangeException("partialOrder");

         this.node = node;
         this.rank = rank;
         this.partialOrder = partialOrder;
      }

      public Node<TKey, TValue> Node {
         get { return node; }
      }

      public int Rank {
         get { return rank; }
      }

      public int PartialOrder {
         get { return partialOrder; }
      }

      public bool Satisfiable {
         get { return rank >= 0; }
      }

      private Node<TKey, TValue> node;
      private int rank;
      private int partialOrder;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreJob.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreJob : WebstoreReplicatedObject {
      public WebstoreJob() { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreFunction.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreFunction : WebstoreReplicatedObject {
      public WebstoreFunction() {
         setupStep = SetupSteps.AfterTables;
      }

      protected override ManifestProperty[] GetProperties() {
         return this.CreateProperties(
            base.GetProperties(),
            setupStep.CreateElementProperty("SetupStep")
         );
      }

      public SetupSteps SetupStep {
         get { return setupStep; }
         set { setupStep = value; }
      }

      private SetupSteps setupStep;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\dependency\graph\DirectedGraph.NodeEdgeCollection.cs ===
﻿namespace xonline.tools.graph {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Collections.Generic;
   #endregion
   
   public enum NodeCategory {
      HeadNode = 1,
      TailNode = 2
   }

   public partial class DirectedGraph<TKey, TValue> {
      public partial class NodeEdgeCollection : ICollection<Edge<TKey, TValue>>, ICollection {
         public NodeEdgeCollection(Node<TKey, TValue> owner, List<Edge<TKey, TValue>> edges, NodeCategory nodeCategory) {
            if (null == owner)
               throw new ArgumentNullException("node");
            if (null == edges)
               throw new ArgumentNullException("edges");

            this.owner = owner;
            this.edges = edges;
            this.nodeCategory = nodeCategory;
         }

         public Edge<TKey, TValue> Add(Node<TKey, TValue> node) { return Add(node, true)[0]; }
         public Edge<TKey, TValue> Add(TKey nodeKey) { return Add(nodeKey, true)[0]; }

         public Edge<TKey, TValue>[] Add(Node<TKey, TValue> item, bool isDirected) {
            if (isDirected) {
               if (nodeCategory == NodeCategory.TailNode)
                  return new Edge<TKey, TValue>[] { new Edge<TKey, TValue>(owner, item) };
               else
                  return new Edge<TKey, TValue>[] { new Edge<TKey, TValue>(item, owner) };
            }
            else
               return new Edge<TKey, TValue>[] { new Edge<TKey, TValue>(owner, item), new Edge<TKey, TValue>(item, owner) };
         }

         public Edge<TKey, TValue>[] Add(TKey nodeKey, bool isDirected) {
            return Add(owner.Owner[nodeKey], isDirected);
         }

         public void Clear() {
            while (edges.Count > 0)
               edges[0].Detach();
         }

         public bool Contains(Edge<TKey, TValue> item) {
            return edges.Contains(item);
         }

         public void CopyTo(Edge<TKey, TValue>[] array, int arrayIndex) {
            edges.CopyTo(array, arrayIndex);
         }

         private List<Edge<TKey, TValue>> buildEdgeList(Predicate<Node<TKey, TValue>> selector) {
            List<Edge<TKey, TValue>> EdgeList;
            EdgeList = new List<Edge<TKey, TValue>>();
            if (nodeCategory == NodeCategory.HeadNode) {
               for (int c = 0; c < edges.Count; c++) {
                  if (selector(edges[c].TailNode))
                     EdgeList.Add(edges[c]);
               }
            }
            else {
               for (int c = 0; c < edges.Count; c++) {
                  if (selector(edges[c].HeadNode))
                     EdgeList.Add(edges[c]);
               }
            }
            return EdgeList;
         }

         private bool removeList(List<Edge<TKey, TValue>> edgeList) {
            for (int c = 0; c < edgeList.Count; c++)
               edgeList[c].Detach();
            return edgeList.Count != 0;
         }

         public bool Remove(TKey nodeKey) {
            List<Edge<TKey, TValue>> EdgeList;
            int NodeKeyHashCode;

            if (null == nodeKey)
               throw new ArgumentNullException("nodeKey");

            NodeKeyHashCode = nodeKey.GetHashCode();
            EdgeList = buildEdgeList(
               delegate(Node<TKey, TValue> item) {
                  return
                     item.Key.GetHashCode() == NodeKeyHashCode &&
                     item.Owner.KeyComparer.Equals(item.Key, nodeKey);
               }
            );
            
            return removeList(EdgeList);
         }

         public bool Remove(Node<TKey, TValue> node) {
            List<Edge<TKey, TValue>> EdgeList;
            
            if (node.Owner != owner.Owner)
               return false;
            
            EdgeList = buildEdgeList(delegate(Node<TKey, TValue> item) { return item == node; });
            return removeList(EdgeList);
         }

         public bool Remove(Edge<TKey, TValue> item) {
            if (null == item)
               throw new ArgumentNullException("item");
            
            if (!item.IsAttached || item.HeadNode.Owner != owner.Owner)
               return false;
            else {
               item.Detach();
               return true;
            }
         }

         public IEnumerator<Edge<TKey, TValue>> GetEnumerator() {
            return edges.GetEnumerator();
         }

         public int Count { get { return edges.Count; } }
         public Node<TKey, TValue> Owner { get { return owner; } }
         public NodeCategory OwnerCategory { get { return nodeCategory; } }
         public Edge<TKey, TValue> this[int index] {
            get { return edges[index]; }
         }

         #region Interface Implementation
         int ICollection.Count { get { return edges.Count; } }

         void ICollection<Edge<TKey, TValue>>.Add(Edge<TKey, TValue> item) { }
         bool ICollection<Edge<TKey, TValue>>.IsReadOnly { get { return false; } }
         void ICollection.CopyTo(Array array, int index) { ((ICollection)edges).CopyTo(array, index); }
         bool ICollection.IsSynchronized { get { return false; } }

         object ICollection.SyncRoot { get { return ((ICollection)edges).SyncRoot; } }

         IEnumerator IEnumerable.GetEnumerator() { return edges.GetEnumerator(); }
         #endregion

         private Node<TKey, TValue> owner;
         private List<Edge<TKey, TValue>> edges;
         private NodeCategory nodeCategory;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreFileGroup.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element
{
    public class WebstoreFileGroup : WebstoreObject
    {
        public WebstoreFileGroup()
        {
        }

        protected override ManifestProperty[] GetProperties()
        {
            ManifestProperty logicalFile = new ManifestProperty();
            ManifestPropertyGroup data = new ManifestPropertyGroup();

            data.ManifestProperties.Add(LogicalFileName.CreateAttributeProperty("Name"));

            logicalFile.Name = "LogicalFile";
            logicalFile.Placement = PropertyPlacement.Element;
            logicalFile.Value = data;

            return new ManifestProperty[] {
                Name.CreateAttributeProperty("Name"),
                logicalFile
            };
        }

        public string LogicalFileName { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreScript.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreScript : WebstoreReplicatedObject {
      public WebstoreScript() {
         setupStep = SetupSteps.AfterTables;
      }

      protected override ManifestProperty[] GetProperties() {
         return this.CreateProperties(
            base.GetProperties(),
            setupStep.CreateElementProperty("SetupStep")
         );
      }

      public SetupSteps SetupStep {
         get { return setupStep; }
         set { setupStep = value; }
      }

      private SetupSteps setupStep;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreStoredProcedure.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreStoredProcedure : WebstoreReplicatedObject {
      public WebstoreStoredProcedure() { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreManifest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element
{
    public enum PartitionType
    {
        Fixed,
        Variable
    }

    public class WebstoreManifest : IManifestElement
    {
        public WebstoreManifest()
        {
            name = "#UNSPECIFIED#";
            version = new Version("1.0.0.0");
            minimumSQLVersion = new Version("9.00.3166");
            logicalPartitionCount = 24;
            logicalPartitionColumn = "si_hash_bucket";
            Description = "";
            MultiMaster = false;
            PartitionType = PartitionType.Fixed;

            tables = new WebstoreObjectCollection<WebstoreTable>("Table");
            triggers = new WebstoreObjectCollection<WebstoreTrigger>("Trigger");
            storedProcedures = new WebstoreObjectCollection<WebstoreStoredProcedure>("Sproc");
            views = new WebstoreObjectCollection<WebstoreView>("View");
            functions = new WebstoreObjectCollection<WebstoreFunction>("Function");
            scripts = new WebstoreObjectCollection<WebstoreScript>("Script");
            securityRoles = new WebstoreObjectCollection<WebstoreSecurityRole>("SecurityRole");
            fileGroups = new WebstoreObjectCollection<WebstoreFileGroup>("FileGroup");
            jobs = new WebstoreObjectCollection<WebstoreJob>("Job");
        }

        IEnumerable<ManifestProperty> IManifestElement.ReadProperties()
        {
            List<ManifestProperty> properties = new List<ManifestProperty>();

            properties.Add(name.CreateAttributeProperty("Name"));
            if (!string.IsNullOrEmpty(Description))
                properties.Add(Description.CreateElementProperty("Description"));
            properties.Add(version.CreateElementProperty("Version"));
            properties.Add(CreateScaleout());
            properties.Add(CreateAvailability());
            properties.Add(CreateSQLObjects());

            return properties.ToArray();
        }

        private ManifestProperty CreateScaleout()
        {
            ManifestProperty property = new ManifestProperty();
            ManifestPropertyGroup scaleout = new ManifestPropertyGroup();

            property.Name = "ScaleOut";
            property.Placement = PropertyPlacement.Element;
            property.Value = scaleout;

            scaleout.AddElement("PartitionType", PartitionType);
            
            if (PartitionType == PartitionType.Fixed)
            {
                ManifestPropertyGroup partitioning = new ManifestPropertyGroup();

                scaleout.AddElement("FixedPartitioning", partitioning);

                partitioning.AddElement("LogicalPartitionCount", logicalPartitionCount);
                partitioning.AddElement("LogicalPartitionColumn", logicalPartitionColumn);
            }

            return property;
        }

        private ManifestProperty CreateAvailability()
        {
            ManifestProperty property = new ManifestProperty();
            ManifestPropertyGroup availability = new ManifestPropertyGroup();
            ManifestPropertyGroup secondary = new ManifestPropertyGroup();

            property.Name = "Availability";
            property.Placement = PropertyPlacement.Element;
            property.Value = availability;

            if (MultiMaster)
                secondary.Add(ManifestExtensions.CreateProperty(null, "Multimaster", PropertyPlacement.Element));

            availability.AddElement("SqlSecondary", secondary);
            

            secondary.AddElement("SqlSecondaryType", "SingleMaster");

            return property;
        }

        private ManifestProperty CreateSQLObjects()
        {
            ManifestProperty property = new ManifestProperty();
            ManifestPropertyGroup sqlObjects = new ManifestPropertyGroup();

            property.Name = "SqlObjects";
            property.Placement = PropertyPlacement.Element;
            property.Value = sqlObjects;

            sqlObjects.AddElement("MinSQLVersion", minimumSQLVersion);

            if (FileGroups.Count > 0)
                sqlObjects.AddElement("FileGroups", fileGroups);

            sqlObjects.AddElement("Tables", tables);
            sqlObjects.AddElement("Triggers", triggers);
            sqlObjects.AddElement("Sprocs", storedProcedures);
            sqlObjects.AddElement("Views", views);
            sqlObjects.AddElement("Functions", functions);
            sqlObjects.AddElement("Scripts", scripts);
            sqlObjects.AddElement("SecurityRoles", securityRoles);
            sqlObjects.AddElement("Jobs", jobs);

            return property;
        }

        public void Save(string filename)
        {
            XmlDocument document;
            XmlNode root, man;
            Stack<XmlNode> xmlStack;
            Stack<IManifestElement> elStack;

            string ns = "urn:WebstoreManifestSchema.xsd";

            if (string.IsNullOrEmpty(filename))
                throw new ArgumentNullException("filename");

            document = new XmlDocument();
            
            root = document.CreateElement("Webstore", ns);
            root.Attributes.Append(document.CreateAttribute("xmlns:xsi")).Value = "http://www.w3.org/2001/XMLSchema-instance";
            root.Attributes.Append(document.CreateAttribute("xmlns:xsd")).Value = "http://www.w3.org/2001/XMLSchema";
            document.AppendChild(root);

            man = document.CreateElement("Manifest", ns);
            root.AppendChild(man);

            xmlStack = new Stack<XmlNode>();
            xmlStack.Push(man);

            elStack = new Stack<IManifestElement>();
            elStack.Push(this);

            while (elStack.Count > 0)
            {
                IManifestElement elCurrent = elStack.Pop();
                XmlNode xmlCurrent = xmlStack.Pop();

                foreach (ManifestProperty mp in elCurrent.ReadProperties())
                {
                    XmlNode item;

                    switch (mp.Placement)
                    {
                        case PropertyPlacement.Attribute:
                            item = document.CreateAttribute(mp.Name);
                            item.Value = Convert.ToString(mp.Value);

                            xmlCurrent.Attributes.Append((XmlAttribute)item);
                            
                            break;
                        case PropertyPlacement.Element:
                            item = document.CreateElement(mp.Name, ns);

                            if (mp.Value is IManifestElement)
                            {
                                xmlStack.Push(item);
                                elStack.Push((IManifestElement)mp.Value);
                            }
                            else if (mp.Value != null)
                                item.InnerText = ManifestFormatter.ToString(mp.Value);

                            xmlCurrent.AppendChild(item);

                            break;
                    }
                }
            }

            using (XmlTextWriter writer = new XmlTextWriter(filename, Encoding.Unicode)) {
                writer.Indentation = 4;
                writer.IndentChar = ' ';
                writer.QuoteChar = '"';
                writer.Formatting = Formatting.Indented;

                document.Save(writer);
            }
        }

        public void AddWebstoreObject(WebstoreObject wso)
        {
            if (null == wso)
                throw new ArgumentNullException("wso");

            if (wso is WebstoreTable)
                Tables.Add((WebstoreTable)wso);
            else if (wso is WebstoreTrigger)
                Triggers.Add((WebstoreTrigger)wso);
            else if (wso is WebstoreStoredProcedure)
                StoredProcedures.Add((WebstoreStoredProcedure)wso);
            else if (wso is WebstoreView)
                Views.Add((WebstoreView)wso);
            else if (wso is WebstoreFunction)
                Functions.Add((WebstoreFunction)wso);
            else if (wso is WebstoreScript)
                Scripts.Add((WebstoreScript)wso);
            else if (wso is WebstoreSecurityRole)
                SecurityRoles.Add((WebstoreSecurityRole)wso);
            else if (wso is WebstoreJob)
                Jobs.Add((WebstoreJob)wso);
            else if (wso is WebstoreFileGroup)
                FileGroups.Add((WebstoreFileGroup)wso);
            else
                throw new InvalidOperationException("unrecognized webstore object type: " + wso.GetType()); ;
        }

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public string Description { get; set; }

        public Version MinimumSQLVersion
        {
            get { return minimumSQLVersion; }
            set { minimumSQLVersion = value; }
        }

        public Version Version
        {
            get { return version; }
            set { version = value; }
        }

        public int LogicalPartitionCount
        {
            get { return logicalPartitionCount; }
            set { logicalPartitionCount = value; }
        }

        public string LogicalPartitionColumn
        {
            get { return logicalPartitionColumn; }
            set { logicalPartitionColumn = value; }
        }

        public bool MultiMaster { get; set; }

        public PartitionType PartitionType { get; set; }

        public WebstoreObjectCollection<WebstoreTable> Tables
        {
            get { return tables; }
        }

        public WebstoreObjectCollection<WebstoreTrigger> Triggers
        {
            get { return triggers; }
        }

        public WebstoreObjectCollection<WebstoreStoredProcedure> StoredProcedures
        {
            get { return storedProcedures; }
        }

        public WebstoreObjectCollection<WebstoreView> Views
        {
            get { return views; }
        }

        public WebstoreObjectCollection<WebstoreFunction> Functions
        {
            get { return functions; }
        }

        public WebstoreObjectCollection<WebstoreScript> Scripts
        {
            get { return scripts; }
        }

        public WebstoreObjectCollection<WebstoreSecurityRole> SecurityRoles
        {
            get { return securityRoles; }
        }

        public WebstoreObjectCollection<WebstoreFileGroup> FileGroups
        {
            get { return fileGroups; }
        } 

        public WebstoreObjectCollection<WebstoreJob> Jobs
        {
            get { return jobs; }
        }

        private int logicalPartitionCount;
        private string logicalPartitionColumn;
        private string name;
        private Version version;
        private Version minimumSQLVersion;
        private WebstoreObjectCollection<WebstoreTable> tables;
        private WebstoreObjectCollection<WebstoreTrigger> triggers;
        private WebstoreObjectCollection<WebstoreStoredProcedure> storedProcedures;
        private WebstoreObjectCollection<WebstoreView> views;
        private WebstoreObjectCollection<WebstoreFunction> functions;
        private WebstoreObjectCollection<WebstoreScript> scripts;
        private WebstoreObjectCollection<WebstoreSecurityRole> securityRoles;
        private WebstoreObjectCollection<WebstoreFileGroup> fileGroups;
        private WebstoreObjectCollection<WebstoreJob> jobs;
    }

    public static class ManifestFormatter
    {
        public static string ToString(object arg)
        {
            if (arg != null && arg is bool)
                return Convert.ToString(arg).ToLower();

            return Convert.ToString(arg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreTrigger.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreTrigger : WebstoreObject {
      public WebstoreTrigger() { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreObject.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreObject : IManifestElement {
      public override string ToString() {
         return Name;
      }

      protected virtual ManifestProperty[] GetProperties() {
         return this.CreateProperties(
            sourceFile.CreateElementProperty("SourceFile"),
            installOrder.CreateElementProperty("InstallOrder"),
            name.CreateAttributeProperty("Name")
         );
      }

      IEnumerable<ManifestProperty> IManifestElement.ReadProperties() {
         return GetProperties();
      }

      public string SourceFile {
         get { return sourceFile; }
         set { sourceFile = value; }
      }

      public int InstallOrder {
         get { return installOrder; }
         set { installOrder = value; }
      }

      public string Name {
         get { return name; }
         set { name = value; }
      }

      private string sourceFile;
      private int installOrder;
      private string name;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreObjectCollection.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreObjectCollection<T> : IManifestElement, ICollection<T> where T : WebstoreObject {
      public WebstoreObjectCollection(string elementName) {
         if (string.IsNullOrEmpty(elementName))
            throw new ArgumentNullException("elementName");

         this.sorted = true;
         this.elementName = elementName;
         this.collection = new List<T>();
      }

      public T Find(string name) {
         Predicate<T> predicate;

         if (string.IsNullOrEmpty(name))
            throw new ArgumentNullException("name");

         predicate = delegate(T item) {
            return string.Compare(item.Name, name, true) == 0;
         };

         return collection.Find(predicate);
      }

      public void Add(T item) {
         if (null == item)
            throw new ArgumentNullException("item");

         sorted = false;
         collection.Add(item);
      }

      public void Sort() {
         if (!sorted) {
            Comparison<T> comparer;

            comparer = delegate(T left, T right) {
               return string.Compare(left.Name, right.Name, true);
            };

            collection.Sort(comparer);
            sorted = true;
         }
      }

      public void Clear() {
         collection.Clear();
      }

      public bool Contains(T item) {
         if (null == item)
            throw new ArgumentNullException("item");

         return collection.Contains(item);
      }

      public void CopyTo(T[] array, int arrayIndex) {
         collection.CopyTo(array, arrayIndex);
      }

      public int Count {
         get { return collection.Count; }
      }

      public bool Remove(T item) {
         if (null == item)
            throw new ArgumentNullException("item");

         return collection.Remove(item);
      }

      #region Explicit Collection Implementation
      
      bool ICollection<T>.IsReadOnly {
         get { throw new NotImplementedException(); }
      }

      IEnumerator<T> IEnumerable<T>.GetEnumerator() {
         return collection.GetEnumerator();
      }

      IEnumerator IEnumerable.GetEnumerator() {
         return ((IEnumerable)collection).GetEnumerator();
      }

      #endregion

      IEnumerable<ManifestProperty> IManifestElement.ReadProperties() {
         Converter<T, ManifestProperty> converter;

         Sort();

         converter = delegate(T item) {
            return item.CreateElementProperty(elementName); 
         };

         return collection.ConvertAll<ManifestProperty>(converter);
      }

      private bool sorted;
      private string elementName;
      private List<T> collection;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreSecurityRole.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element
{
    public class WebstoreSecurityRole : WebstoreObject
    {
        public WebstoreSecurityRole()
        {
            tablePermissions = PermissionFlags.Unspecified;
            viewPermissions = PermissionFlags.Unspecified;
            sprocExecutePermission = false;
            functionExecutePermission = false;
        }

        protected override ManifestProperty[] GetProperties()
        {
            List<ManifestProperty> properties = new List<ManifestProperty>();
            ManifestPropertyGroup execute = new ManifestPropertyGroup();

            properties.AddRange(base.GetProperties());

            execute.AddElement("Execute", true);

            if (TablePermissions != PermissionFlags.Unspecified)
                properties.Add(CreatePermissionProperty("TablePermissions", TablePermissions));
            if (ViewPermissions != PermissionFlags.Unspecified)
                properties.Add(CreatePermissionProperty("ViewPermissions", ViewPermissions));
            if (SprocExecutePermission)
                properties.Add(execute.CreateElementProperty("SprocPermissions"));
            if (FunctionExecutePermission)
                properties.Add(execute.CreateElementProperty("FunctionPermissions"));

            return properties.ToArray();
        }

        private ManifestProperty CreatePermissionProperty(string name, PermissionFlags flags)
        {
            ManifestProperty property = new ManifestProperty();
            ManifestPropertyGroup group = new ManifestPropertyGroup();
            string csv = flags.ToString();
            string[] names = csv.Split(PermissionSeparators, StringSplitOptions.RemoveEmptyEntries);

            property.Name = name;
            property.Value = group;
            property.Placement = PropertyPlacement.Element;

            group.AddEmptyElements(names);

            return property;
        }

        public PermissionFlags TablePermissions
        {
            get { return tablePermissions; }
            set { tablePermissions = value & PermissionMask; }
        }

        public PermissionFlags ViewPermissions
        {
            get { return viewPermissions; }
            set { viewPermissions = value & PermissionMask; }
        }

        public bool SprocExecutePermission
        {
            get { return sprocExecutePermission; }
            set { sprocExecutePermission = value; }
        }

        public bool FunctionExecutePermission
        {
            get { return functionExecutePermission; }
            set { functionExecutePermission = value; }
        }

        private PermissionFlags tablePermissions;
        private PermissionFlags viewPermissions;
        private bool sprocExecutePermission;
        private bool functionExecutePermission;

        private const PermissionFlags PermissionMask = (PermissionFlags)15;
        private readonly static char[] PermissionSeparators = new char[] { ',', ' ' };
    }

    [Flags]
    public enum PermissionFlags : int
    {
        Unspecified = 0,
        Select = 1,
        Insert = 2,
        Delete = 4,
        Update = 8
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreReplicatedObject.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element
{
    public class WebstoreReplicatedObject : WebstoreObject
    {
        public WebstoreReplicatedObject()
        {
            installOnPrimary = true;
            installOnSecondary = true;
        }

        protected override ManifestProperty[] GetProperties()
        {
            List<ManifestProperty> properties = new List<ManifestProperty>();

            properties.AddRange(base.GetProperties());
            
            if (!installOnPrimary)
                properties.Add(installOnPrimary.CreateElementProperty("InstallOnPrimary"));
            if (!installOnSecondary)
                properties.Add(installOnSecondary.CreateElementProperty("InstallOnSecondary"));

            return properties.ToArray();
        }

        public bool InstallOnPrimary
        {
            get { return installOnPrimary; }
            set { installOnPrimary = value; }
        }

        public bool InstallOnSecondary
        {
            get { return installOnSecondary; }
            set { installOnSecondary = value; }
        }

        private bool installOnPrimary;
        private bool installOnSecondary;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreTable.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element
{
    public class WebstoreTable : WebstoreObject
    {
        public WebstoreTable()
        {
            deleteSproc = "";
            insertSproc = "";
            updateSproc = "";
            partitioned = false;
            UpgradeOnly = false;
        }

        protected override ManifestProperty[] GetProperties()
        {
            List<ManifestProperty> properties = new List<ManifestProperty>();

            properties.AddRange(base.GetProperties());
            properties.Add(partitioned.CreateElementProperty("Partitioned"));

            if (!string.IsNullOrEmpty(insertSproc + deleteSproc + updateSproc))
                properties.Add(CreateArticle());

            if (UpgradeOnly)
                properties.Add(UpgradeOnly.CreateElementProperty("UpgradeOnly"));

            return properties.ToArray();
        }

        private ManifestProperty CreateArticle()
        {
            ManifestProperty property = new ManifestProperty();
            ManifestPropertyGroup group = new ManifestPropertyGroup();

            property.Name = "Article";
            property.Value = group;
            property.Placement = PropertyPlacement.Element;

            if (!string.IsNullOrEmpty(insertSproc))
                group.AddElement("INSsproc", insertSproc);
            if (!string.IsNullOrEmpty(deleteSproc))
                group.AddElement("DELsproc", deleteSproc);
            if (!string.IsNullOrEmpty(updateSproc))
                group.AddElement("UPDsproc", updateSproc);

            return property;
        }

        public string DeleteSproc
        {
            get { return deleteSproc; }
            set { deleteSproc = value; }
        }

        public string InsertSproc
        {
            get { return insertSproc; }
            set { insertSproc = value; }
        }

        public string UpdateSproc
        {
            get { return updateSproc; }
            set { updateSproc = value; }
        }

        public bool Partitioned
        {
            get { return partitioned; }
            set { partitioned = value; }
        }

        public bool UpgradeOnly { get; set; }

        private bool partitioned;
        private string deleteSproc;
        private string insertSproc;
        private string updateSproc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\ISchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema
{
    public interface ISchemaExtractor
    {
        void ExtractSchema(Server server, Urn urn, string target);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\manifest\element\WebstoreView.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.tools.sqlcrawler.manifest.extensions;

namespace xonline.tools.sqlcrawler.manifest.element {
   public class WebstoreView : WebstoreReplicatedObject {
      public WebstoreView() { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\GenericSchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    class GenericSchemaExtractor : ISchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.ConvertUserDefinedDataTypesToBaseType = false;
            so.AnsiPadding = true;
            so.NoCollation = true;
            so.NoIdentities = false;
            so.SchemaQualifyForeignKeysReferences = true;
            //Script bound defaults and rules = False
            so.DriChecks = true;
            so.DriDefaults = true;
            so.NoFileGroup = false;
            so.DriForeignKeys = true;
            so.FullTextIndexes = false;
            so.DriIndexes = false;
            so.Indexes = false;
            so.NoIndexPartitioningSchemes = true;
            so.DriPrimaryKey = true;
            so.Statistics = false;
            so.Triggers = false;
            so.DriUniqueKeys = true;
            so.NoViewColumns = false;
            so.DriIncludeSystemNames = false;
            so.IncludeIfNotExists = true;

            /*
            so.Triggers = false;
            so.Indexes = true;
            so.FullTextCatalogs = true;
            so.FullTextIndexes = true;
            so.ExtendedProperties = true;
            so.IncludeIfNotExists = true;
            so.DriIncludeSystemNames = true;
            so.ScriptData = false;
            */

            return so;
        }

        public void ExtractSchema(Server server, Urn urn, string target)
        {
            IScriptable scriptable = server.GetSmoObject(urn) as IScriptable;
            
            if (null == scriptable)
                throw new ArgumentException("not a valid scriptable smo object", "urn");

            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                foreach (string line in scriptable.Script(GetDefaultOptions()))
                    writer.WriteLine(line);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\SchemaExtractorFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using xonline.tools.sqlcrawler.manifest.dependency;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema
{
    public class SchemaExtractorFactory
    {
        public SchemaExtractorFactory(string outputDirectory)
        {
            if (string.IsNullOrEmpty(outputDirectory))
                throw new ArgumentNullException("outputDirectory");

            this.outputDirectory = outputDirectory;
        }

        public ISchemaExtractor GetExtractor(Urn urn, out string path)
        {
            ISchemaExtractor extractor = GenericSchemaExtractor;
            string relative = "ddl\\";

            switch (urn.Type) 
            {
                case DependencyExplorer.FunctionType:
                    relative += "function";
                    extractor = FunctionSchemaExtractor;
                    break;
                case DependencyExplorer.RoleType:
                    relative += "role"; break;
                case DependencyExplorer.SprocType:
                    relative += "sproc";
                    extractor = StoredProcedureSchemaExtractor;
                    break;
                case DependencyExplorer.TableType:
                    relative += "table";
                    extractor = TableSchemaExtractor;
                    break;
                case DependencyExplorer.TriggerType:
                    relative += "trigger";
                    extractor = TriggerSchemaExtractor;
                    break;
                case DependencyExplorer.ViewType:
                    relative += "view";
                    extractor = ViewSchemaExtractor;
                    break;
                default:
                    throw new ArgumentException("unexpected urn type: " + urn.Type, "urn");
            }

            relative += "\\" + urn.GetAttribute("Name") + ".sql";
            path = Path.Combine(outputDirectory, relative);

            return extractor;
        }
        
        public static ISchemaExtractor GenericSchemaExtractor
        {
            get
            {
                if (null == genericSchemaExtractor)
                    genericSchemaExtractor = new extractor.GenericSchemaExtractor();

                return genericSchemaExtractor;
            }
        }

        public static ISchemaExtractor ViewSchemaExtractor
        {
            get
            {
                if (null == viewSchemaExtractor)
                    viewSchemaExtractor = new extractor.ViewSchemaExtractor();

                return viewSchemaExtractor;
            }
        }

        public static ISchemaExtractor FunctionSchemaExtractor
        {
            get
            {
                if (null == functionSchemaExtractor)
                    functionSchemaExtractor = new extractor.FunctionSchemaExtractor();

                return functionSchemaExtractor;
            }
        }

        public static ISchemaExtractor StoredProcedureSchemaExtractor
        {
            get
            {
                if (null == storedProcedureSchemaExtractor)
                    storedProcedureSchemaExtractor = new extractor.StoredProcedureSchemaExtractor();

                return storedProcedureSchemaExtractor;
            }
        }

        public static ISchemaExtractor TriggerSchemaExtractor
        {
            get
            {
                if (null == triggerSchemaExtractor)
                    triggerSchemaExtractor = new extractor.TriggerSchemaExtractor();

                return triggerSchemaExtractor;
            }
        }

        public static ISchemaExtractor TableSchemaExtractor
        {
            get
            {
                if (null == tableSchemaExtractor)
                    tableSchemaExtractor = new extractor.TableSchemaExtractor();

                return tableSchemaExtractor;
            }
        }

        private static ISchemaExtractor genericSchemaExtractor;
        private static ISchemaExtractor viewSchemaExtractor;
        private static ISchemaExtractor functionSchemaExtractor;
        private static ISchemaExtractor storedProcedureSchemaExtractor;
        private static ISchemaExtractor triggerSchemaExtractor;
        private static ISchemaExtractor tableSchemaExtractor;

        private string outputDirectory;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\StoredProcedureSchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    public class StoredProcedureSchemaExtractor : SchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.DriAll = true;
            so.IncludeIfNotExists = false;

            return so;
        }

        public override void ExtractSchema(Server server, Urn urn, string target)
        {
            StoredProcedure sproc = server.GetSmoObject(urn) as StoredProcedure;

            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                string schema = urn.GetAttribute("Schema");
                string name = urn.GetAttribute("Name");

                P_Preamble(writer, schema, name);

                writer.WriteLine();
                writer.WriteLine(NormalizeText(sproc.ScriptHeader(true)));
                writer.WriteLine(NormalizeText(sproc.TextBody));
                writer.WriteLine("GO");
            }
        }

        private void P_Preamble(StreamWriter writer, string schema, string name)
        {
            writer.WriteLine("IF (OBJECT_ID(N'[{0}].[{1}]', 'P') IS NULL)", schema, name);
            writer.WriteLine("BEGIN");
            writer.WriteLine("    EXEC('create procedure [{0}].[{1}] as raiserror(''empty stored procedure!!'', 16, 1) with seterror')", schema, name);
            writer.WriteLine("    IF (@@ERROR = 0)");
            writer.WriteLine("        PRINT 'Successfully created empty stored procedure [{0}].[{1}].'", schema, name);
            writer.WriteLine("    ELSE");
            writer.WriteLine("        PRINT 'Failed to create stored procedure [{0}].[{1}].'", schema, name);
            writer.WriteLine("END");
            writer.WriteLine("GO");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcsv\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\SchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;


using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    public abstract class SchemaExtractor : ISchemaExtractor
    {
        public abstract void ExtractSchema(Server server, Urn urn, string target);

        protected StringCollection Script(IScriptable obj, ScriptingOptions options, int ignoredBeginningLines, int ignoredEndLines)
        {
            StringCollection lines = obj.Script(options);

            while ((ignoredBeginningLines--) > 0)
                lines.RemoveAt(0);

            while ((ignoredEndLines--) > 0)
                lines.RemoveAt(lines.Count - 1);

            return lines;
        }

        protected StringCollection Script(Server server, Urn urn, ScriptingOptions options, int ignoredBeginningLines, int ignoredEndLines)
        {
            IScriptable obj = server.GetSmoObject(urn) as IScriptable;

            if (null == obj)
                throw new ArgumentException("not a valid scriptable smo object", "urn");

            return Script(obj, options, ignoredBeginningLines, ignoredEndLines);
        }

        protected StringCollection Script(Server server, Urn urn, ScriptingOptions options)
        {
            return Script(server, urn, options, 0, 0);
        }

        protected StringCollection NormalizeCollection(IEnumerable<string> strings)
        {
            StringCollection result = new StringCollection();
            bool adding = false;
            int run = 0;

            foreach (string s in strings)
            {
                if (adding)
                {
                    result.Add(s);
                    run = s.Trim().Length > 0 ? 0 : run + 1;
                }
                else if (s.Trim().Length > 0)
                {
                    result.Add(s);
                    adding = true;
                }
            }

            while (run-- > 0)
                result.RemoveAt(result.Count - 1);

            return result;
        }

        protected string NormalizeText(string text)
        {
            while (text.StartsWith("\r\n"))
                text = text.Substring(2);

            while (text.EndsWith("\r\n"))
                text = text.Substring(0, text.Length - 2);

            return text;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\FunctionSchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    public class FunctionSchemaExtractor : SchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.DriAll = true;
            so.IncludeIfNotExists = false;

            return so;
        }

        public override void ExtractSchema(Server server, Urn urn, string target)
        {
            UserDefinedFunction function = server.GetSmoObject(urn) as UserDefinedFunction;

            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                
                string schema = urn.GetAttribute("Schema");
                string name = urn.GetAttribute("Name");

                switch (function.FunctionType)
                {
                    case UserDefinedFunctionType.Inline:
                        IF_Preamble(writer, schema, name); 
                        break;
                    case UserDefinedFunctionType.Table:
                    case UserDefinedFunctionType.Unknown:
                        Console.WriteLine("WARNING: {0} unexpected function type {1}, treating a scalar.", function.Name, function.FunctionType);
                        goto default;
                    default:
                        FN_Preamble(writer, schema, name); 
                        break;
                }

                writer.WriteLine();
                writer.WriteLine(NormalizeText(function.ScriptHeader(true)));
                writer.WriteLine(NormalizeText(function.TextBody));
                writer.WriteLine("GO");
            }
        }

        private void FN_Preamble(StreamWriter writer, string schema, string name)
        {
            writer.WriteLine("IF (OBJECT_ID(N'[{0}].[{1}]', 'FN') IS NULL)", schema, name);
            writer.WriteLine("BEGIN");
            writer.WriteLine("   EXEC('CREATE FUNCTION [{0}].[{1}]() RETURNS INT AS BEGIN RETURN NULL END')", schema, name);
            writer.WriteLine("END");
            writer.WriteLine("GO");
        }

        private void IF_Preamble(StreamWriter writer, string schema, string name)
        {
            writer.WriteLine("IF (OBJECT_ID(N'[{0}].[{1}]', 'IF') IS NULL)", schema, name);
            writer.WriteLine("BEGIN");
            writer.WriteLine("   EXEC('CREATE FUNCTION [{0}].[{1}]() RETURNS TABLE RETURN ( SELECT NULL as vc_column )')", schema, name);
            writer.WriteLine("END");
            writer.WriteLine("GO");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\console\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\console\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\TriggerSchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    public class TriggerSchemaExtractor : SchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.DriAll = true;
            so.IncludeIfNotExists = false;

            return so;
        }

        public override void ExtractSchema(Server server, Urn urn, string target)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                Trigger trigger = (Trigger)server.GetSmoObject(urn);
                Table table = (Table)trigger.Parent;
                string schema = table.Schema;
                string name = urn.GetAttribute("Name");

                TR_Preamble(writer, schema, name, string.Format("[{0}].[{1}]", table.Schema, table.Name));

                writer.WriteLine();
                writer.WriteLine(NormalizeText(trigger.ScriptHeader(true)));
                writer.WriteLine(NormalizeText(trigger.TextBody));
                writer.WriteLine("GO");
            }
        }

        private void TR_Preamble(StreamWriter writer, string schema, string name, string table)
        {
            writer.WriteLine("IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[{0}].[{1}]'))", schema, name);
            writer.WriteLine("BEGIN");
            writer.WriteLine("   EXEC('CREATE TRIGGER [{0}].[{1}] on {2} after insert AS SELECT NULL')", schema, name, table);
            writer.WriteLine("END");
            writer.WriteLine("GO");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\ViewSchemaExtractor.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    public class ViewSchemaExtractor : SchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.DriAll = true;
            so.IncludeIfNotExists = false;

            return so;
        }

        public override void ExtractSchema(Server server, Urn urn, string target)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                View view = (View)server.GetSmoObject(urn);
                string schema = view.Schema;
                string name = view.Name;

                V_Preamble(writer, schema, name);

                writer.WriteLine();
                writer.WriteLine(NormalizeText(view.ScriptHeader(true)));
                writer.WriteLine(NormalizeText(view.TextBody));
                writer.WriteLine("GO");
            }
        }

        private void V_Preamble(StreamWriter writer, string schema, string name)
        {
            writer.WriteLine("IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[{0}].[{1}]'))", schema, name);
            writer.WriteLine("BEGIN");
            writer.WriteLine("   EXEC('CREATE VIEW [{0}].[{1}] AS SELECT NULL as vc_null')", schema, name);
            writer.WriteLine("END");
            writer.WriteLine("GO");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\console\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcrawler\schema\extractor\TableSchemaExtractor.cs ===
﻿using System;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.SqlServer.Management.Smo;

using Urn = Microsoft.SqlServer.Management.Sdk.Sfc.Urn;

namespace xonline.tools.sqlcrawler.schema.extractor
{
    class TableSchemaExtractor : SchemaExtractor
    {
        public static ScriptingOptions GetDefaultOptions()
        {
            var so = new ScriptingOptions();

            so.Triggers = false;
            so.Indexes = true;
            so.FullTextCatalogs = true;
            so.FullTextIndexes = true;
            so.ExtendedProperties = true;
            so.IncludeIfNotExists = true;
            so.DriAll = true;

            return so;
        }

        public override void ExtractSchema(Server server, Urn urn, string target)
        {
            Table table = server.GetSmoObject(urn) as Table;
            
            if (null == table)
                throw new ArgumentException("not a valid scriptable smo object", "urn");

            Directory.CreateDirectory(Path.GetDirectoryName(target));

            using (StreamWriter writer = new StreamWriter(target, false, Encoding.UTF8))
            {
                StringCollection script = Script(table, GetDefaultOptions(), 2, 0);

                writer.WriteLine("SET ANSI_NULLS ON");
                writer.WriteLine("SET QUOTED_IDENTIFIER ON");
                writer.WriteLine();

                foreach (string line in RefineScript(table, script))
                    writer.WriteLine(line);
            }
        }

        protected StringCollection RefineScript(Table obj, StringCollection script)
        {
            StringDictionary lookup = new StringDictionary();
            StringCollection result = new StringCollection();
            StringCollection order = new StringCollection();
            StringCollection alters = new StringCollection();
            StringBuilder table = new StringBuilder();
            string[] lines;
            string leftover = "";
            string full;
            string body;
            int start;
            int end;

            full = NormalizeText(script[0]);

            start = CreateExpression.Match(full).Length;
            end = full.LastIndexOf(')');

            // no match found
            if (start == 0)
            {
                Console.WriteLine("Unable to refine {0}; manually fix column default issues", obj.Name);
                return script;
            }

            body = NormalizeText(full.Substring(start, end - start));

            lines = body.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);

            for (int c = 0; c < lines.Length; c++)
            {
                Match match = LineExpression.Match(lines[c]);

                if (match.Success)
                {
                    lookup.Add(match.Groups[1].Value, lines[c].TrimEnd(' ', '\t'));
                    order.Add(match.Groups[1].Value);
                    continue;
                }

                leftover = lines[c];

                while (++c < lines.Length)
                {
                    leftover += "\r\n" + lines[c];
                }

                leftover += "\r\n";

                break;
            }

            // no match found
            if (lookup.Count != obj.Columns.Count)
            {
                Console.WriteLine("Unable to refine {0}; manually fix column default issues", obj.Name);
                return script;
            }

            for (int c=1; c<script.Count; c++) 
            {
                string line = NormalizeText(script[c]);
                Match match = DefaultExpression.Match(line);
                Match alter = AlterExpression.Match(line);

                if (match.Success)
                {
                    string constraint = match.Groups[1].Value;
                    string column = match.Groups[2].Value;
                    string value = lookup[column];
                    int pos = value.LastIndexOf(',');

                    pos = (pos == -1) ? value.Length : pos;

                    lookup[column] = value.Insert(pos, constraint);
                }
                else if (alter.Success)
                    alters.Add(alter.Value);
                else if (!string.IsNullOrEmpty(line))
                    result.Add(line);
            }

            table.AppendLine(full.Substring(0, start));
            foreach (string column in order)
                table.AppendLine(lookup[column]);
            table.Append(leftover);

            if (alters.Count > 0)
            {
                table.AppendLine(full.Substring(end, full.Length - end - 3));
                foreach (string alter in alters)
                    table.AppendLine(alter);
                table.AppendLine();
                table.AppendLine("END");
            }
            else
                table.AppendLine(full.Substring(end));

            result.Insert(0, table.ToString());

            return result;
        }

        //ALTER TABLE [dbo].[t_countries] ADD  DEFAULT ((0)) FOR [f_allow_paypal]
        private static readonly Regex CreateExpression = new Regex(@"^(.|\n)+CREATE TABLE.*\(");
        private static readonly Regex DefaultExpression = new Regex(@"ALTER TABLE.*ADD\s.*(\sDEFAULT.*)\s+FOR\s+(\[[^\]]*\])");
        private static readonly Regex AlterExpression = new Regex(@"ALTER TABLE(.|\n)+$");
        private static readonly Regex LineExpression = new Regex(@"^\s+(\[[^\]]*\])");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlcsv\sqlcsv.cs ===
using System; 
using System.Collections; 
using System.Data.SqlClient; 
using System.IO;


namespace sqlcsv
{
    internal class Settings
    {
        public string Output;
        public string Query;
        public string DatabaseName;
        public string Server;
        public string Username;
        public string Password;
        public bool Verbose;
        public bool TrustedConnection;

        public bool Parse(string []args)
        {
            bool status = false;

            // Set defaults
            Output = "";
            Verbose = false;
            DatabaseName = "";
            Server = ".";
            TrustedConnection = true;

            for(int i = 0; i < args.Length; ++i)
            { 
                string arg = args[i];

                if(IsSwitch(arg))
                {
                    int left = arg.Length - 1;
                    foreach(char c in arg.Substring(1))
                    {
                        string nextArg = (i < args.Length - 1)  ? args[i + 1] : null;
                        if(!ConsumeSetting(c, left, nextArg))
                        {
                            goto lbDone;
                        }
                        left--;
                    }
                }
            }

            string lastArg = (args.Length > 0) ? args[args.Length-1] : null;
            if(null == lastArg || IsSwitch(lastArg))
            {
                Usage("Last parameter must be a query string");
                goto lbDone;
            }

            Query = lastArg;
            status = true;

lbDone:
            return status;
        }

        private void Usage(string msg)
        {
            if(null != msg || msg.Length > 0)
            {
                Program.Info("> " + msg);
            }

            Program.Info("  sqlcsv [options] <query>");
            Program.Info("  OPTIONS:");
            Program.Info("   -o   Output file to write results");
            Program.Info("   -v   Verbose program information while running");
            Program.Info("   -u   Username to issue query as");
            Program.Info("   -p   Password for user permissions");
            Program.Info("   -d   Initial database/catalog name");
            Program.Info("   -t   Use a trusted connection");
            Program.Info("   -s   Server name to connect to");
        }

        private bool IsSwitch(string v)
        {
            return (v.StartsWith("/") || v.StartsWith("-"));
        }

        private bool ConsumeSetting(char setting, int charsLeft, string nextArg)
        {
            switch(setting)
            {
                case 'v':
                    Verbose = true;
                    Program.Debug("Verbose output enabled");
                    break;
                case 'u':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        Username = nextArg;
                    }
                    else
                    {
                        Usage("Username parameter should be followed by a value");
                    }
                    break;
                case 'p':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        Password = nextArg;
                    }
                    else
                    {
                        Usage("Password parameter should be followed by a value");
                    }
                    break;
                case 'o':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        Output = nextArg;
                    }
                    else
                    {
                        Usage("Output parameter should be followed by a filename");
                    }
                    break;
                case 'd':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        DatabaseName = nextArg;
                    }
                    else
                    {
                        Usage("Database name parameter should be followed by a value");
                    }
                    break;
                case 's':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        Server = nextArg;
                    }
                    else
                    {
                        Usage("Server parameter should be followed by a machine name");
                    }
                    break;
                case 't':
                    if(null != nextArg && !IsSwitch(nextArg))
                    {
                        TrustedConnection = true;
                        Program.Debug("Using trusted connection");
                    }
                    break;
                default:
                    Usage("Unknown option: " + setting);
                    return false;
            }
            return true;
        }

        public string BuildSqlConnectionString()
        {
            System.Data.SqlClient.SqlConnectionStringBuilder builder = new System.Data.SqlClient.SqlConnectionStringBuilder();

            builder.DataSource = Server;
            builder.IntegratedSecurity = TrustedConnection;

            if(DatabaseName.Length > 0)
            {
                builder.InitialCatalog = DatabaseName;
            }

            if(!TrustedConnection && Username.Length > 0)
            {
                builder.UserID = Username;
                builder.Password = Password;
            }

            Program.Debug("Sql Connection string: " + builder.ConnectionString);

            return builder.ConnectionString; 
        }
    }


    public class Program
    {
        private static Settings _settings;

        [STAThread]
        public static void Main(string []args)
        {
            _settings = new Settings();

            if(!_settings.Parse(args))
            {
                goto lbDone;
            }

            SqlConnection conn = null;
            SqlDataReader reader = null;
            SqlCommand command = null;
            TextWriter writer = null;

            try
            {
                Debug("Connecting to server: " + _settings.Server);

                conn = new SqlConnection(_settings.BuildSqlConnectionString());
                conn.StatisticsEnabled = true;
                conn.Open();

                command = new SqlCommand(_settings.Query, conn);

                Debug("Issuing query: " + _settings.Query);
                reader = command.ExecuteReader();

                if(_settings.Output.Length > 0)
                {
                    Debug("Opening output file: " + _settings.Output);
                    writer = File.CreateText(_settings.Output) as TextWriter;
                }
                else
                {
                    Debug("Writing to stdout");
                    writer = System.Console.Out;
                }

                Debug("Writing results");
                WriteHeader(reader, writer);
                while(reader.Read())
                {
                    WriteRow(reader, writer);
                }
            }
            catch(Exception ex)
            {
                Program.Info("Failed to complete query");
                Program.Info("Reason: " + ex.Message);
                Program.Info("Error Type: " + ex.GetType().FullName);
                if(_settings.Verbose)
                {
                    Program.Info("Stack Trace: \r\n" + ex.StackTrace);
                }
            }
            finally
            {
                if(null != writer)
                {
                    writer.Close();
                }

                if(null != reader)
                {
                    reader.Close();
                }

                if(null != command)
                {
                    command.Dispose();
                }

                if(null != conn)
                {
                    conn.Close();
                }
            }

lbDone:
            return;
        }

        public static void Info(string msg)
        {
            Console.WriteLine(msg);
        }

        public static void Debug(string msg)
        {
            if(_settings.Verbose)
            {
                Console.WriteLine("( " + msg + " )");
            }
        }

        private static void WriteHeader(SqlDataReader reader, TextWriter writer)
        {
            int fieldCount = reader.FieldCount;
            for(int i = 0; i < fieldCount; ++i)
            {
                writer.Write(reader.GetName(i));
                if(i < fieldCount - 1)
                {
                    writer.Write(", ");
                }
            }
            writer.Write("\r\n");
        }

        private static void WriteRow(SqlDataReader reader, TextWriter writer)
        {
            int fieldCount = reader.FieldCount;
            for(int i = 0; i < fieldCount; ++i)
            {
                Object sqlValue = reader.GetSqlValue(i);
                string strValue = Convert.ToString(sqlValue);

                writer.Write(strValue);

                if(i < fieldCount - 1)
                {
                    writer.Write(", ");
                }
            }

            writer.Write("\r\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\console\SqlRunnerCmd.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Collections.Specialized;

using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.console
{
	/// <summary>
	/// Provides a command line interface to the core SqlRunner functionality.
	/// </summary>
	class SqlRunnerCmd
	{
        private string sqlServerName = null;
        private string sqlRunnerFilename = null;
        private NameValueCollection overrideVariables = new NameValueCollection();

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
            SqlRunnerCmd theCmd = new SqlRunnerCmd();
            theCmd.ParseCommandLine(args);
            return theCmd.RunIt();
		}

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)", 
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (String.Compare(currentArg, "/s", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    sqlServerName = args[++currentArgIndex];
                }
                else if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    overrideVariables.Set(myMatch.Groups["name"].Value, myMatch.Groups["value"].Value);
                }
                else
                {
                    if (sqlRunnerFilename == null)
                    {
                        sqlRunnerFilename = currentArg;
                    }
                    else
                    {
                        Console.WriteLine();
                        Console.WriteLine("Only one SqlRunner input file can be specified on the command line. Second filename \"" + currentArg + "\" was encountered.");
                        Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                        Environment.Exit(1);
                    }
                }
            }

            if (sqlServerName == null)
            {
                sqlServerName = Environment.MachineName;
            }

            if (sqlRunnerFilename == null)
            {
                Console.WriteLine();
                Console.WriteLine("ERROR: Required input file name not specified.");
                Console.WriteLine("Type \"SqlRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        private void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"SqlRunner /?\" for usage help."); 
                Environment.Exit(1);
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("SqlRunner [/S servername] [VARNAME=VALUE ...] inputfile");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Executes SQL commands as specified by the SqlRunner XML input file.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /S              Connect to the specified SQL Server name to execute");
            Console.WriteLine("                    SQL. If this parameter is not specified, the local");
            Console.WriteLine("                    server's name will be used.");
            Console.WriteLine();
            Console.WriteLine("    VARNAME=VALUE   Specifies a variable name and its associated value");
            Console.WriteLine("                    to use when applying the configuration transform to");
            Console.WriteLine("                    the SqlRunner XML input file. Any number of name/value");
            Console.WriteLine("                    definitions can be specified.");
            Console.WriteLine();
            Console.WriteLine("    inputfile       The filename of the XML input file to use.");
            Console.WriteLine();
            Console.WriteLine("  NOTE:  This tool returns an error level of 0 if all SQL is successfully");
            Console.WriteLine("         executed, or 1 if there are errors in the command line, or 2 if");
            Console.WriteLine("         there were problems processing the input XML or running the SQL it");
            Console.WriteLine("         defines.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    SqlRunner npdb_setup.xml");
            Console.WriteLine(@"    SqlRunner SQLDATAPATH=h:\mssql\data");
            Console.WriteLine(@"              ""SQLLOGPATH=o:\mssql\log files\"" npdb_setup.xml");
            Console.WriteLine();
 
        }

        /// <summary>
        /// Creates a SqlRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            Console.WriteLine();
            Console.WriteLine("SqlRunner started processing '" + sqlRunnerFilename + "' at " + DateTime.Now.ToString());
            Console.WriteLine();

            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(sqlRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                transform.OverrideVariableCollection.Add(overrideVariables);
                transform.TransformDocument(xmlDoc);

                SqlRunnerStep runner = new SqlRunnerStep(xmlDoc.DocumentElement, sqlServerName, Path.GetFullPath(sqlRunnerFilename));
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing SQLRunner. - " + ex.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(ex.ToString());
                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("SqlRunner processing of '" + sqlRunnerFilename + "' completed at " + DateTime.Now.ToString());
            Console.WriteLine();
            return 0;
        }

        /// <summary>
        /// Event handler for SqlRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The SqlRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\AddRoleStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for AddRoleStep.
    /// </summary>
    [StepElement("addRole")]
    public class AddRoleStep : StepContainer
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddRoleStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string RoleName
        {
            get
            {
                string role = BaseXmlElement.GetAttribute("role").Trim();

                if (role.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'role' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return role;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            String sql = String.Format(@"
                if not exists (select * from sys.database_principals where name = N'{0}' and type = N'R')
                    CREATE ROLE {0}", 
                RoleName);

            Root.LogMessage("\nCreating role - " + RoleName);
            DatabaseStep.ExecuteSql(sql);

            // process any child nodes
            base.OnExecute ();
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string roleCheck = RoleName;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public AddRoleStep GetAddRoleAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is AddRoleStep)
                {
                    return (AddRoleStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("Required addRole step not present in the hierarchy above the current step.\r\n Current step = " + startStep.BaseXmlElement.OuterXml);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\AttachDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{

    /// <summary>
    /// Summary description for AttachDatabaseStep.
    /// </summary>
    [StepElement("attachDatabase")]
    public class AttachDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AttachDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        public string DataFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataFilename").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataFilename' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logFilename").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logFilename' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }



        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
	        exec sp_attach_db  @dbname= N'{0}',@filename1=N'{1}\{2}',@filename2=N'{3}\{4}'", 
                DatabaseName,
                DataPath,
                DataFileName,
                DataPath,
                LogFileName);

            Root.LogMessage("\nAttaching database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\AddRoleMemberStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for AddRoleMemberStep.
    /// </summary>
    [StepElement("addRoleMember")]
    public class AddRoleMemberStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddRoleMemberStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public AddRoleStep AddRoleStep
        {
            get {return AddRoleStep.GetAddRoleAncestorOfStep(this);}
        }

        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string UserName
        {
            get
            {
                string user = BaseXmlElement.GetAttribute("user").Trim();
                string userComponent = BaseXmlElement.GetAttribute("userComponent").Trim();
                string userInterface = BaseXmlElement.GetAttribute("userInterface").Trim();
                
                if (user.Length != 0)
                {
                    return user;
                }
                else if (userComponent.Length != 0)
                {
                    string component = userComponent;

                    IComponentInfo componentInfo = Config.GetComponent(component);

                    if ((componentInfo.Username == null) || (componentInfo.Username.Length == 0))
                    {
                        throw new ArgumentException("Username for component " + component.ToString() + " is not defined in the configuration database.", "userComponent");
                    }

                    // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                    // this allows us to use local machine accounts, changing the username to always reference
                    // the local instance of the account.
                    return componentInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);
                }
                else if (userInterface.Length != 0)
                {
                    IInterfaceInfo interfaceInfo = null;
                    try
                    {
                        interfaceInfo = Config.GetInterface(Environment.MachineName, userInterface);
                    }
                    catch (ApplicationException ex)
                    {
                        // An ApplicationException probably means that the interface doesn't exist on the current server, 
                        // so see if we can find the interface on any server.

                        string[] serverList = Config.GetServerListByInterface(userInterface);
                        if (serverList.Length == 0)
                        {
                            throw new ApplicationException("Couldn't find any servers exposing interface " + userInterface, ex);
                        }
 
                        interfaceInfo = Config.GetInterface(serverList[0], userInterface);
                    }

                    if ((interfaceInfo.Username == null) || (interfaceInfo.Username.Length == 0))
                    {
                        throw new ArgumentException("Username for interface " + userInterface + " is not defined in the configuration database.", "userInterface");
                    }

                    // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                    // this allows us to use local machine accounts, changing the username to always reference
                    // the local instance of the account.

                    return interfaceInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);
                }
                else
                {
                    throw new ArgumentException("One of the attributes 'user', 'userComponent', or 'userInterface is required for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding user " + UserName + " to role " + AddRoleStep.RoleName);

            String sql = String.Format(@"
                EXEC sp_grantlogin N'{0}'

                if not exists (select sl.loginname from master..syslogins sl join sysusers su on sl.sid = su.sid where sl.loginname=N'{0}')
                begin
                    EXEC sp_grantdbaccess N'{0}'
                end
                
                EXEC sp_addrolemember N'{1}', N'{0}'
                ", 
                UserName,
                AddRoleStep.RoleName);

            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // make sure we have a valid parent
            AddRoleStep roleStep = AddRoleStep;

            // Make sure the user name has been specified
            string userName = UserName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\AddLinkedServerStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    
    /// <summary>
    /// Summary description for AddLinkedServerStep.
    /// </summary>
    [StepElement("addLinkedServer")]
    public class AddLinkedServerStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public AddLinkedServerStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string LinkedServer
        {
            get
            {
                string linkedServer = BaseXmlElement.GetAttribute("linkedServer").Trim();

                if (linkedServer.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'linkedServer' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return linkedServer;
            }
        }

        public string ServerName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("interface").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'interface' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                IInterfaceInfo interfaceInfo = null;
                try
                {
                    interfaceInfo = Config.GetSingleInterface(attribValue);
                }
                catch (ApplicationException ex)
                {
                    // An ApplicationException probably means that the interface doesn't exist on the current server, 
                    throw new ApplicationException("Couldn't find the interface " + attribValue + " for this envirnoment.\r\n", ex);
                }

                return interfaceInfo.ServerName;
            }
        }

        public string DBName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("interface").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'interface' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                IInterfaceInfo interfaceInfo = null;
                try
                {
                    interfaceInfo = Config.GetSingleInterface(attribValue);
                }
                catch (ApplicationException ex)
                {
                    // An ApplicationException probably means that the interface doesn't exist on the current server, 
                    throw new ApplicationException("Couldn't find the interface " + attribValue + " for this envirnoment.\r\n", ex);
                }

                return interfaceInfo.DBName;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute();

            String sql = String.Format(@"
IF EXISTS (SELECT NULL FROM sys.servers WHERE [name] = N'{0}' AND is_linked = 1)
Begin		EXEC master.sys.sp_dropserver @server = N'{0}'
End
EXEC master.sys.sp_addlinkedserver @server = N'{0}',@srvproduct = N'', @provider = N'SQLOLEDB', @provstr = N'DRIVER={{SQL Server}};SERVER={1}',@catalog=N'{2}'",
                LinkedServer,
                ServerName,
                DBName);

            Root.LogMessage("\nadding linkedserver - " + LinkedServer + " - " + ServerName + " - " + DBName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CLRBaseStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for CLRBaseStep.
	/// </summary>
    public class CLRBaseStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRBaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public CLRStep CLRStep
        {
            get {return CLRStep.GetCLRAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyName
        {
            get {return CLRStep.AssemblyName;}
        }

        /// <summary>
        /// 
        /// </summary>
        public string MethodName
        {
            get
            {
                string method = BaseXmlElement.GetAttribute("method").Trim();

                if (method.Length == 0)
                {
                    return "";
                }

                return method;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\BulkInsertStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for DatabaseStep.
	/// </summary>
    [StepElement("bulkInsert")]
    public class BulkInsertStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public BulkInsertStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        private bool hasWithParameters = false;

        /// <summary>
        /// 
        /// </summary>
		public SqlRunnerStep SqlRunnerStep
		{
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
		}

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public string DataFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("src").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        public string TableName
        {
            get
            {
                string table = BaseXmlElement.GetAttribute("table").Trim();

                if (table.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'table' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return table;
            }
        }

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			base.OnExecute ();

			string src = DataFileName;
            ThrowExceptionIfFileMissing(src);
            ExecuteBulkInsert();
		}

        private void ThrowExceptionIfFileMissing(string src)
        {
            if (!File.Exists(src))
            {
                Root.LogMessage("Specified bulkInsert data file \"" + src + "\" could not be found.");
                throw new FileNotFoundException("Specified bulkInsert data file could not be found.", src);
            }
        }

        private void ExecuteBulkInsert()
        {
            Root.LogMessage("\nBulk inserting file " + DataFileName + " into table " + TableName + ".");

            StringBuilder cmd = new StringBuilder();
            hasWithParameters = false;

            cmd.Append("BULK INSERT [");
            cmd.Append(TableName);
            cmd.Append("] FROM '");
            cmd.Append(DataFileName);
            cmd.Append("'\r\n");

            if (BaseXmlElement.GetAttribute("batchsize").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("BATCHSIZE=");
                cmd.Append(BaseXmlElement.GetAttribute("batchsize"));
            }

            if (BaseXmlElement.GetAttribute("checkConstraints").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("CHECK_CONSTRAINTS");
            }

            if (BaseXmlElement.GetAttribute("codepage").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("CODEPAGE='");
                cmd.Append(BaseXmlElement.GetAttribute("codepage"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("dataFileType").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("DATAFILETYPE='");
                cmd.Append(BaseXmlElement.GetAttribute("dataFileType"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("fieldTerminator").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIELDTERMINATOR='");
                cmd.Append(BaseXmlElement.GetAttribute("fieldTerminator"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("firstRow").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIRSTROW=");
                cmd.Append(BaseXmlElement.GetAttribute("firstRow"));
            }

            if (BaseXmlElement.GetAttribute("fireTriggers").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FIRE_TRIGGERS");
            }

            if (BaseXmlElement.GetAttribute("formatFile").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("FORMATFILE='");
                cmd.Append(BaseXmlElement.GetAttribute("formatFile"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("keepIdentity").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KEEPIDENTITY");
            }

            if (BaseXmlElement.GetAttribute("keepNulls").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KEEPNULLS");
            }

            if (BaseXmlElement.GetAttribute("kilobytesPerBatch").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("KILOBYTES_PER_BATCH=");
                cmd.Append(BaseXmlElement.GetAttribute("kilobytesPerBatch"));
            }

            if (BaseXmlElement.GetAttribute("lastRow").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("LASTROW=");
                cmd.Append(BaseXmlElement.GetAttribute("lastRow"));
            }


            if (BaseXmlElement.GetAttribute("maxErrors").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("MAXERRORS=");
                cmd.Append(BaseXmlElement.GetAttribute("maxErrors"));
            }
            else
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("MAXERRORS=0");
            }

            if (BaseXmlElement.GetAttribute("order").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ORDER=");
                cmd.Append(BaseXmlElement.GetAttribute("order"));
            }

            if (BaseXmlElement.GetAttribute("rowsPerBatch").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ROWS_PER_BATCH=");
                cmd.Append(BaseXmlElement.GetAttribute("rowsPerBatch"));
            }

            if (BaseXmlElement.GetAttribute("rowTerminator").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("ROWTERMINATOR='");
                cmd.Append(BaseXmlElement.GetAttribute("rowTerminator"));
                cmd.Append("'");
            }

            if (BaseXmlElement.GetAttribute("tabLock").Length > 0)
            {
                cmd.Append(WithAttributePrefix);
                cmd.Append("TABLOCK");
            }


            if (hasWithParameters)
            {
                // close the with section
                cmd.Append("\r\n)");
            }

            DatabaseStep.ExecuteSql(cmd.ToString());
        }

        private string WithAttributePrefix
        {
            get
            {
                if (!hasWithParameters)
                {
                    hasWithParameters = true;
                    return "WITH (\r\n\t";
                }

                return ",\r\n\t";
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string src = DataFileName;
            ThrowExceptionIfFileMissing(src);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CLRProcStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for CLRProcStep.
	/// </summary>
    [StepElement("clrProcedure")]
    public class CLRProcStep : CLRBaseStep
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRProcStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public string ProcedureDefinition
        {
            get
            {
                string procedure = BaseXmlElement.GetAttribute("procedure").Trim();

                if (procedure.Length == 0)
                {
                    return "";
                }

                return procedure;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string ProcedureName
        {
            get
            {
                string procedure = ProcedureDefinition;
                int parenIndex = procedure.IndexOf('(');

                if(parenIndex > 0)
                {
                    procedure = procedure.Substring(0, parenIndex);
                }

                return procedure;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        
            //
            // Create the procedure from the assembly
            //
            string sql = String.Format(@"
                DECLARE @vc_sql AS NVARCHAR(MAX)
                IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'P', N'PC'))
                BEGIN
                    SET @vc_sql = 'CREATE PROCEDURE {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END
                ELSE
                BEGIN
                    SET @vc_sql = 'ALTER PROCEDURE {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END",
                ProcedureName, ProcedureDefinition, AssemblyName, MethodName);
        
            Root.LogMessage("\nCreating procedure - " + ProcedureName);
            DatabaseStep.ExecuteSql(sql);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CLRFuncStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for CLRFuncStep.
	/// </summary>
    [StepElement("clrFunction")]
    public class CLRFuncStep : CLRBaseStep
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRFuncStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        public string FunctionDefinition
        {
            get
            {
                string function = BaseXmlElement.GetAttribute("function").Trim();

                if (function.Length == 0)
                {
                    return "";
                }

                return function;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string FunctionName
        {
            get
            {
                string function = FunctionDefinition;
                int parenIndex = function.IndexOf('(');

                if(parenIndex > 0)
                {
                    function = function.Substring(0, parenIndex);
                }

                return function;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();
        
            //
            // Create the function from the assembly
            //
            string sql = String.Format(@"
                DECLARE @vc_sql AS NVARCHAR(MAX)
                IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
                BEGIN
                    SET @vc_sql = 'CREATE FUNCTION {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END
                ELSE
                BEGIN
                    SET @vc_sql = 'ALTER FUNCTION {1} AS EXTERNAL NAME {2}.{3}'
                    EXEC SP_EXECUTESQL @vc_sql
                END",
                FunctionName, FunctionDefinition, AssemblyName, MethodName);
        
            Root.LogMessage("\nCreating function - " + FunctionName);
            DatabaseStep.ExecuteSql(sql);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CLRStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for CLRStep.
	/// </summary>
    [StepElement("clr")]
    public class CLRStep : StepContainer
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public CLRStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public CLRStep GetCLRAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is CLRStep)
                {
                    return (CLRStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No CLRStep present in the hierarchy above the current step.");
        }

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("file").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string AssemblyName
        {
            get
            {
                string assembly = BaseXmlElement.GetAttribute("assembly").Trim();

                if (assembly.Length == 0)
                {
                    return "";
                }

                return assembly;
            }
        }

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
            string assembly = AssemblyFileName;
            ThrowExceptionIfFileMissing(assembly);

            //
            // Create the function from the assembly
            //
            string sql = String.Format(@"
                IF EXISTS (SELECT * FROM sys.assemblies WHERE [name] = N'{0}')
                BEGIN
                    DECLARE @vc_object AS NVARCHAR(255)
                    DECLARE @vc_type AS NVARCHAR(20)
                    DECLARE @vc_sql AS NVARCHAR(MAX)

                    DECLARE CLR_OBJ CURSOR FAST_FORWARD FOR
                        SELECT o.name, o.type FROM sys.objects o INNER JOIN sys.assembly_modules am 
                        ON o.object_id = am.object_id INNER JOIN sys.assemblies a ON a.assembly_id = am.assembly_id
                        WHERE a.[name] = N'{0}'
                    OPEN CLR_OBJ
                    FETCH NEXT FROM CLR_OBJ INTO @vc_object, @vc_type

                    WHILE(@@FETCH_STATUS = 0)
                    BEGIN
                        IF(@vc_type = N'P' OR @vc_type = N'PC')
                        BEGIN
                            SET @vc_sql = 'DROP PROCEDURE ' + @vc_object
                            EXEC SP_EXECUTESQL @vc_sql
                        END
                        ELSE IF(@vc_type = N'FN' OR @vc_type = N'IF' OR @vc_type = N'TF' OR @vc_type = N'FS' OR @vc_type = N'FT')
                        BEGIN
                            SET @vc_sql = 'DROP FUNCTION ' + @vc_object
                            EXEC SP_EXECUTESQL @vc_sql
                        END
                        FETCH NEXT FROM CLR_OBJ INTO @vc_object, @vc_type
                    END

                    DROP ASSEMBLY {0}
                END

                CREATE ASSEMBLY {0} FROM '{1}' WITH PERMISSION_SET = SAFE
                ",
                AssemblyName, AssemblyFileName);
        
            Root.LogMessage("\nCreating assembly - " + AssemblyName);
            DatabaseStep.ExecuteSql(sql);

            base.OnExecute ();
		}

        private void ThrowExceptionIfFileMissing(string assembly)
        {
            if (!File.Exists(assembly))
            {
                Root.LogMessage("Specified assembly \"" + assembly + "\" could not be found.");
                throw new FileNotFoundException("Specified assembly could not be found.", assembly);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string assembly = AssemblyFileName;
            ThrowExceptionIfFileMissing(assembly);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CreateDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for CreateDatabaseStep.
    /// </summary>
    [StepElement("createDatabase")]
    public class CreateDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public CreateDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        public string DataSize
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataSize").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataSize' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string DataGrowth
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataGrowth").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'dataGrowth' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogSize
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logSize").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logSize' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        public string LogGrowth
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logGrowth").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'logGrowth' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the collation for the created database. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;collate&quot; in the source XML.
        /// Defaults to SQL_Latin1_General_CP1_CI_AS.
        /// </remarks>
        public string Collation
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("collate").Trim();

                if (attribValue.Length == 0)
                {
                    return "SQL_Latin1_General_CP1_CI_AS";
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the transaction log file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;logPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqllogroot.
        /// </remarks>
        public string LogPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("logPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqllogroot);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            // Make sure the data and log directories have been created.
            System.IO.Directory.CreateDirectory(DataPath);
            System.IO.Directory.CreateDirectory(LogPath);

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
	        CREATE DATABASE {0} ON
	        (
	            NAME = N'{0}_Data',
                FILENAME = N'{1}\{0}_Data.MDF',
                SIZE = {2},
                FILEGROWTH = {3}
            )
            LOG ON
            (
                NAME = N'{0}_Log',
                FILENAME = N'{4}\{0}_Log.LDF',
                SIZE = {5},
                FILEGROWTH = {6}
            )
            COLLATE {7}", 
                DatabaseName,
                DataPath,
                DataSize,
                DataGrowth,
                LogPath,
                LogSize,
                LogGrowth,
                Collation);

            Root.LogMessage("\nCreating database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string databaseCheck = DatabaseName;
            databaseCheck = DataSize;
            databaseCheck = DataGrowth;
            databaseCheck = LogSize;
            databaseCheck = LogGrowth;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CreateAssemblyStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{

    /// <summary>
    /// Summary description for AttachDatabaseStep.
    /// </summary>
    [StepElement("createAssembly")]
    public class CreateAssemblyStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public CreateAssemblyStep(XmlElement stepElement, StepContainer parent)
            : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string AssemblyName
        {
            get
            {
                string assembly = BaseXmlElement.GetAttribute("name").Trim();

                if (assembly.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'assemblyname' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return assembly;
            }
        }

        public string DataFileName
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("fileName").Trim();

                if (attribValue.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'fileName' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return attribValue;
            }
        }

        /// <summary>
        /// Specifies the path to where the data file will be saved. 
        /// </summary>
        /// <remarks>
        /// Maps to the attribute &quot;dataPath&quot; in the source XML.
        /// Defaults to the value of the config setting setup_sqldbroot.
        /// </remarks>
        public string DataPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("dataPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqldbroot);
                }

                return attribValue;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
            IF NOT EXISTS(SELECT * FROM sys.assemblies WHERE NAME = N'{0}')
	        CREATE ASSEMBLY {0} FROM N'{1}\{2}'",
                AssemblyName,
                DataPath,
                DataFileName);

            Root.LogMessage("\nCreating Assembly - " + AssemblyName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\CreateFTCatalog.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for createFtcatalog.
    /// </summary>
    [StepElement("createFtcatalog")]
    public class CreateFTCatalog : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>       
        public CreateFTCatalog(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
        public string CatalogName
        {
            get
            {
                string name = BaseXmlElement.GetAttribute("name").Trim();

                if (name.Length == 0)
                {
                    return "";
                }

                return name;
            }
        }
        
        // The current thinking is that 1 single path for all free text catalogs is enough
        public string FTPath
        {
            get
            {
                string attribValue = BaseXmlElement.GetAttribute("ftPath").Trim();

                if (attribValue.Length == 0)
                {
                    return Config.GetSetting(Setting.setup_sqlftroot);
                }

                return attribValue;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            // Make sure the FTDirectory directories have been created.
            System.IO.Directory.CreateDirectory(FTPath);

            String sql = String.Format(@"
            IF NOT EXISTS (SELECT null FROM sys.fulltext_catalogs WHERE NAME = N'{0}')
	            CREATE FULLTEXT CATALOG {0} IN PATH N'{1}' WITH ACCENT_SENSITIVITY = OFF", CatalogName, FTPath);

            Root.LogMessage("\nCreating Free Text Catalog - " + CatalogName);
            DatabaseStep.ExecuteSql(sql);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\DropDatabaseStep.cs ===
using System;
using System.Xml;
using System.Text;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("dropDatabase")]
    public class DropDatabaseStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DropDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string DatabaseName
        {
            get
            {
                string database = BaseXmlElement.GetAttribute("database").Trim();

                if (database.Length == 0)
                {
                    throw new ArgumentException("Required attribute 'database' not specified for element <" + BaseXmlElement.LocalName + "> in the following line.\r\n" + BaseXmlElement.OuterXml);
                }

                return database;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            String sql = String.Format(@"
                IF EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N'{0}')
                BEGIN
                    -- kick anyone currently using the database
                    ALTER DATABASE {0} SET OFFLINE WITH ROLLBACK IMMEDIATE 
                
                    -- bring it back online so that the drop statement also deletes any files it uses
                    ALTER DATABASE {0} SET ONLINE, RESTRICTED_USER
                    DROP DATABASE {0}
                END ",
                DatabaseName);

            Root.LogMessage("\nDropping database - " + DatabaseName);
            DatabaseStep.ExecuteSql(sql);
        }

        public override void Validate()
        {
            base.Validate();

            // Make sure the database name has been specified
            string databaseCheck = DatabaseName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\SqlScriptStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("sqlScript")]
    public class SqlScriptStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public SqlScriptStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public SqlRunnerStep SqlRunnerStep
        {
            get 
            {
                if (!(Root is SqlRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be SqlRunnerStep for SqlScriptSetup to function correctly."); 
                }
                return (SqlRunnerStep) Root;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        /// <summary>
        /// 
        /// </summary>
        public string ScriptFileName
        {
            get
            {
                string src = BaseXmlElement.GetAttribute("src").Trim();

                if (src.Length == 0)
                {
                    return "";
                }

                return Path.Combine(SqlRunnerStep.WorkingPath, src);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int Timeout
        {
            get
            {
                int iTimeout;
                string attribValue = BaseXmlElement.GetAttribute("timeout").Trim();

                if (!int.TryParse(attribValue, out iTimeout))
                {
                    iTimeout = 300;
                }
                return iTimeout;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public System.Text.Encoding Encoding
        {
            get
            {
                string name = BaseXmlElement.GetAttribute("encoding").Trim();

                if (name.Length == 0)
                {
                    return Encoding.UTF8;
                }

                return System.Text.Encoding.GetEncoding(name);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            string src = ScriptFileName;
            ThrowExceptionIfFileMissing(src);
            ProcessScript(src);
        }

        private void ThrowExceptionIfFileMissing(string src)
        {
            if (!File.Exists(src))
            {
                string msg;
                if (String.IsNullOrEmpty(src))
                {
                    msg = "Empty src attribute found while processing node: '" + BaseXmlElement.OuterXml + "'";
                }
                else
                {
                    msg = "Specified SQL script \"" + src + "\" could not be found.";
                }
                Root.LogMessage(msg);
                throw new FileNotFoundException(msg, src);
            }
        }

        private void ProcessScript(string filename)
        {
            Root.LogMessage("\nProcessing SQL script at " + filename);

            ArrayList sqlArray = new ArrayList();
            Regex goRegex = new Regex(@"^go($|(\s|--).*)", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);   
            string currentLine = null;
            StringBuilder currentBatch = new StringBuilder(2048);

            StreamReader reader = new StreamReader(filename, this.Encoding, true);

            currentLine = reader.ReadLine();
            while (currentLine != null)
            {
                if (goRegex.IsMatch(currentLine))
                {
                    string sql = currentBatch.ToString().Trim();
                    if (sql.Length!=0) sqlArray.Add(sql);
                    
                    currentBatch.Length = 0;
                }
                else
                {
                    currentBatch.AppendFormat("{0}\r\n", currentLine);
                }

                currentLine = reader.ReadLine();
            }

            string sql2 = currentBatch.ToString().Trim();
            if (sql2.Length!=0) sqlArray.Add(sql2);

            try
            {
                DatabaseStep.BatchExecute(sqlArray, Timeout);
            }
            catch (SqlException se)
            {
                throw new Exception("Unable to process file "+filename+": " + se.Message, se);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            string src = ScriptFileName;
            ThrowExceptionIfFileMissing(src);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\SqlCommandStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for DatabaseStep.
	/// </summary>
    [StepElement("sqlCommand")]
    public class SqlCommandStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public SqlCommandStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
		public DatabaseStep DatabaseStep
		{
			get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
		}

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			base.OnExecute ();

			string sql = BaseXmlElement.InnerText;

			if (sql.Length == 0)
			{
				Root.LogMessage("\n\nSkipping current SqlCommandStep. No command is specified.");
				Root.LogMessage(BaseXmlElement.OuterXml);
			}
			else
			{
				Root.LogMessage("\nExecuting SQL command - " + sql);
				DatabaseStep.ExecuteSql(sql);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_4_none_12.4.56.0_none_e91db7b21ac3617d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.manifest
XP_MANIFEST_PATH=manifests\x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.cat
XP_CATALOG_PATH=manifests\x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.cat
XP_PAYLOAD_PATH=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\installer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\SoupStep.cs ===
using System;
using System.Xml;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;
using MS.PtsCommon.Messages;
using MS.Soup.Engine;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Summary description for DatabaseStep.
	/// </summary>
    [StepElement("soup")]
    public class SoupStep : Step
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public SoupStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public DatabaseStep DatabaseStep
        {
            get {return DatabaseStep.GetDatabaseAncestorOfStep(this);}
        }

        public string TargetDatabase
        {
            get {return DatabaseStep.DatabaseName;}
        }

        public string TemplateDatabase
        {
            get
            {
                string dbname = BaseXmlElement.GetAttribute("templateDatabase");

                if (dbname.Length == 0)
                {
                    throw new ArgumentException("templateDatabase must be specified for <" + BaseXmlElement.Name + "> elements.", "templateDatabase");
                }

                return dbname;
            }
        }

        public string SaveScript
        {
            get {return BaseXmlElement.GetAttribute("saveScript");}
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnExecute()
        {
            base.OnExecute ();

            string server = ((SqlRunnerStep) Root).SqlServerName;

            MessagePlatform messagePlatform = new MessagePlatform();

            messagePlatform.Message +=new MS.PtsCommon.Messages.MessageEventHandler(messagePlatform_Message);

            Root.LogMessage("\nConnecting to the databases ...");

            DatabaseAnalyzer analyzer = new DatabaseAnalyzer(
                messagePlatform, 
                server,
                TargetDatabase,
                server, 
                TemplateDatabase);

            /*
             * Don't know the format of the Customization file
            CustomizationInfo customizationInfo = new CustomizationInfo();
            if (parsedArgs.customizationFile != null) 
            {
                if (!File.Exists(parsedArgs.customizationFile)) 
                {
                    OnError("Customization file " + parsedArgs.customizationFile + " does not exist!");
                    return 3;
                }

                Root.LogMessage("Loading the customization info file: " + parsedArgs.customizationFile);
                customizationInfo = new CustomizationInfo(parsedArgs.customizationFile);
            }
            analyzer.Analyze(customizationInfo);
            */

            analyzer.Analyze(new CustomizationInfo());

            if (analyzer.Sequence.Count == 0) 
            {
                Root.LogMessage("No update needed. Database schemas are the same for both databases.");
            }
            else 
            {
                if (SaveScript.Length > 0)
                {
                    analyzer.Sequence.SaveScriptInFile(SaveScript);
                }

                if (analyzer.Sequence.Execute(server + ":" + TargetDatabase, 
                    "Persist Security Info=False;Integrated Security=SSPI;database=" + TargetDatabase + 
                    ";server=" + server + ";Connect Timeout=30")) 
                {

                    Root.LogMessage("==============================");
                    Root.LogMessage("Database UPDATED SUCCESSFULLY! " + analyzer.Sequence.Count + " changes made.");
                    Root.LogMessage("==============================");
                }
                else 
                {
                    Root.LogMessage("==============================");
                    Root.LogMessage("Database UPDATE FAILED!");
                    Root.LogMessage("==============================");

                    throw new Exception("Soup database update failed. See log for more info.");
                }
            }

            return;       // success
        }



        private void messagePlatform_Message(object sender, MS.PtsCommon.Messages.MessageEventArgs e)
        {
            if (e.Level != MessageLevel.Debug)
            {
                Root.LogMessage("(" + e.Level.ToString() + ") " + e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\DatabaseStep.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Data.SqlClient;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
    /// <summary>
    /// Summary description for DatabaseStep.
    /// </summary>
    [StepElement("database")]
    public class DatabaseStep : StepContainer
    {
        public delegate string StringFilter(string original);
        public static StringFilter SqlStatementFilter;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public string DatabaseName
        {
            get 
            {
                return BaseXmlElement.GetAttribute("name");
            }
        }

        public string ServerName
        {
            get
            {
                string serverName = BaseXmlElement.GetAttribute("server").Trim();

                if (serverName.Length == 0)
                {
                    serverName = ((SqlRunnerStep) Root).SqlServerName;
                }

                return serverName;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string ConnectionString
        {
            get
            {
                return string.Format("Data Source={0};Initial Catalog={1};Integrated Security=SSPI;Application Name=SqlRunner;Persist Security Info=false;", ServerName, DatabaseName);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sqlCommand"></param>
        public virtual void ExecuteSql(string sqlCommand)
        {
            ArrayList sqlArray = new ArrayList();
            sqlArray.Add(sqlCommand);
            BatchExecute(sqlArray);
        }

        public void BatchExecute(ArrayList sqlArray, int timeoout)
        {
            SqlConnection myConnection = new SqlConnection(ConnectionString);
            myConnection.InfoMessage +=new SqlInfoMessageEventHandler(myConnection_InfoMessage);
            string currentSql="";

            try
            {
                myConnection.Open();
                
                foreach (string sql in sqlArray)
                {         
                    currentSql = sql;

                    if (SqlStatementFilter!=null)
                    {
                        currentSql = SqlStatementFilter(currentSql);
                    }

                    SqlCommand myCommand = new SqlCommand(currentSql);
                    myCommand.Connection = myConnection;
                    myCommand.CommandTimeout = timeoout;

                    myCommand.ExecuteNonQuery();
                }
            }
            catch (SqlException ex)
            {
                Root.LogMessage("Encountered SQL exception: " + ex.Message);
                Root.LogMessage("Connection string: " + ConnectionString);
                Root.LogMessage("SQL command: " + currentSql);
                throw;
            }
            finally
            {
                if (myConnection != null)
                {
                    myConnection.InfoMessage -= new SqlInfoMessageEventHandler(myConnection_InfoMessage);
                    myConnection.Close();
                }
            }
        }

        public void BatchExecute(ArrayList sqlArray)
        {
            BatchExecute(sqlArray, 300); // 5 minutes
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public DatabaseStep GetDatabaseAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep;

            while (currentStep != null)
            {
                if (currentStep is DatabaseStep)
                {
                    return (DatabaseStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No DatabaseStep present in the hierarchy above the current step.");
        }

        private void myConnection_InfoMessage(object sender, SqlInfoMessageEventArgs e)
        {
            Root.LogMessage(">>> " + e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\SqlRunnerStep.cs ===
using System;
using System.IO;
using System.Xml;

using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.core
{
	/// <summary>
	/// Provides the entry point for the SqlRunner components.
	/// </summary>
	/// <remarks>
	///  This class provides the primary interface to process a SqlRunner XML document. The SqlRunner XML document defines 
	///  a sequential series of steps to execute on a SQL Server, allowing the sequencing and intent of a set of SQL actions
	///  to be seperated from the code that implements how to perform those actions.
    ///</remarks>
	public class SqlRunnerStep : RootStepContainer
	{
        private string sqlServerName = "";
        private string workingPath = "";

        /// <summary>
        /// Initializes a new instance of the SqlRunnerStep class.
        /// </summary>
        /// <param name="stepElement">
        /// The SqlRunner XmlElement that contains the attributes and steps (children elements) that define the actions to take.
        /// </param>
        /// <param name="sqlServerName">
        /// The name of the SQL Server that the steps should be executed against. 
        /// Passing null or an empty string will default this value to the local machine name.
        /// </param>
        /// <param name="workingPath">
        /// The path to the directory that will be used as the base directory for any relative paths to files defined in children steps.
        /// Passing null or an empty string will default this value to the current working directory.
        /// If the path contains a file, the file name will be removed from the path and the directory containing the passed file will be used as the
        /// working path.
        /// </param>
        /// <exception cref="InvalidOperationException">The passed stepElement does not belong to the SqlRunner namespace.</exception>
        /// <exception cref="ArgumentNullException">The passed stepElement was null.</exception>
		public SqlRunnerStep(
			XmlElement stepElement, 
			string sqlServerName,
			string workingPath) : base(stepElement)
		{
			SqlServerName = sqlServerName;
			WorkingPath = workingPath;
		}

        /// <summary>
        /// Gets the name of the XML namespace that all SqlRunner elements must belong to.  
        /// </summary>
        public override string Namespace
        {
            get {return "http://www.xbox.com/sqlrunner.xsd";}
        }

        /// <summary>
        /// Gets or sets the name of the SQL Server that any SqlRunner steps will be executed against.
        /// </summary>
		public string SqlServerName
		{
			get
			{
				return sqlServerName;
			}

			set
			{
				if ((value == null) || (value.Length == 0))
				{
					sqlServerName = System.Environment.MachineName;
				}
				else
				{
					sqlServerName = value;
				}
			}
		}

        /// <summary>
        /// The path to the directory that will be used as the base directory for any relative paths to files defined in children steps.
        /// </summary>
        /// <remarks>
        /// Setting this property to null or an empty string will default this property to the current working directory.
        /// If the path contains a file, the file name will be removed from the path and the directory containing the passed file will be used as the
        /// working path.       
        /// </remarks>
        /// <exception cref="ArgumentException">The WorkingPath was set to a value containing characters that are not valid in a path specification</exception>
        /// <exception cref="FileNotFoundException">An attempt was made to set the WorkingPath to a non-existant directory.</exception>
		public string WorkingPath
		{
			get
			{
				return workingPath;
			}
			set
			{
				string dirPath = "";

				if ((value == null) || (value.Length == 0))
				{
					dirPath = Environment.CurrentDirectory;
				}
				else
				{
					dirPath = value.Trim();
				}

				if (dirPath.IndexOfAny(System.IO.Path.GetInvalidPathChars()) > -1)
				{
					throw new ArgumentException("Path contains characters that are not valid in a path specification", "WorkingPath");
				}

				if (System.IO.Path.HasExtension(dirPath))
				{
					dirPath = System.IO.Path.GetDirectoryName(dirPath);
				}

                dirPath = Path.GetFullPath(dirPath);

				if (!Directory.Exists(dirPath))
				{
					throw new FileNotFoundException("Specified working path '" + dirPath + "' does not point at a directory.", dirPath);
				}

				workingPath = dirPath;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\installer\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\installer\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_4_none_12.4.56.0_none_e91db7b21ac3617d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.manifest
XP_MANIFEST_PATH=manifests\x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.cat
XP_CATALOG_PATH=manifests\x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969.cat
XP_PAYLOAD_PATH=x86__core_4_no-public-key_12.4.56.0_x-ww_c6562969
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\installer\SqlRunnerInstaller.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Configuration.Install;

using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.installer
{
	/// <summary>
	/// Summary description for SqlRunnerInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class SqlRunnerInstaller : System.Configuration.Install.Installer
	{
        private System.Diagnostics.EventLog eventLog;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public SqlRunnerInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            string message = null;
            string sqlRunnerFilename = Context.Parameters["runnerFile"];
            string sqlServerName = Context.Parameters["sqlServer"];
            
            if ((sqlServerName == null) || (sqlServerName.Length == 0))
            {
                sqlServerName = Environment.MachineName;
            }

            try
            {
                if ((sqlRunnerFilename == null) || (sqlRunnerFilename.Length == 0))
                {
                    throw new ArgumentException("The runnerFile parameter must be specified. It should contain the path to the SqlRunner defeinition file.", "runnerFile");
                }

                message = String.Format("SqlRunner started processing '{0}' against SQL Server {1} at {2}", sqlRunnerFilename, sqlServerName, DateTime.Now.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(sqlRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                
                foreach (DictionaryEntry de in Context.Parameters)
                {
                    transform.OverrideVariableCollection.Set(de.Key.ToString(), de.Value.ToString());
                }
                transform.TransformDocument(xmlDoc);

                SqlRunnerStep runner = new SqlRunnerStep(xmlDoc.DocumentElement, sqlServerName, Path.GetFullPath(sqlRunnerFilename));
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Context.LogMessage("ERROR: Exception encountered executing SQLRunner. - " + ex.Message);
                Context.LogMessage(ex.ToString());

                message = string.Format("Exception encountered executing SqlRunner: \r\n{0}", ex.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("SqlRunner processing of '{0}' completed at {1}", sqlRunnerFilename, DateTime.Now.ToString());
            eventLog.WriteEntry(message, EventLogEntryType.Information);
            Context.LogMessage(message);
        }

        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);
        }

        /// <summary>
        /// Event handler for SqlRunnerStep's Message event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The SqlRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.eventLog = new System.Diagnostics.EventLog();
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).BeginInit();
            // 
            // eventLog
            // 
            this.eventLog.Log = "Application";
            this.eventLog.Source = "SqlRunner";
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).EndInit();

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\SqlRunnerSuite.cs ===
using System;
using System.Xml;
using System.Collections;

using ServerTestFramework;
using xonline.common.diagnostics;

using xonline.tools.sqlrunner.core;

namespace xonline.tools.sqlrunner.test
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\NonExecutingDatabaseStep.cs ===
using System;
using System.Xml;

using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.test
{
	/// <summary>
	/// Summary description for NonExecutingDatabaseStep.
	/// </summary>
	public class NonExecutingDatabaseStep : DatabaseStep
	{
		public NonExecutingDatabaseStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

		public override void ExecuteSql(string sqlCommand)
		{
			Root.LogMessage(sqlCommand);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\SqlRunnerStepDVT.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.test 
{
	[TestGroup, DVT]
	public class SqlRunnerStepDVT : TestNode
	{    
    
		[TestCase]
		public void Constructor()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml("<SqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\" />");

			string testPath = Assembly.GetExecutingAssembly().Location;

			Console.WriteLine( "\t\tCheck good values");
			SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", testPath);

			Assert.AreEqual("myServer", myRunner.SqlServerName);
			Assert.AreEqual(Path.GetDirectoryName(testPath), myRunner.WorkingPath);


			Console.WriteLine("\t\tCheck null SqlServerName");
			myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, testPath);

			Assert.AreEqual(Environment.MachineName, myRunner.SqlServerName);

		
			Console.WriteLine("\t\tCheck empty string SqlServerName");
			myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "", testPath);

			Assert.AreEqual(Environment.MachineName, myRunner.SqlServerName);


			Console.WriteLine("\t\tCheck null WorkingPath");
			myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", null);

			Assert.AreEqual(Environment.CurrentDirectory, myRunner.WorkingPath);

			Console.WriteLine("\t\tCheck empty string WorkingPath");
			myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", "");

			Assert.AreEqual(Environment.CurrentDirectory, myRunner.WorkingPath);


			Console.WriteLine("\t\tCheck invalid format WorkingPath");
			try
			{
				myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", @"c:\a:<bad>directory?");
				throw new Exception("Expected ArgumentException not thrown.");
			}
			catch (ArgumentException) {}


			Console.WriteLine("\t\tCheck WorkingPath to nonexistant directory");
			try
			{
				myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", Path.GetDirectoryName(testPath) + @"\abogusdirectory");
				throw new Exception("Expected FileNotFoundException not thrown.");
			}
			catch (FileNotFoundException) {}

		}

        [TestCase]
        public void NotSqlRunnerNamespace()
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml("<SqlRunner />");

            string testPath = Assembly.GetExecutingAssembly().Location;

            try
            {
                SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, "myServer", testPath);
                throw new Exception("Expected InvalidOperationException not thrown.");
            }
            catch (InvalidOperationException) {}
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\SqlCommandStepDVT.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.test 
{
	[TestGroup, DVT]
	public class SqlCommandStepDVT : TestNode
	{    
		private const string validCommandXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlCommand>My sqlCommand test</sqlCommand></sqlDatabase></sqlRunner>";
		private const string noCommandXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlCommand></sqlCommand></sqlDatabase></sqlRunner>";
		private const string noDatabaseXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlCommand>My sqlCommand test</sqlCommand></sqlRunner>";

		[TestCase]
		public void ValidCommand()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml(validCommandXml);

			SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, null);
			myRunner.TypeMap.Clear();
			myRunner.TypeMap.Add("sqlDatabase", Type.GetType("xonline.tools.sqlrunner.test.NonExecutingDatabaseStep"));
			myRunner.TypeMap.Add("sqlCommand", Type.GetType("xonline.tools.sqlrunner.core.SqlCommandStep"));

			InMemoryMessageLog log = new InMemoryMessageLog();
			log.StartListening(myRunner);
			myRunner.Execute();
			log.StopListening();

			Assert.AreEqual(2, log.Messages.Count);
			Assert.AreEqual("My sqlCommand test", log.Messages[1]);
		}

		[TestCase]
		public void EmptyCommand()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml(noCommandXml);

			SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, null);
			myRunner.TypeMap.Clear();
			myRunner.TypeMap.Add("sqlDatabase", Type.GetType("xonline.tools.sqlrunner.test.NonExecutingDatabaseStep"));
			myRunner.TypeMap.Add("sqlCommand", Type.GetType("xonline.tools.sqlrunner.core.SqlCommandStep"));

			InMemoryMessageLog log = new InMemoryMessageLog();
			log.StartListening(myRunner);
			myRunner.Execute();
			log.StopListening();

			Assert.AreEqual(2, log.Messages.Count);
			Assert.AreEqual("Skipping current SqlCommandStep. No command is specified.", log.Messages[0].ToString().Trim());
			Assert.AreEqual("<sqlCommand xmlns=\"http://www.xbox.com/sqlrunner.xsd\"></sqlCommand>", log.Messages[1]);
		}

		[TestCase]
		public void NoDatabaseContainer()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml(noDatabaseXml);

			SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, null);
			myRunner.TypeMap.Clear();
			myRunner.TypeMap.Add("sqlDatabase", Type.GetType("xonline.tools.sqlrunner.test.NonExecutingDatabaseStep"));
			myRunner.TypeMap.Add("sqlCommand", Type.GetType("xonline.tools.sqlrunner.core.SqlCommandStep"));

			try
			{
				myRunner.Execute();
				throw new Exception("Expected InvalidOperationException not thrown");
			}
			catch (InvalidOperationException) {}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.sqlrunner.test_none_12.4.56.0_none_9498cbd63ae2e327
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.sqlrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.cat
XP_PAYLOAD_PATH=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.sqlrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\StringVetter\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stsync\excpt.cs ===
using System;
using xonline.common.service;

namespace xonline.tools.stsync 
{
    class StSyncException : Exception
    {
        public StSyncException(string message) : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.sqlrunner.test_none_12.4.56.0_none_9498cbd63ae2e327
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.sqlrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb.cat
XP_PAYLOAD_PATH=msil_xonline.tools.sqlrunner.test_no-public-key_12.4.56.0_x-ww_a983b2fb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.sqlrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlrunner\test\SqlScriptStepDVT.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.tools.sqlrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.sqlrunner.test 
{
	[TestGroup, DVT]
	public class SqlScriptStepDVT : TestNode
	{    
        private const string oneLineScriptXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlScript src=\"SqlRunnerFiles\\SqlRunner1line.sql\"/></sqlDatabase></sqlRunner>";
        private const string twoLineScriptXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlScript src=\"SqlRunnerFiles\\SqlRunner2lines.sql\"/></sqlDatabase></sqlRunner>";
        private const string goScriptXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlScript src=\"SqlRunnerFiles\\SqlRunnerGoVariants.sql\"/></sqlDatabase></sqlRunner>";
        private const string noCommandXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlScript/></sqlDatabase></sqlRunner>";
		private const string noDatabaseXml = "<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlScript src=\"SqlRunnerFiles\\SqlRunner1line.sql\"></sqlScript></sqlRunner>";

		private SqlRunnerStep InitSqlRunner(string xml)
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml(xml);

			SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location));
			myRunner.TypeMap.Clear();
			myRunner.TypeMap.Add("sqlDatabase", Type.GetType("xonline.tools.sqlrunner.test.NonExecutingDatabaseStep"));
			myRunner.TypeMap.Add("sqlScript", Type.GetType("xonline.tools.sqlrunner.core.SqlScriptStep"));
			
			return myRunner;
		}

        [TestCase]
        public void OneLineSrcFile()
        {
            SqlRunnerStep myRunner = InitSqlRunner(oneLineScriptXml);

            InMemoryMessageLog log = new InMemoryMessageLog();
            log.StartListening(myRunner);
            myRunner.Execute();
            log.StopListening();

            Assert.AreEqual(2, log.Messages.Count);
            Assert.AreEqual("Test for basic loading of script", log.Messages[1]);
        }

        [TestCase]
        public void TwoLineSrcFile()
        {
            SqlRunnerStep myRunner = InitSqlRunner(twoLineScriptXml);

            InMemoryMessageLog log = new InMemoryMessageLog();
            log.StartListening(myRunner);
            myRunner.Execute();
            log.StopListening();

            Assert.AreEqual(2, log.Messages.Count);
            Assert.AreEqual("Test for basic loading of script\r\nwith two lines", log.Messages[1]);
        }

        [TestCase]
        public void GoProcessingSrcFile()
        {
            SqlRunnerStep myRunner = InitSqlRunner(goScriptXml);

            InMemoryMessageLog log = new InMemoryMessageLog();
            log.StartListening(myRunner);
            myRunner.Execute();
            log.StopListening();

            Assert.AreEqual(4, log.Messages.Count);
            Assert.AreEqual("cmd 1", log.Messages[1]);
            Assert.AreEqual("cmd 2\r\n    second line", log.Messages[2]);
            Assert.AreEqual("cmd 3", log.Messages[3]);
        }

        [TestCase]
		public void EmptySrc()
		{
			SqlRunnerStep myRunner = InitSqlRunner(noCommandXml);

            try
            {
                myRunner.Execute();
                throw new Exception("Expected FileNotFoundException was not thrown");
            }
            catch (FileNotFoundException) {}
		}

		[TestCase]
		public void NoDatabaseContainer()
		{
			SqlRunnerStep myRunner = InitSqlRunner(noDatabaseXml);

			try
			{
				myRunner.Execute();
				throw new Exception("Expected InvalidOperationException not thrown");
			}
			catch (InvalidOperationException) {}
		}

        public class NotASqlRunnerRoot : RootStepContainer
        {
            public NotASqlRunnerRoot(XmlElement stepElement) : base(stepElement)
            {
            }

            public override string Namespace
            {
                get {return "http://www.xbox.com/sqlrunner.xsd";}
            }
        }

		[TestCase]
		public void NoSqlRunnerRoot()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml("<sqlRunner xmlns=\"http://www.xbox.com/sqlrunner.xsd\"><sqlDatabase name=\"test\"><sqlScript src=\"SqlRunnerFiles\\SqlRunner1line.sql\"/></sqlDatabase></sqlRunner>");

			RootStepContainer myRunner = new NotASqlRunnerRoot(xmlDoc.DocumentElement);
			myRunner.TypeMap.Clear();
			myRunner.TypeMap.Add("sqlDatabase", Type.GetType("xonline.tools.sqlrunner.test.NonExecutingDatabaseStep"));
			myRunner.TypeMap.Add("sqlScript", Type.GetType("xonline.tools.sqlrunner.core.SqlScriptStep"));

			try
			{
				myRunner.Execute();
				throw new Exception("Expected InvalidOperationException not thrown");
			}
			catch (InvalidOperationException) {}
		}

        [TestCase]
        public void ScriptFileNameProperty()
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(oneLineScriptXml);
            SqlRunnerStep myRunner = new SqlRunnerStep(xmlDoc.DocumentElement, null, Environment.SystemDirectory);
            DatabaseStep myDatabase = new NonExecutingDatabaseStep((XmlElement) xmlDoc.SelectSingleNode("//sequencens:sqlDatabase", myRunner.NamespaceManager), myRunner);

            Console.WriteLine("\t\tCheck with relative src");
            SqlScriptStep myScript = new SqlScriptStep((XmlElement) xmlDoc.SelectSingleNode("//sequencens:sqlScript", myRunner.NamespaceManager), myDatabase);
            Assert.AreEqual(Environment.SystemDirectory + @"\SqlRunnerFiles\SqlRunner1line.sql", myScript.ScriptFileName);

            Console.WriteLine("\t\tCheck with absolute src");
            XmlElement scriptElement = (XmlElement) xmlDoc.SelectSingleNode("//sequencens:sqlScript", myRunner.NamespaceManager);
            scriptElement.SetAttribute("src", @"e:\myScript.sql");
            myScript = new SqlScriptStep(scriptElement, myDatabase);
            Assert.AreEqual(@"e:\myScript.sql", myScript.ScriptFileName);

            Console.WriteLine("\t\tCheck with empty src");
            scriptElement = (XmlElement) xmlDoc.SelectSingleNode("//sequencens:sqlScript", myRunner.NamespaceManager);
            scriptElement.SetAttribute("src", @"");
            myScript = new SqlScriptStep(scriptElement, myDatabase);
            Assert.AreEqual(@"", myScript.ScriptFileName);

            Console.WriteLine("\t\tCheck with missing src");
            scriptElement = (XmlElement) xmlDoc.SelectSingleNode("//sequencens:sqlScript", myRunner.NamespaceManager);
            scriptElement.RemoveAttribute("src");
            myScript = new SqlScriptStep(scriptElement, myDatabase);
            Assert.AreEqual(@"", myScript.ScriptFileName);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stsync\cfg.cs ===
using System;
using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.stsync 
{
    class Configuration
    {
        static public bool Help
        {
            get { return _fHelp; } 
        }
        
        static public bool UndocumentedHelp
        {
            get { return _fUndocumentedHelp; }
        }

        static public uint TitleId
        {
            get { return _uiTitleId; }
        }

        // StatsSqlServers
        // List of stats sql servers
        static public string[] StatsSqlServers
        {
            get { return _statsSqlServers; }
        }

        static public int BundleSize
        {
            get { return _iBundleSize; }
        }

        static public bool NoConfirmationStorage
        {
            get { return _fNoConfirmationStorage; }
        }

        static public int NoConfirmationFileCount
        {
            get { return _iNoConfirmationFileCount; }
        }

        static public bool IgnoreInvalidPath
        {
            get { return _fIgnoreInvalidPath; }
        }

        static public bool ForceStart
        {
            get { return _fForceStart; }
        }

        static public int AttachCache
        {
            get { return _iAttachCache; }
        }

        static public bool DontMarkAttachmentsForDeletion
        {
            get { return _fDontMarkAttachmentsForDeletion; }
        }

        static public int SafetyInterval
        {
            get { return _iSafetyInterval; }
        }

        static public bool Parse(string[] args)
        {
            // Parse arguments
            NamedArgParser parser = new NamedArgParser(
                new string[] {
                    "help",
                    "h",
                    "hx",
                    "?",                                    
                    "titleid",
                    "stats",
                    "bundlesize",
                    "noconfirmationstorage",
                    "ignoreinvalidpath",
                    "forcestart",
                    "attachcache", 
                    "dontmarkattachmentsfordeletion",
                    "safetyinterval"
                    });

            if(!parser.Parse(args))
                return false;
            
            // Process arguments
            if(parser["help"] != null ||
                parser["h"] != null ||
                parser["?"] != null)
            {
                _fHelp = true;
                return false;
            }

            if(parser["hx"] != null)
            {
                _fHelp = true;
                _fUndocumentedHelp = true;
                return false;
            }
            

            if(parser["titleid"] != null)
                _uiTitleId = Convert.ToUInt32(parser["titleid"], 16);

            if(parser["stats"] != null)
                _statsSqlServers = parser["stats"].Split(new char[] {','});
            else
                return false; // Stats is mandatory

            if(parser["bundlesize"] != null)
                _iBundleSize = Convert.ToInt32(parser["bundlesize"]);

            if(parser["noconfirmationstorage"] != null)
            {
                _fNoConfirmationStorage = true;
                _iNoConfirmationFileCount = Convert.ToInt32(parser["noconfirmationstorage"]);
            }

            if(parser["ignoreinvalidpath"] != null)
                _fIgnoreInvalidPath = true;

            if(parser["forcestart"] != null)
                _fForceStart = true;

            if(parser["attachcache"] != null)
                _iAttachCache = Convert.ToInt32(parser["attachcache"]);

            if(parser["dontmarkattachmentsfordeletion"] != null)
                _fDontMarkAttachmentsForDeletion = true;

            if(parser["safetyinterval"] != null)
                _iSafetyInterval = Convert.ToInt32(parser["safetyinterval"]);
            
            return true;
        }

        static protected bool      _fHelp                  = false;
        static protected bool      _fUndocumentedHelp      = false;
        static protected uint      _uiTitleId              = 0;
        static protected string[]  _statsSqlServers        = new string[] {"localhost"};
        static protected int       _iBundleSize            = 1000;
        static protected bool      _fNoConfirmationStorage = false;
        static protected int       _iNoConfirmationFileCount = 0;
        static protected bool      _fIgnoreInvalidPath     = false;
        static protected bool      _fForceStart            = false;
        static protected int       _iAttachCache           = 20;
        static protected bool      _fDontMarkAttachmentsForDeletion = false;
        static protected int       _iSafetyInterval        = 43200;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\StringVetter\CurseFinder.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using xonline.common.user;
using xonline.common.tools.console;


namespace xonline.tools.stringvetter 
{
	/// <summary>
	/// StringVetter
	/// </summary>
	public class StringVetter
	{

        /// <summary>
        /// 
        /// </summary>
        [STAThread]
        static int Main( string[] args )
        {

            string [] rgstrCmdLineTags = 
            {
                "?", 
                "searchstr",
                "exactpath",     
                "subpath"
            };
            bool[] breakArray = new bool[ 100 ];
            NamedArgParser ArgParser = new NamedArgParser( rgstrCmdLineTags );


            // Parse any command line arguments
            if ( !ArgParser.Parse( args ) )
            {
                Usage();
                return -1;
            }

            // Did the user request usage information?            
            if ( 0 == ArgParser.Count ||
                null != ArgParser[ "?" ] )
            {
                Usage();
                return -1;
            }
            // Did the user ask us to do something?
            if( null == ArgParser[ "searchstr" ] ||
                null == ArgParser[ "exactpath" ] ||
                null == ArgParser[ "subpath" ] 
                )
            {
                // user didn't supply a known command
                Usage();
                return -1;
            }            
            string searchItem = ArgParser[ "searchstr" ];
            string subPath = ArgParser[ "subpath" ];
            string exactPath = ArgParser[ "exactpath" ];

            StringCollection subStrings = new StringCollection();
            StringCollection exactStrings = new StringCollection();            

            Console.WriteLine( "" );
            Console.WriteLine( "This tool doesn't exactly duplicate the logic used in service to vette names. " );
            Console.WriteLine( "It will, however, allow a quick comparison of a string to the flattened strings used " );
            Console.WriteLine( " by the service in the vetting of strings." );
            Console.WriteLine( "" );
            Console.WriteLine( "" );

            // flatten the target string
            string flatSearchItem = UnicodeCurseManager.Flatten( searchItem, ref breakArray );
           
            // load sub strings into StringCollection
            if (!LoadStringFile(subPath, ref subStrings))
            {
                Console.WriteLine( "Substrings could not be loaded." );   
                return -1;
            }
            else
            {
                Console.WriteLine( "Substrings were loaded." );   
            }

            // load exact strings into StringCollection
            if (!LoadStringFile(exactPath, ref exactStrings))
            {
                Console.WriteLine( "Exact strings could not be loaded." );   
                return -1;
            }
            else
            {
                Console.WriteLine( "Exact strings were loaded." );   
            }

            // search to find which real string matches the flattened string 
            // call Load
            UnicodeCurseManager myVetter = new UnicodeCurseManager();
            myVetter.Load( subStrings, exactStrings);

            string vetExact = "", vetSub = "";
            if ( myVetter.VetName( searchItem, ref vetExact, ref vetSub ) )
            {
                Console.WriteLine( "VetName found no conflicts." );
                Console.WriteLine( " Exact match: " + vetExact );
                Console.WriteLine( " Sub match: " + vetSub );
            }
            else
            {
                Console.WriteLine( "VetName found conflicts." );
                Console.WriteLine( " Exact match: " + vetExact );
                Console.WriteLine( " Sub match: " + vetSub );
            }

            // check exact strings
            string searchOutput = "";
            Console.WriteLine( "Checking ExactStrings in loop..." );
            CheckExactStrings( searchItem, exactStrings, ref searchOutput );
            Console.WriteLine( "" );
            Console.WriteLine( searchOutput );
            Console.WriteLine( "" );

            // check the substrings
            searchOutput = "";
            Console.WriteLine( "Checking SubStrings..." );
            CheckSubStrings( searchItem, subStrings, ref searchOutput );
            Console.WriteLine( "" );
            Console.WriteLine( searchOutput );
            Console.WriteLine( "" );



            Console.WriteLine( "String vetting is complete." );

            return 1;

        }

        static private bool CheckExactStrings(  string teststring, StringCollection exactStrings, ref String outputString )
        {

            bool srchResult = false;
            int iLoop = 0;
            bool[] tmpbreakArray = new bool[ 100 ];
            // probably won't matter, but it's good to get in the habit of using 
            // stringbuilders for performance
            StringBuilder tempOutput = new StringBuilder( 100 );
            StringBuilder myOutput = new StringBuilder( 100 );

            // check the exact matches
            foreach (string badExact in exactStrings)
            {
                if (teststring == UnicodeCurseManager.Flatten( badExact, ref tmpbreakArray ))
                {
                    myOutput.Append("Matching " + badExact + " = " + UnicodeCurseManager.Flatten( badExact, ref tmpbreakArray ) + "\n");
                    srchResult = true;
                    // Console.WriteLine("Exact match found:  " + badExact);
                }
                iLoop++;
                if (0 == (iLoop % 50))
                {
                    tempOutput.Append( "." );
                }
            } // for each exact
            
            tempOutput.Append( "\n Checked against " + iLoop + " exact strings... " ); 
            tempOutput.Append( "\n Exact matches found:  \n" + myOutput ); 
            outputString = tempOutput.ToString();
            return srchResult;
        }

        static private bool CheckSubStrings( string teststring, StringCollection subStrings, ref String outputString )
        {
            // teststring should be flattened before it's sent in...
            bool srchResult = false;
            int iLoop = 0;
            bool[] tmpbreakArray = new bool[100];
            // probably won't matter, but it's good to get in the habit of using 
            // stringbuilders for performance
            StringBuilder tempOutput = new StringBuilder( 100 );
            StringBuilder myOutput = new StringBuilder( 100 );


            foreach (string badSub in subStrings)
            {
                if (teststring.IndexOf(UnicodeCurseManager.Flatten( badSub , ref tmpbreakArray ), 0, teststring.Length) > 0 )
                {
                    //Console.WriteLine("Substring match found:  " + badSub );
                    myOutput.Append( "Matching " + badSub + " = " + UnicodeCurseManager.Flatten( badSub , ref tmpbreakArray ) + " \n" );
                    srchResult = true;
                }
                iLoop++;
                if (0 == (iLoop % 50))
                {
                    tempOutput.Append( "." );
                }
            } // for each substring

            
            tempOutput.Append( "\n Checked against " + iLoop + " sub strings... " ); 
            tempOutput.Append( "\n Substring matches found:  \n" + myOutput ); 
            outputString = tempOutput.ToString();
            return srchResult;
        }

        static private bool LoadStringFile( string path, ref StringCollection strings )
        {

            string line;

            // open file
            try 
            {
                using ( StreamReader sr = new StreamReader( path ) ) 
                {
                    while ( ( line = sr.ReadLine() ) != null ) 
                    {
                        strings.Add( line );
                    }
                }
            }
            catch (Exception e) 
            {
                Console.WriteLine( "Problem reading file: " );
                Console.WriteLine(e.Message);
                return false;
            }

            return true;

        } // load strings

        private static void Usage()
        {
            Console.WriteLine( "" );
            Console.WriteLine( "Error:  /searchstr: /subpath: and /exactpath: must be specified" );
        }

	} //CurseFinder

} // Xbox.Tools
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stsync\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stsync\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stsync\stsync.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.service;

namespace xonline.tools.stsync 
{
    class StSync
    {
        [STAThread]
        static void Main(string[] args)
        {
            try
            {
                if(!Configuration.Parse(args))
                {
                    if(!Configuration.Help)
                        Console.Write("Invalid parameters!\n");

                    Usage();
                    return;
                }

                Synchronize();
            }
            catch(StSyncException e)
            {
                Console.Write("\n" + e.Message);
                Console.Write("\n");
            }
            catch(Exception e)
            {
                Console.Write("\nAn error occurred. More details as follows:");
                Console.Write("\n"+e.ToString());
                Console.Write("\n");
            }

            Console.Write("\n");
        }

        static void Usage()
        {
            //               1         2         3         4         5         6         7
            //     01234567890123456789012345678901234567890123456789012345678901234567890123456789
            Console.Write(
                "\nUsage:"+
                "\n  stsync /Stats:s1,s2,... [/TitleId:nnn]"+
                "\n         [/NoConfirmationStorage][/ForceStart][/IgnoreInvalidPath]"+
                "\n"+
                "\nParameters:"+
                "\n"+
                "\n  /Stats:s1,s2,...    Specifies the stats SQL servers to sync with storage."+
                "\n  /TitleId:nnn        Forces the synchronization of ONLY title-id nnn ignoring"+
                "\n                      files from other titles. Title ID must be in hexadecimal"+
                "\n                      without the '0x' prefix. The default value 0 forces "+
                "\n                      synchronization of all titles."+
                "\n  /NoConfirmationStorage:nnn Forces the tool to proceed and delete the files "+
                "\n                      from storage without manual confirmation from the user."+
                "\n                      nnn is the maximum number of files the tool is allowed to"+
                "\n                      delete without confirmation."+
                "\n  /ForceStart         Forces initialization even if the tool detects resources"+
                "\n                      from a different tool instance. USE THIS OPTION ONLY IF"+
                "\n                      YOU'RE SURE THERE IS NO OTHER INSTANCE OF THIS TOOL "+
                "\n                      RUNNING SOMEWHERE ELSE."+
                "\n\n");

            if(Configuration.UndocumentedHelp)
            {
                //               1         2         3         4         5         6         7
                //     01234567890123456789012345678901234567890123456789012345678901234567890123456789
                Console.Write(
                    "\nUndocumented commands:"+
                    "\n  /BundleSize:nnn"+
                    "\n  /IgnoreInvalidPath"+
                    "\n  /AttachCache:nnn"+
                    "\n  /DontMarkAttachmentsForDeletion"+
                    "\n  /SafetyInterval:nnn (in seconds)" +
                    "\n\n");
            }
        }

        static void Synchronize()
        {
            try
            {
                // Start synchronization process on all storage servers
                InitSync();

                // Mark attachments for deletion
                if(!Configuration.DontMarkAttachmentsForDeletion)
                    MarkAttachments();
                
                // Sync Stats
                SyncStatServers();

                // Prepare the delete list and get a summary of stuff to be deleted
                int iDeleteStorage;
                int iDeleteExternal;
                PrepareDeleteList(out iDeleteStorage, out iDeleteExternal);

                if(iDeleteStorage != 0)
                {
                    if(!Configuration.NoConfirmationStorage)
                    {
                        Console.Write("Delete "+iDeleteStorage+" file(s) from storage? (Type YES to confirm):");
                        if(Console.ReadLine().ToLower() != "yes")
                        {
                            throw new StSyncException("Aborting.");
                        }
                    }
                    else if(iDeleteStorage > Configuration.NoConfirmationFileCount)
                    {
                        throw new StSyncException("# of files exceed maximum specified.");
                    }

                    DeleteFromStorage();
                }
                else
                {
                    Console.Write("\nNo files to delete on storage.");
                }
            }
            finally
            {
                // Release resources
                ResetStorage();
            }
        }

        static void InitSync()
        {
            WstConnection   sql = null;
            WstCommand      cmd = null;
            SqlParameter    ret = null;
            
            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();

                // Initialize the syncdomain process on each physical partition
                for(int iPart=0; iPart < sql.SqlPartitions.Count; iPart++)
                {
                    Console.Write("\nInitializing storage physical partition " + iPart);
                    
                    cmd = new WstCommand("p_sd_start", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.Partition = iPart;

                    ret = new SqlParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);
                    cmd.Parameters.Add("@i_force", SqlDbType.Int).Value = Configuration.ForceStart ? (int)1 : (int) 0;
                    cmd.ExecuteNonQuery();

                    if((int)ret.Value != 0)
                    {
                        throw new StSyncException(
                            "Auxiliary tables detected on storage sql servers. It could mean that another StSync is currently "+
                            "running on a different place. If that's the case, stop right now! Trying to run StSync "+
                            "from multiple places simultaneously may cause serious problems. However it could also mean that "+
                            "StSync may have failed to clean up the auxiliary tables from the last run. In that case, ONLY IN "+
                            "THAT CASE, use the /ForceStart flag.");
                    }
                }
            }
            finally
            {
                if(sql != null)
                {
                    sql.Close();
                }
            }
        }

        static void MarkAttachments()
        {
            foreach(string statsSql in Configuration.StatsSqlServers)
            {
                MarkAttachmentsOnServer(statsSql);
            }
        }

        static void MarkAttachmentsOnServer(string statsSql)
        {
            SqlConnection sql = null;
            SqlCommand    cmd = null;

            try
            {
                Console.Write("\nMarking attachments for deletion on server " + statsSql);
                
                sql = new SqlConnection("Data Source="+statsSql+";Initial Catalog=xstats;Integrated Security=SSPI");
                sql.Open();

                cmd = new SqlCommand("p_Stats_DeleteNonQualifyingAttachments", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandTimeout = 0;
                cmd.Parameters.Add("@i_target_title_id", SqlDbType.Int).Value = (int) Configuration.TitleId;
                cmd.Parameters.Add("@i_attach_cache", SqlDbType.Int).Value = (int) Configuration.AttachCache;
                cmd.ExecuteNonQuery();
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }
        
        static void SyncStatServers()
        {
            foreach(string statsSql in Configuration.StatsSqlServers)
            {
                SyncStatServer(statsSql);
            }
        }

        static void SyncStatServer(string statsSql)
        {
            SqlConnection sql = null;
            SqlCommand    cmd = null;
            SqlDataReader reader = null;

            try
            {
                Console.Write("\nRetrieving file list from " + statsSql);
                
                sql = new SqlConnection("Data Source="+statsSql+";Initial Catalog=xstats;Integrated Security=SSPI");
                sql.Open();

                cmd = new SqlCommand("p_Stats_ListAttachments", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandTimeout = 0;
                cmd.Parameters.Add("@i_target_title_id", SqlDbType.Int).Value = (int) Configuration.TitleId;
                reader = cmd.ExecuteReader();
                
                // First rowset contains one row with the title id. Second rowset contains the attachments.
                // One set like this for each title.
                uint uiTitleId;
                do
                {
                    if(!reader.Read())
                        break;

                    // Read title id
                    uiTitleId = (uint) reader.GetInt32(0);

                    if(!reader.NextResult())
                        throw new Exception("Expecting files rowset.");

                    // Read file names and send them to storage in bundle sizes
                    ArrayList files = null;

                    bool fEOR = false;
                    while(!fEOR)
                    {
                        for(;;)
                        {
                            if(!reader.Read())
                            {
                                // No more rows
                                fEOR = true;
                                break;
                            }

                            string filename = reader.GetString(0);
                            
                            if(files == null)
                                files = new ArrayList(Configuration.BundleSize);

                            files.Add(filename);

                            if(files.Count >= Configuration.BundleSize)
                                break;
                        }
                    
                        if(files != null)
                        {
                            // Send files to storage
                            SetExternalFiles(uiTitleId, files);
                            Console.Write(".");
                        }

                        files = null;
                    }

                } while(reader.NextResult());
            }
            finally
            {
                if(reader != null)
                    reader.Close();
                if(sql != null)
                    sql.Close();
            }
        }

        class StFilePath
        {
            public int      iDomain     = 0;
            public int      iKeyType    = 0;
            public ulong    ulKey       = 0;
            public string   pathname    = String.Empty;
        };
        
        private static Regex _filePathRegex = new Regex(            
            @"^/(?:\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
            +   @"/stats"                     // storage domain
            +   @"/u:([0-9a-fA-F]+)"          // partition key type : partition key
            +   @"(/[^\p{Cc}]+)$"             // pathname (with leading /)
            , RegexOptions.Compiled | RegexOptions.IgnoreCase);

        static void SetExternalFiles(
            uint uiTitleId,
            ICollection files)
        {
            WstConnection sql = null;

            try
            {
                string szWsApplication = "StoreDb";
                sql = new WstConnection(szWsApplication);
                sql.Open();

                // Split files into groups by physical partition
                ArrayList[] partitions = new ArrayList[sql.SqlPartitions.Count];
                for(int iPart=0; iPart < sql.SqlPartitions.Count; iPart++)
                {
                    partitions[iPart] = new ArrayList(Configuration.BundleSize);
                }
                
                foreach(string file in files)
                {
                    // Parse file URL
                    StFilePath filePath = new StFilePath();
                    Match pathMatch = _filePathRegex.Match(file);

                    if(!pathMatch.Success)
                    {
                        if(Configuration.IgnoreInvalidPath)
                        {
                            Console.Write("\nInvalid path from stats: "+filePath);
                            continue;
                        }
                        else
                        {
                            throw new Exception("Invalid path from stats: "+filePath);
                        }
                    }

                    filePath.iDomain = 0;
                    filePath.iKeyType = 1;
                    filePath.ulKey = Convert.ToUInt64(pathMatch.Groups[1].Value, 16);
                    filePath.pathname = pathMatch.Groups[2].Value;

                    // Which partition?
                    int iLogicalPartition = WSClient.GetHashPartition(filePath.ulKey, szWsApplication);
                    int iPhysicalPartition = sql.GetSqlPartition(iLogicalPartition);

                    // Store file in the right partition
                    partitions[iPhysicalPartition].Add(filePath);
                }
                
                // Now we can batch files to their corresponding partitions in bundles
                for(int iPart=0; iPart < partitions.Length; iPart++)
                {
                    if(partitions[iPart].Count > 0)
                    {
                        SetExternalFilesOnPartition(iPart, uiTitleId, partitions[iPart]);
                    }
                }
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }

        static void SetExternalFilesOnPartition(
            int iPartition,
            uint uiTitleId,
            ICollection files )
        {
            WstConnection sql = null;
            WstCommand    cmd = null;

            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();

                // Files must be bundled together in a big blob
                MemoryStream mem = new MemoryStream(files.Count * 256);
                BinaryWriter writer = new BinaryWriter(mem);
                foreach(StFilePath file in files)
                {
                    writer.Write(IPAddress.HostToNetworkOrder(file.iKeyType));
                    writer.Write(IPAddress.HostToNetworkOrder((long)file.ulKey));
                    writer.Write((byte)file.pathname.Length);
                    writer.Write(Encoding.Unicode.GetBytes(file.pathname));
                }

                // Send it to the storage sql server
                cmd = new WstCommand("p_sd_set_external_files", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandTimeout = 24*60*60*1000;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Partition = iPartition;
                SqlParameter ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int) uiTitleId;
                cmd.Parameters.Add("@bin_pathnames", SqlDbType.Image).Value = mem.ToArray();
                cmd.ExecuteNonQuery();

                if((int)ret.Value != 0)
                {
                    throw new Exception("p_sd_set_external_files returned " + (int)ret.Value);
                }
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }

        static void PrepareDeleteList(
            out int iDeleteStorage,
            out int iDeleteExternal )
        {
            WstConnection sql       = null;
            
            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();
                
                Console.Write("\nPreparing deletion list\n");
                Hashtable summaryStorage = new Hashtable(1000);
                Hashtable summaryExternal = new Hashtable(1000);

                iDeleteStorage = 0;
                iDeleteExternal = 0;
                for(int iPart=0; iPart < sql.SqlPartitions.Count; iPart++)
                {
                    PrepareDeleteListOnPartition(iPart, summaryStorage, summaryExternal, 
                        ref iDeleteStorage, ref iDeleteExternal);
                }

                if(summaryStorage.Count != 0)
                {
                    Console.Write("\nSummary of files to be deleted from storage by title:");
                    Console.Write("\n" + "TitleId".PadLeft(12) + "Files".PadLeft(12));
                    Console.Write("\n" + new string('-', 24));

                    foreach(DictionaryEntry entry in summaryStorage)
                    {
                        Console.Write("\n" + ((uint)entry.Key).ToString("x").PadLeft(12) + 
                            ((int)entry.Value).ToString().PadLeft(12));
                    }
                }

                if(summaryExternal.Count != 0)
                {
                    Console.Write("\nSummary of broken links in stats (this tool currently can't fix them):");
                    Console.Write("\n" + "TitleId".PadLeft(12) + "Files".PadLeft(12));
                    Console.Write("\n" + new string('-', 24));

                    foreach(DictionaryEntry entry in summaryExternal)
                    {
                        Console.Write("\n" + ((uint)entry.Key).ToString("x").PadLeft(12) + 
                            ((int)entry.Value).ToString().PadLeft(12));
                    }
                }
                
                Console.Write("\n\nTotal files to be deleted from storage: "+iDeleteStorage);
                Console.Write("\nTotal broken links at stats: "+iDeleteExternal);
                Console.Write("\n\n");
            }
            finally
            {
                if(sql != null)
                    sql.Close();
            }
        }
        
        static void PrepareDeleteListOnPartition(
            int iPartition,
            Hashtable summaryStorage,
            Hashtable summaryExternal,
            ref int iDeleteStorage,
            ref int iDeleteExternal
            )
        {
            WstConnection sql       = null;
            WstCommand    cmd       = null;
            WstDataReader reader    = null;

            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();
        
                cmd = new WstCommand("p_sd_sync", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandTimeout = 24*60*60*1000;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Partition = iPartition;
                SqlParameter ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);
                cmd.Parameters.Add("@i_target_title_id", SqlDbType.Int).Value = (int) Configuration.TitleId;
                cmd.Parameters.Add("@i_safety_interval", SqlDbType.Int).Value = (int) Configuration.SafetyInterval;
                reader = cmd.ExecuteReader();

                // Stored procedure will return a summary of stuff to be deleted                
                while(reader.Read())
                {
                    int     iSide       = (int) reader.GetByte(0);
                    uint    uiTitleId   = (uint) reader.GetInt32(1);
                    int     iCount      = reader.GetInt32(2);
                    

                    if(iSide == 1)
                    {
                        object prev = summaryStorage[uiTitleId];
                        summaryStorage[uiTitleId] = iCount + (prev != null ? (int) prev : 0);
                        iDeleteStorage += iCount;
                    }
                    else
                    {
                        object prev = summaryExternal[uiTitleId];
                        summaryExternal[uiTitleId] = iCount + (prev != null ? (int) prev : 0);
                        iDeleteExternal += iCount;
                    }
                }
                reader.Close();

                if((int)ret.Value != 0)
                {
                    throw new Exception("p_sd_sync on partition " + iPartition + " returned " + (int)ret.Value);
                }
            }
            finally
            {
                if(reader != null)
                    reader.Close();
                
                if(sql != null)
                    sql.Close();
            }
        }
        
        static void DeleteFromStorage()
        {
            WstConnection   sql = null;
            WstCommand      cmd = null;
            SqlParameter    ret = null;
            
            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();
                
                for(int iPart=0; iPart < sql.SqlPartitions.Count; iPart++)
                {
                    Console.Write("\nDeleting files on storage partition " + iPart);
                    
                    cmd = new WstCommand("p_sd_delete", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandTimeout = 24*60*60*1000;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.Partition = iPart;

                    ret = new SqlParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);
                    cmd.ExecuteNonQuery();

                    if((int)ret.Value != 0)
                    {
                        throw new Exception("p_sd_delete returned " + (int)ret.Value);
                    }
                }
            }
            finally
            {
                if(sql != null)
                {
                    sql.Close();
                }
            }
        }

        static void ResetStorage()
        {
            WstConnection   sql = null;
            WstCommand      cmd = null;
            SqlParameter    ret = null;
            
            try
            {
                sql = new WstConnection("StoreDb");
                sql.Open();

                for(int iPart=0; iPart < sql.SqlPartitions.Count; iPart++)
                {
                    Console.Write("\nResetting storage partition " + iPart);
                    
                    cmd = new WstCommand("p_sd_reset", sql);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandTimeout = 24*60*60*1000;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.Partition = iPart;

                    ret = new SqlParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);
                    cmd.ExecuteNonQuery();

                    if((int)ret.Value != 0)
                    {
                        throw new Exception("p_sd_reset returned " + (int)ret.Value);
                    }
                }
            }
            finally
            {
                if(sql != null)
                {
                    sql.Close();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SubCodeMgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stutil\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stutil\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\stutil\stutil.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using Microsoft.Webstore.WstClient;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.tools.stutilcore;

namespace xonline.tools.stutil
{
    class StUtilMain
    {
        static NamedArgParser _parsedArgs = null;


        static void EnumStorage(string path, uint titleid, uint maxReturnCount, bool verbose)
        {
            uint    actualFileCount = 0;
            uint    requestStart = 0;

            RepEnumerateFiles[] entries = StUtil.GetStorageEntries(
                path,
                titleid,
                requestStart,
                (0 == maxReturnCount) ? uint.MaxValue : requestStart + maxReturnCount - 1,
                ref actualFileCount);

            if (0 < entries.Length)
            {
                // Header
                if (!verbose)
                    Console.WriteLine("Creation Date     \tModified Date     \tSize\tPath");

                foreach (RepEnumerateFiles entry in entries)
                {
                    if (verbose)
                        Console.WriteLine(entry.ToString());
                    else
                    {
                        Console.WriteLine("{0}\t{1}\t{2}\t{3}",
                            DateTime.FromFileTime(entry._creationDate),
                            DateTime.FromFileTime(entry._modifiedDate),
                            entry._blobSizeUncompressed,
                            entry._pathName);
                    }
                }
            }

            Console.WriteLine("Listed {0} of {1} files.", entries.Length, actualFileCount);
        }


        [STAThread]
        static int Main(string[] args)
        {
            _parsedArgs = new NamedArgParser();
            _parsedArgs.Parse(args);

            try
            {
                string action = _parsedArgs["a"];
                if (action == null)
                    action = "";

                switch(action.ToLower())
                {
                    case "write":
                        if (!RequiredParam("p")) { Help(); return -1; }
                        if (!RequiredParam("f")) { Help(); return -1; }

                        StUtil.Write(_parsedArgs.ParseHexULong("u"), _parsedArgs.ParseHexULong("x"), _parsedArgs["p"], _parsedArgs.ParseHexUInt("t"),
                                    (_parsedArgs["y"] != null), _parsedArgs["f"], (_parsedArgs["sign"] != null), (_parsedArgs["package"] != null));
                        break;

                    case "read":
                        if (!RequiredParam("p")) { Help(); return -1; }
                        if (!RequiredParam("f")) { Help(); return -1; }

                        StUtil.Read(_parsedArgs.ParseHexULong("u"), _parsedArgs.ParseHexULong("x"), _parsedArgs["p"], _parsedArgs.ParseHexUInt("t"), _parsedArgs["f"]);
                        break;

                    case "remove":
                        if (!RequiredParam("p")) { Help(); return -1; }

                        StUtil.Remove(_parsedArgs.ParseHexULong("u"), _parsedArgs.ParseHexULong("x"), _parsedArgs["p"], _parsedArgs.ParseHexUInt("t"));
                        break;

                    case "dbwrite":
                        StUtil.DBWrite(_parsedArgs["f"], _parsedArgs["p"]);
                        break;

                    case "dbremove":
                        StUtil.DBRemove(_parsedArgs["p"]);
                        break;

                    case "enum":
                        EnumStorage(
                            _parsedArgs["p"],
                            _parsedArgs.ParseHexUInt("t"),
                            null == _parsedArgs["n"] ? c_maxResultsDefault : _parsedArgs.ParseUInt("n"),
                            _parsedArgs["v"] != null);
                        break;

                    default:
                        Console.WriteLine("Invalid command " + action);
                        Help();
                        return -1;

                } //switch
            }
            catch ( Exception e )
            {
                Console.WriteLine("Unhandled Exception, sort of:");
                Console.WriteLine(e.ToString());
                return -1;
            }

            return 0;
        } //main

        static bool RequiredParam(string param)
        {
            if (_parsedArgs[param] == null)
            {
                Console.WriteLine("Missing required param '" + param + "'!");
                return false;
            }

            return true;
        }

        static void Help()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("  stutil -a:read -f:<file-name> -p:<full-storage-path>");
            Console.WriteLine("  stutil -a:write -f:<file-name> -p:<full-storage-path>");
            Console.WriteLine("  stutil -a:remove -p:<full-storage-path>");
            Console.WriteLine("  stutil -a:enum -p:<storage-path-with-wildcards> [-n:<max-results>] [-v]");
            Console.WriteLine("Where:");
            Console.WriteLine("  -a is the action (required)");
            Console.WriteLine("  -f is the path to a local file");
            Console.WriteLine("  -p is the full storage path (i.e. //title/t:4d530064/9809/bar.dat");
            Console.WriteLine("  -t is the title id, defaults to XENON_DASH (0xFFFE07D1)");
            Console.WriteLine("  -u is the user puid, defaults to 0");
            Console.WriteLine("  -x is the xbox puid, defaults to 0");
            Console.WriteLine("  -n is the max number to enumerate, defaults to {0}, 0 means all", c_maxResultsDefault);
            Console.WriteLine("  -y is to overwrite existing file in storage");
            Console.WriteLine("  -v is to output verbose enumeration information");
            Console.WriteLine("  -sign is to sign the file/package (xbox 1 only)");
            Console.WriteLine("  -package is if the file is a package, defaults to blob");
        }

        const uint c_maxResultsDefault = 50;

    } // class

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\tagfrag\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\tagfrag\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\tagfrag\main.cs ===
using System;
using System.IO;
using System.Globalization;

using xonline.common.config;
using xonline.common.machine;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.server.presence.client;
using xonline.stats.admin;

using Microsoft.Webstore.WstClient;

public class TagFrag
{
    protected static void ShowUsage()
    {
        Console.WriteLine("\r\nTAGFRAG -- Xbox Live Gamertag Recycling utility\r\n");

        Console.WriteLine("Usage: tagfrag.exe <input file> [-r]\r\n");

        Console.WriteLine("<input file> contains line delimited gamertags that should be deleted \r\n");
        Console.WriteLine("           If -r specified, file needs to be in format: gamertag,consoleid");
        Console.WriteLine("           where the consoleid is used to reserve the gamertags that are ");
        Console.WriteLine("           being recycled (IE: 0123456789016).\r\n");
    }

    protected static void ExpireUserStorageItems(ulong userid)
    {
        for (uint iDomain = StorageDomainConstants._MIN; iDomain <= StorageDomainConstants._MAX; iDomain++)
        {
            StorageDomain sd = StorageDomainList.GetDomain(iDomain);

            using (WSClient ws = new WSClient(sd.WebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "p_expire_files_for_user";
                ws.Partition = ws.CalcPartition(userid);
                ws.AddParameter("@bi_user_puid", userid);

                WstDataReader reader = ws.Execute();
                reader.Close();
            }
        }
        
    }

    private static bool ValidateUser(ulong userid)
    {
        int userCnt = 0;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_tagrecycle_validate_user";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@user_puid", userid);

            
            WstDataReader reader = ws.Execute();
            reader.Read();
            try
            {
                userCnt = reader.GetInt32(0);
            }
            catch
            {
                // do nothing.
            }
            
            reader.Close();
        }
        
        if (userCnt == 1)
        {
            return true;
        }

        return false;
    }

    public static void Main(string[] args)
    {
        if (args.Length < 1 || args.Length > 3)
        {
            ShowUsage();
            Console.WriteLine("ERROR: Number of arguments must equal 1 or 2.");
            return;
        }
        
        if (args[0].Equals("/?") ||
            args[0].Equals("-?") ||
            args[0].Equals("/h") ||
            args[0].Equals("-h") ||
            args[0].Equals("/help", StringComparison.OrdinalIgnoreCase) ||
            args[0].Equals("-help", StringComparison.OrdinalIgnoreCase))
        {
            ShowUsage();
            return;
        }

        Console.TreatControlCAsInput = false;
        Console.CancelKeyPress += new ConsoleCancelEventHandler(OnCtrlC);

        DateTime expires = DateTime.UtcNow;
        bool reserved = false;
        bool validate = true;

        if (args.Length > 1 && (String.Compare(args[1], "-r", true) == 0))
        {
            reserved = true;
            expires = new DateTime(2099, 12, 31);
        }

        if (String.Compare(args[args.Length - 1], "-novalidation", true) == 0)
        {
            validate = false;
        }
        
        try 
        {
            using (StreamReader sr = new StreamReader(args[0])) 
            {
                string gamertag;
                string consoleId = String.Empty;
                ulong machinePuid = 0L;
                bool firstLine = true;

                while (_fAlive && ((gamertag = sr.ReadLine()) != null))
                {
                    try
                    {
                        if (gamertag.Trim().Length == 0)
                        {
                            continue;
                        }

                        consoleId = String.Empty;

                        if (reserved)
                        {
                            if (gamertag.IndexOf(',') == -1)
                            {
                                if (firstLine)
                                {
                                    ShowUsage();
                                    Console.WriteLine("\r\nERROR: -r specified and no delimiter found.");
                                    return;
                                }
                            }

                            char[] splitChars = { ',' };
                            string[] parts = gamertag.Split(splitChars);
                            gamertag = parts[0];
                            consoleId = parts[1];
                        }
                        else if (gamertag.IndexOf(',') >= 0)
                        {
                            if (firstLine)
                            {
                                ShowUsage();
                            }

                            Console.WriteLine("\r\nERROR: Field delimiter detected and -r not specified.");

                            if (firstLine)
                            {
                                return;
                            }
                        }
                        
                        Console.Write("\r\nLooking up gamertag: " + gamertag + "... ");
                        Puid userid = XCache.LookupPUID(gamertag);
                        if (userid == 0)
                        {
                            throw new ApplicationException("gamertag not found by XCache.");
                        }

                        Console.WriteLine("SUCCEEDED.  UserId = " + userid);

                        if (consoleId != String.Empty)
                        {
                            try
                            {
                                machinePuid = MachinePuidUtil.GetXbox360MachineIdFromConsoleIdAndXuid(consoleId, userid );
                            }
                            catch (Exception e)
                            {
                                Console.WriteLine(String.Format("FAILED to read MachinePuid from file value: {0}: {1} ", consoleId, e.Message));
                                throw new Exception(String.Format("ERROR: Invalid machine PUID specified. Skipping tag {0}", gamertag));
                            }
                        }

                        if (validate)
                        {
                            
                            Console.Write("\r\nValidating user is eligible for recycling...");
                            
                            if (!ValidateUser(userid))
                            {
                                throw new ApplicationException(String.Format("gamertag: {0} is not valid for recycling", gamertag));
                            }
                            
                            Console.WriteLine("SUCCEEDED.");
                        }
                        Console.Write("Expiring storage items for user " + userid + "... ");
                        ExpireUserStorageItems(userid);
                        Console.WriteLine("SUCCEEDED.");

                        try
                        {
                            Console.Write("Removing leaderboard entries for user " + userid + "... ");
                            DbLeaderboard.RemoveUserFromAllLeaderboards(userid);
                            Console.WriteLine("SUCCEEDED.");
                        }
                        catch (Exception e)
                        {
                            // Xbox 1 is dead, we don't care about any errors for removing this data
                            Console.WriteLine("SKIPPED.  " + e.Message);
                        }

                        Console.Write("Deleting presence records for user " + userid + "... ");
                        PresClient.DeleteUser(userid);
                        Console.WriteLine("SUCCEEDED.");

                        Console.Write("Deleting xcache records for user " + userid + "... ");
                        PresClient.DeleteGamertagFromUODB(userid, machinePuid, expires);
                        Console.WriteLine("SUCCEEDED.");
                        
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("\r\nFAILED: " + e.Message);
                        continue;
                    }

                    firstLine = false;
                }
            }
        }
        catch (Exception e) 
        {
            ShowUsage();
            Console.WriteLine("ERROR: The file <" + args[0] + "> could not be read:");
            Console.WriteLine(e.Message);
        }
    }

    protected static void OnCtrlC(object sender, ConsoleCancelEventArgs args)
    {
        Console.WriteLine("\r\nOperation interrupted!  Aborting list processing...");
        _fAlive = false;
        args.Cancel = true;
    }

    protected static bool _fAlive = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SubCodeMgr\SubCodeMgrExe.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

using xonline.tools.framework;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.tools;
using xonline.common.tools.console;

[assembly: XomAreaDefinition(XomAreaName.subcodemgr)]

namespace xonline.tools.subcodemgr 
{ 
    /// <summary>
	/// Summary description for SubCodeMgrExe.
	/// </summary>
	class SubCodeMgrExe
	{

        private static void Help()
        {
            Console.WriteLine("Subscription Code Manager");
            Console.WriteLine("");
            Console.WriteLine("This tool can deactivate a subcode/voucher/hash and a user associated with ");
            Console.WriteLine(" a subscription code, depending on the switches supplied.");
            Console.WriteLine("");
            Console.WriteLine("  /checkready: determine whether this tool has access to necessary resources, and then exit.");
//            Console.WriteLine("");
            Console.WriteLine("");
            Console.WriteLine("Working Modes: " );
            Console.WriteLine("  /reportonly: no changes will occur; a log will be written of current status ");
            Console.WriteLine("    and the changes which would be performed ");
            Console.WriteLine("");
            Console.WriteLine("  /retireunusedhashes: will only disable unused voucher/hash/subcode " );
            Console.WriteLine("    items from the input file. Any *used* vouchers will not be touched.");
            Console.WriteLine("");
            Console.WriteLine("  /deactivateaccounts: will disable the voucher and remove the " );
            Console.WriteLine("   voucher's value from the gamer's account.");
            Console.WriteLine("   --> Note: This option will can affect the ability of these " );
            Console.WriteLine("             accounts to use the service.");
            Console.WriteLine("");
//            Console.WriteLine("");
            Console.WriteLine("Required Parameters for ALL modes:");
            Console.WriteLine("");
            Console.WriteLine("  /inputfile: is the path to a file containing serial numbers or sub-codes.");
            Console.WriteLine("  /SerialSql: the resolveable name (or IP) of a SQL server with the Serialnumber database.");
            Console.WriteLine("  /SerialDB: the name of the Serialnumber database.");
//             Console.WriteLine("  /groupid: the groupid of serialnumbers in the file, you should generally use 26.");            
            Console.WriteLine("");
            Console.WriteLine("  NOTE: SubCodeMgr will write a logfile in the location specified in the subcodemgr.ini file in the current directory."); 
//            Console.WriteLine("");
//            Console.WriteLine("");
            Console.WriteLine("");
            Console.WriteLine("");
            Console.WriteLine("Usage Examples:");
            Console.WriteLine("To confirm the tool has all resources needed to run:");
            Console.WriteLine("SubCodeMgr.exe /checkready ");
            Console.WriteLine("");
            Console.WriteLine("To run the tool in report only mode for retiring unused hashes:");
            Console.WriteLine("SubCodeMgr.exe /reportonly /retireunusedhashes /SerialSql:tukprinfrdmg001 /SerialDB:SerialDB /inputfile:\"c:\\temp\\unusedvouchers.txt\"  " );
            Console.WriteLine("");
            Console.WriteLine("To run the tool to process returns and/or deactivate accounts:");
            Console.WriteLine("SubCodeMgr.exe             /deactivateaccounts /SerialSql:tukprinfrdmg001 /SerialDB:SerialDB /inputfile:\"c:\\temp\\unusedvouchers.txt\" " );
            // Webstore - doesn't need to get a server, it's already configured on the server
            // SPS - the URL is in UODB
            //task: any other config items needed from the command line???
        }


		/// <summary>
		/// Console Exe code starts here... 
		/// </summary>
		[STAThread]
		public static void Main( string[] args )
		{

            XomLoggingControl.Init();
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "\r\n" );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "====================================================================" );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "SubCodeMgr started at UTC: " + System.DateTime.UtcNow );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "                   in dir: " + System.Environment.CurrentDirectory );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "====================================================================" );
        
            string [] tags = 
            { 
                "reportonly",           // sets tool to readonly mode
                "checkready",           // command
                "retireunusedhashes",   // command
                "deactivateaccounts",   // command
                "inputfile",            // input file
                "serialsql",            // this is the server name which has the serialdb
                "serialdb",             // this is the serial db
                "?" 
            };
            //NOTE: there is no "logfile" parameter since log location is set by .ini file

            NamedArgParser parsedArgs = new NamedArgParser( tags );
            // process command line options
            // if args aren't good, or they wanted help -> show help
            if  ( ( !parsedArgs.Parse( args ) ) || ( parsedArgs.Count == 0 ) || ( parsedArgs["?"] != null ) )
            {
                Console.WriteLine(" ");
                Help();
                Console.WriteLine(" ");
                Console.WriteLine("====> Please supply correct arguments: either extraneous arguments were present or ");
                Console.WriteLine("      required arguments were missing.  Please check the help text.");
                Console.WriteLine(" ");
                return;
            }

            Console.WriteLine( "\n\nCommand Line Arguments were: " );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "\r\nCommand Line Arguments were: " );
            foreach( object thisArg in parsedArgs.Keys )
            {
                //                Console.WriteLine( "length is " + ( (string) parsedArgs[ thisArg.ToString() ] ).Length + " and == is " + ( ( (string) parsedArgs[ thisArg.ToString() ] ) == "" ) +  " another test " + ( ( (string) parsedArgs[ thisArg.ToString() ] ) == " " ) );
                if ( ( (string) parsedArgs[ thisArg.ToString() ] ) == "" ) 
                {
                    //for switches which don't supply an argument
                    Console.WriteLine( "Switch " + ( (string) thisArg ).PadLeft( 30, ' ') + "    Was Present " );
                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "\r\n" + "Switch " + thisArg + "    Was Present " );
                }
                else 
                {
                    Console.WriteLine( "Switch " + ( (string) thisArg ).PadLeft( 30, ' ') + "    had the value |" + ( (string) parsedArgs[ thisArg.ToString() ] ).PadRight( 30, ' ') + "|" );
                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "\r\n" + "Switch " + ( (string) thisArg ).PadLeft( 30, ' ') + "    had the value |" + ( (string) parsedArgs[ thisArg.ToString() ] ).PadRight( 30, ' ') + "|" );
                }
            }

            Console.WriteLine( "\n" );
            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "\r\n" );

            //task: check for correct combinations of arguments here..
            // hashdb or sql is not present or is blank
            // sourcefile not present or blank
            // one, and only one of:
            //retireunusedhashes - 
            //deactivateaccounts - 

            //check ready
            if ( 
                (
                parsedArgs.ContainsKey("retireunusedhashes") &&
                parsedArgs.ContainsKey("deactivateaccounts") &&
                parsedArgs.ContainsKey("checkready")
                ) ||
                ( 
                parsedArgs.ContainsKey("retireunusedhashes") &&
                parsedArgs.ContainsKey("deactivateaccounts") 
                ) ||
                ( 
                parsedArgs.ContainsKey("retireunusedhashes") &&
                parsedArgs.ContainsKey("checkready")
                ) ||
                ( 
                parsedArgs.ContainsKey("deactivateaccounts") &&
                parsedArgs.ContainsKey("checkready")
                )
                )
            {
                Help();
                Console.WriteLine(" ");
                Console.WriteLine("====> The arguments are incorrect.  Please check them and try again.");
                Console.WriteLine(" ");
                return;
            }

            // The string returned by CheckReady is for console output about dependencies.
            string results;
            bool areWeReady = false;
            areWeReady = CheckReady.CheckReadyMain( parsedArgs, out results );

            if ( ! areWeReady )
            {
                string errorExplain = "\r\n";
                errorExplain += "===> SubCodeMgr does not have resources it needs to run.";
                errorExplain += "     See below for more information.";
                errorExplain += "\r\n";
                errorExplain += results;

                Console.WriteLine( errorExplain );
                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, errorExplain );

                return;
            }

            // if all they wanted was CheckReady, then we're done!
            if ( parsedArgs.ContainsKey("checkready") ) 
            {
                return;
            }

            // if we get here, we have already:
            // confirmed reading from the input file 
            // confirmed writing to the output file
            // connection to uodb (for vouchers)
            // connection to SPS

            // if this is true, we only report on what we *would* have done...
            bool reportonly = ( parsedArgs.ContainsKey("reportonly") );

            // if this is true, we don't touch used vouchers or user accounts, just unused vouchers
            bool    hashonly = false;
            if ( ( parsedArgs["retireunusedhashes"] != null ) && ( parsedArgs["deactivateaccounts"] == null ) )
            {
                hashonly = true;
            }

            // Get local vars ready for post-process reporting
            
            // number of elements in Deactivator ProcessingResult + extra buffer 
            //... in case someone adds to the enum without changing this size
            long[] processingResults = new long[ (int) ProcessingResult.MaxValue ];    //task: is there a way to get the length of an enum?
            long[] processingDecisions = new long[ (int) ActionDecision.MaxValue ];
            ProcessingResult result;
            ActionDecision decision;
            ulong       lineNum = 0;

            try 
            {
                // open input file
                Console.WriteLine("\n\rBeginning to process lines from file: " + parsedArgs["inputfile"] );

                // open source file in using so it's sure to get closed... 
                using (StreamReader sourcefile = new StreamReader( parsedArgs["inputfile"] ) ) 
                {
                    string      hashline;
                    byte[]      hashBytes;
                    char[]      delim = new char[] {','};
                    string      serialnum;
                    string      groupid;
                    string[]    splits;

                    // main loop to process lines in the file
                    while ((hashline = sourcefile.ReadLine()) != null) 
                    {
                        Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_LOW, "Read line " + lineNum.ToString() + "  " + hashline );
                        // determine the line type
                        //matches wwwww-wwwww-wwwww-wwwww-wwwww  where w = [0-9][A-Z][a-z]
                        // would have been nice to have the regex working, but it's not been intuitive,
                        // so back to simple patterns that are easy to use... 
//                        Console.WriteLine( "line " + lineNum.ToString() + " L= " + hashline.Length + "  " + hashline );
                        //Console.WriteLine( hashline.Substring( 5, 1 ) + " " + hashline.Substring( 11, 1 ) + " " + hashline.Substring( 17, 1 ) + " " + hashline.Substring( 23, 1 ) );
                        if (
                            ( hashline.Length >= Voucher.SubscriptionCodeWithDashesStringLen ) &&
                            ( hashline.Substring( 5, 1 ) == "-" ) &&
                            ( hashline.Substring( 11, 1 ) == "-" ) &&
                            ( hashline.Substring( 17, 1 ) == "-" ) &&
                            ( hashline.Substring( 23, 1 ) == "-" ) 
                            )
                        {
                            // Console.WriteLine("matches found in input text line: " + splits.Length );
                            //per spec we only take FIRST matching item on the line 

                            //Console.WriteLine("subcode string: " + hashline.Substring(0, 29) );
                            hashBytes = VoucherUtil2.SubcodeStringToHashByte( hashline.Substring(0, Voucher.SubscriptionCodeWithDashesStringLen ) );
                            Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_LOW, "inputline " + lineNum.ToString() + " is a SUBCODE -> " + hashline + " hash is " + VoucherUtil2.HashByteToHexStr( hashBytes ) );
                            try
                            {
                                // process this voucher hash
                                result = DeActivator.ProcessHash( hashBytes, hashonly, reportonly, out decision );
                                // increment the result
                                if ( result < ProcessingResult.MaxValue )
                                {
                                    processingResults[ (int) result ]++;
                                }
                                else
                                {
                                    throw new Exception("Code Bug: Invalid processing result.");
                                }

                                if ( decision < ActionDecision.MaxValue )
                                {
                                    processingDecisions[ (int) decision ]++;
                                }
                                else
                                {
                                    throw new Exception("Code Bug: Process Hash returned an Invalid decision.");
                                }                                    

                            }
                            catch (Exception e)
                            {
                                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_ERROR, "SubCodeMgr: Exception while processing " + VoucherUtil2.HashByteToHexStr( hashBytes ) + ".\r\n Exception: " + e.ToString() );
                                Console.WriteLine( "An exception occurred while processing " + VoucherUtil2.HashByteToHexStr( hashBytes ) + ".\r\n Exception: " + e.ToString() );
                                return;
                            }

                        }
                        else
                        {
                            // we might have a serial number, if it has a comma, and it's long enough to have a groupID and a serial number (at least 2 digits!)
                            if ( ( hashline.Length > 4 ) && ( hashline.IndexOf( "," ) > 0 ) )
                            {
                                // get serial number from string, the first section before the comma is what we want
                                splits = hashline.Split( delim, 2 );
                                // per spec, first two char are group id, remainder is serialnumber
                                serialnum = splits[0].Trim();
                                groupid = serialnum.Substring( 0, 2 );
                                serialnum = serialnum.Substring( 2 );
//                                Console.WriteLine("  groupid:" + groupid + "  serial number: " + serialnum );
                                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_LOW, "inputline " + lineNum.ToString() + " is SERIAL ->  GroupID: " + groupid + " SerialNum: " + serialnum );
                                try
                                {
                                    SerialNumber sn = SerialNumber.Load( System.Convert.ToInt32( groupid ), System.Convert.ToInt32( serialnum ) , "Data Source=" + parsedArgs["serialsql"] + ";Trusted_Connection=Yes;Initial Catalog=" + parsedArgs["serialdb"]  );
                                    result = DeActivator.ProcessHash( sn.HashBytes, hashonly, reportonly, out decision );    
                                    // increment the result
                                    if ( result < ProcessingResult.MaxValue )
                                    {
                                        processingResults[ (int) result ]++;
                                    }
                                    else
                                    {
                                        throw new Exception("Code Bug: Invalid processing result.");
                                    }
                                    if ( decision < ActionDecision.MaxValue )
                                    {
                                        processingDecisions[ (int) decision ]++;
                                    }
                                    else
                                    {
                                        throw new Exception("Code Bug: Process Hash returned an Invalid decision.");
                                    } 

                                }
                                catch ( ArgumentException ae )
                                {
                                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_ERROR, "SubCodeMgr: Invalid Argument Encountered - groupid " + groupid + " serial " + serialnum + ". Exception was: " + ae.Message );
                                    Console.WriteLine( "SubCodeMgr: Invalid Argument Encountered - groupid " + groupid + " serial " + serialnum + ". Exception was: " + ae.Message );
                                }
                                catch ( OverflowException oe )
                                {
                                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_ERROR, "SubCodeMgr: Serial or GroupID were beyond max/min - groupid " + groupid + " serial " + serialnum + ". Exception was: " + oe.Message );
                                    Console.WriteLine( "SubCodeMgr: Serial or GroupID were beyond max/min - groupid " + groupid + " serial " + serialnum + ". Exception was: " + oe.Message );
                                }
                                catch ( SerialNumberNotFoundException snfe )
                                {
                                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_ERROR, "SubCodeMgr: SerialNumber Not Found - groupid " + groupid + " serial " + serialnum + ". Exception was: " + snfe.Message );
                                    Console.WriteLine( "SubCodeMgr: SerialNumber Not Found - groupid " + groupid + " serial " + serialnum + ". Exception was: " + snfe.Message );
                                }

                                catch ( Exception e )
                                {
                                    //*everyone* wants to know the details when this happens... 
                                    string eventText = "SubCodeMgr: Exception while processing " + hashline + ".\r\n Exception: " + e.ToString();
                                    //log an event for the XOC to catch... 
                                  Xom.NtEvent( XEvent.Id.TOOLS_COMM_55, eventText );
                                    Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_ERROR, "SubCodeMgr: Exception while processing " + hashline + ".\r\n Exception: " + e.ToString() );
                                    Console.WriteLine( "An exception occurred while processing " + hashline + ".\r\n Exception: " + e.ToString() );

                                    XomLoggingControl.Close();
                                    return;
                                }
                            }
                            else
                            {
                                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "INVALID data on line " + lineNum + " " + hashline );
                                Console.WriteLine( "INVALID data on line " + lineNum + " " + hashline );

                            } // if serial

                        } // if subcode
                        
                        Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_LOW, "End Processing line " + lineNum.ToString() + "\r\n" );
                        lineNum++;
                        if ( ( lineNum % 50 ) == 0 ) Console.WriteLine( "Just processed line " + lineNum );
                    } // while

                } // using

                string rptOutput = "";
                rptOutput += "\r\n\r\nS u b C o d e  M a n a g e r  P r o c e s s i n g  R e p o r t\r\n\r\n";
                rptOutput += "\r\nAction Decision\r\nThis is what the tool decided should be done:\r\n";
                for ( ActionDecision iLoop = ActionDecision.NoAction ; iLoop < ActionDecision.MaxValue ; iLoop++ )
                {
                    rptOutput += processingDecisions[ (int) iLoop ].ToString().PadRight( 5, ' ' ) + iLoop.ToString() + "\r\n";
                }               
                rptOutput += "\r\n\r\n";
                rptOutput += "\r\nProcessing Results\r\nThis is what the tool actually did. Note that readonly mode will result in NoAction.\r\n";
                for ( ProcessingResult iLoop = ProcessingResult.VoucherDisabled; iLoop < ProcessingResult.MaxValue ; iLoop++ )
                {
                    rptOutput += processingResults[ (int) iLoop ].ToString().PadRight( 5, ' ' ) + iLoop.ToString() + "\r\n";
                }
                rptOutput += "\r\nTotal Lines Processed from file = " + lineNum;
                Console.WriteLine( rptOutput );
                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, rptOutput );

            } //try
            catch ( Exception e ) 
            {
                // Let the user know what went wrong.
                Console.WriteLine( "An issue occurred during processing:\n" );
                Console.WriteLine( e.Message );
                Console.WriteLine( e.StackTrace );
                Xom.Trace(XomAreaName.subcodemgr, LogLevel.L_NORMAL, "An issue occurred during processing:  " + e.Message + "\r\n\r\n" + e.StackTrace  );

            }
            finally
            {
                XomLoggingControl.Close();
            }
            
		} // main    

	} // class SubCodeMgrExe

} // namespace SubCodeMgr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\comberjob.cs ===
// 
// ProvisionSample.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Cron Job interfaces
// Xbox Online Service


using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.cron.plugins;
using xonline.server.cron.plugins.cronlib;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle.cronjobs
{
    /// <summary>
    /// Comber job. Runs the comber component.
    /// </summary>
    public class TRComberJob : TRCronJobBase
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public TRComberJob()
        {
            _component = new Comber();
        }

    } // class 
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\Disassociaterjob.cs ===
// 
// Disassociaterjob.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Cron Job interfaces
// Xbox Online Service


using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.cron.plugins;
using xonline.server.cron.plugins.cronlib;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle.cronjobs
{
    /// <summary>
    /// Disassociater job. Runs the Disassociater component.
    /// </summary>
    public class TRDisassociaterJob : TRCronJobBase
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public TRDisassociaterJob()
        {
            _component = new Disassociater();
            ((Disassociater)_component).DictionaryFiles = Config.GetSetting(Setting.tagrecycle_disassociater_high_value_files);
            ((Disassociater)_component).ReservationConsoleIdString = Config.GetSetting(Setting.tagrecycle_disassociater_reservation_console_id); 

        }

    } // class 
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\emailer1job.cs ===
﻿// 
// emailer1job.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Cron Job interfaces
// Xbox Online Service


using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.cron.plugins;
using xonline.server.cron.plugins.cronlib;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle.cronjobs
{
    /// <summary>
    /// Comber job. Runs the comber component.
    /// </summary>
    public class Emailer1Job : TRCronJobBase
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public Emailer1Job()
        {
            _component = new Emailer1();
            ((Emailer1)_component).TargetFilePath = Config.GetSetting(Setting.tagrecycle_emailer_job_file_path);
            ((Emailer1)_component).TargetFileName = Config.GetSetting(Setting.tagrecycle_emailer1_file_name);
        }

    } // class 
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\emailer2job.cs ===
﻿// 
// emailer2job.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Cron Job interfaces
// Xbox Online Service


using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.cron.plugins;
using xonline.server.cron.plugins.cronlib;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle.cronjobs
{
    /// <summary>
    /// Comber job. Runs the comber component.
    /// </summary>
    public class Emailer2Job : TRCronJobBase
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public Emailer2Job()
        {
            _component = new Emailer2();
            ((Emailer2)_component).TargetFilePath = Config.GetSetting(Setting.tagrecycle_emailer_job_file_path);
            ((Emailer2)_component).TargetFileName = Config.GetSetting(Setting.tagrecycle_emailer2_file_name);
        }

    } // class 
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\Disassociater.cs ===
// 
// Disassociater.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//.

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.machine;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.server.presence.client;
using xonline.stats.admin;

using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle
{
    /// <summary>
    /// Disassociater component the last step in the TagRecycle process
    /// </summary>
    public class Disassociater : TRComponentBase
    {
        /// <summary>
        /// Expiration of a gamertag reservation.
        /// </summary>
        private static DateTime ReservationExpiration = new DateTime(2099, 12, 31);

        /// <summary>
        /// Dictionary to check for high valued tags
        /// </summary>
        private Dictionary<string, string> _highValueDictionary;

        /// <summary>
        /// ConsoleId stored as a ulong.
        /// </summary>
        private ulong _reservationConsoleId;

        /// <summary>
        /// String containing a ; delimited list of files to load into the high value dictionary.
        /// </summary>
        private string _dictionaryFiles;

        /// <summary>
        /// Console ID to reserve high value tags to.
        /// </summary>
        private string _reservationConsoleIdString;

        /// <summary>
        /// String containing a ; delimited list of files to check for high value tags.
        /// </summary>
        public string DictionaryFiles
        {
            get
            {
                return _dictionaryFiles;
            }

            set
            {
                _dictionaryFiles = value;
            }
        }

        /// <summary>
        /// ID of console to reserve high value tags to.
        /// </summary>
        public string ReservationConsoleIdString
        {
            get
            {
                return _reservationConsoleIdString;
            }

            set
            {
                _reservationConsoleIdString = value;
            }
        }

        /// <summary>
        /// Basic constructor
        /// </summary>
        public Disassociater()
        {
            this._targetState = TagRecycleState.Disassociated;
            _highValueDictionary = new Dictionary<string, string>();
            _reservationConsoleIdString = String.Empty;
            _dictionaryFiles = String.Empty;
            _reservationConsoleId = 0L;
        }

        /// <summary>
        /// Populates highValueDictionary
        /// </summary>
        private void PopulateDictionary()
        {
            if ((_highValueDictionary.Keys.Count > 0) || (string.IsNullOrEmpty(_dictionaryFiles)))
                return;

            string[] dictionaryFiles = null;

            if (_dictionaryFiles.IndexOf(';') > 0)
            {
                char[] splitChar = { ';' };
                dictionaryFiles = _dictionaryFiles.Split(splitChar);
            }
            else
            {
                dictionaryFiles = new string[1];
                dictionaryFiles[0] = _dictionaryFiles;
            }

            // load the dictionaries .
            foreach (string fileName in dictionaryFiles)
            {
                if (!File.Exists(fileName))
                {
                    continue;
                }

                using (StreamReader sr = new StreamReader(fileName))
                {
                    string line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        string[] words;
                        if (line.IndexOf(' ') > 0)
                        {
                            char[] splitSpace = { ' ' };
                            words = line.Split(splitSpace);
                        }
                        else
                        {
                            words = new string[1];
                            words[0] = line.Trim();
                        }

                        foreach (string s in words)
                        {
                            try
                            {
                                _highValueDictionary.Add(s, s);
                            }
                            catch (ArgumentException)
                            {
                                // do nothing.
                            }
                        }
                    }
                }
            }
            // Dictionaries loaded.
        }

        /// <summary>
        /// Expires storage items for a given user
        /// </summary>
        /// <param name="userid">userid of user</param>
        protected static void ExpireUserStorageItems(ulong userid)
        {
            for (uint iDomain = StorageDomainConstants._MIN; iDomain <= StorageDomainConstants._MAX; iDomain++)
            {
                StorageDomain sd = StorageDomainList.GetDomain(iDomain);

                using (WSClient ws = new WSClient(sd.WebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "p_expire_files_for_user";
                    ws.Partition = ws.CalcPartition(userid);
                    ws.AddParameter("@bi_user_puid", userid);

                    WstDataReader reader = ws.Execute();
                    reader.Close();
                }
            }
        }

        // For Leet Speak
        public static string TranslateLeetSpeak(string word)
        {
            StringBuilder leetSpeakConverter = new StringBuilder(word);
            leetSpeakConverter.Replace("1V", "n");
            leetSpeakConverter.Replace("IV", "n");
            leetSpeakConverter.Replace("lV", "n");
            leetSpeakConverter.Replace("Ll", "u");
            leetSpeakConverter.Replace("LJ", "u");
            leetSpeakConverter.Replace("LI", "u");
            leetSpeakConverter.Replace('4', 'a');
            leetSpeakConverter.Replace('3', 'e');
            leetSpeakConverter.Replace('1', 'i');
            leetSpeakConverter.Replace('0', 'o');
            leetSpeakConverter.Replace('5', 's');
            leetSpeakConverter.Replace('7', 't');
            leetSpeakConverter.Replace('9', 'g');
            leetSpeakConverter.Replace('6', 'g');
            leetSpeakConverter.Replace("vv", "w");
            leetSpeakConverter.Replace("VV", "W");
            leetSpeakConverter.Replace("\n", "");
            return leetSpeakConverter.ToString().ToLower();
        }

        /// <summary>
        /// Tests a tag against the _highValueDictionary
        /// </summary>
        /// <param name="tag">the tag to test</param>
        /// <returns>flag indicating if this tag is of "high value"</returns>
        private bool IsHighValueTag(string tag)
        {
            bool returnVal = false;

            string[] testVals;

            if (tag.IndexOf(' ') > 0)
            {
                char[] space = { ' ' };
                testVals = tag.Split(space);
            }
            else
            {
                testVals = new string[1];
                testVals[0] = tag;
            }

            foreach (string s in testVals)
            {
                if (_highValueDictionary.ContainsKey(TranslateLeetSpeak(s)))
                {
                    returnVal = true;
                    break;
                }
                else
                {
                    returnVal = false;
                }
            }

            return returnVal;
        }


        /// <summary>
        /// Method for processing results
        /// </summary>
        /// <param name="reader">reader containing the results</param>
        /// <returns>the number of records successfully processed</returns>
        protected override int GetResults(WstDataReader reader)
        {
            int returnVal = 0;
            int userLcid = 0;
            long userPuid = 0;
            string gamertag;
            ulong userXuid = 0;
            
            if (_reservationConsoleId == 0)
            {
                // Will throw if the ID is not valid.
                _reservationConsoleId = MachinePuidUtil.GetXbox360MachineIdFromConsoleId( _reservationConsoleIdString );
            }

            if ((_highValueDictionary.Keys.Count == 0) && (!string.IsNullOrEmpty(_dictionaryFiles)))
            {
                PopulateDictionary();
            }

            if (_highValueDictionary.Keys.Count== 0)
            {
                throw new ArgumentException("High value dictionary not loaded");
            }

            
            while (reader.Read())
            {
                userXuid = (ulong)reader.GetInt64(0);
                userPuid = reader.GetInt64(1);
                userLcid = reader.GetInt32(2);
                gamertag = reader.GetString(3); 

                ExpireUserStorageItems(userXuid);

                try
                {
                    DbLeaderboard.RemoveUserFromAllLeaderboards(userXuid);
                }
                catch (Exception leaderBoardEx)
                {
                    // If it's the exception that the title doesn't exist in NPDB
                    // we're going to swallow it.
                    if (!leaderBoardEx.Message.Contains("Title Does not Exist in NPDB"))
                    {
                        throw;
                    }
                }

                PresClient.DeleteUser(userXuid);

                if (IsHighValueTag(gamertag))
                {
                    PresClient.DeleteGamertagFromUODB(true, userXuid, _reservationConsoleId, Disassociater.ReservationExpiration);
                }
                else
                {
                    PresClient.DeleteGamertagFromUODB(true, userXuid, 0L, Disassociater.ReservationExpiration);
                }

                UpdateState(userXuid, _targetState);
                returnVal++;
            }
            
            return returnVal;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\comber.cs ===
// 
// Comber.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//.

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle
{
    /// <summary>
    /// Comber component the first step in the TagRecycle process
    /// </summary>
    public class Comber : TRComponentBase
    {
        /// <summary>
        /// Basic constructor
        /// </summary>
        public Comber()
        {
            this._targetState = TagRecycleState.New;
        }

        /// <summary>
        /// Method for processing results
        /// </summary>
        /// <param name="reader">reader containing the results</param>
        /// <returns>the number of records successfully processed</returns>
        protected override int GetResults(WstDataReader reader)
        {
            int returnVal = 0;

            if (reader.Read())
            {
                returnVal = reader.GetInt32(0);
            }

            return returnVal;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\emailer2.cs ===
﻿// 
// Emailer2.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//.

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle
{
    /// <summary>
    /// Emailer2 component the third step in the TagRecycle process
    /// </summary>
    public class Emailer2 : Emailer1
    {
        /// <summary>
        /// Basic constructor
        /// </summary>
        public Emailer2()
        {
            this._targetState = TagRecycleState.SecondEmail;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\cronjobs\TrCronJobBase.cs ===
// 
// TrCronJobBase.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Cron Job interfaces
// Xbox Online Service


using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.cron.plugins;
using xonline.server.cron.plugins.cronlib;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


[assembly: XomAreaDefinition(XomAreaName.TagRecycleCronJobs)]

namespace xonline.tagrecycle.cronjobs
{
    /// <summary>
    /// Base job for all jobs
    /// </summary>
    public abstract class TRCronJobBase : ICronJob
    {
        public bool ShareHealthBlock
        {
            get { return true; }
        }

        private static uint DEFAULT_JOB_SIZE = 100;

        /// <summary>
        /// Ref to base 
        /// </summary>
        protected TRComponentBase _component;

        /// <summary>
        /// Base execute method for all jobs
        /// </summary>
        /// <param name="jobID">the job ID</param>
        /// <param name="titleId">the title Id</param>
        /// <param name="args">arguments for this job.</param>
        public void Execute(uint jobID, uint titleId, ref Hashtable args)
        {
            //log this to let the world know we got called
            Xom.Trace(XomAreaName.TagRecycleCronJobs, LogLevel.L_LOW, String.Format("TagRecycle:{0} Starting - jobID: {1} titleID: {2} args: {3}", _component.GetType().Name, jobID, titleId, PluginUtil.HashtableToXml( args )));
            
            int totalProcessed = 0;
            int processed = 0;
            uint batchSize = 0;

            switch (_component.GetType().Name)
            {
                case "Comber":
                    batchSize = Config.GetUIntSetting(Setting.tagrecycle_comber_job_batch_size);
                    break;
                case "Emailer1":
                case "Emailer2":
                    batchSize = Config.GetUIntSetting(Setting.tagrecycle_emailer_job_batch_size);
                    break;
                default:
                    batchSize = TRCronJobBase.DEFAULT_JOB_SIZE;
                    break;
            }

            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int i = 0; i < ws.LogicalPartitions; i++)
                    {
                        ws.ClearParameters();
                        processed = 0;
                        ws.Partition = i;

                        processed = _component.ProcessBatch(ws, batchSize);

                        Xom.Trace(XomAreaName.TagRecycleCronJobs, LogLevel.L_LOW, String.Format("TagRecycle:{0} Processed {1} records in hash bucket {2} using a batchSize of {3}", _component.GetType().Name, processed, i, batchSize));

                        totalProcessed += processed;
                    }
                }
            }
            catch(Exception e)
            {
                string message = String.Format("TagRecycle:{0} Hit an exception while processing '{1}' Exception being handed up to Cron job manager", _component.GetType().Name, e.Message);
                Xom.Trace(XomAreaName.TagRecycleCronJobs, LogLevel.L_HIGH, message);
                Xom.NtDataDynEvent(XEvent.Id.TAG_RECYCLE_JOB_ERROR, e, new byte[1], message);
            }
            finally
            {
                Xom.Trace(XomAreaName.TagRecycleCronJobs, LogLevel.L_LOW, String.Format("TagRecycle:{0} Finished after processing {1} records in all buckets", _component.GetType().Name, totalProcessed));
            }
        } // execute


        public static string ArgsString(Hashtable argsIn)
        {
            StringBuilder sb = new StringBuilder(" Args passed in had " + argsIn.Count + " items and they are: \n", 200);

            foreach (object o in argsIn.Keys)
            {
                sb.Append("  Key " + o + "  Value: " + argsIn[o]);
            }

            return sb.ToString();
        }

    } // class 


    //task: ADD performance counters
    //        [XomPerformanceCounterCategoryAttr( "CRON: Job counters", "Cron service jobs" )]
    //            public class CronJobCounters : XomPerformanceCounterCategory
    //        {
    //            static public CronJobCounters Current = new CronJobCounters();
    //
    //            [XomPerformanceCounterAttr(
    //                 "Job executions/sec", 
    //                 "Job executions per second", 
    //                 PerformanceCounterType.RateOfCountsPerSecond32)]
    //            public PerformanceCounter ExecRate;
    //
    //            [XomPerformanceCounterAttr(
    //                 "Job execution total", 
    //                 "Total number of jobs executed", 
    //                 PerformanceCounterType.NumberOfItems64)]
    //            public PerformanceCounter ExecTotal;
    // 
    //        } 

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\emailer1.cs ===
﻿// 
// Emailer1.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//.

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle
{
    /// <summary>
    /// Emailer component the second step in the TagRecycle process
    /// </summary>
    public class Emailer1 : TRComponentBase
    {
        /// <summary>
        /// location to put the file
        /// </summary>
        protected string _targetFilePath;
        
        /// <summary>
        /// file name to write to.
        /// </summary>
        protected string _targetFileName;

        /// <summary>
        /// Location to place the output file
        /// </summary>
        public string TargetFilePath
        {
            get
            {
                return _targetFilePath;
            }

            set
            {
                _targetFilePath = value;
            }
        }

        /// <summary>
        /// Filename for output file.
        /// </summary>
        public string TargetFileName
        {
            get
            {
                return _targetFileName;
            }

            set
            {
                _targetFileName = value;
            }
        }

        /// <summary>
        /// Basic constructor
        /// </summary>
        public Emailer1()
        {
            this._targetState = TagRecycleState.FirstEmail;
        }

        /// <summary>
        /// Method for processing results
        /// </summary>
        /// <param name="reader">reader containing the results</param>
        /// <returns>the number of records successfully processed</returns>
        protected override int GetResults(WstDataReader reader)
        {
            if (String.IsNullOrEmpty(_targetFilePath) || String.IsNullOrEmpty(_targetFileName))
            {
                throw new ArgumentNullException("Emailer requires TargetFilePath and TargetFileName be specified");
            }

            int returnVal = 0;
            int userLcid = 0;
            long userPuid = 0;
            ulong userXuid = 0;
            

            using (StreamWriter outputFile = new System.IO.StreamWriter(string.Concat(_targetFilePath, _targetFileName), true, Encoding.Unicode))
            {
                while (reader.Read())
                {
                    // TODO: Do we need to handle errors here or let them bubble up?
                    userXuid = (ulong)reader.GetInt64(0);
                    userPuid = reader.GetInt64(1);
                    userLcid = reader.GetInt32(2);
                    outputFile.WriteLine(String.Format("{0},{1}", userPuid, userLcid));
                    UpdateState(userXuid, _targetState);
                    returnVal++;
                }
                
                outputFile.Flush();
                outputFile.Close();
            }

            return returnVal;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\test\TagRecycleTests.cs ===
﻿using System;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;
using xonline.tagrecycle;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle.functionaltests
{
    

    /// <summary>
    /// Functional test cases for the TagRecycle comber component.
    /// </summary>
    [TestGroup]
    public class TagRecycleTests : TestNode
    {
        /// <summary>
        /// Test helper class for storing shared resources / constants / methods etc.
        /// </summary>
        public class TagRecycleTestHelper
        {
            /// <summary>
            /// number of users to use in tests.
            /// </summary>
            public static uint USERCOUNT = 10;

            /// <summary>
            /// Number of users to age during tests.
            /// </summary>
            public static uint AGEUSERCOUNT = 5; // NOTE!: AGEUSERCOUNT must be less than USERCOUNT.

            /// <summary>
            /// Stirng to use for reserving high value tags.
            /// </summary>
            public static string RESERVATIONCONSOLEIDSTRING = "002638776379";

            /// <summary>
            /// List of dictionary files for use in the Disassociater
            /// </summary>
            public static string DICTIONARYFILES = "female-names.txt;male-names.txt;webster-dictionary.txt";

            /// <summary>
            /// File path for emailer tests
            /// </summary>
            public static string EMAILERFILEPATH = @"C:\";

            /// <summary>
            /// File name for emailer 1 file
            /// </summary>
            public static string EMAILER1FILENAME = @"emailer1file.txt";

            /// <summary>
            /// File name for emailer 2 file.
            /// </summary>
            public static string EMAILER2FILENAME = @"emailer2file.txt";

            /// <summary>
            /// Instance for singleton
            /// </summary>
            private static TagRecycleTestHelper _instance;

            /// <summary>
            /// Expected Results for the current step of the tests
            /// </summary>
            private int _expectedResults;

            /// <summary>
            /// the shared user array
            /// </summary>
            private XeUser[] _users;

            /// <summary>
            /// Expected results for the current step of the tests.
            /// </summary>
            public int ExpectedResults
            {
                get
                {
                    return _expectedResults;
                }

                set
                {
                    _expectedResults = value;
                }
            }

            /// <summary>
            /// The shared user array
            /// </summary>
            public XeUser[] Users
            {
                get
                {
                    return _users;
                }
            }

            /// <summary>
            /// Public instance for getting test helper
            /// </summary>
            /// <returns></returns>
            public static TagRecycleTestHelper GetInstance()
            {
                if (_instance == null)
                {
                    _instance = new TagRecycleTestHelper();
                }

                return _instance;
            }

            /// <summary>
            /// Intializes the user array and sets the ExpectedResults to 0.
            /// </summary>
            public void Intialize()
            {
                if (_users[0] != null)
                {
                    CleanUpTestUsers();
                }

                _expectedResults = 0;

                for (int userIdx = 0; userIdx < TagRecycleTestHelper.USERCOUNT; userIdx++)
                {
                    _users[userIdx] = TagRecycleTestHelper.CreateXenonUser();
                }
            }

            /// <summary>
            /// Constructor
            /// </summary>
            private TagRecycleTestHelper()
            {
                _expectedResults = 0;
                _users = new XeUser[TagRecycleTestHelper.USERCOUNT];
            }

#region test support functions

            /// <summary>
            /// Creates a user
            /// </summary>
            /// <returns></returns>
            private static XeUser CreateXenonUser()
            {
                XeUser user = new XeUser(false);
                if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                Global.RO.Info("User 0x{0:x} created.", user.UserPuid);
                return user;
            }

            /// <summary>
            /// Ages the account and sets billing flags to make the user a candidate for recycling.
            /// </summary>
            /// <param name="user"></param>
            public void AgeAccount(int index)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.SetHashVal(_users[index].PassportPuid);
                    string user_update = String.Format("update dbo.t_users set dt_created = '{0}', i_billing_account_status = 1 where bi_user_puid = {1} ", DateTime.UtcNow.AddYears(-1).ToString("d"), _users[index].UserPuid);
                    ws.ExecuteNonQuery(user_update);
                }
            }

            /// <summary>
            /// Set the last login time for the user. This only works for users who were JUST created.
            /// </summary>
            /// <param name="user">user to set login time for.</param>
            /// <param name="daysToAgeLogin">days to age the login. Set to 0 for a login today.</param>
            public void SetLastLogin(int index, int daysToAgeLogin)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.SetHashVal(_users[index].UserPuid);
                    int returned = 0;

                    // User has just been created so he hasn't logged in yet so we need to fake the login.
                    string loginUpdate = String.Format("insert into t_user_per_client_type_data (bi_user_puid, ti_service_type, ti_client_type, dt_first_signin, dt_last_signin, si_hash_bucket, dt_change_datetime, bi_machine_puid) values({0}, 1, 2, DATEADD(dd,{2},GETUTCDATE()), DATEADD(dd,{2},GETUTCDATE()), {1}, DATEADD(dd,{2},GETUTCDATE()), 0 )", _users[index].UserPuid, ws.Partition, daysToAgeLogin);

                    returned = ws.ExecuteNonQuery(loginUpdate);
                    if (returned == 0)
                    {
                        Global.RO.Info(String.Format("Last Login Insert query: {0}", loginUpdate));
                        Global.RO.Info(String.Format("Last Login Insert returned{0}", returned));
                        throw new UnexpectedTestResultException(String.Format("update to t_user_per_client_type_data returned {0}", returned));
                    }
                }
            }

            /// <summary>
            /// Expires a users subscription
            /// </summary>
            /// <param name="user">user to expire</param>
           public void ExpireSubscription(int index, int subscription_status)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.SetHashVal(_users[index].PassportPuid);
                    string fourth_update = String.Format("update t_subscriptions set i_subscription_status_id = {0} where bi_primary_puid = {1} ", subscription_status, _users[index].UserPuid);
                    ws.ExecuteNonQuery(fourth_update);
                }
            }

            /// <summary>
            /// Updates the date stamp on t_users_tagrecycle to make user eligible for the next step in the proces.
            /// </summary>
            /// <param name="index"></param>
            public void ChangeTimeStampForNextStep(int index)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.SetHashVal(_users[index].PassportPuid);
                    string user_update = String.Format("update dbo.t_users_tagRecycle set [dt_last_state_change] = DATEADD(dd,-33, GETUTCDATE()) where bi_puid = {0} ", _users[index].UserPuid);
                    ws.ExecuteNonQuery(user_update);
                }
            }

            /// <summary>
            /// Inserts the ConsoleId for testing
            /// </summary>
            /// <param name="consoleId"></param>
            public static void InsertConsoleIdForDisassociater(string consoleId)
            {
                MachineEditor.CreateOrUseExistingName("XE."+consoleId);
            }

            /// <summary>
            /// Unages the user for clean up.
            /// </summary>
            /// <param name="user"></param>
            public void UnAgeUser(int index)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.SetHashVal(_users[index].PassportPuid);
                    string un_age_update = String.Format("update t_user_per_client_type_data set dt_last_signin = GETUTCDATE(), dt_change_datetime = GETUTCDATE() where bi_user_puid = {0} ", _users[index].UserPuid);
                    ws.ExecuteNonQuery(un_age_update);
                }
            }

            /// <summary>
            /// Clean up all users in this instance.
            /// </summary>
            public void CleanUpTestUsers()
            {
                for (int i=0; i < TagRecycleTestHelper.AGEUSERCOUNT; i++) 
                {
                    UnAgeUser(i);
                }
            }


            /// <summary>
            /// Runs a TagRecycle component against all partitions.
            /// </summary>
            /// <param name="component">the component to run</param>
            /// <returns>the total number of users processed in all buckets</returns>
            public static int RunComponentOnAllBuckets(TRComponentBase component)
            {
                int processed = 0;
                
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int i = 0; i < ws.LogicalPartitions; i++)
                    {
                        ws.ClearParameters();
                        ws.Partition = i;

                        processed += component.ProcessBatch(ws, TagRecycleTestHelper.USERCOUNT);
                    }
                }
                
                return processed;
            }
#endregion
        }

        [TestCase, Owner("DougA"), Description("Testing the TagRecycle Comber component")]
        class ComberTest : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                int subscriptionId = 0;

                TagRecycleTestHelper.GetInstance().Intialize();

                for (int i = 0; i < TagRecycleTestHelper.AGEUSERCOUNT; i++)
                {
                    
                    switch (i)
                    { 
                        case 0:
                            subscriptionId = 2;
                            break;
                        case 2:
                            subscriptionId = 4;
                            break;
                        default:
                            subscriptionId = 3;
                            break;
                    }

                    Global.RO.Info(String.Format("Aging user at index: {0}", i));
                    TagRecycleTestHelper.GetInstance().AgeAccount(i);
                    TagRecycleTestHelper.GetInstance().ExpireSubscription(i, subscriptionId);
                    TagRecycleTestHelper.GetInstance().SetLastLogin(i, -366);
                    TagRecycleTestHelper.GetInstance().ExpectedResults++;
                }

                
                // Let's age one more but give them a recent login to make sure the 
                // the comber isn't returning false positives.
                int index = ((int)TagRecycleTestHelper.AGEUSERCOUNT) + 1;
                Global.RO.Info(String.Format("Aging user at index: {0}", index));
                TagRecycleTestHelper.GetInstance().AgeAccount(index);
                TagRecycleTestHelper.GetInstance().ExpireSubscription(index, 4);
                Global.RO.Info(String.Format("Logging in user at index: {0}", index));
                TagRecycleTestHelper.GetInstance().SetLastLogin(index, 0);
                
                xonline.tagrecycle.Comber comber = new Comber();
                int processed = TagRecycleTestHelper.RunComponentOnAllBuckets(comber);
                
                if (processed != TagRecycleTestHelper.GetInstance().ExpectedResults)
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException(String.Format("ComponentTests culled {0} expected {1}", processed, TagRecycleTestHelper.GetInstance().ExpectedResults));
                }

                Global.RO.Info(String.Format("Successfully culled {0} users", processed));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("DougA"), Description("Testing the First Emailer component")]
        [RunDependency("ComberTest")]
        class Emailer1Tests : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                Global.RO.Info("Advancing the clock on culled users for next test");

                for (int i = 0; i < TagRecycleTestHelper.AGEUSERCOUNT; i++)
                {
                   TagRecycleTestHelper.GetInstance().ChangeTimeStampForNextStep(i);
                }

                // Log one user in so they are no longer a candidate for tag recycle.
                // We only need to do this in one test because the validation logic 
                // is handled by a sproc common to all components that are not the comber.
                TagRecycleTestHelper.GetInstance().UnAgeUser(((int)TagRecycleTestHelper.AGEUSERCOUNT) - 1);
                TagRecycleTestHelper.GetInstance().ExpectedResults--;

                xonline.tagrecycle.Emailer1 emailer1 = new Emailer1();

                emailer1.TargetFilePath = TagRecycleTestHelper.EMAILERFILEPATH;
                emailer1.TargetFileName = TagRecycleTestHelper.EMAILER1FILENAME;

                int processed = TagRecycleTestHelper.RunComponentOnAllBuckets(emailer1);
                
                if (!File.Exists(String.Concat(TagRecycleTestHelper.EMAILERFILEPATH, TagRecycleTestHelper.EMAILER1FILENAME)))
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException("Emailer1 output file does NOT exist");
                }
                else
                {
                    File.Delete(String.Concat(TagRecycleTestHelper.EMAILERFILEPATH, TagRecycleTestHelper.EMAILER1FILENAME));
                }

                if (processed != TagRecycleTestHelper.GetInstance().ExpectedResults)
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException(String.Format("First Emailer Tests emailed {0} expected {1}", processed, TagRecycleTestHelper.GetInstance().ExpectedResults));
                }

                Global.RO.Info(String.Format("Successfully wrote {0} users to first emailer file", processed));

                ResultCode = TEST_RESULTS.PASSED;

            } // Execute
        } // Class

        [TestCase, Owner("DougA"), Description("Testing the Second Emailer component")]
        [RunDependency("Emailer1Tests")]
        class Emailer2Tests : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                Global.RO.Info("Advancing the clock on culled users for next test");

                for (int i = 0; i < TagRecycleTestHelper.AGEUSERCOUNT; i++)
                {
                    TagRecycleTestHelper.GetInstance().ChangeTimeStampForNextStep(i);
                }

                xonline.tagrecycle.Emailer2 emailer2 = new Emailer2();
                emailer2.TargetFilePath = TagRecycleTestHelper.EMAILERFILEPATH;
                emailer2.TargetFileName = TagRecycleTestHelper.EMAILER2FILENAME;

                int processed = TagRecycleTestHelper.RunComponentOnAllBuckets(emailer2);

                if (!File.Exists(String.Concat(TagRecycleTestHelper.EMAILERFILEPATH, TagRecycleTestHelper.EMAILER2FILENAME)))
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException("Emailer2 output file does NOT exist");
                }
                else
                {
                    File.Delete(String.Concat(TagRecycleTestHelper.EMAILERFILEPATH, TagRecycleTestHelper.EMAILER2FILENAME));
                }

                if (processed != TagRecycleTestHelper.GetInstance().ExpectedResults)
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException(String.Format("Second Emailer Tests emailed {0} expected {1}", processed, TagRecycleTestHelper.GetInstance().ExpectedResults));
                }

                ResultCode = TEST_RESULTS.PASSED;
            } // Execute
        } // Class


        [TestCase, Owner("DougA"), Description("Testing the Disassociater component")]
        [RunDependency("Emailer2Tests")]
        class DisassociaterTests : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                Global.RO.Info("Advancing the clock on culled users for next test");

                for (int i = 0; i < TagRecycleTestHelper.AGEUSERCOUNT; i++)
                {
                    TagRecycleTestHelper.GetInstance().ChangeTimeStampForNextStep(i);
                }

                TagRecycleTestHelper.InsertConsoleIdForDisassociater(TagRecycleTestHelper.RESERVATIONCONSOLEIDSTRING);

                xonline.tagrecycle.Disassociater disassociater= new Disassociater();
                disassociater.DictionaryFiles = TagRecycleTestHelper.DICTIONARYFILES;
                disassociater.ReservationConsoleIdString = TagRecycleTestHelper.RESERVATIONCONSOLEIDSTRING;

                int processed = TagRecycleTestHelper.RunComponentOnAllBuckets(disassociater); ;

                if (processed != TagRecycleTestHelper.GetInstance().ExpectedResults)
                {
                    TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
                    throw new UnexpectedTestResultException(String.Format("Disassociater Tests disacosiated {0} expected {1}", processed, TagRecycleTestHelper.GetInstance().ExpectedResults));
                }

                Global.RO.Info(String.Format("Successfully disacosiated {0} users", processed));

                ResultCode = TEST_RESULTS.PASSED;

                TagRecycleTestHelper.GetInstance().CleanUpTestUsers();
            }
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TagRecycle\lib\TRComponentBase.cs ===
﻿// 
// TRComponentBase.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//.

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tagrecycle
{
    /// <summary>
    /// base class for doing tag recycle work
    /// </summary>
    public abstract class TRComponentBase
    {
        /// <summary>
        /// State of the row in t_users_tagRecycle
        /// </summary>
        protected internal enum TagRecycleState
        { 
            New = 0,
            FirstEmail = 1,
            SecondEmail = 2,
            Disassociated = 3
        }

        /// <summary>
        /// state this object moves the rows TO.
        /// </summary>
        protected internal TagRecycleState _targetState;

        /// <summary>
        /// Virtual method for processing results 
        /// </summary>
        /// <param name="reader">reader containing results</param>
        /// <returns>number of rows successfully  processed.</returns>
        protected abstract int GetResults(WstDataReader reader);

        /// <summary>
        /// Updates row in database table t_Users_Tagrecycle
        /// </summary>
        /// <param name="userPuid">userid to update</param>
        /// <param name="newState">targetstate to set</param>
        protected void UpdateState(ulong userPuid, TagRecycleState newState)
        {
            using (WSClient wsClient = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                wsClient.ClearParameters();
                wsClient.Partition = wsClient.CalcPartition(userPuid);
                wsClient.StoredProc = "p_tagrecycle_update_state";
                wsClient.AddParameter("@bi_UserPuid", userPuid);
                wsClient.AddParameter("@ti_NewState", ((int)newState));
                wsClient.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Base worker method for all TagRecycle Components
        /// </summary>
        /// <param name="client">Connection to the database</param>
        /// <param name="batchSize">batch size</param>
        /// <returns>Number of records successfully processed</returns>
        public int ProcessBatch(WSClient client, uint batchSize)
        {
            int returnVal = 0;
            client.StoredProc = (_targetState == TagRecycleState.New)? "dbo.p_tagrecycle_comber" : "dbo.p_tagrecycle_get_users_in_state";
            client.AddParameter("@i_batchSize", batchSize);
            client.AddParameter("@si_hash_bucket", client.Partition);

            if (_targetState != TagRecycleState.New)
            {
                client.AddParameter("@ti_current_state", (((int)_targetState) - 1));
            }

            using (WstDataReader reader = client.Execute())
            {
                returnVal = GetResults(reader);
                reader.Close();
            }

            return returnVal;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\teamcleaner\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Templates\STF\MainLiveLib.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="MainLiveLib.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   a template for creating STF test cases using LiveLib
// </summary>
//-----------------------------------------------------------------------

using live.common;
using live.lfm;
using live.protocol.Presence;
using live.server;
using ServerTestFramework;

namespace Test.StfTemplate
{
    /// <summary>
    /// The Test Group - it contains all test cases specified herein
    ///   MainTestGroup_LiveLib
    ///     P_MainTestCase_LiveLib
    ///     N_MainTestCase_LiveLib
    /// For more information on test attributes: http://xblwiki/default.aspx/XboxLive/TestTagging.html
    /// </summary>
    [TestGroup, Owner("TEST_OWNER"), TestFrequency("Regression"), EnvRequirement(""), Description("TestGroup_LiveLib Template Description")]
    public class MainTestGroup_LiveLib : TestBaseGroup
    {
        // Create the report object for logging purposes
        private static Report report = new Report(typeof(MainTestGroup).Name);

        // Create the xbox360 object for working with users
        private static Xbox360 xbox360 = new Xbox360();

        /// <summary>
        /// This setup function is called once after this TestGroup is instantiated
        /// Used to setup any requirements for all test cases in this test group
        /// </summary>
        [TestGroupSetup]
        public void Setup()
        {
            xbox360.Client.BypassKDC = true;
        }

        /// <summary>
        /// This cleanup function is called once after all test cases have completed
        /// Used to cleanup after all test cases in this test group
        /// </summary>
        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        /// <summary>
        /// A Positive Test Case with LiveLib
        /// </summary>
        [TestCase, Description("Positive Test Case Template Description")]
        public void P_MainTestCase_LiveLib()
        {
            // Create a silver user
            report.Info("Creating silver user...");

            XblUserSettings userSettings = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);

            XblUser user = null;
            uint hr = UACS.XeCreateLiveAccount(xbox360.Client, userSettings, out user);
            if (0 != hr)
            {
                throw new UnexpectedTestResultException("Create User Failed: hr = " + hr);
            }

            report.Info("Created silver user '{0}' {1}", user.Gamertag, user.Puid);

            // Logon
            report.Info("Logging on...");

            xbox360.Client.UserLoggingOn(user);
            Presence.Alive2(xbox360.Client, user);
            Presence.SetState(xbox360.Client, user, XonPresNoti.P_STATE_MASK_ONLINE);

            xbox360.Client.LoggedOnUsers.Add(user);
            xbox360.ActiveUser = user;

            report.Info("Logged on");

            // Logoff
            report.Info("Logging off...");

            xbox360.Client.UserLoggingOff(user);
            Presence.LogOut(xbox360.Client, user);
            xbox360.Client.LoggedOnUsers.Remove(user);

            report.Info("Logged off");

            // Done
            // Since this test cases returns, it is assumed to pass
        }

        /// <summary>
        /// A Negative Test Case
        /// The RunDependency attribute specifies that this test case is dependent on P_MainTestCase_LiveLib running and succeeding
        /// </summary>
        [RunDependency("P_MainTestCase_LiveLib")]
        [TestCase, Description("Negative Test Case Template Description")]
        public void N_MainTestCase_LiveLib()
        {
            report.Info("Failure test case...");

            // Throw UnexpectedTestResultException
            // This causes the test case to fail with the specified message
            throw new UnexpectedTestResultException("Negative Test Case Template Exception");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Templates\STF\Main.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="Main.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   a template for creating STF test cases
// </summary>
//-----------------------------------------------------------------------

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace Test.StfTemplate
{
    /// <summary>
    /// The Test Group - it contains all test cases specified herein
    ///   MainTestGroup
    ///     P_MainTestCase
    ///     N_MainTestCase
    /// For more information on test attributes: http://xblwiki/default.aspx/XboxLive/TestTagging.html
    /// </summary>
    [TestGroup, Owner("TEST_OWNER"), TestFrequency("Regression"), EnvRequirement(""), Description("TestGroup Template Description")]
    public class MainTestGroup : TestBaseGroup
    {
        // Create the report object for logging purposes
        private static Report report = new Report(typeof(MainTestGroup).Name);

        // Create the uacs object for working with users
        private static UacsCommon2 uacs = new UacsCommon2();

        /// <summary>
        /// This setup function is called once after this TestGroup is instantiated
        /// Used to setup any requirements for all test cases in this test group
        /// </summary>
        [TestGroupSetup]
        public void Setup()
        {
        }

        /// <summary>
        /// This cleanup function is called once after all test cases have completed
        /// Used to cleanup after all test cases in this test group
        /// </summary>
        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        /// <summary>
        /// A Positive Test Case
        /// </summary>
        [TestCase, Description("Positive Test Case Template Description")]
        public void P_MainTestCase()
        {
            // Create a silver user
            report.Info("Creating silver user...");
            XblUser user = uacs.CreateUser(UserType.Silver);

            // Presence state is unlikely to be a concern for most API level testing
            // If presence state is required, consult the appropriate test case in livelib or presence
            
            report.Info("Created silver user '{0}' {1}", user.Gamertag, user.Puid);

            // Done
            // Since this test cases returns, it is assumed to pass
        }
        /// <summary>
        /// A Negative Test Case
        /// The RunDependency attribute specifies that this test case is dependent on P_MainTestCase running and succeeding
        /// </summary>
        [RunDependency("P_MainTestCase")]
        [TestCase, Description("Negative Test Case Template Description")]
        public void N_MainTestCase()
        {
            report.Info("Failure test case...");

            // Throw UnexpectedTestResultException
            // This causes the test case to fail with the specified message
            throw new UnexpectedTestResultException("Negative Test Case Template Exception");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\teamcleaner\TeamCleaner.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Caching;

using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;


namespace TeamCleaner
{
    
    class TeamCleanerApp
    {
        static bool fReport = false;
        static bool fVerbose = false;

        static void PromoteMember(
            uint uiTitleId, 
            ulong puidUser, 
            ulong puidTeam, 
            ulong puidMember,
            byte[] rgbMemberData)
        {
            if (fVerbose)
            {
                Console.Write("PromoteMember team=");
                Console.Write(puidTeam);
                Console.Write(" member=");
                Console.Write(puidMember);
                Console.Write("\n");
            }
            if (fReport) return;

            TeamManageMemberMsg       msg = new TeamManageMemberMsg();;
            TeamManageMemberReplyMsg  reply = new TeamManageMemberReplyMsg();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            BinaryReader        reader;
            byte[]              respBuf;

            msg.qwUserID = puidUser;
            msg.dwTitleID = uiTitleId;
            msg.qwTeamID = puidTeam;
            msg.qwMemberID = puidMember;
            msg.dwMemberPriv = 0xFFFFFFFF;
            if (rgbMemberData != null)
            {
                msg.cbMemberData = (short) rgbMemberData.Length;
                msg.rgbMemberData = rgbMemberData;
            }
            else
            {
                msg.cbMemberData = 0;
                msg.rgbMemberData = new byte[0];
            }

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            uint hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, "", stream.ToArray(), out respBuf);

            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                hr = reply.hr;
            }

            if (HResult.Failed(hr))
            {
                Console.Write("TeamManageMember Failed user=");
                Console.Write(puidMember);
                Console.Write(" hr=");
                Console.Write(hr);
                Console.Write("\n");
            }
        }

        static void CheckForAdmin(uint uiTitleId, ulong puidUser, ulong puidTeam)
        {
            bool fOtherAdmin = false;
            bool fNonRecruit = false;

            TeamListMembersMsg       msg = new TeamListMembersMsg();
            TeamListMembersReplyMsg  reply = new TeamListMembersReplyMsg();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            BinaryReader        reader;
            byte[]              respBuf;
            int                 i;

            msg.qwUserID = puidUser;
            msg.dwTitleID = uiTitleId;
            msg.qwTeamID = puidTeam;
            msg.fShowRecruits = 1;

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            uint hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, "", stream.ToArray(), out respBuf);

            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                hr = reply.hr;

                for (i=0; i< reply.cMembers; i++)
                {
                    if (reply.replyTeamMember[i].qwMemberID != puidUser)
                    {
                        if (reply.replyTeamMember[i].fMember != 0)
                        {
                            fNonRecruit = true;

                            if (reply.replyTeamMember[i].dwMemberPriv == 0xFFFFFFFF)
                            {
                                fOtherAdmin = true;
                            }
                        }
                    }
                }

                if (!fNonRecruit)
                {
                    if (fVerbose)
                    {
                        Console.Write("Team only contains recruits\n");
                    }
                    // Just recruits, delete the team
                    DeleteTeam(uiTitleId, puidUser, puidTeam);
                }
                else
                {
                    if (!fOtherAdmin)
                    {
                        // Find someone to promote
                        for (i=0; i< reply.cMembers; i++)
                        {
                            if ((reply.replyTeamMember[i].qwMemberID != puidUser) && (reply.replyTeamMember[i].fMember != 0))
                            {
                                PromoteMember(uiTitleId, puidUser, puidTeam, reply.replyTeamMember[i].qwMemberID, reply.replyTeamMember[i].rgbMemberData);
                                break;
                            }
                        }

                    }

                    // Remove them from the team
                    RemoveUserFromTeam(uiTitleId, puidUser, puidTeam);
                }

            }
            if (HResult.Failed(hr))
            {
                Console.Write("MemberEnum Failed hr=");
                Console.Write(hr);
                Console.Write("\n");
            }
        }

        static void RemoveUserFromTeam(uint uiTitleId, ulong puidUser, ulong puidTeam)
        {
            if (fVerbose)
            {
                Console.Write("TeamRemove team=");
                Console.Write(puidTeam);
                Console.Write("\n");
            }
            if (fReport) return;

            TeamRemoveMsg       msg = new TeamRemoveMsg();
            TeamRemoveReplyMsg  reply = new TeamRemoveReplyMsg();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            BinaryReader        reader;
            byte[]              respBuf;

            msg.qwUserID = puidUser;
            msg.dwTitleID = uiTitleId;
            msg.qwTeamID = puidTeam;
            msg.qwMemberID = puidUser;

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            uint hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, "", stream.ToArray(), out respBuf);

            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                hr = reply.hr;
            }

            if (HResult.Failed(hr))
            {
                Console.Write("TeamRemoveUser Failed team=");
                Console.Write(puidTeam);
                Console.Write(" hr=");
                Console.Write(hr);
                Console.Write("\n");
            }
        }

        static void DeleteTeam(uint uiTitleId, ulong puidUser, ulong puidTeam)
        {
            if (fVerbose)
            {
                Console.Write("TeamDelete team=");
                Console.Write(puidTeam);
                Console.Write("\n");
            }
            if (fReport) return;

            TeamDeleteMsg       msg = new TeamDeleteMsg();
            TeamDeleteReplyMsg  reply = new TeamDeleteReplyMsg();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            BinaryReader        reader;
            byte[]              respBuf;

            msg.qwUserID = puidUser;
            msg.dwTitleID = uiTitleId;
            msg.qwTeamID = puidTeam;

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            uint hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, "", stream.ToArray(), out respBuf);

            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                hr = reply.hr;
            }

            if (HResult.Failed(hr))
            {
                Console.Write("TeamDelete Failed team=");
                Console.Write(puidTeam);
                Console.Write(" hr=");
                Console.Write(hr);
                Console.Write("\n");
            }
        }

        static void CleanUserTeams(uint uiTitleId, ulong puid)
        {
            if (fVerbose)
            {
                Console.Write("User: ");
                Console.Write(puid);
                Console.Write("\n");
            }

            // Get the teams they're a member of
            TeamListTeamsMsg       msg = new TeamListTeamsMsg();
            TeamListTeamsReplyMsg  reply = new TeamListTeamsReplyMsg();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            BinaryReader        reader;
            byte[]              respBuf;
            int                 i;

            msg.qwUserID = puid;
            msg.dwTitleID = uiTitleId;
            msg.cTeamIDs = 0;
            msg.rgqwTeamIDs = new ulong[0] {};

            msg.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            uint hr = XRLUtil.PostXrlRequest(XOService.Teams, msg.GetXRL(), -1, "", stream.ToArray(), out respBuf);
            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                hr = reply.hr;

                for (i=0; i< reply.cTeams; i++)
                {
                    if (reply.replyTeam[i].dwNumMembers == 1)
                    {
                        // We're the only member, delete the team
                        DeleteTeam(uiTitleId, puid, reply.replyTeam[i].qwTeamID);
                    }
                    else
                    {
                        CheckForAdmin(uiTitleId, puid, reply.replyTeam[i].qwTeamID);
                    }
                }
            }
            if (HResult.Failed(hr))
            {
                Console.Write("TeamEnum Failed hr=");
                Console.Write(hr);
                Console.Write("\n");
            }
                
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            uint uiTitleId = 0;
            string FileNameRead = "";
            int i;

            do
            {
                if (args.Length == 0)
                {
                    Console.WriteLine("TeamCleaner [-r] [-v] -t titleid PUIDFileName");
                    break;
                }

                for (i=0; i< args.Length; i++)
                {
                    if (args[i] == "-r")
                    {
                        fReport = true;
                    }
                    else if (args[i] == "-v")
                    {
                        fVerbose = true;
                    }
                    else if (args[i] == "-t")
                    {
                        i++;
                        if (i< args.Length)
                        {
                            uiTitleId = uint.Parse(args[i]);
                        }
                    }
                    else
                    {
                        FileNameRead = args[i];
                    }
                }

                if (FileNameRead == "")
                {
                    Console.WriteLine("No PUIDFileName specified");
                    break;
                }

                if (uiTitleId == 0)
                {
                    Console.WriteLine("No TitleId specified");
                    break;
                }

                if (fVerbose)
                {
                    Console.Write("Title: ");
                    Console.Write(uiTitleId);
                    Console.Write("\n");
                }

                FileInfo fileInfoRead = new FileInfo(FileNameRead);
                String whitespace = " \t";
 
                StreamReader stream = fileInfoRead.OpenText();

                string strLine;
                ulong puid;
                for(;;)
                {
                    strLine = stream.ReadLine();
                    if (strLine == null) 
                    {
                        break;
                    }

                    strLine.Trim(whitespace.ToCharArray());

                    if (strLine != "")
                    {
                        puid = ulong.Parse(strLine);
                        CleanUserTeams(uiTitleId, puid);
                    }
                }
            } while (false);
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TestWmrm\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TestWmrm\TestWmrmMain.cs ===
using System;
using System.Text;
using System.IO;

using WMRMOBJSLib;

namespace TestWmrm
{
    public class TestWmrmMain
    {

        private static string GetClientInfo(string fileName)
        {
            using (StreamReader reader = new StreamReader(new FileStream(fileName, FileMode.Open), new UnicodeEncoding()))
            {
                return reader.ReadToEnd();
            }
        }

        private static string GenerateResponse(string clientInfo)
        {
            string keyId = "1";
            string seed = "c52LF06QftMXc1DCRQf48sIMSmf00xsJbIn34vAW";

            WMRMKeys keysObj = new WMRMKeys();
            keysObj.KeyID = keyId;
            keysObj.Seed = seed;

            WMRMLicGen licgenObj = new WMRMLicGen();
            licgenObj.ClientInfo = clientInfo;
            licgenObj.KeyID = keyId;
            licgenObj.SetKey("MSDRM", keysObj.GenerateKey());

            WMRMRights rightsObj = new WMRMRights();

            rightsObj.MinimumAppSecurity = 500;
            rightsObj.AllowPlayOnPC = 1;
            rightsObj.AllowBackupRestore = 1;
            rightsObj.AllowTransferToSDMI = 1;
            rightsObj.Playcount = 2;
            rightsObj.PMRights = 51;
            rightsObj.PMAppSecurity = 150;

            licgenObj.Rights = rightsObj.GetAllRights();

            string rawLicense = licgenObj.GetLicenseToDeliver();

            WMRMResponse response = new WMRMResponse();
            response.AddLicense("2.0.0.0", rawLicense);
            return response.GetLicenseResponse();
        }

        public static void Main(string[] args)
        {

            if (args.Length != 1)
            {
                Console.WriteLine("usage: TestWmrm <client_info_filename>");
                return;
            }

            Console.WriteLine("Loading the client info that was passed in...");

            string clientInfo = null;
            try
            {
                clientInfo = GetClientInfo(args[0]);
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("File {0} does not appear to exist.", args[0]);
                return;
            }

            Console.WriteLine("Client info loaded, attempting to create license response...");

            string response = null;
            try
            {
                response = GenerateResponse(clientInfo);
            }
            catch (FileNotFoundException e)
            {
                Console.WriteLine("Could not generate the WMRM response because the file {0} could not be found.", e.FileName);
                Console.WriteLine("This usually indicates that you didn't copy the interop dlls over (they will be in the same place as this executable).");
                Console.WriteLine("Note that these interop dlls are copied over during signature server installation, so this does not indicate a WMRM setup issue, just a tool setup issue.");
                return;
            }
            catch (System.Runtime.InteropServices.COMException e)
            {
                switch ((uint)e.ErrorCode)
                {
                    case 0x80040154:    //  REGDB_E_CLASSNOTREG
                    {
                        Console.WriteLine("Could not generate the WMRM response because of a COM class registration issue.");
                        Console.WriteLine("This is most likely because the WMRM sdk is not properly installed.");
                        return;
                    }

                    case 0xC004291C:    //  DRM_E_LICENSE_SERVER_INFO_MISSING
                    {
                        Console.WriteLine("Could not generate the WMRM resonse because of a licensing service error.");
                        Console.WriteLine("This is most likely because the WMRM certificates have not been installed.");
                        return;
                    }

                    default:
                    {
                        Console.WriteLine("Could not generate the WMRM response because of some interop error: 0x{0:X8}.", e.ErrorCode);
                        return;
                    }
                }
            }

            Console.WriteLine("Succesffuly created the WMRM response. Everything looks good.");

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Templates\STF\MainPresence.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="MainPresence.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   a template for creating STF test cases with presence
// </summary>
//-----------------------------------------------------------------------

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;

namespace Test.StfTemplate
{
    /// <summary>
    /// The Test Group - it contains all test cases specified herein
    ///   MainTestGroup_Presence
    ///     P_MainTestCase_Presence
    ///     N_MainTestCase_Presence
    /// For more information on test attributes: http://xblwiki/default.aspx/XboxLive/TestTagging.html
    /// </summary>
    [TestGroup, Owner("TEST_OWNER"), TestFrequency("Regression"), EnvRequirement(""), Description("TestGroup_Presence Template Description")]
    public class MainTestGroup_Presence : TestBaseGroup
    {
        // Create the report object for logging purposes
        private static Report report = new Report(typeof(MainTestGroup).Name);

        // Create the friends object for working with users
        private static FriendsCommon fc = new FriendsCommon();

        // Create the uacs object for working with users
        private static UacsCommon2 uacs = new UacsCommon2();

        /// <summary>
        /// This setup function is called once after this TestGroup is instantiated
        /// Used to setup any requirements for all test cases in this test group
        /// </summary>
        [TestGroupSetup]
        public void Setup()
        {
        }

        /// <summary>
        /// This cleanup function is called once after all test cases have completed
        /// Used to cleanup after all test cases in this test group
        /// </summary>
        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        /// <summary>
        /// A Positive Test Case
        /// </summary>
        [TestCase, Description("Positive Test Case Template Description")]
        public void P_MainTestCase_Presence()
        {
            // Create a silver user
            report.Info("Creating silver user...");
            XblUser user = uacs.CreateUser(UserType.Silver);

            report.Info("Created silver user '{0}' {1}", user.Gamertag, user.Puid);

            // Create the presence user
            report.Info("Creating presence user...");
            PNUser pnUser = new PNUser(user.Gamertag, user.Puid);

            report.Info("Created presence user");

            // Create the xbox
            report.Info("Creating xbox...");
            PNXbox pnXbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, true);

            report.Info("Created xbox");

            // Logon
            report.Info("Logging on...");
            fc.LogonUser(pnUser);

            report.Info("Logged on");

            // Logoff
            report.Info("Logging off...");
            fc.LogoffUser(pnUser);

            report.Info("Logged off");

            // Done
            // Since this test cases returns, it is assumed to pass
        }
        /// <summary>
        /// A Negative Test Case
        /// The RunDependency attribute specifies that this test case is dependent on P_MainTestCase_Presence running and succeeding
        /// </summary>
        [RunDependency("P_MainTestCase_Presence")]
        [TestCase, Description("Negative Test Case Template Description")]
        public void N_MainTestCase_Presence()
        {
            report.Info("Failure test case...");

            // Throw UnexpectedTestResultException
            // This causes the test case to fail with the specified message
            throw new UnexpectedTestResultException("Negative Test Case Template Exception");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsApplication\Config.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="Config.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to load the config
// </summary>
//-----------------------------------------------------------------------
namespace TfsApplication
{
    using System.Configuration;
    using System.Reflection;

    /// <summary>
    /// Provides access to the configuration
    /// </summary>
    public class Config
    {
        /// <summary>
        /// configuration provides access to the application configuration
        /// </summary>
        private Configuration configuration = ConfigurationManager.OpenExeConfiguration(Assembly.GetExecutingAssembly().Location);

        /// <summary>
        /// Gets the value of the specified key
        /// </summary>
        /// <param name="key">The specified key</param>
        /// <returns>The value of the specified key</returns>
        public string this[string key]
        {
            get { return this.configuration.AppSettings.Settings[key].Value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsApplication\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsApplication")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsApplication")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d86fa9e4-551f-4344-a402-cc7b1a0dce91")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\NUnitTransform\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NUnitTransform")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("NUnitTransform")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("cb5ac88b-7644-40dd-be87-72302e28f65a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\NUnitTransform\NUnitTransform.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="NUnitTransform.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app to transform an nunit xml results file to an mstest trx results file
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace NUnitTransform
{
    using System;
    using System.IO;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// NUnitTransform transforms an nunit xml results file to an mstest trx results file
    /// </summary>
    internal class NUnitTransformConsole : TfsConsole
    {
        /// <summary>
        /// Initializes a new instance of the NUnitTransformConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal NUnitTransformConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the nunit transform tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the input file
            string inFileName = this.NamedArgsCollection["in"];

            // get the output file
            string outFileName = this.NamedArgsCollection["out"];

            // log all info
            this.LogWriter.WriteLine("Input File Name:      {0}", inFileName);
            this.LogWriter.WriteLine("Output File Name:     {0}", outFileName);

            try
            {
                // create the nunit transform instance
                NUnitTransform nunitTransform = new NUnitTransform();

                // run the transform
                string output = nunitTransform.Transform(inFileName);

                // save the transformed xml
                using (StreamWriter streamWriter = new StreamWriter(outFileName))
                {
                    streamWriter.Write(output);
                }
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            this.LogWriter.WriteLine();

            return 0;
        }

        private static int Main(string[] args)
        {
            // create the nunit transform instance
            NUnitTransformConsole nunitTransformConsole = new NUnitTransformConsole(args);

            // run
            return nunitTransformConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsApplication\TfsConsole.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsConsole.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for creating a tfs build
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsApplication
{
    using System;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;

    using ConsoleFileLog;
    using NamedArgParser;

    /// <summary>
    /// TfsConsole is a console application wrapper that exposes a Run method
    /// </summary>
    public abstract class TfsConsole : IDisposable
    {
        /// <summary>
        /// args are the command line arguments
        /// </summary>
        private string[] args;

        /// <summary>
        /// config is the configuration settings
        /// </summary>
        private Config config = new Config();

        /// <summary>
        /// logToFile specifies if the log writer should attach to file
        /// </summary>
        private bool logToFile;

        /// <summary>
        /// logWriter is the object to write to the console and log file
        /// </summary>
        private LogWriter logWriter = new LogWriter();

        /// <summary>
        /// namedArgsCollection is the collection of named arguments
        /// </summary>
        private NamedArgsCollection namedArgsCollection = new NamedArgsCollection();

        /// <summary>
        /// Initializes a new instance of the TfsConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        /// <param name="logToFile">Specifies if the log writer should attach to file</logToFile>
        protected TfsConsole(string[] args, bool logToFile)
        {
            this.args = args;
            this.logToFile = logToFile;
        }

        /// <summary>
        /// Gets the config instance
        /// </summary>
        public Config Config
        {
            get { return this.config; }
        }

        /// <summary>
        /// Gets the log writer instance
        /// </summary>
        public LogWriter LogWriter
        {
            get { return this.logWriter; }
        }

        /// <summary>
        /// Gets the named args collection instance
        /// </summary>
        public NamedArgsCollection NamedArgsCollection
        {
            get { return this.namedArgsCollection; }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        public void Dispose(bool disposing)
        {
            if (true == disposing)
            {
                if (null != this.logWriter)
                {
                    this.logWriter.Dispose();
                }
            }
        }

        /// <summary>
        /// Begins running the tfs tool
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        public int Run()
        {
            int returnValue = 0;

            // attach the log writer
            returnValue = this.LogWriterAttach();
            if (0 != returnValue)
            {
                return returnValue;
            }

            // log the command line
            this.logWriter.WriteLine(Environment.CommandLine);
            this.logWriter.WriteLine();

            // parse the command line arguments
            string namedArgGroup;
            using (Stream stream = Assembly.GetEntryAssembly().GetManifestResourceStream(Assembly.GetEntryAssembly().GetName().Name + ".Resources.Usage.xml"))
            {
                namedArgGroup = this.namedArgsCollection.Parse(stream, this.args, new DisplayUsageCallback(this.DisplayUsage));
            }

            // run
            if (true == String.IsNullOrEmpty(namedArgGroup))
            {
                returnValue = Marshal.GetHRForException(new ArgumentException("The command line arguments are invalid", "args"));
            }
            else
            {
                returnValue = this.Run(namedArgGroup);
            }

            this.logWriter.WriteLine("Done");
            this.logWriter.WriteLine();

            // detach the console and log file
            this.LogWriterDetach();

            return returnValue;
        }

        /// <summary>
        /// Begins running the tfs create build tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public abstract int Run(string namedArgGroup);

        /// <summary>
        /// Displays the program usage
        /// </summary>
        /// <param name="usage">The usage string to display</param>
        private void DisplayUsage(string usage)
        {
            this.logWriter.WriteLine(usage);
        }

        /// <summary>
        /// Attaches the log writer to the console and file name
        /// </summary>
        /// <returns>0 if success; otherwise, the error code</returns>
        private int LogWriterAttach()
        {
            // get the name of the currently executing assembly
            string assemblyName = Path.GetFileNameWithoutExtension(Assembly.GetEntryAssembly().ManifestModule.Name);

            // attach the log object
            this.logWriter.AttachConsole();

            if (true == this.logToFile)
            {
                try
                {
                    this.logWriter.AttachFile(assemblyName + ".log");
                }
                catch (IOException ex)
                {
                    this.logWriter.WriteLine("IOException: " + ex.Message);
                    return Marshal.GetHRForException(ex);
                }
                catch (UnauthorizedAccessException ex)
                {
                    this.logWriter.WriteLine("UnauthorizedAccessException: " + ex.Message);
                    return Marshal.GetHRForException(ex);
                }
            }

            return 0;
        }

        /// <summary>
        /// Detaches the log writer from the console and file name
        /// </summary>
        private void LogWriterDetach()
        {
            if (true == this.logToFile)
            {
                this.logWriter.DetachFile();
            }

            this.logWriter.DetachConsole();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuildAgent\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsCreateBuildAgent")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsCreateBuildAgent")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("236339b0-241d-4ba7-94f2-0444ed94bf64")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuildAgent\TfsCreateBuildAgent.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsCreateBuildAgent.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for creating a tfs build agent
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsCreateBuildAgent
{
    using System;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsCreateBuildAgentConsole creates a tfs build agent
    /// </summary>
    internal class TfsCreateBuildAgentConsole : TfsConsole
    {
        /// <summary>
        /// Initializes a new instance of the TfsCreateBuildAgentConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsCreateBuildAgentConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the tfs create build tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // log all info
            this.LogWriter.WriteLine("TFS Server Name:      {0}", serverName);
            this.LogWriter.WriteLine("TFS Project Name:     {0}", projectName);

            this.LogWriter.WriteLine();

            try
            {
                // create the project instance
                TfsProject tfsProject = new TfsProject(serverName, projectName);

                // create the build agent
                tfsProject.CreateBuildAgent();
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            return 0;
        }

        private static int Main(string[] args)
        {
            // create the tfs create build agent instance
            TfsCreateBuildAgentConsole tfsCreateBuildAgentConsole = new TfsCreateBuildAgentConsole(args);

            // run
            return tfsCreateBuildAgentConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuild\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsCreateBuild")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsCreateBuild")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b7d0ed17-adc9-4764-89cb-789c4b1b1247")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuild\TfsCreateBuild.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsCreateBuild.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for creating a tfs build
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsCreateBuild
{
    using System;
    using System.IO;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsCreateBuild creates a tfs build
    /// </summary>
    internal class TfsCreateBuildConsole : TfsConsole
    {
        /// <summary>
        /// Initializes a new instance of the TfsCreateBuildConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsCreateBuildConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the tfs create build tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // get the build definition name
            string buildDefinition = this.NamedArgsCollection["buildDefinition"];

            // get the build number
            string buildNumber = this.NamedArgsCollection["buildNumber"];

            // get the original build drop
            string buildDrop = this.NamedArgsCollection["buildDrop"];

            // get the build configurations
            string buildConfigurations = this.Config["buildConfigs"];
            if (null != this.NamedArgsCollection["buildConfigs"])
            {
                buildConfigurations = this.NamedArgsCollection["buildConfigs"];
            }

            // get the build log drop
            string buildLogDrop = this.NamedArgsCollection["buildLogDrop"];

            // parse the build configurations
            TfsBuildConfigurationCollection tfsBuildConfigurations = TfsCreateBuildConsole.ParseBuildConfigurations(buildLogDrop, buildConfigurations);

            // log all info
            this.LogWriter.WriteLine("TFS Server Name:      {0}", serverName);
            this.LogWriter.WriteLine("TFS Project Name:     {0}", projectName);
            this.LogWriter.WriteLine("Build Definition:     {0}", buildDefinition);
            this.LogWriter.WriteLine("Build Number:         {0}", buildNumber);
            this.LogWriter.WriteLine("Build Drop:           {0}", buildDrop);
            this.LogWriter.WriteLine("Build Log Drop:       {0}", buildLogDrop);
            this.LogWriter.WriteLine("Build Configurations: {0}", tfsBuildConfigurations.Count);

            foreach (TfsBuildConfiguration tfsBuildConfiguration in tfsBuildConfigurations)
            {
                this.LogWriter.WriteLine("  Configuration:");
                this.LogWriter.WriteLine("    Flavor:           {0}", tfsBuildConfiguration.Flavor);
                this.LogWriter.WriteLine("    Platform:         {0}", tfsBuildConfiguration.Platform);

                if (false == String.IsNullOrEmpty(tfsBuildConfiguration.LogFile))
                {
                    this.LogWriter.WriteLine("    Log File:         {0}", tfsBuildConfiguration.LogFile);
                }

                this.LogWriter.WriteLine("    Errors:           {0}", tfsBuildConfiguration.Errors);
                this.LogWriter.WriteLine("    Warnings:         {0}", tfsBuildConfiguration.Warnings);
            }

            try
            {
                // create the project instance
                TfsProject tfsProject = new TfsProject(serverName, projectName);

                // get the build definition
                TfsBuildDefinition tfsBuildDefinition = tfsProject.GetBuildDefinition(buildDefinition);

                // create the build
                TfsBuild tfsBuild = tfsBuildDefinition.CreateBuild(buildNumber, buildDrop, tfsBuildConfigurations);

                this.LogWriter.WriteLine("Build Status:         {0}", tfsBuild.Status);
                this.LogWriter.WriteLine("Build Uri:            {0}", tfsBuild.Uri);
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            this.LogWriter.WriteLine();

            return 0;
        }

        /// <summary>
        /// Get the number of lines in the log file (roughly the number of error or warnings in the build)
        /// </summary>
        /// <param name="logFile">The specified log file</param>
        /// <returns>The number of lines in the log file</returns>
        private static int GetLogFileCount(string logFile)
        {
            // logFileCount is the number of lines in the log file (roughly the number of errors or warnings in the build)
            int logFileCount = 0;

            try
            {
                // Open the log file for reading
                using (StreamReader streamReader = LongPath.Read(logFile))
                {
                    // Read each line and increment the logFileCount
                    while (false == streamReader.EndOfStream)
                    {
                        streamReader.ReadLine();
                        logFileCount++;
                    }
                }
            }
            catch (System.ComponentModel.Win32Exception)
            {
            }

            return logFileCount;
        }

        /// <summary>
        /// Parses the build configurations strings for each build configuration
        /// </summary>
        /// <param name="buildLogDrop">The full path to the share for the build log files</param>
        /// <param name="buildConfigurations">The delimited string specifying each build configuration</param>
        /// <returns>The collection of build configurations</returns>
        private static TfsBuildConfigurationCollection ParseBuildConfigurations(string buildLogDrop, string buildConfigurations)
        {
            TfsBuildConfigurationCollection tfsBuildConfigurations = new TfsBuildConfigurationCollection();

            // Get the configurations
            string[] buildConfigurationsSplit = buildConfigurations.Split(';');

            foreach (string buildConfiguration in buildConfigurationsSplit)
            {
                // split the configuration into flavor, platform, build log file, error log file, warning log file
                string[] buildConfigurationSplit = buildConfiguration.Split(',');

                if ((2 != buildConfigurationSplit.Length) && (5 != buildConfigurationSplit.Length))
                {
                    throw new ArgumentException();
                }

                // get the flavor and platform
                string flavor = buildConfigurationSplit[0];
                string platform = buildConfigurationSplit[1];

                if ((2 == buildConfigurationSplit.Length) || (true == String.IsNullOrEmpty(buildLogDrop)))
                {
                    // create the build configuration
                    tfsBuildConfigurations.Add(new TfsBuildConfiguration(flavor, platform));
                }
                else
                {
                    // get the build log files
                    string buildLogFile = buildLogDrop + "\\" + buildConfigurationSplit[2];
                    string errorLogFile = buildLogDrop + "\\" + buildConfigurationSplit[3];
                    string warningLogFile = buildLogDrop + "\\" + buildConfigurationSplit[4];

                    TfsBuildLogs tfsBuildLogs = new TfsBuildLogs(buildLogFile, errorLogFile, warningLogFile);

                    string logFile = buildLogFile;

                    // Get the build warnings
                    int warnings = TfsCreateBuildConsole.GetLogFileCount(warningLogFile);
                    if (0 < warnings)
                    {
                        logFile = warningLogFile;
                    }

                    // Get the build errors
                    int errors = TfsCreateBuildConsole.GetLogFileCount(errorLogFile);
                    if (0 < errors)
                    {
                        logFile = errorLogFile;
                    }

                    // create the build configuration
                    tfsBuildConfigurations.Add(new TfsBuildConfiguration(flavor, platform, logFile, errors, warnings, tfsBuildLogs));
                }
            }

            return tfsBuildConfigurations;
        }

        private static int Main(string[] args)
        {
            // create the tfs create build instance
            TfsCreateBuildConsole tfsCreateBuildConsole = new TfsCreateBuildConsole(args);

            // run
            return tfsCreateBuildConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuildDefinition\TfsCreateBuildDefinition.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsCreateBuildDefinition.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for creating a tfs build definition
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsCreateBuildDefinition
{
    using System;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsCreateBuildDefinition creates a tfs build definition
    /// </summary>
    internal class TfsCreateBuildDefinitionConsole : TfsConsole
    {
        /// <summary>
        /// Initializes a new instance of the TfsCreateBuildDefinitionConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsCreateBuildDefinitionConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the tfs create build tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // get the build definition name
            string buildDefinition = this.NamedArgsCollection["buildDefinition"];

            // get the tfs build drop
            string buildDrop = this.Config["buildDrop"];
            if (null != this.NamedArgsCollection["buildDrop"])
            {
                buildDrop = this.NamedArgsCollection["buildDrop"];
            }

            // log all info
            this.LogWriter.WriteLine("TFS Server Name:      {0}", serverName);
            this.LogWriter.WriteLine("TFS Project Name:     {0}", projectName);
            this.LogWriter.WriteLine("Build Definition:     {0}", buildDefinition);
            this.LogWriter.WriteLine("Build Drop:           {0}", buildDrop);

            this.LogWriter.WriteLine();

            try
            {
                // create the project instance
                TfsProject tfsProject = new TfsProject(serverName, projectName);

                // create the build definition
                tfsProject.CreateBuildDefinition(buildDefinition, buildDrop);
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            return 0;
        }

        private static int Main(string[] args)
        {
            // create the tfs create build definition instance
            TfsCreateBuildDefinitionConsole tfsCreateBuildDefinitionConsole = new TfsCreateBuildDefinitionConsole(args);

            // run
            return tfsCreateBuildDefinitionConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\LongPath.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="LongPath.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   long path support
//   http://blogs.msdn.com/bclteam/archive/2007/03/26/long-paths-in-net-part-2-of-3-long-path-workarounds-kim-hamilton.aspx
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.IO;
    using System.Runtime.InteropServices;
    using Microsoft.Win32.SafeHandles;

    /// <summary>
    /// Class to support long paths in file operations: read, write, delete, copy, exists
    /// </summary>
    public static class LongPath
    {
        /// <summary>
        /// Copies an existing file to a new file.  Overwrites the new file if it exists.
        /// </summary>
        /// <param name="left">The name of the existing file</param>
        /// <param name="right">The name of the new file</param>
        /// <param name="throwException">Indicates if an exception should be thrown</param>
        public static void Copy(string left, string right, bool throwException)
        {
            // copy the file
            bool result = NativeMethods.CopyFile(left, right, false);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if ((false == result) && (true == throwException))
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }
        }

        /// <summary>
        /// Creates the specified directory
        /// </summary>
        /// <param name="fileName">The name of the directory to create</param>
        /// <param name="throwException">Indicates if an exception should be thrown</param>
        public static void CreateDirectory(string fileName, bool throwException)
        {
            // create the directory
            bool result = NativeMethods.CreateDirectory(LongPath.FormatFileName(fileName), IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if ((false == result) && (true == throwException))
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }
        }

        /// <summary>
        /// Deletes the specified file
        /// </summary>
        /// <param name="fileName">The name of the file to delete</param>
        public static void Delete(string fileName)
        {
            // delete the file
            NativeMethods.DeleteFile(LongPath.FormatFileName(fileName));
        }

        /// <summary>
        /// Determines whether the specified file/directory exists
        /// </summary>
        /// <param name="fileName">The name of the file/directory to find</param>
        /// <returns>true if file/directory is found in the collection; otherwise, false</returns>
        public static bool Exists(string fileName)
        {
            NativeMethods.WIN32_FIND_DATA findData;
            IntPtr findHandle = NativeMethods.FindFirstFile(LongPath.FormatFileName(fileName), out findData);

            return NativeMethods.INVALID_HANDLE_VALUE != findHandle;
        }

        /// <summary>
        /// Opens an existing file for reading.
        /// </summary>
        /// <param name="fileName">The name of the file to open</param>
        /// <returns>A StreamReader object for reading the file</returns>
        public static StreamReader Read(string fileName)
        {
            // open the file
            SafeFileHandle safeFileHandle = NativeMethods.CreateFile(LongPath.FormatFileName(fileName), NativeMethods.EFileAccess.GenericRead, NativeMethods.EFileShare.None, IntPtr.Zero, NativeMethods.ECreationDisposition.OpenExisting, 0, IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (true == safeFileHandle.IsInvalid)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }

            // create the filestream
            FileStream fileStream = new FileStream(safeFileHandle, FileAccess.Read);
            return new StreamReader(fileStream, System.Text.Encoding.UTF8, true);
        }

        /// <summary>
        /// Creates a new file for writing.  Overwrites the new file if it exists
        /// </summary>
        /// <param name="fileName">The name of the file to create</param>
        /// <returns>A StreamWriter object for writing to the file</returns>
        public static StreamWriter Write(string fileName)
        {
            // open the file
            SafeFileHandle safeFileHandle = NativeMethods.CreateFile(LongPath.FormatFileName(fileName), NativeMethods.EFileAccess.GenericWrite, NativeMethods.EFileShare.None, IntPtr.Zero, NativeMethods.ECreationDisposition.CreateAlways, 0, IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (true == safeFileHandle.IsInvalid)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }

            // create the filestream
            FileStream fileStream = new FileStream(safeFileHandle, FileAccess.Write);
            return new StreamWriter(fileStream, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Formats the specified file name for use by native methods
        /// </summary>
        /// <param name="fileName">The specified file name</param>
        /// <returns>The formatted file name</returns>
        private static string FormatFileName(string fileName)
        {
            if (true == fileName.StartsWith(@"\\"))
            {
                return @"\\?\UNC\" + fileName.Substring(2);
            }

            return @"\\?\" + fileName;
        }

        /// <summary>
        /// Class to P/Invoke Win32 methods to support long paths in file operations
        /// </summary>
        private static class NativeMethods
        {
            internal const int MAX_PATH = 260;
            internal static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

            [Flags]
            internal enum ECreationDisposition : uint
            {
                New = 1,
                CreateAlways = 2,
                OpenExisting = 3,
                OpenAlways = 4,
                TruncateExisting = 5,
            }

            [Flags]
            internal enum EFileAccess : uint
            {
                GenericRead = 0x80000000,
                GenericWrite = 0x40000000,
                GenericExecute = 0x20000000,
                GenericAll = 0x10000000,
            }

            [Flags]
            internal enum EFileAttributes : uint
            {
                Readonly = 0x00000001,
                Hidden = 0x00000002,
                System = 0x00000004,
                Directory = 0x00000010,
                Archive = 0x00000020,
                Device = 0x00000040,
                Normal = 0x00000080,
                Temporary = 0x00000100,
                SparseFile = 0x00000200,
                ReparsePoint = 0x00000400,
                Compressed = 0x00000800,
                Offline = 0x00001000,
                NotContentIndexed = 0x00002000,
                Encrypted = 0x00004000,
                Write_Through = 0x80000000,
                Overlapped = 0x40000000,
                NoBuffering = 0x20000000,
                RandomAccess = 0x10000000,
                SequentialScan = 0x08000000,
                DeleteOnClose = 0x04000000,
                BackupSemantics = 0x02000000,
                PosixSemantics = 0x01000000,
                OpenReparsePoint = 0x00200000,
                OpenNoRecall = 0x00100000,
                FirstPipeInstance = 0x00080000
            }

            [Flags]
            internal enum EFileShare : uint
            {
                None = 0x00000000,
                Read = 0x00000001,
                Write = 0x00000002,
                Delete = 0x00000004,
            }

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool CopyFile(
                string lpExistingFileName,
                string lpNewFileName,
                [MarshalAs(UnmanagedType.Bool)]
                bool bFailIfExists);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern SafeFileHandle CreateFile(
                string lpFileName,
                EFileAccess dwDesiredAccess,
                EFileShare dwShareMode,
                IntPtr lpSecurityAttributes,
                ECreationDisposition dwCreationDisposition,
                EFileAttributes dwFlagsAndAttributes,
                IntPtr hTemplateFile);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool CreateDirectory(
                string lpPathName,
                IntPtr lpSecurityAttributes);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool DeleteFile(
                string lpFileName);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern IntPtr FindFirstFile(
                string lpFileName,
                out WIN32_FIND_DATA lpFindFileData);

            [StructLayout(LayoutKind.Sequential)]
            internal struct FILETIME
            {
                internal uint dwLowDateTime;
                internal uint dwHighDateTime;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct SECURITY_ATTRIBUTES
            {
                public int nLength;
                public IntPtr lpSecurityDescriptor;
                public int bInheritHandle;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct WIN32_FIND_DATA
            {
                internal FileAttributes dwFileAttributes;
                internal FILETIME ftCreationTime;
                internal FILETIME ftLastAccessTime;
                internal FILETIME ftLastWriteTime;
                internal int nFileSizeHigh;
                internal int nFileSizeLow;
                internal int dwReserved0;
                internal int dwReserved1;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
                internal string cFileName;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 14)]
                internal string cAlternate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsCreateBuildDefinition\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsCreateBuildDefinition")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsCreateBuildDefinition")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8108896f-b714-47d5-80f7-b6eb14c8f47a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\StringWriterUTF8.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="StringWriterUTF8.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   implements a TextWriter for writing information to a UTF8 encoded string
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System.IO;
    using System.Text;

    /// <summary>
    /// Implements a TextWriter for writing information to a UTF8 encoded string
    /// </summary>
    public sealed class StringWriterUTF8 : StringWriter
    {
        /// <summary>
        /// Initializes a new instance of the StringWriterUTF8 class that writes to the specified StringBuilder
        /// </summary>
        /// <param name="stringBuilder">The StringBuilder to write to</param>
        public StringWriterUTF8(StringBuilder stringBuilder)
            : base(stringBuilder)
        {
        }

        /// <summary>
        /// Gets the Encoding in which the output is written (UTF8)
        /// </summary>
        public override Encoding Encoding
        {
            get { return Encoding.UTF8; }
        }

        /// <summary>
        /// Releases all the unmanaged resources used by the StringWriterUTF8 and optionally releases the managed resources
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\NUnitTransform.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="NUnitTransform.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to transform an nunit xml results file to an mstest trx results file
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Xml;

    using Saxon.Api;

    public class NUnitTransform
    {
        /// <summary>
        /// processor is the factory for generating the xslt compiler and xdm node
        /// </summary>
        private Processor processor = new Processor();

        /// <summary>
        /// xsltTransformer is the object to run the xslt transform
        /// </summary>
        private XsltTransformer xsltTransformer;

        /// <summary>
        /// Initializes a new instance of the NUnitTransform class
        /// </summary>
        public NUnitTransform()
        {
            // load the xslt
            this.LoadXslt();
        }

        /// <summary>
        /// Transforms the specified file using the xslt
        /// </summary>
        /// <param name="fileName">The specified file name</param>
        /// <returns>The string representation of the transform file</returns>
        public string Transform(string fileName)
        {
            // load the xml into the xslt transformer instance
            xsltTransformer.InitialContextNode = this.LoadXml(fileName);

            // run the transform
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                using (XmlTextWriter xmlTextWriter = new XmlTextWriterCRLF(stringWriterUTF8))
                {
                    XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                    xmlTextWriter.Formatting = Formatting.Indented;

                    // run the transform
                    TextWriterDestination textWriterDestination = new TextWriterDestination(xmlTextWriter);
                    xsltTransformer.Run(textWriterDestination);
                }
            }

            return stringBuilder.ToString();
        }

        /// <summary>
        /// Loads the specified xml file
        /// </summary>
        /// <param name="fileName">The specified file name</param>
        /// <returns>The xdm node instance that contains the loaded xml</returns>
        private XdmNode LoadXml(string fileName)
        {
            // load the xml
            using (StreamReader streamReader = new StreamReader(fileName))
            {
                using (XmlReader xmlReader = XmlReader.Create(streamReader))
                {
                    // create the xdm node instance
                    return this.processor.NewDocumentBuilder().Build(xmlReader);
                }
            }
        }

        /// <summary>
        /// Loads the xslt
        /// </summary>
        private void LoadXslt()
        {
            // create the xslt compiler instance
            XsltCompiler xsltCompiler = this.processor.NewXsltCompiler();

            // set the base uri
            UriBuilder uriBuilder = new UriBuilder("file", "NUnitTransform.xslt");
            xsltCompiler.BaseUri = uriBuilder.Uri;

            // load the xslt
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(Assembly.GetExecutingAssembly().GetName().Name + ".Resources.NUnitTransform.xslt"))
            {
                using (XmlReader xmlReader = XmlReader.Create(stream))
                {
                    // create the xslt executable instance
                    XsltExecutable xsltExecutable = xsltCompiler.Compile(xmlReader);

                    // create the xslt transformer instance
                    this.xsltTransformer = xsltExecutable.Load();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\MSTest.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="MSTest.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to find and invoke mstest to publish a test results file
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using Microsoft.Win32;

    public static class MSTest
    {
        /// <summary>
        /// msTestPath is the full path to mstest.exe
        /// </summary>
        private static string msTestPath = MSTest.GetMSTestPath();

        /// <summary>
        /// Gets the full path to mstest
        /// </summary>
        /// <returns>The full path to mstest.exe</returns>
        private static string GetMSTestPath()
        {
            // get the current version of visual studio
            string versionPath = @"SOFTWARE\Classes\VisualStudio.Solution\CurVer";
            RegistryKey regKeyVersion = Registry.LocalMachine.OpenSubKey(versionPath);

            if (null == regKeyVersion)
            {
                return null;
            }

            string version = regKeyVersion.GetValue(null) as string;

            if (true == String.IsNullOrEmpty(version))
            {
                return null;
            }

            // split the version
            string[] versions = version.Split('.');

            if (4 != versions.Length)
            {
                return null;
            }

            if ("VisualStudio" != versions[0])
            {
                return null;
            }

            if ("Solution" != versions[1])
            {
                return null;
            }

            if (9 > Convert.ToInt32(versions[2]))
            {
                return null;
            }

            // get the path to the local server
            string clsidPath = @"SOFTWARE\Classes\VisualStudio.Solution\CLSID";
            RegistryKey regKeyCLSID = Registry.LocalMachine.OpenSubKey(clsidPath);

            if (null == regKeyCLSID)
            {
                return null;
            }

            string clsid = regKeyCLSID.GetValue(null) as string;

            if (true == String.IsNullOrEmpty(clsid))
            {
                return null;
            }

            // get the local server
            string localServerPath = String.Format(@"SOFTWARE\Classes\CLSID\{0}\LocalServer32", clsid);
            RegistryKey regKeyLocalServer = Registry.LocalMachine.OpenSubKey(localServerPath);

            if (null == regKeyLocalServer)
            {
                return null;
            }

            string localServer = regKeyLocalServer.GetValue(null) as string;

            if ((2 < localServer.Length) && ('"' == localServer[0]) && ('"' == localServer[localServer.Length - 1]))
            {
                localServer = localServer.Substring(1, localServer.Length - 2);
            }

            // get the path to mstest.exe
            return Path.Combine(Path.GetDirectoryName(localServer), "mstest.exe");
        }

        /// <summary>
        /// Publishes the specified results file to the specified TFS server and project for the specified build
        /// </summary>
        /// <param name="resultsFile">The specified results file</param>
        /// <param name="serverName">The specified TFS server name</param>
        /// <param name="projectName">The specified TFS project name</param>
        /// <param name="buildNumber">The specified build number</param>
        /// <param name="flavor">The specified build flavor</param>
        /// <param name="platform">The specified build platform</param>
        public static void PublishResults(string resultsFile, string serverName, string projectName, string buildNumber, string flavor, string platform)
        {
            if (null == msTestPath)
            {
                throw new FileNotFoundException("MSTest.exe could not be found.");
            }

            // build the arguments
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append(String.Format("/publishresultsfile:\"{0}\" ", resultsFile));
            stringBuilder.Append(String.Format("/publish:\"{0}\" ", serverName));
            stringBuilder.Append(String.Format("/teamproject:\"{0}\" ", projectName));
            stringBuilder.Append(String.Format("/publishbuild:\"{0}\" ", buildNumber));
            stringBuilder.Append(String.Format("/flavor:\"{0}\" ", flavor));
            stringBuilder.Append(String.Format("/platform:\"{0}\" ", platform));

            // set the process start info
            ProcessStartInfo processStartInfo = new ProcessStartInfo(MSTest.msTestPath, stringBuilder.ToString());
            processStartInfo.CreateNoWindow = true;
            processStartInfo.ErrorDialog = false;
            processStartInfo.RedirectStandardError = true;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = Path.GetDirectoryName(MSTest.msTestPath);

            Process process = new Process();
            process.StartInfo = processStartInfo;

            // capture the standard error and standard output
            OutputData outputData = new OutputData();
            process.ErrorDataReceived += new DataReceivedEventHandler(outputData.DataReceived);
            process.OutputDataReceived += new DataReceivedEventHandler(outputData.DataReceived);

            // append the command line
            outputData.Append(MSTest.msTestPath);
            outputData.Append(stringBuilder.ToString());
            outputData.Append(String.Empty);

            // start the process and wait for exit
            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
            process.WaitForExit();

            if (0 != process.ExitCode)
            {
                throw new ApplicationException("\r\n" + outputData.Data);
            }
        }

        /// <summary>
        /// Class to capture the standard error and standard output of a process
        /// </summary>
        private class OutputData
        {
            // stringBuilder is the object to capture the standard error and standard output
            private StringBuilder stringBuilder = new StringBuilder();

            /// <summary>
            /// Gets the standard error and standard output of the process
            /// </summary>
            public string Data
            {
                get { return this.stringBuilder.ToString(); }
            }

            /// <summary>
            /// Append the specific string value to the data
            /// </summary>
            /// <param name="value">The specified string value</param>
            public void Append(string value)
            {
                stringBuilder.AppendLine(value);
            }

            /// <summary>
            /// Represents the method that will handle the data received events of a process
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            public void DataReceived(object sender, DataReceivedEventArgs e)
            {
                if (null != e.Data)
                {
                    stringBuilder.AppendLine(e.Data);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildAgent.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildAgent.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a build agent in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// TfsBuildAgent exposes a methods to reference a build agent in a tfs project
    /// </summary>
    public sealed class TfsBuildAgent
    {
        /// <summary>
        /// buildAgent is the interface to the build agent object model
        /// </summary>
        private IBuildAgent buildAgent;

        /// <summary>
        /// Initializes a new instance of the TfsBuildAgent class
        /// </summary>
        /// <param name="buildAgent">The interface to the build agent object model</param>
        public TfsBuildAgent(IBuildAgent buildAgent)
        {
            this.buildAgent = buildAgent;
        }

        /// <summary>
        /// Gets the interface to the build agent object model
        /// </summary>
        internal IBuildAgent BuildAgent
        {
            get { return this.buildAgent; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuild.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuild.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a build in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.IO;
    using System.Xml.XPath;

    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// TfsBuild exposes a methods to reference a build in a tfs project
    /// </summary>
    public sealed class TfsBuild
    {
        /// <summary>
        /// buildDetail is the interface to the build detail object model
        /// </summary>
        private IBuildDetail buildDetail;

        /// <summary>
        /// tfsBuildConfigurations is the collection of build configurations for this build
        /// </summary>
        private TfsBuildConfigurationCollection tfsBuildConfigurations = new TfsBuildConfigurationCollection();

        /// <summary>
        /// tfsTestSummaries is the collection of test summaries for this build
        /// </summary>
        private TfsTestSummaryCollection tfsTestSummaries = new TfsTestSummaryCollection();

        /// <summary>
        /// Initializes a new instance of the TfsBuild class
        /// </summary>
        /// <param name="buildDetail">The interface to the build detail object model</param>
        internal TfsBuild(IBuildDetail buildDetail)
        {
            this.buildDetail = buildDetail;

            this.Refresh();
        }

        /// <summary>
        /// Gets the collection of build configurations for this build
        /// </summary>
        public TfsBuildConfigurationCollection BuildConfigurations
        {
            get { return this.tfsBuildConfigurations; }
        }

        /// <summary>
        /// Gets the build definition for this build
        /// </summary>
        public string BuildDefinition
        {
            get { return this.buildDetail.BuildDefinition.Name; }
        }

        /// <summary>
        /// Gets the drop location for this build
        /// </summary>
        public string BuildDrop
        {
            get { return this.buildDetail.DropLocation; }
        }

        /// <summary>
        /// Gets the build number for this build
        /// </summary>
        public string BuildNumber
        {
            get { return this.buildDetail.BuildNumber; }
        }

        /// <summary>
        /// Gets the quality for this build
        /// </summary>
        public string Quality
        {
            get { return this.buildDetail.Quality; }
            set { this.buildDetail.Quality = value; }
        }

        /// <summary>
        /// Gets the status for this build
        /// </summary>
        public TfsBuildStatus Status
        {
            get { return (TfsBuildStatus)this.buildDetail.Status; }
        }

        /// <summary>
        /// Gets the uri of the build
        /// </summary>
        public Uri Uri
        {
            get { return this.buildDetail.Uri; }
        }

        /// <summary>
        /// Deletes the specified build
        /// </summary>
        public void Delete()
        {
            // mark the build for deletion
            this.buildDetail.Status = BuildStatus.Stopped;
            this.buildDetail.Save();

            // delete the build
            this.buildDetail.Delete();
        }

        /// <summary>
        /// Queries the specified test results run id
        /// </summary>
        /// <param name="runId">The specified run id of the test results</param>
        /// <returns>The tfs test result instance, if found; otherwise, null</returns>
        public TfsTestSummary QueryResult(Guid runId)
        {
            return this.tfsTestSummaries[runId];
        }

        /// <summary>
        /// Publishes the specified mstest results file to the build
        /// </summary>
        /// <param name="resultsFile">The specified results file</param>
        /// <param name="flavor">The specified build flavor</param>
        /// <param name="platform">The specified build platform</param>
        /// <returns>The tfs test result instance</returns>
        public TfsTestSummary PublishResultsMSTest(string resultsFile, string flavor, string platform)
        {
            // publish the test results
            MSTest.PublishResults(Path.GetFullPath(resultsFile), this.buildDetail.BuildServer.TeamFoundationServer.Uri.ToString(), this.buildDetail.BuildDefinition.TeamProject, this.BuildNumber, flavor, platform);

            // refresh the build details
            this.Refresh();

            // get the test result run id
            Guid runId = TfsBuild.GetTestResultRunId(Path.GetFullPath(resultsFile));
            return this.QueryResult(runId);
        }

        /// <summary>
        /// Publishes the specified nunit results file to the build
        /// </summary>
        /// <param name="resultsFile">The specified results file</param>
        /// <param name="flavor">The specified build flavor</param>
        /// <param name="platform">The specified build platform</param>
        /// <returns>The tfs test result instance</returns>
        public TfsTestSummary PublishResultsNUnit(string resultsFile, string flavor, string platform)
        {
            string transformFile = Path.GetFullPath(resultsFile) + ".trx";

            // create the nunit transform instance
            NUnitTransform nunitTransform = new NUnitTransform();

            // run the transform
            string output = nunitTransform.Transform(resultsFile);

            // save the transformed xml
            using (StreamWriter streamWriter = new StreamWriter(transformFile))
            {
                streamWriter.Write(output);
            }

            // publish the test results
            return this.PublishResultsMSTest(transformFile, flavor, platform);
        }

        /// <summary>
        /// Refreshes the details of this build instance
        /// </summary>
        public void Refresh()
        {
            // refresh the build details
            this.buildDetail.RefreshAllDetails();

            // clear any existing build configurations
            this.tfsBuildConfigurations.Clear();

            // clear any existing test results
            this.tfsTestSummaries.Clear();

            // get the collection of build configurations
            foreach (IConfigurationSummary configurationSummary in InformationNodeConverters.GetConfigurationSummaries(this.buildDetail))
            {
                // Get the compilation summary
                ICompilationSummary compilationSummary = configurationSummary.CompilationSummaries[0];

                // Create the build configuration
                this.tfsBuildConfigurations.Add(new TfsBuildConfiguration(configurationSummary.Flavor, configurationSummary.Platform, configurationSummary.LogFile, compilationSummary.CompilationErrors, compilationSummary.CompilationWarnings, null));

                // Get the test summaries
                foreach (ITestSummary testSummary in configurationSummary.TestSummaries)
                {
                    Guid runId = new Guid(testSummary.RunId);

                    // Create the test result
                    this.tfsTestSummaries.Add(new TfsTestSummary(this, configurationSummary.Flavor, configurationSummary.Platform, testSummary));
                }
            }
        }

        /// <summary>
        /// Gets the test result run id from the specified results file
        /// </summary>
        /// <param name="resultsFile">The specified results file</param>
        /// <returns>The run id of the test result</returns>
        private static Guid GetTestResultRunId(string resultsFile)
        {
            using (StreamReader streamReader = LongPath.Read(resultsFile))
            {
                // load the results file
                XPathDocument xpathDocument = new XPathDocument(streamReader);
                XPathNavigator xpathNavigator = xpathDocument.CreateNavigator();

                // move to the root
                xpathNavigator.MoveToFirstChild();

                // get the id
                return new Guid(xpathNavigator.GetAttribute("id", String.Empty));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildCollection.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a collection of builds in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System.Collections.Generic;

    /// <summary>
    /// TfsBuild exposes a methods to reference a build in a tfs project
    /// </summary>
    public sealed class TfsBuildCollection : IEnumerable<TfsBuild>
    {
        /// <summary>
        /// listTfsBuild is collection of builds in a tfs project
        /// </summary>
        private List<TfsBuild> listTfsBuilds = new List<TfsBuild>();

        /// <summary>
        /// Initializes a new instance of the TfsBuildCollection class
        /// </summary>
        public TfsBuildCollection()
        {
        }

        /// <summary>
        /// Gets the build at the specified index
        /// </summary>
        /// <param name="index"></param>
        /// <returns>The build at the specified index</returns>
        public TfsBuild this[int index]
        {
            get { return this.listTfsBuilds[index]; }
        }

        /// <summary>
        /// Gets the number of builds in the collection
        /// </summary>
        public int Count
        {
            get { return this.listTfsBuilds.Count; }
        }

        /// <summary>
        /// Adds the specified build to this collection
        /// </summary>
        /// <param name="tfsBuild">The tfs build instance</param>
        public void Add(TfsBuild tfsBuild)
        {
            this.listTfsBuilds.Add(tfsBuild);
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<TfsBuild> IEnumerable<TfsBuild>.GetEnumerator()
        {
            foreach (TfsBuild tfsBuild in this.listTfsBuilds)
            {
                yield return tfsBuild;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.listTfsBuilds.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildLogs.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildLogs.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to represent a the build logs of a particular build configuration
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;

    /// <summary>
    /// TfsBuildLogs details the build logs of a particular build configuration
    /// </summary>
    public sealed class TfsBuildLogs
    {
        /// <summary>
        /// buildLogFile is the full path to the build log file
        /// </summary>
        private string buildLogFile;

        /// <summary>
        /// buildLogFileName is the name of the build log file
        /// </summary>
        private string buildLogFileName;

        /// <summary>
        /// errorLogFile is the full path to the error log file
        /// </summary>
        private string errorLogFile;

        /// <summary>
        /// errorLogFile is the name of the error log file
        /// </summary>
        private string errorLogFileName;

        /// <summary>
        /// warningLogFile is the full path to the warning log file
        /// </summary>
        private string warningLogFile;

        /// <summary>
        /// warningLogFile is the name of the warning log file
        /// </summary>
        private string warningLogFileName;

        /// <summary>
        /// Initializes a new instance of the TfsBuildLogs class
        /// </summary>
        /// <param name="buildLogFile">The full path to the build log file</param>
        /// <param name="errorLogFile">The full path to the error log file</param>
        /// <param name="warningLogFile">The full path to the warning log file</param>
        public TfsBuildLogs(string buildLogFile, string errorLogFile, string warningLogFile)
        {
            if (false == String.IsNullOrEmpty(buildLogFile))
            {
                this.buildLogFile = buildLogFile;
                this.buildLogFileName = buildLogFile.Substring(buildLogFile.LastIndexOf('\\') + 1);
            }

            if (false == String.IsNullOrEmpty(errorLogFile))
            {
                this.errorLogFile = errorLogFile;
                this.errorLogFileName = errorLogFile.Substring(errorLogFile.LastIndexOf('\\') + 1);
            }

            if (false == String.IsNullOrEmpty(warningLogFile))
            {
                this.warningLogFile = warningLogFile;
                this.warningLogFileName = warningLogFile.Substring(warningLogFile.LastIndexOf('\\') + 1);
            }
        }

        /// <summary>
        /// Gets the full path to the build log file
        /// </summary>
        internal string BuildLogFile
        {
            get { return this.buildLogFile; }
        }

        /// <summary>
        /// Gets the name of the build log file
        /// </summary>
        internal string BuildLogFileName
        {
            get { return this.buildLogFileName; }
        }

        /// <summary>
        /// Gets the full path to the error log file
        /// </summary>
        internal string ErrorLogFile
        {
            get { return this.errorLogFile; }
        }

        /// <summary>
        /// Gets the name of the error log file
        /// </summary>
        internal string ErrorLogFileName
        {
            get { return this.errorLogFileName; }
        }

        /// <summary>
        /// Gets the full path to the warning log file
        /// </summary>
        internal string WarningLogFile
        {
            get { return this.warningLogFile; }
        }

        /// <summary>
        /// Gets the name of the warning log file
        /// </summary>
        internal string WarningLogFileName
        {
            get { return this.warningLogFileName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildConfiguration.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildConfiguration.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to represent a particular build configuration
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;

    /// <summary>
    /// TfsBuildConfiguration details the results for a particular build configuration
    /// </summary>
    public sealed class TfsBuildConfiguration
    {
        /// <summary>
        /// errors is number of errors that occurred for this build configuration
        /// </summary>
        private int errors;

        /// <summary>
        /// flavor is the type of the build configuration: debug, release, etc.
        /// </summary>
        private string flavor;

        /// <summary>
        /// logFile is the full path to the most appropriate log file for the build configuration (build log file, error log file, or warning log file)
        /// </summary>
        private string logFile;

        /// <summary>
        /// logFileName is the name of the most appropriate log file for the build configuration (build log file, error log file, or warning log file)
        /// </summary>
        private string logFileName;

        /// <summary>
        /// platform is the architecture of the build: x86, amd64, etc.
        /// </summary>
        private string platform;

        /// <summary>
        /// tfsBuildLogs is the build logs for this build configuration
        /// </summary>
        private TfsBuildLogs tfsBuildLogs;

        /// <summary>
        /// warnings is the number of warnings that occurred for this build configuration
        /// </summary>
        private int warnings;

        /// <summary>
        /// Initializes a new instance of the TfsBuildConfiguration class
        /// </summary>
        /// <param name="flavor">Specifies the type of the build configuration: debug, release, etc.</param>
        /// <param name="platform">Specifies the architecture of the build configuration: x86, amd64, etc.</param>
        public TfsBuildConfiguration(string flavor, string platform)
        {
            this.flavor = flavor;
            this.platform = platform;
        }

        /// <summary>
        /// Initializes a new instance of the TfsBuildConfiguration class
        /// </summary>
        /// <param name="flavor">Specifies the type of the build configuration: debug, release, etc.</param>
        /// <param name="platform">Specifies the architecture of the build configuration: x86, amd64, etc.</param>
        /// <param name="logFile">The full path to the build log file</param>
        /// <param name="errors">The number of errors for this build configuration</param>
        /// <param name="warnings">The number of warnings for this build configuration</param>
        /// <param name="tfsBuildLogs">The build logs for this build configuration</param>
        public TfsBuildConfiguration(string flavor, string platform, string logFile, int errors, int warnings, TfsBuildLogs tfsBuildLogs)
            : this(flavor, platform)
        {
            if (false == String.IsNullOrEmpty(logFile))
            {
                this.logFile = logFile;
                this.logFileName = logFile.Substring(logFile.LastIndexOf('\\') + 1);
            }

            this.errors = errors;
            this.warnings = warnings;
            this.tfsBuildLogs = tfsBuildLogs;
        }

        /// <summary>
        /// Gets the number of errors that occurred for this build
        /// </summary>
        public int Errors
        {
            get { return this.errors; }
        }

        /// <summary>
        /// Gets the type of the build: debug, release, etc.
        /// </summary>
        public string Flavor
        {
            get { return this.flavor; }
        }

        /// <summary>
        /// Gets the full path to the log file for this build
        /// </summary>
        public string LogFile
        {
            get { return this.logFile; }
        }

        /// <summary>
        /// Gets the name of the log file for this build
        /// </summary>
        public string LogFileName
        {
            get { return this.logFileName; }
        }

        /// <summary>
        /// Gets the architecture of the build: x86, amd64, etc.
        /// </summary>
        public string Platform
        {
            get { return this.platform; }
        }

        /// <summary>
        /// Gets the number of warnings that occurred for this build
        /// </summary>
        public int Warnings
        {
            get { return this.warnings; }
        }

        /// <summary>
        /// Gets the build logs for this build configuration
        /// </summary>
        internal TfsBuildLogs BuildLogs
        {
            get { return this.tfsBuildLogs; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildConfigurationCollection.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildConfigurationCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a collection of build configurations for a build
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System.Collections.Generic;

    /// <summary>
    /// TfsBuildConfigurationCollection represents a collection of build configurations for a build
    /// </summary>
    public sealed class TfsBuildConfigurationCollection : IEnumerable<TfsBuildConfiguration>
    {
        /// <summary>
        /// listTfsBuildConfigurations is collection of build configurations for a build
        /// </summary>
        private List<TfsBuildConfiguration> listTfsBuildConfigurations = new List<TfsBuildConfiguration>();

        /// <summary>
        /// Initializes a new instance of the TfsBuildConfigurationCollection class
        /// </summary>
        public TfsBuildConfigurationCollection()
        {
        }

        /// <summary>
        /// Gets the number of build configurations in the collection
        /// </summary>
        public int Count
        {
            get { return this.listTfsBuildConfigurations.Count; }
        }

        /// <summary>
        /// Adds the specified build configuration to this collection
        /// </summary>
        /// <param name="tfsBuildConfiguration">The tfs build configuration instance</param>
        public void Add(TfsBuildConfiguration tfsBuildConfiguration)
        {
            this.listTfsBuildConfigurations.Add(tfsBuildConfiguration);
        }

        /// <summary>
        /// Removes all build configurations from the collection
        /// </summary>
        public void Clear()
        {
            this.listTfsBuildConfigurations.Clear();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<TfsBuildConfiguration> IEnumerable<TfsBuildConfiguration>.GetEnumerator()
        {
            foreach (TfsBuildConfiguration tfsBuildConfiguration in this.listTfsBuildConfigurations)
            {
                yield return tfsBuildConfiguration;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.listTfsBuildConfigurations.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildQualityCollection.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildQualityCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a collection of build qualities
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System.Collections.Generic;

    /// <summary>
    /// TfsBuildQualityCollection represents a collection of build qualities
    /// </summary>
    public sealed class TfsBuildQualityCollection : IEnumerable<string>
    {
        /// <summary>
        /// collectionTfsBuildQualities is collection of build qualities
        /// </summary>
        private Dictionary<string, string> collectionTfsBuildQualities = new Dictionary<string, string>();

        /// <summary>
        /// Initializes a new instance of the TfsBuildConfigurationCollection class
        /// </summary>
        internal TfsBuildQualityCollection(IEnumerable<string> buildQualities)
        {
            foreach (string buildQuality in buildQualities)
            {
                collectionTfsBuildQualities[buildQuality.ToLower()] = buildQuality;
            }
        }

        /// <summary>
        /// Gets the build quality at the specified index
        /// </summary>
        /// <param name="index">The specified index</param>
        /// <returns>The build quality at the specified index</returns>
        public string this[string index]
        {
            get { return this.collectionTfsBuildQualities[index.ToLower()]; }
        }

        /// <summary>
        /// Gets the number of build qualities in the collection
        /// </summary>
        public int Count
        {
            get { return this.collectionTfsBuildQualities.Count; }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<string> IEnumerable<string>.GetEnumerator()
        {
            foreach (string buildQuality in this.collectionTfsBuildQualities.Values)
            {
                yield return buildQuality;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.collectionTfsBuildQualities.Values.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildSpec.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildSpec.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to define the query conditions for a build
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;

    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// TfsBuildSpec defines the query conditions for a build
    /// </summary>
    public sealed class TfsBuildSpec
    {
        /// <summary>
        /// buildNumber defines the build number of the specified build or builds.  Wildcard characters are supported.
        /// </summary>
        private string buildNumber = "*";

        /// <summary>
        /// buildQuality defines the build quality
        /// </summary>
        private string buildQuality;

        /// <summary>
        /// tfsBuildStatus defines the build status
        /// </summary>
        private TfsBuildStatus tfsBuildStatus;

        /// <summary>
        /// Initializes a new instance of the TfsBuildSpec class
        /// </summary>
        public TfsBuildSpec()
        {
            foreach (TfsBuildStatus tfsBuildStatusEnum in Enum.GetValues(typeof(TfsBuildStatus)))
            {
                this.tfsBuildStatus |= tfsBuildStatusEnum;
            }
        }

        /// <summary>
        /// Gets or sets the build number of the desired build or builds.  Wildcard characters are supported.
        /// </summary>
        public string BuildNumber
        {
            get { return this.buildNumber; }
            set { this.buildNumber = value; }
        }

        /// <summary>
        /// Gets or sets the build quality of the desired build or builds.
        /// </summary>
        public string Quality
        {
            get { return this.buildQuality; }
            set { this.buildQuality = value; }
        }

        /// <summary>
        /// Gets or sets the build status of the desired build or builds.
        /// </summary>
        public TfsBuildStatus Status
        {
            get { return this.tfsBuildStatus; }
            set { this.tfsBuildStatus = value; }
        }

        /// <summary>
        /// Sets the build detail spec with the conditions specified
        /// </summary>
        /// <param name="buildDetailSpec"></param>
        internal void SetBuildDetailSpec(IBuildDetailSpec buildDetailSpec)
        {
            buildDetailSpec.BuildNumber = this.buildNumber;
            buildDetailSpec.Quality = buildQuality;
            buildDetailSpec.Status = (BuildStatus)this.tfsBuildStatus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildStatus.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildStatus.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   enum to define the build status
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// Defines the build status
    /// </summary>
    public enum TfsBuildStatus
    {
        /// <summary>
        /// The build has not started
        /// </summary>
        NotStarted = BuildStatus.NotStarted,

        /// <summary>
        /// The build is in progress
        /// </summary>
        InProgress = BuildStatus.InProgress,

        /// <summary>
        /// The build is stopped
        /// </summary>
        Stopped = BuildStatus.Stopped,

        /// <summary>
        /// The build failed
        /// </summary>
        Failed = BuildStatus.Failed,

        /// <summary>
        /// The build partially succeeded
        /// </summary>
        PartiallySucceeded = BuildStatus.PartiallySucceeded,

        /// <summary>
        /// The build succeeded
        /// </summary>
        Succeeded = BuildStatus.Succeeded
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsBuildDefinition.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsBuildDefinition.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a build definition in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.IO;
    using System.Web.Services.Protocols;

    using IWshRuntimeLibrary;

    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// TfsBuild exposes a methods to reference a build definition in a tfs project
    /// </summary>
    public sealed class TfsBuildDefinition
    {
        /// <summary>
        /// buildDefinition is the interface to the build definition object model
        /// </summary>
        private IBuildDefinition buildDefinition;

        /// <summary>
        /// Initializes a new instance of the TfsBuildDefinition class
        /// </summary>
        /// <param name="buildDefinition">The interface to the build definition object model</param>
        internal TfsBuildDefinition(IBuildDefinition buildDefinition)
        {
            this.buildDefinition = buildDefinition;
        }

        /// <summary>
        /// Create a build with the specified build number and configurations
        /// </summary>
        /// <param name="buildNumber">The specified build number to use for this build</param>
        /// <param name="buildDropLocation">The path to the original build drop location</param>
        /// <param name="tfsBuildConfigurations">The collection of configurations to use for this build</param>
        /// <returns>The tfs build instance</returns>
        public TfsBuild CreateBuild(string buildNumber, string buildDropLocation, TfsBuildConfigurationCollection tfsBuildConfigurations)
        {
            if ((null == tfsBuildConfigurations) || (0 == tfsBuildConfigurations.Count))
            {
                throw new ArgumentException("No build configurations specified", "tfsBuildConfigurations");
            }

            // Create the build detail
            IBuildDetail buildDetail = this.CreateBuildDetail(buildNumber);

            // Create the configuration and compilation summary
            this.CreateSummary(buildDetail, tfsBuildConfigurations);

            // Create the drop location
            this.CreateDropLocation(buildDetail, tfsBuildConfigurations);

            // Create the drop shortcut
            this.CreateDropShortcut(buildDetail, buildDropLocation);

            // Create the build uri file
            this.CreateDropBuildUri(buildDetail);

            // Save the build detail
            buildDetail.Save();

            return new TfsBuild(buildDetail);
        }

        /// <summary>
        /// Queries all of the builds matching the specified build spec
        /// </summary>
        /// <param name="tfsBuildSpec">The tfs build spec defining the query conditions for the builds
        /// <returns>The collection of builds matching the specified build spec</returns>
        public TfsBuildCollection QueryBuilds(TfsBuildSpec tfsBuildSpec)
        {
            // create the build detail specification to query for builds
            IBuildDetailSpec buildDetailSpec = this.buildDefinition.BuildServer.CreateBuildDetailSpec(this.buildDefinition);

            // set the build detail specification
            tfsBuildSpec.SetBuildDetailSpec(buildDetailSpec);

            // query the builds
            IBuildQueryResult buildQueryResult = this.buildDefinition.BuildServer.QueryBuilds(buildDetailSpec);

            TfsBuildCollection tfsBuildCollection = new TfsBuildCollection();
            foreach (IBuildDetail buildDetail in buildQueryResult.Builds)
            {
                tfsBuildCollection.Add(new TfsBuild(buildDetail));
            }

            return tfsBuildCollection;
        }

        /// <summary>
        /// Creates a build detail using the specified build number
        /// If a matching build detail already exists, it will get that build detail
        /// </summary>
        /// <param name="buildNumber">The specified build number</param>
        /// <returns>The interface to the build detail object model</returns>
        private IBuildDetail CreateBuildDetail(string buildNumber)
        {
            try
            {
                // Create the build detail
                IBuildDetail buildDetail = this.buildDefinition.CreateManualBuild(buildNumber);

                // Set the build drop location
                buildDetail.DropLocation = this.buildDefinition.DefaultDropLocation + "\\" + buildNumber;

                return buildDetail;
            }
            catch (BuildNumberAlreadyExistsException)
            {
                // Get the build detail
                return this.GetBuildDetail(buildNumber);
            }
            catch (SoapException ex)
            {
                if (false == ex.Message.StartsWith("TF42064:"))
                {
                    throw;
                }

                // Get the build detail
                return this.GetBuildDetail(buildNumber);
            }
        }

        /// <summary>
        /// Creates the directories under the build drop location
        /// </summary>
        /// <param name="buildDetail">The interface to the build detail object model</param>
        /// <param name="tfsBuildConfigurations">The collection of build configurations for this build</param>
        private void CreateDropLocation(IBuildDetail buildDetail, TfsBuildConfigurationCollection tfsBuildConfigurations)
        {
            // Create the root directory
            LongPath.CreateDirectory(buildDetail.BuildDefinition.DefaultDropLocation, false);

            // Create the build number directory
            LongPath.CreateDirectory(buildDetail.DropLocation, false);

            // Create the build logs directory
            string buildLogShare = buildDetail.DropLocation + "\\Logs";
            LongPath.CreateDirectory(buildLogShare, false);

            // Copy the log files
            foreach (TfsBuildConfiguration tfsBuildConfiguration in tfsBuildConfigurations)
            {
                if (null == tfsBuildConfiguration.BuildLogs)
                {
                    continue;
                }

                LongPath.Copy(tfsBuildConfiguration.BuildLogs.BuildLogFile, buildLogShare + "\\" + tfsBuildConfiguration.BuildLogs.BuildLogFileName, false);
                LongPath.Copy(tfsBuildConfiguration.BuildLogs.ErrorLogFile, buildLogShare + "\\" + tfsBuildConfiguration.BuildLogs.ErrorLogFileName, false);
                LongPath.Copy(tfsBuildConfiguration.BuildLogs.WarningLogFile, buildLogShare + "\\" + tfsBuildConfiguration.BuildLogs.WarningLogFileName, false);
            }
        }

        /// <summary>
        /// Create the shortcut to the original build drop location
        /// </summary>
        /// <param name="buildDetail">The interface to the build detail object model</param>
        /// <param name="buildDropLocation">The path to the original build drop location</param>
        private void CreateDropShortcut(IBuildDetail buildDetail, string buildDropLocation)
        {
            if (true == String.IsNullOrEmpty(buildDropLocation))
            {
                return;
            }

            // Create the shortcut to the original build drop location
            WshShellClass wshShellClass = new WshShellClass();

            IWshRuntimeLibrary.IWshShortcut wshShortcut = wshShellClass.CreateShortcut(Directory.GetCurrentDirectory() + "\\BuildDropLocation.lnk") as IWshRuntimeLibrary.IWshShortcut;
            wshShortcut.TargetPath = buildDropLocation;
            wshShortcut.Save();

            // Copy the shortcut
            LongPath.Copy(Directory.GetCurrentDirectory() + "\\BuildDropLocation.lnk", buildDetail.DropLocation + "\\BuildDropLocation.lnk", false);
            LongPath.Delete(Directory.GetCurrentDirectory() + "\\BuildDropLocation.lnk");
        }

        /// <summary>
        /// Create a text file on the drop location that specified the build uri
        /// </summary>
        /// <param name="buildDetail">The interface to the build detail object model</param>
        private void CreateDropBuildUri(IBuildDetail buildDetail)
        {
            using (StreamWriter streamWriter = LongPath.Write(buildDetail.DropLocation + "\\BuildUri.txt"))
            {
                streamWriter.WriteLine(buildDetail.Uri);
            }
        }

        /// <summary>
        /// Creates the configuration summary and the compilation summary
        /// </summary>
        /// <param name="buildDetail">The interface to the build detail object model</param>
        /// <param name="tfsBuildConfigurations">The collection of build configurations for this build</param>
        private void CreateSummary(IBuildDetail buildDetail, TfsBuildConfigurationCollection tfsBuildConfigurations)
        {
            int errors = 0;
            int warnings = 0;

            foreach (TfsBuildConfiguration tfsBuildConfiguration in tfsBuildConfigurations)
            {
                // Check if the configuration summary already exists
                IConfigurationSummary configurationSummary = InformationNodeConverters.GetConfigurationSummary(buildDetail, tfsBuildConfiguration.Flavor, tfsBuildConfiguration.Platform);
                if (null != configurationSummary)
                {
                    continue;
                }

                // Create the configuration summary
                string logFile = String.Empty;
                if (false == String.IsNullOrEmpty(tfsBuildConfiguration.LogFileName))
                {
                    string buildLogShare = buildDetail.DropLocation + "\\Logs";
                    logFile = buildLogShare + "\\" + tfsBuildConfiguration.LogFileName;
                }

                configurationSummary = InformationNodeConverters.AddConfigurationSummary(buildDetail, tfsBuildConfiguration.Flavor, tfsBuildConfiguration.Platform, logFile);

                // Create the compilation summary
                ICompilationSummary compilationSummary = configurationSummary.AddCompilationSummary();

                compilationSummary.CompilationErrors = tfsBuildConfiguration.Errors;
                compilationSummary.CompilationWarnings = tfsBuildConfiguration.Warnings;

                errors += tfsBuildConfiguration.Errors;
                warnings += tfsBuildConfiguration.Warnings;

                // Save the compilation summary
                compilationSummary.Save();

                // Save the configuration summary
                configurationSummary.Save();
            }

            // Set the build status
            if (0 < errors)
            {
                buildDetail.CompilationStatus = BuildPhaseStatus.Failed;
                buildDetail.Status = BuildStatus.Failed;
            }
            else if (0 < warnings)
            {
                buildDetail.CompilationStatus = BuildPhaseStatus.Unknown;
                buildDetail.Status = BuildStatus.PartiallySucceeded;
            }
            else
            {
                buildDetail.CompilationStatus = BuildPhaseStatus.Succeeded;
                buildDetail.Status = BuildStatus.Succeeded;
            }
        }

        /// <summary>
        /// Gets the build detail with the specified build number
        /// </summary>
        /// <param name="buildNumber">The specified build number</param>
        /// <returns>The interface to the build detail object model</returns>
        private IBuildDetail GetBuildDetail(string buildNumber)
        {
            foreach (IBuildDetail buildDetail in this.buildDefinition.QueryBuilds())
            {
                if (0 == String.Compare(buildDetail.BuildNumber, buildNumber, true))
                {
                    return buildDetail;
                }
            }

            throw new BuildNotFoundException(buildNumber, this.buildDefinition.Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsHelper.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly to expose tfs helper classes
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsTestSummaryCollection.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsTestSummaryCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a collection of test results for a build
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// TfsTestSummaryCollection represents a collection of test summaries for a build
    /// </summary>
    public sealed class TfsTestSummaryCollection : IEnumerable<TfsTestSummary>
    {
        /// <summary>
        /// collectionTfsTestSummaries is collection of test summaries for a build
        /// </summary>
        private Dictionary<Guid, TfsTestSummary> collectionTfsTestSummaries = new Dictionary<Guid, TfsTestSummary>();

        /// <summary>
        /// Initializes a new instance of the TfsTestSummaryCollection class
        /// </summary>
        public TfsTestSummaryCollection()
        {
        }

        /// <summary>
        /// Returns the tfs test result at the specified index in the collection
        /// </summary>
        /// <param name="index">The run id of the test result to return</param>
        /// <returns>The tfs test result at the specified index if it exists; otherwise, null</returns>
        public TfsTestSummary this[Guid index]
        {
            get
            {
                if (false == this.collectionTfsTestSummaries.ContainsKey(index))
                {
                    return default(TfsTestSummary);
                }

                return this.collectionTfsTestSummaries[index];
            }
        }

        /// <summary>
        /// Adds the specified test result to this collection
        /// </summary>
        /// <param name="tfsTestSummary">The tfs test summary instance</param>
        public void Add(TfsTestSummary tfsTestSummary)
        {
            this.collectionTfsTestSummaries[tfsTestSummary.RunId] = tfsTestSummary;
        }

        /// <summary>
        /// Gets the number of test results in the collection
        /// </summary>
        public int Count
        {
            get { return this.collectionTfsTestSummaries.Count; }
        }

        /// <summary>
        /// Removes all build configurations from the collection
        /// </summary>
        public void Clear()
        {
            this.collectionTfsTestSummaries.Clear();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<TfsTestSummary> IEnumerable<TfsTestSummary>.GetEnumerator()
        {
            foreach (TfsTestSummary tfsTestSummary in this.collectionTfsTestSummaries.Values)
            {
                yield return tfsTestSummary;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.collectionTfsTestSummaries.Values.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\XmlTextWriterCRLF.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="XmlTextWriterCRLF.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   writes the specified xml data with an extra cr lf if one is specified
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System.IO;
    using System.Xml;

    /// <summary>
    /// Class to write the specified xml data with an extra cr lf if one is specified
    /// </summary>
    internal sealed class XmlTextWriterCRLF : XmlTextWriter
    {
        private int indentCount = 0;

        /// <summary>
        /// Initializes a new instance of the XmlTextWriterCRLF class
        /// </summary>
        /// <param name="textWriter">The TextWriter to write to</param>
        public XmlTextWriterCRLF(TextWriter textWriter)
            : base(textWriter)
        {
        }

        /// <summary>
        /// Closes the open element
        /// </summary>
        public override void WriteEndElement()
        {
            indentCount--;
            base.WriteEndElement();
        }

        /// <summary>
        /// Writes the specified start tag
        /// </summary>
        /// <param name="prefix">The namespace prefix of the element</param>
        /// <param name="localName">The local name of the element</param>
        /// <param name="ns">The namespace URI to associate with the element</param>
        public override void WriteStartElement(string prefix, string localName, string ns)
        {
            indentCount++;
            base.WriteStartElement(prefix, localName, ns);
        }

        /// <summary>
        /// Writes the given text context
        /// </summary>
        /// <param name="text">Text to write</param>
        public override void WriteString(string text)
        {
            if (true == text.Contains("\n"))
            {
                // get the indentation
                string indentString = new string(base.IndentChar, base.Indentation * indentCount);
                string indentEnd = new string(base.IndentChar, base.Indentation * (indentCount - 1));

                base.WriteWhitespace("\r\n" + indentString);

                base.WriteString(text.Replace("\n", "\r\n" + indentString));

                base.WriteWhitespace("\r\n" + indentEnd);
            }
            else
            {
                base.WriteString(text);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\ClientBuildDefinition.cs ===
//-----------------------------------------------------------------------
// <copyright file="ClientBuildDefinition.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe a client build definition
// </summary>
//-----------------------------------------------------------------------

namespace TfsMonitorXenon
{
    using System;
    using System.Collections.Generic;
    using System.Xml.Serialization;

    /// <summary>
    /// Class to describe a client build configuration
    /// </summary>
    [Serializable()]
    public class ClientBuildDefinition
    {
        /// <summary>
        /// buildNumberFormat specifies the string format of the build number
        /// </summary>
        private string buildNumberFormat;

        /// <summary>
        /// buildNumberRegex specifies the regular expression to parse the build number
        /// </summary>
        private string buildNumberRegex;

        /// <summary>
        /// buildRoot specifies the root of the build path
        /// </summary>
        private string buildRoot;

        /// <summary>
        /// buildConfigurations is the collection of build configurations for this build definition
        /// </summary>
        private List<ClientBuildConfiguration> clientBuildConfigurations;

        /// <summary>
        /// latestFile specifies the name of the file specifying the latest build number for this build definition
        /// </summary>
        private string latestFile;

        /// <summary>
        /// name specifies the name of this build definition
        /// </summary>
        private string name;

        /// <summary>
        /// nextBuildNumber specifies the next build number for this build definition
        /// </summary>
        private int nextBuildNumber;

        /// <summary>
        /// Initializes a new instance of the ClientBuildDefinition class
        /// </summary>
        internal ClientBuildDefinition()
        {
        }

        /// <summary>
        /// Gets or sets the name of this build definition
        /// </summary>
        public string Name
        {
            get { return this.name; }
            set { this.name = value; }
        }

        /// <summary>
        /// Gets or sets the root of the build path
        /// </summary>
        public string BuildRoot
        {
            get { return this.buildRoot; }
            set { this.buildRoot = value; }
        }

        /// <summary>
        /// Gets or sets the name of the file specifying the latest build number for this build definition
        /// </summary>
        public string LatestFile
        {
            get { return this.latestFile; }
            set { this.latestFile = value; }
        }

        /// <summary>
        /// Gets or sets the string format of the build number
        /// </summary>
        public string BuildNumberFormat
        {
            get { return this.buildNumberFormat; }
            set { this.buildNumberFormat = value; }
        }

        /// <summary>
        /// Gets or sets the regular expression to parse the build number
        /// </summary>
        public string BuildNumberRegex
        {
            get { return this.buildNumberRegex; }
            set { this.buildNumberRegex = value; }
        }

        /// <summary>
        /// Gets or sets the next build number for this build definition
        /// </summary>
        public int NextBuildNumber
        {
            get { return this.nextBuildNumber; }
            set { this.nextBuildNumber = value; }
        }

        /// <summary>
        /// Gets or sets the collection of build configurations for this build definition
        /// </summary>
        [XmlIgnore]
        public List<ClientBuildConfiguration> ClientBuildConfigurations
        {
            get { return this.clientBuildConfigurations; }
            set { this.clientBuildConfigurations = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsProject.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsProject.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;

    using Microsoft.TeamFoundation.Build.Client;
    using Microsoft.TeamFoundation.Client;
    using Microsoft.TeamFoundation.WorkItemTracking.Client;

    /// <summary>
    /// TfsProject exposes a method to create a build in a tfs project
    /// </summary>
    public sealed class TfsProject : IDisposable
    {
        /// <summary>
        /// buildServer is the interface to the build server object model
        /// </summary>
        private IBuildServer buildServer;

        /// <summary>
        /// projectName is the name of the tfs project
        /// </summary>
        private string projectName;

        /// <summary>
        /// teamFoundationServer is the interface to the team foundation server object model
        /// </summary>
        private TeamFoundationServer teamFoundationServer;

        /// <summary>
        /// Initializes a new instance of the TfsProject class with the specified server and project
        /// </summary>
        /// <param name="serverName">The specified tfs server name</param>
        /// <param name="projectName">The specified tfs project name</param>
        public TfsProject(string serverName, string projectName)
        {
            // Get the interface to the team foundation server object model
            this.teamFoundationServer = new TeamFoundationServer(serverName);
            this.projectName = projectName;

            // Get the interface to the build server object model
            this.buildServer = (IBuildServer)this.teamFoundationServer.GetService(typeof(IBuildServer));
        }

        /// <summary>
        /// Gets the interface to the build server object model
        /// </summary>
        internal IBuildServer BuildServer
        {
            get { return this.buildServer; }
        }

        /// <summary>
        /// Creates a build agent using the tfs server name
        /// If a matching build agent already exists, it will return that build agent
        /// </summary>
        /// <returns>The tfs build agent instance</returns>
        public TfsBuildAgent CreateBuildAgent()
        {
            try
            {
                // Create the build agent
                IBuildAgent buildAgent = this.buildServer.CreateBuildAgent(this.projectName);

                // Set the build agent
                buildAgent.MachineName = this.teamFoundationServer.Name;
                buildAgent.Name = this.teamFoundationServer.Name;

                // Save the build agent
                this.buildServer.SaveBuildAgents(new IBuildAgent[] { buildAgent });

                return new TfsBuildAgent(buildAgent);
            }
            catch (BuildAgentAlreadyExistsException)
            {
                // Get the build agent
                return this.GetBuildAgent();
            }
        }

        /// <summary>
        /// Creates a build definition using the specified build definition name
        /// If a matching build definition already exists, it will get that build definition
        /// </summary>
        /// <param name="buildDefinitionName">The name of the build definition</param>
        /// <param name="buildDropLocation">The path to the build drop location</param>
        /// <returns>The tfs build definition instance</returns>
        public TfsBuildDefinition CreateBuildDefinition(string buildDefinitionName, string buildDropLocation)
        {
            TfsBuildAgent tfsBuildAgent = this.GetBuildAgent();

            try
            {
                // Create the build definition
                IBuildDefinition buildDefinition = this.buildServer.CreateBuildDefinition(this.projectName);

                // Set the build definition
                buildDefinition.ConfigurationFolderPath = String.Format(@"$/{0}", this.projectName);
                buildDefinition.DefaultBuildAgent = tfsBuildAgent.BuildAgent;
                buildDefinition.DefaultDropLocation = String.Format(@"{0}\{1}", buildDropLocation, buildDefinitionName);
                buildDefinition.Name = buildDefinitionName;

                // Save the build definition
                this.buildServer.SaveBuildDefinitions(new IBuildDefinition[] { buildDefinition });

                return new TfsBuildDefinition(buildDefinition);
            }
            catch (BuildDefinitionAlreadyExistsException)
            {
                // Get the build definition
                return this.GetBuildDefinition(buildDefinitionName);
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        public void Dispose(bool disposing)
        {
            if (true == disposing)
            {
                if (null != this.teamFoundationServer)
                {
                    this.teamFoundationServer.Dispose();
                }
            }
        }

        /// <summary>
        /// Gets the build agent with the specified tfs server name.
        /// </summary>
        /// <returns>The tfs build agent instance</returns>
        public TfsBuildAgent GetBuildAgent()
        {
            // Get the build agents
            foreach (IBuildAgent buildAgent in this.buildServer.QueryBuildAgents(this.projectName))
            {
                if (0 == String.Compare(buildAgent.Name, this.buildServer.TeamFoundationServer.Name, true))
                {
                    return new TfsBuildAgent(buildAgent);
                }
            }

            throw new BuildAgentDoesNotExistException("A build agent does not exist for the specified project.  Please contact the system administrator.");
        }

        /// <summary>
        /// Gets the build definition with the specified build definition name.
        /// </summary>
        /// <param name="buildDefinitionName">The name of the build definition.</param>
        /// <returns>The tfs build definition instance</returns>
        public TfsBuildDefinition GetBuildDefinition(string buildDefinitionName)
        {
            // Get the build definitions
            foreach (IBuildDefinition buildDefinition in this.buildServer.QueryBuildDefinitions(this.projectName))
            {
                if (0 == String.Compare(buildDefinition.Name, buildDefinitionName, true))
                {
                    return new TfsBuildDefinition(buildDefinition);
                }
            }

            throw new BuildDefinitionDoesNotExistException("The specified build definition does not exist for the specified project.  Please contact the system administrator.");
        }

        /// <summary>
        /// Gets the collection of build qualities for the project
        /// </summary>
        /// <returns></returns>
        public TfsBuildQualityCollection GetBuildQualities()
        {
            // Get the build qualities
            string[] buildQualities = this.buildServer.GetBuildQualities(this.projectName);

            return new TfsBuildQualityCollection(buildQualities);
        }

        /// <summary>
        /// Queries all of the builds matching the specified build spec
        /// </summary>
        /// <param name="tfsBuildSpec">The tfs build spec defining the query conditions for the builds
        /// <returns>The collection of builds matching the specified build spec</returns>
        public TfsBuildCollection QueryBuilds(TfsBuildSpec tfsBuildSpec)
        {
            // create the build detail specification to query for builds
            IBuildDetailSpec buildDetailSpec = this.buildServer.CreateBuildDetailSpec(this.projectName);

            // set the build detail specification
            tfsBuildSpec.SetBuildDetailSpec(buildDetailSpec);

            // query the builds
            IBuildQueryResult buildQueryResult = this.buildServer.QueryBuilds(buildDetailSpec);

            TfsBuildCollection tfsBuildCollection = new TfsBuildCollection();
            foreach (IBuildDetail buildDetail in buildQueryResult.Builds)
            {
                tfsBuildCollection.Add(new TfsBuild(buildDetail));
            }

            return tfsBuildCollection;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\TfsTestSummary.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsTestSummary.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to reference a test result in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsHelper
{
    using System;
    using System.IO;

    using Microsoft.TeamFoundation.Build.Client;

    /// <summary>
    /// TfsTestSummary exposes a methods to reference a test summary in a tfs project
    /// </summary>
    public sealed class TfsTestSummary
    {
        /// <summary>
        /// flavor is the type of the build configuration: debug, release, etc.
        /// </summary>
        private string flavor;

        /// <summary>
        /// platform is the architecture of the build: x86, amd64, etc.
        /// </summary>
        private string platform;

        /// <summary>
        /// testSummary is the interface to the test summary
        /// </summary>
        private ITestSummary testSummary;

        /// <summary>
        /// tfsBuild is the instance of the tfs build object
        /// </summary>
        private TfsBuild tfsBuild;

        /// <summary>
        /// Initializes a new instance of the TfsTestSummary class
        /// </summary>
        /// <param name="tfsBuild">The instance of the tfs build object</param>
        /// <param name="flavor">Specifies the type of the build configuration: debug, release, etc.</param>
        /// <param name="platform">Specifies the architecture of the build configuration: x86, amd64, etc.</param>
        /// <param name="testSummary">The interface to the test result object model</param>
        internal TfsTestSummary(TfsBuild tfsBuild, string flavor, string platform, ITestSummary testSummary)
        {
            this.tfsBuild = tfsBuild;
            this.flavor = flavor;
            this.platform = platform;
            this.testSummary = testSummary;
        }

        /// <summary>
        /// Gets the name of the test result
        /// </summary>
        public string Name
        {
            get { return this.testSummary.Name; }
        }

        /// <summary>
        /// Gets the run id of the test result
        /// </summary>
        public Guid RunId
        {
            get { return new Guid(this.testSummary.RunId); }
        }

        /// <summary>
        /// Gets the user who initiated the test result
        /// </summary>
        public string RunUser
        {
            get { return this.testSummary.RunUser; }
        }

        /// <summary>
        /// Gets the number of tests that failed
        /// </summary>
        public int TestsFailed
        {
            get { return this.testSummary.TestsFailed; }
        }

        /// <summary>
        /// Gets the number of tests that passed
        /// </summary>
        public int TestsPassed
        {
            get { return this.testSummary.TestsPassed; }
        }

        /// <summary>
        /// Gets the total number of tests
        /// </summary>
        public int TestsTotal
        {
            get { return this.testSummary.TestsTotal; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\ClientBuildConfiguration.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ClientBuildConfiguration.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe a client build configuration
// </summary>
//-----------------------------------------------------------------------

namespace TfsMonitorXenon
{
    using System;

    /// <summary>
    /// Class to describe a client build configuration
    /// </summary>
    [Serializable()]
    public class ClientBuildConfiguration
    {
        /// <summary>
        /// buildLog specifies the relative path to the build log file
        /// </summary>
        private string buildLog;

        /// <summary>
        /// errorLog specifies the relative path to the error log file
        /// </summary>
        private string errorLog;

        /// <summary>
        /// flavor specifies the configuration flavor
        /// </summary>
        private string flavor;

        /// <summary>
        /// path specifies the path to this build configuration
        /// </summary>
        private string path;

        /// <summary>
        /// platform specifies the configuration platform
        /// </summary>
        private string platform;

        /// <summary>
        /// warningLog specifies the relative path to the warning log file
        /// </summary>
        private string warningLog;

        /// <summary>
        /// Initializes a new instance of the ClientBuildConfiguration class
        /// </summary>
        internal ClientBuildConfiguration()
        {
        }

        /// <summary>
        /// Gets or sets the platform for this build configuration
        /// </summary>
        public string Platform
        {
            get { return this.platform; }
            set { this.platform = value; }
        }

        /// <summary>
        /// Gets or sets the flavor for this build configuration
        /// </summary>
        public string Flavor
        {
            get { return this.flavor; }
            set { this.flavor = value; }
        }

        /// <summary>
        /// Gets or sets the path to this build configuration
        /// </summary>
        public string Path
        {
            get { return this.path; }
            set { this.path = value; }
        }

        /// <summary>
        /// Gets or sets the relative path to the build log file
        /// </summary>
        public string BuildLog
        {
            get { return this.buildLog; }
            set { this.buildLog = value; }
        }

        /// <summary>
        /// Gets or sets the relative path to the error log file
        /// </summary>
        public string ErrorLog
        {
            get { return this.errorLog; }
            set { this.errorLog = value; }
        }

        /// <summary>
        /// Gets or sets the relative path to the warning log file
        /// </summary>
        public string WarningLog
        {
            get { return this.warningLog; }
            set { this.warningLog = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsHelper\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsHelper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsHelper")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7999249c-4d60-4645-9f00-ab2ae1552b0a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\TestRun.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TestRun.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe a test run
// </summary>
//-----------------------------------------------------------------------

namespace TfsMonitorXenon
{
    using System;
    using System.Xml.Serialization;

    using TfsHelper;

    /// <summary>
    /// Class to describe a test run
    /// </summary>
    [Serializable()]
    public class TestRun : IEquatable<TestRun>
    {
        /// <summary>
        /// buildNumber is the build number for this test run
        /// </summary>
        private int buildNumber;

        /// <summary>
        /// clientBuildDefinition is the client build definition for this test run
        /// </summary>
        private string clientBuildDefinition;

        /// <summary>
        /// flavor is the configuration flavor for this test run
        /// </summary>
        private string flavor;

        /// <summary>
        /// path is the path to the test run file
        /// </summary>
        private string path;

        /// <summary>
        /// platform is the configuration platform for this test run
        /// </summary>
        private string platform;

        /// <summary>
        /// tfsBuild is the tfs build instance
        /// </summary>
        private TfsBuild tfsBuild;

        /// <summary>
        /// Initializes a new instance of the TestRun class
        /// </summary>
        internal TestRun()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TestRun class
        /// </summary>
        internal TestRun(string clientBuildDefinition, int buildNumber, string platform, string flavor, string path, TfsBuild tfsBuild)
        {
            this.clientBuildDefinition = clientBuildDefinition;
            this.buildNumber = buildNumber;
            this.platform = platform;
            this.flavor = flavor;
            this.path = path;
            this.tfsBuild = tfsBuild;
        }

        /// <summary>
        /// Gets or sets the test run definition for this test run
        /// </summary>
        public string ClientBuildDefinition
        {
            get { return this.clientBuildDefinition; }
            set { this.clientBuildDefinition = value; }
        }

        /// <summary>
        /// Gets or sets the build number for this test run
        /// </summary>
        public int BuildNumber
        {
            get { return this.buildNumber; }
            set { this.buildNumber = value; }
        }

        /// <summary>
        /// Gets or sets the configuration platform for this test run
        /// </summary>
        public string Platform
        {
            get { return this.platform; }
            set { this.platform = value; }
        }

        /// <summary>
        /// Gets or sets the configuration flavor for this test run
        /// </summary>
        public string Flavor
        {
            get { return this.flavor; }
            set { this.flavor = value; }
        }

        /// <summary>
        /// Gets or sets the path to the test run file
        /// </summary>
        public string Path
        {
            get { return this.path; }
            set { this.path = value; }
        }

        /// <summary>
        /// Gets or sets the tfs build instance
        /// </summary>
        [XmlIgnore]
        public TfsBuild TfsBuild
        {
            get { return this.tfsBuild; }
            set { this.tfsBuild = value; }
        }

        /// <summary>
        /// Determines whether the two test runs are equal
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are the same; otherwise, false</returns>
        public static bool operator ==(TestRun left, TestRun right)
        {
            if (true == System.Object.ReferenceEquals(left, right))
            {
                return true;
            }

            if ((null == left) || (null == right))
            {
                return false;
            }

            return left.Equals(right);
        }

        /// <summary>
        /// Determines whether the two test runs are different
        /// </summary>
        /// <param name="left">The left comparand</param>
        /// <param name="right">The right comparand</param>
        /// <returns>true if the value of left and right are different; otherwise, false</returns>
        public static bool operator !=(TestRun left, TestRun right)
        {
            return !(left == right);
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public override bool Equals(object obj)
        {
            if (false == (obj is TestRun))
            {
                return false;
            }

            return this.Equals(obj as TestRun);
        }

        /// <summary>
        /// Determines whether the two objects have the same value
        /// </summary>
        /// <param name="other">The specified object</param>
        /// <returns>true if the value of other is the same as this instance; otherwise, false</returns>
        public bool Equals(TestRun other)
        {
            if (true == System.Object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (null == other)
            {
                return false;
            }

            if (this.clientBuildDefinition != other.clientBuildDefinition)
            {
                return false;
            }

            if (this.buildNumber != other.buildNumber)
            {
                return false;
            }

            if (this.platform != other.platform)
            {
                return false;
            }

            if (this.flavor != other.flavor)
            {
                return false;
            }

            if (this.path != other.path)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns the hash code for the current object
        /// </summary>
        /// <returns>The hash code for the current object</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\TestRunDefinition.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TestRunDefinition.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe a test run definition
// </summary>
//-----------------------------------------------------------------------

namespace TfsMonitorXenon
{
    using System;

    /// <summary>
    /// Class to describe a test run definition
    /// </summary>
    [Serializable()]
    public class TestRunDefinition
    {
        /// <summary>
        /// name specifies the name of this test run definition
        /// </summary>
        private string name;

        /// <summary>
        /// path specifies the path to the test run file
        /// </summary>
        private string path;

        /// <summary>
        /// Initializes a new instance of the TestRunDefinition class
        /// </summary>
        internal TestRunDefinition()
        {
        }

        /// <summary>
        /// Gets or sets the name of this test run definition
        /// </summary>
        public string Name
        {
            get { return this.name; }
            set { this.name = value; }
        }

        /// <summary>
        /// Gets or sets the path to the test run file
        /// </summary>
        public string Path
        {
            get { return this.path; }
            set { this.path = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsMonitorXenon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsMonitorXenon")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9cc5d74c-e4af-4b82-99a2-a0855ac98ff3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\TfsMonitorXenonConfig.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsMonitorXenonConfig.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe the configuration for this tool
// </summary>
//-----------------------------------------------------------------------

namespace TfsMonitorXenon
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Class to describe the configuration for this tool
    /// </summary>
    [Serializable()]
    public class TfsMonitorXenonConfig
    {
        /// <summary>
        /// clientBuildDefinitions specifies the collection of client build definitions
        /// </summary>
        private List<ClientBuildDefinition> clientBuildDefinitions;

        /// <summary>
        /// clientBuildConfigurations specifies the collection of client build configurations
        /// </summary>
        private List<ClientBuildConfiguration> clientBuildConfigurations;

        /// <summary>
        /// testRunDefinitions specifies the collection of test run definitions
        /// </summary>
        private List<TestRunDefinition> testRunDefinitions;

        /// <summary>
        /// testRunsPublished specifies the collection of test runs published
        /// </summary>
        private List<TestRun> testRunsPublished;

        /// <summary>
        /// Initializes a new instance of the ClientBuildConfiguration class
        /// </summary>
        internal TfsMonitorXenonConfig()
        {
        }

        /// <summary>
        /// Gets or sets the collection of client build definitions
        /// </summary>
        public List<ClientBuildDefinition> ClientBuildDefinitions
        {
            get { return this.clientBuildDefinitions; }
            set { this.clientBuildDefinitions = value; }
        }

        /// <summary>
        /// Gets or sets the collection of client build configurations
        /// </summary>
        public List<ClientBuildConfiguration> ClientBuildConfigurations
        {
            get { return this.clientBuildConfigurations; }
            set { this.clientBuildConfigurations = value; }
        }

        /// <summary>
        /// Gets or sets the collection of test run definitions
        /// </summary>
        public List<TestRunDefinition> TestRunDefinitions
        {
            get { return this.testRunDefinitions; }
            set { this.testRunDefinitions = value; }
        }

        /// <summary>
        /// Gets or sets the collection of test runs published
        /// </summary>
        public List<TestRun> TestRunsPublished
        {
            get { return this.testRunsPublished; }
            set { this.testRunsPublished = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsPublishResults\TfsPublishResults.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsPublishResults.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for publishing test results to a tfs build
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsPublishResults
{
    using System;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsPublishResultsConsole publishes the test results to a tfs build
    /// </summary>
    internal class TfsPublishResultsConsole : TfsConsole
    {
        /// <summary>
        /// Initializes a new instance of the TfsPublishResultsConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsPublishResultsConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the tfs publish results tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // get the build definition
            string buildDefinition = this.NamedArgsCollection["buildDefinition"];

            // get the build number
            string buildNumber = this.NamedArgsCollection["buildNumber"];

            // get the flavor
            string flavor = this.NamedArgsCollection["flavor"];

            // get the platform
            string platform = this.NamedArgsCollection["platform"];

            string resultsFile = null;
            switch (namedArgGroup)
            {
                case "PublishResultsMSTest":
                    resultsFile = this.NamedArgsCollection["mstest"];
                    break;

                case "PublishResultsNUnit":
                    resultsFile = this.NamedArgsCollection["nunit"];
                    break;
            }

            // log all info
            this.LogWriter.WriteLine("TFS Server Name:      {0}", serverName);
            this.LogWriter.WriteLine("TFS Project Name:     {0}", projectName);
            this.LogWriter.WriteLine("Build Definition:     {0}", buildDefinition);
            this.LogWriter.WriteLine("Build Number:         {0}", buildNumber);
            this.LogWriter.WriteLine("Flavor:               {0}", flavor);
            this.LogWriter.WriteLine("Platform:             {0}", platform);
            this.LogWriter.WriteLine("Results File:         {0}", resultsFile);

            try
            {
                // create the project instance
                TfsProject tfsProject = new TfsProject(serverName, projectName);

                // get the build definition
                TfsBuildDefinition tfsBuildDefinition = tfsProject.GetBuildDefinition(buildDefinition);

                // get the build
                TfsBuildSpec tfsBuildSpec = new TfsBuildSpec();
                tfsBuildSpec.BuildNumber = buildNumber;

                TfsBuildCollection tfsBuildCollection = tfsBuildDefinition.QueryBuilds(tfsBuildSpec);

                if (1 != tfsBuildCollection.Count)
                {
                    throw new ApplicationException(String.Format("'{0}' could not be found", buildNumber));
                }

                TfsBuild tfsBuild = tfsBuildCollection[0];

                // publish the results
                TfsTestSummary tfsTestSummary = null;
                switch (namedArgGroup)
                {
                    case "PublishResultsMSTest":
                        tfsTestSummary = tfsBuild.PublishResultsMSTest(resultsFile, flavor, platform);
                        break;

                    case "PublishResultsNUnit":
                        tfsTestSummary = tfsBuild.PublishResultsNUnit(resultsFile, flavor, platform);
                        break;
                }

                this.LogWriter.WriteLine("Run Id:               {0}", tfsTestSummary.RunId);
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            this.LogWriter.WriteLine();

            return 0;
        }
        private static int Main(string[] args)
        {
            // create the tfs publish results instance
            TfsPublishResultsConsole tfsPublishResultsConsole = new TfsPublishResultsConsole(args);

            // run
            return tfsPublishResultsConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsMonitorXenon\TfsMonitorXenon.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsMonitorXenon.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for create a client build in tfs
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsMonitorXenon
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Xml;
    using System.Xml.Serialization;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsMonitorXenonConsole monitors the xenon release share and creates newly avaiable client builds in tfs
    /// </summary>
    internal class TfsMonitorXenonConsole : TfsConsole
    {
        /// <summary>
        /// tfsMonitorXenonConfig specifies the configuration for this tool
        /// </summary>
        private TfsMonitorXenonConfig tfsMonitorXenonConfig;

        /// <summary>
        /// fileName is the file name containing the configuration for this tool
        /// </summary>
        private string fileName;

        /// <summary>
        /// tfsProject is the tfs project object
        /// </summary>
        private TfsProject tfsProject;

        /// <summary>
        /// testRunsUnpublished specifies the collection of test runs not yet published
        /// </summary>
        private List<TestRun> testRunsUnpublished = new List<TestRun>();

        /// <summary>
        /// Initializes a new instance of the TfsMonitorXenonConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsMonitorXenonConsole(string[] args)
            : base(args, false)
        {
        }

        /// <summary>
        /// Begins running the tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            this.fileName = this.NamedArgsCollection["fileName"];

            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // connect to the project
            this.tfsProject = new TfsProject(serverName, projectName);

            while (true)
            {
                try
                {
                    this.RunIteration();
                }
                catch (Exception ex)
                {
                    this.LogWriter.WriteLine("Exception: " + ex.Message);
                    this.LogWriter.WriteLine();
                }

                this.LogWriter.WriteLine("Sleeping for 5 minutes...");
                Thread.Sleep(TimeSpan.FromMinutes(5));
            }

            return 0;
        }

        /// <summary>
        /// Format the client build configurations into a build configuration collection
        /// </summary>
        /// <param name="clientBuildDefinition">The specified client build definition</param>
        /// <param name="currentBuildNumber">The current build number</param>
        /// <returns>The build configuration collection</returns>
        private static TfsBuildConfigurationCollection FormatClientBuildConfigurations(ClientBuildDefinition clientBuildDefinition, int currentBuildNumber)
        {
            TfsBuildConfigurationCollection tfsBuildConfigurationCollection = new TfsBuildConfigurationCollection();

            foreach (ClientBuildConfiguration clientBuildConfiguration in clientBuildDefinition.ClientBuildConfigurations)
            {
                // format the build configuration path
                string path = String.Format(clientBuildConfiguration.Path, currentBuildNumber);

                // format the log files
                string buildLog = String.Format(clientBuildConfiguration.BuildLog, path);
                string errorLog = String.Format(clientBuildConfiguration.ErrorLog, path);
                string warningLog = String.Format(clientBuildConfiguration.WarningLog, path);

                buildLog = Path.Combine(clientBuildDefinition.BuildRoot, buildLog);
                errorLog = Path.Combine(clientBuildDefinition.BuildRoot, errorLog);
                warningLog = Path.Combine(clientBuildDefinition.BuildRoot, warningLog);

                TfsBuildLogs tfsBuildLogs = new TfsBuildLogs(buildLog, errorLog, warningLog);

                string logFile = buildLog;

                // Get the build warnings
                int warnings = TfsMonitorXenonConsole.GetLogFileCount(warningLog);
                if (0 < warnings)
                {
                    logFile = warningLog;
                }

                // Get the build errors
                int errors = TfsMonitorXenonConsole.GetLogFileCount(errorLog);
                if (0 < errors)
                {
                    logFile = errorLog;
                }

                // create the build configuration
                tfsBuildConfigurationCollection.Add(new TfsBuildConfiguration(clientBuildConfiguration.Flavor, clientBuildConfiguration.Platform, logFile, errors, warnings, tfsBuildLogs));
            }

            return tfsBuildConfigurationCollection;
        }

        /// <summary>
        /// Get the number of lines in the log file (roughly the number of error or warnings in the build)
        /// </summary>
        /// <param name="logFile">The specified log file</param>
        /// <returns>The number of lines in the log file</returns>
        private static int GetLogFileCount(string logFile)
        {
            // logFileCount is the number of lines in the log file (roughly the number of errors or warnings in the build)
            int logFileCount = 0;

            try
            {
                // Open the log file for reading
                using (StreamReader streamReader = LongPath.Read(logFile))
                {
                    // Read each line and increment the logFileCount
                    while (false == streamReader.EndOfStream)
                    {
                        streamReader.ReadLine();
                        logFileCount++;
                    }
                }
            }
            catch (System.ComponentModel.Win32Exception)
            {
            }

            return logFileCount;
        }

        /// <summary>
        /// Checks for and publishes newly available builds
        /// </summary>
        /// <param name="tfsBuildDefinition">The tfs build definition</param>
        /// <param name="clientBuildDefinition">The specified client build definition</param>
        private void CheckBuildNumbers(TfsBuildDefinition tfsBuildDefinition, ClientBuildDefinition clientBuildDefinition)
        {
            // get the latest build number
            string latestFile = Path.Combine(clientBuildDefinition.BuildRoot, clientBuildDefinition.LatestFile);
            int latestBuildNumber = this.GetLatestBuildNumber(latestFile);

            // check if new builds are available
            if (latestBuildNumber >= clientBuildDefinition.NextBuildNumber)
            {
                // publish the newly available builds
                this.PublishBuilds(tfsBuildDefinition, clientBuildDefinition, latestBuildNumber);
            }
        }

        /// <summary>
        /// Checks for and publishes newly available test runs
        /// </summary>
        private void CheckTestRuns()
        {
            // iterate each test run unpublished
            foreach (TestRun testRun in this.testRunsUnpublished)
            {
                // check if the test run has already been published
                if (true == this.tfsMonitorXenonConfig.TestRunsPublished.Contains(testRun))
                {
                    continue;
                }

                // check if the test run exists
                if (false == File.Exists(testRun.Path))
                {
                    continue;
                }

                // publish the test run
                this.LogWriter.WriteLine("Publishing Test Run [{0}] ...", testRun.Path);

                // copy the file local
                string path = Path.GetTempPath();
                string fileName = String.Format("{0}.trx", Guid.NewGuid().ToString());
                fileName = Path.Combine(path, fileName);

                File.Copy(testRun.Path, fileName);

                try
                {
                    TfsTestSummary tfsTestSummary = testRun.TfsBuild.PublishResultsMSTest(fileName, testRun.Flavor, testRun.Platform);

                    this.LogWriter.WriteLine("  Test Run Id: {0}", tfsTestSummary.RunId);
                }
                catch (ApplicationException ex)
                {
                    this.LogWriter.WriteLine(ex.Message);
                }

                // add the test run to the published test runs
                this.tfsMonitorXenonConfig.TestRunsPublished.Add(testRun);

                // save the config
                this.SaveConfig();

                // delete the local file
                File.Delete(fileName);
            }
        }

        /// <summary>
        /// Format the test runs into a collection
        /// </summary>
        /// <param name="clientBuildDefinition">The specified client build definition</param>
        /// <param name="currentBuildNumber">The current build number</param>
        /// <param name="tfsBuild">The tfs build instance</param>
        /// <returns>The collection of test runs</returns>
        private List<TestRun> FormatTestRuns(ClientBuildDefinition clientBuildDefinition, int buildNumber, TfsBuild tfsBuild)
        {
            List<TestRun> testRuns = new List<TestRun>();

            // iterate each build configuration
            foreach (ClientBuildConfiguration clientBuildConfiguration in clientBuildDefinition.ClientBuildConfigurations)
            {
                // iterate each test run definition
                foreach (TestRunDefinition testRunDefinition in this.tfsMonitorXenonConfig.TestRunDefinitions)
                {
                    // format the test run path
                    string testRunPath = String.Format(clientBuildConfiguration.Path, buildNumber);
                    testRunPath = String.Format(testRunDefinition.Path, testRunPath);
                    testRunPath = Path.Combine(clientBuildDefinition.BuildRoot, testRunPath);

                    // create the test run instance
                    testRuns.Add(new TestRun(clientBuildDefinition.Name, buildNumber, clientBuildConfiguration.Platform, clientBuildConfiguration.Flavor, testRunPath, tfsBuild));
                }
            }

            return testRuns;
        }

        /// <summary>
        /// Gets the tfs build definition specified by the name
        /// </summary>
        /// <param name="name">The specified build definition name</param>
        /// <returns>The tfs build definition object</returns>
        private TfsBuildDefinition GetBuildDefinition(string name)
        {
            // get the build definition
            this.LogWriter.WriteLine("Getting Build Definition [{0}] ...", name);

            TfsBuildDefinition tfsBuildDefinition = tfsProject.GetBuildDefinition(name);

            return tfsBuildDefinition;
        }

        /// <summary>
        /// Gets the latest build number from the latest file
        /// </summary>
        /// <param name="latestFile">The latest file name</param>
        /// <returns>The latest build number</returns>
        private int GetLatestBuildNumber(string latestFile)
        {
            int latestBuildNumber = -1;

            this.LogWriter.WriteLine("Checking Latest File [{0}] ...", latestFile);

            if (true == File.Exists(latestFile))
            {
                this.LogWriter.WriteLine("  Getting Latest Build Number ...");

                // read the latest build
                using (StreamReader streamReader = new StreamReader(latestFile))
                {
                    latestBuildNumber = int.Parse(streamReader.ReadToEnd());
                }

                this.LogWriter.WriteLine("  Latest Build Number: {0}", latestBuildNumber);
            }

            return latestBuildNumber;
        }

        /// <summary>
        /// Deserializes the config from the specified file name
        /// </summary>
        private void LoadConfig()
        {
            this.LogWriter.WriteLine("Loading Configuration [{0}] ...", this.fileName);

            // load and deserialize the xml document specified by the fileName
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlSerializer xmlSerializer = new XmlSerializer(typeof(TfsMonitorXenonConfig));
                this.tfsMonitorXenonConfig = xmlSerializer.Deserialize(fileStream) as TfsMonitorXenonConfig;
            }

            foreach (ClientBuildDefinition clientBuildDefinition in this.tfsMonitorXenonConfig.ClientBuildDefinitions)
            {
                clientBuildDefinition.ClientBuildConfigurations = new List<ClientBuildConfiguration>(this.tfsMonitorXenonConfig.ClientBuildConfigurations);
            }

            this.LogWriter.WriteLine("  Build Definitions:    {0}", this.tfsMonitorXenonConfig.ClientBuildDefinitions.Count);
            this.LogWriter.WriteLine("  Build Configurations: {0}", this.tfsMonitorXenonConfig.ClientBuildConfigurations.Count);
            this.LogWriter.WriteLine("  Test Run Definitions: {0}", this.tfsMonitorXenonConfig.TestRunDefinitions.Count);
            this.LogWriter.WriteLine("  Test Runs Published:  {0}", this.tfsMonitorXenonConfig.TestRunsPublished.Count);
        }

        /// <summary>
        /// Loads all possible test runs
        /// </summary>
        /// <param name="tfsBuildDefinition">The tfs build definition</param>
        /// <param name="clientBuildDefinition">The specified client build definition</param>
        private void LoadTestRunsUnpublished(TfsBuildDefinition tfsBuildDefinition, ClientBuildDefinition clientBuildDefinition)
        {
            // load the existing client builds
            this.LogWriter.WriteLine("Querying Builds [{0}] ...", clientBuildDefinition.Name);

            TfsBuildCollection tfsBuildCollection = tfsBuildDefinition.QueryBuilds(new TfsBuildSpec());

            this.LogWriter.WriteLine("  Build Count: {0}", tfsBuildCollection.Count);

            // iterate each build
            foreach (TfsBuild tfsBuild in tfsBuildCollection)
            {
                // parse out the build number
                Match match = Regex.Match(tfsBuild.BuildNumber, clientBuildDefinition.BuildNumberRegex);
                if (false == match.Success)
                {
                    continue;
                }

                int buildNumber = int.Parse(match.Groups[1].Value);

                // get the test runs
                List<TestRun> testRuns = this.FormatTestRuns(clientBuildDefinition, buildNumber, tfsBuild);
                this.testRunsUnpublished.AddRange(testRuns);
            }
        }

        /// <summary>
        /// Publish the newly available builds for the specified client build definition
        /// </summary>
        /// <param name="tfsBuildDefinition">The specified tfs build definition</param>
        /// <param name="clientBuildDefinition">The specified client build definition</param>
        /// <param name="latestBuildNumber">The latest build number</param>
        private void PublishBuilds(TfsBuildDefinition tfsBuildDefinition, ClientBuildDefinition clientBuildDefinition, int latestBuildNumber)
        {
            // iterate the newly available builds
            for (int currentBuildNumber = clientBuildDefinition.NextBuildNumber; currentBuildNumber <= latestBuildNumber; currentBuildNumber++)
            {
                this.LogWriter.WriteLine("Checking Build Number [{0}] ...", currentBuildNumber);

                // check if the build directory exists
                string buildDrop = Path.Combine(clientBuildDefinition.BuildRoot, currentBuildNumber.ToString());

                this.LogWriter.WriteLine("  Checking Build Directory [{0}] ...", buildDrop);

                if (true == Directory.Exists(buildDrop))
                {
                    // format the build number
                    string buildNumber = String.Format(clientBuildDefinition.BuildNumberFormat, currentBuildNumber);

                    // get the client build configurations
                    TfsBuildConfigurationCollection tfsBuildConfigurationCollection = TfsMonitorXenonConsole.FormatClientBuildConfigurations(clientBuildDefinition, currentBuildNumber);

                    this.LogWriter.WriteLine("  Creating Build:");

                    this.LogWriter.WriteLine("    Build Number:         {0}", buildNumber);
                    this.LogWriter.WriteLine("    Build Drop:           {0}", buildDrop);
                    this.LogWriter.WriteLine("    Build Configurations: {0}", tfsBuildConfigurationCollection.Count);

                    foreach (TfsBuildConfiguration tfsBuildConfiguration in tfsBuildConfigurationCollection)
                    {
                        this.LogWriter.WriteLine("      Configuration:");
                        this.LogWriter.WriteLine("        Flavor:           {0}", tfsBuildConfiguration.Flavor);
                        this.LogWriter.WriteLine("        Platform:         {0}", tfsBuildConfiguration.Platform);
                        this.LogWriter.WriteLine("        Log File:         {0}", tfsBuildConfiguration.LogFile);
                        this.LogWriter.WriteLine("        Errors:           {0}", tfsBuildConfiguration.Errors);
                        this.LogWriter.WriteLine("        Warnings:         {0}", tfsBuildConfiguration.Warnings);
                    }

                    // publish the new build
                    TfsBuild tfsBuild = tfsBuildDefinition.CreateBuild(buildNumber, buildDrop, tfsBuildConfigurationCollection);

                    // set the next expected build number
                    clientBuildDefinition.NextBuildNumber = currentBuildNumber + 1;

                    this.LogWriter.WriteLine("    Build Status:         {0}", tfsBuild.Status);
                    this.LogWriter.WriteLine("    Build Uri:            {0}", tfsBuild.Uri);

                    // save the config
                    this.SaveConfig();
                }
            }
        }

        /// <summary>
        /// Serializes the config to the specified file name
        /// </summary>
        private void SaveConfig()
        {
            this.LogWriter.WriteLine("Saving Configuration [{0}] ...", this.fileName);

            XmlDocument xmlDocument = new XmlDocument();

            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriter = new StringWriterUTF8(stringBuilder))
            {
                XmlSerializer xmlSerializer = new XmlSerializer(this.tfsMonitorXenonConfig.GetType());
                xmlSerializer.Serialize(stringWriter, this.tfsMonitorXenonConfig);
            }

            xmlDocument.PreserveWhitespace = true;
            xmlDocument.LoadXml(stringBuilder.ToString());

            xmlDocument.Save(fileName);

            this.LogWriter.WriteLine("  Build Definitions:    {0}", this.tfsMonitorXenonConfig.ClientBuildDefinitions.Count);
            this.LogWriter.WriteLine("  Build Configurations: {0}", this.tfsMonitorXenonConfig.ClientBuildConfigurations.Count);
            this.LogWriter.WriteLine("  Test Run Definitions: {0}", this.tfsMonitorXenonConfig.TestRunDefinitions.Count);
            this.LogWriter.WriteLine("  Test Runs Published:  {0}", this.tfsMonitorXenonConfig.TestRunsPublished.Count);
        }

        /// <summary>
        /// Run an iteration to detect and publish new builds
        /// </summary>
        private void RunIteration()
        {
            // clear the test runs unpublished
            this.testRunsUnpublished.Clear();

            // load the config
            this.LoadConfig();

            // iterate the client build definitions
            foreach (ClientBuildDefinition clientBuildDefinition in this.tfsMonitorXenonConfig.ClientBuildDefinitions)
            {
                // get the build definition
                TfsBuildDefinition tfsBuildDefinition = this.GetBuildDefinition(clientBuildDefinition.Name);

                // check for and publish newly available builds
                this.CheckBuildNumbers(tfsBuildDefinition, clientBuildDefinition);

                // load the test runs unpublished
                this.LoadTestRunsUnpublished(tfsBuildDefinition, clientBuildDefinition);
            }

            // check for and publish newly available test runs
            this.CheckTestRuns();
        }

        static private int Main(string[] args)
        {
            TfsMonitorXenonConsole tfsMonitorXenonConsole = new TfsMonitorXenonConsole(args);

            return tfsMonitorXenonConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsPublishResults\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsPublishResults")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsPublishResults")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("633acc22-32c9-4215-a056-e4e58859d060")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsQueryBuilds\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsQueryBuilds")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TfsQueryBuilds")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ae3ff4a3-3b4d-475b-9fe0-30a272604c08")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\BuildConfigurationResult.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="BuildConfigurationResult.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to represent the result for a particular build configuration
// </summary>
//-----------------------------------------------------------------------
namespace TfsCreateBuild
{
    using System.IO;

    using Common.LongPath;

    /// <summary>
    /// BuildConfigurationResult details the results for a particular build configuration
    /// </summary>
    internal sealed class BuildConfigurationResult
    {
        /// <summary>
        /// completed specifies if the build completed
        /// </summary>
        private bool completed;

        /// <summary>
        /// errors is number of errors that occurred for this build
        /// </summary>
        private int errors;

        /// <summary>
        /// flavor is the type of the build: debug, release, etc.
        /// </summary>
        private string flavor;

        /// <summary>
        /// logFile is the full path to the most appropriate log file for the build (build log file, error log file, or warning log file)
        /// </summary>
        private string logFile;

        /// <summary>
        /// platform is the architecture of the build: x86, amd64, etc.
        /// </summary>
        private string platform;

        /// <summary>
        /// warnings is the number of warnings that occurred for this build
        /// </summary>
        private int warnings;

        /// <summary>
        /// Initializes a new instance of the BuildConfigurationResult class
        /// </summary>
        /// <param name="flavor">Specifies the type of the build: debug, release, etc.</param>
        /// <param name="platform">Specifies the architecture of the build: x86, amd64, etc.</param>
        public BuildConfigurationResult(string flavor, string platform)
        {
            this.flavor = flavor;
            this.platform = platform;
        }

        /// <summary>
        /// Gets a value indicating whether the build completed
        /// </summary>
        public bool Completed
        {
            get { return this.completed; }
        }

        /// <summary>
        /// Gets the number of errors that occurred for this build
        /// </summary>
        public int Errors
        {
            get { return this.errors; }
        }

        /// <summary>
        /// Gets the type of the build: debug, release, etc.
        /// </summary>
        public string Flavor
        {
            get { return this.flavor; }
        }

        /// <summary>
        /// Gets the full path to the log file for this build
        /// </summary>
        public string LogFile
        {
            get { return this.logFile; }
        }

        /// <summary>
        /// Gets the architecture of the build: x86, amd64, etc.
        /// </summary>
        public string Platform
        {
            get { return this.platform; }
        }

        /// <summary>
        /// Gets the number of warnings that occurred for this build
        /// </summary>
        public int Warnings
        {
            get { return this.warnings; }
        }

        /// <summary>
        /// Loads the results of the build
        /// </summary>
        /// <param name="buildLogFile">The full path to the build log file</param>
        /// <param name="errorLogFile">The full path to the error log file</param>
        /// <param name="warningLogFile">The full path to the warning log file</param>
        public void Load(string buildLogFile, string errorLogFile, string warningLogFile)
        {
            // Check if the build log file exists (i.e. build completed)
            this.completed = LongPath.Exists(buildLogFile);
            this.logFile = buildLogFile;

            // Get the build warnings
            this.warnings = BuildConfigurationResult.GetLogFileCount(warningLogFile);
            if (0 < this.warnings)
            {
                this.logFile = warningLogFile;
            }

            // Get the build errors
            this.errors = BuildConfigurationResult.GetLogFileCount(errorLogFile);
            if (0 < this.errors)
            {
                this.logFile = errorLogFile;
            }
        }

        /// <summary>
        /// Get the number of lines in the log file (roughly the number of error or warnings in the build)
        /// </summary>
        /// <param name="logFile">The specified log file</param>
        /// <returns>The number of lines in the log file</returns>
        private static int GetLogFileCount(string logFile)
        {
            // logFileCount is the number of lines in the log file (roughly the number of errors or warnings in the build)
            int logFileCount = 0;

            try
            {
                // Open the log file for reading
                using (StreamReader streamReader = LongPath.Read(logFile))
                {
                    // Read each line and increment the logFileCount
                    while (false == streamReader.EndOfStream)
                    {
                        streamReader.ReadLine();
                        logFileCount++;
                    }
                }
            }
            catch (System.ComponentModel.Win32Exception)
            {
            }

            return logFileCount;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\Config.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="Config.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to load the config
// </summary>
//-----------------------------------------------------------------------
namespace TfsCreateBuild
{
    using System;
    using System.Configuration;
    using System.Reflection;

    /// <summary>
    /// Provides access to the configuration
    /// </summary>
    public class Config
    {
        /// <summary>
        /// configurations is the delimited list of build configurations
        /// </summary>
        private string configurations;

        /// <summary>
        /// projectName is the name of the tfs project
        /// </summary>
        private string projectName;

        /// <summary>
        /// releaseShare is the release share on the tfs server
        /// </summary>
        private string releaseShare;

        /// <summary>
        /// serverName is the name of the tfs server
        /// </summary>
        private string serverName;

        /// <summary>
        /// Initializes a new instance of the Config class
        /// </summary>
        public Config()
        {
            Configuration configuration = ConfigurationManager.OpenExeConfiguration(Assembly.GetExecutingAssembly().Location);

            this.configurations = configuration.AppSettings.Settings["Configurations"].Value;

            this.serverName = configuration.AppSettings.Settings["ServerName"].Value;
            this.projectName = configuration.AppSettings.Settings["ProjectName"].Value;
            this.releaseShare = configuration.AppSettings.Settings["ReleaseShare"].Value;
        }

        /// <summary>
        /// Gets the delimited list of build configurations
        /// </summary>
        public string Configurations
        {
            get { return this.configurations; }
        }

        /// <summary>
        /// Gets the name of the tfs project
        /// </summary>
        public string ProjectName
        {
            get { return this.projectName; }
        }

        /// <summary>
        /// Gets the release share on the tfs server
        /// </summary>
        public string ReleaseShare
        {
            get { return this.releaseShare; }
        }

        /// <summary>
        /// Gets the name of the tfs server
        /// </summary>
        public string ServerName
        {
            get { return this.serverName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\BuildResult.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="BuildResult.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to represent the result of a build
// </summary>
//-----------------------------------------------------------------------
namespace TfsCreateBuild
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;

    /// <summary>
    /// BuildResult details the results for the build
    /// </summary>
    internal sealed class BuildResult
    {
        /// <summary>
        /// errors is number of errors that occurred for this build
        /// </summary>
        private int errors;

        /// <summary>
        /// listBuildCompilations is the list of build configuration results for this build
        /// </summary>
        private List<BuildConfigurationResult> listBuildConfigurationResults = new List<BuildConfigurationResult>();

        /// <summary>
        /// warnings is the number of warnings that occurred for this build
        /// </summary>
        private int warnings;

        /// <summary>
        /// Gets the collection of build configuration results for this build
        /// </summary>
        public ReadOnlyCollection<BuildConfigurationResult> BuildConfigurationResults
        {
            get { return new ReadOnlyCollection<BuildConfigurationResult>(this.listBuildConfigurationResults); }
        }

        /// <summary>
        /// Gets a value indicating whether the build completed
        /// </summary>
        public bool Completed
        {
            get { return 0 != this.listBuildConfigurationResults.Count; }
        }

        /// <summary>
        /// Gets the number of errors that occurred for this build
        /// </summary>
        public int Errors
        {
            get { return this.errors; }
        }

        /// <summary>
        /// Gets the number of warnings that occurred for this build
        /// </summary>
        public int Warnings
        {
            get { return this.warnings; }
        }

        /// <summary>
        /// Loads the build configurations from the specified release share
        /// </summary>
        /// <param name="buildLogShare">The path to the build logs on the release share</param>
        /// <param name="configurations">The delimited list of build configurations</param>
        public void Load(string buildLogShare, string configurations)
        {
            // Get the configurations
            string[] configurationsSplit = configurations.Split(';');

            foreach (string configuration in configurationsSplit)
            {
                // split the configuration into flavor, platform, build log file, error log file, warning log file
                string[] configurationSplit = configuration.Split(',');

                // get the flavor and platform
                string flavor = configurationSplit[0];
                string platform = configurationSplit[1];

                // create the build configuration result
                BuildConfigurationResult buildConfigurationResult = new BuildConfigurationResult(flavor, platform);

                // get the build, error and warning log files
                string buildLogFile = String.Format(@"{0}\{1}", buildLogShare, configurationSplit[2]);
                string errorLogFile = String.Format(@"{0}\{1}", buildLogShare, configurationSplit[3]);
                string warningLogFile = String.Format(@"{0}\{1}", buildLogShare, configurationSplit[4]);

                // load the build configuration result
                buildConfigurationResult.Load(buildLogFile, errorLogFile, warningLogFile);

                if (false == buildConfigurationResult.Completed)
                {
                    continue;
                }

                // add the errors and warnings
                this.errors += buildConfigurationResult.Errors;
                this.warnings += buildConfigurationResult.Warnings;

                // add the build configuration result
                this.listBuildConfigurationResults.Add(buildConfigurationResult);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\LongPath.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="LongPath.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   long path support
//   http://blogs.msdn.com/bclteam/archive/2007/03/26/long-paths-in-net-part-2-of-3-long-path-workarounds-kim-hamilton.aspx
// </summary>
//-----------------------------------------------------------------------
namespace Common.LongPath
{
    using System;
    using System.IO;
    using System.Runtime.InteropServices;
    using Microsoft.Win32.SafeHandles;

    /// <summary>
    /// Class to support long paths in file operations: read, write, delete, copy, exists
    /// </summary>
    public static class LongPath
    {
        /// <summary>
        /// Copies an existing file to a new file.  Overwrites the new file if it exists.
        /// </summary>
        /// <param name="left">The name of the existing file</param>
        /// <param name="right">The name of the new file</param>
        public static void Copy(string left, string right)
        {
            // copy the file
            bool result = NativeMethods.CopyFile(left, right, false);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (false == result)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }
        }

        /// <summary>
        /// Creates the specified directory
        /// </summary>
        /// <param name="fileName">The name of the directory to create</param>
        public static void CreateDirectory(string fileName)
        {
            // create the directory
            bool result = NativeMethods.CreateDirectory(LongPath.FormatFileName(fileName), IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (false == result)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }
        }

        /// <summary>
        /// Deletes the specified file
        /// </summary>
        /// <param name="fileName">The name of the file to delete</param>
        public static void Delete(string fileName)
        {
            // delete the file
            NativeMethods.DeleteFile(LongPath.FormatFileName(fileName));
        }

        /// <summary>
        /// Determines whether the specified file/directory exists
        /// </summary>
        /// <param name="fileName">The name of the file/directory to find</param>
        /// <returns>true if file/directory is found in the collection; otherwise, false</returns>
        public static bool Exists(string fileName)
        {
            NativeMethods.WIN32_FIND_DATA findData;
            IntPtr findHandle = NativeMethods.FindFirstFile(LongPath.FormatFileName(fileName), out findData);

            return NativeMethods.INVALID_HANDLE_VALUE != findHandle;
        }

        /// <summary>
        /// Opens an existing file for reading.
        /// </summary>
        /// <param name="fileName">The name of the file to open</param>
        /// <returns>A StreamReader object for reading the file</returns>
        public static StreamReader Read(string fileName)
        {
            // open the file
            SafeFileHandle safeFileHandle = NativeMethods.CreateFile(LongPath.FormatFileName(fileName), NativeMethods.EFileAccess.GenericRead, NativeMethods.EFileShare.None, IntPtr.Zero, NativeMethods.ECreationDisposition.OpenExisting, 0, IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (true == safeFileHandle.IsInvalid)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }

            // create the filestream
            FileStream fileStream = new FileStream(safeFileHandle, FileAccess.Read);
            return new StreamReader(fileStream, System.Text.Encoding.UTF8, true);
        }

        /// <summary>
        /// Creates a new file for writing.  Overwrites the new file if it exists
        /// </summary>
        /// <param name="fileName">The name of the file to create</param>
        /// <returns>A StreamWriter object for writing to the file</returns>
        public static StreamWriter Write(string fileName)
        {
            // open the file
            SafeFileHandle safeFileHandle = NativeMethods.CreateFile(LongPath.FormatFileName(fileName), NativeMethods.EFileAccess.GenericWrite, NativeMethods.EFileShare.None, IntPtr.Zero, NativeMethods.ECreationDisposition.CreateAlways, 0, IntPtr.Zero);

            // check for errors
            int win32error = Marshal.GetLastWin32Error();
            if (true == safeFileHandle.IsInvalid)
            {
                throw new System.ComponentModel.Win32Exception(win32error);
            }

            // create the filestream
            FileStream fileStream = new FileStream(safeFileHandle, FileAccess.Write);
            return new StreamWriter(fileStream, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Formats the specified file name for use by native methods
        /// </summary>
        /// <param name="fileName">The specified file name</param>
        /// <returns>The formatted file name</returns>
        private static string FormatFileName(string fileName)
        {
            if (true == fileName.StartsWith(@"\\"))
            {
                return @"\\?\UNC\" + fileName.Substring(2);
            }

            return @"\\?\" + fileName;
        }

        /// <summary>
        /// Class to P/Invoke Win32 methods to support long paths in file operations
        /// </summary>
        private static class NativeMethods
        {
            internal const int MAX_PATH = 260;
            internal static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

            [Flags]
            internal enum ECreationDisposition : uint
            {
                New = 1,
                CreateAlways = 2,
                OpenExisting = 3,
                OpenAlways = 4,
                TruncateExisting = 5,
            }

            [Flags]
            internal enum EFileAccess : uint
            {
                GenericRead = 0x80000000,
                GenericWrite = 0x40000000,
                GenericExecute = 0x20000000,
                GenericAll = 0x10000000,
            }

            [Flags]
            internal enum EFileAttributes : uint
            {
                Readonly = 0x00000001,
                Hidden = 0x00000002,
                System = 0x00000004,
                Directory = 0x00000010,
                Archive = 0x00000020,
                Device = 0x00000040,
                Normal = 0x00000080,
                Temporary = 0x00000100,
                SparseFile = 0x00000200,
                ReparsePoint = 0x00000400,
                Compressed = 0x00000800,
                Offline = 0x00001000,
                NotContentIndexed = 0x00002000,
                Encrypted = 0x00004000,
                Write_Through = 0x80000000,
                Overlapped = 0x40000000,
                NoBuffering = 0x20000000,
                RandomAccess = 0x10000000,
                SequentialScan = 0x08000000,
                DeleteOnClose = 0x04000000,
                BackupSemantics = 0x02000000,
                PosixSemantics = 0x01000000,
                OpenReparsePoint = 0x00200000,
                OpenNoRecall = 0x00100000,
                FirstPipeInstance = 0x00080000
            }

            [Flags]
            internal enum EFileShare : uint
            {
                None = 0x00000000,
                Read = 0x00000001,
                Write = 0x00000002,
                Delete = 0x00000004,
            }

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool CopyFile(
                string lpExistingFileName,
                string lpNewFileName,
                [MarshalAs(UnmanagedType.Bool)]
                bool bFailIfExists);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern SafeFileHandle CreateFile(
                string lpFileName,
                EFileAccess dwDesiredAccess,
                EFileShare dwShareMode,
                IntPtr lpSecurityAttributes,
                ECreationDisposition dwCreationDisposition,
                EFileAttributes dwFlagsAndAttributes,
                IntPtr hTemplateFile);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool CreateDirectory(
                string lpPathName,
                IntPtr lpSecurityAttributes);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool DeleteFile(
                string lpFileName);

            [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
            internal static extern IntPtr FindFirstFile(
                string lpFileName,
                out WIN32_FIND_DATA lpFindFileData);

            [StructLayout(LayoutKind.Sequential)]
            internal struct FILETIME
            {
                internal uint dwLowDateTime;
                internal uint dwHighDateTime;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct SECURITY_ATTRIBUTES
            {
                public int nLength;
                public IntPtr lpSecurityDescriptor;
                public int bInheritHandle;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct WIN32_FIND_DATA
            {
                internal FileAttributes dwFileAttributes;
                internal FILETIME ftCreationTime;
                internal FILETIME ftLastAccessTime;
                internal FILETIME ftLastWriteTime;
                internal int nFileSizeHigh;
                internal int nFileSizeLow;
                internal int dwReserved0;
                internal int dwReserved1;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
                internal string cFileName;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 14)]
                internal string cAlternate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// SetTimestampProperty.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TFS\TfsQueryBuilds\TfsQueryBuilds.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsQueryBuilds.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   console app for querying builds from a tfs project
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsQueryBuilds
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;

    using TfsApplication;
    using TfsHelper;

    /// <summary>
    /// TfsQueryBuildsConsole queries builds from a tfs project
    /// </summary>
    internal class TfsQueryBuildsConsole : TfsConsole
    {
        /// <summary>
        /// tfsBuildCollection is the collection of builds returned from the query
        /// </summary>
        private TfsBuildCollection tfsBuildCollection;

        /// <summary>
        /// Initializes a new instance of the TfsQueryBuildsConsole class
        /// </summary>
        /// <param name="args">The collection of command line arguments</param>
        internal TfsQueryBuildsConsole(string[] args)
            : base(args, true)
        {
        }

        /// <summary>
        /// Begins running the tfs create build tool with the specified named argument group
        /// </summary>
        /// <param name="namedArgGroup"></param>
        /// <returns>0 if success; otherwise, the error code</returns>
        public override int Run(string namedArgGroup)
        {
            // get the server name
            string serverName = this.Config["serverName"];
            if (null != this.NamedArgsCollection["serverName"])
            {
                serverName = this.NamedArgsCollection["serverName"];
            }

            // get the project name
            string projectName = this.Config["projectName"];
            if (null != this.NamedArgsCollection["projectName"])
            {
                projectName = this.NamedArgsCollection["projectName"];
            }

            // log all info
            this.LogWriter.WriteLine("TFS Server Name:      {0}", serverName);
            this.LogWriter.WriteLine("TFS Project Name:     {0}", projectName);

            try
            {
                switch (namedArgGroup)
                {
                    case "QueryBuilds":
                        this.QueryBuilds(serverName, projectName);
                        break;

                    case "QueryBuildsByDefinition":
                        this.QueryBuildsByDefinition(serverName, projectName);
                        break;
                }
            }
            catch (Exception ex)
            {
                this.LogWriter.WriteLine("Exception: " + ex.Message);
                this.LogWriter.WriteLine();
                this.LogWriter.WriteLine(ex.StackTrace);
                return Marshal.GetHRForException(ex);
            }

            // log all info
            this.LogWriter.WriteLine("Builds:               {0}", this.tfsBuildCollection.Count);

            // iterate each build in the collection
            foreach (TfsBuild tfsBuild in this.tfsBuildCollection)
            {
                this.LogWriter.WriteLine("  Build:");
                this.LogWriter.WriteLine("    Build Definition: {0}", tfsBuild.BuildDefinition);
                this.LogWriter.WriteLine("    Build Number:     {0}", tfsBuild.BuildNumber);
                this.LogWriter.WriteLine("    Build Drop:       {0}", tfsBuild.BuildDrop);
                this.LogWriter.WriteLine("    Build Uri:        {0}", tfsBuild.Uri);
                this.LogWriter.WriteLine("    Status:           {0}", tfsBuild.Status);
                this.LogWriter.WriteLine("    Quality:          {0}", tfsBuild.Quality);

                foreach (TfsBuildConfiguration tfsBuildConfiguration in tfsBuild.BuildConfigurations)
                {
                    this.LogWriter.WriteLine("      Configuration:");
                    this.LogWriter.WriteLine("        Flavor:       {0}", tfsBuildConfiguration.Flavor);
                    this.LogWriter.WriteLine("        Platform:     {0}", tfsBuildConfiguration.Platform);

                    if (false == String.IsNullOrEmpty(tfsBuildConfiguration.LogFile))
                    {
                        this.LogWriter.WriteLine("        Log File:     {0}", tfsBuildConfiguration.LogFile);
                    }

                    this.LogWriter.WriteLine("        Errors:       {0}", tfsBuildConfiguration.Errors);
                    this.LogWriter.WriteLine("        Warnings:     {0}", tfsBuildConfiguration.Warnings);
                }

                // check if the build should be deleted
                if (null != this.NamedArgsCollection["delete"])
                {
                    bool delete = false;

                    if ("quiet" == this.NamedArgsCollection["delete"])
                    {
                        delete = true;
                    }
                    else
                    {
                        // prompt for deletion
                        Console.Write("Are you sure you want to delete this build and all of its data (Y/N)?");
                        string response = Console.ReadLine();

                        if (("Y" == response) || ("y" == response))
                        {
                            delete = true;
                        }
                    }

                    // delete the build
                    if (true == delete)
                    {
                        tfsBuild.Delete();
                    }
                }
            }

            this.LogWriter.WriteLine();

            return 0;
        }

        /// <summary>
        /// Gets the tfs build spec from the command line parameters
        /// </summary>
        /// <returns>The tfs build spec that defines the query conditions for a build</returns>
        private TfsBuildSpec GetBuildSpec(TfsProject tfsProject)
        {
            // create the build spec
            TfsBuildSpec tfsBuildSpec = new TfsBuildSpec();

            // get the build number
            if (null != this.NamedArgsCollection["buildNumber"])
            {
                tfsBuildSpec.BuildNumber = this.NamedArgsCollection["buildNumber"];

                this.LogWriter.WriteLine("Build Number:         {0}", tfsBuildSpec.BuildNumber);
            }

            // get the build status
            if (null != this.NamedArgsCollection["buildStatus"])
            {
                string[] buildStatus = this.NamedArgsCollection["buildStatus"].Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                StringBuilder stringBuilder = new StringBuilder();

                // update the build status
                tfsBuildSpec.Status = (TfsBuildStatus)Enum.Parse(typeof(TfsBuildStatus), buildStatus[0], true);

                // update the build status string
                stringBuilder.Append(tfsBuildSpec.Status.ToString());

                for (int index = 1; index < buildStatus.Length; index++)
                {
                    // update the build status
                    TfsBuildStatus tfsBuildStatus = (TfsBuildStatus)Enum.Parse(typeof(TfsBuildStatus), buildStatus[index], true);
                    tfsBuildSpec.Status |= tfsBuildStatus;

                    // update the build status string
                    stringBuilder.Append(" | ");
                    stringBuilder.Append(tfsBuildStatus.ToString());
                }

                this.LogWriter.WriteLine("Build Status:         {0}", stringBuilder.ToString());
            }

            // get the build quality
            if (null != this.NamedArgsCollection["buildQuality"])
            {
                // get the build qualities
                TfsBuildQualityCollection tfsBuildQualities = tfsProject.GetBuildQualities();

                string buildQuality = this.NamedArgsCollection["buildQuality"];

                // get the build quality
                tfsBuildSpec.Quality = tfsBuildQualities[buildQuality];

                this.LogWriter.WriteLine("Build Quality:        {0}", tfsBuildSpec.Quality);
            }

            this.LogWriter.WriteLine();

            return tfsBuildSpec;
        }

        /// <summary>
        /// Query all of the builds for the project
        /// </summary>
        /// <param name="serverName">The specified server name</param>
        /// <param name="projectName">The specified project name</param>
        private void QueryBuilds(string serverName, string projectName)
        {
            // create the project instance
            TfsProject tfsProject = new TfsProject(serverName, projectName);

            // get the build spec
            TfsBuildSpec tfsBuildSpec = this.GetBuildSpec(tfsProject);

            // query the builds
            this.tfsBuildCollection = tfsProject.QueryBuilds(tfsBuildSpec);
        }

        /// <summary>
        /// Query all of the builds for the build definition
        /// </summary>
        /// <param name="serverName">The specified server name</param>
        /// <param name="projectName">The specified project name</param>
        private void QueryBuildsByDefinition(string serverName, string projectName)
        {
            // create the project instance
            TfsProject tfsProject = new TfsProject(serverName, projectName);

            // get the build definition
            string buildDefinition = this.NamedArgsCollection["buildDefinition"];

            // log all info
            this.LogWriter.WriteLine("Build Definition:     {0}", buildDefinition);

            // get the build spec
            TfsBuildSpec tfsBuildSpec = this.GetBuildSpec(tfsProject);

            // get the build definition
            TfsBuildDefinition tfsBuildDefinition = tfsProject.GetBuildDefinition(buildDefinition);

            // query the builds
            this.tfsBuildCollection = tfsBuildDefinition.QueryBuilds(tfsBuildSpec);
        }

        private static int Main(string[] args)
        {
            // create the tfs query builds instance
            TfsQueryBuildsConsole tfsQueryBuildsConsole = new TfsQueryBuildsConsole(args);

            // run
            return tfsQueryBuildsConsole.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\SetTimestampProperty.cpp ===
#include "stdafx.h"

int FormatTimestamp(LPWSTR pwszTimestamp, DWORD dwTimestampLen, LPWSTR pwszFormatString, ...)
{
    int iRet;

    ::memset((void *)pwszTimestamp, 0, dwTimestampLen);
    va_list args;
    va_start(args, pwszFormatString);
    iRet = ::_vsnwprintf_s(pwszTimestamp, dwTimestampLen, _TRUNCATE, pwszFormatString, args);
    return iRet;
}

UINT __stdcall SetTimestampProperty(MSIHANDLE hInstall)
{
    UINT        uiRet;
    int         iRet;

    WCHAR       wszTimestamp[256];
    SYSTEMTIME  st;

    ::GetLocalTime(&st);
    iRet = FormatTimestamp(wszTimestamp, 256, L"_%04d%02d%02d_%02d%02d%02d%03d", st.wYear, st.wMonth, st.wDay, st.wHour,
        st.wMinute, st.wSecond, st.wMilliseconds);

    if(0 > iRet)
    {
        return ERROR_INSTALL_FAILURE;
    }

    uiRet = ::MsiSetProperty(hInstall, L"LOGTIMESTAMP", wszTimestamp);

    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <wchar.h>
#include <msi.h>
#include <msiquery.h>

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\TfsCreateBuildMain.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsCreateBuildMain.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   manually creates a build in a tfs project
// </summary>
//-----------------------------------------------------------------------
// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace TfsCreateBuild
{
    using System;

    /// <summary>
    /// TfsCreateBuildMain exposes the entry point for this application
    /// </summary>
    public sealed class TfsCreateBuildMain
    {
        /// <summary>
        /// Prevents a default instance of the TfsCreateBuildMain class from being created.
        /// </summary>
        private TfsCreateBuildMain()
        {
        }

        /// <summary>
        /// The entry point for this application
        /// </summary>
        /// <param name="args">The array of command line arguments</param>
        public static void Main(string[] args)
        {
            try
            {
                TfsCreateBuild tfsCreateBuild = new TfsCreateBuild();

                tfsCreateBuild.CreateBuild(args[0], args[1], args[2]);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine();
                Console.WriteLine(ex.StackTrace);
                Console.WriteLine();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\TfsCreateBuild.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TfsCreateBuild.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to create a build in a tfs project
// </summary>
//-----------------------------------------------------------------------
namespace TfsCreateBuild
{
    using System;

    using Microsoft.TeamFoundation.Build.Client;
    using Microsoft.TeamFoundation.Client;

    using Common.LongPath;

    /// <summary>
    /// TfsCreateBuild exposes a method to create a build in a tfs project
    /// </summary>
    internal sealed class TfsCreateBuild : IDisposable
    {
        /// <summary>
        /// buildDefinition is the interface to the build definition object model
        /// </summary>
        private IBuildDefinition buildDefinition;

        /// <summary>
        /// buildDetail is the interface to the build detail object model
        /// </summary>
        private IBuildDetail buildDetail;

        /// <summary>
        /// buildResult is the results for the build
        /// </summary>
        private BuildResult buildResult;

        /// <summary>
        /// buildServer is the interface to the build server object model
        /// </summary>
        private IBuildServer buildServer;

        /// <summary>
        /// config is the config object for accessing the configuration
        /// </summary>
        private Config config = new Config();

        /// <summary>
        /// teamFoundationServer is the interface to the team foundation server object model
        /// </summary>
        private TeamFoundationServer teamFoundationServer;

        /// <summary>
        /// Create a build with the specified build number
        /// </summary>
        /// <param name="buildDefinitionName">The specified build definition name to use for this build</param>
        /// <param name="buildNumber">The specified build number to use for this build</param>
        /// <param name="buildLogShare">The share location of the build logs to parse for errors and warnings</param>
        public void CreateBuild(string buildDefinitionName, string buildNumber, string buildLogShare)
        {
            // Create the build result
            this.CreateBuildResult(buildLogShare);
            if (false == this.buildResult.Completed)
            {
                return;
            }

            // Get the team foundation server
            this.teamFoundationServer = new TeamFoundationServer(this.config.ServerName);

            // Get the interface to the build server object model
            this.buildServer = (IBuildServer)teamFoundationServer.GetService(typeof(IBuildServer));

            // Create the build definition
            this.CreateBuildDefinition(buildDefinitionName);

            // Create the build detail
            this.buildDetail = this.buildDefinition.CreateManualBuild(buildNumber);

            // Create the configuration and compilation summary
            this.CreateSummary();

            // Create the drop location
            this.CreateDropLocation();

            // Save the build detail
            this.SaveBuildDetail();
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting resources
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        public void Dispose(bool disposing)
        {
            if (true == disposing)
            {
                if (null != this.teamFoundationServer)
                {
                    this.teamFoundationServer.Dispose();
                }
            }
        }

        /// <summary>
        /// Creates the specified directory
        /// </summary>
        /// <param name="path">The path to the directory</param>
        private static void CreatePath(string path)
        {
            try
            {
                LongPath.CreateDirectory(path);
            }
            catch (System.ComponentModel.Win32Exception)
            {
            }
        }

        /// <summary>
        /// Creates a build agent using the tfs server name.
        /// If a matching build agent already exists, it will return that build agent.
        /// </summary>
        /// <returns>The IBuildAgent instance of the specified build agent.</returns>
        private IBuildAgent CreateBuildAgent()
        {
            try
            {
                // Create the build agent
                IBuildAgent buildAgent = this.buildServer.CreateBuildAgent(this.config.ProjectName);

                // Set the build agent
                buildAgent.MachineName = this.buildServer.TeamFoundationServer.Name;
                buildAgent.Name = this.buildServer.TeamFoundationServer.Name;

                // Save the build agent
                this.buildServer.SaveBuildAgents(new IBuildAgent[] { buildAgent });

                return buildAgent;
            }
            catch (BuildAgentAlreadyExistsException)
            {
                // Get the build agent
                return this.GetBuildAgent();
            }
        }

        /// <summary>
        /// Creates a build definition using the specified build definition name.
        /// If a matching build definition already exists, it will return that build definition.
        /// </summary>
        /// <param name="buildDefinitionName">The name of the build definition.</param>
        private void CreateBuildDefinition(string buildDefinitionName)
        {
            try
            {
                // Create the build definition
                IBuildDefinition buildDefinitionNew = this.buildServer.CreateBuildDefinition(this.config.ProjectName);

                // Set the build definition
                buildDefinitionNew.ConfigurationFolderPath = String.Format(@"$/{0}", this.config.ProjectName);
                buildDefinitionNew.DefaultBuildAgent = this.CreateBuildAgent();
                buildDefinitionNew.DefaultDropLocation = String.Format(@"{0}\{1}", this.config.ReleaseShare, buildDefinitionName);
                buildDefinitionNew.Name = buildDefinitionName;

                // Save the build definition
                this.buildServer.SaveBuildDefinitions(new IBuildDefinition[] { buildDefinitionNew });

                this.buildDefinition = buildDefinitionNew;
            }
            catch (BuildDefinitionAlreadyExistsException)
            {
                // Get the build definition
                this.buildDefinition = this.GetBuildDefinition(buildDefinitionName);
            }
        }

        /// <summary>
        /// Creates a build result and loads it with the log files from the specified log share
        /// </summary>
        /// <param name="buildLogShare">The path to the build logs on the release share</param>
        private void CreateBuildResult(string buildLogShare)
        {
            // Create the build result
            this.buildResult = new BuildResult();

            // Load the build results
            this.buildResult.Load(buildLogShare, this.config.Configurations);
        }

        /// <summary>
        /// Creates the directories under the drop location
        /// </summary>
        private void CreateDropLocation()
        {
            // Create the root
            TfsCreateBuild.CreatePath(this.buildDetail.BuildDefinition.DefaultDropLocation);

            // Create the build number
            string path = this.buildDetail.BuildDefinition.DefaultDropLocation + "\\" + this.buildDetail.BuildNumber;
            TfsCreateBuild.CreatePath(path);
        }

        /// <summary>
        /// Creates the configuration summary and the compilation summary
        /// </summary>
        private void CreateSummary()
        {
            foreach (BuildConfigurationResult buildConfigurationResult in this.buildResult.BuildConfigurationResults)
            {
                // Create the configuration summary
                IConfigurationSummary configurationSummary = InformationNodeConverters.AddConfigurationSummary(this.buildDetail, buildConfigurationResult.Flavor, buildConfigurationResult.Platform, buildConfigurationResult.LogFile);

                // Create the compilation summary
                ICompilationSummary compilationSummary = configurationSummary.AddCompilationSummary();

                compilationSummary.CompilationErrors = buildConfigurationResult.Errors;
                compilationSummary.CompilationWarnings = buildConfigurationResult.Warnings;

                // Save the compilation summary
                compilationSummary.Save();

                // Save the configuration summary
                configurationSummary.Save();
            }
        }

        /// <summary>
        /// Gets the build agent with the specified tfs server name.
        /// </summary>
        /// <returns>The IBuildAgent instance of the specified build agent.</returns>
        private IBuildAgent GetBuildAgent()
        {
            // Get the build agents
            foreach (IBuildAgent buildAgent in this.buildServer.QueryBuildAgents(this.config.ProjectName))
            {
                if (buildAgent.Name == this.buildServer.TeamFoundationServer.Name)
                {
                    return buildAgent;
                }
            }

            throw new InvalidOperationException("SaveBuildAgents threw BuildAgentAlreadyExistsException but QueryBuildAgents did not return a matching build agent.");
        }

        /// <summary>
        /// Gets the build definition with the specified build definition name.
        /// </summary>
        /// <param name="buildDefinitionName">The name of the build definition.</param>
        /// <returns>The IBuildServer instance of the specified build definition.</returns>
        private IBuildDefinition GetBuildDefinition(string buildDefinitionName)
        {
            // Get the build definitions
            foreach (IBuildDefinition buildDefinitionNew in this.buildServer.QueryBuildDefinitions(this.config.ProjectName))
            {
                if (buildDefinitionNew.Name == buildDefinitionName)
                {
                    return buildDefinitionNew;
                }
            }

            throw new InvalidOperationException("SaveBuildDefinitions threw BuildDefinitionAlreadyExistsException but QueryBuildDefinitions did not return a matching build definition.");
        }

        /// <summary>
        /// Saves the build detail
        /// </summary>
        private void SaveBuildDetail()
        {
            // Set the build drop location
            this.buildDetail.DropLocation = this.buildDetail.BuildDefinition.DefaultDropLocation + "\\" + this.buildDetail.BuildNumber;

            // Set the status
            if (0 < this.buildResult.Errors)
            {
                this.buildDetail.CompilationStatus = BuildPhaseStatus.Failed;
                this.buildDetail.Status = BuildStatus.Failed;
            }
            else if (0 < this.buildResult.Warnings)
            {
                this.buildDetail.CompilationStatus = BuildPhaseStatus.Unknown;
                this.buildDetail.Status = BuildStatus.PartiallySucceeded;
            }
            else
            {
                this.buildDetail.CompilationStatus = BuildPhaseStatus.Succeeded;
                this.buildDetail.Status = BuildStatus.Succeeded;
            }

            // Save the build detail
            this.buildDetail.Save();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_timestampprop_none_12.4.56.0_none_79711b0392642f99
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=timestampprop
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.manifest
XP_MANIFEST_PATH=manifests\x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.cat
XP_CATALOG_PATH=manifests\x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.cat
XP_PAYLOAD_PATH=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=timestampprop,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TimeStampProp\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_timestampprop_none_12.4.56.0_none_79711b0392642f99
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=timestampprop
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.manifest
XP_MANIFEST_PATH=manifests\x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.cat
XP_CATALOG_PATH=manifests\x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f.cat
XP_PAYLOAD_PATH=x86_timestampprop_no-public-key_12.4.56.0_x-ww_53a2c78f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=timestampprop,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TfsCreateBuild\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TfsCreateBuild")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("TfsCreateBuild")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f432f627-638f-47bd-9c64-5c4050f8fe2f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CConsoleCtrl.cs ===
using System;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;

namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// This will catch the ctrl-c event
    /// </summary>
    public class CConsoleCtrl: IDisposable
    {
        /// <summary>
        /// Which event was called?  This tells us
        /// </summary>
        public enum ConsoleEvent
        {
            CTRL_C = 0, // in wincom.h
            CTRL_BREAK = 1,
            CTRL_CLOSE = 2,
            CTRL_LOGOFF = 5,
            CTRL_SHUTDOWN = 6
        }

        /// <summary>
        /// This is what is called when ctrl-c is pressed
        /// </summary>
        public delegate void ControlEventHandler(ConsoleEvent consoleEvent);

        /// <summary>
        /// same as above
        /// </summary>
        public event ControlEventHandler ControlEvent;

        ControlEventHandler eventHandler;

        /// <summary>
        /// Create a new instance.
        /// </summary>
        public CConsoleCtrl()
        {
            // save this to a private var so the GC doesn't collect it...
            eventHandler = new ControlEventHandler(Handler);
            SetConsoleCtrlHandler(eventHandler, true);
        }

        ~CConsoleCtrl()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
        }

        void Dispose(bool disposing)
        {
            if (eventHandler != null)
            {
                SetConsoleCtrlHandler(eventHandler, false);
                eventHandler = null;
            }
        }

        private void Handler(ConsoleEvent consoleEvent)
        {
            if (ControlEvent != null)
                ControlEvent(consoleEvent);
        }

        [DllImport("kernel32.dll")]
        static extern bool SetConsoleCtrlHandler(ControlEventHandler e, bool add);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CDisable.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.Xml;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr
{
    /// <summary>
    /// Summary description for CDisable.
    /// </summary>
    public class CDisable
    {
        public CDisable()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        public static void Exec(string titleid)
        {
            string dir = Environment.CurrentDirectory + "\\" + titleid;
            if (!Directory.Exists(dir))
            {
                CTitleMgrApp.WriteLine("FAIL: " + titleid + " not in current repository");
                return;
            }

            string versionFile = dir + "\\config\\versions.ini";

            Ini versionIni = new Ini(versionFile);

            if (versionIni.GetSetting("STATUS", "NOSYNC") == "TRUE")
            {
                CTitleMgrApp.WriteLine("FAIL: Title " + titleid + " already disabled");
                return;
            }

            RunWebstoreCommand("p_svc_delete_versions", titleid);

            //now we have to edit the versions.ini and add NOSYNC=TRUE
            CSourceDepot sd = new CSourceDepot();

            sd.Edit(versionFile);

            versionIni.SetSetting("STATUS", "NOSYNC", "TRUE");

            versionIni.Save(versionFile);

            sd.Submit(versionFile, "Disabled title");

            CPropUtils.UpdateXKDCCache();

            CTitleMgrApp.WriteLine("Disable: Success");
        }


        static void RunWebstoreCommand(string sp, string titleid)
        {
            uint hr = 0;

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    ws.PhysicalPartition = i;
                    ws.StoredProc = sp;

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                    ws.AddParameter(ParamType.INPUT, "@i_title_id", Int32.Parse(titleid, System.Globalization.NumberStyles.HexNumber));

                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@RETVAL");

                    ws.Close();
                }
            }

            if (hr != 0)
                CTitleMgrApp.WriteLineV("Nothing to delete in webstore");

            return;

        } //RunWebstoreCommand

        public static void Enable(string titleid)
        {
            string dir = Environment.CurrentDirectory + "\\" + titleid;
            if (!Directory.Exists(dir))
            {
                CTitleMgrApp.WriteLine("FAIL: " + titleid + " not in current repository");
                return;
            }

            string versionFile = dir + "\\config\\versions.ini";

            Ini versionIni = new Ini(versionFile);

            if (versionIni.GetSetting("STATUS", "NOSYNC") != "TRUE")
            {
                CTitleMgrApp.WriteLine("FAIL: Title " + titleid + " not disabled");
                return;
            }

            //now we have to edit the versions.ini and add NOSYNC=TRUE
            CSourceDepot sd = new CSourceDepot();

            sd.Edit(versionFile);

            versionIni.SetSetting("STATUS", "NOSYNC", null);

            versionIni.Save(versionFile);

            sd.Submit(versionFile, "Enabled title");

            CTitleMgrApp.WriteLine("Title + " + titleid + " enabled.  Please sync to reenable the title.");

            //CSync.Exec(titleid, true);
        }

        public static bool Check(string titleid)
        {
            string dir = Environment.CurrentDirectory + "\\" + titleid;
            if (!Directory.Exists(dir))
            {
                CTitleMgrApp.WriteLine("FAIL: " + titleid + " not in current repository");
                return false;
            }

            if (titleid.Length != 8)
            {
                CTitleMgrApp.WriteLine("FAIL: " + titleid + " has bad format.  Requires length of 8");
                return false;
            }

            string versionFile = dir + "\\config\\versions.ini";

            Ini versionIni = new Ini(versionFile);

            if (versionIni.GetSetting("STATUS", "NOSYNC") == "TRUE")
            {
                //this shouldn't FAIL unittest
                CTitleMgrApp.WriteLine("Title " + titleid + " disabled.");
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CExempt.cs ===
using System;
using System.Globalization;
using xonline.common.config;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr
{
    /// <summary>
    /// Summary description for CExempt.
    /// </summary>
    public class CExempt
    {
        public CExempt()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        public static uint Exec(string titleid, string exempt)
        {
            uint hr = 0;
            CSourceDepot sd = null;

            try
            {
                bool skip = false;

                if(exempt != "0" && exempt != "1")
                {
                    CTitleMgrApp.HelpExempt();
                    throw new ApplicationException("/exempt: Invalid argument (must be 0 or 1)!");
                }

                //are we making the title exempt, or non-exempt
                if (exempt == "0")
                {
                    return ExecOff(titleid);
                }

                //first we add this to the database
                int ntitleid = Int32.Parse(titleid, NumberStyles.HexNumber);

                string dir = Environment.CurrentDirectory + "\\" + titleid + "\\config\\";

                Ini version = new Ini(dir + "versions.ini");

                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                try
                {
                            ws.StoredProc = "dbo.p_xprof_insert_exempt_title";
                            ws.AddParameter(ParamType.INPUT, "@i_title_id", ntitleid);
                    ws.ExecuteNonQuery();
                            ws.Close();
                }
                catch(Exception)
                {
                    CTitleMgrApp.WriteLineV("Title " + titleid + " already has exempt status in db");
                    skip = true;
                }
                    }
                }

                if (!skip)
                {
                    CTitleMgrApp.WriteLine("Title " + titleid + " inserted into exempt table");


                    version.SetSetting("VERSION", "MakeExempt", null); //remove the MakeExempt, if it was there
                    version.SetSetting("STATUS", "EXEMPT", DateTime.Now.ToString("MM/dd/yyyy hh:mm"));

                    sd = new CSourceDepot();

                    sd.Edit(dir + "versions.ini");
                    version.Save(dir + "versions.ini");
                    sd.Submit(dir + "versions.ini", "Updated versions.ini for exempt status");
                }
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = 1; //failed
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished();
                }
            }

            return hr;
        }

        public static uint ExecOff(string titleid)
        {
            uint hr = 0;
            CSourceDepot sd = null;

            try
            {
                //first we add this to the database
                int ntitleid = Int32.Parse(titleid, NumberStyles.HexNumber);

                string dir = Environment.CurrentDirectory + "\\" + titleid + "\\config\\";

                Ini version = new Ini(dir + "versions.ini");

                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                try
                {
                            ws.StoredProc = "dbo.p_xprof_delete_exempt_title";
                            ws.AddParameter(ParamType.INPUT, "@i_title_id", ntitleid);
                    ws.ExecuteNonQuery();
                            ws.Close();
                }
                catch(Exception)
                {
                    throw new ApplicationException("Title " + titleid + " already has exempt status in db");
                        }
                    }
                }

                CTitleMgrApp.WriteLine("Title " + titleid + " removed from exempt table");

                version.SetSetting("VERSION", "MakeExempt", null); //remove the MakeExempt, if it was there
                version.SetSetting("STATUS", "EXEMPT", null); //this line would be false...

                sd = new CSourceDepot();

                sd.Edit(dir + "versions.ini");
                version.Save(dir + "versions.ini");
                sd.Submit(dir + "versions.ini", "Updated versions.ini for exempt status");

            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = 1; //failed
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(titleid);
                    sd = null;
                }
            }

            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CMgmtCommand.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;

namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// 
	/// </summary>
	public class CMgmtCommand
	{
        public static string Exec(string target, string command)
        {
            //add this pair to the queue if it isn't already there
            CTitleMgrApp.AddMgmtCommand(target, command);

            return "Command has been queued until later";
        }

        public static string RunCommand(string target, string command)
        {
            TcpClient client = new TcpClient();
            string result = null;
            
            try
            {
                CTitleMgrApp.WriteLineV("Before connect: " + target + " : " + command);
                client.NoDelay = true;
                client.Connect(target, 4100);

                CTitleMgrApp.WriteLineV("After connect");
                client.ReceiveTimeout = 10 * 1000;
                client.SendTimeout = 10 * 1000;

                NetworkStream stream = client.GetStream();
                StreamReader reader = new StreamReader(stream);

                if(stream.CanWrite && stream.CanRead)
                {
                    byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                    CTitleMgrApp.WriteLineV("Before send: " + command);
                    stream.Write(sendBytes, 0, sendBytes.Length);

                    CTitleMgrApp.WriteLineV("Before read 1");

                    //  Second line is the response text, this is what we return
                    result = reader.ReadLine();

                    CTitleMgrApp.WriteLineV("Before read 2");

                    result = reader.ReadLine();

                    
                }
                else
                    return null;
            }
            catch (Exception e)
            {
                //CTitleMgrApp.WriteLine("FAIL: CMgmtCommand - " + e.Message);
                result = "FAIL: " + e.Message;
            }
            finally
            {
                client.Close();
            }

            return result;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CMatchDB.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Threading;

namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// 
	/// </summary>
    public class CMatchDB
    {
        /// <summary>
        /// Execute the matchdb command.
        /// </summary>
        public static void Exec(string titleid, string matchDBIndex)
        {
            string matchIniFile = Environment.CurrentDirectory + "\\" + titleid.ToLower() + "\\config\\match.ini";
            string destPath     = Environment.CurrentDirectory + "\\" + titleid.ToLower() + "\\matchsp";
            string sqlFile      = destPath + "\\" + titleid.ToLower() + ".sql";
            
            CSourceDepot sd = null;

            try
            {
                string titlesDB     = CTitleMgrApp.Servers.GetSetting("SERVERS", "NPDB");
                string matchFDs     = CTitleMgrApp.Servers.GetSetting("SERVERS", "MATCHFD");
                string matchDBs     = CTitleMgrApp.Servers.GetSetting("SERVERS", "MATCHDB");
                    
                if(titlesDB.Length == 0)
                {
                    throw new ApplicationException("NPDB database not specified in servers.ini.");
                }

                if(matchFDs.Length == 0)
                {
                    throw new ApplicationException("Matchmaking front doors not specified in servers.ini.");
                }

                //make sure we have a correct index
                int nMatchDBIndex = Int32.Parse(matchDBIndex);

                string [] rDBs = matchDBs.Split(';');

                if (nMatchDBIndex >= rDBs.Length)
                {
                    CTitleMgrApp.WriteLine("FAIL: The matchdb index you specified was too high");
                    return;
                }

                sd = new CSourceDepot();

                string matchDBAddr = CTitleMgrApp.GetServerAddress("MATCHDB", nMatchDBIndex);

                //
                //  Sync and checkout match.ini
                //

                CTitleMgrApp.WriteLineV("Checking out match.ini.");
                sd.Sync(matchIniFile);
                sd.Edit(matchIniFile);

                
                //
                //  Write out the new match.ini file
                //


                Ini matchINI = new Ini(matchIniFile);

                matchINI.SetSetting("SETTINGS", "MATCHDB", matchDBIndex);

                matchINI.Save(matchIniFile);

                sd.Submit(matchIniFile, "Updated matchdb server");

                //
                //  Now execute SQL file against new match DB
                //

                if (File.Exists(sqlFile))
                {
                    CTitleMgrApp.WriteLine("Running generated SQL against " + matchDBAddr + "...");
                    if(CTitleMgrApp.RunOSqlCommand(matchDBAddr, "xmatch", sqlFile, destPath) != 0)
                    {
                        throw new ApplicationException("Failed!!!");
                    }

                    CTitleMgrApp.WriteLine("Done!");
                }

                //
                //  Update t_match_titles row for this title
                //

                CTitleMgrApp.WriteLine("Updating title's row in t_match_titles on " + titlesDB + ".");
                int iTitleID = Int32.Parse(titleid, NumberStyles.HexNumber);
                CTitleMgrApp.RunSqlCommand(titlesDB, 
                                           "npdb", 
                                           "exec p_match_title_update_db " + 
                                             iTitleID.ToString() + 
                                             ",'" + matchDBAddr + "'");

                //
                //  Finally, tell all the matchmaking front doors to reload title information
                //

                CTitleMgrApp.WriteLine("Telling all matchmaking front doors to reload their cached title information.");
                string [] matchFDArray = matchFDs.Split(';');
                foreach(string matchFD in matchFDArray)
                {
                    string output = CMgmtCommand.Exec(matchFD, "exec :XMatchFD reloadtitleinfo\r\n");
                    CTitleMgrApp.WriteLine(matchFD + ":  " + output);
                }

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(titleid);
                    sd = null;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CNew.cs ===
/*
 *  This class is used to create a new title space. 
 * 
 * Create <titleid>\config\versions.ini file using version string passed on command line.
 * Create <titleid>\config\match.ini file using the matchdb passed on the command line.  
 *   First verify that matchdb matches one of the dbs specified in servers.ini.
 * Create <titleid>\config\stats.ini file using statsdb passed on the command line, 
 *   and populate the stats.ini file with the default leaderboards (1-20 = 0).  
 *   First verify that statsdb matches one of the dbs specified in servers.ini.
 * Create title description xml files in the <titleid>\message directory.  
 *   Each of these files would contain <title_description> as the description if passed, 
 *   otherwise just the title id in hex as the description.
 * If the /xms argument is passed then copy <path_to_xms> to <titleid>/matchsp/<titleid>.xms.
 * Add all of these new files to source depot and submit them.
*/
using System;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Threading;


namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// Summary description for CNew.
	/// </summary>
	public class CNew
	{
		static string _dir;
		static string _titleid;
		static CSourceDepot sd;
		static Stack filesToAdd;
        static int next_statsdb;
        static int next_matchdb;

		public CNew()
		{
			//
			// TODO: Add constructor logic here
			//
			_titleid = "";
			_dir = "";
		}

		public static void Exec(string titleid, string version, string matchDB, string statsDB, 
			string title_description, string pathtoxms, bool bExempt )
		{
            bool failed = true;

            try
            {
                if (titleid.Length != 8)
                    throw new ApplicationException("");

                Int32.Parse(titleid, NumberStyles.HexNumber);
            }
            catch (Exception)
            {
                CTitleMgrApp.WriteLine("FAIL: Invalid titleid.  titleid must be 8 HEX letters/numbers long.");
                return;
            }

            if (title_description.Length > CNameTranslations.c_iMaxTitleNameLength)
            {
                CTitleMgrApp.WriteLine(
                    "FAIL: title description may not be longer than "
                    +CNameTranslations.c_iMaxTitleNameLength
                    +" characters");
                return;
            }

            try
            {
                CTitleMgrApp.WriteLine("Creating new repository for " + titleid);
                sd = new CSourceDepot();

                //make sure titleid doesn't already exist
                if (Directory.Exists(Environment.CurrentDirectory + "\\" + titleid))
                {
                    CTitleMgrApp.WriteLine("FAIL: This title, " + titleid + ", already exists.  Can't create.");
                    return;
                }

                Ini load;

                if (File.Exists("load.ini"))
                {
                    load = new Ini("load.ini");
                    sd.Edit("load.ini");
                }
                else
                {
                    load = new Ini();

                    load.SetSetting("servers", "matchdb", "0");
                    load.SetSetting("servers", "statsdb", "0");

                    load.Save("load.ini");
                    sd.Add("load.ini");

                }
            
                if (matchDB == null)
                {
                    next_matchdb = Int32.Parse(load.GetSetting("servers", "matchdb"));

                    next_matchdb++;

                    if (next_matchdb >= GetNumServers("MATCHDB"))
                        next_matchdb = 0;

                    matchDB = next_matchdb.ToString();

                    load.SetSetting("servers", "matchdb", matchDB);
                }

                if (statsDB == null)
                {
                    next_statsdb = Int32.Parse(load.GetSetting("servers", "statsdb"));

                    next_statsdb++;

                    if (next_statsdb >= GetNumServers("STATSDB"))
                        next_statsdb = 0;

                    statsDB = next_statsdb.ToString();

                    load.SetSetting("servers", "statsdb", statsDB);
                }

                load.Save("load.ini");
                sd.Submit("load.ini", "Updated load balancing ini file");
                    

                //this calls functions that take care of everything (including adding/submitting to sd)
                filesToAdd = new Stack();
		
                //first create all directories we'll need
                if (!CreateDirs(titleid))
                    return;

                //now create match.ini using the db they passed (first, verify that it matches a server in servers.ini)
                //if db isn't in servers.ini, fail
                if (!CreateMatchIni(matchDB))
                    return;

                //now create stats.ini, verify the db they passed is in servers.ini, fill the file with 1-20=0
                if (!CreateStatsIni(statsDB))
                    return;
			

                //now create all the title description files (1 for each language).  use title_description if passed
                CreateTitleDescriptions(title_description);

                //if xms is passed, then copy the file they point to to the matchsp dir
                if (pathtoxms != null && pathtoxms.Length > 0)
                {
                    CopyXMS(pathtoxms);
                }

                //now create versions.ini using the version they passed
                CreateVersionsIni(version, bExempt);

                //no errors yet - add files
                failed = false;

                foreach (string file in filesToAdd)
                {
                    CTitleMgrApp.WriteLine(file);
                    sd.Add(file);
                    sd.Submit(file, "/new submit for " + titleid);
                }

                CTitleMgrApp.WriteLine("Created new repository for " + titleid);
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                CTitleMgrApp.WriteLine("Repository not created");

                if (failed)
                {
                    CTitleMgrApp.WriteLine("Deleting directory");
                    Directory.Delete(Environment.CurrentDirectory + "\\" + titleid, true);
                }
            }
		}

		public static void CopyXMS(string pathtoxms)
		{
			/*
			 * If the /xms argument is passed then copy <path_to_xms> to <titleid>/matchsp/<titleid>.xms.
			*/

			string fname = _dir + "\\matchsp\\" + _titleid + ".xms";
			//copy the file, fail if the file already exists
			System.IO.File.Copy(pathtoxms, fname, false);

			filesToAdd.Push(fname);
		}

		public static void CreateTitleDescriptions(string title_description)
		{
			/*
			 * Create title description xml files in the <titleid>\message directory.  
			 *   Each of these files would contain <title_description> as the description if passed, 
			 *   otherwise just the title id in hex as the description.
			*/

			string []langs = {"english", "japanese", "german", "french", "spanish", 
								 "italian", "korean", "chinese", "portuguese"};

			long iTitleID = Int64.Parse(_titleid, System.Globalization.NumberStyles.HexNumber);

			if (title_description == null || title_description.Length == 0)
				title_description = "0x" + _titleid.ToUpper();

			for (int i = 0; i < langs.Length; i++)
			{

				//create a separate file for each language
				string fname = _dir + "\\message\\titles." + langs[i] + ".xml";
				FileStream stream = new FileStream(fname, FileMode.CreateNew);
				StreamWriter writer = new StreamWriter(stream);
				
				//capitalize first letter
				langs[i].ToCharArray()[0] = Char.ToUpper(langs[i].ToCharArray()[0]);
				
				//output file
				writer.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\" ?>");

				//each lang has a specific number
				writer.WriteLine("  <msgstrings type=\"1\" language=\"" + (i + 1).ToString() + "\">");

				//each lang has it's own name in the description
				
				writer.WriteLine("    <msgmapping id=\"" + iTitleID.ToString() + "\">" + title_description + "</msgmapping>");
				writer.WriteLine("</msgstrings>");

				writer.Close();

				filesToAdd.Push(fname);

			}
		}

		public static bool CreateStatsIni(string statsDB)
		{
			/*
			 * Create <titleid>\config\stats.ini file using statsdb passed on the command line, 
			 *   and populate the stats.ini file with the default leaderboards (1-20 = 0).  
			 *   First verify that statsdb matches one of the dbs specified in servers.ini.
			*/



			//create the file, if it already exists, fail
			string fname = _dir + "\\config\\stats.ini";
			FileStream stream = new FileStream(fname, FileMode.CreateNew);
			StreamWriter writer = new StreamWriter(stream);

			//write settings to file
			writer.WriteLine("[SETTINGS]");
			writer.WriteLine("STATSDB="+statsDB);
			
			writer.Close();


			filesToAdd.Push(fname);


			return true;
		}

		public static bool CreateMatchIni(string matchDB)
		{
			/*
			 *  * Create <titleid>\config\match.ini file using the matchdb passed on the command line.  
			 *   First verify that matchdb matches one of the dbs specified in servers.ini.
			*/


			//create the file, if it already exists, fail
			string fname = _dir + "\\config\\match.ini";
			FileStream stream = new FileStream(fname, FileMode.CreateNew);
			StreamWriter writer = new StreamWriter(stream);

			//output settings to file
			writer.WriteLine("[SETTINGS]");
			writer.WriteLine("MATCHDB=" + matchDB);
			
			writer.Close();


			filesToAdd.Push(fname);

			return true;
		}

		public static void CreateVersionsIni(string version, bool bExempt)
		{
			/*
			 * Create <titleid>\config\versions.ini file using version string passed on command line.
			 *  
			 * 
			*/

            CPropUtils.VerifyVersion(version);

            string strVersionFile = _dir + "\\config\\versions.ini";

            if(File.Exists(strVersionFile))
            {
                throw new ApplicationException("File already exists: " + strVersionFile);
            }

            Ini versionIni = new Ini();

            versionIni.SetSetting("Version", "Initial", version);
            if(bExempt)
            {
                versionIni.SetSetting("Version", "MakeExempt", "1");
            }

            versionIni.Save(strVersionFile);

            filesToAdd.Push(strVersionFile);
		}


		public static bool CreateDirs(string titleid)
		{
			//create all dirs we'll be using

			//make sure it isn't empty
			if (titleid == null || titleid.Length == 0)
				return false;

			if (Int64.Parse(titleid, System.Globalization.NumberStyles.HexNumber) == 0)
				return false;

			_dir = Environment.CurrentDirectory + "\\" +  titleid.ToLower();
			_titleid = titleid;

			//Create <titleid>
			System.IO.Directory.CreateDirectory(_dir);

			//<titleid>\config
			System.IO.Directory.CreateDirectory(_dir + "\\config");

			//<titleid>\message
			System.IO.Directory.CreateDirectory(_dir + "\\message");

			//<titleid>\matchsp
			System.IO.Directory.CreateDirectory(_dir + "\\matchsp");

			return true;
		}

        private static int GetNumServers(string setting)
        {
            //get the total number of matchdb or statsdb servers in servers.ini
            string servers_db = CTitleMgrApp.Servers.GetSetting("SERVERS", setting);

            //servers are separated by ;
            string []servers = servers_db.Split(";".ToCharArray());

            return servers.Length;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CNewXMS.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;
using xonline.tools.framework;
using xonline.common.mgmt;

namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// 
    /// </summary>
    public class CNewXMS
    {
        /// <summary>
        /// Execute the newxms command.
        /// </summary>
        public static void Exec(
            string titleid, 
            string xmsFile, 
            bool dropTable,
            string sSdPort,
            string sSdClient,
            CLog log)
        {
            string titlePath            = Environment.CurrentDirectory.ToLower() + "\\" + titleid.ToLower();
            string matchIniFile         = titlePath + "\\config\\match.ini";
            string destPath             = titlePath + "\\matchsp";
            string destFileName         = titleid.ToLower() + ".xms";
            string destFile             = destPath + "\\" + destFileName;
            string sqlFileName          = titleid.ToLower() + ".sql";
            string titleInfoFileName    = titleid.ToLower() + "_title_info.sql";
            string sqlFile              = destPath + "\\" + sqlFileName;
            string titleInfoFile        = destPath + "\\" + titleInfoFileName;
            bool   bNewXMS;

            xonline.tools.framework.CSourceDepot sd = null;

            xmsFile = xmsFile.ToLower();
            
            try
            {
                sd = new xonline.tools.framework.CSourceDepot(sSdPort, sSdClient, log);

                //
                //  Sync the title's tree
                //

                sd.Sync(titlePath);
                
                //
                //  Does the specified source file even exist?
                //

                if (xmsFile.Length == 0)
                {
                    // using /titleid:all
                    xmsFile = destFile;
                }

                CPropUtils.VerifyExists(xmsFile);

                //
                // Check to see if the title id in the xms matches the input one
                //
                XmlDocument xmlDoc = new XmlDocument();

                xmlDoc.Load(xmsFile);

                XmlNodeList elemList = xmlDoc.GetElementsByTagName("title");
                bool bFoundTitle = false;

                for (int i=0; (i < elemList.Count) && (!bFoundTitle); i++)
                {   
                    string strTitleID = elemList[i].Attributes["id"].Value;
                    if(Convert.ToInt32(titleid, 16) == Convert.ToInt32(strTitleID, 16))
                    {
                        bFoundTitle = true;
                    }
                } 

                if(!bFoundTitle)
                {
                    throw new ApplicationException("The input title ID (" + titleid + ") does not match any of the title IDs in " + xmsFile + "!");
                }

                bNewXMS = ( destFile != xmsFile );

                //
                //  Open and read match.ini
                //

                if(!File.Exists(matchIniFile))
                {
                    throw new ApplicationException("File not found: \"" + matchIniFile + "\"");
                }

                Ini matchIni = new Ini(matchIniFile);

                // match now supports multiple match databases for one title, so the MATCHDB setting
                // is now a semicolon delimited list of database indexes, not a single database.
                // A database index of '1' means "use the first match server listed in servers.ini"
                string sMatchDBIndexes = matchIni.GetSetting("SETTINGS", "MATCHDB");
                if (sMatchDBIndexes == null || sMatchDBIndexes == String.Empty)
                {
                    throw new ApplicationException("Matchmaking database index not specified in match.ini.");
                }

                // we've got the list of match database indexes, parse each one out and 
                // look it up in servers.ini
                string[] rgsMatchDBIndexes = sMatchDBIndexes.Split(';');
                string sMatchDBList = String.Empty;
                foreach (string sMatchDBIndex in rgsMatchDBIndexes)
                {
                    int iMatchDBIndex = Int32.Parse(sMatchDBIndex);
                    string sMatchDB = CTitleMgrApp.GetServerAddress("MATCHDB", iMatchDBIndex);
                    if (sMatchDB == null)
                    {
                        throw new ApplicationException("Matchmaking database index " 
                            + iMatchDBIndex + " is missing from servers.ini.");
                    }
                    if (sMatchDBList != String.Empty)
                    {
                        sMatchDBList += ";";
                    }
                    sMatchDBList += CTitleMgrApp.GetServerAddress("MATCHDB", iMatchDBIndex);
                }

                // see if NONAT is set to true in the ini file
                bool bNoNat = false;
                string sNoNat = matchIni.GetSetting("SETTINGS", "NONAT");
                if (sNoNat.ToUpper().Trim() == "TRUE")
                {
                    bNoNat = true;
                }

                //
                //  Create destination directory if necessary
                //


                if(!Directory.Exists(destPath))
                {
                    Directory.CreateDirectory(destPath);
                }

                //
                //  Do the destination files exist in sd?
                //

                string [] files = sd.Files(destPath + "\\*", true);

                bool bXMSFileOpened = false;
                bool bSQLFileOpened = false;
                bool bTitleInfoFileOpened = false;

                bool bAddXMSFile = true;
                bool bAddSQLFile = true;
                bool bAddTitleInfoFile = true;

                for(int nCurrentFile = 0; nCurrentFile < files.Length; ++nCurrentFile)
                {
                    if(files[nCurrentFile].ToLower().IndexOf(destFileName) != -1)
                        bAddXMSFile = false;
                    if(files[nCurrentFile].ToLower().IndexOf(sqlFileName) != -1)
                        bAddSQLFile = false;
                    if(files[nCurrentFile].ToLower().IndexOf(titleInfoFileName) != -1)
                        bAddTitleInfoFile = false;
                    if(!bAddXMSFile && !bAddSQLFile && !bAddTitleInfoFile)
                        break;
                }

                //
                //  Sync and check out all files in the directory
                //

                if(!bAddXMSFile && bNewXMS)
                {
                    CTitleMgrApp.WriteLineV("Checking out \"" + destFile + "\".");
                    sd.Edit(destFile);
                    bXMSFileOpened = true;
                }
                
                if(!bAddSQLFile)
                {
                    CTitleMgrApp.WriteLineV("Checking out \"" + sqlFile + "\".");
                    sd.Edit(sqlFile);
                    bSQLFileOpened = true;
                }

                if(!bAddTitleInfoFile)
                {
                    CTitleMgrApp.WriteLineV("Checking out \"" + titleInfoFile + "\".");
                    sd.Edit(titleInfoFile);
                    bTitleInfoFileOpened = true;
                }

                //
                //  Copy the new file over
                //

                if(bNewXMS)
                {
                    CTitleMgrApp.WriteV("Copying \"" + xmsFile + "\" to \"" + destFile + "\"...");
                    File.Copy(xmsFile, destFile, true);
                    CTitleMgrApp.WriteLineV("Success");
                }

                //
                //  Execute xmltosql on the file
                //

                CTitleMgrApp.WriteLineV("Converting \"" + destFile + "\" to SQL...");
                string strArgs = "/in:" + destFile + " /dblist:" + sMatchDBList + " /tsunami";
                if (dropTable)
                    strArgs += " /droptable";
                if (bNoNat)
                    strArgs += " /nonat";
                CTitleMgrApp.RunCommandLine("xmltosql.exe", strArgs,
                                            destPath);
                CTitleMgrApp.WriteLineV("Success");

                //
                //  Add files if necessary
                //

                if(bAddXMSFile)
                {
                    CTitleMgrApp.WriteV("Adding \"" + destFile + "\" to the repository...");
                    sd.Add(destFile);
                    bXMSFileOpened = true;
                    CTitleMgrApp.WriteLineV("Success");
                }

                if(bAddSQLFile)
                {
                    CTitleMgrApp.WriteV("Adding \"" + sqlFile + "\" to the repository...");
                    sd.Add(sqlFile);
                    bSQLFileOpened = true;
                    CTitleMgrApp.WriteLineV("Success");
                }

                if(bAddTitleInfoFile)
                {
                    CTitleMgrApp.WriteV("Adding \"" + titleInfoFile + "\" to the repository...");
                    sd.Add(titleInfoFile);
                    bTitleInfoFileOpened = true;
                    CTitleMgrApp.WriteLineV("Success");
                }

                //
                //  Submit changes
                //

                CTitleMgrApp.WriteV("Submitting changes to the repository...");
                if(bXMSFileOpened)
                    sd.Submit(destFile, "titlemgr: Updating XMS and SQL files");
                if(bSQLFileOpened)
                    sd.Submit(sqlFile, "titlemgr: Updating XMS and SQL files");
                if(bTitleInfoFileOpened)
                    sd.Submit(titleInfoFile, "titlemgr: Updating XMS and SQL files");
                CTitleMgrApp.WriteLineV("Success");

                //
                //  Add title information to NPDB
                //

                string npdb = CTitleMgrApp.Servers.GetSetting("SERVERS", "NPDB");
                if(npdb == null || npdb.Length == 0)
                    CTitleMgrApp.WriteLine("No NPDB database specified in servers.ini.  Skipping execution of .sql files.");
                else
                {
                    CTitleMgrApp.WriteLine("Executing generated SQL title info file against NPDB");

                    if(CTitleMgrApp.RunOSqlCommand(npdb, "npdb", titleInfoFile, destPath) != 0)
                    {
                        CTitleMgrApp.WriteLine("\r\nFailed!!!");
                    }
                }

                //
                //  Now execute SQL file against match DB
                //

                string matchDBList = CTitleMgrApp.Servers.GetSetting("SERVERS", "MATCHDB");
                if(matchDBList == null || matchDBList.Length == 0)
                    CTitleMgrApp.WriteLine("No matchmaking databases specified in servers.ini.  Skipping execution of .sql files.");
                else
                {
                    string [] matchDBs = matchDBList.Split(';');

                    CTitleMgrApp.WriteLine("Executing generated SQL files against each matchmaking DB server...");

                    foreach(string curMatchDB in matchDBs)
                    {
                        CTitleMgrApp.WriteLineV(curMatchDB + "...");

                        if(CTitleMgrApp.RunOSqlCommand(curMatchDB, "xmatch", sqlFile, destPath) != 0)
                        {
                            CTitleMgrApp.WriteLine("\r\nFailed!!!");
                            continue;
                        }
                    }
                }


                ReloadMatch();

                CTitleMgrApp.WriteLine("SUCCESS: New XMS processed!");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }

        public static void ReloadMatch()
        {
            string matchFDList = CTitleMgrApp.Servers.GetSetting("SERVERS", "MATCHFD");
            if(matchFDList == null || matchFDList.Length == 0)
                CTitleMgrApp.WriteLineV("No matchmaking frontdoors in servers.ini.  Skipping execution reloadtitleinfo.");
            else
            {
                string [] matchFDs = matchFDList.Split(';');

                CTitleMgrApp.WriteLineV("Reloading titleinfo on matchmaking front doors.");

                foreach (string curMatchFD in matchFDs)
                {
                    CTitleMgrApp.WriteLineV(curMatchFD + "...");
                                                       
                    string output = CMgmtCommand.Exec(curMatchFD, "exec :XMatchFD reloadtitleinfo\r\n");
                    CTitleMgrApp.WriteLineV(output);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CPropUpdate.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.IO;
using xonline.common.service;

namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// Execute the update propping comands
    /// </summary>
    public class CPropUpdate
    {
        public static string DASHID = CTitleMgrApp.Servers.GetSetting("SERVERS", "DASHID");

        public static int RebuildUpdate(string strTitle, string strUpdatePath, string strControlFile, bool bModifyAllFiles, bool bFull)
        {
            string strRebuildFile  = "RebuildUpdate.exe";
            int hr = CPropUtils.HR_SUCCEEDED;
            
            try
            {
                //
                //  Do the working files exist?
                //
                CPropUtils.VerifyExists(strUpdatePath);
                CPropUtils.VerifyExists(strControlFile);
                
                Ini updateIni = new Ini(strControlFile);
                string strKey = updateIni.GetSetting("Autoupd", "Key");
                string strSite = updateIni.GetSetting("Package", "Site");
                string strType = updateIni.GetSetting("Package", "Type");
                bool   bSiteUpdateControlFile = false;

                if (strType != "AutoUpdate")
                    bSiteUpdateControlFile = true;

                string strXRLRoot = CPropUtils.GetIPs("XRLRoot", strSite);

                if (strXRLRoot.Length == 0)
                    throw new ApplicationException("No XRLRoots in site " + strSite);
                
                //
                // Prepare the .control file expected by RebuildContent
                //
                Ini tmpIni = new Ini();
                tmpIni.SetSetting("Autoupd", "XRLRoot", strXRLRoot);
                tmpIni.Save(strControlFile + ".tmp");

                string strArgs = "\"" + strUpdatePath + "\" \"" + strControlFile + ".tmp\"" + " ";

                //strArgs += "/titleid:" + strTitle + " ";

                //
                // Retail signed
                //
                strArgs += "-R ";

                if (CTitleMgrApp.DefaultUpdate)
                    strArgs += "-T:" + strTitle + " ";
                
                if(CPropUtils.uiKeyLength == strKey.Length)
                {
                    strArgs += strKey;
                }

                //
                // Run rebuild update on the packet
                //
                CTitleMgrApp.WriteLineV("Args for RebuildUpdate: " + strArgs);
                hr = CTitleMgrApp.RunCommandLine(strRebuildFile, strArgs, Environment.CurrentDirectory);

                //
                // Delete the temporary .tmp file
                //
                File.Delete(strControlFile + ".tmp");

                if(CPropUtils.HR_SUCCEEDED != hr)
                {
                    throw(new ApplicationException("RebuildUpdate failed!"));
                }

                CPropUtils.VerifyExists(strUpdatePath + ".xbx");
                Ini xbxIni = new Ini(strUpdatePath + ".xbx");

                string strTitleID = CPropUtils.ExtractID(xbxIni.GetSetting("All", "TitleID"), 8);
                string strBaseVersion = CPropUtils.ExtractID(xbxIni.GetSetting("All", "BaseVersion"), 8);
                string strUpdateVersion = CPropUtils.ExtractID(xbxIni.GetSetting("All", "UpdateVersion"), 8);

                if(strTitle.ToLower() != strTitleID.ToLower())
                {
                    throw new ApplicationException("The input title ID(" + strTitle + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                bool isDash = false;
                if (strTitleID.ToUpper() == DASHID)
                    isDash = true;

                //make sure that the versions are decent
                uint iBaseDisc, iBaseBuild,
                    iUpdateDisc, iUpdateBuild;

                if (GetDiscBuild(strBaseVersion, out iBaseDisc, out iBaseBuild) == false)
                    throw new ApplicationException("The base version of the update is corrupted.");
                
                if (GetDiscBuild(strUpdateVersion, out iUpdateDisc, out iUpdateBuild) == false)
                    throw new ApplicationException("The update version of the update is corrupted.");

                if (iUpdateDisc != iBaseDisc && !isDash)
                    throw new ApplicationException("The update version and base version don't match on disc number.");

                if (iUpdateBuild < iBaseBuild)
                    throw new ApplicationException("The update build is lower than the base build.");

                //make sure we don't have a higher version number already in the repository
                ArrayList rUpdates = GetUpdates(strTitle); //get a list of enabled updates

                foreach (string update in rUpdates)
                {
                    uint iBDisc, iUDisc, iBBuild, iUBuild;

                    string baseVer = update.Substring(0, 8);
                    string updateVer = update.Substring(8, 8);

                    if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                        continue;

                    if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                        continue;

                    if (iBDisc != iUDisc)
                        continue; //this was propped with an old version of titlemgr - we should do something here

                    if (iBDisc != iBaseDisc)
                        continue; //for a  different disc

                    if (DisabledUpdate(strTitleID, update))
                        continue; //this title is disabled

                    if (iUBuild > iUpdateBuild)
                        throw new ApplicationException("There is already an update with a higher version in the repository. " + update);

                    if (iUBuild == iUpdateBuild && !CTitleMgrApp.DefaultUpdate && !isDash)
                        CTitleMgrApp.WriteLine("There is already an update with this version in the repository.  Overwriting..");

                    //we should never get here
                    if (iBBuild > iUpdateBuild)
                        throw new ApplicationException("There is already an update with a higher version in the repository. " + update);

                }

                //change versions.ini
                string versionFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\config\\versions.ini";
                Ini vIni = new Ini(versionFile);
                string vers = vIni.GetSetting("VERSION", "ADDITIONAL");
                if (vers.Length == 0)
                    vers = strBaseVersion + ";" + strUpdateVersion;
                else
                {
                    string [] avers = vers.Split(';');
                    bool bBase = false, bUpdate = false;
                    foreach(string ver in avers)
                    {
                        if (ver == strBaseVersion)
                            bBase = true;
                        if (ver == strUpdateVersion)
                            bUpdate = true;
                    }
                    if (!bBase)
                        vers += ";" + strBaseVersion;
                    if (!bUpdate)
                        vers += ";" + strUpdateVersion;
                }
                CTitleMgrApp.WriteLineV("Additional in versions.ini is: " + vers);
                vIni.SetSetting("VERSION", "ADDITIONAL", vers);

                CSourceDepot sd = new CSourceDepot();
                sd.Edit(versionFile);
                vIni.Save(versionFile);
                sd.Submit(versionFile, "titlemgr: updated versions.ini");

                string strUpdateID = strBaseVersion + strUpdateVersion;
                if(bModifyAllFiles)
                {
                    CPropUtils.SDWorkPackage(strUpdatePath, strTitleID, strUpdateID);
                }

                if(bModifyAllFiles || bSiteUpdateControlFile)
                {
                    CPropUtils.SDWorkControl(strControlFile, strTitleID, strUpdateID, BillingState.CURRENT, false, bSiteUpdateControlFile, false);
                }
                
                CPropUtils.SDWorkSQL2(strUpdatePath + ".sql2", strTitleID, strUpdateID);

                string strPackageID = strBaseVersion + strUpdateVersion;

                if (bFull)
                    MakeFull(strTitleID, strPackageID, true);

                //erase that file for next time
                if (CTitleMgrApp.DefaultUpdate)
                    File.Delete(strUpdatePath);

                CTitleMgrApp.WriteLine("SUCCESS: Use /sync or (/transfer,/uodbupdate)to complete the operation!");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = CPropUtils.HR_FAILED;
            }
            finally
            {
                CPropUtils.CleanUpWorkingFolder(strUpdatePath);
            }

            return (hr);
                
        }

        public static int RebuildUpdate(string strTitle, string strUpdatePath, string strSite, bool bFull)
        {
            int hr = CPropUtils.HR_SUCCEEDED;

            try
            {
                if (DASHID.Length == 0)
                {
                    CTitleMgrApp.WriteLine("Please add a DASHID line in servers.ini to specify which title is the dash");
                    return 0;
                }
                //
                //  Does the specified source file exist?
                //
                CPropUtils.VerifyExists(strUpdatePath);
                CPropUtils.VerifySites(strSite);
                
                Ini controlIni = new Ini();

                controlIni.SetSetting("Package", "Site", strSite);
                controlIni.SetSetting("Package", "Type", "AutoUpdate");

                controlIni.Save(strUpdatePath + ".control2");

                hr = RebuildUpdate(strTitle, strUpdatePath, strUpdatePath + ".control2", true, bFull);
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine(e.Message);
                hr = CPropUtils.HR_FAILED;
            }
            
            return (hr);
        }

        public static uint CombineVersion(uint iHighestBuild, uint iDisc)
        {
            if (CTitleMgrApp.IsFootball)
                return ( (iHighestBuild << 16) | iDisc);

            return ( (iHighestBuild << 8) | iDisc);

        }

        public static bool GetDiscBuild(string version, out uint disc, out uint build)
        {
            if (version .Length != 8)
            {
                disc = 0;
                build = 0;
                return false;
            }

            string strDisc; 
            string strBuild;
            
            if (CTitleMgrApp.IsFootball)
            {
                strBuild = version.Substring(0,4);
                strDisc = version.Substring(4,4);
            }
            else
            {
                strDisc = version.Substring(6, 2);
                strBuild = version.Substring(0, 6);
            }

            disc = UInt32.Parse(strDisc, NumberStyles.HexNumber);
            build = UInt32.Parse(strBuild, NumberStyles.HexNumber);

            return true;
        }

        public static ArrayList GetVersions(string strTitleID)
        {
            ArrayList versions = new ArrayList();
            string versionsFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\config\\versions.ini";
            Ini versionIni = new Ini(versionsFile);

            string version = versionIni.GetSetting("VERSION", "Initial");
            versions.Add(version);
    
            string strVersions = versionIni.GetSetting("VERSION", "Additional");

            if (strVersions.Length > 0)
            {
                string [] rVersions = strVersions.Split(';');
                foreach (string strV in rVersions)
                {
                    versions.Add(strV);
                }
            }

            return versions;
        }

        public static void DashSync()
        {
            string strTitleID = DASHID;
            ArrayList rUpdates = GetUpdates(strTitleID);

            //add all base and additional versions
            ArrayList versions = GetVersions(strTitleID);

            try
            {
                foreach (string strVersion in versions)
                {
                    CPropUtils.BeginTransactions();
                    uint version = UInt32.Parse(strVersion, NumberStyles.HexNumber);
                    CUODBUpdate.InsertTitleVersion(strTitleID, version, version, true); 
                    CPropUtils.CommitTransactions();
                }
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                CPropUtils.RollbackTransactions();
            }

            try
            {
                foreach (string update in rUpdates)
                {

                    string strBaseVer = update.Substring(0, 8);
                    string strUpdateVer = update.Substring(8, 8);

                    uint baseVer = UInt32.Parse(strBaseVer, NumberStyles.HexNumber);
                    uint updateVer = UInt32.Parse(strUpdateVer, NumberStyles.HexNumber);

                    //process this update
                    if (CTitleMgrApp.Transfer)
                    {
                        CPropUtils.BeginTransactions();
                        CPropUtils.Transfer(strTitleID, update);
                        CPropUtils.CommitTransactions();
                    }

                    //insert base row
                    CPropUtils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, baseVer, true); 
                    CPropUtils.CommitTransactions();

                    if (IsFullUpdate(strTitleID, update))
                    {
                        CPropUtils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, updateVer, true); 
                        CPropUtils.CommitTransactions();
                    }
                    else
                    {
                        CPropUtils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, updateVer, false); 
                        CPropUtils.CommitTransactions();
                    }

                    CPropUtils.BeginTransactions();
                    CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, update);
                    CPropUtils.CommitTransactions();
                }
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                CPropUtils.RollbackTransactions();
            }

        }

        public static void Sync(string strTitleID)
        {
            //do separate sync for dash
            if (strTitleID.ToUpper() == DASHID.ToUpper())
            {
                DashSync();
                return;
            }


            //get a list of package IDs for each disc
            ArrayList rUpdates = GetUpdates(strTitleID); //get a list of enabled updates

            //get a list of all the discs we need to prop updates for
            ArrayList rDiscs = new ArrayList();
            foreach (string update in rUpdates)
            {
                uint iBDisc, iBBuild,
                        iUDisc, iUBuild;
                string baseVer = update.Substring(0, 8);
                string updateVer = update.Substring(8, 8);

                if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    continue;

                if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    continue;

                if (iBDisc != iUDisc)
                    continue; //this was propped with an old version of titlemgr - we should do something here

                if (!rDiscs.Contains(iBDisc))
                    rDiscs.Add(iBDisc);
            }

            //insert all baseversions
            string versionsFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\config\\versions.ini";
            Ini versionIni = new Ini(versionsFile);

            string version = versionIni.GetSetting("VERSION", "Initial");
            uint iVBuild, iVDisc;
            GetDiscBuild(version, out iVDisc, out iVBuild);


            if (!rDiscs.Contains(iVDisc))
                rDiscs.Add(iVDisc);
                
            string strVersions = versionIni.GetSetting("VERSION", "Additional");

            if (strVersions.Length > 0)
            {
                string [] rVersions = strVersions.Split(';');
                foreach (string strV in rVersions)
                {
                    GetDiscBuild(strV, out iVDisc, out iVBuild);
                    if (!rDiscs.Contains(iVDisc))
                        rDiscs.Add(iVDisc);
                }
            }

            foreach (uint iDisc in rDiscs)
            {
            
                ArrayList baseVers = new ArrayList();
                uint iHighestBuild = 0;
                uint iHighestFullBuild = 0;

                string strHighestVer = null;
                string strHighestFullVer = null;

                bool bHaveFull = false;

                foreach (string update in rUpdates)
                {
                    uint iBDisc, iUDisc, iBBuild, iUBuild;

                    string baseVer = update.Substring(0, 8);
                    string updateVer = update.Substring(8, 8);

                    if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    {
                        CTitleMgrApp.WriteLine("The base version of " + update + " is screwy.");
                        continue;
                    }

                    if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    {
                        CTitleMgrApp.WriteLine("The update version of " + update + " is screwy.");
                        continue;
                    }

                    if (iBDisc != iUDisc)
                    {
                        CTitleMgrApp.WriteLine("The package " + update + " was propped with an old version of titlemgr and will never be synced again.");
                        continue;
                    }

                    if (iBDisc != iDisc)
                        continue; //for a  different disc

                    //we should never get here
                    if (iBBuild > iUBuild)
                    {
                        CTitleMgrApp.WriteLine("Update " + update + " has a higher update than build version. ");
                        continue;
                    }

                    //remember this package so we can update uodb correctly
                    if (!baseVers.Contains(baseVer))
                        baseVers.Add(baseVer);
                
                    //we also need to make sure that all update versions can be updated to the new high
                    if (!baseVers.Contains(updateVer))
                        baseVers.Add(updateVer);
                
                    //if we have a new high, then set it
                    if (iUBuild > iHighestBuild)
                    {
                        iHighestBuild = iUBuild;
                        strHighestVer = update;
                    }
                    
                    if (IsFullUpdate(strTitleID, update))
                        bHaveFull = true;
                
                    if (iUBuild > iHighestFullBuild && IsFullUpdate(strTitleID, update))
                    {
                        iHighestFullBuild = iUBuild;
                        strHighestFullVer = update;
                    }
                
                }//each update
            
                //insert all baseversions
                
                version = versionIni.GetSetting("VERSION", "Initial");
                GetDiscBuild(version, out iVDisc, out iVBuild);

                /*
                bool bFullPack = true, bPack = true;

                if (null == strHighestVer)
                    bPack = false;
                if (null == strHighestFullVer)
                    bFullPack = false;
                */
                /*
                
                if (null == strHighestVer && iVDisc == iDisc)
                {
                    strHighestVer = version;
                    iHighestBuild = iVBuild;
                }

                if (null == strHighestFullVer && iVDisc == iDisc)
                {
                    strHighestFullVer = version;
                    iHighestFullBuild = iVBuild;
                }

                */

                if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(version))
                    baseVers.Add(version);
                
                strVersions = versionIni.GetSetting("VERSION", "Additional");

                if (strVersions.Length > 0)
                {
                    string [] rVersions = strVersions.Split(';');
                    foreach (string strV in rVersions)
                    {
                        GetDiscBuild(strV, out iVDisc, out iVBuild);
                        if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(strV))
                            baseVers.Add(strV);

                        /*
                        if (null == strHighestVer && iVDisc == iDisc)
                        {
                            strHighestVer = strV;
                            iHighestBuild = iVBuild;
                        }

                        if (null == strHighestFullVer && iVDisc == iDisc)
                        {
                            strHighestFullVer = strV;
                            iHighestFullBuild = iVBuild;
                        }
                        */
                    }
                }

                if (null == strHighestVer)
                {
                    //CTitleMgrApp.WriteLine("FAIL: Can't find a highest ver for disc " + iDisc.ToString());
                    continue;
                }

                uint iHighestVersion = CombineVersion(iHighestBuild, iDisc);
                uint iHighestFullVersion = CombineVersion(iHighestFullBuild, iDisc);

                CTitleMgrApp.WriteLineV("Highest build for disc " + iDisc.ToString() + " is " + strHighestVer);
                
                if (CTitleMgrApp.Transfer)
                    CPropUtils.Transfer(strTitleID, strHighestVer);

                if (null != strHighestFullVer && CTitleMgrApp.Transfer)
                    CPropUtils.Transfer(strTitleID, strHighestFullVer);

            
                //CUODBUpdate.InsertTitleVersion(strTitleID, iHighestBuild, iHighestBuild, true);

                //prop the highest update
                //UODBWork(strTitleID, strHighestVer, UODBAction.UPDATE_TRANSFER);
                //we don't want to reprop the highest version - it is already in there
                //baseVers.Remove(strHighestVer.Substring(0, 8));

                //now we have to update t_title_versions for each other update (beta only)
                //we also have to point to their offer locations/packages


                try
                {
                    foreach (string strBaseVer in baseVers)
                    {
                        CTitleMgrApp.WriteLineV("Inserting " + strBaseVer + " with Highest's stats");

                        uint baseVer = UInt32.Parse(strBaseVer, NumberStyles.HexNumber);

                        //establish base row if not there
                        CPropUtils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, baseVer, true); 
                        CPropUtils.CommitTransactions();

                        if (baseVer <= iHighestFullVersion && bHaveFull)
                        {
                            //this is a full update, so set the full field
                            CPropUtils.BeginTransactions();
                            CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, iHighestFullVersion, true);
                            CPropUtils.CommitTransactions();

                            CPropUtils.BeginTransactions();
                            CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, strHighestFullVer);
                            CPropUtils.CommitTransactions();
                        }
                        
                        //update the beta field to the row
                        CPropUtils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, iHighestVersion, false);
                        CPropUtils.CommitTransactions();

                        CPropUtils.BeginTransactions();
                        CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, strHighestVer);
                        CPropUtils.CommitTransactions();

                    } //each update for this disc

                }                
                catch (Exception e)
                {
                    CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    CPropUtils.RollbackTransactions();
                }

                CTitleMgrApp.WriteLineV("Disc " + iDisc.ToString() +" Sync: Success");

            } //each disc

            CTitleMgrApp.WriteLine("AutoUpdate Sync: Success");
        }

        static public void MakeFootball(string titleID)
        {
            string strFile = Environment.CurrentDirectory + "\\" + titleID + "\\config\\versions.ini";
            Ini vIni = new Ini(strFile);
            vIni.SetSetting("VERSION", "FOOTBALL", "TRUE");

            CSourceDepot sd = new CSourceDepot();
            sd.Edit(strFile);

            vIni.Save(strFile);
            
            sd.Submit(strFile, "Set football version info");

            CTitleMgrApp.WriteLine("Successfully set July version info (football) on title " + titleID);
        }

        static public void AddBaseVer(string titleid, string strVersion)
        {   

            try
            {
                CPropUtils.VerifyVersion(strVersion);

                string versionFile = Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini";

                if (!File.Exists(versionFile))
                {
                    CTitleMgrApp.WriteLine("FAIL: " + versionFile + " does not exist.");
                    return;
                }

                Ini versionIni = new Ini(versionFile);
                CSourceDepot sd = new CSourceDepot();

                sd.Edit(versionFile);

                string versions = versionIni.GetSetting("Version", "Additional");

                string [] current_vers = versions.Split(';');
                foreach(string ver in current_vers)
                {
                    if (ver == strVersion)
                    {
                        CTitleMgrApp.WriteLine("This version(" + strVersion + ") has already been added to " + titleid);
                        return;
                    }
                }

                if (versions.Length > 0)
                    versions += ";";

                versions += strVersion;
                versionIni.SetSetting("Version", "Additional", versions);
                versionIni.Save(versionFile);

                sd.Submit(versionFile, "added base version");

                //insert that version into uodb
                uint iVersion = UInt32.Parse(strVersion, NumberStyles.HexNumber);

                try
                {
                    CPropUtils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(titleid, iVersion, iVersion, true);
                    CPropUtils.CommitTransactions();
                }
                catch (Exception e)
                {
                    CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    CPropUtils.RollbackTransactions();
                }

                CTitleMgrApp.WriteLine("Added version " + strVersion + " to title " + titleid);

            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }


        static public void ChangeBaseVer(string titleid, string strVersion)
        {   

            try
            {
                CPropUtils.VerifyVersion(strVersion);

                string versionFile = Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini";

                if (!File.Exists(versionFile))
                {
                    CTitleMgrApp.WriteLine("FAIL: " + versionFile + " does not exist.");
                    return;
                }

                Ini versionIni = new Ini(versionFile);
                CSourceDepot sd = new CSourceDepot();

                sd.Edit(versionFile);

                versionIni.SetSetting("Version", "Initial", strVersion);
                versionIni.Save(versionFile);

                sd.Submit(versionFile, "updated base version");

                //insert that version into uodb
                uint iVersion = UInt32.Parse(strVersion, NumberStyles.HexNumber);
                try
                {
                    CPropUtils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(titleid, iVersion, iVersion, true);
                    CPropUtils.CommitTransactions();
                }
                catch (Exception e)
                {
                    CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    CPropUtils.RollbackTransactions();
                }

                CTitleMgrApp.WriteLine("Updated base version to " + strVersion);
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }

        static public bool IsFullUpdate(string strTitleID, string strPackageID)
        {
            string ctlFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strPackageID + ".control";

            Ini ctlIni = new Ini(ctlFile);

            if (ctlIni.GetSetting("PACKAGE", "FULL").ToUpper() == "TRUE")
                return true;
            else
                return false;
        }

        static public void MakeFull(string titleid, string packageid, bool full)
        {
            //edit the sql2 file

            //there is a part
            /*
             * 
                exec p_svc_insert_title_versions
                    0x4D530027,
                    0x00000000,
                    0x00000100,
                    1
             */

            //we need to change the  4th line under it to 0

            string strSQLFile = Environment.CurrentDirectory + "\\" + titleid + "\\" + packageid + ".sql2";

            CTitleMgrApp.WriteLineV("Looking for sql2");
            if (!File.Exists(strSQLFile))
            {
                CTitleMgrApp.WriteLine("FAIL: Cannot MakeFull because sql2 file does not exist");
                CTitleMgrApp.WriteLine("Can't find: " + strSQLFile);
                return;
            }

            CTitleMgrApp.WriteLineV("Opening sql2 file");
            StreamReader reader = new StreamReader(strSQLFile);

            string line;
            ArrayList output = new ArrayList();
            int count = 0;
            while ((line = reader.ReadLine()) != null)
            {
                if (count > 0)
                    count++;

                if (count == 5)
                {
                    if (full == true)
                    {
                        if (line.Trim() == "0")
                        {
                            /*
                            CTitleMgrApp.WriteLine("Package " + packageid + " already full");
                            return;
                            */
                        }
                        else
                            line = line.Replace("1", "0");
                    }
                    else
                    {
                        if (line.Trim() == "1")
                        {
                            /*
                            CTitleMgrApp.WriteLine("Package " + packageid + " already selective");
                            return;
                            */
                        }
                        else
                            line = line.Replace("0", "1");
                    }
                }

                output.Add(line);

                if (line.IndexOf("p_svc_insert_title_versions") >= 0)
                    count  = 1;
            }

            reader.Close();

            CTitleMgrApp.WriteLineV("Parsed sql2 file");

            //now, check out, edit, check in
            CSourceDepot sd = new CSourceDepot();
            sd.Edit(strSQLFile);

            StreamWriter writer = new StreamWriter(strSQLFile);

            for (int i = 0; i < output.Count; i++)
                writer.WriteLine(output[i]);

            writer.Close();

            sd.Submit(strSQLFile, "Made Full Update");


            string ctlFile = Environment.CurrentDirectory + "\\" + titleid + "\\" + packageid + ".control";
            
            sd.Edit(ctlFile);

            Ini ctlIni = new Ini(ctlFile);
            if (full == true)
                ctlIni.SetSetting("PACKAGE", "FULL", "TRUE");
            else
                ctlIni.SetSetting("PACKAGE", "FULL", "FALSE");

            ctlIni.Save(ctlFile);

            sd.Submit(ctlFile, "Updated full status of " + packageid);


            CTitleMgrApp.WriteLine("MakeFull: Success - use /sync or /uodbupdate to complete this operation");
        }

        public static ArrayList GetUpdates(string strTitle)
        {
            ArrayList rUpdates = new ArrayList();
            string [] files = Directory.GetFiles(Environment.CurrentDirectory + "\\" + strTitle, "*.control");

            foreach (string file in files)
            {
                string strID = Path.GetFileNameWithoutExtension(file);

                if (CPropUtils.IsIDContent(strTitle, strID) == false)
                    rUpdates.Add(strID);
            }

            return rUpdates;
        }

        public static void BuildDefaultUpdate(string strTitleID)
        {
            CTitleMgrApp.WriteLine("Building default autoupdate for " + strTitleID);
            string updateDir = Environment.CurrentDirectory + "\\DefaultUpdate";

            //clear out the old update stuff
            CTitleMgrApp.WriteLineV("Cleaning up old dir");
            CTitleMgrApp.RunCommandLine("delnode.exe", "/q " + strTitleID, updateDir);

            //now create the update dir and put the necessary files there
            CTitleMgrApp.WriteLineV("Copying files from \\new");
            Directory.CreateDirectory(updateDir + "\\" + strTitleID);
            string [] patchFiles = Directory.GetFiles(updateDir + "\\new");
            foreach (string file in patchFiles)
            {
                CTitleMgrApp.WriteLineV("Copying " + file + " to " + Path.GetFileName(file));
                File.Copy(file, updateDir + "\\" + strTitleID + "\\" + Path.GetFileName(file));
            }

            //make and old dir if it doesn't exist
            if (!Directory.Exists(updateDir + "\\old"))
                Directory.CreateDirectory(updateDir + "\\old");

            //now cert the xbe that we just copied
            CTitleMgrApp.WriteLineV("Cert..");
            File.SetAttributes(updateDir + "\\" + strTitleID + "\\default.xbe", FileAttributes.Normal);
            string strArgs = "/in:" + strTitleID + "\\default.xbe ";
            strArgs += "/testid:0x" + strTitleID + " ";
            strArgs += "/testversion:0x00000299";

            CTitleMgrApp.RunCommandLine("xbecert.exe", strArgs, updateDir);

            //now run xpatch to create the diff
            CTitleMgrApp.WriteLineV("Xpatch");
            strArgs = "-c old " + strTitleID + " ";
            strArgs += strTitleID + "\\diff";
            CTitleMgrApp.RunCommandLine("xpatch.exe", strArgs, updateDir);

            //now build the update
            CSourceDepot sd = new CSourceDepot();
            sd.Edit(updateDir + "\\update.xbx");
            CTitleMgrApp.WriteLineV("BuildUpdate");
            strArgs = "update.pkg " + "update.xbx " + strTitleID + "\\diff " + strTitleID;
            CTitleMgrApp.RunCommandLine("BuildUpdate.exe", strArgs, updateDir);
            sd.Revert(updateDir + "\\update.xbx");


            //we now have an update.pkg we can use - delete the temp dir
            CTitleMgrApp.WriteLineV("Cleaning up dir");
            CTitleMgrApp.RunCommandLine("delnode.exe", "/q " + strTitleID, updateDir);

            CTitleMgrApp.WriteLine("");
        }

        public static bool DisabledUpdate(string strTitleID,string update)
        {
            string strPath = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + update + ".control";

            if (!File.Exists(strPath))
            {
                throw new ApplicationException("Cannot find the update " + strPath);
            }

            Ini ctlIni = new Ini(strPath);

            if ("TRUE" == ctlIni.GetSetting("PACKAGE", "DISABLED"))
                return true;

            return false;
        }

        public static void EnableUpdate(string strTitleID, string strID)
        {
            //to remove an update from the database all we have to do is set it to disabled
            string strPath = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strID;

            if (!File.Exists(strPath + ".pkg"))
            {
                throw new ApplicationException("Cannot find the update " + strID);
            }

            if (CPropUtils.IsIDContent(strTitleID, strID))
            {
                throw new ApplicationException("You cannot enable content this way.  This is for enabling autoupdates.");
            }

            CSourceDepot sd = new CSourceDepot();
            
            sd.Edit(strPath + ".control");

            Ini ctlIni = new Ini(strPath + ".control");

            ctlIni.SetSetting("PACKAGE", "DISABLED", "FALSE");
            ctlIni.Save(strPath + ".control");

            sd.Submit(strPath + ".control", "Enabling " + strPath);
              
            CTitleMgrApp.WriteLine("Successfully enabled " + strID);
        }

        public static void RemoveUpdate(string strTitleID, string strID)
        {

            CTitleMgrApp.WriteLine("FAIL: Removing an update is disabled.  Prop a higher version of the autoupdate.");
            return;

            /*
            //to remove an update from the database all we have to do is set it to disabled
            string strPath = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strID;

            if (!File.Exists(strPath + ".pkg"))
            {
                throw new ApplicationException("Cannot find the update " + strID);
            }

            if (CPropUtils.IsIDContent(strTitleID, strID))
            {
                throw new ApplicationException("You cannot remove content this way.  This is for removing autoupdates.");
            }

            CSourceDepot sd = new CSourceDepot();
            
            sd.Edit(strPath + ".control");

            Ini ctlIni = new Ini(strPath + ".control");

            ctlIni.SetSetting("PACKAGE", "DISABLED", "TRUE");
            ctlIni.Save(strPath + ".control");

            sd.Submit(strPath + ".control", "Disabling " + strPath);
              
            CTitleMgrApp.WriteLine("Successfully disabled " + strID);
            */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CNameTranslations.cs ===
using System;
using System.IO;
using System.Xml;
using System.Globalization;

namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// Summary description for CNameTranslations.
	/// </summary>
	public class CNameTranslations
	{
        static Ini translationInfo;
        static string [] Langs; //caps b/c info should come from a file

        public const int c_iMaxTitleNameLength = 40;

        public static void Exec(string titleid, string iniPath)
        {
            CSourceDepot sd = null;

            try
            {
                string titlePath = Environment.CurrentDirectory + "\\" + titleid;

                CPropUtils.VerifyExistsDir(titlePath);
                
                Langs = new string[10];
                Langs[1] = "EN"; //english
                Langs[5] = "ES"; //spanish
                Langs[3] = "DE"; //german
                Langs[6] = "IT"; //italian
                Langs[4] = "FR"; //french
                Langs[2] = "JA"; //japanese
                Langs[7] = "KO"; //korean
                Langs[8] = "TW"; //chinese
                Langs[9] = "BR"; //portuguese

                CPropUtils.VerifyExists(iniPath);
                
                translationInfo = new Ini(iniPath);

                string defaultName = translationInfo.GetSetting("default", "TitleName");
                if (defaultName.Length > c_iMaxTitleNameLength)
                {
                    throw new ApplicationException(
                        "default title description may not be longer than "
                        +c_iMaxTitleNameLength
                        +" characters");
                }

                //go through the files in the message directory, place the title name in there if it isn't already
                string [] msgFiles;

                msgFiles = Directory.GetFiles(titlePath + "\\message", "*.xml");

                if(msgFiles.Length == 0)
                {
                    throw new ApplicationException("No XML files found in \"" + titlePath + "\".");
                }
            
                sd = new CSourceDepot();

                //change esrb/cluster/default_locale in stats.ini
                string statsIniPath = Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.ini";
                if(!File.Exists(statsIniPath))
                {
                    throw new ApplicationException("File not found:  \"" + statsIniPath + "\".");
                }

                Ini statsIni = new Ini(statsIniPath);

                string esrb = "", cluster = "", default_locale = "";

                esrb = translationInfo.GetSetting("TITLE", "ESRB");
                cluster = translationInfo.GetSetting("TITLE", "CLUSTER");
                default_locale = translationInfo.GetSetting("TITLE", "DEFAULTLOCALE");

                if (esrb.Length == 0)
					esrb = "0";
				if (cluster.Length == 0)
					cluster = "1";
				if (default_locale.Length == 0)
				{
					string stats_ini_default_locale = statsIni.GetSetting("TITLE", "DEFAULTLOCALE");
					if (stats_ini_default_locale.Length == 0)
					{
						default_locale = "en-US";
					}
					else
					{
						default_locale = stats_ini_default_locale;
					}
				}

                try
                {
                    Int32.Parse(esrb);
                }
                catch (Exception)
                {
                    throw new Exception("ESRB has to be a number.");
                }
                
                try
                {
                    Int32.Parse(cluster);
                }
                catch (Exception)
                {
                    throw new Exception("CLUSTER has to be a number.");
                }

                if (!CSyncLeaderboards.InLocaleList(default_locale))
                    throw new Exception("The DEFAULTLOCALE you specified is invalid.");

                statsIni.SetSetting("TITLE", "ESRB", esrb);
                statsIni.SetSetting("TITLE", "CLUSTER", cluster);
                statsIni.SetSetting("TITLE", "DefaultLocale", default_locale);

                sd.Edit(statsIniPath);
                statsIni.Save(statsIniPath);
                sd.Submit(statsIniPath, "updated esrb/cluster/default_locale in stats.ini");



                foreach(string file in msgFiles)
                {
                    sd.Sync(file);
                    sd.Edit(file);
                    PlaceNameInFile(file, defaultName, titleid);
                    sd.Submit(file, "Added translation to " + file);
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished();
                    sd = null;
                }
            }

        } //Exec

        private static void PlaceNameInFile(string file, string defaultName, string titleid)
        {
            XmlDocument doc = new XmlDocument();
                
            try
            {
                doc.Load(file);
            }
            catch(Exception)
            {
                CTitleMgrApp.WriteLine("Failed to load \"" + file + "\", skipping.");
                return;
            }

            XmlNodeList msgStringsNodes = doc.SelectNodes("msgstrings");

            //we only want to change the first node
            XmlNode msgStringsNode = msgStringsNodes.Item(0);

            if(msgStringsNode.NodeType != XmlNodeType.Element)
                return;

            XmlElement msgStringsElem = (XmlElement)msgStringsNode;

            //make sure we are looking at something type 1 (the title is type 1)
            int nType = Int32.Parse(msgStringsElem.GetAttribute("type"));
            if(nType != 1)
                return;

            string langStr = msgStringsElem.GetAttribute("language");
            if(langStr == null)
            {
                CTitleMgrApp.WriteLine("No language attribute found in \"" + file + "\", skipping.");
                return;
            }

            int nLang = Int32.Parse(langStr);
            string title;
    
            //see if we have a language from the translationInfo.ini
            if (Langs.Length <= nLang)
            {
                //we don't support this language - use default
                title = defaultName;
            }
            else
            {
                //we have this language's title in the .ini file
                title = translationInfo.GetSetting(Langs[nLang], "TitleName");

                if (title == null || title.Length == 0)
                    title = defaultName;

                if (title.Length > c_iMaxTitleNameLength)
                {
                    CTitleMgrApp.WriteLine(
                        "FAIL: title description for "
                        +Langs[nLang]
                        +" may not be longer than "
                        +c_iMaxTitleNameLength
                        +" characters");
                    return;
                }
            }

            if (title == null || title.Length == 0)
            {
                CTitleMgrApp.WriteLine("FAIL: No name specified for " + Langs[nLang] + ". Please specify a default language.");
                return;
            }

            string longTitleIDString = Int64.Parse(titleid, NumberStyles.HexNumber).ToString(); 
            
            XmlNode msgMappingNode = msgStringsElem.SelectSingleNode("child::msgmapping[attribute::id=\"" + longTitleIDString + "\"]");
            if(msgMappingNode == null)
            {
                //add language section to file (shouldn't be necessary)
                XmlElement newElem = doc.CreateElement("msgmapping");

                newElem.SetAttribute("id", longTitleIDString);
                newElem.AppendChild(doc.CreateTextNode(title));

                msgStringsElem.AppendChild(newElem);

                CTitleMgrApp.WriteLine("Added title description to \"" + file + "\".");
            }
            else
            {
                if(msgMappingNode.NodeType != XmlNodeType.Element)
                    return;

                XmlElement msgMappingElem = (XmlElement)msgMappingNode;

                msgMappingElem.InnerText = title;

                CTitleMgrApp.WriteLine("Updated title description in \"" + file + "\".");
            }

            //now save file
            try
            {
                doc.Save(file);
                CTitleMgrApp.WriteLine("\"" + file + "\" saved.");
            }
            catch(Exception)
            {
                CTitleMgrApp.WriteLine("Failed to save changes to \"" + file + "\".");
            }
        } //PlaceNameInFile

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CPropContent.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.IO;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

using Excel;
using System.Reflection;


namespace xonline.tools.titlemgr
{
    /// <summary>
    /// Execute the content propping comands
    /// </summary>
    public class CPropContent
    {
        public enum OfferTypes
        {
            CONTENT,
            SUBSCRIPTION,
            BASE_SUBSCRIPTION,
            MAX_TYPES
        };

        public static int RebuildContent(string strTitle, string strContentPath,
            string strControlFile, bool bModifyAllFiles, bool bDefaultTemplate,
            string strStartDate, string strEndDate)
        {
            string strRebuildFile  = "rebuildcontent.exe";
            int hr = CPropUtils.HR_SUCCEEDED;

            try
            {
                //
                //  Do the working files exist?
                //
                CPropUtils.VerifyExists(strContentPath);
                CPropUtils.VerifyExists(strControlFile);

                Ini controlIni = new Ini(strControlFile);
                string strAlternateOfferID = controlIni.GetSetting("Content", "OfferID");
                string strKey = controlIni.GetSetting("Content", "Key");
                string strSite = controlIni.GetSetting("Package", "Site");
                string strType = controlIni.GetSetting("Package", "Type");
                bool   bSiteUpgrade = false;

                if (strSite.ToUpper() == "ALL")
                    throw new ApplicationException("You have to specifically order your sites for content.");

                string strXRLRoot = CPropUtils.GetIPs("XRLRoot", strSite);

                if (strXRLRoot.Length == 0)
                    throw new ApplicationException("No XRLRoots in site " + strSite);

                //
                // Prepare the .control file expected by RebuildContent
                //
                Ini tmpIni = new Ini();
                tmpIni.SetSetting("Content", "XRLRoot", strXRLRoot);
                tmpIni.Save(strControlFile + ".tmp");

                string strArgs = "\"" + strContentPath + "\" \"" + strControlFile + ".tmp\"" + " ";

                //
                // Retail signed
                //
                strArgs += "-R ";

                if(CPropUtils.uiIDLength== strAlternateOfferID.Length)
                {
                    strArgs += "-O:" + strAlternateOfferID + " ";
                }
                if(CPropUtils.uiKeyLength == strKey.Length)
                {
                    strArgs += strKey;
                }

                //
                // Run rebuild content on the packet
                //
                hr = CTitleMgrApp.RunCommandLine(strRebuildFile, strArgs, Environment.CurrentDirectory);

                //
                // Delete the temporary .tmp file
                //
                File.Delete(strControlFile + ".tmp");

                if(CPropUtils.HR_SUCCEEDED != hr)
                {
                    throw(new ApplicationException("RebuildContent failed!"));
                }

                string strMainSite = strSite;

                if (strMainSite.IndexOf(';') > 0)
                    strMainSite = strMainSite.Substring(0, strMainSite.IndexOf(';'));

                CPropUtils.VerifyRegions(strContentPath + ".sql2", strMainSite);

                CPropUtils.VerifyExists(strContentPath + ".xbx");
                Ini xbxIni = new Ini(strContentPath + ".xbx");

                string strTitleID = CPropUtils.ExtractID(xbxIni.GetSetting("All", "TitleID"), 8);
                string strOfferID = CPropUtils.ExtractID(xbxIni.GetSetting("All", "OfferingID"), 16);
                string strPremium = xbxIni.GetSetting("All", "Premium").ToUpper();

                if(strTitle.ToLower() != strTitleID.ToLower())
                {
                    throw new ApplicationException("The input title ID(" + strTitle + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                if(!CPropUtils.IsIDContent(strTitleID, strOfferID))
                {
                    throw new ApplicationException("The offer ID(" + strOfferID + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                if(bModifyAllFiles)
                {
                    CPropUtils.SDWorkPackage(strContentPath, strTitleID, strOfferID);
                }

                if(bModifyAllFiles || bSiteUpgrade)
                {
                    string strBillingState = controlIni.GetSetting("Billing", "SPS").ToUpper();

                    BillingState state = BillingState.CURRENT;
                    if("" == strBillingState)
                    {
                        string strBillingFile  = Environment.CurrentDirectory + "\\billing.ini";
                        Ini billingIni = new Ini(strBillingFile);
                        string strTemplateRequired = billingIni.GetSetting("Template", "Required").ToUpper();

                        if("YES" == strTemplateRequired)
                        {
                            state = BillingState.SPS_NOT_READY;
                        }
                        else
                        {
                            state = BillingState.SPS_READY;
                        }
                    }

                    bool bPremium = (strPremium == "YES");

                    if (!bPremium)
                        state = BillingState.SPS_READY;

                    CPropUtils.SDWorkControl(strControlFile, strTitleID, strOfferID, state, bPremium, bSiteUpgrade, true);
                }

                //if start date < now, have start date = now
                UpdateStartDate(strContentPath + ".sql2", strStartDate, strEndDate);
                CPropUtils.SDWorkSQL2(strContentPath + ".sql2", strTitleID, strOfferID);

                if (bDefaultTemplate)
                    ProcessDefaultTemplate(strTitleID, strOfferID);

                CTitleMgrApp.WriteLine("RebuildContent: " + strOfferID + ": Success");
                CTitleMgrApp.WriteLine("RebuildContent: Use /sync or (/transfer,/uodbupdate) to complete this operation");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = CPropUtils.HR_FAILED;
            }
            finally
            {
                CPropUtils.CleanUpWorkingFolder(strContentPath);
            }

            return (hr);

        }

        public static void ProcessDefaultTemplate(string strTitleID, string strOfferID)
        {
            string controlFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strOfferID + ".control";
            string premiumTemplateFile = Environment.CurrentDirectory + "\\DefaultPackages\\PremiumTemplate.xls";
            string freeTemplateFile = Environment.CurrentDirectory + "\\DefaultPackages\\FreeTemplate.xls";

            Ini controlIni = new Ini(controlFile);
            string premium = controlIni.GetSetting("BILLING", "PREMIUM");
            if (premium == "YES")
            {
                CPropContent.SubmitTemplate(strTitleID, strOfferID, premiumTemplateFile, true);
            }
            else
            {
                CPropContent.SubmitTemplate(strTitleID, strOfferID, freeTemplateFile, true);
            }

            CPropContent.InjectBoids(strTitleID, strOfferID);
        }

        public static void UpdateStartDate(string sqlFile, string strStartDate, string strEndDate)
        {
            if (!File.Exists(sqlFile))
                throw new Exception("Can't find file: " + sqlFile);

            StreamReader sr = new StreamReader(sqlFile);

            CTitleMgrApp.WriteLineV("Setting dates: " + strStartDate + " -> " + strEndDate);

            string line;
            ArrayList lines = new ArrayList();
            int done = 0;
            while ((line = sr.ReadLine()) != null)
            {
                //first date is start date
                string []parts = line.Split('/');
                if (parts.Length == 3 && done == 0)
                {
                    //it's a date
                    line.Replace("'", "");
                    line.Replace(",", "");
                    DateTime dt = Convert.ToDateTime(line);
                    if (strStartDate != null)
                        dt = Convert.ToDateTime(strStartDate);

                    if (DateTime.Compare(dt, DateTime.Now) < 0)
                        dt = DateTime.Now;

                    line = "    '" + dt.ToString("MM/dd/yyyy") + "',";

                    done = 1;
                }
                else if (parts.Length == 3 && done == 1)
                { //second date is end date
                    if (strEndDate != null)
                    {
                        DateTime dt = Convert.ToDateTime(strEndDate);
                        line = "    '" + dt.ToString("MM/dd/yyyy") + "',";
                    }
                    done = 2;
                }
                lines.Add(line);
            }
            sr.Close();

            //write the lines out again
            StreamWriter wr = new StreamWriter(sqlFile);

            for (int i = 0; i < lines.Count; i++)
                wr.WriteLine((string)(lines[i]));
            wr.Close();
        }

        public static int RebuildContent(string strTitle, string strContentPath, string strSite, string strOfferID,
            string strStartDate, string strEndDate, bool bDefaultTemplate)
        {
            int hr = CPropUtils.HR_SUCCEEDED;

            try
            {
                //
                //  Does the specified source file exist?
                //
                CPropUtils.VerifyExists(strContentPath);
                CPropUtils.VerifySites(strSite);

                Ini controlIni = new Ini();

                controlIni.SetSetting("Package", "Site", strSite);

                if(null != strOfferID)
                {
                    CPropUtils.VerifyID(strOfferID);
                    controlIni.SetSetting("Content", "OfferID", strOfferID);
                }

                if(null != strStartDate)
                {
                    CPropUtils.VerifyDate(strStartDate);
                    controlIni.SetSetting("Content", "StartDate", strStartDate);
                }

                if(null != strEndDate)
                {
                    CPropUtils.VerifyDate(strEndDate);
                    controlIni.SetSetting("Content", "EndDate", strEndDate);
                }

                controlIni.Save(strContentPath + ".control2");

                hr = RebuildContent(strTitle, strContentPath, strContentPath + ".control2", true, bDefaultTemplate, strStartDate, strEndDate);
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = CPropUtils.HR_FAILED;
            }

            return (hr);
        }

        private static void DashUODBUpdate(string strOfferID)
        {
            int hr = CPropUtils.HR_SUCCEEDED;
            Ini billingIni = new Ini(Environment.CurrentDirectory + "\\Billing.ini");
            long lParam = Convert.ToInt64(strOfferID, 16);
            bool offerExists = true;

            string strSites = billingIni.GetSetting("BaseSubscription", "Sites");

            if("" != strSites)
            {
                string [] strSiteArray = strSites.Split(';');

                foreach(string strSite in strSiteArray)
                {
                    using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                    {
                        c.Open();

                        for (int i=0; i < c.SqlPartitions.Count; i++)
                        {
                            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                            ws.PhysicalPartition = i;
                            ws.StoredProc = "dbo.p_svc_insert_offer_services";
                            ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);

                            ws.AddParameter("@bi_offer_id", lParam);
                            ws.AddParameter("@i_site_id", strSite);
                            ws.ExecuteNonQuery();

                            hr = ws.GetIntParameter("@RETVAL");
                            ws.Close();

                            if(CPropUtils.HR_SUCCEEDED != hr)
                            {
                                throw new ApplicationException("UODB: Nonexistent offer ID:" + strOfferID );
                            }
                        }
                    }
                }
            }

            string strVouchers = billingIni.GetSetting("BaseSubscription", "Vouchers");

            if("" != strVouchers)
            {
                string [] strVoucherArray = strVouchers.Split(';');
                
                //Check the existence of Offers in UODB
                offerExists = VerifyOfferExistence(lParam);

                if (offerExists)
                {
                    foreach (string strVoucher in strVoucherArray)
                    {
                        using (WstConnection c = new WstConnection(ConfigUtil.TokendbWebstoreApp))
                        {
                            c.Open();
                            for (int i = 0; i < c.SqlPartitions.Count; i++)
                            {

                                WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                                ws.PhysicalPartition = i;

                                ws.StoredProc = "dbo.p_svc_add_voucher";
                                CUODBContent.AddBinaryParam(ws, "@bin_voucher_hash", strVoucher); // hash value of the voucher
                                ws.AddParameter("@bi_offer_id", lParam);//offer id
                                ws.AddParameter("@i_use_count", -1);// i_use_count
                                ws.AddParameter("@i_voucher_status_id", 0); //i_voucher_status_id)

                                ws.ExecuteNonQuery();
                                ws.Close();
                            }
                        }
                    }
                }
            }
        }
        private static bool VerifyOfferExistence(long offerId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_verify_offer_exists";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                uint hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
        }
        public static bool UODBWork(string strTitleID, string strOfferID, UODBAction action)
        {
            bool bRet = true;
            CSourceDepot sd = null;

            try
            {
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToLower();

                if(UODBAction.DELETE == action)
                {
                    //
                    // Run clear offer
                    //
                    //CPropContent.ChangeDates(strTitleID, strOfferID, DateTime.Now.ToString(), DateTime.Now.ToString(), true);

                    using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                    {
                        c.Open();

                        for (int i=0; i < c.SqlPartitions.Count; i++)
                        {
                            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                            ws.PhysicalPartition = i;
                            ws.StoredProc = "dbo.p_svc_offer_change_dates";

                            long lParam = Convert.ToInt64(strOfferID, 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            DateTime dt = DateTime.Now;
                            ws.AddParameter("@dt_start_date", dt); //startdate
                            ws.AddParameter("@dt_end_date", dt); //end date

                            ws.ExecuteNonQuery();
                            ws.Close();
                        }
                    }

                    /*
                    if (CPropUtils.HR_FAILED == CPropUtils.CleanOffer(strOfferID))
                    {
                        CTitleMgrApp.WriteLine("FAIL: Failed to clear offer " + strOfferID + " in the database");
                        bRet = false;
                    }

                    CTitleMgrApp.WriteLineV("strOfferID: Sucessfully disabled from UODB.");

                    if(bRet)
                    {
                        //
                        // Remove it from the downloadservers
                        //
                        //CPropUtils.RemovePackagesFromDL(strTitleID, strOfferID);
                        //CTitleMgrApp.WriteLineV("strOfferID: Sucessfully removed from the download servers.");
                    }

                    */
                    return (bRet);
                }

                string strSQL2File = strPath + "\\" + strOfferID.ToLower() + ".sql2";
                string strControlFile = strPath + "\\" + strOfferID.ToLower() + ".control";


                //
                //  Do the working files exist?
                //

                CPropUtils.VerifyExists(strSQL2File);
                CPropUtils.VerifyExists(strControlFile);

                Ini controlIni = new Ini(strControlFile);
                string strBillingState = controlIni.GetSetting("Billing", "SPS");

                if("NOTREADY" == strBillingState.ToUpper())
                {
                    throw new ApplicationException("Packet in SPSNotReady billing state can not be propped to UODB!");
                }

                //
                // Transfer files first if that is the case
                //
                if(UODBAction.UPDATE_TRANSFER == action)
                {
                    bRet = CPropUtils.TransferWork(strTitleID, strOfferID);
                }

                if(bRet)
                {
                    CTitleMgrApp.WriteV(strOfferID + ": Updating UODB ... \r\n");
                    //
                    // Update UODB
                    //
                    CUODBContent.Exec(strSQL2File);

                    //
                    // For the Dash
                    //
                    if(strTitleID.ToUpper() == "FFFE0000" && CPropUtils.IsIDContent(strTitleID, strOfferID))
                    {
                        DashUODBUpdate(strOfferID);
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                bRet = false;
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }
            return (bRet);
        }


        public static int ChangeDates(string strTitleID, string strOfferID, string strStartDate, string strEndDate, bool bReloadCache)
        {
            int hr = CPropUtils.HR_SUCCEEDED;
            CSourceDepot sd = null;

            try
            {
                sd = new CSourceDepot();

                //
                // Sync the control and sql2 files from the repository
                //
                string strControlFile = Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                    "\\" + strOfferID.ToLower() + ".control";
                string strSQL2File = Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                    "\\" + strOfferID.ToLower() + ".sql2";
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToLower();

                sd.Sync(strControlFile);
                sd.Sync(strSQL2File);

                //
                //  Do the working files exist?
                //
                CPropUtils.VerifyExists(strControlFile);
                CPropUtils.VerifyExists(strSQL2File);

                sd.Edit(strControlFile);
                sd.Edit(strSQL2File);

                Ini controlIni = new Ini(strControlFile);

                if(null != strStartDate)
                {
                    CPropUtils.VerifyDate(strStartDate);
                    controlIni.SetSetting("Content", "StartDate", strStartDate);
                }
                else
                    strStartDate = controlIni.GetSetting("Content", "StartDate");

                if(null != strEndDate)
                {
                    CPropUtils.VerifyDate(strEndDate);
                    controlIni.SetSetting("Content", "EndDate", strEndDate);
                }
                else
                    strEndDate = controlIni.GetSetting("Content", "EndDate");

                if (strEndDate == null || strStartDate == null ||
                    strEndDate.Length == 0 || strStartDate.Length == 0)
                {
                    throw new ApplicationException("Please specify both a start date and an end date");
                }
                if (Convert.ToDateTime(strStartDate) > Convert.ToDateTime(strEndDate))
                {
                    throw new ApplicationException("You cannot specify a start date " + strStartDate +
                        " that is later than the end date " + strEndDate);
                }

                controlIni.Save(strControlFile);

                //
                // Modify the .sql2 file
                //
                // remove any instances of p_svc_offer_change_dates
                StreamReader reader = new StreamReader(strSQL2File);
                ArrayList list = new ArrayList();

                //add every line except lines from change_dates .. blank line
                string line;
                bool addLine = true;
                while ((line = reader.ReadLine()) != null)
                {
                    if (line.Trim().Length == 0)
                        addLine = true;

                    if (line.IndexOf("p_svc_offer_change_dates") >= 0)
                        addLine = false;

                    if (addLine)
                        list.Add(line);
                }

                reader.Close();

                StreamWriter sw = new StreamWriter(strSQL2File);
                for(int i = 0; i < list.Count; i++)
                    sw.WriteLine(list[i]);

                //append the changedate
                sw.WriteLine("");
                sw.WriteLine("exec p_svc_offer_change_dates");
                sw.WriteLine("    0x" + strOfferID + ",");
                if(null == strStartDate)
                {
                    sw.WriteLine("    null,");
                }
                else
                {
                    sw.WriteLine("    " + strStartDate + ",");
                }
                if(null == strEndDate)
                {
                    sw.WriteLine("    null");
                }
                else
                {
                    sw.WriteLine("    " + strEndDate);
                }

                sw.Close();

                //
                //  Submit changes
                //
                CTitleMgrApp.WriteV("Submitting changes to the repository...");
                sd.Submit(Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                    "\\...", "titlemgr: Updated dates package for " + strOfferID);
                CTitleMgrApp.WriteLineV("Success");

                CTitleMgrApp.WriteV(strOfferID + ": Updating UODB ...");

                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                        ws.StoredProc = "dbo.p_svc_offer_change_dates";

                        long lParam = Convert.ToInt64(strOfferID, 16);
                        ws.AddParameter("@bi_offer_id", lParam);
                        DateTime dt = Convert.ToDateTime(strStartDate);
                        ws.AddParameter("@dt_start_date", dt);
                        dt = Convert.ToDateTime(strEndDate);
                        ws.AddParameter("@dt_end_date", dt);

                        ws.ExecuteNonQuery();
                        ws.Close();
                    }
                }

                CTitleMgrApp.WriteLine("Successfully changed dates and updated uodb.");

                if(bReloadCache)
                {
                    CPropUtils.UpdateXBOSCache();
                    CPropUtils.UpdateUACSCache();
                    CPropUtils.UpdateXKDCCache();
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = CPropUtils.HR_FAILED;
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }

            return (hr);
        }

        public static bool AddDefault(string strTitleID, string strStartIndex, string strSite)
        {
            bool bRet = true;

            string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
            string strDefaultPackagesPath = Environment.CurrentDirectory + "\\DefaultPackages";

            CTitleMgrApp.WriteLine("Adding default content packages for " + strTitleID + "...");


            try
            {
                if (strStartIndex == null || strStartIndex.Length != 8)
                    strStartIndex = "00000001";

                if(CTitleMgrApp.InvalidArgument(strSite) || CTitleMgrApp.InvalidArgument(strStartIndex))
                {
                    CTitleMgrApp.HelpAddDefault();
                    throw new ApplicationException("/site or /startindex: Invalid parameter!");
                }

                if(!Directory.Exists(strTitlePath))
                {
                    throw new ApplicationException("Title directory does not exist! (" + strTitlePath + ")");
                }

                if(!Directory.Exists(strDefaultPackagesPath))
                {
                    throw new ApplicationException("Default packages directory does not exist! (" + strDefaultPackagesPath + ")");
                }

                int nOfferIndex = Convert.ToInt32(strStartIndex, 16);

                string [] strFiles = Directory.GetFiles(strDefaultPackagesPath, "*.pkg");
                foreach(string strFile in strFiles)
                {
                    string strRealFile = strDefaultPackagesPath + "\\" + Path.GetFileName(strFile);
                    string strOfferID = strTitleID + CPropUtils.ExtractID(nOfferIndex.ToString("X"), 8);
                    RebuildContent(
                        strTitleID,
                        strRealFile,
                        strSite,
                        strOfferID,
                        null,
                        null,
                        true
                        );
                    nOfferIndex++;
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                bRet = false;
            }

            return (bRet);
        }

        public static void RemoveDefault(string strTitleID)
        {
            string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();

            try
            {
                CSync.RemoveTitles(strTitlePath, false);
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }


        public static void SubmitTemplate(string strTitleID, string strOfferID, string strInitialTemplate, bool bResubmit)
        {
            string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
            string strControlFile =  strTitlePath + "\\" + strOfferID.ToUpper() + ".boids";

            string strSPSFile =  strTitlePath + "\\" + strOfferID.ToUpper() + ".sps";
            string strBOIDsFile = Environment.CurrentDirectory + "\\Billing.ini";

            CSourceDepot sd = null;
            bool bSPSFileExists = false;
            bool bBOIDSFileExists = false;

            try
            {
                //
                //  Do the working files exist?
                //
                CPropUtils.VerifyExists(strInitialTemplate);
                CPropUtils.VerifyExists(strBOIDsFile);

                Ini billingIni = new Ini(strBOIDsFile);

                string strTemplateRequired = billingIni.GetSetting("Template", "Required").ToUpper();

                if (strOfferID.Length != 16)
                {
                    throw new Exception("All offerid's must be 16 characters long.");
                }
                if("YES" != strTemplateRequired)
                {
                    throw new ApplicationException("Template submitting is not allowed for this environment! Exiting...");
                }

                if(!CPropUtils.IsIDContent(strTitleID, strOfferID))
                {
                    throw new ApplicationException("The offer ID(" + strOfferID + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                sd = new CSourceDepot();

                bSPSFileExists = File.Exists(strSPSFile);

                if(bSPSFileExists && !bResubmit)
                {
                    throw new ApplicationException("Template already exists in repository." +
                        "If you are sure you want to overwrite it, try the /resubmit option." +
                        "/resubmit will cause the template information to be submitted to UODB.  Make sure it matches SPS!!");
                }

                if(!File.Exists(strControlFile))
                {
                    bBOIDSFileExists = false;
                }
                else
                {
                    bBOIDSFileExists = true;
                    sd.Edit(strControlFile);
                }

                if(bSPSFileExists)
                {
                    CTitleMgrApp.WriteLineV("Checking out \"" + strSPSFile + "\".");
                    sd.Edit(strSPSFile);
                }

                FillSPSFile(strOfferID, strInitialTemplate, strSPSFile, strControlFile);

                if (!bBOIDSFileExists) //it was just created with FillSPSFile
                    sd.Add(strControlFile);

                if (!bSPSFileExists)
                {
                    CTitleMgrApp.WriteLineV("Adding \"" + strSPSFile + "\".");
                    sd.AddBinary(strSPSFile);
                }

                //
                // Submitting changes to the repository
                //
                CTitleMgrApp.WriteLineV("Submitting changes to the repository...");

                sd.Submit(strSPSFile, "titlemgr: Updated sps package for " + strOfferID);
                sd.Submit(strControlFile, "titlemgr: Updated control package for " + strOfferID);

                /*if(File.Exists(strSQL2File))
                {
                    sd.Submit(strSQL2File, "titlemgr: Updated sql2 package for " + strOfferID);
                }
                */

                CTitleMgrApp.WriteLine("SUCCESS: Template stored in the repository.");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);

                //delete the .boids file
                sd.Revert(strSPSFile);
                sd.Revert(strControlFile);
                if (!bBOIDSFileExists)
                    File.Delete(strControlFile);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }

        }

        public static bool FillSPSFile(string strOfferID, string strInitialFile,
                                       string strSPSFile, string strControlFile)
        {
            Excel.Application oXL = null;
            string strBillingFile = Environment.CurrentDirectory + "\\Billing.ini";
            bool bValidSPSFile = false;


            try
            {
                Ini billingIni = new Ini(strBillingFile);

                //Start Excel and get Application object.
                CTitleMgrApp.WriteLineV("Starting Excel to read template spreadsheet file");
                oXL = new Excel.Application();

                if (oXL == null)
                {
                    throw new ApplicationException("Can't instantiate Excel object.  Please install Excel and make sure Excel.dll is ok");
                }

                oXL.UserControl = true;
                oXL.Visible = false;

                //Get a new workbook.
                CTitleMgrApp.WriteLineV("Opening the Excel workbook in file '"
                    + strInitialFile
                    + "'");
                Excel._Workbook oWB = (Excel._Workbook)(oXL.Workbooks.Open(
                    strInitialFile, Missing.Value, Missing.Value,Missing.Value,
                    Missing.Value,Missing.Value, Missing.Value,Missing.Value,
                    Missing.Value,Missing.Value, Missing.Value,Missing.Value,
                    Missing.Value,Missing.Value, Missing.Value));

                CTitleMgrApp.WriteLineV("Getting pricing worksheet (2nd sheet) from Excel workbook");
                Excel._Worksheet oPricingSheet = (Excel._Worksheet)oWB.Sheets[2];

                //
                // First validate the info in the spreadsheet
                //
                Excel.Range oRange = oPricingSheet.get_Range("A1", Missing.Value);

                CTitleMgrApp.WriteLineV("Retrieving 'XOfferID' from the pricing worksheet");
                Excel.Range oXOIDRange = oRange.Find("XOfferID", Missing.Value,
                    Missing.Value,XlLookAt.xlPart,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oXOIDRange)
                {
                    throw new ApplicationException("Unable to find 'XOfferID' on pricing worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                Excel.Range oXOID = oPricingSheet.get_Range(oPricingSheet.Cells[oXOIDRange.Row, oXOIDRange.Column + 1],
                                         oPricingSheet.Cells[oXOIDRange.Row, oXOIDRange.Column + 1]);

                string strSPSOfferID = oXOID.Text.ToString();

                CTitleMgrApp.WriteLineV("'XOfferID' is '"
                    + strSPSOfferID
                    + "'");

                if (strSPSOfferID.Length < 2)
                {
                    throw new ApplicationException("'XOfferID' on the pricing worksheet of Excel billing template '"
                        + strInitialFile
                        + "' of '"
                        + strSPSOfferID
                        + "' is too short to be valid.");
                }
                if(strSPSOfferID.Substring(2).ToLower() != "baadf00d" && strSPSOfferID.Substring(2).ToLower() != strOfferID.ToLower())
                {
                    throw new ApplicationException("'XOfferID' on the pricing worksheet of Excel billing template '"
                        + strInitialFile
                        + "' of '"
                        + strSPSOfferID.Substring(2).ToLower()
                        + "' does not match the offer id from the command line of '"
                        + strOfferID.ToLower()
                        + "'");
                }

                CTitleMgrApp.WriteLineV("Finding 'Tax in SRP' column on the pricing worksheet");
                Excel.Range oTaxRange = oRange.Find("Tax in SRP", Missing.Value,
                    Missing.Value,XlLookAt.xlPart,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oTaxRange)
                {
                    throw new ApplicationException("Unable to find 'Tax in SRP' column on pricing worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                int nTaxesColumn = oTaxRange.Row + 1;

                //
                // Rest of the billing validations ....
                //


                //
                // Fill in the information
                //
                CTitleMgrApp.WriteLineV("Getting offering worksheet (3rd sheet) from Excel workbook");
                Excel._Worksheet oOfferingSheet = (Excel._Worksheet)oWB.Sheets[3];

                oRange = oOfferingSheet.get_Range("A1", Missing.Value);

                CTitleMgrApp.WriteLineV("Finding 'Country' cell on the offering worksheet");
                Excel.Range oCountryRange = oRange.Find("Country", Missing.Value,
                    Missing.Value,XlLookAt.xlWhole,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oCountryRange)
                {
                    throw new ApplicationException("Unable to find 'Country' cell on offering worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                int nColumn = oCountryRange.Column + 1;

                int nCountryRow = oCountryRange.Row;

                CTitleMgrApp.WriteLineV("Finding 'SPS Offer ID' cell on the offering worksheet");
                Excel.Range oBOIDsRange = oRange.Find("SPS Offer ID", Missing.Value,
                    Missing.Value,XlLookAt.xlPart,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oBOIDsRange)
                {
                    throw new ApplicationException("Unable to find 'SPS Offer ID' cell on offering worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                int nBOIDRow = oBOIDsRange.Row;

                CTitleMgrApp.WriteLineV("Finding 'UODB End User Price' cell on the offering worksheet");
                Excel.Range oPriceRange = oRange.Find("UODB End User Price", Missing.Value,
                    Missing.Value,XlLookAt.xlWhole,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oPriceRange)
                {
                    throw new ApplicationException("Unable to find 'UODB End User Price' cell on offering worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                int nPriceRow = oPriceRange.Row;

                CTitleMgrApp.WriteLineV("Finding 'Purchase' cell on the offering worksheet");
                Excel.Range oPurchaseRange = oRange.Find("Purchase", Missing.Value,
                    Missing.Value,XlLookAt.xlWhole,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oPurchaseRange)
                {
                    throw new ApplicationException("Unable to find 'Purchase' cell on offering worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                int nPurchaseRow = oPurchaseRange.Row;

                CTitleMgrApp.WriteLineV("Finding 'Service Component ID' cell on the offering worksheet");
                Excel.Range oBSCIDRange = oRange.Find("Service Component ID", Missing.Value,
                    Missing.Value,XlLookAt.xlWhole,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                if(null  == oBSCIDRange)
                {
                    throw new ApplicationException("Unable to find 'Service Component ID' cell on offering worksheet of Excel billing template '"
                        + strInitialFile
                        + "'");
                }

                CTitleMgrApp.WriteLineV("Finding 'Cancel Flag (Y/N)' cell on the offering worksheet");
                Excel.Range oCancelFlagRange = oRange.Find("Cancel Flag (Y/N)", Missing.Value,
                    Missing.Value,XlLookAt.xlWhole,
                    Missing.Value, XlSearchDirection.xlNext,
                    Missing.Value, Missing.Value, Missing.Value);

                bool bCancelRowPresent;
                int nCancelFlagRow = -1;
                if(null  == oCancelFlagRange)
                {
                    CTitleMgrApp.WriteLine("Warning: Template "
                        + strInitialFile
                        + " does not contain Cancel Flag row. "
                        + "Offer will not be cancellable by the end user in any region.");
                    bCancelRowPresent = false;
                }
                else
                {
                    bCancelRowPresent = true;
                    nCancelFlagRow = oCancelFlagRange.Row;
                }

                Ini BOIDsIni = new Ini();

                //
                // Check to see if a BSCID is needed
                //
                int nBSCIDRow = oBSCIDRange.Row;
                oBSCIDRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nBSCIDRow, nColumn], oOfferingSheet.Cells[nBSCIDRow, nColumn]);
                string strBSCID = oBSCIDRange.Text.ToString();
                CTitleMgrApp.WriteLineV("'Service Component ID' on offering worksheet is '"
                    + strBSCID
                    + "'");
                if(null != strBSCID)
                {
                    //BSCID has been passed, save it to .boids

                    if(strBSCID.IndexOf("N/A") >= 0)
                    {
                        //they want a BSCID, but one isn't passed
                        strBSCID = Guid.NewGuid().ToString();
                        CTitleMgrApp.WriteLineV("'Service Component ID' on offering worksheet is 'N/A', generated new Service Component ID of '"
                            + strBSCID
                            + "'");
                    }

                    CTitleMgrApp.WriteLineV("Setting BSCID="
                        + strBSCID
                        + " in OFFER section of BOIDs ini file");
                    BOIDsIni.SetSetting("OFFER", "BSCID", strBSCID);
                }

                while(nColumn < oOfferingSheet.Columns.Count)
                {
                    CTitleMgrApp.WriteLineV("Examining column '"
                        + nColumn
                        + "' in offering worksheet");

                    oCountryRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nCountryRow, nColumn], oOfferingSheet.Cells[nCountryRow, nColumn]);
                    oPriceRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nPriceRow, nColumn], oOfferingSheet.Cells[nPriceRow, nColumn]);
                    oPurchaseRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nPurchaseRow, nColumn], oOfferingSheet.Cells[nPurchaseRow, nColumn]);
                    string strCountry = oCountryRange.Text.ToString();
                    string strPrice = oPriceRange.Text.ToString();
                    string strPurchase = oPurchaseRange.Text.ToString();
                    string strCancelFlag = "N"; // default to not cancelable
                    if (bCancelRowPresent)
                    {
                        oCancelFlagRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nCancelFlagRow, nColumn], oOfferingSheet.Cells[nCancelFlagRow, nColumn]);
                        strCancelFlag = oCancelFlagRange.Text.ToString();
                    }

                    if((0 == strCountry.Length))
                    {
                        CTitleMgrApp.WriteLineV("'Country' was empty. Finished reading columns");
                        break;
                    }

                    if (strPurchase == null || strPurchase.Length == 0
                        || strPrice == null || strPrice.Length ==0)
                    {
                        // if any of the required information is missing, ignore this region
                        CTitleMgrApp.WriteLineV("'Purchase' or 'Price' was blank for 'Country' '"
                            + strCountry
                            + "', skipping this column");
                        nColumn++;
                        continue;
                    }

                    CTitleMgrApp.WriteLineV("'Country' is '"
                        + strCountry
                        + "', 'UODB End User Price' is '"
                        + strPrice
                        + "' 'Purchase' is '"
                        + strPurchase
                        + "' 'Cancel Flag' is '"
                        + strCancelFlag
                        + "'");

                    string strRegion = billingIni.GetSetting("RegionsMapping", strCountry);

                    if (strRegion.Length == 0)
                    {
                        //the region isn't in billing.ini
                        throw new ApplicationException("Unable to find Country '"
                            + strCountry
                            + "' in the [RegionsMapping] section of billing.ini");
                    }
                    CTitleMgrApp.WriteLineV("'Region code for Country '"
                        + strCountry
                        + "' is '"
                        + strRegion
                        + "'");

                    //
                    // Check for a valid number
                    //
                    try
                    {
                        Convert.ToInt32(strRegion, 10);
                    }
                    catch
                    {
                        throw new ApplicationException("Unable to parse region code '"
                            + strRegion
                            + "' as a decimal integer");
                    }

                    //
                    // Generate GUIDs for the region
                    //
                    string strBOID;
                    Excel.Range oBOIDRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nBOIDRow, nColumn],
                        oOfferingSheet.Cells[nBOIDRow, nColumn]);
                    strBOID = oBOIDRange.Text.ToString();
                    CTitleMgrApp.WriteLineV("'SPS Offer ID' in spreadsheet is currently '"
                        + strBOID
                        + "'");

                    if (strBOID.Trim().Length == 0)
                    {
                        // there is currently no BOID defined for this country, so generate one
                        // and save it to the spreadsheet
                        strBOID = Guid.NewGuid().ToString();
                        oOfferingSheet.Cells[nBOIDRow, nColumn] = strBOID;
                        CTitleMgrApp.WriteLineV("'SPS Offer ID' was blank. Generated new SPS Offer ID of '"
                            + strBOID
                            + "' and saved to offering worksheet");
                    }

                    if(null != strBSCID)
                    {
                        CTitleMgrApp.WriteLineV("Saving 'Service Component ID' of '"
                            + strBSCID
                            + "' to offering worksheet");
                        oOfferingSheet.Cells[nBSCIDRow, nColumn] = strBSCID;
                    }

                    CTitleMgrApp.WriteLineV("Setting BOID="
                        + strBOID
                        + " in ["
                        + strRegion
                        + "] section of BOIDs ini file");
                    BOIDsIni.SetSetting(strRegion, "BOID", strBOID);

                    //
                    // The price need to be valid
                    //
                    try
                    {
                        Convert.ToDouble(strPrice);
                    }
                    catch
                    {
                        throw new ApplicationException("Unable to parse price code '"
                            + strPrice
                            + "' as a double precision floating point number");
                    }
                    CTitleMgrApp.WriteLineV("Setting Price="
                        + strPrice
                        + " in ["
                        + strRegion
                        + "] section of BOIDs ini file");
                    BOIDsIni.SetSetting(strRegion, "Price", strPrice);

                    //
                    // The Cancel Flag must be "Y" or "N"
                    // If the cancel row was not present because we're dealing with
                    // an old billing template we'll have set it to "N" by default
                    strCancelFlag = strCancelFlag.Trim().ToUpper();
                    if (strCancelFlag != "Y"
                        && strCancelFlag != "N")
                    {
                        throw new ApplicationException("Cancel Flag must be either Y or N. "
                            + " Cancel flag in spreadsheet is '"
                            + strCancelFlag
                            + "'");
                    }

                    CTitleMgrApp.WriteLineV("Setting CancelFlag="
                        + strCancelFlag
                        + " in ["
                        + strRegion
                        + "] section of BOIDs ini file");
                    BOIDsIni.SetSetting(strRegion, "CancelFlag", strCancelFlag);

                    //
                    // Record the taxes - look in the pricing spreadsheet
                    //
                    CTitleMgrApp.WriteLineV("Looking for tax information on Pricing worksheet for country '"
                        + strCountry
                        + "'");

                    Excel.Range oPTaxRange = oPricingSheet.get_Range("A1", Missing.Value);

                    Excel.Range oCountryCell = oPTaxRange.Find(strCountry, Missing.Value,
                        Missing.Value,XlLookAt.xlWhole,
                        Missing.Value, XlSearchDirection.xlNext,
                        Missing.Value, Missing.Value, Missing.Value);
                    if (oCountryCell == null)
                    {
                        throw new ApplicationException("Unable to find Country '"
                            + strCountry
                            + "' on Pricing worksheet");
                    }

                    int nPCountryRow = oCountryCell.Row;

                    Excel.Range oPFCol = oPTaxRange.Find("Price Pass/Fail", Missing.Value,
                        Missing.Value,XlLookAt.xlWhole,
                        Missing.Value, XlSearchDirection.xlNext,
                        Missing.Value, Missing.Value, Missing.Value);

                    if (oPFCol == null)
                    {
                        throw new ApplicationException("Unable to find 'Price Pass/Fail' on Pricing worksheet");
                    }

                    int nPFColumn = oPFCol.Column;

                    Excel.Range oPFCell = oPricingSheet.get_Range(oPricingSheet.Cells[nPCountryRow, nPFColumn], oPricingSheet.Cells[nPCountryRow, nPFColumn]);
                    string strPF = oPFCell.Text.ToString();

                    if (strPF.Trim().ToUpper() != "OK")
                    {
                        throw new ApplicationException("'Price Pass/Fail' for Country '"
                            + strCountry
                            + "' on Pricing worksheet is '"
                            + strPF
                            + "'. It must be set to 'OK'");
                    }

                    Excel.Range oTaxNameCol = oPTaxRange.Find("Tax in SRP?", Missing.Value,
                        Missing.Value,XlLookAt.xlWhole,
                        Missing.Value, XlSearchDirection.xlNext,
                        Missing.Value, Missing.Value, Missing.Value);

                    if (oTaxNameCol == null)
                    {
                        throw new ApplicationException("Unable to find 'Tax in SRP?' on Pricing worksheet");
                    }

                    int nPColumn = oTaxNameCol.Column;

                    Excel.Range oTaxCell = oPricingSheet.get_Range(oPricingSheet.Cells[nPCountryRow, nPColumn], oPricingSheet.Cells[nPCountryRow, nPColumn]);
                    string strTaxSetting = oTaxCell.Text.ToString();


                    // The XONLINE_TAX_TYPE enum from xonline.h defines the tax types
                    // that billing understands. It is repeated here for reference:
                    //
                    //  typedef enum {
                    //    NO_TAX = 0,
                    //    DEFAULT,
                    //    GST,
                    //    VAT,
                    //    TAX_NOT_APPLICABLE
                    //} XONLINE_TAX_TYPE;
                    //
                    CTitleMgrApp.WriteLineV("Read 'Tax in SRP?' value of of '"
                        + strTaxSetting
                        + "' for region '"
                        + strRegion
                        + "'");
                    if (strTaxSetting.Trim().ToUpper().Equals("PLUS APPLICABLE TAXES"))
                    {
                        CTitleMgrApp.WriteLineV("Setting Tax=0 in ["
                            + strRegion
                            + "] section of BOIDs ini file");
                        BOIDsIni.SetSetting(strRegion, "Tax", "0");
                    }
                    else if (strTaxSetting.Trim().ToUpper().Equals("GST INCLUDED"))
                    {
                        CTitleMgrApp.WriteLineV("Setting Tax=2 in ["
                            + strRegion
                            + "] section of BOIDs ini file");
                        BOIDsIni.SetSetting(strRegion, "Tax", "2");
                    }
                    else if (strTaxSetting.Trim().ToUpper().Equals("VAT INCLUDED"))
                    {
                        CTitleMgrApp.WriteLineV("Setting Tax=3 in ["
                            + strRegion
                            + "] section of BOIDs ini file");
                        BOIDsIni.SetSetting(strRegion, "Tax", "3");
                    }
                    else if (strTaxSetting.Trim().ToUpper().Equals("TAX NOT APPLICABLE"))
                    {
                        CTitleMgrApp.WriteLineV("Setting Tax=4 in ["
                            + strRegion
                            + "] section of BOIDs ini file");
                        BOIDsIni.SetSetting(strRegion, "Tax", "4");
                    }
                    else
                    {
                        // we didn't understand the content of the tax field, so whine loudly
                        throw new ApplicationException("Could not understand tax setting of '"
                            + strTaxSetting
                            + "' for region '"
                            + strRegion
                            + "'. The allowable values are: 'PLUS APPLICABLE TAXES', 'GST INCLUDED', 'VAT INCLUDED', and 'TAX NOT APPLICABLE'");
                    }

                    nColumn++;
                }

                CTitleMgrApp.WriteLineV("Saving updated spreadsheet to '"
                    + strSPSFile
                    + "'");
                if (File.Exists(strSPSFile))
                    File.Delete(strSPSFile);
                oWB.SaveAs(strSPSFile ,Missing.Value,Missing.Value, Missing.Value,Missing.Value,
                    Missing.Value,XlSaveAsAccessMode.xlNoChange, Missing.Value ,Missing.Value,
                    Missing.Value,Missing.Value, Missing.Value);

                BOIDsIni.Save(strControlFile);

                bValidSPSFile = true;
            }
            finally
            {
                if(null != oXL)
                {
                    //saving this file as a temp b/c otherwise excel prompts you to save
                    oXL.Save(Environment.CurrentDirectory + "\\temp.tmp");
                    File.Delete(Environment.CurrentDirectory + "\\temp.tmp");
                    oXL.Quit();
                }
            }

            return (bValidSPSFile);
        }

        public static void InjectBoids(string strTitleID, string strID)
        {
            string strSQL2File = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".sql2";
            string strBOIDsFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".boids";
            string strCTLFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".control";

            try
            {
                ModifyBillingContent(strSQL2File, strBOIDsFile);

                //copy the new to the sql2
                CSourceDepot sd = new CSourceDepot();
                sd.Edit(strSQL2File);
                File.Copy(strSQL2File + ".new", strSQL2File, true);
                File.Delete(strSQL2File + ".new");
                sd.Submit(strSQL2File, "New billing info injected");

                sd.Edit(strCTLFile);
                Ini ctlIni = new Ini(strCTLFile);
                ctlIni.SetSetting("BILLING", "SPS", "READY");
                ctlIni.Save(strCTLFile);
                sd.Submit(strCTLFile, "SPS is ready");

            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }

            CTitleMgrApp.WriteLine("Boids injected successfully");
        }

        public static void ModifyBillingContent(string strSQL2File, string strBOIDsFile)
        {
            StreamReader sr = null;
            StreamWriter sw = null;
            FileStream fsr = null;
            FileStream fsw = null;

            string strNewSQL2File = strSQL2File + ".new";

            try
            {
                Ini BOIDsIni = new Ini(strBOIDsFile);

                string strID = Path.GetFileNameWithoutExtension(strBOIDsFile);

                fsr = new FileStream(strSQL2File,FileMode.Open, FileAccess.Read);

                if (File.Exists(strNewSQL2File))
                    File.Delete(strNewSQL2File);
                fsw = new FileStream(strNewSQL2File, FileMode.CreateNew, FileAccess.Write);
                sr = new StreamReader(fsr);
                sw = new StreamWriter(fsw);

                int  nOfferRegionSPLine = 0; // stored procedure not found yet
                int nInsertSubscriptionsSPLine = -1; //stored procedure not found yet
                string strLine = sr.ReadLine();
                string strRegionNumber = null;
                string strPrice = null;
                int lineNum = 0;
                OfferTypes offerType = OfferTypes.CONTENT;

                //get BSCID
                string strBSCID = BOIDsIni.GetSetting("OFFER", "BSCID");
                if (strBSCID.Length == 0)
                    strBSCID = "";


                while( null != strLine )
                {
                    if(nOfferRegionSPLine > 0)
                    {
                        if (strBOIDsFile.IndexOf(".boids") < 0)
                        {
                            switch(nOfferRegionSPLine)
                            {
                                case 2: // region number
                                    strRegionNumber = strLine.Replace(',', ' ').Trim();
                                    break;
                                case 3:// BOID
                                    if (strBOIDsFile.IndexOf(".boids") < 0)
                                    {
                                        switch(offerType)
                                        {
                                            case OfferTypes.SUBSCRIPTION:
                                                strLine = "    '" + BOIDsIni.GetSetting("Subscription." + strRegionNumber, "BOID") + "',";
                                                break;
                                            case OfferTypes.BASE_SUBSCRIPTION:
                                                strLine = "    '" + BOIDsIni.GetSetting("BaseSubscription." + strRegionNumber, "BOID") + "',";
                                                break;
                                            default:
                                                strLine = "    '" + BOIDsIni.GetSetting("Content." + strRegionNumber, "BOID") + "',";
                                                break;
                                        }
                                    }
                                    break;
                                case 4: // whole price - keep these the same

                                    break;
                                case 5: //fractional price

                                    break;
                                case 6:
                                    nOfferRegionSPLine = -1;
                                    if (strLine == null || strLine.Length == 0)
                                        strLine = "0x000";
                                    break;
                            }
                        }

                        //we are deleting all previous region info
                        nOfferRegionSPLine++;

                        if (nOfferRegionSPLine == 8)
                            nOfferRegionSPLine = -1;
                    }
                    else
                    {
                        if(0 < strLine.IndexOf("p_svc_insert_offer_regions"))
                        {
                            nOfferRegionSPLine = 1; // found stored proc
                        }

                    }

                    if(nInsertSubscriptionsSPLine > 0)
                    {
                        switch(nInsertSubscriptionsSPLine)
                        {
                            case 1: //Titleid
                                if(0 < strLine.ToUpper().IndexOf(CPropUpdate.DASHID))
                                {
                                    //
                                    // Dash subscription
                                    //
                                    offerType = OfferTypes.BASE_SUBSCRIPTION;
                                }
                                else
                                {
                                    offerType = OfferTypes.SUBSCRIPTION;
                                }
                                break;
                            case 9:// BSCID
                                if(offerType != OfferTypes.BASE_SUBSCRIPTION)
                                {
                                    //not the dash
                                    strLine = "    '" + BOIDsIni.GetSetting("PremiumSubscription", "BSCID") + "',";
                                }
                                else
                                {
                                    //dash uses base ID
                                    strLine = "    '" + BOIDsIni.GetSetting("BaseSubscription", "BSCID") + "',";
                                }
                                break;
                            case 10:
                                nInsertSubscriptionsSPLine = -1;
                                break;
                        }

                        nInsertSubscriptionsSPLine++;
                    }
                    else
                    {
                        if(0 < strLine.IndexOf("p_svc_insert_subscriptions"))
                        {
                            nInsertSubscriptionsSPLine = 1; // found stored proc
                        }
                    }

                    //change BSCID line
                    lineNum++;
                    if (lineNum == 10)
                        strLine = "    '" + strBSCID + "',";

                    //
                    // Write the line
                    // Unless there is a .boids file and we are in a region
                    //
                    if (nOfferRegionSPLine == 0 || strBOIDsFile.IndexOf(".boids") < 0)
                        sw.WriteLine(strLine);

                    //have we erased the region, start writing again
                    if (nOfferRegionSPLine < 0)
                        nOfferRegionSPLine = 0;
                    //
                    // Read another line
                    //
                    strLine = sr.ReadLine();
                }

                //add region info from BOIDS file
                if (strBOIDsFile.IndexOf(".boids") >= 0)
                {
                    Hashtable hashRegions = BOIDsIni.Sections;

                    //
                    //  Find all the services, add them to the array
                    //

                    foreach(DictionaryEntry section in hashRegions)
                    {
                        //
                        //  Get section and derive service id from it
                        //

                        strRegionNumber = section.Key.ToString();

                        try
                        {
                            if (strRegionNumber == "OFFER")
                            {
                                continue;
                            }

                            Int32.Parse(strRegionNumber);

                            //if this didn't throw an exception, we have a region

                            string strBoid = BOIDsIni.GetSetting(strRegionNumber, "BOID");

                            if (strBoid.Length == 0)
                                throw new ApplicationException("Bad BOID in region " + strRegionNumber);

                            string strPriceWhole, strPricePart;
                            string [] strPrices = null;

                            strPrice = BOIDsIni.GetSetting(strRegionNumber, "PRICE");

                            if (strPrice.Length == 0)
                                throw new ApplicationException("Bad Price in region " + strRegionNumber);

                            strPrices = strPrice.Split('.');

                            strPriceWhole = strPrices[0];
                            if (strPrices.Length == 2)
                            {
                                strPricePart = strPrices[1];
                            }
                            else
                                strPricePart = "0";

                            if (strPricePart.Length == 1)
                                strPricePart += "0";

                            if (strPriceWhole.Length == 0 || strPricePart.Length == 0)
                                throw new ApplicationException("Bad Price in region " + strRegionNumber);

                            string strTax = BOIDsIni.GetSetting(strRegionNumber, "TAX");
                            string strCancelFlag = BOIDsIni.GetSetting(strRegionNumber, "CancelFlag");

                            //
                            // si_specific_offer_details column in t_offer_regions stores both
                            // the tax type, and a flag that indicates if the offer can be cancelled
                            // by the user in the dashboard.
                            //
                            // The tax type is stored in the low 3 bits (mask: 0x0007)
                            // The cancel flag is tored in the 4th bit (mask: 0x0008)
                            int iTax = 0;
                            try
                            {
                                iTax = Int32.Parse(strTax);
                            }
                            catch (Exception e)
                            {
                                throw new ApplicationException(
                                    "Unable to parse TAX setting in boids.ini file for region "
                                    + strRegionNumber,
                                    e);
                            }

                            // make sure that only the lower three bits have been
                            // used to store this tax type
                            if ((iTax & 0xFFFF8) != 0)
                            {
                                throw new ApplicationException(
                                    "Invalid TAX setting in boids.ini file for region "
                                    + strRegionNumber
                                    + " of "
                                    + iTax.ToString());
                            }

                            int iCancelFlag = 0;
                            if (strCancelFlag == "Y")
                            {
                                iCancelFlag = 0x0008;
                            }

                            int iSpecificOfferDetails = (iTax | iCancelFlag);
                            string strSpecificOfferDetails = iSpecificOfferDetails.ToString("X");

                            sw.WriteLine("exec p_svc_insert_offer_regions"); //command
                            sw.WriteLine("    0x" + strID + ","); //offer id
                            sw.WriteLine("    " + strRegionNumber + ","); //region
                            sw.WriteLine("    '" + strBoid + "',"); //boid
                            sw.WriteLine("    " + strPriceWhole + ","); //price whole
                            sw.WriteLine("    " + strPricePart + ","); //price part
                            sw.WriteLine("    0x" + strSpecificOfferDetails); //tax & cancel flag
                            sw.WriteLine(""); //blank line at the end


                        }
                        catch (FormatException)
                        {
                            //we only want to catch the Int32 exception
                            //Console.WriteLine(e.ToString());
                        }
                    }
                } //if we are in a boids file, add regions from there

            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sr)
                {
                    sr.Close();
                }

                if(null != sw)
                {
                    sw.Close();
                }

                if(null != fsr)
                {
                    fsr.Close();
                }

                if(null != fsw)
                {
                    fsw.Close();
                }

            }


        }


        public static void SetBillingState(string strTitleID, string strOfferID, string strSPSState)
        {
            string strControlFile = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper()
                 + "\\" + strOfferID.ToUpper() + ".control";

            CSourceDepot sd = null;

            try
            {
                if(!File.Exists(strControlFile))
                {
                    throw new ApplicationException("Path not found: " + strControlFile);
                }

                if(("READY" != strSPSState.ToUpper()) && ("NOTREADY" != strSPSState.ToUpper()))
                {
                    throw new ApplicationException("Invalid SPS state specified: " + strSPSState);
                }

                sd = new CSourceDepot();

                CTitleMgrApp.WriteLine("Checking out \"" + strControlFile + "\".");
                sd.Edit(strControlFile);

                Ini controlIni = new Ini(strControlFile);

                controlIni.SetSetting("Billing", "SPS", strSPSState);

                controlIni.Save(strControlFile);

                CTitleMgrApp.WriteLineV("Submitting out \"" + strControlFile + "\".");
                sd.Submit(strControlFile, "TitleMgr: changing billing states.");
                CTitleMgrApp.WriteLineV("Success!");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }
        }

        public static void Renew(string titleID, string from, string to, string sMode)
        {
            //add insert_offer_relations to sql2 file
            string path = Environment.CurrentDirectory + "\\" + titleID + "\\";
            string [] fromOffers = from.Split(';');
            if (!File.Exists(path + to + ".control"))
            {
                throw new Exception("To offer " + to + " does not belong to " + titleID);
            }

            if (!CPropUtils.IsSubscription(titleID, to))
            {
                throw new Exception("You can only renew subscriptions. To offer " + to + " is content.");
            }

            CSourceDepot sd = new CSourceDepot();

            foreach(string offer in fromOffers)
            {
                if (!File.Exists(path + offer + ".control"))
                {
                    CTitleMgrApp.WriteLine("From offer " + offer + " does not belong to " + titleID);
                    continue;
                }
                if (!CPropUtils.IsSubscription(titleID, offer))
                {
                    CTitleMgrApp.WriteLine("You can only renew subscriptions. From offer " + offer + " is content.");
                    continue;
                }
                string sqlfile = path + to + ".sql2";
                //see if relation exists
                StreamReader reader = new StreamReader(sqlfile);
                string line;

                bool found;
                found = false;

                int number;
                number = 0;

                ArrayList lines = new ArrayList();
                while ((line = reader.ReadLine()) != null)
                {
                    if (line.Trim() == "exec p_svc_insert_offer_relations")
                    {
                        // we've found an offer relations stored proc

                        // write the stored proc name line to the output array
                        lines.Add(line);

                        // the next three lines contain the "to" offerid
                        // the "from" offerid, and the relation type
                        string sToLine = reader.ReadLine();
                        string sFromLine = reader.ReadLine();
                        number += 2;

                        // the first two lines don't get changed no matter what
                        // so add them to the output array list
                        lines.Add(sToLine);
                        lines.Add(sFromLine);

                        // now, check to see if this is the offer relation
                        // we're interested in
                        if (sToLine.Trim().Substring(2).ToUpper() == (to.ToUpper() + ",")
                            && sFromLine.Trim().Substring(2).ToUpper() == (offer.ToUpper() + ","))
                        {
                            // this is the offer we're interested in
                            found = true;

                            // the 3rd line of the proc is the relation parameter
                            string sRelationLine = reader.ReadLine();
                            number++;

                            // the 4th line may or may not be the convert mode,
                            // because it's a new optional parameter that wasn't
                            // there before tsunami. Therefore all the pre-tsunami
                            // sql2 files in the repository don't have it. We
                            // can tell if it's there, because the previous line
                            // will end with a comma if there's another parameter
                            // to come
                            string sRelationLineTrim = sRelationLine.Trim();
                            if (sRelationLineTrim[sRelationLineTrim.Length-1] == ',')
                            {
                                // there's already a fourth line, so we don't
                                // need to add a comma to the third
                                lines.Add(sRelationLine);

                                // get the fourth line so the reader is properly
                                // positioned
                                reader.ReadLine();
                                number++;
                            }
                            else
                            {
                                // there are currently only three lines. Append
                                // a comma to the third line, and add the fourth
                                lines.Add(sRelationLine+",");
                            }

                            // output the correct 4th line
                            lines.Add("    0x" + sMode);
                        }
                    }
                    else
                    {
                        if (number == 10)
                        {
                            line = "    0x0004,";
                        }

                        lines.Add(line);

                        number++;
                    }
                }

                reader.Close();

                sd.Edit(sqlfile);
                StreamWriter writer = new StreamWriter(sqlfile);

                for (int k = 0; k < lines.Count; k++)
                    writer.WriteLine(lines[k]);

                if (!found)
                {
                    //the stored proc is not in the sql2 file yet
                    CTitleMgrApp.WriteLine("Adding relation " + offer + " to " + sqlfile);

                    writer.WriteLine("");
                    writer.WriteLine("exec p_svc_insert_offer_relations");
                    writer.WriteLine("    0x" + to + ",");
                    writer.WriteLine("    0x" + offer + ",");
                    writer.WriteLine("    3,");
                    writer.WriteLine("    0x" + sMode);
                }
                else
                {
                    CTitleMgrApp.WriteLine("Offer relation from " + offer + " to " + to + " updated.");
                }

                writer.Close();
                sd.Submit(sqlfile, "Added offer relation from " + offer + " to " + to);
            }
        }

        public static void Voucher(string titleid, string offers, bool add)
        {
            string path = Environment.CurrentDirectory + "\\" + titleid + "\\";
            string [] Offers = offers.Split(';');
            foreach (string offer in Offers)
            {
                CTitleMgrApp.WriteLineV("Checking: " + offer);

                string sqlfile = path + offer + ".sql2";
                if (!File.Exists(sqlfile))
                {
                    CTitleMgrApp.WriteLine("Can't find sql file: " + sqlfile);
                    continue;
                }

                ArrayList lines = new ArrayList();
                StreamReader reader = new StreamReader(sqlfile);
                string line = "";
                int i = 0;
                try
                {
                    while ((line = reader.ReadLine()) != null)
                    {
                        if (i == 16)
                        {
                            //on policy flags

                            //if there is a comma at end of line, replace it
                            bool comma = false;
                            if (line.IndexOf(",") > 0)
                            {
                                comma = true;
                                line = line.Replace(",","");
                            }
                            int policy = Int32.Parse(line.Trim().Substring(2), NumberStyles.HexNumber);
                            if (add)
                                policy |= 0x200;
                            else
                                policy &= ~0x200;
                            line = "    0x" + policy.ToString("x");
                            if (comma)
                                line += ",";
                        }

                        i++;
                        lines.Add(line);
                    }
                }
                catch(Exception e)
                {
                    CTitleMgrApp.WriteLine("Error checking line: " + line + ". " + e.Message);
                    continue;
                }
                finally
                {
                    reader.Close();
                }

                CSourceDepot sd = new CSourceDepot();
                sd.Edit(sqlfile);

                StreamWriter writer = new StreamWriter(sqlfile);
                for(int k = 0; k < lines.Count; k++)
                    writer.WriteLine(lines[k]);
                writer.Close();

                sd.Submit(sqlfile, "titlemgr: updated policy flags on voucher: " + add.ToString());

                CTitleMgrApp.WriteLine("Set voucher status to " + add + " on: " + offer);
            }
        }

        public static void SyncOffer(string titleid, string offer)
        {
            try
            {
                CTitleMgrApp.WriteLine("Syncing single offer: " + offer);

                string strFileBase = Environment.CurrentDirectory + "\\" + titleid + "\\" + offer;
                if (!File.Exists(strFileBase + ".sql2"))
                    throw new Exception("FAIL: file not found - " + strFileBase + ".sql2");

                //first transfer the file
                CPropUtils.Transfer(titleid, offer);

                //now do uodb work
                CUODBContent.Exec(strFileBase + ".sql2");

                //reload front doors
                CPropUtils.UpdateXKDCCache();
                CPropUtils.UpdateXBOSCache();
                CPropUtils.UpdateUACSCache();
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CResetLeaderboard.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;

namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// 
	/// </summary>
	public class CResetLeaderboard
	{
		public static void Exec(string titleid, string lb_list)
		{
            try
            {
                if("" == lb_list)
                {
                    CTitleMgrApp.HelpResetLB();
                    throw new ApplicationException("/resetlb: Invalid argument!");
                }

                int nTitleID = Int32.Parse(titleid, NumberStyles.HexNumber);
                
                //
                //  Load stats.ini
                //

                string statsIniPath = Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.ini";

                Ini statsIni;
                if(File.Exists(statsIniPath))
                    statsIni = new Ini(statsIniPath);
                else
                    statsIni = new Ini();

                string statsDB = CStatsUtil.ResolveTitleStatsDB(nTitleID, ref statsIni, null);

                if(statsDB == null)
                {
                    throw new ApplicationException("No database found for " + titleid + ".");
                }

                CStatsUtil.UpdateStatsIni(statsIni, statsIniPath);

                //
                //  Reset the leaderboards
                //

                if(lb_list.ToLower() == "all")
                {
                    ResetTitleLeaderboards(statsDB, nTitleID);
                }
                else
                {
                    Hashtable leaderBoards = CTitleMgrApp.GetLeaderboardList(statsDB, nTitleID.ToString());

                    string [] lbArray = lb_list.Split(';');

                    foreach(string lb in lbArray)
                    {
                        if(!leaderBoards.ContainsKey(Int32.Parse(lb)))
                        {
                            CTitleMgrApp.WriteLine("Leaderboard " + lb + " not found in the database.");
                            continue;
                        }

                        int nLB = Int32.Parse(lb);

                        CTitleMgrApp.WriteLine("Resetting leaderboard " + lb + " for title " + titleid + ".");
                        ResetTitleLeaderboard(statsDB, nTitleID, nLB);
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }

		}

        private static int ResetTitleLeaderboards(string statsDB, int nTitleID)
        {
            return CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetTitle " + nTitleID.ToString());
        }

        private static int ResetTitleLeaderboard(string statsDB, int nTitleID, int nLB)
        {
            return CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetLeaderBoard " + nTitleID.ToString() + ", " + nLB.ToString() + ", null");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CStatsUtil.cs ===
using System;
using System.Collections;
using System.IO;
using System.Data.SqlClient;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.titlemgr
{
    /// <summary>
    /// Caller is responsible for saving any changes to statsIni.
    /// </summary>
    internal class CStatsUtil
    {
        //
        //  Stats DB is determined in the following order:
        //
        //  1.  If the title id already has entries in a database, then that database is used and stats.ini
        //      is updated with the correct index.
        //  2.  If a database name is passed on the command line, then that database is used and
        //      stats.ini is updated with the correct index.
        //  3.  If stats.ini contains a database index, then lookup the correct database for that
        //      index.  stats.ini is NOT updated in this case.
        //
        //  Returns null if no DB could be found for the title, otherwise a server name.
        //

        public static string ResolveTitleStatsDB(int nTitleID, ref Ini statsIni, string statsDBOverride)
        {
            int     statsDBIndex;
            string  statsDB;

            //
            //  1.  If the title id already has entries in a database, then that database is used and stats.ini
            //      is updated with the correct index.
            //

            statsDB = CStatsUtil.FindDBForTitle(nTitleID);
            if(statsDB != null)
            {
                // statsDBIndex will never get -1 in this case because FindDBForTitle above, looks through
                // the servers in servers.ini to find a DB.  The returned statsDB must be one of those.
                statsDBIndex = CTitleMgrApp.GetServerIndex("STATSDB", statsDB);

                // update entry in stats.ini
                statsIni.SetSetting("SETTINGS", "STATSDB", statsDBIndex.ToString());

                return statsDB;
            }

            //
            //  2.  If a database name is passed on the command line, then that database is used and
            //      stats.ini is updated with the correct index.
            //

            if(statsDBOverride != null && statsDBOverride.Length != 0)
            {
                statsDBIndex = CTitleMgrApp.GetServerIndex("STATSDB", statsDBOverride);
                if(statsDBIndex == -1)
                {
                    CTitleMgrApp.WriteLine("Specified stats db is not specified in servers.ini.");
                }
                else
                {
                    statsDB = statsDBOverride;
                    statsIni.SetSetting("SETTINGS", "STATSDB", statsDBIndex.ToString());

                    return statsDB;
                }
            }

            //  3.  If stats.ini contains a database index, then lookup the correct database for that
            //      index.  stats.ini is NOT updated in this case.
            statsDB = statsIni.GetSetting("SETTINGS", "STATSDB");
            if(statsDB.Length != 0)
            {
                try
                {
                    statsDBIndex = Int32.Parse(statsDB);
                }
                catch (Exception)
                {
                    //statsDB is in IP format - old school
                    return null;
                }
                statsDB = CTitleMgrApp.GetServerAddress("STATSDB", statsDBIndex);
                if(statsDB == null)
                    CTitleMgrApp.WriteLine("No stats DBs specified in servers.ini.");
                else
                    return statsDB;
            }

            return null;
        }

        //
        //  Searches through all stats databases specified in servers.ini, looking
        //  for a server hosting the specified title id.  Returns the name of the
        //  server if found, otherwise returns null.
        //

        public static string FindDBForTitle(int nTitleID)
        {
            string server = null;
            string serverList = CTitleMgrApp.Servers.GetSetting("SERVERS", "STATSDB");
            if(serverList.Length == 0)
            {
                CTitleMgrApp.WriteLine("No statistics databases specified in servers.ini.");
                goto Done;
            }

            string [] serverArray = serverList.Split(';');

            foreach(string curServer in serverArray)
            {
                SqlDataReader reader = CTitleMgrApp.RunSqlQuery(curServer, "xstats", "exec p_Stats_QueryTitles");

                while(reader.Read())
                {
                    if(reader.GetInt32(0) == nTitleID)
                    {
                        server = curServer;
                        goto Done;
                    }
                }
            }

Done:
            return server;
        }

        //
        //  If the specified statsIni object has been changed, this
        //  function checks it out, saves the new data, and checks it back in.
        //  If the ini hasn't changed, nothing happens.
        //

        public static void UpdateStatsIni(Ini statsIni, string statsIniPath)
        {
            if(!statsIni.Changed)
            {
                CTitleMgrApp.WriteLineV("stats.ini was not changed.");
                return;
            }

            CSourceDepot sd;

            try
            {
                sd = new CSourceDepot();

                CTitleMgrApp.WriteLineV("Checking out stats.ini...");
                sd.Edit(statsIniPath);

                CTitleMgrApp.WriteLineV("Writing new stats.ini...");
                statsIni.Save(statsIniPath);

                //
                //  Submit changes
                //

                CTitleMgrApp.WriteLineV("Checking in stats.ini...");
                sd.Submit(statsIniPath, "Adding STATSDB entry.");
            }
            finally
            {
                sd = null;
            }
        }

        public static void RemoveUserFromLB(string titleid, string user, string lb_list)
        {
            try
            {
                if(("" == user) || CTitleMgrApp.InvalidArgument(lb_list))
                {
                    CTitleMgrApp.HelpRemoveUserFromLB();
                    throw new ApplicationException("/removeuserfromlb or /lb : Invalid argument!");
                }

                int nTitleID = Int32.Parse(titleid, NumberStyles.HexNumber);
                string statsIniPath = Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.ini";

                Ini statsIni;
                if(File.Exists(statsIniPath))
                    statsIni = new Ini(statsIniPath);
                else
                    statsIni = new Ini();

                string statsDB = CStatsUtil.ResolveTitleStatsDB(nTitleID, ref statsIni, null);

                if(statsDB == null)
                {
                    throw new ApplicationException("Could not determine database for " + titleid + ".");
                }

                //
                //  Try to treat user as a hexadecimal string
                //

                long puid;
                try
                {
                    puid = Int64.Parse(user, NumberStyles.HexNumber);
                }
                catch(Exception)
                {
                    puid = 0;
                }

                //
                //  Not a puid, try to look up user in uodb db
                //

                if(puid == 0)
                {
                    WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                    WstDataReader results;

                    ws.SetHashVal(user);
                    ws.StoredProc = "dbo.p_pres_get_user_puid";
                    ws.AddParameter("@vc_gamertag", user);

                    results = ws.Execute();

                    while(results.Read())
                    {
                        puid = results.GetInt64(0);
                        break;
                    }
                }

                //
                //  Still don't have a puid?  Operation fails.
                //

                if(puid == 0)
                {
                    throw new ApplicationException("Could not convert " + user + " to a valid PUID.");
                }

                //
                //  We have a puid now, remove the user from all specified leaderboards
                //

                if(lb_list.ToLower() == "all")
                {
                    CTitleMgrApp.WriteLine("Reseting all leaderboards for " + puid.ToString());
                    CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetUser " + nTitleID.ToString() + ",0," + puid.ToString());
                }
                else
                {
                    string[] lbArray = lb_list.Split(';');

                    foreach(string lb in lbArray)
                    {
                        int nLB = Int32.Parse(lb);

                        CTitleMgrApp.WriteLine("Reseting leaderboard " + nLB.ToString() + " for " + puid.ToString());
                        CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetUser " + nTitleID.ToString() + "," + nLB.ToString() + "," + puid.ToString());
                    }
                }

                CTitleMgrApp.WriteLine("SUCCESS: User removed from leaderboards!");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }
        public static void DeleteLB(string titleid, string lb_list)
        {
            try
            {
                int nTitleID = Int32.Parse(titleid, NumberStyles.HexNumber);

                string strTitlePath = Environment.CurrentDirectory + "\\" + titleid;

                //
                //  Open stats.ini
                //
                CPropUtils.VerifyExistsDir(strTitlePath);

                Ini statsIni = null;
                string statsIniPath = strTitlePath + "\\config\\stats.ini";

                if(File.Exists(statsIniPath))
                    statsIni = new Ini(statsIniPath);
                else
                    statsIni = new Ini();

                string statsDB = CStatsUtil.ResolveTitleStatsDB(nTitleID, ref statsIni, null);

                if(statsDB == null)
                {
                    throw new ApplicationException("Could not determine database for " + titleid + ".");
                }

                //
                //  Get list of leaderboards to delete from the server
                //

                Hashtable leaderBoards = CTitleMgrApp.GetLeaderboardList(statsDB, nTitleID.ToString());

                //  Are there any?

                if(leaderBoards.Count == 0)
                {
                    throw new ApplicationException("No leaderboards in database to delete.");
                }

                //
                //  Set up the list of leaderboards to delete
                //

                string [] lbArray;

                if(lb_list.ToLower() == "all")
                {
                    lbArray = new string[leaderBoards.Keys.Count];
                    int nCurKey = 0;

                    foreach(int nLB in leaderBoards.Keys)
                    {
                        lbArray[nCurKey++] = nLB.ToString();
                    }
                }
                else
                {
                    lbArray = lb_list.Split(';');
                    if(lbArray.Length == 0)
                    {
                        throw new ApplicationException("No leaderboards specified.");
                    }
                }

                //
                //  Delete all leaderboards in list from the database and stats.ini
                //

                foreach(string lb in lbArray)
                {
                    if(!leaderBoards.ContainsKey(Int32.Parse(lb)))
                    {
                        CTitleMgrApp.WriteLine("Leaderboard " + lb + " was not found in the database.");
                        continue;
                    }

                    CTitleMgrApp.WriteLine("Deleting leaderboard " + lb + " from the database but NOT stats.ini/xml.");

                    //  Remove the leader board from the list, whether it's actually in there or not.
                    //actually, since we don't want to update the xml, this is just used to clear the db out
                    //statsIni.SetSetting("LEADERBOARDS", lb, null);

                    //  Remove the leader board from the db.
                    CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_DeleteLeaderBoard " + nTitleID.ToString() + "," + lb);
                }

           }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }

        }

        public static void ResetLB(string titleid, string lb_list)
        {
            try
            {
                if("" == lb_list)
                {
                    CTitleMgrApp.HelpResetLB();
                    throw new ApplicationException("/resetlb: Invalid argument!");
                }

                int nTitleID = Int32.Parse(titleid, NumberStyles.HexNumber);

                //
                //  Load stats.ini
                //

                string statsIniPath = Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.ini";

                Ini statsIni;
                if(File.Exists(statsIniPath))
                    statsIni = new Ini(statsIniPath);
                else
                    statsIni = new Ini();

                string statsDB = CStatsUtil.ResolveTitleStatsDB(nTitleID, ref statsIni, null);

                if(statsDB == null)
                {
                    throw new ApplicationException("No database found for " + titleid + ".");
                }

                //
                //  Reset the leaderboards
                //

                if(lb_list.ToLower() == "all")
                {
                    ResetTitleLeaderboards(statsDB, nTitleID);
                    CTitleMgrApp.WriteLine("Resetting all leaderboards for " + titleid);
                }
                else
                {
                    Hashtable leaderBoards = CTitleMgrApp.GetLeaderboardList(statsDB, nTitleID.ToString());

                    string [] lbArray = lb_list.Split(';');

                    foreach(string lb in lbArray)
                    {
                        if(!leaderBoards.ContainsKey(Int32.Parse(lb)))
                        {
                            CTitleMgrApp.WriteLine("Leaderboard " + lb + " not found in the database.");
                            continue;
                        }

                        int nLB = Int32.Parse(lb);

                        CTitleMgrApp.WriteLine("Resetting leaderboard " + lb + " for title " + titleid + ".");
                        ResetTitleLeaderboard(statsDB, nTitleID, nLB);
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }

        }

        private static int ResetTitleLeaderboards(string statsDB, int nTitleID)
        {
            return CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetTitle " + nTitleID.ToString());
        }

        private static int ResetTitleLeaderboard(string statsDB, int nTitleID, int nLB)
        {
            return CTitleMgrApp.RunSqlCommand(statsDB, "xstats", "exec p_Stats_ResetLeaderBoard " + nTitleID.ToString() + ", " + nLB.ToString() + ", null");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\cservices.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr
{
    public struct STriplet
    {
        //called a triplet because it used to work by region too
        public int site;
        public int version;
    };

    public struct SService
    {
        /*
            MACHINE_ONLY=[TRUE|FALSE]
            SERVICE_DESCRIPTION=<At most 30 characters describing the service>
            SERVICE_NAME=Name of service
            SITES=<semi-colon separated list of site ids>
            VERSIONS=<semi-colon separated list of title versions>
            OFFERIDS=<semi-colon separated list of hexadecimal offering ids for associated subscription>
        */

        public string id;
        public int fake_titleid;
        public int machine_only; //MACHINE_ONLY=[TRUE|FALSE]
        public string service_description; //<At most 30 characters describing the service>
        public string service_name;
        public STriplet [] triplet;
        public int port;
        public string [] sites;
        public string [] offerids; //semi-colon separated list of hexadecimal offering ids for associated subscription
    };

    public struct SInterface
    {
        public string id;
        public string ip;
        public int port;
    };

    public struct SServer
    {
        /*
            [SERVER.<ID>]
            SERVICEIDS=<serviceId1>;<serviceId2>;;<serviceIdN>
            ADDRESS_<interfaceid1>=<ipAddress>:<port>
            ADDRESS_<interfaceid2>=<ipAddress>:<port>
        */

        public int id;
        public SService [] services; //this will contain the serviceID
        public SInterface [] interfaces;
        public int numinterfaces;
        public string site;
        public string protocol;
    };


    /*
        First populate UODB
            Place all services in t_services
            Place all triplets of (sites, version) and each port in a corresponding server in t_service_instances
            Place all offers in t_offer_services

        Now send info to SG via CMgmtCommand (looks like below)
            ; ----------------------------------------------------------------------------------------
            ; Services
            ;
            ; This section specifies the Id and Name of each service that any of the servers
            ; behind the gateway provide.  There is a maximum of 32 services that can be specified.
            ; Note that only those services which are referenced by the Servers section need be
            ; listed here.
            ; ----------------------------------------------------------------------------------------

            Service
            {
                Id                  0x5345000C                        ; Id of the service
                Name                PSO_GAME_SERVER                   ; Name of the service
            }



            ; ----------------------------------------------------------------------------------------
            ; Servers
            ;
            ; Each server in the datacenter is assigned an Id that the client uses as the destination
            ; port to address UDP or TCP packets.  This port is used to route the packet to the
            ; given server on the datacenter.  Note that each server must have a unique Ip/Port pair.
            ; That is, it is illegal for two server records to point to the same Ip/Port.  It is
            ; acceptable, however, to have two server records point to the same Ip on different Ports.
            ; ----------------------------------------------------------------------------------------

            Server
            {
                Id                  9001                          ; The Id of this server (dest port to client)
                Service             PSO_GAME_SERVER               ; Service this server provides
                Address { InterfaceId 1 Ip 10.12.0.34 Port 9001 } ; Address for Interface 1
            }

            Server
            {
                Id                  9002                          ; The Id of this server (dest port to client)
                Service             PSO_GAME_SERVER               ; Service this server provides
                Address { InterfaceId 1 Ip 10.12.0.34 Port 9002 } ; Address for Interface 1
            }

    */
    /// <summary>
    ///
    /// </summary>
    public class CServices
    {
        public static void Exec(string titleid)
        {
            try
            {
                ArrayList services = new ArrayList();
                ArrayList servers = new ArrayList();

                int i; //my counter

                int nTitleId = Int32.Parse(titleid, NumberStyles.HexNumber);

                //
                //  Do we have any work to do?
                //

                string configDir = Environment.CurrentDirectory + "\\" + titleid + "\\config\\";
                string serviceIdIniPath = configDir + "serviceid.ini";

                if(!File.Exists(serviceIdIniPath))
                {
                    CTitleMgrApp.WriteLineV("No serviceid.ini file found for this title.  Skipping installation of title-specific services.");
                    return;
                }

                //
                //  Get drive and path location for sg.ini file on sg's.
                //  Do this before we do anything else to verify we have the
                //  correct config.
                //

                string rootpath = CTitleMgrApp.Servers.GetSetting("SERVERS", "SGCFG");
                if (rootpath.Length == 0)
                    throw new Exception("You need to set SGCFG in servers.ini.");
                if (rootpath.IndexOf(':') == -1)
                    throw new Exception("SGCFG setting must be in the form <drive>:<path>.");
                if (rootpath.IndexOf(':') != 1)
                    throw new Exception("Drive specified in SGCFG must be exactly one character.");

                // split drive and path
                string drive = rootpath.Substring(0, 1);
                rootpath = rootpath.Substring(2);

                //
                //  Load serviceid.ini file
                //

                CTitleMgrApp.WriteLineV("Opening serviceid.ini for titleid: " + titleid);
                Ini serviceIdIni = new Ini(serviceIdIniPath);
                Hashtable serviceIds = serviceIdIni.Sections;

                //
                //  Find all the services, add them to the array
                //

                CTitleMgrApp.WriteLineV("Reading SERVICE sections from serviceid.ini");
                foreach(DictionaryEntry section in serviceIds)
                {
                    //
                    //  Get section and derive service id from it
                    //

                    string sectionName = section.Key.ToString();

                    if (sectionName.ToUpper().IndexOf("SERVICE") >= 0)
                    {
                        SService s = new SService();


                        CTitleMgrApp.WriteLineV("Examining section: " + sectionName);
                        s.id = sectionName.Split('.')[1];

                        CTitleMgrApp.WriteLineV("Service ID is '"
                            + s.id
                            + "'");
                        string machine = serviceIdIni.GetSetting(sectionName, "MACHINE_ONLY");

                        if (machine == "TRUE")
                        {
                            s.machine_only = 1;
                        }
                        else
                        {
                            s.machine_only = 0;
                        }
                        CTitleMgrApp.WriteLineV("machine only is '"
                            + s.machine_only
                            + "'");

                        s.service_description = serviceIdIni.GetSetting(sectionName, "SERVICE_DESCRIPTION");
                        CTitleMgrApp.WriteLineV("service description is '"
                            + s.service_description
                            + "'");

                        s.service_name = serviceIdIni.GetSetting(sectionName, "SERVICE_NAME");
                        CTitleMgrApp.WriteLineV("service name is '"
                            + s.service_name
                            + "'");

                        string [] sites;
                        string [] versions;

                        sites = serviceIdIni.GetSetting(sectionName, "SITES").Split(';');
                        versions = serviceIdIni.GetSetting(sectionName, "VERSIONS").Split(';');

                        if (sites.Length != versions.Length)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                + titleid
                                + "' in section '"
                                + sectionName
                                + "'. The SITES setting has "
                                + sites.Length
                                + " values and the VERSIONS setting has "
                                + versions.Length
                                + "values. They must have the same number of values.");
                            return;
                        }

                        s.triplet = new STriplet[sites.Length];

                        for (i = 0; i < sites.Length; i++)
                        {
                            s.triplet[i].site = Int32.Parse(sites[i]);
                            s.triplet[i].version = Int32.Parse(versions[i]);
                            CTitleMgrApp.WriteLineV("site '"
                                + s.triplet[i].site
                                + "' is configured to use version '"
                                + s.triplet[i].version
                                + "'");
                        }

                        string strPort = serviceIdIni.GetSetting(sectionName, "PORT");

                        if (strPort == null || strPort.Length == 0)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                + titleid
                                + "' in section '"
                                + sectionName
                                + "'. The PORT setting is either missing or has no value");
                            return;
                        }

                        s.port = Int32.Parse(strPort);

                        if (s.port == 0)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                + titleid
                                + "' in section '"
                                + sectionName
                                + "'. The PORT setting cannot equal zero");
                            return;
                        }

                        CTitleMgrApp.WriteLineV("port is '"
                            + s.port
                            + "'");

                        string strSite = serviceIdIni.GetSetting(sectionName, "SITES");

                        if (strSite.Length == 0)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                + titleid
                                + "' in section '"
                                + sectionName
                                + "'. The SITES setting is either missing or has no value");
                            return;
                        }
                        else
                        {
                            s.sites = strSite.Split(';');
                        }

                        string offerids = serviceIdIni.GetSetting(sectionName, "OFFERIDS");

                        if (offerids != null && offerids.Length > 0)
                        {
                            // strip any leading "0x" or "0X"
                            string [] rgsOfferIds = offerids.Split(';');
                            for (i = 0; i < rgsOfferIds.Length; ++i)
                            {
                                rgsOfferIds[i] = rgsOfferIds[i].Trim().ToUpper();
                                if (rgsOfferIds[i].Length > 2 && rgsOfferIds[i].Substring(0, 2) == "0X")
                                {
                                    rgsOfferIds[i] = rgsOfferIds[i].Substring(2);
                                }
                            }
                            s.offerids = rgsOfferIds;
                        }
                        else
                        {
                            s.offerids = new string[0];
                        }
                        foreach (string offerid in s.offerids)
                        {
                            CTitleMgrApp.WriteLineV("found offerid '"
                                + offerid
                                + "'");
                        }

                        // default to the titleid we were called for
                        s.fake_titleid = Int32.Parse(titleid, NumberStyles.HexNumber);

                        // if there's a valid TITLEID setting, then override the default
                        string sTitleIdSetting = serviceIdIni.GetSetting(sectionName, "TITLEID").Trim().ToUpper();
                        if (sTitleIdSetting.Length > 0)
                        {
                            // strip any leading "0x" or "0X"
                            if (sTitleIdSetting.Length > 2 && sTitleIdSetting.Substring(0, 2) == "0X")
                            {
                                sTitleIdSetting = sTitleIdSetting.Substring(2);
                            }
                            s.fake_titleid = Int32.Parse(sTitleIdSetting, NumberStyles.HexNumber);
                        }
                        CTitleMgrApp.WriteLineV("title id is '"
                            + s.fake_titleid
                            + "'");

                        services.Add(s);
                    } //created the service
                }
                CTitleMgrApp.WriteLineV("Finished parsing SERVICE sections");

                //
                //  Now, find all the servers, add them to the array
                //
                serviceIds = serviceIdIni.Sections;

                CTitleMgrApp.WriteLineV("Reading SERVER sections from serviceid.ini");
                foreach(DictionaryEntry section in serviceIds)
                {
                    //
                    //  Get section and derive server id from it
                    //

                    string sectionName = section.Key.ToString();

                    SServer s = new SServer();

                    if (sectionName.ToUpper().IndexOf("SERVER") >= 0)
                    {
                        //get the id (part of the section name)
                        CTitleMgrApp.WriteLineV("Reading SERVER section: " + sectionName);

                        s.id = Int32.Parse(sectionName.Split('.')[1]);

                        //there is a list of service ids - find the service they are, and assign them
                        string [] serviceids = serviceIdIni.GetSetting(sectionName, "SERVICEIDS").Split(';');

                        s.services = new SService[serviceids.Length];

                        for (int j = 0; j < serviceids.Length; j++)
                        {
                            for (i = 0; i < services.Count; i++)
                            {
                                if (((SService)services[i]).id == serviceids[j])
                                {
                                    CTitleMgrApp.WriteLineV("Assigning serviceid '"
                                        + ((SService)services[i]).id
                                        + "' to server id '"
                                        + s.id
                                        + "'");
                                    s.services[j] = (SService)services[i];
                                    break;
                                }
                            }

                            if (i == services.Count)
                            {
                                CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                    + titleid
                                    + "' in section '"
                                    + sectionName
                                    + "'. No Services found for Server ID '"
                                    + s.id
                                    + "'");
                                return;
                            }
                        }

                        StringDictionary settings = serviceIdIni.GetSection(sectionName);

                        string site = serviceIdIni.GetSetting(sectionName, "SITE").Trim();
                        if (site.Length == 0)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Error found in serviceid.ini for title '"
                                + titleid
                                + "' in section '"
                                + sectionName
                                + "'. No SITE setting found in SERVER section. All SERVER sections require a SITE setting");
                            return;
                        }

                        s.site = site;
                        CTitleMgrApp.WriteLineV("Server id '"
                            + s.id
                            + "' is in site '"
                            + s.site
                            + "'");

                        string protocol = serviceIdIni.GetSetting(sectionName, "PROTOCOL").Trim();
                        CTitleMgrApp.WriteLineV("Server id '"
                            + s.id
                            + "' is using protocol '"
                            + s.protocol
                            + "'");
                        s.protocol = protocol;

                        s.interfaces = new SInterface[settings.Count]; //subtract 1 for the SERVICEIDS
                        int icount = 0;

                        foreach(DictionaryEntry setting in settings)
                        {
                            //find all those that start with interface_<id> - and map them to the interfaces
                            string settingName = setting.Key.ToString();

                            if (settingName.ToLower().IndexOf("address") < 0)
                                continue;

                            string iface = serviceIdIni.GetSetting(sectionName, settingName);

                            SInterface face = new SInterface();

                            //id is part of setting name
                            face.id = settingName.Split('_')[1];

                            string [] ip_port = iface.Split(':');

                            //this are the value (ip:port)
                            face.ip = ip_port[0];
                            face.port = Int32.Parse(ip_port[1]);

                            CTitleMgrApp.WriteLineV("Adding interface '"
                                + face.id
                                + "' to server id '"
                                + s.id
                                + "with address '"
                                + face.ip + ":" + face.port
                                + "'");
                            s.interfaces[icount++] = face;
                        }
                        s.numinterfaces = icount;

                        servers.Add(s);

                    } //created the server

                }
                CTitleMgrApp.WriteLineV("Finished parsing SERVER sections");

                //we have now populated the services, and the servers arraylists
                //should be easy to populate uodb now...

                //need to run the following 3 commands
                /*
                   insert into t_services (i_service_id, vc_kerb_service_name, vc_kerb_domain_name, vc_description, i_machine_only)
                                    values (0x5345000C  , N'sg', N'Sx5345000C'  , N'Phantasy Star Online'        , 0)

                    insert into t_service_instances (i_service_id, i_title_id, i_title_version, i_title_region, i_site_id, i_port, i_service_available)
                                    values (0x5345000C, 0x5345000C, 0, 0, 1, 9001, 1)

                    insert into t_offer_services (bi_offer_id, i_service_id)
                                    values (0xFFFE000080000001, 0x5345000C)
                */



                CTitleMgrApp.WriteLineV("Updating UODB with service information from serviceid.ini for title '"
                    + titleid
                    + "'");
                for(i = 0; i < services.Count; i++)
                {
                    //insert into t_services
                    SService s = (SService)services[i];

                    int sid = Int32.Parse(s.id);
                    uint usid = (uint)sid;


                    InsertTServices(Int32.Parse(s.id), "sg", "S" + usid.ToString(), s.service_description, s.machine_only);

                    //foreach triplet insert it into service_instances, along with the default port
                    foreach (STriplet t in s.triplet)
                    {
                        //insert the triplet (now doublet) into the service_instances table
                        InsertTServiceInstances(Int32.Parse(s.id), s.fake_titleid,
                            t.version, t.site,
                            s.port, 1);

                    } //each triplet

                    //insert each offer the service has
                    foreach (string offer in s.offerids)
                    {
                        string strOffer = offer;

                        if (offer.Length > 2 && offer.IndexOf("0x") >= 0)
                            strOffer = offer.Substring(2);

                        InsertTOfferServices(Int64.Parse(strOffer, NumberStyles.HexNumber), Int32.Parse(s.id));

                    } //each offer
                }
                CTitleMgrApp.WriteLineV("Finished Updating UODB with service information from serviceid.ini for title '"
                    + titleid
                    + "'");

                //
                // now that uodb has been updated, we can create the big string to send to the sgs
                //

                CTitleMgrApp.WriteLineV("Generating Security Gateway configuration files for title '"
                    + titleid
                    + "'");

                int numSites = 0;
                Hashtable hashSites = CTitleMgrApp.Servers.Sections;
                foreach(DictionaryEntry entry in hashSites)
                {
                    if (entry.Key.ToString().ToUpper().IndexOf("SITE") == 0)
                    {
                        string [] parts = entry.Key.ToString().Split('.');
                        if (parts.Length == 2)
                        {
                            if (numSites < Int32.Parse(parts[1]))
                                numSites = Int32.Parse(parts[1]);
                        }
                    }
                }

                CTitleMgrApp.WriteLineV("This cluster has "
                    + numSites
                    + " site(s) configured in servers.cfg");

                string []rSiteInis = new string[numSites + 1];

                for (i = 0; i < rSiteInis.Length; i++)
                    rSiteInis[i] = "";

                for (i = 0; i < services.Count; i++)
                {
                    string sgcom = "";

                    //add the following to sgcom
                    /*
                        Service
                        {
                            Id                  0x5345000C                        ; Id of the service
                            Name                PSO_GAME_SERVER                   ; Name of the service
                        }
                    */

                    SService s = (SService)services[i];

                    sgcom = "Service\r\n";
                    sgcom += "{\r\n";
                    sgcom += "    Id\t\t\t0x" + Int32.Parse(s.id).ToString("x") + "\r\n"; //the want hex
                    sgcom += "    Name\t\t" + s.service_name + "\r\n";
                    sgcom += "}\r\n\r\n";

                    CTitleMgrApp.WriteLineV("Generating Security Gateway config entry for service id '"
                        + s.id
                        + "' (or '"
                        + Int32.Parse(s.id).ToString("x")
                        + "' in hex) service name '"
                        + s.service_name
                        + "'");

                    ArrayList rAddedSites = new ArrayList();
                    foreach(string site in s.sites)
                    {
                        int iSite = Int32.Parse(site);
                        if (rAddedSites.Contains(iSite))
                        {
                            continue;
                        }

                        if (iSite >= rSiteInis.Length)
                        {
                            // The WriteLine code looks for "FAIL" in the message to decide if a
                            // message is worthy of adding to the event log. So this message says FAIL
                            // even though we continue processing after, because this should go in the
                            // event log. We want to continue processing, since we've already comitted
                            // changes to UODB, and so we should do the best job we can to configure
                            // the SGs.
                            CTitleMgrApp.WriteLine("FAIL: Error Generating Security Gateway configuration files for title '"
                                + titleid
                                + "'. A site number provided for service '"
                                + s.id
                                + "' in serviceid.ini was larger than the highest site number in servers.cfg. "
                                + "This service entry in serviceid.ini will not be included in the security gateway configuration files.");
                            continue;
                        }

                        rAddedSites.Add(iSite);
                        CTitleMgrApp.WriteLineV("Adding generated config entry to site '"
                            + site
                            + "'");
                        rSiteInis[iSite] += sgcom;
                        /*
                         * Just care about site number, not SGs
                        string strSGList = CTitleMgrApp.Servers.GetSetting("SITE." + site, "SG");

                        if (strSGList.Length == 0)
                        {
                            CTitleMgrApp.WriteLine("FAIL: Serviceid.ini - no SGs in site " + site);
                            return;
                        }

                        string [] sgs = strSGList.Split(';');

                        for (int w = 0; sgs != null && w < sgs.Length; w++)
                        {
                            if (sgs[w] == null || sgs[w].Length == 0)
                                continue;
                            string output = CMgmtCommand.RunCommand(sgs[w], "e sgsvc configure_string " + sgcom);
                            CTitleMgrApp.WriteLineV("Finished configuring: " + sgs[w].ToString());
                            CTitleMgrApp.WriteLineV("out: " + output);
                        }
                        */
                    }
                } //each service

                for (i = 0; i < servers.Count; i++)
                {
                    //add the folling to sgcom
                    /*
                        Server
                        {
                            Id                  9001                          ; The Id of this server (dest port to client)
                            Service             PSO_GAME_SERVER               ; Service this server provides
                            Address { InterfaceId 1 Ip 10.12.0.34 Port 9001 } ; Address for Interface 1
                        }
                    */

                    SServer s = (SServer)servers[i];

                    if (Int32.Parse(s.site) >= rSiteInis.Length)
                    {
                        // The WriteLine code looks for "FAIL" in the message to decide if a
                        // message is worthy of adding to the event log. So this message says FAIL
                        // even though we continue processing after, because this should go in the
                        // event log. We want to continue processing, since we've already comitted
                        // changes to UODB, and so we should do the best job we can to configure
                        // the SGs.
                        CTitleMgrApp.WriteLine("FAIL: Error Generating Security Gateway configuration files for title '"
                            + titleid
                            + "'. The site number provided for server '"
                            + s.id
                            + "' in serviceid.ini was larger than the highest site number in servers.cfg. "
                            + "This server entry in serviceid.ini will not be included in the security gateway configuration files.");
                        continue;
                    }

                    CTitleMgrApp.WriteLineV("Generating Security Gateway config entry for server id '"
                        + s.id
                        + "'");

                    string sgcom = "Server\r\n";
                    sgcom += "{\r\n";
                    sgcom += "    Id\t\t\t" + s.id.ToString() + "\r\n";


                    int j;
                    for (j = 0; j < s.services.Length; j++)
                    {
                        CTitleMgrApp.WriteLineV("Adding service '"
                            + s.services[j].service_name
                            + "' to server id '"
                            + s.id
                            + "'");
                        sgcom += "    Service\t\t" + s.services[j].service_name + "\r\n";
                    }

                    if (s.protocol.Length > 0)
                    {
                        CTitleMgrApp.WriteLineV("Adding protocol '"
                            + s.protocol
                            + "' to server id '"
                            + s.id
                            + "'");
                        sgcom += "    Protocol\t\t" + s.protocol + "\r\n";
                    }

                    for (j = 0; j < s.numinterfaces; j++)
                    {
                        CTitleMgrApp.WriteLineV("Adding interface with ip '"
                            + s.interfaces[j].ip
                            + "' and port '"
                            + s.interfaces[j].port
                            + "' to server id '"
                            + s.id
                            + "'");
                        sgcom += "    Address { InterfaceID " + s.interfaces[j].id +
                                " Ip " + s.interfaces[j].ip +
                                " Port " + s.interfaces[j].port.ToString() +
                                " }\r\n";
                    }

                    sgcom += "}\r\n\r\n";

                    CTitleMgrApp.WriteLineV("Adding server entry to security gateway configuration for site '"
                        + s.site
                        + "'");
                    rSiteInis[Int32.Parse(s.site)] += sgcom;
                }

                for (i = 0; i < rSiteInis.Length; i++)
                {
                    string site = i.ToString();
                    string sgcom = rSiteInis[i];
                    if (sgcom.Length == 0)
                    {
                        // we now have site 9999 in some environments due to
                        // nat type detection service, so this line was being generated
                        // nearly 10,000 times instead of once or twice. Therefore we're
                        // removing the log line. A real fix to make this efficient can wait
                        // until we rewrite this stuff for LSP
                        /*
                        CTitleMgrApp.WriteLineV("Note: site '"
                            + i
                            + "' has no security gateway configuration for this serviceid.ini");
                        */
                        continue;
                    }

                    string strSGList = CTitleMgrApp.Servers.GetSetting("SITE." + site, "SG");

                    if (strSGList.Length == 0)
                    {
                        CTitleMgrApp.WriteLine("FAIL: Unable to send security gateway configuration to site '"
                            + site
                            + "' because there is no 'SG' setting in section 'SITE."
                            + site
                            + "' in servers.ini - continuing to next SITE");
                        continue;
                    }

                    string [] sgList = strSGList.Split(';');

                    foreach(string sg in sgList)
                    {
                        //write the sg.ini file to each SG in that site
                        //then run configure_file on that site

                        if (!rootpath.EndsWith("\\"))
                            rootpath += "\\";
                        string remoteDir = "\\\\" + sg + "\\" + drive + "$" + rootpath;
                        string remotePath = remoteDir + "sg-" + titleid + ".ini";
                        string path = rootpath + "sg-" + titleid + ".ini";
                        //string remotePath = "\\\\" + sg + "\\" + drive + "$" + path;
                        string localPath = drive + ":" + path;
                        CTitleMgrApp.WriteLineV("Sending security gateway configuration file to '"
                            + remotePath
                            + "'");

                        // check to make sure the directory exists. We don't want this to
                        // throw an exception because the "fake" sg that does nat type
                        // doesn't have any sg.ini config directories. Just mention the
                        // error and continue.
                        if (Directory.Exists(remoteDir))
                        {
                            StreamWriter writer = new StreamWriter(remotePath);
                            writer.Write(sgcom);
                            writer.Close();

                            string sMgmtCommand = "e :sg configure_file " + localPath + "\r\n";
                            CTitleMgrApp.WriteLineV("Sending management command '"
                                + sMgmtCommand
                                + "' to '"
                                + sg
                                + "'");
                            string output = CMgmtCommand.Exec(sg, sMgmtCommand);
                        }
                        else
                        {
                            CTitleMgrApp.WriteLineV("Error: directory '"
                                + remoteDir
                                + "' does not exist. Skipping send.");
                        }

                    }
                    CTitleMgrApp.WriteLineV("Finished sending security gateway configuration files for SITE '"
                        + site
                        + "'");
                }

                CTitleMgrApp.WriteLineV("Finished sending security gateway configuration files for all SITEs");

                /*
                CSourceDepot sd = new CSourceDepot();

                //see if sgtmp.ini = sg.ini
                if (!File.Exists(configDir + "sg.ini"))
                {
                    File.Copy(configDir + "sgtmp.ini", configDir + "sg.ini", false);
                    sd.Add(configDir + "sg.ini");
                    sd.Submit(configDir + "sg.ini", "added sg.ini addon");
                    CTitleMgrApp.WriteLine("NOTICE: " + configDir + "sg.ini has been created.");
                    CTitleMgrApp.WriteLine("NOTICE: Please let an ops engineer know that ");
                    CTitleMgrApp.WriteLine("NOTICE: they have to copy and paste sg.ini onto all SGs");
                }
                else
                {
                    StreamReader local = new StreamReader(configDir + "sgtmp.ini");
                    StreamReader remote = new StreamReader(configDir + "sg.ini");

                    string sLocal = local.ReadToEnd();
                    string sRemote = remote.ReadToEnd();

                    local.Close();
                    remote.Close();

                    if (sLocal != sRemote)
                    {
                        sd.Edit(configDir + "sg.ini");
                        File.Copy(configDir + "sgtmp.ini", configDir + "sg.ini", true);
                        sd.Submit(configDir + "sg.ini", "updated sg.ini addon");
                        CTitleMgrApp.WriteLine("NOTICE: " + configDir + "sg.ini has been updated.");
                        CTitleMgrApp.WriteLine("NOTICE: Please let an ops engineer know that ");
                        CTitleMgrApp.WriteLine("NOTICE: they have to copy and paste sg.ini onto all SGs");
                        CTitleMgrApp.WriteLine("NOTICE: Make sure they overwrite the old data for " + titleid);
                    }
                }

                File.Delete(configDir + "sgtmp.ini");

                */
                //now we have to reload the xkdcs
                CPropUtils.UpdateXKDCCache();

                CTitleMgrApp.WriteLine("Finished serviceid.ini processing: Success");
            }
            catch (Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }



        } //Exec

        private static void InsertTServices(int id, string name, string domain, string desc, int machine_only)
        {
            CTitleMgrApp.WriteLineV("Calling p_askdc_set_service to add service to t_services with id: "
                + id
                + " name: "
                + name
                + " domain: "
                + domain
                + " desc: "
                + desc
                + " machine_only: "
                + machine_only);

            /*
                    @i_service_id      int
                    ,@i_machine_only    int
                    ,@vc_description    nvarchar(30)
                    ,@vc_service_name   nvarchar(30)
            */

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    ws.PhysicalPartition = i;
                    ws.StoredProc = "dbo.p_askdc_set_service";

                    ws.AddParameter(ParamType.INPUT, "@i_service_id", id);
                    ws.AddParameter(ParamType.INPUT, "@i_machine_only", machine_only);
                    ws.AddParameter(ParamType.INPUT, "@vc_description", desc, desc.Length);
                    ws.AddParameter(ParamType.INPUT, "@vc_service_name", domain, domain.Length);

                    try
                    {
                        ws.ExecuteNonQuery();
                    }
                    catch(Exception e)
                    {
                        CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    }

                    ws.Close();
                }
            }
        }

        private static void InsertTOfferServices(long offerid, int service_id)
        {
            CTitleMgrApp.WriteLineV("Calling p_askdc_set_offer_services to associate the serviceid '"
                + service_id
                + "' with offerid '"
                + offerid
                + "' in t_offer_services");

            /*
                  @bi_offer_id       bigint
                  ,@i_service_id      int
            */

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    ws.PhysicalPartition = i;
                    ws.StoredProc = "dbo.p_askdc_set_offer_services";

                    ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerid);
                    ws.AddParameter(ParamType.INPUT, "@i_service_id", service_id);

                    try
                    {
                        ws.ExecuteNonQuery();
                    }
                    catch(Exception e)
                    {
                        CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    }

                    ws.Close();
                }
            }
        }

        private static void InsertTServiceInstances(int service_id, int fake_titleid, int version, int site,
            int port, int online)
        {
            CTitleMgrApp.WriteLineV(
                "Calling p_askdc_set_service_instance to create an service instance in t_service_instances with service_id '"
                + service_id
                + "', titleid '"
                + fake_titleid
                + "', version '"
                + version
                + "' and site '"
                + site
                + "'");

            /*
                 @i_service_id      int
                ,@i_title_id        int
                ,@i_site_id         int
                ,@i_title_version   int
                ,@i_port            int
            */

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    ws.PhysicalPartition = i;
                    ws.StoredProc = "dbo.p_askdc_set_service_instance";

                    ws.AddParameter(ParamType.INPUT, "@i_service_id", service_id);
                    ws.AddParameter(ParamType.INPUT, "@i_title_id", fake_titleid);
                    ws.AddParameter(ParamType.INPUT, "@i_site_id", site);
                    ws.AddParameter(ParamType.INPUT, "@i_title_version", version);
                    ws.AddParameter(ParamType.INPUT, "@i_port", port);


                    try
                    {
                        ws.ExecuteNonQuery();
                    }
                    catch(Exception e)
                    {
                        CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                    }

                    ws.Close();
                }
            }
        }

        public static void AddServiceIdIniToRepository(string sTitleId, string sServiceIdIniPath)
        {
            // After all the validitiy checks, if this is still false, then we'll try to check the
            // file into the respository.
            bool bError = false;

            // One of the validity checks is to make sure there is at least one "SERVICE" section
            // in the file.
            bool bAtLeastOneServiceSection = false;

            // First, can we even find the file?
            if (!File.Exists(sServiceIdIniPath))
            {
                CTitleMgrApp.WriteLine("FAIL: couldn't find serviceid.ini file at path '"
                    + sServiceIdIniPath
                    + "'");
                return;
            }

            CTitleMgrApp.WriteLine("Examining serviceid ini file '"
                + sServiceIdIniPath
                + "'...");
            Ini iniServiceId = new Ini(sServiceIdIniPath);

            // iterate through each of the sections and check them for errors
            Hashtable htServiceIds = iniServiceId.Sections;
            if (htServiceIds != null)
            {
                foreach(DictionaryEntry deSection in htServiceIds)
                {
                    //  Get the section name
                    string sSectionName = deSection.Key.ToString();
                    CTitleMgrApp.WriteLineV("Examining Section '"
                        + sSectionName
                        + "'");

                    // is this a SERVICE section?
                    if (sSectionName.ToUpper().IndexOf("SERVICE") >= 0)
                    {
                        bAtLeastOneServiceSection = true;
                        if (ExamineServiceSection(iniServiceId, sSectionName))
                        {
                            bError = true;
                        }
                    }
                    // is this a SERVER section?
                    else if (sSectionName.ToUpper().IndexOf("SERVER") >= 0)
                    {
                        if (ExamineServerSection(iniServiceId, sSectionName))
                        {
                            bError = true;
                        }
                    }
                    else
                    {
                        // This is an unexpected section type. It will be ignored, so we won't cause an
                        // error, but we will issue a warning.
                        CTitleMgrApp.WriteLine("Warning: Unknown section type '"
                            + sSectionName
                            + "' encountered in ini file '"
                            + sServiceIdIniPath
                            + "'");
                    }
                }
            }

            if (bAtLeastOneServiceSection == false)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: No SERVICE sections found in '"
                    + sServiceIdIniPath
                    + "'");
            }

            if (bError)
            {
                CTitleMgrApp.WriteLine("FAIL: Errors detected in file '"
                    + sServiceIdIniPath
                    + "'. File NOT added to title repository. Please correct the errors and retry the operation");
            }
            else
            {
                // no problems were found with the serviceid.ini file. check it into the
                // repository
                string sServiceIdIniRepositoryPath = Environment.CurrentDirectory
                    + "\\"
                    + sTitleId
                    + "\\config\\serviceid.ini";

                // is there already a copy of serviceid.ini in the repository?
                CSourceDepot sd = new CSourceDepot();
                string [] rgsFiles;
                CTitleMgrApp.WriteLineV("Checking for presense of '"
                    + sServiceIdIniRepositoryPath
                    + "' in title repository");
                sd.Files(sServiceIdIniRepositoryPath, out rgsFiles);

                if (rgsFiles.Length == 0)
                {
                    // the file does not exist in the repository, so copy the
                    // input file to the repository, then "sd add" it.
                    // Overwrite any existing, not checked in serviceid.ini
                    CTitleMgrApp.WriteLine("'"
                        + sServiceIdIniRepositoryPath
                        + "' not found in repository, adding");
                    File.Copy(sServiceIdIniPath, sServiceIdIniRepositoryPath, true);
                    sd.Add(sServiceIdIniRepositoryPath);
                    sd.Submit(sServiceIdIniRepositoryPath,
                        "Titlemgr: adding new serviceid.ini to repository for titleid: "
                        + sTitleId);
                }
                else if (rgsFiles.Length == 1)
                {
                    // the file already exists in the repository, so "sd edit" it first,
                    // and then overwrite it.
                    CTitleMgrApp.WriteLine("'"
                        + sServiceIdIniRepositoryPath
                        + "' found in repository, updating");
                    sd.Edit(sServiceIdIniRepositoryPath);
                    File.Copy(sServiceIdIniPath, sServiceIdIniRepositoryPath, true);
                    sd.Submit(sServiceIdIniRepositoryPath,
                        "Titlemgr: updating serviceid.ini in repository for titleid: "
                        + sTitleId);
                }
                else
                {
                    // this should not happen - something not understood is happening
                    // here. Issue a failure message and get out.
                    CTitleMgrApp.WriteLine("FAIL: 'sd files' returned unexpected results when checking the status of '"
                        + sServiceIdIniRepositoryPath
                        + "' File NOT added to repository");
                }
            }
        }

        private static bool ExamineServiceSection(Ini iniServiceId, string sSectionName)
        {
            bool bError = false;

            // the service section should be formatted as SERVICE.1 or SERVICE.2
            // where '1' or '2' is the service ID. Try to extract a service id
            // from this service section name
            string [] rgsSectionNameSplit = sSectionName.Split('.');
            if (rgsSectionNameSplit.Length != 2)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: Invalid Service section name '"
                    + sSectionName
                    + "' service section names should be formatted as SERVICE.# where # is the service ID");
            }
            else
            {
                try
                {
                    // try to parse the stuff after the '.'
                    int i = Int32.Parse(rgsSectionNameSplit[1]);
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Invalid Service section name: " +
                        sSectionName + ", service section names should be formatted as SERVICE.# where # is the service ID");
                }
            }

            // There's no real need to check for the presense or validity of a MACHINE_ONLY setting since
            // it defaults to FALSE and any setting other than TRUE will be considered FALSE. However,
            // in the interest of keeping the repository ini files as clean as possible, we'll check
            // to see that any MACHINE_ONLY section is some case-insensitive version of "TRUE" or "FALSE"
            //
            // Note that GetSetting returns "" not null if there is no matching setting in the file
            // it also returns "" if the setting is 'SETTING=', so we can't tell those conditions apart
            CTitleMgrApp.WriteLineV("Checking for valid MACHINE_ONLY setting in section '"
                + sSectionName
                + "'");
            string sMachineOnly = iniServiceId.GetSetting(sSectionName, "MACHINE_ONLY");
            if (sMachineOnly.Length > 0)
            {
                if (sMachineOnly.ToUpper() != "TRUE" && sMachineOnly.ToUpper() != "FALSE")
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Invalid MACHINE_ONLY setting of '"
                        + sMachineOnly
                        + "' in section '"
                        + sSectionName
                        + "'");
                }
            }

            // make sure there is a SERVICE_DESCRIPTION setting
            CTitleMgrApp.WriteLineV("Checking for existence of SERVICE_DESCRIPTION setting in section '"
                + sSectionName
                + "'");
            string sServiceDescription = iniServiceId.GetSetting(sSectionName, "SERVICE_DESCRIPTION");
            if (sServiceDescription.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: SERVICE_DESCRIPTION setting is missing in section '"
                    + sSectionName
                    + "'");
            }

            // make sure there is a SERVICE_NAME setting
            CTitleMgrApp.WriteLineV("Checking for existence of SERVICE_NAME setting in section '"
                + sSectionName
                + "'");
            string sServiceName = iniServiceId.GetSetting(sSectionName, "SERVICE_NAME");
            if (sServiceName.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: SERVICE_NAME setting is missing in section '"
                    + sSectionName
                    + "'");
            }

            // check that there are SITES and VERSIONS specified, and that the number of
            // sites entries matches the number of versions entries
            CTitleMgrApp.WriteLineV("Checking for valid SITES and VERSIONS settings in section '"
                + sSectionName
                + "'");
            string [] rgsSites = iniServiceId.GetSetting(sSectionName, "SITES").Split(';');
            string [] rgsVersions = iniServiceId.GetSetting(sSectionName, "VERSIONS").Split(';');

            if (rgsSites.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: no SITES specified in section '"
                    + sSectionName
                    + "'");
            }
            if (rgsVersions.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: no VERSIONS specified in section '"
                    + sSectionName
                    + "'");
            }
            if (rgsSites.Length != rgsVersions.Length)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: number of SITES ("
                    + rgsSites.Length
                    + ") must match number of VERSIONS ("
                    + rgsVersions.Length
                    + ") in section '"
                    + sSectionName
                    + "'");
            }

            // check that the SITES can be parsed into Int32
            foreach (string sSite in rgsSites)
            {
                try
                {
                    Int32.Parse(sSite);
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Unable to parse SITE setting of '"
                        + sSite
                        + "' into integer in section '"
                        + sSectionName
                        + "'");
                }
            }

            // check that the VERSIONS can be parsed into Int32
            foreach (string sVersion in rgsVersions)
            {
                try
                {
                    Int32.Parse(sVersion);
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Unable to parse VERSIONS setting of '"
                        + sVersion
                        + "' into integer in section '"
                        + sSectionName
                        + "'");
                }
            }

            // check to ensure there is a PORT setting for this SERVICE
            CTitleMgrApp.WriteLineV("Checking for valid PORT setting in section '"
                + sSectionName
                + "'");
            string sPort = iniServiceId.GetSetting(sSectionName, "PORT");
            if (sPort.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: PORT setting is missing in section '"
                    + sSectionName
                    + "'");
            }
            else
            {
                // check to ensure we can parse the PORT into an Int32
                int iPort;
                try
                {
                    iPort = Int32.Parse(sPort);

                    // the port parsed, make sure it's not zero
                    if (iPort == 0)
                    {
                        bError = true;
                        CTitleMgrApp.WriteLine("Error: PORT setting cannot be zero in section '"
                            + sSectionName
                            + "'");
                    }
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Unable to parse PORT setting of '"
                        + sPort
                        + "' into integer in section '"
                        + sSectionName
                        + "'");
                }
            }

            // offerids are optional, but if they are there, make sure they
            // are valid. They should be 64bit hex numbers
            CTitleMgrApp.WriteLineV("Checking OFFERIDS setting, if present in section '"
                + sSectionName
                + "'");
            string [] rgsOfferIds = iniServiceId.GetSetting(sSectionName, "OFFERIDS").Split(';');
            if (rgsOfferIds[0] != "" || rgsOfferIds.Length > 1)
            {
                foreach (string sOfferId in rgsOfferIds)
                {
                    try
                    {
                        // strip leading "0x" or "0X"
                        string sOfferIdTrim = sOfferId.Trim().ToUpper();
                        if (sOfferIdTrim.Length > 2 && sOfferIdTrim.Substring(0, 2) == "0X")
                        {
                            sOfferIdTrim = sOfferIdTrim.Substring(2);
                        }
                        Int64.Parse(sOfferIdTrim, NumberStyles.HexNumber);
                    }
                    catch
                    {
                        bError = true;
                        CTitleMgrApp.WriteLine("Error: Unable to parse OFFERIDS value of '"
                            + sOfferId
                            + "' as a 64-bit Hex value in section '"
                            + sSectionName
                            + "'");
                    }
                }
            }

            // titleid is optional, but if it is there, it should parse properly
            CTitleMgrApp.WriteLineV("Checking TITLEID setting, if present in section '"
                + sSectionName
                + "'");
            string sTitleIdSetting = iniServiceId.GetSetting(sSectionName, "TITLEID");
            if (sTitleIdSetting.Length > 0)
            {
                try
                {
                    // strip leading "0x" or "0X"
                    string sTitleIdSettingTrim = sTitleIdSetting.Trim().ToUpper();
                    if (sTitleIdSettingTrim.Length > 2 && sTitleIdSettingTrim.Substring(0, 2) == "0X")
                    {
                        sTitleIdSettingTrim = sTitleIdSettingTrim.Substring(2);
                    }
                    Int32.Parse(sTitleIdSettingTrim, NumberStyles.HexNumber);
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Unable to parse TITLEID of '"
                        + sTitleIdSetting
                        + "' as 32 bit hex value in section '"
                        + sSectionName
                        + "'");
                }
            }

            return bError;
        }

        private static bool ExamineServerSection(Ini iniServiceId, string sSectionName)
        {
            bool bError = false;

            // the server section should be formatted as SERVER.1 or SERVER.2
            // where '1' or '2' is the server ID. Try to extract a server id
            // from this server section name
            string [] rgsSectionNameSplit = sSectionName.Split('.');
            if (rgsSectionNameSplit.Length != 2)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: Invalid Server section name '"
                    + sSectionName
                    + "' server section names should be formatted as SERVER.# where # is the server ID");
            }
            else
            {
                try
                {
                    Int32.Parse(rgsSectionNameSplit[1]);
                }
                catch
                {
                    CTitleMgrApp.WriteLine("Error: Invalid Server section name '"
                        + sSectionName
                        + "' server section names should be formatted as SERVER.# where # is the server ID");
                }
            }

            // get the SERVICEID list and make sure it parses
            CTitleMgrApp.WriteLineV("Checking SERVICEID setting in section '"
                + sSectionName
                + "'");
            string sServiceIds = iniServiceId.GetSetting(sSectionName, "SERVICEIDS");
            if (sServiceIds.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: SERVICEIDS must be specified in server section '"
                    + sSectionName
                    + "'");
            }
            else
            {
                string [] rgsServiceIds = sServiceIds.Split(';');
                foreach (string sServiceId in rgsServiceIds)
                {
                    try
                    {
                        Int32.Parse(sServiceId);

                        // the service ID parsed. now make sure that it is a service that
                        // is defined in this ini file somewhere.
                        if (iniServiceId.GetSection("SERVICE." + sServiceId.Trim()) ==  null)
                        {
                            // Can't find a matching service section
                            bError = true;
                            CTitleMgrApp.WriteLine("Error: SERVICEID '"
                                + sServiceId
                                + "' in server section '"
                                + sSectionName
                                + "' does not have a corresponding SERVICE section in this file");
                        }
                    }
                    catch
                    {
                        bError = true;
                        CTitleMgrApp.WriteLine("Error: Unable to parse SERVICEID of '"
                            + sServiceId
                            + "' as integer in server section '"
                            + sSectionName
                            + "'");
                    }
                } // foreach sServiceId
            }

            // check to make sure a SITE has been provided and we can parse it
            CTitleMgrApp.WriteLineV("Checking SITE setting in section '"
                + sSectionName
                + "'");
            string sSite = iniServiceId.GetSetting(sSectionName, "SITE");
            if (sSite.Length == 0)
            {
                bError = true;
                CTitleMgrApp.WriteLine("Error: SITE must be specified in server section '"
                    + sSectionName
                    + "'");
            }
            else
            {
                try
                {
                    Int32.Parse(sSite);
                }
                catch
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Unable to parse SITE of '"
                        + sSite
                        + "' as integer in section '"
                        + sSectionName
                        + "'");
                }
            }

            // the protocol setting should either be "VDP" or absent
            CTitleMgrApp.WriteLineV("Checking any PROTOCOL setting, if present in section '"
                + sSectionName
                + "'");
            string sProtocol = iniServiceId.GetSetting(sSectionName, "PROTOCOL");
            if (sProtocol.Length > 0)
            {
                if (sProtocol.Trim().ToUpper() != "VDP")
                {
                    bError = true;
                    CTitleMgrApp.WriteLine("Error: Invalid PROTOCOL of '"
                        + sProtocol
                        + "' specified in server section '"
                        + sSectionName
                        + " only the value of 'VDP' is allowed");
                }
            }

            // Look for any "ADDRESS_??" settings and validate them
            CTitleMgrApp.WriteLineV("Checking any ADDRESS_? settings, if present in section '"
                + sSectionName
                + "'");
            StringDictionary sdServerSection = iniServiceId.GetSection(sSectionName);
            foreach(DictionaryEntry deSetting in sdServerSection)
            {
                // is this an "ADDRESS" setting?
                string sSetting = ((string)deSetting.Key).ToUpper();
                if (sSetting.IndexOf("ADDRESS") >= 0)
                {
                    CTitleMgrApp.WriteLineV("Found ADDRESS setting named '"
                        + sSetting
                        + "' in section '"
                        + sSectionName
                        + "'");

                    // the interface ID should be after an _ in the setting name
                    if (sSetting.Split('_').Length != 2)
                    {
                        bError = true;
                        CTitleMgrApp.WriteLine("Error: Invalid Address setting name '"
                            + sSetting
                            + "' in server section '"
                            + sSectionName
                            + "'. Address setting should be formatted as ADDRESS_# where # is the interface ID");
                    }
                    else
                    {
                        // the interface ID after the '_' should be parsable
                        try
                        {
                            Int32.Parse(sSetting.Split('_')[1]);

                            // the setting itself should be of the form 1.2.3.4:5678
                            string sAddressAndPort = iniServiceId.GetSetting(sSectionName, sSetting);
                            try
                            {
                                string [] rgsAddressAndPort = sAddressAndPort.Split(':');
                                if (rgsAddressAndPort.Length != 2)
                                {
                                    throw new Exception();
                                }

                                // the first part should be 1.2.3.4
                                string [] rgsIP = rgsAddressAndPort[0].Split('.');
                                if (rgsIP.Length != 4)
                                {
                                    // try parsing out the address parts
                                    Int32.Parse(rgsIP[0]);
                                    Int32.Parse(rgsIP[1]);
                                    Int32.Parse(rgsIP[2]);
                                    Int32.Parse(rgsIP[3]);
                                }

                                // the second part should just be a parsable port
                                Int32.Parse(rgsAddressAndPort[1]);
                            }
                            catch
                            {
                                bError = true;
                                CTitleMgrApp.WriteLine("Error: Unable to parse IP:port from setting '"
                                    + sSetting
                                    + "' of value '"
                                    + sAddressAndPort
                                    + "' specified in server section '"
                                    + sSectionName);
                            }
                        }
                        catch
                        {
                            bError = true;
                            CTitleMgrApp.WriteLine("Error: Unable to parse Interface ID from address setting '"
                                + sSetting
                                + "' specified in server section '"
                                + sSectionName
                                + "' as an integer");
                        }
                    } // endif Length != 2
                } // endif Address setting
            } // end foreach sSetting in sdServerSection (to look for address sections)

            return bError;
        }

    } //class

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CSync.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;


using xonline.tools.framework;

namespace xonline.tools.titlemgr 
{
	/// <summary>
	/// Sync all information for one or more titles.  None of the files in the
	/// repository should get modified by this class.  This can be used to add
	/// new titles, or change a bunch of information in one command.
	/// </summary>
	public class CSync
	{
		public static void Exec(
            string titleid_list, 
            bool bReloadCache,
            string sSdPort,
            string sSdClient,
            CLog log)
		{
            string srcPath = Environment.CurrentDirectory;

            //
            //  Make sure the entire tree is sync'd.  If titleid == "all"
            //  we enumerate the directories to get the list of titles
            //  to sync.
            //

            CSourceDepot sd = null;

            try
            {
                sd = new CSourceDepot();

                sd.Sync(srcPath + "\\...");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("The following exception occured while syncing: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished();
                    sd = null;
                }
            }

            //
            //  Now get the list of title ids we are syncing.
            //
            Queue titleIDs = CTitleMgrApp.GetTitleList(titleid_list);
            
            //
            //  Now sync each title.
            //
            foreach(string titleid in titleIDs)
            {
                SyncTitle(titleid, 
                    bReloadCache,
                    sSdPort,
                    sSdClient,
                    log);
                if (CTitleMgrApp.Stop == true)
                {
                    break;
                }
            }
		}

        private static void SyncTitle(
            string titleid, 
            bool bReloadCache,
            string sSdPort,
            string sSdClient,
            CLog log)
        {
            if (!CDisable.Check(titleid))
                return;

            CTitleMgrApp.WriteLine("Syncing " + titleid + "...");

            int nTitleId = Int32.Parse(titleid, NumberStyles.HexNumber);

            try
            {
                ///
                /// 1.	Populate the t_titles and t_title_versions table in UODB for this title.
                /// 2.	Populate information in UODB for any content and/or autoupdate packages.
                /// 

				if (!Directory.Exists(Environment.CurrentDirectory + "\\" + titleid))
				{
					CTitleMgrApp.WriteLine("FAIL: The titleid: " + titleid + " does not exist in the repository.  You might have misspelled it.");
					return;
				}

                string versionIni = Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini";
                if(File.Exists(versionIni))
                    CPropUtils.Sync(titleid, bReloadCache);
                else
                {
                    CTitleMgrApp.WriteLine("FAIL: No versions.ini file found for this title.  Skipping entire sync operation.");
                    return;
                }

                ///
                /// 3.	Populate information in UODB for any services in serviceid.ini.
                /// 
              
                CServices.Exec(titleid);

                /// 4.	Populate a row in the t_match_titles table in matchdb for this title.
                /// 5.	Check out the matchmaking SQL file from the repository.
                /// 6.	Run xml2sql to regenerate the SQL file, and then check it back into the repository.
                /// 7.	Execute the SQL file against the matchmaking db.
                
                string xmsFile = Environment.CurrentDirectory + "\\" + titleid + "\\matchsp\\" + titleid + ".xms";
                if(File.Exists(xmsFile))
                    CNewXMS.Exec(titleid, xmsFile, false, sSdPort, sSdClient, log);
                else
                    CTitleMgrApp.WriteLineV("No " + titleid + ".xms found, skipping matchmaking sync.");

                /// sync statsdb
                // this is commented out until we have support for the 
                // new leaderboard server
                //CTitleMgrApp.DoSyncStats();

                /// sync webdb
                CTitleMgrApp.DoSyncWebDB();

                /// sync npdb
                CTitleMgrApp.DoSyncNPDB();

                /// sync querydb
                CTitleMgrApp.DoSyncQuery();

                /// sync uodb alternate title ids 
                CTitleMgrApp.DoSyncAlternateTitleIds();

                /// sync the lsp site and service information.
                CTitleMgrApp.DoSyncLSPSite();

                /// sync alertsdb title description
                CTitleMgrApp.DoSyncAlerts();

                /// sync game config
                CTitleMgrApp.DoSyncGameConfig();

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: Failed syncing " + titleid + " with the error: " + e.Message);
            }

            CTitleMgrApp.WriteLine("Sync: Success");
        }

		public static void Remove(string titleid_list)
		{
			string strRootPath = Environment.CurrentDirectory;

			if(titleid_list.ToLower() == "all")
			{
				RemoveTitles(strRootPath, true);
			}
			else
			{
				string [] strTitleIDs = titleid_list.Split(';');

				foreach(string strTitleID in strTitleIDs)
				{
					string strTitlePath = strRootPath + "\\" + strTitleID.ToLower();
					RemoveTitles(strTitlePath, true);
				}
			}
		}

		public static void RemoveTitles(string strTitlePath, bool bSubdir)
		{ 
			CSourceDepot sd = null;

			try
			{
				CPropUtils.VerifyExistsDir(strTitlePath);

				sd = new CSourceDepot();
				string strSufix = "\\*";

				if(true == bSubdir)
				{
					strSufix = "\\...";
				}

				sd.Delete(strTitlePath + strSufix);

				string [] files = null;

				sd.Opened(strTitlePath + strSufix, out files);

				if(files.Length > 0)
				{
					for(int nCurrentFile = 0; nCurrentFile < files.Length; ++nCurrentFile)
					{
						sd.Submit(files[nCurrentFile], "titlemgr: Remove " + strTitlePath );
					}

					try
					{
						sd.Submit(strTitlePath + "\\...", "All files");
					}
					catch(Exception)
					{
					}

					CTitleMgrApp.WriteLine("Successfully removed " + strTitlePath + " from repository!");
				}
				else
				{
					CTitleMgrApp.WriteLine("FAIL:" + strTitlePath + " : Invalid path or no files to delete!");
				}
				
			}
			catch(Exception e)
			{
				CTitleMgrApp.WriteLine("FAIL: " + e.Message);
			}
			finally
			{
				sd = null;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CUODBContent.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// Takes the .sql2 file generated by the RebuildContent tool and updates UODB
    /// </summary>
    class CUODBContent
    {
        static public void Exec(string strSQL2File)
        {
            StreamReader  sr = null;
            WSClient[] wsClients = null;
            int nWSClients = 0;
            bool bRollback = false;
            
            try
            {
                wsClients = CPropUtils.GetUODBWebstoreClients();
                nWSClients = wsClients.Length;

                sr = File.OpenText(strSQL2File);

                string strFileContent = sr.ReadToEnd();
                string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

                if(strStoredProcedures.Length < 4)
                {
                    throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
                }
                
                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].ClearParameters();
                    wsClients[k].PartitionType = WstPartitionType.Physical;
                    wsClients[k].Partition = k;
                    wsClients[k].BeginTransaction();
                }

                int hr = CPropUtils.HR_SUCCEEDED;      

                //
                // First stored proc checks for preexistent info in DB; may return error
                //
                for(int k = 0; (k < nWSClients) && (CPropUtils.HR_SUCCEEDED == hr); k++)
                {
                    ParseQueryString(wsClients[k], strStoredProcedures[1]);
                    wsClients[k].ExecuteNonQuery();
                    hr = wsClients[k].GetIntParameter("@RETVAL");
                }

                if(CPropUtils.HR_FAILED_NO_TITLE == hr)
                {
                    throw new ApplicationException("Inexistent titleID!");
                }

                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].CommitTransaction();
                    wsClients[k].ClearParameters();
                    wsClients[k].PartitionType = WstPartitionType.Physical;
                    wsClients[k].Partition = k;
                    wsClients[k].BeginTransaction();
                }
                

                //
                // Clean offer_regions first
                //
                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].StoredProc = "p_svc_delete_regions";
                    long lOfferID = Convert.ToInt64("0x" + Path.GetFileNameWithoutExtension(strSQL2File), 16);
                    wsClients[k].AddParameter("@bi_offer_id", lOfferID);

                    wsClients[k].ExecuteNonQuery();
                }

                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].CommitTransaction();
                }
                
                //
                // Execute all other stored procedures
                //
                for(int i = 2 ; i < strStoredProcedures.GetLength(0); i++)
                {

                    for(int k = 0; k < nWSClients; k++)
                    {
                        wsClients[k].ClearParameters();
                        wsClients[k].PartitionType = WstPartitionType.Physical;
                        wsClients[k].Partition = k;
                        wsClients[k].BeginTransaction();
                    }
                
                    for(int k = 0; k < nWSClients; k++)
                    {
                        ParseQueryString(wsClients[k], strStoredProcedures[i]);
                        wsClients[k].ExecuteNonQuery();
                    }

                    for(int k = 0; k < nWSClients; k++)
                    {
                        wsClients[k].CommitTransaction();
                    }
                
                }
                
                CTitleMgrApp.WriteLineV("Success!");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                bRollback = true;
            }
            finally
            {
                if(null != sr)
                {
                    sr.Close();
                }
            }

            if(bRollback)
            {
                if(null != wsClients)
                {
                    for(int k = 0; k < nWSClients; k++)
                    {
                        try
                        {
                            wsClients[k].RollbackTransaction();
                        }
                        catch(Exception)
                        {
                        }
                    }
                }
            }
        }


        /// <summary>
        /// ParseQueryString():
        /// Parses given query string and sets up the webstore client for the stored procedure call.
        /// </summary>
        private static void ParseQueryString(WSClient ws, string strStoredProc)
        {
            try
            {
                // Note - this is a hack. We're splitting on any comma at the
                // end of a line. This works because xmltosql puts each parameter
                // on it's own line. However, if xmltosql changes in the future
                // such that it puts multiple parameters on a single line 
                // (which would be a perfectly reasonable thing to do) 
                // this will break. But for now, this will allow ops to prop
                // content packages that have commas in the friendly name.
                string[] paramsArray = Regex.Split(strStoredProc, @",\s*\r\n");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_offers":
                        ParseParamsInsertOffers(ws, paramsArray);
                        break;
                    case "p_svc_insert_subscriptions":
                        ParseParamsInsertSubscriptions(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_descriptions":
                        ParseParamsInsertOfferDescriptions(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_description_details":
                        ParseParamsInsertOfferDescriptionDetails(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_locations":
                        ParseParamsInsertOfferLocations(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_regions":
                        ParseParamsInsertOfferRegions(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_relations":
                        ParseParamsInsertOfferRelations(ws, paramsArray);
                        break;
                    case "p_svc_offer_change_dates":
                        ParseParamsChangeOfferDates(ws, paramsArray);
                        break;
                    default:
                        throw new System.Exception("Error:  Invalid procedure name: " + strSPName );
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString

        public static void AddBinaryParam(WSClient ws, string strParamName, string strParam)
        {
            int nSize = strParam.Length / 2 - 1;
            byte[] binaryData = new byte[nSize];
            for(int k = 0 ; k < nSize; k++)
            {                               
                string strTmp = strParam.Substring(2 * (k + 1), 2);
                byte bChar = Convert.ToByte(strTmp, 16);
                binaryData[k] = bChar;
            }
            ws.AddParameter(strParamName, binaryData);
        }

        private static void ParseParamsInsertOffers(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        // bigint in hexa
                        case 1://bi_offer_id 
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 2://i_ESRB_id
                            ws.AddParameter("@i_ESRB_id", paramsArray[i]);
                            break;
                        case 3://b_cancelable
                        	byte bParam = Convert.ToByte(paramsArray[i]);
                            ws.AddParameter("@b_cancelable", bParam);
                            break;
                        // binaries
                        case 6: //vb_sym_key
                            AddBinaryParam(ws, "@vb_sym_key", paramsArray[i]);
                            break;
                        case 14://vb_public_key
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                        // int in decimal
                        case 4:
                            int dParam = Int32.Parse(paramsArray[i]);
                            ws.AddParameter("@i_package_size", dParam);
                            break;
                        case 5:
                            dParam = Int32.Parse(paramsArray[i]);
                            ws.AddParameter("@i_install_size", dParam);
                            break;
                        // int in hex
                        case 0: //i_title_id
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 7: //i_bitfilter
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_bitfilter", iParam);
                            break;
                        case 15://i_policy_flags
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_policy_flags", iParam);
                            break;
                        case 9://i_offer_type_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_type_id", iParam);
                            break;
                        case 10://i_offer_frequency_id 
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_frequency_id", iParam);
                            break;
                        // datetime
                        case 11: //dt_start_date
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            break;
                        case 12: //dt_end_date
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            break;
                        //strings
                        case 8: // vc_billing_svc_component_id
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_billing_svc_component_id", str);
                            break;
                        case 13:// vc_friendly_name
                            str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_friendly_name", str);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertSubscriptions(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                            // bigint in hexa
                        case 1://bi_offer_id 
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                            // plain ints
                        case 2://i_ESRB_id
                            ws.AddParameter("@i_ESRB_id", paramsArray[i]);
                            break;
                        case 3://b_cancelable
                        	byte bParam = Convert.ToByte(paramsArray[i]);
                            ws.AddParameter("@b_cancelable", bParam);
                            break;
                        case 4://i_package_size
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 5://i_install_size
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                            // binaries
                        case 6: //vb_sym_key
                            AddBinaryParam(ws, "@vb_sym_key", paramsArray[i]);
                            break;
                        case 14://vb_public_key
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                            // int in hexa
                        case 0: //i_title_id
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 7: //i_bitfilter
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_bitfilter", iParam);
                            break;
                        case 15://i_policy_flags
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_policy_flags", iParam);
                            break;
                        case 9://i_offer_type_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_type_id", iParam);
                            break;
                        case 10://i_offer_frequency_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_frequency_id", iParam);
                            break;
                            // datetime
                        case 11: //dt_start_date
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            break;
                        case 12: //dt_end_date
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            break;
                            //strings
                        case 8: // vc_billing_svc_component_id
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_billing_svc_component_id", str);
                            break;
                        case 13:// vc_friendly_name
                            str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_friendly_name", str);
                            break;
                        case 16: //si_global_offer_details
                            short wParam = Convert.ToInt16(paramsArray[i], 16);
                            ws.AddParameter("@si_global_offer_details", wParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }
   
        private static void ParseParamsInsertOfferDescriptions(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            AddBinaryParam(ws, "@vb_enum_blob", paramsArray[i]);
                            break;
                        case 2:
                            ws.AddParameter("@i_description_index", paramsArray[i]);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferDescriptionDetails(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            AddBinaryParam(ws, "@vb_details_blob", paramsArray[i]);
                            break;
                        case 2:
                            ws.AddParameter("@i_description_index", paramsArray[i]);
                            break;
                        case 3:
                            ws.AddParameter("@i_order", paramsArray[i]);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferLocations(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            break;
                        case 2:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferRegions(WSClient ws, string[] paramsArray)
        {
            try
            {
                string guid = "";
                long price = 0;
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            ws.AddParameter("@ti_country_id", paramsArray[i]);
                            break;
                        case 2:
                            string str = paramsArray[i].Replace("'","");
                            guid = str;
                            ws.AddParameter("@vc_billing_offer_id", str);
                            break;
                        case 3:
                            if (guid.Length == 0)
                            {
                                price = Int32.Parse(paramsArray[i]);
                                if (price > 0)
                                    throw new ApplicationException("There is a price but no GUID for region " 
                                            + paramsArray[1] + " in offer " + paramsArray[0]);
                            }
                            ws.AddParameter("@i_price_whole", paramsArray[i]);
                            break;
                        case 4:
                            if (guid.Length == 0)
                            {
                                price = Int32.Parse(paramsArray[i]);
                                if (price > 0)
                                    throw new ApplicationException("There is a price but no GUID for region " 
                                            + paramsArray[1] + " in offer " + paramsArray[0]);
                            }
                            ws.AddParameter("@i_price_fractional", paramsArray[i]);
                            break;
                        case 5:
                            byte bParam = Convert.ToByte(paramsArray[i], 16);
                            ws.AddParameter("@si_specific_offer_details", bParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferRelations(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_related_offer_id", lParam);
                            break;
                        case 2:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_relation_type_id", iParam);
                            break;
                        case 3:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_convert_mode", iParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsChangeOfferDates(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            break;
                        case 2:
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CSyncLeaderboards.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Data;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using System.Text;

using xonline.tools.framework;

namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// Enumerates the different database actions that can occur during
    /// a sync operation.
    /// </summary>
    enum LBUpdateAction { LEAVE, UPDATE, ADD, DELETE };

    /// <summary>
    /// Contains information about a single leader board.  Titles can
    /// have multiple leaderboards.  This structure is used to track
    /// what actions need to happen to which leaderboards during a sync operation.
    /// </summary>
    class CLeaderBoard
    {
        private int _leaderBoardType;
        private byte _resetType;
        private LBUpdateAction _action;


        //
        //  Constructor
        //

        public CLeaderBoard(int leaderBoardType, byte resetType, LBUpdateAction action)
        {
            _leaderBoardType = leaderBoardType;
            _resetType = resetType;
            _action = action;
        }

        //
        //  Properties
        //

        public int LeaderBoardType
        {
            get { return _leaderBoardType; }
            set { _leaderBoardType = value; }
        }

        public byte ResetType
        {
            get { return _resetType; }
            set { _resetType = value; }
        }

        public LBUpdateAction Action
        {
            get { return _action; }
            set { _action = value; }
        }
    }

	/// <summary>
	/// 
	/// </summary>
	internal class CSyncLeaderboards
	{
        /// <summary>
        /// Called when syncing changes to stats.ini for a title.  Can also be
        /// called when adding a title to the system.
        /// </summary>
        /// <param name="titleid"></param>
        /// <param name="statsDB"></param>
        /// 
        public static string []SupportedLocales  = 
        {
            "da-DK - Danish - Denmark",
            "de-AT - German - Austria",
            "de-CH - German - Switzerland",
            "de-DE - German - Germany",
            "en-AU - English - Australia",
            "en-CA - English - Canada",
            "en-IE - English - Ireland",
            "en-GB - English - United Kingdom",
            "en-SG - English - Singapore",
            "en-US - English - United States",
            "es-ES - Spanish - Spain",
            "fi-FI - Finnish - Finland",
            "fr-BE - French - Belgium",
            "fr-CA - French - Canada",
            "fr-CH - French - Switzerland",
            "fr-FR - French - France",
            "it-IT - Italian - Italy",
            "ja-JP - Japanese - Japan",
            "ko-KR - Korean - Republic of Korea",
            "nl-BE - Dutch - Belgium",
            "nl-NL - Dutch - Netherlands",
            "nb-NO - Norwegian - Norway",
            "sv-SE - Swedish - Sweden",
            "zh-HK - Chinese - Hong Kong",
            "zh-TW - Chinese - Taiwan"
        };

        private static string m_sStatsIniFilename = "config\\stats.ini";

        public static void RunStoredProc(string serverLookup, string database, string sp, params object []args)
        {
            string [] servers = CTitleMgrApp.Servers.GetSetting("SERVERS", serverLookup).Split(';');
            foreach (string server in servers)
            {
                RunStoredProcOnce(server, database, sp, args);
            }
        }

        public static void RunStoredProcOnce(string server, string database, string sp, params object []args)
        {
            string connStr = "Server=" + server + ";Database=" + database;

            connStr += ";Integrated Security=true";

            SqlConnection conn = new SqlConnection(connStr);
            conn.Open();

            bool comma = false;
            string comSp = sp;
            comSp += " ";
            foreach (object arg in args)
            {
                if (comma)
                    comSp += ",";
                if (arg.GetType() == server.GetType()) //it's a string
                    comSp += " '" + arg.ToString() + "'";
                else
                    comSp += arg.ToString();
                comma = true;
            }

            string sqlcommand = "exec " + comSp;

            CTitleMgrApp.WriteLineV("Running " + server + " command: " + sqlcommand);

            SqlCommand cmd = new SqlCommand(sqlcommand, conn);
            cmd.ExecuteNonQuery();
            conn.Close();
        }

        public static void ReloadStatsFD()
        {
            string statsFDs = CTitleMgrApp.Servers.GetSetting("SERVERS", "STATSFD");

            CTitleMgrApp.WriteLineV("Telling all stats front doors to reload their cached title information.");
            string [] statsFDArray = statsFDs.Split(';');
            foreach(string statsFD in statsFDArray)
            {
                string output = CMgmtCommand.Exec(statsFD, "e :xstatsfd reloaddbmap\r\n");
                CTitleMgrApp.WriteLineV(statsFD + ":  " + output);
            }
        }

        public static void ReloadWbca()
        {
            // collect all the webcache component ips
            string sWCAlerts = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCALERTS");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCALERTS entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCAlerts = sWCAlerts.Split(';');

            string sWCGeneral = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCGENERAL");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCGENERAL entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCGeneral = sWCGeneral.Split(';');

            string sWCMessaging = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCMESSAGING");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCMESSAGING entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCMessaging = sWCMessaging.Split(';');

            string sWCPresence = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCPRESENCE");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCPRESENCE entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCPresence = sWCPresence.Split(';');

            string sWCQuery = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCQUERY");
            if (sWCQuery.Length == 0)
            {
                throw new Exception("FAIL: WCQUERY entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCQuery = sWCQuery.Split(';');

            string sWCSignature = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCSIGNATURE");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCSIGNATURE entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCSignature = sWCSignature.Split(';');

            string sWCStats = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCSTATS");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCSTATS entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCStats = sWCStats.Split(';');

            string sWCStorage = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCSTORAGE");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCSTORAGE entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCStorage = sWCStorage.Split(';');

            string sWCUsers = CTitleMgrApp.Servers.GetSetting("SERVERS", "WCUSERS");
            if (sWCAlerts.Length == 0)
            {
                throw new Exception("FAIL: WCUSERS entry missing from servers.ini, unable to send xmgmt command.");
            }
            string [] rgsWCUsers = sWCUsers.Split(';');

            // now iterate through each server for each component and send the relevant xmgmt commands
            foreach(string sServer in rgsWCAlerts)
            {
                CMgmtCommand.Exec(sServer, "e :wcalerts ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCGeneral)
            {
                CMgmtCommand.Exec(sServer, "e :wcgeneral ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCMessaging)
            {
                CMgmtCommand.Exec(sServer, "e :wcmessaging ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCPresence)
            {
                CMgmtCommand.Exec(sServer, "e :wcpresence ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCQuery)
            {
                CMgmtCommand.Exec(sServer, "e :wcquery ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCSignature)
            {
                CMgmtCommand.Exec(sServer, "e :wcsignature ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCStats)
            {
                CMgmtCommand.Exec(sServer, "e :wcstats ReloadTitles\r\n");
                CMgmtCommand.Exec(sServer, "e :wcstats ReloadLeaderboards\r\n");
            }

            foreach(string sServer in rgsWCStorage)
            {
                CMgmtCommand.Exec(sServer, "e :wcstorage ReloadTitles\r\n");
            }

            foreach(string sServer in rgsWCUsers)
            {
                CMgmtCommand.Exec(sServer, "e :wcusers ReloadTitles\r\n");
            }
        }

        public static void GetWebDBVals(string titleid, out string esrb, out string cluster, out string default_locale)
        {
            //process title info (this isn't in the xml)
            string statsIniPath 
                = Environment.CurrentDirectory 
                + "\\" + titleid 
                + "\\" + m_sStatsIniFilename;
            if(!File.Exists(statsIniPath))
            {
                throw new ApplicationException("File not found:  \"" + statsIniPath + "\".");
            }

            Ini statsIni = new Ini(statsIniPath);

            esrb = ""; cluster = ""; default_locale = "";

            esrb = statsIni.GetSetting("TITLE", "ESRB");
            cluster = statsIni.GetSetting("TITLE", "Cluster");

            if (esrb.Length == 0)
                esrb = "7";
            if (cluster.Length == 0)
                cluster = "1";

            default_locale = statsIni.GetSetting("TITLE", "DefaultLocale");
            if (default_locale.Length == 0)
                default_locale = "en-US";
        }

        public static bool InLocaleList(string locale)
        {
            bool rval = false;
            
            for (int i = 0; i < SupportedLocales.Length; i++)
            {
                if (SupportedLocales[i].Substring(0, 5).ToUpper() == locale.ToUpper())
                    return true;
            }

            return rval;
        }

        /*
        public static void GetDefaultValuesFromIni(
                string sIniPathAndFilename,
                string sSectionName,
                ref uint uiMaxAttachmentSize,
                ref uint uiMaxTotalAttachmentSize,
                ref uint uiMaxAvailUnits,
                ref uint uiSizeUnitCache,
                ref EESRBRating esrbRating,
                ref uint uiClusterId,
                ref CLocale locDefault,
                ref uint uiEntriesPerCacheLine,
                ref uint uiExpirationSeconds,
                ref bool bOverrideWarnings,
                CLog log)
        {
            if (File.Exists(sIniPathAndFilename))
            {
                Ini iniDefaults = new Ini(sIniPathAndFilename);
                string sMaxAttachmentSize = iniDefaults.GetSetting(sSectionName, m_sIniSettingMaxAttachmentSize);
                if (sMaxAttachmentSize != "")
                {
                    try
                    {
                        uiMaxAttachmentSize = UInt32.Parse(sMaxAttachmentSize);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] " 
                            + m_sIniSettingMaxAttachmentSize 
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sMaxTotalAttachmentSize = iniDefaults.GetSetting(sSectionName, m_sIniSettingMaxTotalAttachmentSize);
                if (sMaxTotalAttachmentSize != "")
                {
                    try
                    {
                        uiMaxTotalAttachmentSize = UInt32.Parse(sMaxTotalAttachmentSize);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingMaxTotalAttachmentSize
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sMaxAvailUnits = iniDefaults.GetSetting(sSectionName, m_sIniSettingMaxAvailUnits);
                if (sMaxAvailUnits != "")
                {
                    try
                    {
                        uiMaxAvailUnits = UInt32.Parse(sMaxAvailUnits);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingMaxAvailUnits
                            + "setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sSizeUnitCache = iniDefaults.GetSetting(sSectionName, m_sIniSettingSizeUnitCache);
                if (sSizeUnitCache != "")
                {
                    try
                    {
                        uiSizeUnitCache = UInt32.Parse(sSizeUnitCache);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingSizeUnitCache
                            + " setting in "
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sEsrbRating = iniDefaults.GetSetting(sSectionName, m_sIniSettingEsrbRating);
                if (sEsrbRating != "")
                {
                    try
                    {
                        int iEsrbRating = Int32.Parse(sEsrbRating);
                        if (iEsrbRating < (int)EESRBRating.MinValue || iEsrbRating > (int)EESRBRating.MaxValue)
                        {
                            throw new Exception("Error: The [" 
                                + sSectionName 
                                + "] "
                                + m_sIniSettingEsrbRating
                                + " setting in " 
                                + sIniPathAndFilename
                                + " is not in the allowed range of " 
                                + (int)EESRBRating.MinValue
                                + " to "
                                + (int)EESRBRating.MaxValue
                                + ". Please check this setting.");
                        }
                        else
                        {
                            esrbRating = (EESRBRating)iEsrbRating;
                        }
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingEsrbRating
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sClusterId = iniDefaults.GetSetting(sSectionName, m_sIniSettingClusterId);
                if (sClusterId != "")
                {
                    try
                    {
                        uiClusterId = UInt32.Parse(sClusterId);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingClusterId
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sLocDefault = iniDefaults.GetSetting(sSectionName, m_sIniSettingDefaultLocale);
                if (sLocDefault != "")
                {
                    if (CLocale.IsSupported(sLocDefault))
                    {
                        locDefault = new CLocale(sLocDefault);
                    }
                    else
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingDefaultLocale
                            + " setting in " 
                            + sIniPathAndFilename
                            + " was not valid. Please check this setting.");
                    }
                }

                string sEntriesPerCacheLine = iniDefaults.GetSetting(sSectionName, m_sIniSettingEntriesPerCacheLine);
                if (sEntriesPerCacheLine != "")
                {
                    try
                    {
                        uiEntriesPerCacheLine = UInt32.Parse(sEntriesPerCacheLine);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingEntriesPerCacheLine
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sExpirationSeconds  = iniDefaults.GetSetting(sSectionName, m_sIniSettingExpriationSeconds);
                if (sExpirationSeconds != "")
                {
                    try
                    {
                        uiExpirationSeconds = UInt32.Parse(sExpirationSeconds);
                    }
                    catch (Exception)
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingExpriationSeconds
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }

                string sOverrideWarnings = iniDefaults.GetSetting(sSectionName, m_sIniSettingOverrideWarnings);
                if (sOverrideWarnings != "")
                {
                    if (sOverrideWarnings.Trim().ToLower() == "true")
                    {
                        bOverrideWarnings = true;
                    }
                    else if (sOverrideWarnings.Trim().ToLower() == "false")
                    {
                        bOverrideWarnings = false;
                    }
                    else
                    {
                        throw new Exception("Error: The [" 
                            + sSectionName 
                            + "] "
                            + m_sIniSettingOverrideWarnings
                            + " setting in " 
                            + sIniPathAndFilename
                            + " could not be parsed. Please check this setting.");
                    }
                }
            }
        }
        */

        /*
        private static void SaveCommandLineParametersToIni(
            string sIniPathAndFilename,
            string sSectionName,
            uint uiStatsMaxAttachmentSize,
            uint uiStatsMaxTotalAttachmentSize,
            uint uiStatsMaxAvailUnits,
            uint uiStatsSizeUnitCache,
            EESRBRating esrbRatingWebStats,
            uint uiWebStatsClusterId,
            CLocale locDefaultWebStats,
            uint uiWebStatsEntriesPerCacheLine,
            uint uiWebStatsExpirationSeconds,
            bool bStatsOverrideWarnings,
            bool bStatsNoOverrideWarnings,
            ref uint uiMaxAttachmentSize,
            ref uint uiMaxTotalAttachmentSize,
            ref uint uiMaxAvailUnits,
            ref uint uiSizeUnitCache,
            ref EESRBRating esrbRating,
            ref uint uiClusterId,
            ref CLocale locDefault,
            ref uint uiEntriesPerCacheLine,
            ref uint uiExpirationSeconds,
            ref bool bOverrideWarnings,
            CLog log)
        {
            if (File.Exists(sIniPathAndFilename))
            {
                StringBuilder sbComment = new StringBuilder();
                bool bSettingsUpdated = false;

                Ini iniDefaults = new Ini(sIniPathAndFilename);
                if (uiStatsMaxAttachmentSize != 0)
                {
                    uiMaxAttachmentSize = uiStatsMaxAttachmentSize;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingMaxAttachmentSize, 
                        uiMaxAttachmentSize.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingMaxAttachmentSize);
                    sbComment.Append(" to ");
                    sbComment.Append(uiMaxAttachmentSize);
                    sbComment.Append("\n");
                }

                if (uiStatsMaxTotalAttachmentSize != 0)
                {
                    uiMaxTotalAttachmentSize = uiStatsMaxTotalAttachmentSize;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingMaxTotalAttachmentSize, 
                        uiMaxTotalAttachmentSize.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingMaxTotalAttachmentSize);
                    sbComment.Append(" to ");
                    sbComment.Append(uiMaxTotalAttachmentSize);
                    sbComment.Append("\n");
                }

                if (uiStatsMaxAvailUnits != 0)
                {
                    uiMaxAvailUnits = uiStatsMaxAvailUnits;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingMaxAvailUnits, 
                        uiMaxAvailUnits.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingMaxAvailUnits);
                    sbComment.Append(" to ");
                    sbComment.Append(uiMaxAvailUnits);
                    sbComment.Append("\n");
                }

                if (uiStatsSizeUnitCache != 0)
                {
                    uiSizeUnitCache = uiStatsSizeUnitCache;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingSizeUnitCache, 
                        uiSizeUnitCache.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingSizeUnitCache);
                    sbComment.Append(" to ");
                    sbComment.Append(uiSizeUnitCache);
                    sbComment.Append("\n");
                }

                if (esrbRatingWebStats != EESRBRating.Unspecified)
                {
                    esrbRating = esrbRatingWebStats;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingEsrbRating, 
                        ((Int32)esrbRatingWebStats).ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingEsrbRating);
                    sbComment.Append(" to ");
                    sbComment.Append((Int32)esrbRatingWebStats);
                    sbComment.Append("\n");
                }

                if (uiWebStatsClusterId != 0)
                {
                    uiClusterId = uiWebStatsClusterId;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingClusterId, 
                        uiClusterId.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingClusterId);
                    sbComment.Append(" to ");
                    sbComment.Append(uiClusterId);
                    sbComment.Append("\n");
                }

                if (locDefaultWebStats != null)
                {
                    locDefault = locDefaultWebStats;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingDefaultLocale, 
                        locDefault.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingDefaultLocale);
                    sbComment.Append(" to ");
                    sbComment.Append(locDefault.ToString());
                    sbComment.Append("\n");
                }

                if (uiWebStatsEntriesPerCacheLine != 0)
                {
                    uiEntriesPerCacheLine = uiWebStatsEntriesPerCacheLine;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingEntriesPerCacheLine, 
                        uiEntriesPerCacheLine.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingEntriesPerCacheLine);
                    sbComment.Append(" to ");
                    sbComment.Append(uiEntriesPerCacheLine);
                    sbComment.Append("\n");
                }

                if (uiWebStatsExpirationSeconds != 0)
                {
                    uiExpirationSeconds = uiWebStatsExpirationSeconds;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingExpriationSeconds, 
                        uiExpirationSeconds.ToString());
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingExpriationSeconds);
                    sbComment.Append(" to ");
                    sbComment.Append(uiExpirationSeconds);
                    sbComment.Append("\n");
                }

                if (bStatsOverrideWarnings == true && bStatsNoOverrideWarnings == false)
                {
                    bOverrideWarnings = true;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingOverrideWarnings, 
                        "TRUE");
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingOverrideWarnings);
                    sbComment.Append(" to TRUE \n");
                }

                if (bStatsNoOverrideWarnings == true)
                {
                    bOverrideWarnings = false;
                    iniDefaults.SetSetting(
                        sSectionName, 
                        m_sIniSettingOverrideWarnings, 
                        "FALSE");
                    bSettingsUpdated = true;
                    sbComment.Append("Updating [");
                    sbComment.Append(sSectionName);
                    sbComment.Append("] ");
                    sbComment.Append(m_sIniSettingOverrideWarnings);
                    sbComment.Append(" to FALSE \n");
                }

                if (bSettingsUpdated)
                {
                    CSourceDepot sd = new CSourceDepot();
                    sd.Edit(sIniPathAndFilename);
                    iniDefaults.Save(sIniPathAndFilename);
                    sd.Submit(sIniPathAndFilename, sbComment.ToString());
                }
            }
        }
        */

        /*
        private static string GetWebDBConnectionString(CLog log)
        {
            string sServersIniPathAndFilename
                = Environment.CurrentDirectory
                + "\\"
                + m_sServersIniFilename;
            Ini iniServers = new Ini(sServersIniPathAndFilename);
            string sWebDBIp = iniServers.GetSetting("SERVERS","WEBDB");
            if (sWebDBIp == "")
            {
                string sError = "Unable to find [SERVERS] WEBDB setting in "
                    + sServersIniPathAndFilename
                    + ". Leaderboards will not be syncronized with the statistics xml data.";
                log.WriteLine(sError);
                throw new Exception(sError);
            }

            return "Server=" + sWebDBIp + ";"
                + "Database=webdb;"
                + "Integrated Security=true";
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CTitleMgrLog.cs ===
using System;
using System.IO;
using System.Diagnostics;
using xonline.tools.framework;
using xonline.common.service;

namespace xonline.tools.titlemgr 
{
    public class CTitleMgrLog : CLog
    {
        private FileStream m_fileStream;
        private StreamWriter m_streamWriter;
        private EventLog m_eventLog;
        private string m_sLogPathAndName;

        public CTitleMgrLog(Ini iniServers)
        {
            // Simple titlemgr logging, designed to emulate the current way titlemgr 
            // does output. This will be updated to use the logging from private\mgmt
            // "real soon".

            // log files are named titlemgr_MMddyyyy_HHmmss.log
            string sLogName = "titlemgr_" + DateTime.Now.ToString("MMddyyyy_HHmmssff") + ".log";

            // log files are written to the location specified in [SERVERS] LOGDIR in the passed Ini
            // if no location is specified in the Ini object, then logs are written to the \logs
            // subdirectory of the current directory.
            string sLogDir = CTitleMgrApp.Servers.GetSetting("SERVERS", "LOGDIR");
            string sDefaultLogDir = Environment.CurrentDirectory + "\\logs";
            if (sLogDir == null || sLogDir.Length == 0)
            {
                sLogDir = Environment.CurrentDirectory + "\\logs";
            }
            sLogDir = CPathUtil.AddPathTerminator(sLogDir);

            if (!Directory.Exists(sLogDir))
            {
                Directory.CreateDirectory(sLogDir);
            }

            m_sLogPathAndName = sLogDir + sLogName;

            // we shouldn't ever overwrite logs
            if (File.Exists(m_sLogPathAndName))
            {
                throw new ApplicationException("Log file " + m_sLogPathAndName + " already exists!");
            }

            m_fileStream = new FileStream(m_sLogPathAndName, FileMode.Create, FileAccess.Write);
            m_streamWriter = new StreamWriter(m_fileStream);

            // Setup the event log
            m_eventLog = new EventLog();
            m_eventLog.Source = "Titlemgr";
        }

        public string LogPathAndName
        {
            get { return m_sLogPathAndName; }
        }

        public void Close()
        {
            m_eventLog.Close();
            m_streamWriter.Close();
            m_fileStream.Close();
        }

        public void WriteEvent(string sMessage, EventLogEntryType eventLogEntryType)
        {
            int iEventId = (int)((uint)(XEvent.Id.TITLEMGR_GENERAL_ERROR) & 65535);
            m_eventLog.WriteEntry(sMessage, eventLogEntryType, iEventId);
        }

        protected override void WriteLine(int iLevel, string s)
        {
            lock(this)
            {
                if (iLevel == CLog.CONSOLE)
                {
                    System.Console.WriteLine(s);
                    System.Console.Out.Flush();
                }
                if (iLevel <= Level)
                {
                    // prepend the log string with the level.
                    // this will make it easier to navigate big log files generated by
                    // high log levels
                    m_streamWriter.WriteLine(LevelPrefix(iLevel)+s);
                    m_streamWriter.Flush();
                }
            }
        }

        // WriteLine(strin) and WriteLineV(string) are inheritied from CLog, and
        // call WriteLine(int, string) above

        // some of the legacy titlemgr code expects these functions, so let em have it
        public void WriteV(string sMessage)
        {
            lock(this)
            {
                m_streamWriter.Write(sMessage);
                m_streamWriter.Flush();
            }
        }

        public void Write(string sMessage)
        {
            lock(this)
            {
                System.Console.Write(sMessage);
                System.Console.Out.Flush();
                m_streamWriter.Write(sMessage);
                m_streamWriter.Flush();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CUODBUpdate.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// Takes the .sql2 file generated by the RebuildUpdate tool and updates UODB
    /// </summary>
    class CUODBUpdate
    {
        static public void Exec(string strSQL2File)
        {
            StreamReader  sr = null;
            int nWSClients = 0;
            WSClient[] wsClients = null;
            bool bRollback = false;
            
            try
            {
                wsClients = CPropUtils.GetUODBWebstoreClients();
                nWSClients = wsClients.Length;

                sr = File.OpenText(strSQL2File);

                string strFileContent = sr.ReadToEnd();
                string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

                if(strStoredProcedures.Length < 4)
                {
                    throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
                }
                
                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].ClearParameters();
                    wsClients[k].PartitionType = WstPartitionType.Physical;
                    wsClients[k].Partition = k;
                    wsClients[k].BeginTransaction();
                }

                int hr = CPropUtils.HR_SUCCEEDED;      
                
                //
                // Execute all stored procedures
                //
                for(int i = 1 ; i < strStoredProcedures.GetLength(0); i++)
                {
                    for(int k = 0; (k < nWSClients) && (CPropUtils.HR_SUCCEEDED == hr); k++)
                    {
                        ParseQueryString(wsClients[k], strStoredProcedures[i]);
                        wsClients[k].ExecuteNonQuery();
                        hr = wsClients[k].GetIntParameter("@RETVAL");
                        wsClients[k].ClearParameters();

                        if(CPropUtils.HR_FAILED_NO_TITLE == hr)
                        {
                            throw new ApplicationException("Inexistent titleID!");
                        }
                        else if(CPropUtils.HR_FAILED_TITLE_VERSION == hr)
                        {
                            throw new ApplicationException("Base version in update package doesn't exist in UODB");
                        }
                    }
                }

                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].CommitTransaction();
                }

                CTitleMgrApp.WriteLineV("Success!");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                bRollback = true;
            }
            finally
            {
                if(null != sr)
                {
                    sr.Close();
                }
            }

            if(bRollback)
            {
                if(null != wsClients)
                {
                    for(int k = 0; k < nWSClients; k++)
                    {
                        try
                        {
                            wsClients[k].RollbackTransaction();
                        }
                        catch(Exception)
                        {
                        }
                    }
                }

            }
            
        }
        
        /// <summary>
        /// ParseQueryString():
        /// Parses given query string and sets up the webstore client for the stored procedure call.
        /// </summary>
        private static void ParseQueryString(WSClient ws, string strStoredProc)
        {
            try
            {
                string[] paramsArray = Regex.Split(strStoredProc, "[,]");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_title_update_packages":
                        ParseParamsTitleUpdatePackages(ws, paramsArray);
                        break;
                    case "p_svc_insert_title_update_locations":
                        ParseParamsTitleUpdateLocations(ws, paramsArray);
                        break;
                    case "p_svc_insert_title_versions":
                        ParseParamsInsertTitleVersions(ws, paramsArray);
                        break;
                    default:
                        throw new System.Exception("Error:  Invalid procedure name: " + strSPName );
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString


        private static void ParseQueryString(WSClient ws, string strStoredProc, uint baseVer)
        {
            try
            {
                string[] paramsArray = Regex.Split(strStoredProc, "[,]");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_title_update_packages":
                        ParseParamsTitleUpdatePackages(ws, paramsArray, baseVer);
                        break;
                    case "p_svc_insert_title_update_locations":
                        ParseParamsTitleUpdateLocations(ws, paramsArray, baseVer);
                        break;
                    default:
                        ws.StoredProc = "";
                        break;
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString

        private static void AddBinaryParam(WSClient ws, string strParamName, string strParam)
        {
            int nSize = strParam.Length / 2 - 1;
            byte[] binaryData = new byte[nSize];
            for(int k = 0 ; k < nSize; k++)
            {                               
                string strTmp = strParam.Substring(2 * (k + 1), 2);
                byte bChar = Convert.ToByte(strTmp, 16);
                binaryData[k] = bChar;
            }
            ws.AddParameter(strParamName, binaryData);
        }

        private static void ParseParamsTitleUpdatePackages(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 4:
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                        case 5:
                            AddBinaryParam(ws, "@vb_update_sym_key", paramsArray[i]);
                            break;
                        case 6:
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdatePackages(WSClient ws, string[] paramsArray, uint baseVer)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    //CTitleMgrApp.WriteLineV("Adding param " + paramsArray[i] + " to update_pacs");
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            CTitleMgrApp.WriteLineV("Adding int " + iParam.ToString());
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            CTitleMgrApp.WriteLineV("Base " + baseVer.ToString());
                            ws.AddParameter("@i_title_base_version", baseVer);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            CTitleMgrApp.WriteLineV("Adding int " + iParam.ToString());
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            CTitleMgrApp.WriteLineV("Adding def " + paramsArray[i]);
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 4:
                            CTitleMgrApp.WriteLineV("Adding def " + paramsArray[i]);
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                        case 5:
                            CTitleMgrApp.WriteLineV("Adding bin " + paramsArray[i]);
                            AddBinaryParam(ws, "@vb_update_sym_key", paramsArray[i]);
                            break;
                        case 6:
                            CTitleMgrApp.WriteLineV("Adding bin " + paramsArray[i]);
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdateLocations(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            break;
                        case 4:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdateLocations(WSClient ws, string[] paramsArray, uint baseVer)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    CTitleMgrApp.WriteLineV("Adding param " + paramsArray[i] + " to update_locs");
                    
                    switch(i)
                    {
                        case 1:
                            ws.AddParameter("@i_title_base_version", baseVer);
                            break;
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            break;
                        case 4:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }


        private static void ParseParamsInsertTitleVersions(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_new_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_version_flag", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsCleanAutoupdates(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.StoredProc = "dbo.p_svc_clean_autoupdates";
                ws.AddParameter("@i_title_id", Convert.ToInt32(paramsArray[0], 16));
                ws.AddParameter("@i_base_version", Convert.ToInt32(paramsArray[1], 16));
                ws.AddParameter("@i_new_version", Convert.ToInt32(paramsArray[2], 16));
            }
            catch(System.Exception)
            {
                throw;
            }
        }
  
        public static void InsertTitleVersion(string strTitleID, uint baseVer, uint iHighestVer, bool bFullUpdate)
        {
            int nWSClients = 0;
            WSClient[] wsClients = null;

            CTitleMgrApp.WriteLineV("Inserting t_title_versions from " + baseVer.ToString() + 
                " to " + iHighestVer.ToString() + " for " + bFullUpdate.ToString());

            int iTitleID = Int32.Parse(strTitleID, NumberStyles.HexNumber);
            
            wsClients = CPropUtils.GetTransactionWebstoreClients();
            nWSClients = wsClients.Length;

            for(int k = 0; k < nWSClients; k++)
            {
                //for each client, insert t_title_versions from base to highest

                wsClients[k].StoredProc = "dbo.p_svc_insert_title_versions";
                
                wsClients[k].AddParameter(ParamType.INPUT, "@i_title_id", iTitleID);
                wsClients[k].AddParameter(ParamType.INPUT, "@i_base_version", baseVer);
                wsClients[k].AddParameter(ParamType.INPUT, "@i_new_version", iHighestVer);
                wsClients[k].AddParameter(ParamType.INPUT, "@i_version_flag", (bFullUpdate == false) ? 1 : 0);

                wsClients[k].ExecuteNonQuery();
            }
        }

        public static void InsertUpdatePackageLocations(string strTitleID, uint baseVer, string  strHighestVer)
        {
            StreamReader  sr = null;
            int nWSClients = 0;
            WSClient[] wsClients = null;
        
            string strSQL2File = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strHighestVer + ".sql2";

            //don't run this if baseVer = HighestVer
            string updateVer = strHighestVer.Substring(8, 8);
            if (baseVer == UInt32.Parse(updateVer, NumberStyles.HexNumber))
                return;

            wsClients = CPropUtils.GetTransactionWebstoreClients();
            nWSClients = wsClients.Length;

            sr = File.OpenText(strSQL2File);

            string strFileContent = sr.ReadToEnd();
            sr.Close();
            string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

            if(strStoredProcedures.Length < 4)
            {
                throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
            }
        
            int hr = CPropUtils.HR_SUCCEEDED;      
        
            //
            // Execute all stored procedures
            //
            for(int i = 1 ; i < strStoredProcedures.GetLength(0); i++)
            {
                for(int k = 0; (k < nWSClients) && (CPropUtils.HR_SUCCEEDED == hr); k++)
                {
                    wsClients[k].StoredProc = "";
                    
                    ParseQueryString(wsClients[k], strStoredProcedures[i], baseVer);
                    
                    //insert t_offers
                    
                    if (wsClients[k].StoredProc == "")
                        continue;

                    wsClients[k].ExecuteNonQuery();

                    hr = wsClients[k].GetIntParameter("@RETVAL");

                    if(CPropUtils.HR_FAILED_NO_TITLE == hr)
                    {
                        throw new ApplicationException("Inexistent titleID!");
                    }
                    else if(CPropUtils.HR_FAILED_TITLE_VERSION == hr)
                    {
                        throw new ApplicationException("Base version in update package doesn't exist in UODB");
                    }
                }

                //
                //  Need to commit trans, clear parameters, reset partition and start new trans
                //  for next iteration.
                //

                for(int k = 0; (k < nWSClients); k++)
                {
                    wsClients[k].CommitTransaction();
                    wsClients[k].ClearParameters();
                    wsClients[k].PartitionType = WstPartitionType.Physical;
                    wsClients[k].Partition = k;
                    wsClients[k].BeginTransaction();
                }
            }
                
            CTitleMgrApp.WriteLineV("Success!");

        } //insertpackagelocations
    } //class
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\CPropUtils.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Threading;
using System.Collections;
using System.Text.RegularExpressions;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.titlemgr
{
    public enum UODBAction { LEAVE, UPDATE, DELETE, UPDATE_TRANSFER };

    public enum BillingState {CURRENT, SPS_NOT_READY, SPS_READY};

    public class CUODBID
    {
        private string m_strID;
        private UODBAction m_action;

        //
        //  Constructor
        //
        public CUODBID(string strID, UODBAction action)
        {
            m_strID = strID;
            m_action = action;
        }

        //
        //  Properties
        //
        public string ID
        {
            get { return m_strID; }
            set { m_strID = value; }
        }

        public UODBAction Action
        {
            get { return m_action; }
            set { m_action = value; }
        }

        public override int GetHashCode()
        {
            return StringComparer.CurrentCultureIgnoreCase.GetHashCode(m_strID);
        }

        public override bool Equals(object obj)
        {
            Debug.Assert( obj is CUODBID );
            CUODBID uodbID = (CUODBID)obj;
            return (CaseInsensitiveComparer.Default.Compare(m_strID, uodbID.m_strID) == 0);
        }

    }

    /// <summary>
    /// Utils for propping content / update packages
    /// </summary>
    internal class CPropUtils
    {
        public const uint uiIDLength      = 16;
        public const uint uiKeyLength     = 32;
        public const uint uiVersionLength = 8;
        public const uint uiTitleLength   = 8;

        public static int HR_FAILED               = Convert.ToInt32("0x8007000D", 16);
        public static int HR_FAILED_NO_TITLE      = Convert.ToInt32("0x80156001", 16);
        public static int HR_FAILED_TITLE_VERSION = Convert.ToInt32("0x80156002", 16);
        public static int HR_FAILED_INSERT        = Convert.ToInt32("0x80156002", 16);
        public static int HR_FAILED_NO_OFFER      = Convert.ToInt32("0x80156003", 16);
        public static int HR_SUCCEEDED            = 0x00000000;
        public static int HR_EXIT                 = 0x00000001;

        public static WSClient[] _wsClients = null;
        public static WSClient[] _transClients = null;

        public static WSClient   _wsClient = null;

        public static WSClient[] GetTransactionWebstoreClients()
        {
            return _transClients;
        }

        public static void BeginTransactions()
        {
            if (null == _transClients)
            {
                //  We create a dummy object for the purposes of getting number of partitions.
                WSClient wsDummy = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);

                _transClients = new WSClient[wsDummy.PhysicalPartitions];

                for(int k = 0 ; k < _transClients.Length; k++)
                {
                    // init the webstore objects
                    _transClients[k] = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                }
            }

            for(int k = 0; k < _transClients.Length; k++)
            {
                CTitleMgrApp.WriteLineV("Beginning transaction for " + k.ToString());
                _transClients[k].ClearParameters();
                _transClients[k].PartitionType = WstPartitionType.Physical;
                _transClients[k].Partition = k;
                _transClients[k].BeginTransaction();
            }
        }

        public static void RollbackTransactions()
        {
            for(int k = 0; k < _transClients.Length; k++)
            {
                try
                {
                    CTitleMgrApp.WriteLineV("Rolling transaction for " + k.ToString());
                    _transClients[k].ClearParameters();
                    _transClients[k].RollbackTransaction();
                }
                catch (Exception)
                {
                }
            }
        }

        public static void CommitTransactions()
        {
            for(int k = 0; k < _transClients.Length; k++)
            {
                CTitleMgrApp.WriteLineV("Committing transaction for " + k.ToString());
                _transClients[k].ClearParameters();
                _transClients[k].CommitTransaction();
            }
        }

        public static WSClient[] GetUODBWebstoreClients()
        {
            if(null == _wsClients)
            {
                //  We create a dummy object for the purposes of getting number of partitions.
                WSClient wsDummy = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);

                _wsClients = new WSClient[wsDummy.PhysicalPartitions];

                for(int k = 0 ; k < _wsClients.Length; k++)
                {
                    // init the webstore objects
                    _wsClients[k] = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                }
            }

            for(int k = 0; k < _wsClients.Length; k++)
            {
                _wsClients[k].ClearParameters();
            }

            return(_wsClients);
        }

#if false
        public static WSClient GetUODBWebstoreClient()
        {
            if(null == _wsClient)
            {
                // init the webstore object
                _wsClient = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                _wsClient.Partition = WSClient.ALL_PARTITIONS;
            }

            _wsClient.ClearParameters();

            return(_wsClient);
        }
#endif

        public static string ExtractID(string strOriginal, int iLength)
        {
            string strID = strOriginal.Trim();
            strID = strID.Replace(",", "");
            strID = strID.Replace("0x", "");
            strID = strID.PadLeft(iLength, '0');

            return (strID);
        }

        public static void VerifyExists(string strFilePath)
        {
            if(!File.Exists(strFilePath))
            {
                throw new ApplicationException("File not found! " + strFilePath);
            }
        }

        public static bool IsSubscription(string strTitleID, string offer)
        {
            string sqlfile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + offer + ".sql2";
            StreamReader reader = new StreamReader(sqlfile);
            string line = reader.ReadLine();
            reader.Close();
            if (line.IndexOf("subscriptions") > 0)
                return true;
            else
                return false;
        }

        public static void VerifyExistsDir(string strDirPath)
        {
            if(!Directory.Exists(strDirPath))
            {
                throw new ApplicationException("Dir not found! " + strDirPath);
            }
        }

        public static void VerifySites(string strInputSite)
        {
            if("all" == strInputSite.ToLower())
            {
                return;
            }
            string [] strSites = strInputSite.Split(';');

            foreach(string strSite in strSites)
            {
                uint uiSite = Convert.ToUInt16(strSite);
                if(null == CTitleMgrApp.Servers.GetSection("Site." + uiSite.ToString()))
                {
                    throw new ApplicationException("Site " + strSite + " not present in servers.ini!");
                }
            }
        }

        public static void VerifyVersion(string strVersion)
        {
            if(uiVersionLength != strVersion.Length)
            {
                throw new ApplicationException("Invalid initial version: " + strVersion);
            }
            Convert.ToInt32(strVersion, 16);
        }

        public static void VerifyID(string strID)
        {
            if(uiIDLength != strID.Length)
            {
                throw new ApplicationException("Invalid ID: " + strID);
            }
            Convert.ToInt64(strID, 16);
        }

        public static void VerifyXRL(string strXRL)
        {
            if(0 == strXRL.Length)
            {
                throw new ApplicationException("Invalid XRL: " + strXRL);
            }
        }

        public static void VerifyKey(string strKey)
        {
            if(uiKeyLength != strKey.Length)
            {
                throw new ApplicationException("Invalid Key: " + strKey);
            }
        }

        public static void VerifyDate(string strDate)
        {
            if(0 == strDate.Length)
            {
                throw new ApplicationException("Invalid Date: " + strDate);
            }
            Convert.ToDateTime(strDate);
        }

        public static bool IsIDContent(string strTitleID, string strID)
        {
            Ini controlIni = new Ini(Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strID + ".control");

            string type = controlIni.GetSetting("Package", "Type");

            if (type == "Content")
                return true;

            if (type == "AutoUpdate")
                return false;

            return (strID.ToLower().StartsWith(strTitleID.ToLower()));
        }

        public static bool IsIDTitle(string strTitleID)
        {
            bool bTitle = false;

            if(uiTitleLength == strTitleID.Length)
            {
                try
                {
                    Convert.ToInt32(strTitleID, 16);
                    bTitle = true;
                }
                catch(Exception)
                {
                }
            }

            return (bTitle);
        }

        public static void VerifyRegions(string strSqlFile, string strSite)
        {
            StreamReader reader = new StreamReader(strSqlFile);

            string strContents = reader.ReadToEnd();

            reader.Close();

            //CTitleMgrApp.WriteLineV("Splitting by exec");
            string [] rProcs = Regex.Split(strContents, "exec");

            ArrayList rRegions = new ArrayList();

            foreach (string strProc in rProcs)
            {
                if (strProc.Length == 0)
                    continue;

                //CTitleMgrApp.WriteLineV("Splitting by , for " + strProc);

                string[] paramsArray = Regex.Split(strProc, "[,]");

                //CTitleMgrApp.WriteLineV("Trimming for " + strProc);

                for(int i = 0 ; i < paramsArray.Length; i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                //CTitleMgrApp.WriteLineV("Splitting by spaces for " + strProc);

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");

                //CTitleMgrApp.WriteLineV("Accessing 0 and 1" + strProc);

                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                if (strSPName != "p_svc_insert_offer_regions")
                    continue;

                //CTitleMgrApp.WriteLineV("Accessing params1 " + strProc);

                rRegions.Add(paramsArray[1]); //this is the region
            }

            //now get regions in the site
            string strSiteRegions = CTitleMgrApp.Servers.GetSetting("SITE." + strSite, "REGIONS");

            if (strSiteRegions.Length == 0)
                throw new ApplicationException("You need to specify a REGIONS setting under the SITE." + strSite + " tab");

            string [] rSiteRegions = strSiteRegions.Split(';');

            ArrayList rSiteList = new ArrayList();

            foreach (string strSiteRegion in rSiteRegions)
                rSiteList.Add(strSiteRegion);

            foreach (string strRegion in rRegions)
            {
                if (!rSiteList.Contains(strRegion))
                    throw new ApplicationException("Region(" + strRegion + ") is not under SITE." + strSite + ". Please place a different site first in the list.");
            }

        }

        public static void SDWorkPackage(string strFilePath, string strTitleID, string strPackageID)
        {
            CSourceDepot sd = null;

            try
            {
                sd = new CSourceDepot();

                //
                // Check all the files in the repository
                //
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
                string strPKGFile = strPath + "\\" + strPackageID.ToUpper() + ".pkg";
                string strXCPFile = strPath + "\\" + strPackageID.ToUpper() + ".xcp";


                //
                //  Create destination directory if necessary
                //
                if(!Directory.Exists(strPath))
                {
                    Directory.CreateDirectory(strPath);
                }

                CPropUtils.SDAddEdit(sd, strFilePath, strPKGFile, true);
                CPropUtils.SDAddEdit(sd, strFilePath + ".new", strXCPFile, true);

                //
                //  Submit changes
                //
                CTitleMgrApp.WriteV("Submitting changes to the repository...");
                sd.Submit(strPKGFile, "titlemgr: Updated original package for " + strPackageID);
                sd.Submit(strXCPFile, "titlemgr: Updated rebuilt package for " + strPackageID);

                CTitleMgrApp.WriteLineV("Success");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }
        }

        public static bool VersionExists(string strTitleID, string strBaseVersion)
        {
            //See if the pair titleid/baseversion exists in uodb

            int hr = 0;
            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

            ws.ClearParameters();
            ws.StoredProc = "dbo.p_svc_get_title_versions";
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
            int iParam = Convert.ToInt32(strTitleID, 16);
            ws.AddParameter("@i_title_id", iParam);
            iParam = Convert.ToInt32(strBaseVersion, 16);
            ws.AddParameter("@i_base_version", iParam);

            ws.ExecuteNonQuery();
            hr = ws.GetIntParameter("@RETVAL");

            ws.Close();

            if (hr == 0)
                return false;

            return true;
        }

        public static void SetContentControl(string strControlFilePath, BillingState state, bool bPremium, bool bWriteSites)
        {
            Ini controlIni = new Ini(strControlFilePath);

            controlIni.SetSetting("Billing", "Premium", (bPremium)?"YES":"NO");
            controlIni.SetSetting("Package", "Type", "Content");

            switch(state)
            {
                case BillingState.SPS_NOT_READY:
                    controlIni.SetSetting("Billing", "SPS", "NotReady");
                    break;
                case BillingState.SPS_READY:
                    controlIni.SetSetting("Billing", "SPS", "Ready");
                    break;
            }

            controlIni.Save(strControlFilePath);
        }

        public static void SetAutoupdControl(string strControlFilePath, bool bWriteSites)
        {
            Ini controlIni = new Ini(strControlFilePath);

            controlIni.SetSetting("Package", "Type", "AutoUpdate");


            controlIni.Save(strControlFilePath);
        }


        public static void SDWorkControl(string strControlFilePath, string strTitleID, string strPackageID, BillingState state, bool bPremium, bool bWriteSites, bool bContent)
        {
            CSourceDepot sd = null;

            try
            {
                sd = new CSourceDepot();

                //
                // Check all the files in the repository
                //
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
                string strControlFile = strPath + "\\" + strPackageID.ToUpper() + ".control";


                //
                //  Create destination directory if necessary
                //
                if(!Directory.Exists(strPath))
                {
                    Directory.CreateDirectory(strPath);
                }

                CPropUtils.SDAddEdit(sd, strControlFilePath, strControlFile, false);

                if(bContent == true)
                {
                    SetContentControl(strControlFile, state, bPremium, bWriteSites);
                }
                else
                {
                    SetAutoupdControl(strControlFile, bWriteSites);
                }


                //
                //  Submit changes
                //
                CTitleMgrApp.WriteV("Submitting changes to the repository...");
                sd.Submit(strControlFile, "titlemgr: Updated control package for " + strPackageID);

                CTitleMgrApp.WriteLineV("Success");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }
        }

        public static void SDWorkSQL2(string strSQL2FilePath, string strTitleID, string strPackageID)
        {
            CSourceDepot sd = null;

            try
            {
                sd = new CSourceDepot();

                //
                // Check all the files in the repository
                //
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
                string strSQL2File = strPath + "\\" + strPackageID.ToUpper() + ".sql2";
                string strSPSFile = strPath + "\\" + strPackageID.ToUpper() + ".sps";
                string strControlFile = strPath + "\\" + strPackageID.ToUpper() + ".control";
                string strBillingFile = Environment.CurrentDirectory + "\\Billing.ini";
                string strBOIDsFile = strPath + "\\" + strPackageID.ToUpper() + ".boids";

                Ini controlIni = new Ini(strControlFile);

                //
                //  Create destination directory if necessary
                //
                if(!Directory.Exists(strPath))
                {
                    Directory.CreateDirectory(strPath);
                }

                CPropUtils.SDAddEdit(sd, strSQL2FilePath, strSQL2File, false);

                bool bPremium = (controlIni.GetSetting("Billing", "Premium").ToUpper() == "YES");

                /*
                if(bPremium)
                {
                    Ini billingIni = new Ini(strBillingFile);
                    if (billingIni.GetSetting("Template", "Required").ToUpper() != "YES")
                    {
                        CPropContent.ModifyBillingContent(strSQL2File, strBillingFile);
                        string strNewSQL2File = strSQL2File + ".new";
                        File.Copy(strNewSQL2File, strSQL2File, true);
                        File.Delete(strNewSQL2File);
                    }
                }
                */

                //
                //  Submit changes
                //
                CTitleMgrApp.WriteV("Submitting changes to the repository...");
                sd.Submit(strSQL2File, "titlemgr: Updated control package for " + strPackageID);

                CTitleMgrApp.WriteLineV("Success");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }
        }

        public static void CleanUpWorkingFolder(string strFilePath)
        {
            //
            // Clean up the current directory
            //
            if (CTitleMgrApp.Verbose())
                return;

            File.Delete(strFilePath + ".new");
            File.Delete(strFilePath + ".cab");
            File.Delete(strFilePath + ".ops");
            File.Delete(strFilePath + ".sql");
            File.Delete(strFilePath + ".sql2");
            File.Delete(strFilePath + ".xbx");
            File.Delete(strFilePath + ".control2");
        }

        public static void UpdateXKDCCache()
        {
            //
            // Update XKDC cache
            //
            CTitleMgrApp.WriteLineV("Telling all XKDCs  to reload their cached title information.");
            string XKDCs = CTitleMgrApp.Servers.GetSetting("SERVERS", "XKDC");
            string [] XKDCArray = XKDCs.Split(';');

            if((0 == XKDCArray.Length) || ("" == XKDCArray[0]))
            {
                CTitleMgrApp.WriteLine("FAIL: Servers.ini: No XKDC IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < XKDCArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.Exec(XKDCArray[iIndex], "exec :xkdc reload\r\n");
                    CTitleMgrApp.WriteLineV(XKDCArray[iIndex] + ":  " + output);
                }
            }
        }

        public static void UpdateXBOSCache()
        {
            //
            // Update XBOS cache
            //
            CTitleMgrApp.WriteLineV("Telling all XBOSes  to flush their cached information.");
            string XBOSs = CTitleMgrApp.Servers.GetSetting("SERVERS", "XBOS");
            string [] XBOSArray = XBOSs.Split(';');

            if((0 == XBOSArray.Length) || ("" == XBOSArray[0]))
            {
                CTitleMgrApp.WriteLine("Servers.ini: No XBOS IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < XBOSArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.Exec(XBOSArray[iIndex], "exec :xbos cacheflush\r\n");
                    CTitleMgrApp.WriteLineV(XBOSArray[iIndex] + ":  " + output);
                }
            }
        }

        public static void UpdateUACSCache()
        {
            //
            // Update UACS cache
            //
            CTitleMgrApp.WriteLineV("Telling all UACS to flush their cached information.");
            string UACSs = CTitleMgrApp.Servers.GetSetting("SERVERS", "UACS");
            string [] UACSArray = UACSs.Split(';');

            if((0 == UACSArray.Length) || ("" == UACSArray[0]))
            {
                CTitleMgrApp.WriteLine("Servers.ini: No UACS IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < UACSArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.Exec(UACSArray[iIndex], "exec :xuacs cacheflush\r\n");
                    CTitleMgrApp.WriteLineV(UACSArray[iIndex] + ":  " + output);
                }
            }
        }



        public static bool TransferWork(string strTitleID, string strID)
        {
            string strRelativePath = "\\" + strTitleID.ToLower() + "\\" + strID.ToLower();
            string strPackageFile = Environment.CurrentDirectory + strRelativePath + ".xcp";
            string strControlFile = Environment.CurrentDirectory + strRelativePath + ".control";
            string strSql2File = Environment.CurrentDirectory + strRelativePath + ".sql2";
            string strDownloadServers = null;
            string strSite = null;

            bool bRet = true;

            try
            {
                //
                //  Do the working file exist?
                //
                CPropUtils.VerifyExists(strControlFile);
                CPropUtils.VerifyExists(strPackageFile);

                //
                // Is it a subscription?
                StreamReader reader = new StreamReader(strSql2File);
                string line = reader.ReadLine();
                reader.Close();

                if (line == null || line.IndexOf("subscriptions") >= 0)
                {
                    CTitleMgrApp.WriteLineV("Skipping transfer of subscription: " + strID);
                    return true;
                }

                Ini controlIni = new Ini(strControlFile);

                string strBillingState = controlIni.GetSetting("Billing", "SPS");

                if("NOTREADY" == strBillingState.ToUpper())
                {
                    throw new ApplicationException("Packet in SPSNotReady billing state can not be transferred!");
                }


                strSite = controlIni.GetSetting("Package", "Site");

                if("" == strSite)
                {
                    strSite = "1";
                }

                //
                // Transfer the files
                //

                strDownloadServers = GetIPs("DownloadServers", strSite);

                if(null == strDownloadServers)
                {
                    throw(new ApplicationException("No valid Download Servers for package!"));
                }

                CTitleMgrApp.WriteLineV("Transferring " + strPackageFile + " to the locations...");
                string [] DownloadServersArray = strDownloadServers.Split(';');
                File.SetAttributes(strPackageFile, FileAttributes.Normal);
                FileInfo fi = new FileInfo(strPackageFile);

                for(int iIndex = 0; iIndex < DownloadServersArray.Length; ++iIndex)
                {
                    try
                    {
                        fi.CopyTo(DownloadServersArray[iIndex] + strRelativePath + ".xcp", true);
                    }
                    catch(Exception)
                    {
                        DirectoryInfo di = new DirectoryInfo(DownloadServersArray[iIndex] + "\\" + strTitleID.ToLower());
                        di.Create();
                        fi.CopyTo(DownloadServersArray[iIndex] + strRelativePath + ".xcp", true);
                    }
                    CTitleMgrApp.WriteLine("Server " + iIndex.ToString() +  ":  " + strID +" Transferred!");
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                bRet = false;
            }
            finally
            {
                File.SetAttributes(strPackageFile, FileAttributes.ReadOnly);
            }

            return (bRet);
        }

        public static string [] GetPackageList(string strTitlePath, string strPackageID)
        {
            string [] strPackageIDs;

            if(strPackageID.ToLower() == "all")
            {
                strPackageIDs = Directory.GetFiles(strTitlePath, "*.control");
                for (int i = 0; i < strPackageIDs.GetLength(0); i++)
                {
                    strPackageIDs[i] = Path.GetFileNameWithoutExtension(strPackageIDs[i]);
                }
            }
            else
            {
                strPackageIDs = strPackageID.Split(';');
            }

            return (strPackageIDs);
        }

        public static int Transfer(string strTitleID, string strPackageID)
        {
            int hr = HR_SUCCEEDED;
            CSourceDepot sd = null;
            string srcPath = Environment.CurrentDirectory;

            try
            {
                sd = new CSourceDepot();

                //
                //  Get the list of title ids we are transferring
                //
                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);

                if(null == strPackageID)
                {
                    strPackageID = "all";
                }
                if((titleIDs.Count > 1) && ("all" != strPackageID))
                {
                    CTitleMgrApp.WriteLine("Ignoring /packageid option...");
                    strPackageID = "all";
                }

                foreach(string strTitle in titleIDs)
                {

                    //
                    //  Get the list of package ids we are transferring
                    //
                    string strTitlePath = srcPath + "\\" + strTitle.ToLower();
                    string [] packageIDs = GetPackageList(strTitlePath, strPackageID);

                    foreach(string strPackage in packageIDs)
                    {
                        try
                        {
                            string strPackagePath = strTitlePath + "\\" + strPackage;
                            string strPackageFile = strPackagePath + ".xcp";
                            string strControlFile = strPackagePath + ".control";

                            sd.Sync(strPackageFile);
                            sd.Sync(strControlFile);

                            TransferWork(strTitle, strPackage);
                        }
                        catch (Exception e)
                        {
                            CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                        }
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }

            return (hr);
        }

        public static int InsertTitle(string strTitlePath)
        {
            int hr = HR_SUCCEEDED;

            try
            {
                string strTitleID = Path.GetFileName(strTitlePath);
                string strVersionsFile = strTitlePath + "\\Config\\Versions.ini";

                VerifyExists(strVersionsFile);

                Ini versionsIni = new Ini(strVersionsFile);
                string strInitialVersion = versionsIni.GetSetting("Version", "Initial");
                string strExemptStatus = versionsIni.GetSetting("Version", "MakeExempt");
                string strExemptDate = versionsIni.GetSetting("Status", "Exempt");
                if (strExemptStatus == "1" ||
                    !CTitleMgrApp.InvalidArgument(strExemptDate))
                {
                    CExempt.Exec(strTitleID, "1");
                }

                VerifyVersion(strInitialVersion);

                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                        ws.StoredProc = "dbo.p_svc_insert_titles";

                        ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                        int iParam = Convert.ToInt32(strTitleID, 16);
                        ws.AddParameter("@i_title_id", iParam);
                        iParam = Convert.ToInt32(strInitialVersion, 16);
                        ws.AddParameter("@i_initial_version", iParam);

                        ws.ExecuteNonQuery();
                        hr = ws.GetIntParameter("@RETVAL");
                        ws.Close();

                        if(HR_SUCCEEDED != hr)
                        {
                            throw new ApplicationException("Insert new title and initial version failed ");
                        }
                    }
                }

                string strAdditionalVersions = versionsIni.GetSetting("VERSION", "ADDITIONAL");
                if("" != strAdditionalVersions)
                {

                    string [] strVersions = strAdditionalVersions.Split(';');


                    foreach(string strVersion in strVersions)
                    {

                        try
                        {
                            CPropUtils.BeginTransactions();
                            VerifyVersion(strVersion);

                            CUODBUpdate.InsertTitleVersion(strTitleID, UInt32.Parse(strVersion, NumberStyles.HexNumber),
                                UInt32.Parse(strVersion, NumberStyles.HexNumber), true);

                            CTitleMgrApp.WriteLineV("Added version " + strVersion + " to title " + strTitleID);
                            CPropUtils.CommitTransactions();
                        }
                        catch(Exception e)
                        {
                            CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                            CPropUtils.RollbackTransactions();
                        }

                    }

                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }

            return (hr);
        }

        public static int CleanOffer(string strOfferID)
        {
            int hr = HR_SUCCEEDED;

            try
            {
                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                        ws.StoredProc = "dbo.p_svc_clean_offers";

                        long lParam = Convert.ToInt64(strOfferID, 16);
                        ws.AddParameter("@bi_offer_id", lParam);

                        ws.ExecuteNonQuery();
                        ws.Close();
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }

            return (hr);
        }

        public static int EnumerateOffers(string strTitlePath)
        {
            int hr = HR_SUCCEEDED;

            try
            {
                string strTitleID = Path.GetFileName(strTitlePath);
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

                ws.StoredProc = "dbo.p_svc_enumerate_offers";
                ws.AddParameter("@i_title_id", Convert.ToInt32("0x" + strTitleID, 16));

                WstDataReader rs = ws.Execute();

                FileStream fs = new FileStream(strTitlePath + "\\offers.txt", FileMode.Create, FileAccess.Write);
                StreamWriter sw = new StreamWriter(fs);

                while( rs.Read() )
                {
                    sw.WriteLine(ExtractID(Convert.ToString(rs.GetInt64(0),16), 16));
                }

                rs.Close();
                sw.Close();
                fs.Close();
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }

            return (hr);
        }

        public static void Sync(string strTitlePath, bool bReloadCache)
        {
            string strTitleID = Path.GetFileName(strTitlePath);

            try
            {

                //
                // Run insert title
                //
                if (HR_FAILED == InsertTitle(strTitlePath))
                {
                    throw new ApplicationException("Failed to insert title in the database");
                }

                if (HR_FAILED == EnumerateOffers(strTitlePath))
                {
                    throw new ApplicationException("Failed to enumerate offers for title " + strTitlePath);
                }

                string strOffersFile = strTitlePath + "\\offers.txt";

                StreamReader sr = File.OpenText(strOffersFile);

                ArrayList actions = new ArrayList();
                string strLine = sr.ReadLine();
                while( null != strLine )
                {
                    CUODBID action = new CUODBID(strLine, UODBAction.DELETE);
                    actions.Add(action);
                    strLine = sr.ReadLine();
                }

                sr.Close();

                //
                // Delete the offers.txt file created previous step
                //
                File.Delete(strOffersFile);

                string [] controlFiles = Directory.GetFiles(strTitlePath, "*.control");

                for(int iIndex = 0; iIndex < controlFiles.Length; iIndex++)
                {
                    //only do content
                    string strID = Path.GetFileNameWithoutExtension(controlFiles[iIndex]);

                    if (!IsIDContent(strTitleID, strID))
                    {
                        continue;
                    }

                    //see if it is sps=notready
                    Ini ctlIni = new Ini(controlFiles[iIndex]);
                    if (ctlIni.GetSetting("BILLING", "SPS").ToUpper() == "NOTREADY")
                    {
                        CTitleMgrApp.WriteLine("NOTE: Skipping NotReady " + strID);
                        continue;
                    }

                    CUODBID action = null;
                    if (CTitleMgrApp.Transfer)
                        action = new CUODBID(strID, UODBAction.UPDATE_TRANSFER);
                    else
                        action = new CUODBID(strID, UODBAction.UPDATE);

                    int nIndex = actions.IndexOf(action);

                    if(-1 != nIndex)
                    {
                        actions.RemoveAt(nIndex);
                    }

                    actions.Add(action);
                }

                //do all content related actions
                foreach(CUODBID action in actions)
                {
                    if(CPropUtils.IsIDContent(strTitleID, action.ID))
                    {
                        if(!CPropContent.UODBWork(strTitleID, action.ID, action.Action))
                        {
                            throw new ApplicationException("Update UODB for " + action.ID);
                        }
                    }
                }

                CPropUpdate.Sync(strTitleID); //autoupdates get a special sync now

                if(bReloadCache)
                {
                    UpdateXKDCCache();
                    UpdateXBOSCache();
                    UpdateUACSCache();
                }

                CTitleMgrApp.WriteLine("Content Sync: Success");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
        }

        public static void Export(string strExportPath, string strTitleID)
        {
            CSourceDepot sd;

            try
            {
                sd = new CSourceDepot();

                CTitleMgrApp.WriteV("Copying files...");
                //
                // Check all the files in the repository
                //
                string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
                strExportPath += "\\" + strTitleID.ToUpper();

                sd.Sync(strTitlePath + "\\...");
                sd.Finished();

                if(!Directory.Exists(strTitlePath))
                {
                    throw (new ApplicationException("The title " + strTitleID + " doesn't exist in the repository!"));
                }

                //
                //  Create destination directory if necessary
                //
                if(!Directory.Exists(strExportPath))
                {
                    Directory.CreateDirectory(strExportPath);
                }

                //
                // Copy everything under the title under the export path
                //
                CopyDirectory(strTitlePath, strExportPath, false);

                CTitleMgrApp.WriteLineV("Success!");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                sd = null;
            }
        }

        public static void CopyFiles(string strSrcDir, string strPattern , string strDestDir)
        {
            //
            // All the classes that refer to Directory in .NET have a Move method, but not a Copy
            //
            string [] strFiles;

            if(null == strPattern)
            {
                strFiles = Directory.GetFiles(strSrcDir);
            }
            else
            {
                strFiles = Directory.GetFiles(strSrcDir, strPattern);
            }

            foreach(string strFile in strFiles)
            {
                string strDestFile = strDestDir + "\\" + Path.GetFileName(strFile);
                File.Copy( strFile, strDestFile, true);
                File.SetAttributes(strDestFile, FileAttributes.Normal);
            }
        }

        public static void CopyDirectory(string strSrcDir, string strDestDir, bool bCopyFiles)
        {
            if(!Directory.Exists(strDestDir))
            {
                Directory.CreateDirectory(strDestDir);
            }

            if(bCopyFiles)
            {
                CopyFiles(strSrcDir, null, strDestDir);
            }

            // make a reference to a directory
            DirectoryInfo diSrc = new DirectoryInfo(strSrcDir);

            // get a reference to each directory in that directory
            DirectoryInfo[] diArr = diSrc.GetDirectories();

            foreach (DirectoryInfo di in diArr)
            {
                string strDir = di.FullName;
                string strTargetDir = strDestDir + "\\" + Path.GetFileName(strDir);

                CopyDirectory(strDir, strTargetDir, true);
            }
        }

        public static void CopyDirectoryInRepository(CSourceDepot sd, string strSrcDir, string strDestDir, bool bOverwrite, bool bCopyFiles)
        {
            CTitleMgrApp.WriteLine("Importing " + strSrcDir + " into " + strDestDir + "...");
            if(!Directory.Exists(strDestDir))
            {
                Directory.CreateDirectory(strDestDir);
            }

            if(bCopyFiles)
            {
                string [] strFiles = Directory.GetFiles(strSrcDir);

                foreach(string strFile in strFiles)
                {
                    string strDestFile = strDestDir + "\\" + Path.GetFileName(strFile);
                    if(File.Exists(strDestFile))
                    {
                        string strLine = "y";
                        if(!bOverwrite)
                        {
                            if(File.GetLastWriteTime(strDestFile) > File.GetLastWriteTime(strFile))
                            {
                                CTitleMgrApp.WriteLine(Path.GetFileName(strFile) + " already exists and is more recent.");
                            }
                            CTitleMgrApp.Write("Overwrite existing file " + Path.GetFileName(strFile) + "?(y/n/a)");
                            strLine = Console.ReadLine();
                            if("a" == strLine)
                            {
                                strLine = "y";
                                bOverwrite = true;
                            }

                        }
                        if("y" == strLine)
                        {
                            sd.Edit(strDestFile);
                            File.Copy( strFile, strDestFile, true);
                            sd.Submit(strDestFile, "titlemgr: Imported " + strDestFile);
                            CTitleMgrApp.WriteLine("Overwritten " + strDestFile);
                        }
                    }
                    else
                    {
                        File.Copy( strFile, strDestFile);
                        File.SetAttributes(strDestFile, FileAttributes.Normal);
                        sd.Add(strDestFile);
                        sd.Submit(strDestFile, "titlemgr: Imported " + strDestFile);
                        CTitleMgrApp.WriteLine("Added " + strDestFile);
                    }
                }
            }

            // make a reference to a directory
            DirectoryInfo diSrc = new DirectoryInfo(strSrcDir);

            // get a reference to each directory in that directory
            DirectoryInfo[] diArr = diSrc.GetDirectories();

            foreach (DirectoryInfo di in diArr)
            {
                string strDir = di.FullName;
                string strTargetDir = strDestDir + "\\" + Path.GetFileName(strDir);

                CopyDirectoryInRepository(sd, strDir, strTargetDir, bOverwrite, true);
            }
        }

        public static void Import(string strImportPath, bool bOverwrite)
        {
            CSourceDepot sd;

            try
            {
                if(!Directory.Exists(strImportPath))
                {
                    throw (new ApplicationException("Invalid path: " + strImportPath));
                }

                sd = new CSourceDepot();

                // make a reference to a directory
                DirectoryInfo diSrc = new DirectoryInfo(strImportPath);

                // get a reference to each directory in that directory
                DirectoryInfo[] diArr = diSrc.GetDirectories();

                foreach (DirectoryInfo di in diArr)
                {
                    string strDir = di.FullName;
                    string strTargetDir = Environment.CurrentDirectory + "\\" + Path.GetFileName(strDir);

                    sd.Sync(strTargetDir + "\\...");

                    CopyDirectoryInRepository(sd, strDir, strTargetDir, bOverwrite, false);

                    sd.Finished();
                }

                CTitleMgrApp.WriteLineV("Success!");

            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                sd = null;
            }
        }

        public static bool IsInArray(string [] strArray, string str)
        {
            foreach(string strIt in strArray)
            {
                if(strIt.ToLower() == str.ToLower())
                {
                    return (true);
                }
            }

            return (false);
        }


        public static string GetIPs(string strSetting, string strSiteIndexes)
        {
            string strIPs = "";
            string [] strSiteIndexesArray = strSiteIndexes.Split(';');

            if (strSiteIndexes == "all")
            {
                foreach(DictionaryEntry section in CTitleMgrApp.Servers.Sections)
                {
                    string strSection = section.Key.ToString().Trim().ToUpper();

                    if(strSection.IndexOf("SITE.") >= 0)
                    {
                        //
                        // It is a SITE section
                        //
                        strIPs += CTitleMgrApp.Servers.GetSetting(section.Key.ToString(), strSetting) + ";";
                    }
                }
            }
            else
            {
                for(int i = 0; i < strSiteIndexesArray.Length; i++)
                {
                    string strSite = strSiteIndexesArray[i];
                    strIPs += CTitleMgrApp.Servers.GetSetting("SITE." + strSite, strSetting) + ";";
                }
            }

            if(strIPs == null)
            {
                throw new ApplicationException("Error: " + strSetting + " not present in Servers.ini");
            }

            //Remove final ;
            return strIPs.Remove(strIPs.Length - 1, 1);
        }

        public static string GetIndexes(string strSetting, string strIPs)
        {
            string strIndexes = null;
            string [] strSettingIPs = strIPs.Split(';');

            foreach (string strSettingIP in strSettingIPs)
            {
                int nIndex = CTitleMgrApp.GetServerIndex(strSetting, strSettingIP);

                if(-1 == nIndex)
                {
                    throw new ApplicationException("Error: " + strSetting + " not present in Servers.ini");
                }

                if((null == strIndexes) || (-1 == strIndexes.IndexOf(nIndex.ToString())))
                {
                    strIndexes += nIndex.ToString() + ";";
                }
            }

            if(null != strIndexes)
            {
                //Remove final ;
                return strIndexes.Remove(strIndexes.Length - 1, 1);
            }

            return strIndexes;
        }

        public static int UODBUpdate(string strTitleID, string strPackageID, bool bReloadCache)
        {

            int hr = HR_SUCCEEDED;
            CSourceDepot sd = null;
            string srcPath = Environment.CurrentDirectory;
            bool bChangesMade = false;

            try
            {
                sd = new CSourceDepot();

                //
                //  Get the list of title ids we are updating
                //
                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);

                if(null == strPackageID)
                {
                    strPackageID = "all";
                }
                if((titleIDs.Count > 1)&& ("all" != strPackageID))
                {
                    CTitleMgrApp.WriteLine("Ignoring /offerid option...");
                    strPackageID = "all";
                }

                foreach(string strTitle in titleIDs)
                {

                    //
                    //  Get the list of package ids we are updating
                    //
                    string strTitlePath = srcPath + "\\" + strTitle.ToLower();
                    string [] packageIDs = GetPackageList(strTitlePath, strPackageID);

                    foreach(string strPackage in packageIDs)
                    {
                        string strPackagePath = strTitlePath + "\\" + strPackage;
                        string strSQL2File = strPackagePath + ".sql2";

                        sd.Sync(strSQL2File);

                        if(IsIDContent(strTitle, strPackage))
                        {
                            CPropContent.UODBWork(strTitle, strPackage, UODBAction.UPDATE);
                        }
                    }

                    //do autoupdates, but no transfer
                    bool oldTransfer = CTitleMgrApp.Transfer;
                    CTitleMgrApp.Transfer = false;
                    CPropUpdate.Sync(strTitle);
                    CTitleMgrApp.Transfer = oldTransfer;

                    // when we're all done, reload the caches
                    bChangesMade = true;
                }

                CTitleMgrApp.WriteLine("UODBUpdate: Success");
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished();
                    sd = null;
                }

                if((HR_SUCCEEDED == hr) && bChangesMade && bReloadCache)
                {
                    CPropUtils.UpdateXBOSCache();
                    CPropUtils.UpdateXKDCCache();
                    CPropUtils.UpdateUACSCache();
                }
            }

            return (hr);
        }

        public static int SetLocations(string strTitleID, string strPackageID,
                                       string strXRLRoot, string strDownloadServers)
        {

            int hr = HR_SUCCEEDED;
            CSourceDepot sd = null;
            string srcPath = Environment.CurrentDirectory;

            try
            {
                //
                //  Get the list of title ids we are changing locations for
                //
                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);

                if(null == strPackageID)
                {
                    strPackageID = "all";
                }
                if((titleIDs.Count > 1)&& ("all" != strPackageID))
                {
                    CTitleMgrApp.WriteLine("Ignoring /packageid option...");
                    strPackageID = "all";
                }

                foreach(string strTitle in titleIDs)
                {

                    //
                    //  Get the list of package ids we are changing locations for
                    //
                    string strTitlePath = srcPath + "\\" + strTitle.ToLower();
                    string [] packageIDs = GetPackageList(strTitlePath, strPackageID);

                    foreach(string strPackage in packageIDs)
                    {
                        string strPackagePath = strTitlePath + "\\" + strPackage;
                        string strPackageFile = strPackagePath + ".pkg";
                        string strControlFile = strPackagePath + ".control";

                        sd = new CSourceDepot();

                        sd.Sync(strPackageFile);
                        sd.Sync(strControlFile);

                        VerifyExists(strPackageFile);
                        VerifyExists(strControlFile);

                        sd.Edit(strControlFile);

                        Ini controlIni = new Ini(strControlFile);

                        VerifyXRL(strXRLRoot);

                        if(IsIDContent(strTitle, strPackage))
                        {
                            controlIni.SetSetting("Content", "XRLRoot", strXRLRoot);
                            if(null != strDownloadServers)
                            {
                                CPropUtils.VerifyXRL(strDownloadServers);
                                controlIni.SetSetting("Content", "DownloadServers", strDownloadServers);
                            }
                        }
                        else
                        {
                            controlIni.SetSetting("Autoupd", "XRLRoot", strXRLRoot);
                            if(null != strDownloadServers)
                            {
                                CPropUtils.VerifyXRL(strDownloadServers);
                                controlIni.SetSetting("Autoupd", "DownloadServers", strDownloadServers);
                            }
                        }

                        controlIni.Save(strControlFile);
                        sd.Submit(strControlFile, "TitleMgr: Set locations");
                        CTitleMgrApp.WriteLine("Submitted changes to the control file " + strControlFile);
                        sd.Finished();
                        sd = null;

                        if(IsIDContent(strTitle, strPackage))
                        {
                            CPropContent.RebuildContent(strTitle, strPackageFile, strControlFile, false, false, null, null);
                        }
                        else
                        {
                            CPropUpdate.RebuildUpdate(strTitle, strPackageFile, strControlFile, false);
                        }
                    }
                }
            }
            catch(Exception e)
            {
                CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }
            finally
            {
                if(null != sd)
                {
                    sd.Finished(strTitleID);
                    sd = null;
                }
            }

            return (hr);
        }

        public static void SDAddEdit(CSourceDepot sd, string strSrcFile, string strDstFile, bool bBinary)
        {

            //
            // Check all the files in the repository
            //
            string strDstPath = Path.GetPathRoot(strDstFile);

            //
            //  Create destination directory if necessary
            //
            if(!Directory.Exists(strDstPath))
            {
                Directory.CreateDirectory(strDstPath);
            }

            //
            //  Do the destination files exist in sd?
            //
            bool bEditFile = File.Exists(strDstFile);

            //
            //  Check out all files in the directory
            //
            if(bEditFile)
            {
                CTitleMgrApp.WriteLineV("Checking out \"" + strDstFile + "\".");
                sd.Edit(strDstFile);
            }

            //
            //  Copy the new files over
            //
            CTitleMgrApp.WriteV("Copying \"" + strSrcFile + "\" to \"" + strDstFile + "\"...");
            File.Copy(strSrcFile, strDstFile, true);
            File.SetAttributes(strDstFile, FileAttributes.Normal);
            CTitleMgrApp.WriteLineV("Success");


            if(!bEditFile)
            {
                CTitleMgrApp.WriteLine("Adding \"" + strDstFile + "\".");
                if(bBinary)
                {
                    sd.AddBinary(strDstFile);
                }
                else
                {
                    sd.Add(strDstFile);
                }
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\ini.cs ===
//
// Iniuration settings
//  
//  Provides global management of config settings.
// 
//  To use:
//
//      Ini.GetSetting("foo"); 
//          - returns the string value of 'foo' as specified
//            in the [global] section of the assembly's ini file, 
//            or empty string if not found.
//
//      Ini.GetSetting("mysection", "foo");
//          - same as above, but gets the setting from the 
//            specified section of the ini file.
//         
//  Ini files:
//      typical windows ini file format:
// 
//          ; this is a comment
//          [global]
//          MyFirstSetting=a value
//
//          [another section]
//          MyOtherSetting=another Value
//  
//      everything to the left of the first "=" is the name,
//      everything to the right is the value.
//
//      Note: all setting names/sections are case insensitive.
//
//  File name:
//      The ini file has the same name as the 
//      assembly this code is compiled, with the extension ".ini"
//
//  Location:
//      The same directory as the assembly is checked first.
//      If not found, the parent directory is checked.
//      If still not found, a warning event is logged, and all
//       calls to GetSetting() return an empty string.
//  
//  

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using xonline.common.service;

namespace xonline.tools.titlemgr 
{

public class Ini
{
    private Hashtable _configSections = null;
    private bool _bChanged = false;

    public string GetSetting(string setting)
    {
        return GetSetting("global", setting);
    }
    
    /// <summary>
    ///  Adds, changes or removes a setting.  Pass in a null value
    ///  to remove a setting
    /// </summary>
    /// <param name="section"></param>
    /// <param name="setting"></param>
    /// <param name="value"></param>

    public void SetSetting(string section, string setting, string value)
    {
        if(_configSections == null)
        {
            if(value == null)
                return;

            _configSections = new Hashtable();
        }

        StringDictionary sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if(sectionSettings == null)
        {
            if(value == null)
                return;

            sectionSettings = new StringDictionary();
            _configSections[section.ToUpper()] = sectionSettings;
        }

        if(value != null)
            sectionSettings[setting.ToUpper()] = value;
        else
            sectionSettings.Remove(setting.ToUpper());

        _bChanged = true;
    }

    public void Save(string IniPath)
    {
        StreamWriter writer = File.CreateText(IniPath);

        try
        {
            foreach(DictionaryEntry section in _configSections)
            {
                writer.WriteLine("[" + section.Key.ToString().ToUpper() + "]");

                StringDictionary sd = (StringDictionary)section.Value;

                foreach(DictionaryEntry setting in sd)
                {
                    writer.WriteLine(setting.Key.ToString().ToUpper() + "=" + setting.Value.ToString());
                }

                writer.WriteLine("");
            }
        }
        finally
        {
            writer.Close();
        }

        _bChanged = false;
    }

    public string GetSetting(string section, string setting)
    {
        StringDictionary sectionSettings;
        string val = "";
        
        if (_configSections == null)
        {
            goto Cleanup;
        }        
        
        sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if (sectionSettings == null)
        {
            goto Cleanup;
        }
        
        val = sectionSettings[setting.ToUpper()];
        if(val == null)
            val = "";
        
Cleanup:        
        return val;
    }
    



    public Ini(string iniPath)
    {
        Init(iniPath);
    }

    public Ini()
    {
        Init(null);
    }

    private void Init(string iniPath)
    {
        StreamReader reader = null;
        string line;
        Hashtable configSections = null;
        string currentSection = "global";
        string name;
        string val;
        int n;
        
        
        if(iniPath != null)
        {
            try
            {
                if (!File.Exists(iniPath))
                {
                    return;
                }
        
                reader = File.OpenText(iniPath);
                for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                {
                    line = line.Trim();
                
                    // emtpy line
                    if (line == "")
                        continue;
                    
                    // comment
                    if (line.StartsWith(";"))
                        continue;
                
                    // new section    
                    if (line.StartsWith("["))
                    {
                    
                        n = line.IndexOf(']');
                        if (n <= 1)
                        {
                            return;
                        }
                    
                        currentSection = line.Substring(1, n-1).ToUpper();
                        continue;
                    }
                
                    line = line.Trim();
                
                    // continuation char
                
                    while (line.EndsWith("\\"))
                    {
                        // REVIEW: is this correct?
                        line = line.Substring(0, line.Length-1);
                    
                        string line2 = reader.ReadLine();
                        if (line2 == null)
                        {
                            return;
                        }
                    
                        line += line2.TrimEnd(null);
                    }
                
                
                    // name/value pair
                    n = line.IndexOf("=");
                    if (n <= 0)
                    {
                        return;
                    }
                
                    name = line.Substring(0, n).Trim().ToUpper();
                
                    if (n < line.Length-1)
                    {
                        val = line.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        val = "";
                    }
                
                    if (configSections == null)
                    {
                        configSections = new Hashtable();
                    }
                    if (configSections[currentSection] == null)
                    {
                        configSections[currentSection] = new StringDictionary();
                    }
                
                    ((StringDictionary)(configSections[currentSection]))[name] = val;
                
                }
                _configSections = configSections;
            }
            finally
            {
                if(null != reader)
                {
                    reader.Close();
                }
            }
        }
    }
    
    public StringDictionary GetSection(string section)
    {
        return (_configSections == null ? null : (StringDictionary)_configSections[section.ToUpper()]);
    }

    public bool Changed
    {
        get
        {
            return _bChanged;
        }
    }

    public Hashtable Sections
    {
        get
        {
            return _configSections;
        }
    }
}

internal class IniUtil
{
    public static string[,] GetParams(string str)
    {
        string[] pairs = str.Split( new char[] { ';' } );
        string[] param;
        string[,] paramList = new string[pairs.Length, 2];
        char[] pairDelim = new char[] { '=' };

        for (int n = 0; n < pairs.Length; n++)
        {
            param = pairs[n].Split( pairDelim );

            if (param.Length != 2)
            {
                return null;
            }

            paramList[n,0] = param[0].ToUpper();
            paramList[n,1] = param[1];
        }

        return paramList;

    }
    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\DiffTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\sd.cs ===
using System;
using System.Collections;
using SDAPILib;

namespace xonline.tools.titlemgr 
{
    /// <summary>
    /// 
    /// </summary>
    public class CSourceDepot : ISDClientUser
    {
        protected enum SD_OPERATION
        {
            SD_NOOP,
            SD_FILES,
            SD_EDIT,
            SD_SYNC,
            SD_SUBMIT,
            SD_ADD,
            SD_REVERT,
			SD_DELETE,
			SD_OPENED
        };

        protected SD_OPERATION _currentOp = SD_OPERATION.SD_NOOP;
        protected SDAPIClass _sdapi = null;
        protected ArrayList _files = null;

        public CSourceDepot()
        {
            _sdapi = new SDAPIClass();

            if(CTitleMgrApp.SDPort != null)
                _sdapi.SetPort(CTitleMgrApp.SDPort);
            if(CTitleMgrApp.SDClient != null)
                _sdapi.SetClient(CTitleMgrApp.SDClient);
        }

        public static string AddQuotes(string s)
        {
            return "\"" + s + "\"";
        }
	
        /// <summary>
        /// Wrapper for "sd files"
        /// </summary>
        /// <param name="filespec"></param>
        /// <param name="files"></param>
        /// <returns></returns>
        public void Files(string filespec, out string[] files)
        {
            try
            {
                files = null;
                _files = new ArrayList();
                _currentOp = SD_OPERATION.SD_FILES;

                //
                //  Run the "sd files" command, indicating structured output so we
                //  can get the list of files from the property bag.
                //

                _sdapi.Run("files -d " + AddQuotes(filespec), this, 1);

                //
                //  Now copy the resulting list into the output parameters
                //

                files = new String[_files.Count];
                _files.CopyTo(files);

                //
                //  Kill the working list
                //

                _files = null;
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        /// <summary>
        /// Wrapper for "sd sync"
        /// </summary>
        /// <param name="filespec"></param>
        /// <returns></returns>
        public void Sync(string filespec)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_SYNC;
                _sdapi.Run("sync " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        /// <summary>
        /// Wrapper for "sd edit"
        /// </summary>
        /// <param name="filespec"></param>
        /// <returns></returns>
        public void Edit(string filespec)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_EDIT;
                _sdapi.Run("edit " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        /// <summary>
        /// Wrapper for "sd submit"
        /// </summary>
        /// <param name="filespec"></param>
        /// <returns></returns>
        public void Submit(string filespec, string desc)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_SUBMIT;
                _sdapi.Run("submit -C \"" + desc + "\" " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        /// <summary>
        /// Wrapper for "sd add"
        /// </summary>
        /// <param name="filespec"></param>
        /// <returns></returns>
        public void Add(string filespec)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_ADD;
                _sdapi.Run("add " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        public void AddBinary(string filespec)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_ADD;
                _sdapi.Run("add -t binary " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

        public void Revert(string filespec)
        {
            try
            {
                _currentOp = SD_OPERATION.SD_REVERT;
                _sdapi.Run("revert " + AddQuotes(filespec), this, 0);
            }
            finally
            {
                _currentOp = SD_OPERATION.SD_NOOP;
            }
        }

		public void Delete(string filespec)
		{
			try
			{
				_currentOp = SD_OPERATION.SD_DELETE;
				_sdapi.Run("delete " + AddQuotes(filespec), this, 0);
			}
			finally
			{
				_currentOp = SD_OPERATION.SD_NOOP;
			}
		}

		/// <summary>
		/// Wrapper for "sd submit"
		/// </summary>
		/// <param name="filespec"></param>
		/// <returns></returns>
		public void SubmitMany(string filespec)
		{
			try
			{
				_currentOp = SD_OPERATION.SD_SUBMIT;
				_sdapi.Run("submit " + AddQuotes(filespec), this, 0);
			}
			finally
			{
				_currentOp = SD_OPERATION.SD_NOOP;
			}
		}

		
		/// <summary>
		/// Wrapper for "sd opened"
		/// </summary>
		/// <param name="filespec"></param>
		/// <param name="files"></param>
		/// <returns></returns>
		public void Opened(string filespec, out string[] files)
		{
			try
			{
				files = null;
				_files = new ArrayList();
				_currentOp = SD_OPERATION.SD_OPENED;

				//
				//  Run the "sd opened" command, indicating structured output so we
				//  can get the list of files from the property bag.
				//

				_sdapi.Run("opened " + AddQuotes(filespec), this, 1);

				//
				//  Now copy the resulting list into the output parameters
				//

				files = new String[_files.Count];
				_files.CopyTo(files);

				//
				//  Kill the working list
				//

				_files = null;
			}
			finally
			{
				_currentOp = SD_OPERATION.SD_NOOP;
			}
		}

        /// <summary>
        /// Source Depot callback methods, ISDClientUser.
        /// </summary>
        

        public void Finished()
        {
            if(_sdapi != null)
            {
                _sdapi.Final();
                _sdapi = null;
            }
        }

        public void Finished(string strTitleID)
        {
            if(_sdapi != null)
            {
                Revert(Environment.CurrentDirectory + "\\" + strTitleID + "\\...");
                _sdapi.Final();
                _sdapi = null;
            }
        }

        public void OutputBinary(ref byte pbData, int cbData)
        {
        }

        public void OutputText(string pszText, int cchText)
        {
        }

        public void OutputInfo(int cIndent, string pszInfo)
        {
        }

        public void OutputWarning(int cIndent, string pszWarning, int fEmptyReason)
        {
        }

        public void OutputError(string pszError)
        {
            CTitleMgrApp.WriteLine(pszError);
        }

        public void OutputStructured(ISDVars pVars)
        {
            switch(_currentOp)
            {
                case SD_OPERATION.SD_FILES:
				case SD_OPERATION.SD_OPENED:

                    ISDVars2 pVars2 = (ISDVars2)pVars;
                    ISDVar pVar;

                    //  Figure out how many files there are in the list
                    pVar = pVars2.GetVar("depotFile");
                    _files.Add(pVar.GetByteString());

                    break;

                default:
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\test\CRepositoryTest.cs ===
using System;
using NUnit.Framework;
using TitleMgr;

namespace xonline.tools.titlemgr.test 
{
    /// <summary>
    /// NUnit test class for CRepository class.
    /// </summary>
    [TestFixture]
    public class CRepositoryTest
    {
        [Test]
        public static void StatsConfigTest()
        {
            throw new Exception("not yet implemented");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\stats_schema.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.titlemgr  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Title {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Leaderboard")]
        public TitleLeaderboard[] Leaderboard;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string schema_version;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string default_locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class TitleLeaderboard {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public TitleLeaderboardLocalizedName[] Names;
        
        /// <remarks/>
        public string FriendlyAdminName;
        
        /// <remarks/>
        public int Reset;
        
        /// <remarks/>
        public int DecayDays;
        
        /// <remarks/>
        public bool TopOneHundred;
        
        /// <remarks/>
        public TitleLeaderboardAttachments Attachments;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Attribute", IsNullable=false)]
        public TitleLeaderboardAttribute[] RawAttributes;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("FormattedValue", IsNullable=false)]
        public TitleLeaderboardFormattedValue[] FormattedValues;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int id;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class TitleLeaderboardLocalizedName {
        
        /// <remarks/>
        public string Name;
        
        /// <remarks/>
        public string Locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class TitleLeaderboardFormattedValue {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public TitleLeaderboardLocalizedName[] Names;
        
        /// <remarks/>
        public string NameID;
        
        /// <remarks/>
        public AttributeUnit Type;
        
        /// <remarks/>
        public string FriendlyAdminName;
        
        /// <remarks/>
        public string Formula;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum AttributeUnit {
        
        /// <remarks/>
        Integer,
        
        /// <remarks/>
        Float,
        
        /// <remarks/>
        Percent,
        
        /// <remarks/>
        GamerTag,
        
        /// <remarks/>
        TimeStamp,
        
        /// <remarks/>
        MilliSecond,
        
        /// <remarks/>
        TenMilliSecond,
        
        /// <remarks/>
        HundredMilliSecond,
        
        /// <remarks/>
        Second,
        
        /// <remarks/>
        Minute,
        
        /// <remarks/>
        Hours,
        
        /// <remarks/>
        Days,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class TitleLeaderboardAttribute {
        
        /// <remarks/>
        public bool Puid;
        
        /// <remarks/>
        public int Index;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class TitleLeaderboardAttachments {
        
        /// <remarks/>
        public int Uploads;
        
        /// <remarks/>
        public int Size;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\test\CTitleMgrTest.cs ===
using System;
using System.Diagnostics;
using System.IO;
using NUnit.Framework;

namespace xonline.tools.titlemgr.test 
{
    [TestFixture]
    public class CTitleMgrTest
    {
        // for this unit test to work, there must be a source depot server running 
        // at localhost:1666
        [Test]
        public void StatsV3Test()
        {
            CLog log = new CLog();
            log.WriteLine("============================================================");
            log.WriteLine("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test starting");
            log.WriteLine("============================================================");

            InitializeTestRepository(log);

            string sArgs = "/lock:ignore /sdclient:TITLEMGR_UNITTEST /sdport:localhost:1666 /titleid:ffff1234";
            log.WriteLine("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test: "
                + "Running titlemgr.exe with the following command line parameters: "
                + sArgs);

            Process p = new Process();
            p.StartInfo.FileName = "titlemgr.exe";
            p.StartInfo.Arguments = sArgs;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = false;
            p.Start();

            log.WriteLine("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test: "
                + "Output to stdout from titlemgr:");
            log.WriteLine(p.StandardOutput.ReadToEnd());
            p.WaitForExit();

            string sLogFile = "last.log";
            if (File.Exists(sLogFile))
            {
                log.WriteLineV("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test: "
                    + "Content of " + sLogFile + ":");
                FileStream fs = new FileStream(sLogFile, FileMode.Open, FileAccess.Read);
                StreamReader sr = new StreamReader(fs);
                log.WriteLineV(sr.ReadToEnd());
            }
            else
            {
                log.WriteLineV("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test: "
                    + "Log file " + sLogFile + "does not exist.");
            }

            log.WriteLine("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test complete");
        }

        private void InitializeTestRepository(CLog log)
        {
            // make sure there is a server where we expect it to be...
            Process p = new Process();
            p.StartInfo.FileName = "sd.exe";
            p.StartInfo.Arguments = "-p localhost:1666 -c TITLEMGR_UNITTEST info";
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = false;
            p.Start();

            string sSdInfo = p.StandardOutput.ReadToEnd();
            log.WriteLine("Xbox.Tools.Framework.Test.CTitleMgrTest.StatsV3Test: "
                + "Output from sd info: ");
            log.WriteLine(sSdInfo);
            if (sSdInfo.IndexOf("Client name: TITLEMGR_UNITTEST") == -1
                || sSdInfo.IndexOf("Server address: localhost:1666") == -1)
            {
            }

            Assert.Fail();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\WinTDiff\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\DiffTest\ini.cs ===
//
// Iniuration settings
//  
//  Provides global management of config settings.
// 
//  To use:
//
//      Ini.GetSetting("foo"); 
//          - returns the string value of 'foo' as specified
//            in the [global] section of the assembly's ini file, 
//            or empty string if not found.
//
//      Ini.GetSetting("mysection", "foo");
//          - same as above, but gets the setting from the 
//            specified section of the ini file.
//         
//  Ini files:
//      typical windows ini file format:
// 
//          ; this is a comment
//          [global]
//          MyFirstSetting=a value
//
//          [another section]
//          MyOtherSetting=another Value
//  
//      everything to the left of the first "=" is the name,
//      everything to the right is the value.
//
//      Note: all setting names/sections are case insensitive.
//
//  File name:
//      The ini file has the same name as the 
//      assembly this code is compiled, with the extension ".ini"
//
//  Location:
//      The same directory as the assembly is checked first.
//      If not found, the parent directory is checked.
//      If still not found, a warning event is logged, and all
//       calls to GetSetting() return an empty string.
//  
//  

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using xonline.common.service;

namespace xonline.tools.titlemgr.difftest 
{

public class Ini
{
    private Hashtable _configSections = null;
    private bool _bChanged = false;

    public string GetSetting(string setting)
    {
        return GetSetting("global", setting);
    }
    
    /// <summary>
    ///  Adds, changes or removes a setting.  Pass in a null value
    ///  to remove a setting
    /// </summary>
    /// <param name="section"></param>
    /// <param name="setting"></param>
    /// <param name="value"></param>

    public void SetSetting(string section, string setting, string value)
    {
        if(_configSections == null)
        {
            if(value == null)
                return;

            _configSections = new Hashtable();
        }

        StringDictionary sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if(sectionSettings == null)
        {
            if(value == null)
                return;

            sectionSettings = new StringDictionary();
            _configSections[section.ToUpper()] = sectionSettings;
        }

        if(value != null)
            sectionSettings[setting.ToUpper()] = value;
        else
            sectionSettings.Remove(setting.ToUpper());

        _bChanged = true;
    }

    public void Save(string IniPath)
    {
        StreamWriter writer = File.CreateText(IniPath);

        try
        {
            foreach(DictionaryEntry section in _configSections)
            {
                writer.WriteLine("[" + section.Key.ToString().ToUpper() + "]");

                StringDictionary sd = (StringDictionary)section.Value;

                foreach(DictionaryEntry setting in sd)
                {
                    writer.WriteLine(setting.Key.ToString().ToUpper() + "=" + setting.Value.ToString());
                }

                writer.WriteLine("");
            }
        }
        finally
        {
            writer.Close();
        }

        _bChanged = false;
    }

    public string GetSetting(string section, string setting)
    {
        StringDictionary sectionSettings;
        string val = "";
        
        if (_configSections == null)
        {
            goto Cleanup;
        }        
        
        sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if (sectionSettings == null)
        {
            goto Cleanup;
        }
        
        val = sectionSettings[setting.ToUpper()];
        if(val == null)
            val = "";
        
Cleanup:        
        return val;
    }
    



    public Ini(string iniPath)
    {
        Init(iniPath);
    }

    public Ini()
    {
        Init(null);
    }

    private void Init(string iniPath)
    {
        StreamReader reader = null;
        string line;
        Hashtable configSections = null;
        string currentSection = "global";
        string name;
        string val;
        int n;
        
        
        if(iniPath != null)
        {
            try
            {
                if (!File.Exists(iniPath))
                {
                    return;
                }
        
                reader = File.OpenText(iniPath);
                for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                {
                    line = line.Trim();
                
                    // emtpy line
                    if (line == "")
                        continue;
                    
                    // comment
                    if (line.StartsWith(";"))
                        continue;
                
                    // new section    
                    if (line.StartsWith("["))
                    {
                    
                        n = line.IndexOf(']');
                        if (n <= 1)
                        {
                            return;
                        }
                    
                        currentSection = line.Substring(1, n-1).ToUpper();
                        continue;
                    }
                
                    line = line.Trim();
                
                    // continuation char
                
                    while (line.EndsWith("\\"))
                    {
                        // REVIEW: is this correct?
                        line = line.Substring(0, line.Length-1);
                    
                        string line2 = reader.ReadLine();
                        if (line2 == null)
                        {
                            return;
                        }
                    
                        line += line2.TrimEnd(null);
                    }
                
                
                    // name/value pair
                    n = line.IndexOf("=");
                    if (n <= 0)
                    {
                        return;
                    }
                
                    name = line.Substring(0, n).Trim().ToUpper();
                
                    if (n < line.Length-1)
                    {
                        val = line.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        val = "";
                    }
                
                    if (configSections == null)
                    {
                        configSections = new Hashtable();
                    }
                    if (configSections[currentSection] == null)
                    {
                        configSections[currentSection] = new StringDictionary();
                    }
                
                    ((StringDictionary)(configSections[currentSection]))[name] = val;
                
                }
                _configSections = configSections;
            }
            finally
            {
                if(null != reader)
                {
                    reader.Close();
                }
            }
        }
    }
    
    public StringDictionary GetSection(string section)
    {
        return (_configSections == null ? null : (StringDictionary)_configSections[section.ToUpper()]);
    }

    public bool Changed
    {
        get
        {
            return _bChanged;
        }
    }

    public Hashtable Sections
    {
        get
        {
            return _configSections;
        }
    }
}

internal class IniUtil
{
    public static string[,] GetParams(string str)
    {
        string[] pairs = str.Split( new char[] { ';' } );
        string[] param;
        string[,] paramList = new string[pairs.Length, 2];
        char[] pairDelim = new char[] { '=' };

        for (int n = 0; n < pairs.Length; n++)
        {
            param = pairs[n].Split( pairDelim );

            if (param.Length != 2)
            {
                return null;
            }

            paramList[n,0] = param[0].ToUpper();
            paramList[n,1] = param[1];
        }

        return paramList;

    }
    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\unittest\v3xsd\StatsV3xmlTest.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using NUnit.Framework;
using xonline.tools.framework;
using xonline.tools.framework.test.v3xsd;

namespace xonline.tools.titlemgr.unittest.v3xsd 
{
    [TestFixture]
    public class CStatsV3XmlTest
    {
        [Test]
        public void CStatsV3RoundTrip()
        {
            // this is a cheezy test, since it doesn't really test that I got the xml schema right. However, it does
            // at least confirm that the code generated by xsd can be used to read and write xml data.

            CTitle title = new CTitle();
            title.TitleID = "abcdef01";
            title.Version = "00000100";
            title.UnitLeaderboardDecayConstant = "5";
            title.Default_Locale = "en-US";

            title.LeaderboardContainer = new CLeaderboardContainer[4];
            title.LeaderboardContainer[0] = new CLeaderboardContainer();
            title.LeaderboardContainer[0].type = LeaderboardTypeType.individual;
            title.LeaderboardContainer[1] = new CLeaderboardContainer();
            title.LeaderboardContainer[1].type = LeaderboardTypeType.units;
            title.LeaderboardContainer[2] = new CLeaderboardContainer();
            title.LeaderboardContainer[2].type = LeaderboardTypeType.teams;
            title.LeaderboardContainer[3] = new CLeaderboardContainer();
            title.LeaderboardContainer[3].type = LeaderboardTypeType.competitions;

            title.LeaderboardContainer[0].Leaderboard = new CLeaderboard[2];
            title.LeaderboardContainer[1].Leaderboard = new CLeaderboard[1];
            title.LeaderboardContainer[2].Leaderboard = new CLeaderboard[0];

            title.LeaderboardContainer[0].Leaderboard[0] = new CLeaderboard();
            title.LeaderboardContainer[0].Leaderboard[0].ID= "1";
            title.LeaderboardContainer[0].Leaderboard[0].Reset = "0";
            title.LeaderboardContainer[0].Leaderboard[0].DecayDays= "1";
            title.LeaderboardContainer[0].Leaderboard[0].TopOneHundred = false;
            title.LeaderboardContainer[0].Leaderboard[0].Arbitrate = false;
            title.LeaderboardContainer[0].Leaderboard[0].ELO = new CELO();
            title.LeaderboardContainer[0].Leaderboard[0].ELO.InitialPlayerRating = "1";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.RatingScaleFactor = "1";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.ExponentialBase = ELOExponentialBaseType.E;
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray = new CMaxWeightRatingRange[1];
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0] = new CMaxWeightRatingRange();
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0].maxweight = "10";
            title.LeaderboardContainer[0].Leaderboard[0].ELO.MaxWeightRatingRangeArray[0].start = "1";
            title.LeaderboardContainer[0].Leaderboard[0].Names = new CLocalizedName[1];
            title.LeaderboardContainer[0].Leaderboard[0].Names[0] = new CLocalizedName();
            title.LeaderboardContainer[0].Leaderboard[0].Names[0].Locale = "en-US";
            title.LeaderboardContainer[0].Leaderboard[0].Names[0].Name = "en-US name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues = new CFormattedValue[1];
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0] = new CFormattedValue();
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names = new CLocalizedName[1];
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0] = new CLocalizedName();
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0].Locale = "en-US";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Names[0].Name = "en-US name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].NameID = "1";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Type = FormattedValueReturnType.Integer;
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].FriendlyAdminName = "name";
            title.LeaderboardContainer[0].Leaderboard[0].FormattedValues[0].Formula = "formula";
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes = new CAttribute[1];
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0] = new CAttribute();
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0].Index = "1";
            title.LeaderboardContainer[0].Leaderboard[0].RawAttributes[0].PUID = false;

            title.LeaderboardContainer[0].Leaderboard[1] = new CLeaderboard();
            title.LeaderboardContainer[0].Leaderboard[1].ID= "2";

            string sFilename = "StatsV3XmlTestRoundTrip.xml";
            FileStream fs = new FileStream(sFilename, FileMode.Create);
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(CTitle));
            xmlSerializer.Serialize(fs, title);
            fs.Close();

            fs = new FileStream(sFilename, FileMode.Open);
            CTitle title2 = (CTitle)xmlSerializer.Deserialize(fs);
            fs.Close();
            
            Assert.AreEqual(title.TitleID, title2.TitleID);
            Assert.AreEqual(title.Version, title2.Version);
            Assert.AreEqual(title.UnitLeaderboardDecayConstant, title2.UnitLeaderboardDecayConstant);
            Assert.AreEqual(title.Default_Locale, title2.Default_Locale);
            for (int i1 = 0; i1 < title.LeaderboardContainer.Length; ++i1)
            {
                if (title.LeaderboardContainer[i1] == null) continue;
                
                Assert.AreEqual(title.LeaderboardContainer[i1].type, title2.LeaderboardContainer[i1].type);
                if (title.LeaderboardContainer[i1].Leaderboard == null) continue;
                
                for (int i2 = 0; i2 < title.LeaderboardContainer[i1].Leaderboard.Length; ++i2)
                {
                    if (title.LeaderboardContainer[i1].Leaderboard[i2] == null) continue;

                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ID, title2.LeaderboardContainer[i1].Leaderboard[i2].ID);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Reset, title2.LeaderboardContainer[i1].Leaderboard[i2].Reset);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].DecayDays, title2.LeaderboardContainer[i1].Leaderboard[i2].DecayDays);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].TopOneHundred, title2.LeaderboardContainer[i1].Leaderboard[i2].TopOneHundred);
                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Arbitrate, title2.LeaderboardContainer[i1].Leaderboard[i2].Arbitrate);
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].ELO != null)
                    {
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.InitialPlayerRating, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.InitialPlayerRating);
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.RatingScaleFactor, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.RatingScaleFactor);
                        Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.ExponentialBase, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.ExponentialBase);
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].maxweight, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].maxweight);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].start, title2.LeaderboardContainer[i1].Leaderboard[i2].ELO.MaxWeightRatingRangeArray[i3].start);
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].Names != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].Names.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Locale, title2.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Locale);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Name, title2.LeaderboardContainer[i1].Leaderboard[i2].Names[i3].Name);
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].NameID, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].NameID);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Type, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Type);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].FriendlyAdminName, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].FriendlyAdminName);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Formula, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Formula);
                            if (title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names != null)
                            {
                                for (int i4 = 0; i4 < title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names.Length; ++i4)
                                {
                                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Locale, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Locale);
                                    Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Name, title2.LeaderboardContainer[i1].Leaderboard[i2].FormattedValues[i3].Names[i4].Name);
                                }
                            }
                        }
                    }
                    if (title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes != null)
                    {
                        for (int i3 = 0; i3 < title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes.Length; ++i3)
                        {
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].Index, title2.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].Index);
                            Assert.AreEqual(title.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].PUID, title2.LeaderboardContainer[i1].Leaderboard[i2].RawAttributes[i3].PUID);
                        }
                    }
                }
            }

        }
        public void CStatsV3Deserialize()
        {
            // use text writer to generate an XML file that tests the boundary conditions of the schema.
            // don't want to use the CTitle class generated by xsd, because that doesn't independantly
            // implement the schema. What we're really trying to unit test here is the xsd, not the C#
            // class that was generated by xsd.exe
            
            string sFilename = "StatsV3BoundaryConditions.xml";
            FileStream fs = new FileStream(sFilename, FileMode.Create);
            XmlTextWriter xmlTextWriter = new XmlTextWriter(fs, null);
            xmlTextWriter.Formatting = Formatting.Indented;

            /*
            Console.WriteLine("CStatsV3Deserialize::Creating XmlSerializer(typeof(CTitle))");
            XmlSerializer xmlsTitle = new XmlSerializer(typeof(CTitle));
            string sPath = ".\\ValidStatsV3.xsc";
            Console.WriteLine("CStatsV3Deserialize::Opening xml file '" + sPath + "' which should parse correctly");
            FileStream fs = new FileStream(".\\ValidStatsV3.xsc", FileMode.Open);
            Console.WriteLine("CStatsV3Deserialize::Deserializing file");
            CTitle title = (CTitle)xmlsTitle.Deserialize(fs);
            Console.WriteLine("CStatsV3Deserialize::Deserializing complete! Checking created object");

            Assert.AreEqual("3.0", title.Version);
            Assert.AreEqual("baadf00d", title.TitleID);
            Assert.AreEqual("en-US", title.Default_Locale);

            Assert.AreEqual(LeaderboardTypeType.individual , title.LeaderboardContainer[0].type);
            */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\titlemgr.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Globalization;
using System.Security.Cryptography;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Resources;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.common.tools.console;
using System.Xml;

using xonline.tools.framework;

namespace xonline.tools.titlemgr
{
    class CTitleMgrApp
    {
        private const string c_sServersIniFileName = "servers.ini";
        private static Ini s_iniServers;
        private static CTitleMgrLog s_log;
        public static CTitleMgr s_titleMgr;

        // default values used for optional command line parameters
        private const uint c_uiDefaultQueryPartitionId = 1;

        // legacy begin //
        static NamedArgParser   _args       = null;
        static bool             _force      = false;
        static bool             _transfer   = true;
        static string           _sdport     = null;
        static string           _sdclient   = null;
        static string           _sqluser    = null;
        static string           _sqlpwd     = null;
        static bool             _stop       = false;
        static Queue            _commands   = null;
        static int              _football   = -1;
        static string           _titleid    = null;
        static int              _hr         = CPropUtils.HR_FAILED;
        static bool             _bDefaultUpdate = false;
        // legacy end //

        // this is a list of all the exes and dlls that titlemgr.exe depends on
        // for all it's functionality
        static string [] m_rgsSupportBins= {
            "wsreaderlib.dll",
            "sdapi.dll",
            "SDAPILib.dll",
            "sd.exe",
            "excel.dll",
            "buildupdate.exe",
            "delnode.exe",
            "rebuildcontent.exe",
            "rebuildupdate.exe",
            "xbecert.exe",
            "xcontent.dll",
            "xmltosql.exe",
            "xpatch.exe",
            "osql.exe"
        };

        static string [] m_rgsNameArgParserTags = {
            "?",
            "help",
            "sdport",
            "sdclient",
            "sqluser",
            "sqlpwd",
            "sync",
            "titleid",
            "resetlb",
            "removeuserfromlb",
            "lb",
            "lbtype",

            // I have no idea what 'deletelb' would do to a
            // stats v2 or v3 title that uses stats.xml to define
            // leaderboards, so I'm disabling this command
            // If we need to remove a leaderboard on an old title,
            // we can edit the ini file by hand.
            //"deletelb",

            "esrb",
            "cluster",
            "syncwebdb",
            "syncstats",
            "progress",
            "syncnpdb",
            "stats",
            "xms",
            "droptable",
            "matchdb",
            "control",
            "noreload",
            "notransfer",
            "uodbupdate",
            "content",
            "autoupd",
            "offerid",
            "updateid",
            "xrlroot",
            "startdate",
            "enddate",
            "transfer",
            "downloadservers",
            "statsdb",
            "new",
            "version",
            "pathtoxms",
            "titledescription",
            "overwrite",
            "translate",
            "force",
            "adddefault",
            "defaulttemplate",
            "check",
            "exempt",
            "markexempt",
            "template",
            "sps",
            "resubmit",
            "site",
            "startindex",
            "disable",
            "enable",
            "changebasever",
            "addbasever",
            "full",
            "makefull",
            "verbose",
            "removeupdate",
            "lock",
            "julyversion",
            "enableupdate",
            "reloadfrontdoors",
            "injectboids",
            "renew",
            "convert",
            "from",
            "to",
            "voucher",
            "defaultlocale",
            "report",
            "serviceid",
            "query",
            "querytype",
            "partition",
            "syncquery",
            "alternatetitleids",
            "syncalternatetitleids",
            "syncalerts",
            "timeout",
            "lspsite",
            "deletesite",
            "deleteservice",
            "synclspsite",
            "gameconfig",
            "syncgameconfig"
        };


        // used to parse the ssc xml files.  Used for LSP site and service management.
        protected const string sscXMLNameSpacePrefix = "ns1";
        protected const string sscXMLNameSpaceURI    = "urn:PartnerData";
        protected const string sscXMLSitePath        = "/ns1:Root/ns1:Site";
        protected const string sscXMLServicePath     = "/ns1:Root/ns1:Service";

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] rawArgs)
        {
            // NOTE: Titlemgr is in the process of being rewritten. The new structure of titlemgr is
            // for this file to simply be a command line shell for titlemgr. It will parse command
            // line arguments, create a CTitleMgr object, and invoke the appropriate methods on it.
            // However, at the moment, the CTitleMgr object performs only a subset of the complete
            // titlemgr functionality, so this main function is a bit of a mess, since it has to
            // do some things the old way and some things the new way, often repeating certain
            // set up work twice. Such is life until the rewrite is complete. The motivation for
            // the CTitleMgr class is so title management functionality can be invoked by things
            // other than titlemgr.exe, such as the webwidget we are building to allow partners to
            // prop their own content to partnernet.

            // First we want to get our log open. We need to do this outside the
            // main try block below, because the corresponding finally block needs
            // to use the log. However, before we can open the log, we have to open
            // the ini file because CTitleMgrLog wants to check it for [SERVERS] LOGDIR

            // I'm not wrapping these lines in a try block, because all I'd do is output
            // an error to the console anyway, which the runtime will do for me quite nicely
            string sServersIniPath
                = CPathUtil.AddPathTerminator(Environment.CurrentDirectory)
                + c_sServersIniFileName;
            if(!File.Exists(sServersIniPath))
            {
                Console.WriteLine("Error: Could not open " + sServersIniPath);
                return 1;
            }
            s_iniServers = new Ini(sServersIniPath);

            // Now create the log object
            s_log = new CTitleMgrLog(s_iniServers);

            // default log level is a bit more detailed than what
            // goes to the console - should capture errors and surprises,
            // but not generate huge logs by default
            s_log.Level = CLog.LOGFILE;

            // before we go any further, log the command line
            s_log.LogFile(Environment.CommandLine);

            // let the user know where they can find this log
            s_log.Console("Note: log can be found at "+s_log.LogPathAndName);

            // now that we have the log object in hand, open a try block
            try
            {
                _args = new NamedArgParser(m_rgsNameArgParserTags);

                if (!_args.Parse(rawArgs))
                {
                    // An invalid argument was specified, complain and exit
                    Help();
                    s_log.Console("Invalid Argument: " + _args.InvalidArgText);
                    return 1;
                }

                // If no arguments were specified, or /? or /help were specified, then
                // give the user some help
                if (_args.Count == 0 || _args["?"] != null || _args["help"] != null)
                {
                    Help();
                    return 1;
                }

                // Set the verbosity level on the log
                // Default level is LOGFILE, set above.
                // Anything sent to the log at CONSOLE level will be sent
                // to System.Console, no matter what the verbosity
                // level is set at.
                if (_args["verbose"] != null)
                {
                    if (_args["verbose"] == "console" || _args["verbose"] == "1")
                    {
                        s_log.Console("Log verbosity set to 'console' level");
                        s_log.Level = CLog.CONSOLE;
                    }
                    else if (_args["verbose"] == "logfile" || _args["verbose"] == "2")
                    {
                        s_log.Console("Log verbosity set to 'logfile' level");
                        s_log.Level = CLog.LOGFILE;
                    }
                    else if (_args["verbose"] == "datamod" || _args["verbose"] == "3")
                    {
                        s_log.Console("Log verbosity set to 'datamod' level");
                        s_log.Level = CLog.DATAMOD;
                    }
                    else if (_args["verbose"] == "datamod2" || _args["verbose"] == "4")
                    {
                        s_log.Console("Log verbosity set to 'datamod2' level");
                        s_log.Level = CLog.DATAMOD2;
                    }
                    else if (_args["verbose"] == "stacktrace" || _args["verbose"] == "5")
                    {
                        s_log.Console("Log verbosity set to 'stacktrace' level");
                        s_log.Level = CLog.STACKTRACE;
                    }
                    else if (_args["verbose"] == "fulltrace" || _args["verbose"] == "6")
                    {
                        s_log.Console("Log verbosity set to 'fulltrace' level");
                        s_log.Level = CLog.FULLTRACE;
                    }
                    else
                    {
                        // an unrecognized /verbose sets log level to max!
                        s_log.Console("Log verbosity set to 'fulltrace' level");
                        s_log.Level = CLog.FULLTRACE;
                    }
                }

                // next we want to open the repository object
                // collect any source depot settings from the command line
                string sSdPort = _args["sdport"];
                string sSdClient = _args["sdclient"];

                // this construction performs an 'sd info' operation to
                // figure out the root of the repository. If 'sd info' fails
                // the constructor will throw, which is what we want.
                CRepository repository = new CRepository(sSdPort, sSdClient, s_log);

                // collect any sql settings from the command line
                string sSqlUser = _args["sqluser"];
                string sSqlPwd = _args["sqlpwd"];

                // if you specify one, you must specify both!
                if (sSqlUser == null && sSqlPwd != null)
                {
                    //   0        1        2        3        4        5        6        7        8
                    string sErr =
                        "Error: cannot specify /sqlpwd without /sqluser";
                    s_log.LogFile(sErr);
                    throw new ApplicationException(sErr);
                }
                if (sSqlPwd == null && sSqlUser != null)
                {
                    //   0        1        2        3        4        5        6        7        8
                    string sErr =
                        "Error: cannot specify /sqluser without /sqlpwd";
                    s_log.LogFile(sErr);
                    throw new ApplicationException(sErr);
                }

                // we now have what we need to set up our CTitleMgr object
                s_titleMgr = new CTitleMgr(
                    repository,
                    sSqlUser,
                    sSqlPwd,
                    s_log);

                // lock the title
                bool bRemove = false;
                if (_args["lock"] == "remove")
                {
                    bRemove = true;
                }
                string sLockDetails;
                if (!s_titleMgr.Lock(bRemove, out sLockDetails))
                {
                    //   0        1        2        3        4        5        6        7        8
                    s_log.Console(
                        "Title already locked. Lock details:");
                    s_log.Console(
                        sLockDetails);
                    s_log.Console(
                        "To remove this lock, specify /lock:remove on the command line");
                }
                else
                {
                    // Even the new code is still using the legacy xmgmt command code,
                    // so we need to allocate this queue object here.
                    _commands = new Queue();

                    // I've separated out the new from the old as best I can.
                    // New operations that use the CTitleMgr object are implemented in
                    // PerformOperations. The code that used to live here in main
                    // has been moved to PerformLegacyOperations. If PerformOperations
                    // returns true, that means it has handled the command and we're
                    // done. If it return false, then we need to call PerformLegacyOperations.
                    // Note that it is permissible for PerformOperation to do some things,
                    // and still return false, so that PerformLegacyOperations takes over.
                    bool bComplete = false;
                    try
                    {
                        bComplete = PerformOperations();
                    }
                    catch (Exception e)
                    {
                        // the individual operations in PerformOperations are supposed to
                        // catch and handle any exception they expect. If one bubbles up
                        // to here, then its an unexpected problem, so output the exception
                        // details to the console, and a fullstack trace to the log.
                        //   0        1        2        3        4        5        6        7        8
                        s_log.Console("Error: Unhandled Exception. Log saved to " + s_log.LogPathAndName);
                        s_log.Console("Exception.Message: " + e.Message);
                        s_log.LogFile("Exception.StackTrace: " + e.StackTrace);
                        bComplete = true;
                    }

                    // if the PerformOperations method didn't completely handle the
                    // operation, and it wants the legacy code invoked, it returns
                    // false.
                    if (!bComplete)
                    {
                        PerformLegacyOperations();
                    }
                }
            }
            catch (Exception e)
            {
                // legacy begin //
                if(_hr == CPropUtils.HR_FAILED)
                {
                    CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                }
                else if(_hr == CPropUtils.HR_SUCCEEDED)
                {
                    CTitleMgrApp.WriteLine("SUCCESS: " + e.Message);
                }
                // legacy end //
            }
            finally
            {
                // Legacy begin //
                if (_args["noreload"] == null)
                    RunReloadCommands();
                else
                {
                    if (_commands.Count > 0)
                        CTitleMgrApp.WriteLine("Skipping reload of queued servers because of /noreload command");
                }
                // Legacy end //

                // unlock the title, if required
                if (s_titleMgr != null && s_titleMgr.Locked)
                {
                    s_titleMgr.Unlock();
                }

                // close the log if required
                if (s_log != null)
                {
                    // save the log file name...
                    string sLogPathAndName = s_log.LogPathAndName;
                    s_log.Close();

                    // copy the log file to last.log so you don't have to look around
                    // for the log of the most recent titlemgr execution
                    string sLastLog = Environment.CurrentDirectory + "\\last.log";
                    if (File.Exists(sLastLog))
                        File.SetAttributes(sLastLog, FileAttributes.Normal);
                    File.Copy(sLogPathAndName, sLastLog , true);
                }
            }
            return (_hr);
        }

        // returns true if processing is complete
        // used by main to detemine if it needs to call PerformLegacyOperations
        private static bool PerformOperations()
        {
            // to keep this section nice and readable, we don't do anything
            // here but find the major command parameter (e.g. /sync) and
            // call a function to do the work.
            if (_args["check"] != null)
            {
                s_log.FullTrace("/check found");
                return DoCheck();
            }

            // operations that add information to the repository.
            if (_args["stats"] != null)
            {
                s_log.FullTrace("/stats found");
                return DoStats();
            }
            if (_args["query"] != null)
            {
                s_log.FullTrace("/query found");
                return DoQuery();
            }
            if (_args["alternatetitleids"] != null)
            {
                s_log.FullTrace("/alternatetitleids found");
                return DoAlternateTitleIds();
            }
            if (_args["lspsite"] != null)
            {
                s_log.FullTrace("/lspsite found");
                return DoLSPSite();
            }
            if (_args["gameconfig"] != null)
            {
                s_log.FullTrace("/gameconfig found");
                return DoGameConfig();
            }

            // operations that apply the state of the repository
            // to various servers
            if (_args["syncquery"] != null)
            {
                s_log.FullTrace("/syncquery found");
                return DoSyncQuery();
            }
            if (_args["syncalternatetitleids"] != null)
            {
                s_log.FullTrace("/syncalternatetitleids found");
                return DoSyncAlternateTitleIds();
            }
            if (_args["synclspsite"] != null)
            {
                s_log.FullTrace("/synclspsite found");
                return DoSyncLSPSite();
            }
            if (_args["syncalerts"] != null)
            {
                s_log.FullTrace("/syncalerts found");
                return DoSyncAlerts();
            }
            if (_args["syncstats"] != null)
            {
                s_log.FullTrace("/syncstats found");
                return DoSyncStats();
            }
            if (_args["syncwebdb"] != null)
            {
                s_log.FullTrace("/syncwebdb found");
                return DoSyncWebDB();
            }
            if (_args["syncnpdb"] != null)
            {
                s_log.FullTrace("/syncnpdb found");
                return DoSyncNPDB();
            }
            if (_args["deletesite"] != null)
            {
                s_log.FullTrace("/deletesite found");
                return DoDeleteSite();
            }
            if (_args["deleteservice"] != null)
            {
                s_log.FullTrace("/deleteservice found");
                return DoDeleteService();
            }
            if (_args["syncgameconfig"] != null)
            {
                s_log.FullTrace("/syncgameconfig found");
                return DoSyncGameConfig();
            }

            return false;
        }

        // called for /check
        private static bool DoCheck()
        {
            s_log.FullTrace("running titlemgr diagnostics");
            s_titleMgr.RunDiagnostics();

            // RunDiagnostics only checks the things that the tools
            // framework relies on. Return false so a legacy check
            // will be called as well to check things like wsreader
            // and sdapi that the framekwork does not use.
            return false;
        }

        // called for /stats
        private static bool DoStats()
        {
            s_log.FullTrace("submitting xsc file");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpStats();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpStats();
                return true;
            }

            string sXscPathAndFileName = _args["stats"];
            if (sXscPathAndFileName == null || sXscPathAndFileName == String.Empty)
            {
                s_log.Console("Error: must specify xsc file using /stats argument");
                s_log.Console("");
                HelpStats();
                return true;
            }

            // we should check this here because it's really part of
            // parsing the command line. The StatsSubmitXsc call will
            // properly throw an exception if the file doesn't exist,
            // so it protects itself, but it doesn't know if it's being
            // called from a command line app (like this) or from a
            // web widget, or what, so it's message can't be as helpful
            if (!File.Exists(sXscPathAndFileName))
            {
                s_log.Console("Error: xsc file '"+sXscPathAndFileName+"' does not exist");
                s_log.Console("");
                HelpStats();
                return true;
            }

            bool bIgnorePolicy = false;
            if (_args["force"] != null)
            {
                // /force is how the user tells us to ignore policy on this
                // command
                bIgnorePolicy = true;
            }

            s_titleMgr.StatsSubmitXsc(tid, sXscPathAndFileName, bIgnorePolicy);
            return true;
        }

        // called for /syncstats
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncStats()
        {
            s_log.FullTrace("syncronizing stats service with repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncStats();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncStats();
                return true;
            }

            // this parameter configures how many seconds we'll wait for
            // move leaderboard related stored procs to complete, which can
            // take a long time depending on the amount of data in question.
            // default to zero, which means "no timeout - wait forever"
            int iSqlTimeoutSeconds = 0;
            if (_args["timeout"] != null)
            {
                try
                {
                    iSqlTimeoutSeconds = Int32.Parse(_args["timeout"]);
                }
                catch (Exception)
                {
                    s_log.Console("Error: invalid /timeout specified");
                    s_log.Console("       Unable to parse /timeout as an integer");
                    s_log.Console("");
                    HelpSyncStats();
                    return true;
                }
            }

            // this parameter configures how many seconds we'll wait between
            // progress reports when performing move leaderboard operations
            // if this is 0, then no progress reports will be provided
            // default is 10 seconds. Note that command line arg is in
            // seconds, but method parameter is in milliseconds.
            int iProgressReportIntervalMilliseconds = 10 * 1000;
            if (_args["progress"] != null)
            {
                try
                {
                    iProgressReportIntervalMilliseconds = Int32.Parse(_args["progress"]) * 1000;
                }
                catch (Exception)
                {
                    s_log.Console("Error: invalid /progress specified");
                    s_log.Console("       Unable to parse /progress as an integer");
                    s_log.Console("");
                    HelpSyncStats();
                    return true;
                }
            }

            bool bAllowDelete = false;
            if (_args["force"] != null)
            {
                // /force is how the user tells us to allow deletion of leaderboards
                bAllowDelete = true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.StatsSync(
                tid,
                iSqlTimeoutSeconds,
                iProgressReportIntervalMilliseconds,
                bAllowDelete,
                bReportOnly);

            // the legacy code is still responsible for xmgmt commands at this time
            CSyncLeaderboards.ReloadStatsFD();

            return true;
        }

        // called for /syncwebdb
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncWebDB()
        {
            s_log.FullTrace("syncronizing webdb with repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncWebDB();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncWebDB();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.WebDBSync(
                tid,
                bReportOnly);

            // the legacy code is still responsible for xmgmt commands at this time
            CSyncLeaderboards.ReloadWbca();

            return true;
        }


        // called for /query
        private static bool DoQuery()
        {
            s_log.FullTrace("submitting xqs file");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpQuery();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpQuery();
                return true;
            }

            string sXqsPathAndFileName = _args["query"];
            if (sXqsPathAndFileName == null || sXqsPathAndFileName == String.Empty)
            {
                s_log.Console("Error: must specify xqs file using /query");
                s_log.Console("");
                HelpQuery();
                return true;
            }

            if (!File.Exists(sXqsPathAndFileName))
            {
                s_log.Console("Error: xqs file '"+sXqsPathAndFileName+"' does not exist");
                s_log.Console("");
                HelpQuery();
                return true;
            }

            // get the list of supported query types
            string[] rgsValidQueryTypes = s_titleMgr.QueryTypeGetList();
            if (rgsValidQueryTypes.Length == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                s_log.Console("Error: No query types configured in service.xml.");
                return true;
            }

            string sQueryTypeName = _args["querytype"];
            if (sQueryTypeName == null || sQueryTypeName == String.Empty)
            {
                s_log.Console("Error: must specify query type using /querytype");
                s_log.Console("");
                s_log.Console("Supported query types are: ");
                foreach (string sValidQueryTypeName in rgsValidQueryTypes)
                {
                    s_log.Console("    /querytype:"+sValidQueryTypeName);
                }
                s_log.Console("");
                HelpQuery();
                return true;
            }

            // query type names are case insensitive
            sQueryTypeName = sQueryTypeName.ToLower();

            ArrayList alValidQueryTypes = new ArrayList(rgsValidQueryTypes);
            if (!alValidQueryTypes.Contains(sQueryTypeName))
            {
                s_log.Console("Error: invalid query type specified");
                s_log.Console("");
                s_log.Console("Supported query types are: ");
                foreach (string sValidQueryTypeName in rgsValidQueryTypes)
                {
                    s_log.Console("    /querytype:"+sValidQueryTypeName);
                }
                s_log.Console("");
                HelpQuery();
                return true;
            }

            string sPartitionId = _args["partition"];
            uint uiPartitionId;
            if (sPartitionId == null || sPartitionId == String.Empty)
            {
                uiPartitionId = c_uiDefaultQueryPartitionId;
            }
            else
            {
                try
                {
                    uiPartitionId = UInt32.Parse(sPartitionId);
                }
                catch (Exception)
                {
                    s_log.Console("Error: invalid /partition parameter");
                    s_log.Console("");
                    HelpQuery();
                    return true;
                }
            }

            s_titleMgr.QuerySubmitXqs(tid, sXqsPathAndFileName, sQueryTypeName, uiPartitionId);
            return true;
        }

        // called for /syncquery
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncQuery()
        {
            s_log.FullTrace("syncronizing querydb and npdb with query config in repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncQuery();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncQuery();
                return true;
            }

            bool bDropTable = false;
            if (_args["droptable"] != null)
            {
                bDropTable = true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.QuerySync(tid, bDropTable, bReportOnly);

            // send the xmgmt refresh command
            RefreshQuery();

            return true;
        }

        private static void RefreshQuery()
        {
            // the legacy code is still responsible for xmgmt commands at this time
            // I'm getting the server IPS the old fashioned way, because this code
            // doesn't have access to a repository object.
            string sServerIPs = CTitleMgrApp.Servers.GetSetting("SERVERS", "XQRY");
            if (sServerIPs.Length == 0)
            {
                s_log.Console("Error: Could not find XQRY setting in servers.ini");
                s_log.Console("       Unable to send CacheFlush command to querylib component on front doors");
            }
            else
            {
                string [] rgsServerIPs = sServerIPs.Split(';');

                foreach (string sServer in rgsServerIPs)
                {
                    CMgmtCommand.Exec(sServer, "e :querylib CacheFlush\r\n");
                }
            }

            return;
        }

        // called for /syncnpdb
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncNPDB()
        {
            s_log.FullTrace("syncronizing npdb with repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncNPDB();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncNPDB();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.NPDBSync(
                tid,
                bReportOnly);

            return true;
        }


        public static bool DoAlternateTitleIds()
        {
            s_log.FullTrace("changing alternate titleds");

            //
            //  Validate title id
            //

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpAlternateTitleIds();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpAlternateTitleIds();
                return true;
            }

            //
            //  Get list of alternate ids
            //

            string sAlternateTitleIdList = _args["alternatetitleids"];

            //
            //  Build up temporary ArrayList containing CTitleId objects representing every
            //  valid title id string specified in /alternatetitleids.  Any invalid title id
            //  string will cause the operation to fail.
            //

            ArrayList aTitlesTemp = new ArrayList();

            if(sAlternateTitleIdList != string.Empty)
            {
                string [] aAlternateTitleIdStrings = sAlternateTitleIdList.Split(';');

                if(aAlternateTitleIdStrings.Length > 4)
                {
                    s_log.Console("Error: Maximum of four alternate title ids can be specified");
                    HelpAlternateTitleIds();
                    return true;
                }

                foreach(string sAltTitleId in aAlternateTitleIdStrings)
                {
                    try
                    {
                        CTitleId tidAlt = new CTitleId(sAltTitleId);
                        aTitlesTemp.Add(tidAlt);
                    }
                    catch(Exception)
                    {
                        s_log.Console("Error: invalid title id \"" + sAltTitleId + "\" in /alternatetitleids list");
                        s_log.Console("");
                        HelpAlternateTitleIds();
                        return true;
                    }
                }
            }

            //
            //  Create array, copy title id objects to it, and set the ids
            //

            CTitleId [] aAlternateTitleIds = new CTitleId[aTitlesTemp.Count];
            aTitlesTemp.CopyTo(aAlternateTitleIds);
            s_titleMgr.AlternateTitleIdSet(tid, aAlternateTitleIds);

            return true;
        }

        // called for /syncalternatetitleids
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncAlternateTitleIds()
        {
            s_log.FullTrace("syncronizing uodb with alternate title ids config in repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncAlternateTitleIds();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncAlternateTitleIds();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.AlternateTitleIdSync(tid, bReportOnly);

            CPropUtils.UpdateXKDCCache();

            return true;
        }

        /// <summary>
        /// DoLSPSite:   reads lsp site information from an ssc file and puts it in repository.
        /// </summary>
        /// <returns>True if successful.</returns>
        private static bool DoLSPSite()
        {
            string filename = "";
            s_log.FullTrace("changing LSP Site information");

            //
            //  Validate title id
            //

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpLSPSite();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpLSPSite();
                return true;

            }

            //
            //  Validate lsp site information
            //

            if ( _args["lspsite"] == String.Empty )
            {
                s_log.Console("Error: must specify file with /lspsite option.");
                s_log.Console("");
                HelpLSPSite();
                return true;
            }

            // get the file name of the ssc file.
            filename = _args["lspsite"];

            //
            //  Open the given ssc file and extract the desired information.
            //
            XmlDocument cfg = new XmlDocument();

            XmlTextReader reader = new XmlTextReader( filename );
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();
            cfg.Load(reader);
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(cfg.NameTable);

            XmlElement docElement = cfg.DocumentElement;
            nsmgr.AddNamespace(sscXMLNameSpacePrefix, sscXMLNameSpaceURI);

            // this is the node which hold the http server we want to connect to.
            XmlNodeList nl = docElement.SelectNodes( sscXMLSitePath, nsmgr );
            CSite[] sites = null;
            if ( nl == null )
            {
                // no sites to add. interesting.
                sites = new CSite[0];
            }
            else
            {
                int nCnt = 0;
                sites = new CSite[nl.Count];
                // for each site entry in this file, copy to our list.
                foreach (XmlNode xmln in nl )
                {
                    sites[nCnt] = new CSite( xmln );
                    nCnt++;
                }
            }

            // set into the repository.
            s_titleMgr.LSPSitesSet( tid, sites );

            // this is the node which hold the http server we want to connect to.
            nl = docElement.SelectNodes( sscXMLServicePath, nsmgr );
            CService[] services = null;
            if ( nl == null )
            {
                // no sites to add. interesting.
                services = new CService[0];
            }
            else
            {
                int nCnt = 0;
                services = new CService[nl.Count];
                // for each site entry in this file, copy to our list.
                foreach (XmlNode xmln in nl )
                {
                    services[nCnt] = new CService( xmln );
                    nCnt++;
                }
            }

            // set the services into the repository.
            s_titleMgr.LSPServicesSet( tid, services );

            // archive the ssc file.
            s_titleMgr.LSPArchiveSSC( tid, filename );

            return true;
        }

        // called for /synclspsite
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncLSPSite()
        {
            s_log.FullTrace("syncronizing uodb with site and service config in repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncLSPSites();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncLSPSites();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.LspSiteSync(tid, bReportOnly);

            CPropUtils.UpdateXKDCCache();

            return true;
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        private static bool DoDeleteSite()
        {
            s_log.FullTrace("Modifying UODB; removing a site");

            //
            //  Validate title id
            //

            if (_args["deletesite"] == null || _args["deletesite"] == String.Empty)
            {
                s_log.Console("Error: must specify /deletesite");
                s_log.Console("");
                HelpDeleteSite();
                return true;
            }

            uint siteId = 0;
            try
            {
                string strSiteId = _args["deletesite"];
                if ( strSiteId.StartsWith("0x") )
                {
                    siteId = UInt32.Parse( strSiteId.Substring( 2 ), NumberStyles.HexNumber );
                }
                else
                {
                    siteId = UInt32.Parse( strSiteId );
                }
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /deletesite site id specified");
                s_log.Console("");
                HelpDeleteSite();
                return true;

            }

            try
            {
                // Use the site mgr to delete this site.
                CSiteMgr sm = new CSiteMgr( CTitleMgr.c_sUODBDBName, CTitleMgr.c_iDefaultUODBTimeout, "", s_log );

                // remove the site.
                if ( sm.Remove_Site( siteId ) )
                {
                    s_log.Console("Site (" + siteId + ") successfully removed.");
                    s_log.Console("");
                }
                else
                {
                    throw new Exception( "Error:  Failed to fully remove site " + siteId + " from UODB.  Please investigate.");
                }
            }
            catch (Exception e)
            {
                s_log.Console("Error: Site " + siteId + " deletion failed:  " + e.Message );
                s_log.Console("");
            }

            return true;
        }

        /// <summary>
        /// DoDeleteService:   reads lsp site information from an ssc file and puts it in repository.
        /// </summary>
        /// <returns>True if successful.</returns>
        private static bool DoDeleteService()
        {
            s_log.FullTrace("Modifying UODB; removing a service");

            //
            //  Validate title id
            //

            if (_args["deleteservice"] == null || _args["deleteservice"] == String.Empty)
            {
                s_log.Console("Error: must specify /deleteservice");
                s_log.Console("");
                HelpDeleteService();
                return true;
            }

            uint serviceId = 0;
            try
            {
                string strServiceId = _args["deleteservice"];
                if ( strServiceId.StartsWith("0x" ) )
                {
                    serviceId = UInt32.Parse( strServiceId.Substring( 2 ), NumberStyles.HexNumber );
                }
                else
                {
                    serviceId = UInt32.Parse( strServiceId );
                }
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /deleteservice service id specified");
                s_log.Console("");
                HelpDeleteService();
                return true;

            }

            try
            {
                // Use the site mgr to delete this site.
                CServiceMgr sm = new CServiceMgr( CTitleMgr.c_sUODBDBName, (uint)CTitleMgr.c_iDefaultUODBTimeout, s_log );

                // remove the site.
                if ( sm.Remove_Service( serviceId ) )
                {
                    s_log.Console("Service (" + serviceId + ") successfully removed.");
                    s_log.Console("");
                }
                else
                {
                    throw new Exception( "Error:  Failed to fully remove service " +
                        serviceId +
                        " from UODB.  Please investigate.");
                }
            }
            catch (Exception e)
            {
                s_log.Console("Error: Service " + serviceId + " deletion failed:  " + e.Message );
                s_log.Console("");
            }

            return true;

        }


        // called for /syncalerts
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncAlerts()
        {
            s_log.FullTrace("syncronizing alertsdb with title names in repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncAlerts();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncAlerts();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.AlertsSync(tid, bReportOnly);

            return true;
        }

        // called for /gameconfig
        private static bool DoGameConfig()
        {
            s_log.FullTrace("submitting game config file");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpGameConfig();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpGameConfig();
                return true;
            }

            string gameConfigPathAndFileName = _args["gameconfig"];
            if (gameConfigPathAndFileName == null || gameConfigPathAndFileName == String.Empty)
            {
                s_log.Console("Error: must specify game config file using /gameconfig");
                s_log.Console("");
                HelpGameConfig();
                return true;
            }

            if (!File.Exists(gameConfigPathAndFileName))
            {
                s_log.Console("Error: game config file '"+gameConfigPathAndFileName+"' does not exist");
                s_log.Console("");
                HelpGameConfig();
                return true;
            }

            s_titleMgr.GameConfigSubmit(tid, gameConfigPathAndFileName);
            return true;
        }

        // called for /syncgameconfig
        // public so I can call it from legacy /sync code in CSync.cs
        public static bool DoSyncGameConfig()
        {
            s_log.FullTrace("syncronizing npdb with game config in repository");

            if (_args["titleid"] == null || _args["titleid"] == String.Empty)
            {
                s_log.Console("Error: must specify /titleid");
                s_log.Console("");
                HelpSyncGameConfig();
                return true;
            }

            CTitleId tid;
            try
            {
                tid = ParseTitleId(_args["titleid"]);
            }
            catch (Exception)
            {
                s_log.Console("Error: invalid /titleid specified");
                s_log.Console("");
                HelpSyncGameConfig();
                return true;
            }

            bool bReportOnly = false;
            if (_args["report"] != null)
            {
                bReportOnly = true;
            }

            s_titleMgr.GameConfigSync(tid, bReportOnly);

            return true;
        }

        private static void PerformLegacyOperations()
        {
            // note, main has already saved something in _titleid for us

            //
            //  Source Depot settings
            //
            if (_args["sdclient"] != null)
            {
                _sdclient = _args["sdclient"].Trim();
                if(_sdclient.Length == 0)
                    _sdclient = null;
            }

            if (_args["sdport"] != null)
            {
                if(_args["sdport"].Trim().Length != 0)
                    _sdport = _args["sdport"].Trim();
            }

            //
            //  SQL access permissions
            //

            if (_args["sqluser"] != null)
            {
                _sqluser = _args["sqluser"].Trim();
                if(_sqluser.Length == 0)
                    _sqluser = null;
            }

            if (_args["sqlpwd"] != null)
            {
                _sqlpwd = _args["sqlpwd"].Trim();
                if(_sqlpwd.Length == 0)
                    _sqlpwd = null;
            }

            if (_args["force"] != null)
            {
                _force = true;
            }

            if (_args["notransfer"] != null)
            {
                _transfer = false;
            }

            //add handler for ctrl-c
            CConsoleCtrl cc = new CConsoleCtrl();
            cc.ControlEvent += new CConsoleCtrl.ControlEventHandler(MyHandler);

            //
            //  Now start parsing commands and figuring out what we need to do
            //

            // removing this because it's broken - it doesn't honor the
            // sdport and sdclient command line options. The /sync command
            // sync a title's section of the repository, so we don't need
            // to worry about applying out of date stuff to the service...
            //
            //sync up the repository
            //
            //RunCommandLine("sd.exe", "sync", Environment.CurrentDirectory);

            if (_args["check"] != null)
            {
                RunDiagnostics();
                Exit();
            }

            // save the titleid parameter in the global that the legacy code uses
            _titleid = _args["titleid"];

            //new has to come first because it uses so many many things
            if (_args["new"] != null)
            {
                if( InvalidArgument(_args["version"]))
                {
                    HelpNew();
                    throw new ApplicationException("/new - Incomplete /version parameter.");
                }

                bool bExempt = false;

                if (_args["markexempt"] != null)
                    bExempt = true;

                CNew.Exec(_args["titleid"], _args["version"],
                    _args["matchdb"], _args["statsdb"], _args["titledescription"], _args["pathtoxms"],
                    bExempt);

                Exit();
            }

            //do a reload if they want
            if (_args["reloadfrontdoors"] != null)
            {
                CTitleMgrApp.WriteLine("Reloading front doors to: XBOS, XKDC, MATCH, MSG, STATS, WBCA, XQRY");
                CPropUtils.UpdateXBOSCache();
                CPropUtils.UpdateXKDCCache();
                CNewXMS.ReloadMatch();
                CSyncLeaderboards.ReloadStatsFD();
                CSyncLeaderboards.ReloadWbca();
                RefreshQuery();
                _hr = CPropUtils.HR_SUCCEEDED;
                throw new ApplicationException("/reloadfrontdoors complete");
            }

            //
            // Execute each command
            //
            if (_args["exempt"] != null)
            {
                if (CDisable.Check(_titleid))
                    CExempt.Exec(_titleid, _args["exempt"]);
            }
            else if (_args["enable"] != null)
            {
                CDisable.Enable(_titleid);
            }
            else if (_args["disable"] != null)
            {
                CDisable.Exec(_titleid);
            }
            else if (_args["changebasever"] != null)
            {
                if (_args["version"] == null || _args["version"].Length != 8)
                {
                    HelpChangeBaseVer();
                    throw new ApplicationException("/changebasever - missing /version argumen");
                }
                if (CDisable.Check(_titleid))
                    CPropUpdate.ChangeBaseVer(_titleid, _args["version"]);
            }
            else if (_args["addbasever"] != null)
            {
                if (_args["version"] == null || _args["version"].Length != 8)
                {
                    HelpAddBaseVer();
                    throw new ApplicationException("/changebasever - missing /version argument");
                }
                if (CDisable.Check(_titleid))
                    CPropUpdate.AddBaseVer(_titleid, _args["version"]);
            }
            else if (_args["julyversion"] != null)
            {
                if (CDisable.Check(_titleid))
                    CPropUpdate.MakeFootball(_titleid);
            }
            else if (_args["translate"] != null)
            {
                if (CDisable.Check(_titleid))
                    CNameTranslations.Exec(_titleid, _args["translate"]);
            }
            else if (_args["resetlb"] != null)
            {
                if (CDisable.Check(_titleid))
                    CStatsUtil.ResetLB(_titleid, _args["resetlb"]);
            }
            else if (_args["removeuserfromlb"] != null)
            {
                if (CDisable.Check(_titleid))
                    CStatsUtil.RemoveUserFromLB(_titleid, _args["removeuserfromlb"], _args["lb"]);
            }
            /*
            // I have no idea what effect this command would have on a stats v2 or v3
            // title that uses xml to define it's leaderboards, so I'm disabling this
            // command. If we want to delete a leaderboard, we'll do into the ini
            // file manually.
            else if (_args["deletelb"] != null)
            {
                if (CDisable.Check(_titleid))
                    CStatsUtil.DeleteLB(_titleid, _args["deletelb"]);
            }
            */
            else if (_args["xms"] != null)
            {
                if (CDisable.Check(_titleid))
                    CNewXMS.Exec(
                        _titleid,
                        _args["xms"],
                        (null == _args["droptable"]?false:true),
                        _sdport,
                        _sdclient,
                        s_log);
            }
            else if (_args["matchdb"] != null)
            {
                if (CDisable.Check(_titleid))
                    CMatchDB.Exec(_titleid, _args["matchdb"]);
            }
            else if((_args["startdate"] != null || _args["enddate"] != null) && _args["content"] == null)
            {
                if (CDisable.Check(_titleid))
                    CPropContent.ChangeDates( _titleid, _args["offerid"],
                        _args["startdate"],
                        _args["enddate"],
                        (null == _args["noreload"]? true:false));
            }
            else if(_args["renew"] != null || _args["convert"] != null)
            {
                if (InvalidArgument(_args["from"]) ||
                    InvalidArgument(_args["to"]))
                {
                    HelpRenew();
                    CTitleMgrApp.WriteLine("You must specify /from and /to");
                }
                else if (_args["renew"] != null && _args["convert"] != null)
                {
                    HelpRenew();
                    CTitleMgrApp.WriteLine("You may specify either /renew or /convert but not both");
                }
                else if (CDisable.Check(_titleid))
                {
                    if (_args["renew"] != null)
                    {
                        // renew is conversion mode 1
                        CPropContent.Renew(_titleid, _args["from"], _args["to"], "1");
                    }
                    else
                    {
                        // convert is conversion mode 0
                        CPropContent.Renew(_titleid, _args["from"], _args["to"], "0");
                    }
                }
            }
            else if(_args["voucher"] != null)
            {
                if (InvalidArgument(_args["voucher"]) ||
                    InvalidArgument(_args["offerid"]))
                {
                    HelpVoucher();
                    CTitleMgrApp.WriteLine("You must specify true|false for voucher and offerids");
                }
                else
                {
                    if (CDisable.Check(_titleid))
                    {
                        CPropContent.Voucher(_titleid, _args["offerid"],
                            (_args["voucher"].ToUpper() == "TRUE") ? true : false );
                    }
                }
            }
            else if(_args["adddefault"] != null)
            {
                if (InvalidArgument(_args["site"]))
                {
                    HelpAddDefault();
                    CTitleMgrApp.WriteLine("You must specify a /site to adddefault");
                }
                else
                {
                    if (CDisable.Check(_titleid))
                    {
                        if (_args["adddefault"] != "0")
                            CPropContent.AddDefault(_titleid, _args["startindex"], _args["site"]);

                        if (_args["adddefault"] != "1")
                        {
                            _bDefaultUpdate = true;
                            CPropUpdate.BuildDefaultUpdate(_titleid);
                            CPropUpdate.RebuildUpdate(_titleid, DefaultUpdatePath, _args["site"], false);
                        }
                    }
                }
            }
            else if (_args["sync"] != null)
            {
                if (CDisable.Check(_args["titleid"]))
                {
                    if (_args["offerid"] != null)
                    {
                        //sync just a single offer
                        string [] offers = _args["offerid"].Split(';');
                        foreach(string offer in offers)
                            CPropContent.SyncOffer(_args["titleid"], offer);
                    }
                    else
                    {
                        CSync.Exec(
                            _args["titleid"],
                            (null == _args["noreload"]? true:false),
                            _sdport,
                            _sdclient,
                            s_log);
                    }
                }
            }
            else if (_args["uodbupdate"] != null)
            {
                if(_args["offerid"] == null)
                {
                    _args["offerid"] = "all";
                }

                if (CDisable.Check(_args["titleid"]))
                    CPropUtils.UODBUpdate(_args["titleid"], _args["offerid"],
                        (null == _args["noreload"]? true:false));
            }
            else if (_args["makefull"] != null)
            {
                if (CTitleMgrApp.InvalidArgument(_args["offerid"]))
                {
                    HelpMakeFull();
                    throw new ApplicationException("/makefull - Invalid offerid");
                }

                CPropUpdate.MakeFull(_args["titleid"], _args["offerid"],
                    (_args["makefull"] == "0") ? false : true);
            }
            else if(_args["transfer"] != null)
            {
                if(_args["offerid"] == null)
                {
                    _args["offerid"] = "all";
                }

                if (CDisable.Check(_args["titleid"]))
                    CPropUtils.Transfer(_args["titleid"], _args["offerid"]);
            }
            else if (_args["removeupdate"] != null)
            {
                if (CDisable.Check(_args["titleid"]))
                    CPropUpdate.RemoveUpdate(_args["titleid"], _args["offerid"]);
            }
            else if (_args["enableupdate"] != null)
            {
                if (CDisable.Check(_args["titleid"]))
                    CPropUpdate.EnableUpdate(_args["titleid"], _args["offerid"]);
            }
            else if (_args["content"] != null)
            {
                if(_args["control"] != null)
                {
                    //
                    // Tries to find all the info in the control file checked in
                    //
                    if (CDisable.Check(_args["titleid"]))
                        CPropContent.RebuildContent(_args["titleid"], _args["content"], _args["control"], true,
                            (null == _args["defaulttemplate"]? false:true),
                            _args["startdate"], _args["enddate"]);
                }
                else
                {
                    if (InvalidArgument(_args["site"]))
                    {
                        HelpContent();
                        throw new ApplicationException("/content - Incomplete /site parameter.");
                    }

                    //
                    // Updates the control file
                    //
                    if (CDisable.Check(_args["titleid"]))
                        CPropContent.RebuildContent(
                            _args["titleid"],
                            _args["content"],
                            _args["site"],
                            _args["offerid"],
                            _args["startdate"],
                            _args["enddate"],
                            (null == _args["defaulttemplate"]? false:true));
                }
            }
            else if (_args["autoupd"] != null)
            {
                if(_args["control"] != null)
                {
                    //
                    // Tries to find all the info in the control file checked in
                    //
                    if (CDisable.Check(_args["titleid"]))
                        CPropUpdate.RebuildUpdate(_args["titleid"], _args["autoupd"], _args["control"], true,
                                (null == _args["full"]? false:true));
                }
                else
                {
                    if (InvalidArgument(_args["site"]))
                    {
                        HelpAutoupd();
                        throw new ApplicationException("/autoupd - Incomplete /site parameter.");
                    }
                    //
                    // Updates the control file
                    //
                    if (CDisable.Check(_args["titleid"]))
                        CPropUpdate.RebuildUpdate(
                            _args["titleid"],
                            _args["autoupd"],
                            _args["site"],
                            (null == _args["full"]? false:true));
                }
            }
            else if (_args["template"] != null)
            {
                if(0 != _args["template"].Length)
                {

                    if (CDisable.Check(_args["titleid"]))
                        CPropContent.SubmitTemplate(_args["titleid"], _args["offerid"],
                            _args["template"], (null == _args["resubmit"]? false:true));
                }
                else if (null != _args["injectboids"])
                {
                    if (CDisable.Check(_args["titleid"]))
                        CPropContent.InjectBoids(_args["titleid"], _args["offerid"]);
                }
                else
                {
                    if((null == _args["sps"]) || ( 0 == _args["sps"].Length))
                    {
                        HelpTemplate();
                        throw new ApplicationException("/template - bad input parameters");;
                    }

                    if (CDisable.Check(_args["titleid"]))
                        CPropContent.SetBillingState(_args["titleid"], _args["offerid"], _args["sps"]);
                }
            }
            else if (_args["serviceid"] != null)
            {
                if(0 != _args["serviceid"].Length)
                {
                    if (CDisable.Check(_args["titleid"]))
                        CServices.AddServiceIdIniToRepository(_args["titleid"], _args["serviceid"]);
                }
                else
                {
                    HelpServiceId();
                    throw new ApplicationException("/serviceid - bad input parameters");;
                }
            }
            else
            {
                WriteLine("Unknown command! See below the list of options supported:");
                Help();
            }
        }

        public static void HelpGameConfigDescription()
        {
            CTitleMgrApp.WriteLine("/gameconfig       Submit a game config xml to the repository.");
            CTitleMgrApp.WriteLine("");
        }

        public static void HelpGameConfig()
        {
            HelpGameConfigDescription();
            CTitleMgrApp.WriteLine("    /gameconfig:<file.xqs> /titleid:<titleid>");
            CTitleMgrApp.WriteLine("");
            CTitleMgrApp.WriteLine("    /gameconfig:<file.xqs> - the game config xml file to submit to the repository ");
            CTitleMgrApp.WriteLine("    /titleid:<titleid> - the titleid to apply the game config xml file to");
        }

        public static void HelpSyncGameConfigDescription()
        {
            CTitleMgrApp.WriteLine("/syncgameconfig   Inserts the game config xml into npdb.");
            CTitleMgrApp.WriteLine("");
        }

        public static void HelpSyncGameConfig()
        {
            HelpSyncGameConfigDescription();
            CTitleMgrApp.WriteLine("    /syncgameconfig /titleid:<titleid>");
            CTitleMgrApp.WriteLine("");
            CTitleMgrApp.WriteLine("    /titleid:<titleid> - the titleid to sync game config information for");
        }

        public static void HelpQueryDescription()
        {
            CTitleMgrApp.WriteLine("/query            Submit an xqs file to the repository.");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpQuery()
        {
            HelpQueryDescription();
            CTitleMgrApp.WriteLine("    /query:<file.xqs> /querytype:<name> /titleid:<titleid>");
            CTitleMgrApp.WriteLine("        [/partition:<integer>]");
            CTitleMgrApp.WriteLine("");
            CTitleMgrApp.WriteLine("    /query:<file.xqs> -the xqs file that to submit to the repository ");
            CTitleMgrApp.WriteLine("    /querytype:<name> - the type of xqs file that is being submitted");
            CTitleMgrApp.WriteLine("                        Note: you can submit one of each supported xqs type");
            CTitleMgrApp.WriteLine("                              per title");
            CTitleMgrApp.WriteLine("    /titleid:<titleid> - the titleid to apply the xqs file to");
            CTitleMgrApp.WriteLine("    [/partition:<integer>] - the query service partition, optional");
            CTitleMgrApp.WriteLine("                             defaults to 1");
        }

        public static void HelpSyncQueryDescription()
        {
            CTitleMgrApp.WriteLine("/syncquery        Sync querydb and npdb with the specified.");
            CTitleMgrApp.WriteLine("                  title's query service config in the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncQuery()
        {
            HelpSyncQueryDescription();
            CTitleMgrApp.WriteLine("    /syncquery /titleid:<titleid> [/droptable] [/report]");
            CTitleMgrApp.WriteLine("        /droptable - instructs titlemgr to generate sql that drops");
            CTitleMgrApp.WriteLine("                     existing tables in querydb");
            CTitleMgrApp.WriteLine("        /report - tells titlemgr to generate console and log output only,");
            CTitleMgrApp.WriteLine("                  no database changes will be made");
        }

        public static void HelpSyncAlertsDescription()
        {
            CTitleMgrApp.WriteLine("/syncalerts       Sync alertsdb with the title descriptions.");
            CTitleMgrApp.WriteLine("                  in the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncAlerts()
        {
            HelpSyncAlertsDescription();
            CTitleMgrApp.WriteLine("    /syncalerts /titleid:<titleid> [/report]");
            CTitleMgrApp.WriteLine("        /report - tells titlemgr to generate console and log output only,");
            CTitleMgrApp.WriteLine("                  no database changes will be made");
        }

        public static void HelpSyncDescription()
        {
            CTitleMgrApp.WriteLine("/sync             Synchronize all information for one title");
            CTitleMgrApp.WriteLine("                  with the repository, or sync just a single offer");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSync()
        {
            HelpSyncDescription();
            CTitleMgrApp.WriteLine("    /sync /titleid:<title_1> [/noreload] [/notransfer]");
            CTitleMgrApp.WriteLine("    /sync /titleid:<title_1> /offerid:<offer1>;<offer2> [/noreload] [/notransfer]");
        }

        public static void HelpResetLBDescription()
        {
            CTitleMgrApp.WriteLine("/resetlb          Reset one or more leaderboards for a title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpResetLB()
        {
            HelpResetLBDescription();
            CTitleMgrApp.WriteLine("    /resetlb:<lb_1>[;<lb_2>;...] /titleid:<title_id>");
        }

        public static void HelpRemoveUserFromLBDescription()
        {
            CTitleMgrApp.WriteLine("/removeuserfromlb Remove a user's statistics from one or more leaderboards");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpRemoveUserFromLB()
        {
            HelpRemoveUserFromLBDescription();
            CTitleMgrApp.WriteLine("    /removeuserfromlb:<user> /titleid:<title_id> /lb:all");
            CTitleMgrApp.WriteLine("    /removeuserfromlb:<user> /titleid:<title_id> /lb:<lb_1>[;<lb_2>;...]");
        }

        public static void HelpSyncStatsDescription()
        {
            CTitleMgrApp.WriteLine("/syncstats     Sync all stats databases with the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncStats()
        {
            HelpSyncStatsDescription();
            //                      0         1         2         3         4         5         6         7         8
            CTitleMgrApp.WriteLine("    /syncstats /titleid:<title_id> [/force] [/report]");
            CTitleMgrApp.WriteLine("        /force - gives titlemgr permission to destroy data if required to sync");
            CTitleMgrApp.WriteLine("        /report - tells titlemgr to generate console and log output only,");
            CTitleMgrApp.WriteLine("                  no database changes will be made");
            CTitleMgrApp.WriteLine("        /timeout - specifies the timeout (in seconds) that titlemgr will wait");
            CTitleMgrApp.WriteLine("                   for stored procedures related to moving leaderboards to ");
            CTitleMgrApp.WriteLine("                   complete. Defaults to 0 if not specified, which means wait");
            CTitleMgrApp.WriteLine("                   forever. Under ordinary circumstances, this default should");
            CTitleMgrApp.WriteLine("                   be used.");
            CTitleMgrApp.WriteLine("        /progress - specifies the time interval (in seconds) between progress");
            CTitleMgrApp.WriteLine("                    reports when moving leaderboards. Defaults to 10 if not");
            CTitleMgrApp.WriteLine("                    specified. /progress:0 disables progress reporting");
        }

        public static void HelpSyncWebDBDescription()
        {
            CTitleMgrApp.WriteLine("/syncwedb     Sync webdb database with the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncWebDB()
        {
            HelpSyncWebDBDescription();
            //                      0         1         2         3         4         5         6         7         8
            CTitleMgrApp.WriteLine("    /syncwebdb /titleid:<title_id> [/report]");
            CTitleMgrApp.WriteLine("        /report - tells titlemgr to generate console and log output only,");
            CTitleMgrApp.WriteLine("                  no database changes will be made");
        }

        public static void HelpSyncNPDBDescription()
        {
            CTitleMgrApp.WriteLine("/syncnpdb     Sync title descriptions in npdb database with the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncNPDB()
        {
            HelpSyncNPDBDescription();
            //                      0         1         2         3         4         5         6         7         8
            CTitleMgrApp.WriteLine("    /syncnpdb /titleid:<title_id> [/report]");
            CTitleMgrApp.WriteLine("        /report - tells titlemgr to generate console and log output only,");
            CTitleMgrApp.WriteLine("                  no database changes will be made");
        }

        public static void HelpStatsDescription()
        {
            //                      0         1         2         3         4         5         6         7         8
            CTitleMgrApp.WriteLine("/stats         submits a new stats configuration (xsc file) to the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpStats()
        {
            HelpStatsDescription();
            //                      0         1         2         3         4         5         6         7         8
            CTitleMgrApp.WriteLine("    /stats:<xsc file> /titleid:<title_id> [/force]");
            CTitleMgrApp.WriteLine("        /force - instructs titlemgr to allow this xsc to violate current policy");
        }
        public static void HelpXMSDescription()
        {
            CTitleMgrApp.WriteLine("/xms              Process a matchmaking XMS file for one or more titles");
            CTitleMgrApp.WriteLine("    /droptable will add the DROP TABLE line from XMLtoSQL");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpXMS()
        {
            HelpXMSDescription();
            CTitleMgrApp.WriteLine("    /xms /titleid:all [/droptable]");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /xms /titleid:<title_1>[;<title_2>;...] [/droptable]");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /xms:<xmsfilepath> /titleid:<title_1> [/droptable]");
        }

        public static void HelpMatchDBDescription()
        {
            CTitleMgrApp.WriteLine("/matchdb          Change the matchmaking database used by a title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpMatchDB()
        {
            HelpMatchDBDescription();
            CTitleMgrApp.WriteLine("    /matchdb:<dbindex> /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /matchdb:<dbindex> /titleid:<title_1>[;<title_2>;...] ");
        }

        public static void HelpJulyVersionDescription()
        {
            CTitleMgrApp.WriteLine("/julyversion        Tells titlemgr that this title uses July versioning");
            CTitleMgrApp.WriteLine("                    ie, XXXX.YYYY instead of YYYYYY.XX");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpJulyVersion()
        {
            HelpJulyVersionDescription();
            CTitleMgrApp.WriteLine("    /julyversion /titleid:<title_id> ");
        }

        public static void HelpReloadFrontDoorsDescription()
        {
            CTitleMgrApp.WriteLine("/reloadfrontdoors   Sends the reload command to all front doors in servers.ini");
            CTitleMgrApp.WriteLine("");
        }

        public static void HelpReloadFrontDoors()
        {
            HelpReloadFrontDoorsDescription();
            CTitleMgrApp.WriteLine("    /reloadfrontdoors");
        }

        public static void HelpRemoveUpdateDescription()
        {
            CTitleMgrApp.WriteLine("/removeupdate        Removes an autoupdate, reverting to the prev update on sync");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpRemoveUpdate()
        {
            HelpRemoveUpdateDescription();
            CTitleMgrApp.WriteLine("    /removeupdate /titleid:<title_id> /offerid:<id>");
        }

        public static void HelpEnableUpdateDescription()
        {
            CTitleMgrApp.WriteLine("/enableupdate        Enables an autoupdate, undoing the remove");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpEnableUpdate()
        {
            HelpEnableUpdateDescription();
            CTitleMgrApp.WriteLine("    /enableupdate /titleid:<title_id> /offerid:<id>");
        }

        public static void HelpVoucherDescription()
        {
            CTitleMgrApp.WriteLine("/voucher            Set/Unset a group of offers to have a voucher policy flag");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpVoucher()
        {
            HelpVoucherDescription();
            CTitleMgrApp.WriteLine("    /voucher:true:false /titleid:<titleid> /offerid:<offer1>;<offer2>...");
        }

        public static void HelpRenewDescription()
        {
            CTitleMgrApp.WriteLine("/renew            Set a group of offers to renew into another offer");
            CTitleMgrApp.WriteLine("/convert          Set a group of offers to convert into another offer");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpRenew()
        {
            HelpRenewDescription();
            CTitleMgrApp.WriteLine("    /renew /titleid:<titleid> /from:<offer1>;<offer2>... /to:<offer>");
            CTitleMgrApp.WriteLine("    /convert /titleid:<titleid> /from:<offer1>;<offer2>... /to:<offer>");
        }

        public static void HelpServiceIdDescription()
        {
            CTitleMgrApp.WriteLine("/serviceid        Check the provided serviceid.ini file for validity, and add it to the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpServiceId()
        {
            HelpServiceIdDescription();
            CTitleMgrApp.WriteLine("    /serviceid:<serviceid.ini> /titleid:<titleid>");
        }

        public static void HelpContentDescription()
        {
            CTitleMgrApp.WriteLine("/content          Content propagation - phase 1");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpContent()
        {
            HelpContentDescription();
            CTitleMgrApp.WriteLine("    /content:<packagepath> /control:<controlpath> /titleid:<titleid>");
            CTitleMgrApp.WriteLine("                           OR");
            CTitleMgrApp.WriteLine("    /content:<packagepath> /titleid:<titleid>");
            CTitleMgrApp.WriteLine("                           /site:<site_1>[;<site_2>;...] or all");
            CTitleMgrApp.WriteLine("                           [/offerid:<offerid>]");
            CTitleMgrApp.WriteLine("                           [/startdate:<date>] [/enddate:<date>]");
            CTitleMgrApp.WriteLine("                           [/defaulttemplate]");
        }

        public static void HelpChangeDatesDescription()
        {
            CTitleMgrApp.WriteLine("/startdate and/or ");
            CTitleMgrApp.WriteLine("      /enddate    Change advertisement dates for an offering");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpChangeDates()
        {
            HelpChangeDatesDescription();
            CTitleMgrApp.WriteLine("    /titleid:<title_id> /offerid:<offerid>");
            CTitleMgrApp.WriteLine("                        [/startdate:<date>] [/enddate:<date>] [/noreload]");
        }

        public static void HelpAutoupdDescription()
        {
            CTitleMgrApp.WriteLine("/autoupd          Auto-update propagation - phase 1");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpAutoupd()
        {
            HelpAutoupdDescription();
            CTitleMgrApp.WriteLine("    /autoupd:<packagepath> /control:<controlpath> /titleid:<titleid> [/full]");
            CTitleMgrApp.WriteLine("                           OR");
            CTitleMgrApp.WriteLine("    /autoupd:<packagepath> /titleid:<titleid>");
            CTitleMgrApp.WriteLine("                           /site:<site_1>[;<site_2>;...] or all");
        }

        public static void HelpMakeFullDescription()
        {
            CTitleMgrApp.WriteLine("/makefull          Make a beta-only autoupdate full (or not full)");
            CTitleMgrApp.WriteLine("                    (ie, for beta and non-beta)");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpMakeFull()
        {
            HelpAutoupdDescription();
            CTitleMgrApp.WriteLine("    /makefull:0|1 /offerid:<pkgid> /titleid:<titleid>");
        }

        public static void HelpTransferDescription()
        {
            CTitleMgrApp.WriteLine("/transfer         Package propagation - phase 2");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpTransfer()
        {
            HelpTransferDescription();
            CTitleMgrApp.WriteLine("    /transfer /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /transfer /titleid:<title_1>[;<title_2>;...]]");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /transfer /titleid:<title_id> [/offerid:<package_1>[;<package_2>;...]]");
        }

        public static void HelpUODBUpdateDescription()
        {
            CTitleMgrApp.WriteLine("/uodbupdate       Package propagation - phase 3");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpUODBUpdate()
        {
            HelpUODBUpdateDescription();
            CTitleMgrApp.WriteLine("    /uodbupdate /titleid:all [/noreload]");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /uodbupdate /titleid:<title_1>[;<title_2>;...] [/noreload]");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /uodbupdate /titleid:<title_id> [/offerid:<package_1>[;<package_2>;...]] [/noreload]");
        }

        public static void HelpChangeBaseVerDescription()
        {
            CTitleMgrApp.WriteLine("/changebasever    Sets the base version for a title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpChangeBaseVer()
        {
            HelpChangeBaseVerDescription();
            CTitleMgrApp.WriteLine("    /changebasever /titleid:<titleid> /version:<version>");
        }

        public static void HelpAddBaseVerDescription()
        {
            CTitleMgrApp.WriteLine("/addbasever    Creates an additional base version for a title");
            CTitleMgrApp.WriteLine("               Use this when another cd is printed.");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpAddBaseVer()
        {
            HelpAddBaseVerDescription();
            CTitleMgrApp.WriteLine("    /addbasever /titleid:<titleid> /version:<version>");
        }

        public static void HelpDisableDescription()
        {
            CTitleMgrApp.WriteLine("/disable           Removes all information for the title");
            CTitleMgrApp.WriteLine("                  from the datacenter but NOT the repository");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpDisable()
        {
            HelpDisableDescription();
            CTitleMgrApp.WriteLine("    /disable /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /disable /titleid:<title_1>[;<title_2>;...]");
        }

        public static void HelpEnableDescription()
        {
            CTitleMgrApp.WriteLine("/enable           Adds a title to the datacenter if it");
            CTitleMgrApp.WriteLine("                  was previously disabled");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpEnable()
        {
            HelpEnableDescription();
            CTitleMgrApp.WriteLine("    /enable /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /enable /titleid:<title_1>[;<title_2>;...]");
        }

        public static void HelpExemptDescription()
        {
            CTitleMgrApp.WriteLine("/exempt           Gives title exempt status - updates versions.ini");
            CTitleMgrApp.WriteLine("                  and inserts a row in uodb");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpExempt()
        {
            HelpExemptDescription();
            CTitleMgrApp.WriteLine("    /exempt:0|1 /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /exempt:0|1 /titleid:<title_1>[;<title_2>;...]");
            CTitleMgrApp.WriteLine("    0 to make non-exempt, 1 to make exempt");

        }

        public static void HelpTranslateDescription()
        {
            CTitleMgrApp.WriteLine("/translate        Takes name info from <file> with TITLEINFO format ");
            CTitleMgrApp.WriteLine("                  and updates the message dir");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpTranslate()
        {
            HelpTranslateDescription();
            CTitleMgrApp.WriteLine("    /translate:<pathtofile> /titleid:all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /translate:<pathtofile> /titleid:<title_1>[;<title_2>;...]");
        }

        public static void HelpNewDescription()
        {
            CTitleMgrApp.WriteLine("/new              Creates a new title, automating every step");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpNew()
        {
            HelpNewDescription();
            CTitleMgrApp.WriteLine("    /new /titleid:<titleid> /version:<version_id> [/matchdb:<matchdb>]");
            CTitleMgrApp.WriteLine("         [/statsdb:<statsdb>] [/titledescription:<desc>] [/pathtoxms:<path>]");
            CTitleMgrApp.WriteLine("         [/markexempt]");
        }

        public static void HelpAddDefaultDescription()
        {
            CTitleMgrApp.WriteLine("/adddefault       Adds the default packages for a specified title");
            CTitleMgrApp.WriteLine("                :1 adds default content, :0 adds default autoupdate");
            CTitleMgrApp.WriteLine("                just plain /adddefault props both content and autoupdate");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpAddDefault()
        {
            HelpAddDefaultDescription();
            CTitleMgrApp.WriteLine("    /adddefault[:0|1] /titleid:all /startindex:<index> /site:<site_1>[;<site_2>;...] or all");
            CTitleMgrApp.WriteLine("              OR");
            CTitleMgrApp.WriteLine("    /adddefault[:0|1] /titleid:<title_1>[;<title_2>;...] /startindex:<index> /site:<site_1>[;<site_2>;...] or all");
        }

        public static void HelpAlternateTitleIdsDescription()
        {
            CTitleMgrApp.WriteLine("/alternatetitleids");
            CTitleMgrApp.WriteLine("              Sets alternate title ids for this title");
            CTitleMgrApp.WriteLine("              Up to four alternate title ids may be");
            CTitleMgrApp.WriteLine("              specified.  Specify none to clear all");
            CTitleMgrApp.WriteLine("              alternate titleids for the title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpAlternateTitleIds()
        {
            HelpAlternateTitleIdsDescription();
            CTitleMgrApp.WriteLine("    /alternatetitleids[:<title_1>[;<title_2>;...]] /titleid:<title>");
        }

        public static void HelpDeleteSiteDescription()
        {
            CTitleMgrApp.WriteLine("/deletesite");
            CTitleMgrApp.WriteLine("              Deletes the specified site from UODB.");
            CTitleMgrApp.WriteLine("              This includes deleting all site");
            CTitleMgrApp.WriteLine("              entries in t_sites and t_service_instances.");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpDeleteSite()
        {
            HelpDeleteSiteDescription();
            CTitleMgrApp.WriteLine("    /deletesite:<site id>");
        }

        public static void HelpDeleteServiceDescription()
        {
            CTitleMgrApp.WriteLine("/deleteservice");
            CTitleMgrApp.WriteLine("              Deletes the specified site from UODB.");
            CTitleMgrApp.WriteLine("              This includes deleting a service from");
            CTitleMgrApp.WriteLine("              t_services, t_service_instances and");
            CTitleMgrApp.WriteLine("              t_offer_services.");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpDeleteService()
        {
            HelpDeleteServiceDescription();
            CTitleMgrApp.WriteLine("    /deleteservice:<service id>");
        }

        public static void HelpLSPSiteDescription()
        {
            CTitleMgrApp.WriteLine("/lspsite");
            CTitleMgrApp.WriteLine("              Reads an XML format ssc file and");
            CTitleMgrApp.WriteLine("              extracts site and service information");
            CTitleMgrApp.WriteLine("              for a specific title.");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpLSPSite()
        {
            HelpLSPSiteDescription();
            CTitleMgrApp.WriteLine("    /lspsite:<ssc filename> /titleid:<title>");
        }

        public static void HelpSyncLSPSitesDescription()
        {
            CTitleMgrApp.WriteLine("/synclspsites");
            CTitleMgrApp.WriteLine("              Syncs alternate title ids for the specified title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncLSPSites()
        {
            HelpSyncLSPSitesDescription();
            CTitleMgrApp.WriteLine("    /synclspsites /titleid:<title>");
        }

        public static void HelpSyncAlternateTitleIdsDescription()
        {
            CTitleMgrApp.WriteLine("/syncalternatetitleids");
            CTitleMgrApp.WriteLine("              Syncs alternate title ids for the specified title");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSyncAlternateTitleIds()
        {
            HelpSyncAlternateTitleIdsDescription();
            CTitleMgrApp.WriteLine("    /syncalternatetitleids /titleid:<title>");
        }

        public static void HelpCheckDescription()
        {
            CTitleMgrApp.WriteLine("/check        Perform diagnostics");
            CTitleMgrApp.WriteLine("");
        }

        public static void HelpLogDescription()
        {
            CTitleMgrApp.WriteLine("/log              Specify a log filename to override default or disables");
            CTitleMgrApp.WriteLine("                  logging altogether");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpLog()
        {
            HelpLogDescription();
            CTitleMgrApp.WriteLine("    /log:<file_name>");
            CTitleMgrApp.WriteLine("         OR");
            CTitleMgrApp.WriteLine("    /log:nolog");
        }

        public static void HelpSetLocationsDescription()
        {
            CTitleMgrApp.WriteLine("/xrlroot          Set new XRL for a package or a number of packages");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpSetLocations()
        {
            HelpSetLocationsDescription();
            CTitleMgrApp.WriteLine("    /xrlroot:<xrlindex_1>[;<xrlindex_2>;...]");
            CTitleMgrApp.WriteLine("                 [/downloadservers:<dsindex_1>[;<ds_index2>...]]");
            CTitleMgrApp.WriteLine("                  /titleid:all");
            CTitleMgrApp.WriteLine("            OR");
            CTitleMgrApp.WriteLine("    /xrlroot:<xrlindex_1>[;<xrlindex_2>;...]");
            CTitleMgrApp.WriteLine("                 [/downloadservers:<dsindex_1>[;<ds_index2>...]]");
            CTitleMgrApp.WriteLine("                  /titleid:<title_1>[;<title_2>;...]]");
            CTitleMgrApp.WriteLine("            OR");
            CTitleMgrApp.WriteLine("    /xrlroot:<xrlindex_1>[;<xrlindex_2>;...]");
            CTitleMgrApp.WriteLine("                 [/downloadservers:<dsindex_1>[;<ds_index2>...]]");
            CTitleMgrApp.WriteLine("                  /titleid:<title_id>");
            CTitleMgrApp.WriteLine("                 [/offerid:<package_1>[;<package_2>;...]]");
        }

        public static void HelpTemplateDescription()
        {
            CTitleMgrApp.WriteLine("/template         Submits a billing template for a given title and offer");
            CTitleMgrApp.WriteLine("");
        }
        public static void HelpTemplate()
        {
            HelpTemplateDescription();
            CTitleMgrApp.WriteLine("    /template:<templatepath> /titleid:<titleid> /offerid:<offerid>");
            CTitleMgrApp.WriteLine("                             [/resubmit]");
            CTitleMgrApp.WriteLine("            OR");
            CTitleMgrApp.WriteLine("    /template /titleid:<titleid> /offerid:<offerid>");
            CTitleMgrApp.WriteLine("                             [/injectboids");
            CTitleMgrApp.WriteLine("            OR");
            CTitleMgrApp.WriteLine("    /template /titleid:<titleid> /offerid:<offerid>");
            CTitleMgrApp.WriteLine("                             [/sps:notready|ready]");

        }


        public static void Help()
        {
            CTitleMgrApp.WriteLine("TitleMgr <options>");
            CTitleMgrApp.WriteLine("    -- OPTIONS -- ");
            CTitleMgrApp.WriteLine("/?                Show this help text");
            CTitleMgrApp.WriteLine("");
            CTitleMgrApp.WriteLine("Commands: (for help type titlemgr /? /<command>)");
            CTitleMgrApp.WriteLine("");
            HelpAddDefaultDescription();
            HelpAutoupdDescription();
            HelpMakeFullDescription();
            HelpChangeBaseVerDescription();
            HelpAddBaseVerDescription();
            HelpCheckDescription();
            HelpContentDescription();
            HelpDisableDescription();
            HelpEnableDescription();
            HelpExemptDescription();
            HelpLogDescription();
            HelpMatchDBDescription();
            HelpNewDescription();
            HelpResetLBDescription();
            HelpReloadFrontDoorsDescription();
            HelpRemoveUpdateDescription();
            HelpEnableUpdateDescription();
            HelpJulyVersionDescription();
            HelpRenewDescription();
            HelpVoucherDescription();
            HelpRemoveUserFromLBDescription();
            HelpChangeDatesDescription();
            HelpStatsDescription();
            HelpSyncDescription();
            HelpTemplateDescription();
            HelpTransferDescription();
            HelpTranslateDescription();
            HelpUODBUpdateDescription();
            HelpXMSDescription();
            HelpAlternateTitleIdsDescription();
            HelpSyncAlternateTitleIdsDescription();
            HelpSyncAlertsDescription();
            HelpSyncWebDBDescription();
            HelpSyncNPDBDescription();
            HelpSyncStatsDescription();
            HelpDeleteSiteDescription();
            HelpDeleteServiceDescription();
            HelpLSPSiteDescription();
            HelpSyncLSPSitesDescription();
            HelpQueryDescription();
            HelpSyncQueryDescription();
            HelpGameConfigDescription();
            HelpSyncGameConfigDescription();

            CTitleMgrApp.WriteLine("");
        }

        private static long StringToPuid(string puidStr)
        {
            if(puidStr.Substring(0, 2) == "0x")
            {
                return Int64.Parse(puidStr.Substring(2), NumberStyles.AllowHexSpecifier);
            }
            else
            {
                return Int64.Parse(puidStr);
            }
        }

        public static Ini Servers
        {
            get
            {
                return s_iniServers;
            }
        }

        public static string SDClient
        {
            get
            {
                return _sdclient;
            }
        }

        public static string SDPort
        {
            get
            {
                return _sdport;
            }
        }

        public static string SQLUser
        {
            get
            {
                return _sqluser;
            }
        }

        public static string SQLPwd
        {
            get
            {
                return _sqlpwd;
            }
        }

        public static bool Force
        {
            get
            {
                return _force;
            }
        }

        public static bool Stop
        {
            get
            {
                return _stop;
            }
        }

        public static string MessagePath
        {
            get
            {
                return "\\d$\\webroot\\msgxml";
            }
        }

        public static string DefaultUpdatePath
        {
            get
            {
                return Environment.CurrentDirectory + "\\DefaultUpdate\\update.pkg";
            }
        }

        public static bool DefaultUpdate
        {
            get
            {
                return _bDefaultUpdate;
            }
        }

        public static bool Transfer
        {
            get
            {
                return _transfer;
            }
            set
            {
                _transfer = value;
            }
        }

        public static bool IsFootball
        {
            get
            {
                if (_football == -1)
                {
                    string strFile = Environment.CurrentDirectory + "\\" + _titleid + "\\config\\versions.ini";
                    Ini vIni = new Ini(strFile);
                    if (vIni.GetSetting("VERSION", "FOOTBALL") == "TRUE")
                        _football = 1;
                    else
                        _football = 0;
                }

                if (_football == 1)
                    return true;

                return false;
            }
        }

        public static string TitleID
        {
            set
            {
                _titleid = value;
            }
            get
            {
                if (_titleid != null)
                    return _titleid;
                else
                    return "UNDEF";
            }
        }

        public static void AddMgmtCommand(string server, string command)
        {
            string combo = server + "-" + command;
            if (!_commands.Contains(combo))
            {
                CTitleMgrApp.WriteLineV("Added xmgmt: " + combo);
                _commands.Enqueue(combo);
            }
        }

        public static int RunOSqlCommand(string server, string database, string sqlfile, string workingDir)
        {
            string sqlParams = "-S " + server + " -i \"" + sqlfile + "\" -d " + database + " -n";

            if(CTitleMgrApp.SQLUser != null && CTitleMgrApp.SQLPwd != null)
                sqlParams += " -U " + CTitleMgrApp.SQLUser + " -P " + CTitleMgrApp.SQLPwd;
            else
                sqlParams += " -E";

            return RunCommandLine("osql.exe", sqlParams, workingDir);
        }

        public static int RunSqlCommand(string server, string database, string sqlcommand)
        {
            string connStr = "Server=" + server + ";Database=" + database;

            if(CTitleMgrApp.SQLUser != null && CTitleMgrApp.SQLPwd != null)
                connStr += ";User ID=" + CTitleMgrApp.SQLUser + ";Pwd=" + CTitleMgrApp.SQLPwd;
            else
                connStr += ";Integrated Security=true";

            SqlConnection conn = new SqlConnection(connStr);
            conn.Open();

            SqlCommand cmd = new SqlCommand(sqlcommand, conn);

            int hr = cmd.ExecuteNonQuery();

            conn.Close();

            return hr;

        }

        public static SqlDataReader RunSqlQuery(string server, string database, string sqlcommand)
        {
            string connStr = "Server=" + server + ";Database=" + database;

            if(CTitleMgrApp.SQLUser != null && CTitleMgrApp.SQLPwd != null)
                connStr += ";User ID=" + CTitleMgrApp.SQLUser + ";Pwd=" + CTitleMgrApp.SQLPwd;
            else
                connStr += ";Integrated Security=true";

            SqlConnection conn = new SqlConnection(connStr);
            conn.Open();

            SqlCommand cmd = new SqlCommand(sqlcommand, conn);

            return cmd.ExecuteReader();
        }

        public static int RunCommandLine(string file, string args, string workingDir)
        {
            CTitleMgrApp.WriteLineV("Running Command: "+file+" "+args);
            CTitleMgrApp.WriteLineV("In working directory of: "+workingDir);

            Process p = new Process();
            p.StartInfo.WorkingDirectory = workingDir;
            p.StartInfo.FileName = file;
            p.StartInfo.Arguments = args;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.Start();

            string output = p.StandardOutput.ReadToEnd();
            output += p.StandardError.ReadToEnd();

            if (output.IndexOf("FAIL") >= 0)
                CTitleMgrApp.Write(output);
            else
                CTitleMgrApp.WriteV(output);

            p.WaitForExit();

            return p.ExitCode;
        }

        public static Hashtable GetLeaderboardList(string statsDB, string titleid)
        {
            SqlDataReader reader = RunSqlQuery(statsDB, "xstats", "exec p_Stats_QueryLeaderBoards " + titleid);
            Hashtable leaderBoards = new Hashtable();

            if(reader != null)
            {
                while(reader.Read())
                {
                    CLeaderBoard lb = new CLeaderBoard(reader.GetInt32(0), reader.GetByte(1), LBUpdateAction.DELETE);

                    leaderBoards.Add(lb.LeaderBoardType, lb);
                }
            }

            reader.Close();

            return leaderBoards;
        }

        //
        //  Given a server type and index, return the server address.
        //  This will always return a server address as long as there are some specified in servers.ini.
        //

        public static string GetServerAddress(string serverType, int nIndex)
        {
            string servers = s_iniServers.GetSetting("SERVERS", serverType);
            if(servers.Length == 0)
            {
                return null;
            }

            string [] serverArray = servers.Split(';');

            if(nIndex < serverArray.Length)
                return serverArray[nIndex];
            else
                return serverArray[0];
        }

        //
        //  Given a server type and server address, return the index.
        //  Returns index -1 if not found.
        //

        public static int GetServerIndex(string serverType, string serverAddr)
        {
            string servers = s_iniServers.GetSetting("SERVERS", serverType);
            string [] serverArray = servers.Split(';');
            if(serverArray.Length == 0)
                return -1;

            for(int nServerIndex = 0; nServerIndex < serverArray.Length; ++nServerIndex)
            {
                if(serverArray[nServerIndex] == serverAddr)
                    return nServerIndex;
            }

            return 0;
        }

        public static bool Verbose()
        {
            if (s_log.Level > CLog.LOGFILE)
            {
                return true;
            }
            return false;
        }

        public static void Write(string s)
        {
            if (s_log == null)
            {
                Console.Write(s);
            }
            else
            {
                s_log.Write(s);
            }
        }

        public static void WriteV(string s)
        {
            if (s_log == null)
            {
                Console.Write(s);
            }
            else
            {
                s_log.WriteV(s);
            }
        }

        public static void WriteLine(string s)
        {
            if (s_log == null)
            {
                Console.WriteLine(s);
            }
            else
            {
                s_log.WriteLine(s);
            }
        }

        public static void WriteLineV(string s)
        {
            if (s_log == null)
            {
                Console.WriteLine(s);
            }
            else
            {
                s_log.WriteLineV(s);
            }
        }

        //event stuff
        public static void MyHandler(CConsoleCtrl.ConsoleEvent consoleEvent)
        {
            Console.WriteLine("Event: {0}", consoleEvent);

            if (consoleEvent == CConsoleCtrl.ConsoleEvent.CTRL_C)
            {
                Console.WriteLine("");
                Console.WriteLine("*****************************************************************************");
                Console.WriteLine("Titlemgr has received your request to stop the program.  Will stop when safe.");
                Console.WriteLine("*****************************************************************************");
                Console.WriteLine("");

                _stop = true;
            }

        }

        public static Queue GetTitleList(string strTitleID)
        {
            Queue titleIDs = new Queue();

            string [] strTitleIDs;

            string srcPath = Environment.CurrentDirectory;

            if(strTitleID.ToLower() == "all")
            {
                strTitleIDs = Directory.GetDirectories(srcPath);
                for (int i = 0; i < strTitleIDs.GetLength(0); i++)
                {
                    strTitleIDs[i] = Path.GetFileNameWithoutExtension(strTitleIDs[i]);
                }
            }
            else
            {
                strTitleIDs = strTitleID.Split(';');
            }

            foreach(string strTitle in strTitleIDs)
            {
                if(CPropUtils.IsIDTitle(strTitle))
                {
                    titleIDs.Enqueue(strTitle);
                }
            }

            return (titleIDs);
        }

        public static void RunReloadCommands()
        {
            string combo;

            if (_commands == null)
                return;

            while (_commands.Count > 0)
            {
                try
                {
                    combo = (string)_commands.Dequeue();
                    char [] separator = {'-'};
                    string [] fields = combo.Split(separator, 2);

                    if (fields.Length != 2)
                        continue;
                    string server = fields[0];
                    string command = fields[1];

                    string output = CMgmtCommand.RunCommand(server, command);

                    if (output.IndexOf("FAIL") >= 0 || output.IndexOf("not found") >= 0)
                    {
                        CTitleMgrApp.WriteLine("Error: sending xmgmt command '"+command.Trim()+"' to " + server);
                        CTitleMgrApp.WriteLine("    Error details: " + output);
                    }
                    else
                        CTitleMgrApp.WriteLineV("Output " + server + ": " + output);
                }
                catch (Exception e)
                {
                    CTitleMgrApp.WriteLine("FAIL: " + e.Message);
                }
            }
        }

        public static bool InvalidArgument(string strArg)
        {
            return (strArg == null || (strArg.Length == 0));
        }

        private static bool EmptyArgument(string strArg)
        {
            return (strArg.Length == 0);
        }

        private static void Exit()
        {
            _hr = CPropUtils.HR_EXIT;
            throw new ApplicationException("");
        }

        private static CTitleId ParseTitleId(string sTitleId)
        {
            // the caller of this function is expected to catch any exceptions
            // (including ArgumentNullException) that may be thown by CTitleId.ctor.
            // The purpose of this routine is so we don't have to prepend the 0x prefix
            // everywhere.

            // the CTitleId class expects the "0x" prefix if the titleid is in hex.
            // historically, titleids have been specified to titlemgr in hex but without
            // the 0x prefix. Starting now, we still expect the titleid to be in hex,
            // but we'll start accepting the "0x" prefix on the command line as well
            sTitleId = sTitleId.Trim().ToLower();
            if (sTitleId.Substring(0,2) != "0x")
            {
                sTitleId = "0x" + sTitleId;
            }
            CTitleId tid= new CTitleId(sTitleId);
            return tid;
        }


        private static void RunDiagnostics()
        {
            CheckSourceDepotStatus();

            // check connectivity to the webstore databases titlemgr touches
            CheckWebstoreConnectivity(ConfigUtil.UodbWebstoreApp);

            //   0        1        2        3        4        5        6        7        8
            WriteLineV(
                "Current Directory is: " + Directory.GetCurrentDirectory());

            // First output the location and version of titlemgr.exe
            CheckRunningProgramVersion();

            // Then check that all the supporting exes and dlls are there and
            // output their version info
            foreach (string sSupportBin in m_rgsSupportBins)
            {
                CheckSupportBinaryVersion(sSupportBin);
            }

            return;
        }

        private static void CheckRunningProgramVersion()
        {
            WriteLineV(
                "Checking location and version of running program.");

            string [] rgsArgs = Environment.GetCommandLineArgs();
            if (rgsArgs.Length == 0)
            {
                // according to sdk docs, this shouldn't happen, so throw
                throw new Exception("Error: Environment.GetCommandLineArgs returned zero length array.");
            }

            // the first element of the array is the program name, possibly with complete path
            // information, or String.Empty if not available.
            string sProgramPathAndFileName = rgsArgs[0];
            if (sProgramPathAndFileName == String.Empty)
            {
                //   0        1        2        3        4        5        6        7        8
                WriteLineV(
                    "Current program name not available from environment.");
                WriteLineV(
                    "    Assuming current program name is 'titlemgr.exe'");
                sProgramPathAndFileName = "titlemgr.exe";
            }
            else
            {
                //   0        1        2        3        4        5        6        7        8
                WriteLineV(
                    "Environment reports current program as: " + sProgramPathAndFileName);
            }

            sProgramPathAndFileName = CPathUtil.AddExeExtension(sProgramPathAndFileName);

            string sProgramFileName = Path.GetFileName(sProgramPathAndFileName);
            string sProgramPath = Path.GetDirectoryName(sProgramPathAndFileName);

            if (sProgramPath == String.Empty)
            {
                // there is no path information available, search the path
                // environment variable for the most likely running program
                //   0        1        2        3        4        5        6        7        8
                WriteLineV(
                    "Searching path for: " + sProgramFileName);
                sProgramPathAndFileName = CPathUtil.SearchPath(sProgramFileName);
                if (sProgramPathAndFileName == null)
                {
                    // couldn't find the program in the current directory or the path!
                    // no idea where it's coming from, so we can't check the version...
                    //   0        1        2        3        4        5        6        7        8
                    WriteLine("Error: Unable to locate " + sProgramFileName);
                    return;
                }
            }

            // we have some path information, expand it to a fully qualified path
            sProgramPathAndFileName = Path.GetFullPath(sProgramPathAndFileName);

            if (!File.Exists(sProgramPathAndFileName))
            {
                // couldn't find the program where it's supposed to be
                // no idea where it's coming from, so we can't check the version...
                //   0        1        2        3        4        5        6        7        8
                WriteLine(
                    "Error: Program " + sProgramPathAndFileName + " does not exist");
                return;
            }

            // we have a valid location for the running program, output version info
            WriteLineV(
                "filever for " + sProgramPathAndFileName);
            WriteLine(filever(sProgramPathAndFileName));
            return;
        }

        private static void CheckSupportBinaryVersion(
            string sBinName)
        {
            WriteLineV(
                "Checking support binary: " + sBinName);

            // no path information should be provided with the bin name, because
            // titlemgr calls these support programs without any path information
            // this is a private function, so it's programming error to violate this
            // therefore throw
            if (Path.GetDirectoryName(sBinName) != String.Empty)
            {
                throw new ArgumentException("No path information should be passed to "
                    + "Xbox.Tools.TitleMgr.CTitleMgr.CheckSupportBinaryVersion", "sBinName");
            }

            // search the current directory, and then the system path for the
            // support binary
            string sSupportBinPathAndFileName = CPathUtil.SearchPath(sBinName);
            if (sSupportBinPathAndFileName == null)
            {
                // the file was not found!
                //   0        1        2        3        4        5        6        7        8
                WriteLine(
                    "Error: Could not find required support program " + sBinName);
                return;
            }

            // the file was found, output the location, then check the version and output that
            //   0        1        2        3        4        5        6        7        8
            WriteLineV(
                "filever for " + sSupportBinPathAndFileName);
            WriteLine(
                filever(sSupportBinPathAndFileName));
            return;
        }

        private static string filever(string sProgramPathAndFileName)
        {
            Process p = new Process();
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.FileName = "filever";

            // quote the argument to support spaces in pathnames
            p.StartInfo.Arguments = "\"" + sProgramPathAndFileName + "\"";
            p.Start();
            string output = p.StandardOutput.ReadToEnd();
            p.WaitForExit();
            return output.Trim();
        }

        private static void CheckWebstoreConnectivity(
            string sWebstoreAppName)
        {
            //   0        1        2        3        4        5        6        7        8
            WriteLineV(
                "Checking connectivity to " + sWebstoreAppName);

            WSClient ws;
            try
            {
                ws = new WSClient(sWebstoreAppName, CmdType.WRITEONLY_COMMANDTYPE);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                WriteLine(
                    "Error: Unable to connect to " + sWebstoreAppName);
                WriteLineV(
                    "Exception:" + e.Message);
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            WriteLine(
                sWebstoreAppName + " webstore connectivity ok");
        }

        private static void CheckSourceDepotStatus()
        {
            //   0        1        2        3        4        5        6        7        8
            WriteLineV(
                "Checking sdapi.dll functionality");

            try
            {
                CSourceDepot sd;
                sd = new CSourceDepot();

                string [] files;
                sd.Opened("*.*", out files);
            }
            catch (Exception e)
            {
                //   0        1        2        3        4        5        6        7        8
                CTitleMgrApp.WriteLine(
                    "Error: Unable to access source depot");
                CTitleMgrApp.WriteLineV(
                    "Exception attempting to use sdapi. Exception details:");
                CTitleMgrApp.WriteLineV(e.Message);
                return;
            }

            //   0        1        2        3        4        5        6        7        8
            CTitleMgrApp.WriteLine(
                "sdapi.dll functionality ok");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_4_none_12.4.56.0_none_2759e4a443f69403
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.manifest
XP_MANIFEST_PATH=manifests\x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.cat
XP_CATALOG_PATH=manifests\x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.cat
XP_PAYLOAD_PATH=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\WinTDiff\CWinTDiff.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Globalization;
using System.Diagnostics;
using System.Threading;


namespace xonline.tools.titlemgr.wintdiff 
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class TDiff : System.Windows.Forms.Form
	{
        private System.Windows.Forms.Button BTest;
        private System.Windows.Forms.TextBox tTitleID;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label Output;
        
        private static string TitleMgrDirectory = Environment.CurrentDirectory;
        private System.Windows.Forms.Button BSync;

		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public TDiff()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.BTest = new System.Windows.Forms.Button();
            this.tTitleID = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.Output = new System.Windows.Forms.Label();
            this.BSync = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // BTest
            // 
            this.BTest.Location = new System.Drawing.Point(216, 16);
            this.BTest.Name = "BTest";
            this.BTest.Size = new System.Drawing.Size(104, 26);
            this.BTest.TabIndex = 3;
            this.BTest.Text = "Test";
            this.BTest.Click += new System.EventHandler(this.BTest_Click);
            // 
            // tTitleID
            // 
            this.tTitleID.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.tTitleID.Location = new System.Drawing.Point(88, 16);
            this.tTitleID.MaxLength = 8;
            this.tTitleID.Name = "tTitleID";
            this.tTitleID.Size = new System.Drawing.Size(96, 26);
            this.tTitleID.TabIndex = 1;
            this.tTitleID.Text = "";
            this.tTitleID.TextChanged += new System.EventHandler(this.tTitleID_TextChanged);
            // 
            // label1
            // 
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.label1.Location = new System.Drawing.Point(8, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(56, 26);
            this.label1.TabIndex = 2;
            this.label1.Text = "TitleID";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // Output
            // 
            this.Output.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.Output.Location = new System.Drawing.Point(16, 64);
            this.Output.Name = "Output";
            this.Output.Size = new System.Drawing.Size(496, 184);
            this.Output.TabIndex = 4;
            // 
            // BSync
            // 
            this.BSync.Location = new System.Drawing.Point(208, 256);
            this.BSync.Name = "BSync";
            this.BSync.Size = new System.Drawing.Size(128, 24);
            this.BSync.TabIndex = 5;
            this.BSync.Text = "Sync";
            this.BSync.Click += new System.EventHandler(this.BSync_Click);
            // 
            // TDiff
            // 
            this.AcceptButton = this.BTest;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.AutoScroll = true;
            this.ClientSize = new System.Drawing.Size(528, 294);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.BSync,
                                                                          this.Output,
                                                                          this.label1,
                                                                          this.tTitleID,
                                                                          this.BTest});
            this.Name = "TDiff";
            this.Text = "TitleMgr DiffTest";
            this.Load += new System.EventHandler(this.TDiff_Load);
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new TDiff());
		}

        private void tTitleID_TextChanged(object sender, System.EventArgs e)
        {
            BSync.BackColor = BTest.BackColor;
            BSync.ForeColor = BTest.ForeColor;

        }

        private void BTest_Click(object sender, System.EventArgs e)
        {
            int titleid;

            BSync.BackColor = BTest.BackColor;
            BSync.ForeColor = BTest.ForeColor;

            try
            {
                titleid = Int32.Parse(tTitleID.Text, NumberStyles.HexNumber);
            }
            catch (Exception)
            {
                MessageBox.Show("You must enter a valid hex number. eg 1AB589FF");
                tTitleID.Text = "";
                return;
            }

            try
            {
                Output.Text = "Getting Info....";
                Output.Invalidate();

                BTest.Enabled = false;

                //run the thread...
                ThreadStart pstart = new ThreadStart(RunDiff);
                Thread pthread = new Thread(pstart);   

                pthread.Start();

            }
            /*catch (ThreadStateException)
            {
                //do nothing
            }*/
            catch (Exception x)
            {
                MessageBox.Show(x.ToString(), "Error");
            }

        }

        private void RunDiff()
        {
            try
            {

                Process p = new Process();
                p.StartInfo.WorkingDirectory = TitleMgrDirectory;
                p.StartInfo.FileName = "difftest.exe";
                p.StartInfo.Arguments = "/titleid:" + tTitleID.Text;
                p.StartInfo.CreateNoWindow = true;
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.Start();
                
                Output.Text = p.StandardOutput.ReadToEnd();
                
                p.WaitForExit();

                BTest.Enabled = true;

                if (Output.Text.IndexOf("FAIL") >= 0)
                {
                    //it failed, enable a sync
                    BSync.BackColor = Color.Blue;
                    BSync.ForeColor = Color.Yellow;
                }


            }
            catch(ThreadStateException)
            {
                //this process can be interrupted at any time, so we let that happen
            }
        }

        private void RunSync()
        {
            try
            {

                Process p = new Process();
                p.StartInfo.WorkingDirectory = TitleMgrDirectory;
                p.StartInfo.FileName = "titlemgr.exe";
                p.StartInfo.Arguments = "/sync /titleid:" + tTitleID.Text;
                p.StartInfo.CreateNoWindow = false;
                p.StartInfo.UseShellExecute = true;
                p.StartInfo.RedirectStandardOutput = false;
                p.Start();
                
                p.WaitForExit();

                BSync.Enabled = true;

                if (BTest.Enabled)
                    BTest_Click(this, new EventArgs()); //simulate a new test

            }
            catch(ThreadStateException)
            {
                //this process can be interrupted at any time, so we let that happen
            }
        }


        private void TDiff_Load(object sender, System.EventArgs e)
        {
        
        }

        private void BSync_Click(object sender, System.EventArgs e)
        {
            //run a thread /sync on the titleid
            int titleid;

            BSync.BackColor = BTest.BackColor;
            BSync.ForeColor = BTest.ForeColor;

            try
            {
                titleid = Int32.Parse(tTitleID.Text, NumberStyles.HexNumber);
            }
            catch (Exception)
            {
                MessageBox.Show("You must enter a valid hex number. eg 1AB589FF");
                tTitleID.Text = "";
                return;
            }

            try
            {
                Output.Text = "Syncing....";
                Output.Invalidate();

                BSync.Enabled = false;

                //run the thread...
                ThreadStart pstart = new ThreadStart(RunSync);
                Thread pthread = new Thread(pstart);   

                pthread.Start();

            }
                /*catch (ThreadStateException)
                {
                    //do nothing
                }*/
            catch (Exception x)
            {
                MessageBox.Show(x.ToString(), "Error");
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\DiffTest\DiffTest.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Text;
using System.Text.RegularExpressions;
using System.Data;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Data.SqlClient;
using System.Xml;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.service;
using xonline.common.tools.console;


namespace xonline.tools.titlemgr.difftest
{
    public struct STriplet
    {
        //called a triplet because it used to work by region too
        public int site;
        public int version;
    };

    public struct SService
    {
        /*
            MACHINE_ONLY=[TRUE|FALSE]
            SERVICE_DESCRIPTION=<At most 30 characters describing the service>
            SERVICE_NAME=Name of service
            SITES=<semi-colon separated list of site ids>
            VERSIONS=<semi-colon separated list of title versions>
            OFFERIDS=<semi-colon separated list of hexadecimal offering ids for associated subscription>
        */

        public string id;
        public int machine_only; //MACHINE_ONLY=[TRUE|FALSE]
        public string service_description; //<At most 30 characters describing the service>
        public string service_name;
        public STriplet [] triplet;
        public int port;
        public string faketitle;
        public string [] offerids; //semi-colon separated list of hexadecimal offering ids for associated subscription
    };

    public struct SInterface
    {
        public string id;
        public string ip;
        public int port;
    };

    public struct SServer
    {
        /*
            [SERVER.<ID>]
            SERVICEIDS=<serviceId1>;<serviceId2>;;<serviceIdN>
            ADDRESS_<interfaceid1>=<ipAddress>:<port>
            ADDRESS_<interfaceid2>=<ipAddress>:<port>
        */

        public int id;
        public SService [] services; //this will contain the serviceID
        public SInterface [] interfaces;
    };

    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class CDiffTest
    {

        private static string   titleid             = null;
        private static Ini      _servers            = null;
        private static SqlConnection   _profServer  = null;
        private static SqlConnection   _uodbServer  = null;
        private static int      _football           = -1;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] rawArgs)
        {
            //
            // TODO: Add code to start application here
            //
            string [] tags = {
                                 "titleid",
                                 "once",
                                 "formula",
                                 "lb"
                             };

            NamedArgParser args = new NamedArgParser(tags);

            if (!args.Parse(rawArgs))
            {
                Help();
                return 1;
            }

            titleid = args["titleid"];

            if (titleid == "all")
            {
                //run this for each title, only printing out titles where there are errors
                Queue titleids = GetTitleList();

                foreach (string title in titleids)
                {
                    try
                    {

                        Console.WriteLine(title);
                        Console.WriteLine("--------");
                        //we don't want to check this title, it is content sample and has
                        //200+ megs of content, it takes 30 minutes to check this 1 title
                        if (title.ToUpper() == "FFFF010C")
                        {
                            Console.WriteLine("Skipping Download Sample because of excessive content.");
                            continue;
                        }

                        string output = RunCommandLine("difftest.exe", "/titleid:" + title, Environment.CurrentDirectory);
                        if (output.IndexOf("FAIL") >= 0)
                        {
                            Console.WriteLine(output);
                        }
                        else
                        {
                            Console.WriteLine("Success");
                            Console.WriteLine("");
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }

                return 0;
            }


            try
            {

                //init
                _servers = new Ini(Environment.CurrentDirectory + "\\servers.ini");

                string iniPath = Environment.CurrentDirectory + "\\ServerList.ini";
                Ini wsClientIni = new Ini(iniPath);

                string strServerList = wsClientIni.GetSetting("SERVER", "UODB");
                string strProfList = wsClientIni.GetSetting("SERVER", "XPROF");


                if(strServerList.IndexOf(',') >= 0)
                {
                    throw new ApplicationException("ServerList.ini should contain ';' separated values! Please modify the file!!.");
                }

                string [] strClients = strServerList.Split(';');
                string [] strProfClients = strProfList.Split(';');

                int nClients = strClients.Length;
                int nProfClients = strProfClients.Length;

                if (args["once"] != null)
                {
                    nClients = 1;
                    nProfClients = 1;
                }

                if (args["formula"] != null)
                {
                    string lb = args["lb"];
                    if (lb == null)
                    {
                        throw new Exception("You need to specify /lb to use /formula.");
                    }

                    SqlConnection npdbServer = new SqlConnection(ConfigUtil.NpdbConnectionString);
                    npdbServer.Open();

                    string query = "SELECT vc_formula FROM t_leaderboard_formatted_attribute_info " +
                        "WHERE i_title_id = 0x" + titleid + " AND i_lb_id = " + lb;
                    Console.WriteLine("Running query: " + query);
                    SqlCommand cmd = new SqlCommand(query, npdbServer);
                    SqlDataReader reader = cmd.ExecuteReader();

                    if (!reader.Read())
                    {
                        Console.WriteLine("Row not found in db.");
                    }
                    else
                    {
                        string formula = reader.GetString(0);

                        Console.WriteLine("Formula: " + formula);
                    }
                    reader.Close();
                    npdbServer.Close();
                    return 0;
                }

                int k;
                for(k = 0; k < nClients; k++)
                {
                    try
                    {
                        _uodbServer = new SqlConnection("data source=" + strClients[k] +
                            ";initial catalog=uodb;integrated security=SSPI;persist security info=False;packet size=4096");
                        _uodbServer.Open();

                        Console.WriteLine("Testing server " + strClients[k]);

                        //test everything
                        Console.WriteLine(TestTitle());
                        try
                        {
                            Console.WriteLine(TestVersions());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("VERSIONS: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestServiceID());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("SERVICEID: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestLeaderBoards());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("STATS: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestMatch());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("MATCH: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestMessage());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("MESSAGE: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestContent());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("CONTENT: " + e.Message);
                        }
                        try
                        {
                            Console.WriteLine(TestAutoUpdates());
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("UPDATE: " + e.ToString());
                        }

                        _uodbServer.Close();

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAIL: " + e.ToString());
                    }
                }

                for (k = 0; k <nProfClients; k++)
                {

                    _profServer = new SqlConnection("data source=" + strProfClients[k] +
                        ";initial catalog=uodb;integrated security=SSPI;persist security info=False;packet size=4096");
                    _profServer.Open();

                    Console.WriteLine("Testing PROF server " + strProfClients[k]);

                    try
                    {
                        Console.WriteLine(TestBounty());
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("BOUNTY: " + e.Message);
                    }

                }
            }

            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }

            return 0;
        }

        public static string TestTitle()
        {
            if (null == _uodbServer)
                throw new ApplicationException("FAIL: UODB not initialized");

            SqlCommand cmd = new SqlCommand("p_svc_difftest_get_title", _uodbServer);
            cmd.CommandType = CommandType.StoredProcedure;
            // return param
            SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
            rval.Direction = ParameterDirection.ReturnValue;

            SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id",
                Int32.Parse(titleid, NumberStyles.HexNumber)); //owner_puid

            SqlDataReader reader = cmd.ExecuteReader();

            bool found = false;
            if ((int)(rval.Value) == 0)
                found = true;
            reader.Close();

            if (!found)
                throw new ApplicationException("Cannot find title in t_titles"); //throw b/c we want program to quit
            else
                return "Titles: Passed";

        }

        public static string TestVersions()
        {
            Ini vIni = new Ini(Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini");
            string initial = vIni.GetSetting("VERSION", "INITIAL");
            if (!VersionExists(initial))
                return "Versions: FAIL - Can't find initial version of " + initial + " in db.";

            string additional = vIni.GetSetting("VERSION", "ADDITIONAL");
            if (additional != "")
            {
                string [] vers = additional.Split(';');

                foreach (string ver in vers)
                {
                    if (!VersionExists(ver))
                        return "Versions: FAIL - Can't find additional version of " + ver + " in db.";
                }
            }

            return "Versions: Passed";
        }

        public static bool VersionExists(string ver)
        {
            SqlCommand cmd = new SqlCommand("p_svc_difftest_get_version", _uodbServer);
            cmd.CommandType = CommandType.StoredProcedure;
            // return param
            SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
            rval.Direction = ParameterDirection.ReturnValue;

            SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id",
                Int32.Parse(titleid, NumberStyles.HexNumber)); //owner_puid

            SqlParameter sqlVersione = cmd.Parameters.Add("@i_base_version",
                Int32.Parse(ver, NumberStyles.HexNumber)); //owner_puid

            SqlParameter sqlUpdate = cmd.Parameters.Add("@i_update_version", 0);
            sqlUpdate.Direction = ParameterDirection.Output;

            SqlParameter sqlBeta = cmd.Parameters.Add("@i_beta_version", 0);
            sqlBeta.Direction = ParameterDirection.Output;

            SqlDataReader reader = cmd.ExecuteReader();

            bool found = false;
            if ((int)(rval.Value) == 0)
                found = true;

            reader.Close();
            if (!found)
                return false;

            return true;
        }



        public static string TestContent()
        {

            //kind of tricky - find all the .control files
            //each control file contains the offerid
            //check to make sure each offerid/titleid pair is in t_title_offers
            //make sure it is in t_offers
            //downloadserver is specified in .control file - make sure that the pkg file is there
            //diff the local pkg file and the remote pkg file

            string dir = Environment.CurrentDirectory + "\\" + titleid;

            string [] ctlFiles = Directory.GetFiles(dir, "*.control");

            foreach (string ctlFile in ctlFiles)
            {
                Ini ctl = new Ini(ctlFile);

                string offerid = Path.GetFileNameWithoutExtension(ctlFile);

                if (!IsIDContent(titleid, offerid))
                    continue; //autoupdate

                if (ctl.GetSetting("BILLING", "SPS").ToUpper() == "NOTREADY")
                    continue;

                if (!CheckTitleOffers(offerid))  //make sure it is in t_title_offers
                    return "Content: FAIL - Offer " + offerid + " not in t_title_offers";

                if (!CheckOffers(offerid)) //make sure it is in t_offers (need to pass more info here when I can)
                    return "Content: FAIL - Offer " + offerid + " not in t_offers";

                //check location/package info
                CheckTransfer(offerid);

                if (!CheckSqlFile(offerid)) //make sure sql2 file matches
                    return "Content: FAIL - Offer " + offerid + " does not match with sql2 file";

            } //each offerid

            return "Content: Passed";
        }

        public static uint CombineVersion(uint iHighestBuild, uint iDisc)
        {
            if (IsFootball)
                return ( (iHighestBuild << 16) | iDisc);

            return ( (iHighestBuild << 8) | iDisc);

        }

        public static bool GetDiscBuild(string version, out uint disc, out uint build)
        {
            if (version .Length != 8)
            {
                disc = 0;
                build = 0;
                return false;
            }

            string strDisc;
            string strBuild;

            if (IsFootball)
            {
                strBuild = version.Substring(0,4);
                strDisc = version.Substring(4,4);
            }
            else
            {
                strDisc = version.Substring(6, 2);
                strBuild = version.Substring(0, 6);
            }

            disc = UInt32.Parse(strDisc, NumberStyles.HexNumber);
            build = UInt32.Parse(strBuild, NumberStyles.HexNumber);

            return true;
        }

        public static bool IsFootball
        {
            get
            {
                if (_football == -1)
                {
                    string strFile = Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini";
                    Ini vIni = new Ini(strFile);
                    if (vIni.GetSetting("VERSION", "FOOTBALL") == "TRUE")
                        _football = 1;
                    else
                        _football = 0;
                }

                if (_football == 1)
                    return true;

                return false;
            }
        }

        public static ArrayList GetUpdates(string strTitle)
        {
            ArrayList rUpdates = new ArrayList();
            string [] files = Directory.GetFiles(Environment.CurrentDirectory + "\\" + strTitle, "*.control");

            foreach (string file in files)
            {
                string strID = Path.GetFileNameWithoutExtension(file);

                if (IsIDContent(strTitle, strID) == false)
                    rUpdates.Add(strID);
            }

            return rUpdates;
        }

        public static bool IsIDContent(string titleid, string strID)
        {
            Ini controlIni = new Ini(Environment.CurrentDirectory + "\\" + titleid + "\\" + strID + ".control");

            string type = controlIni.GetSetting("Package", "Type");

            if (type == "Content")
                return true;

            if (type == "AutoUpdate")
                return false;

            return (strID.ToLower().StartsWith(titleid.ToLower()));
        }

        public static string TestAutoUpdates()
        {
            //make sure that the versions are right in t_title_versions
            //get a list of package IDs for each disc
            ArrayList rUpdates = GetUpdates(titleid); //get a list of enabled updates

            //get a list of all the discs we need to prop updates for
            ArrayList rDiscs = new ArrayList();
            foreach (string update in rUpdates)
            {
                if (update.Length == 0)
                    continue;
                uint iBDisc, iBBuild,
                    iUDisc, iUBuild;
                string baseVer = update.Substring(0, 8);
                string updateVer = update.Substring(8, 8);

                if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    continue;

                if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    continue;

                if (iBDisc != iUDisc)
                    continue; //this was propped with an old version of titlemgr - we should do something here

                if (!rDiscs.Contains(iBDisc))
                    rDiscs.Add(iBDisc);
            }

            //insert all baseversions
            string versionsFile = Environment.CurrentDirectory + "\\" + titleid + "\\config\\versions.ini";
            Ini versionIni = new Ini(versionsFile);

            string version = versionIni.GetSetting("VERSION", "Initial");
            uint iVBuild, iVDisc;
            GetDiscBuild(version, out iVDisc, out iVBuild);


            if (!rDiscs.Contains(iVDisc))
                rDiscs.Add(iVDisc);

            string strVersions = versionIni.GetSetting("VERSION", "Additional");

            if (strVersions.Length > 0)
            {
                string [] rVersions = strVersions.Split(';');
                foreach (string strV in rVersions)
                {
                    GetDiscBuild(strV, out iVDisc, out iVBuild);
                    if (!rDiscs.Contains(iVDisc))
                        rDiscs.Add(iVDisc);
                }
            }

            foreach (uint iDisc in rDiscs)
            {

                ArrayList baseVers = new ArrayList();
                uint iHighestBuild = 0;
                uint iHighestFullBuild = 0;

                string strHighestVer = null;
                string strHighestFullVer = null;

                bool bHaveFull = false;

                foreach (string update in rUpdates)
                {
                    uint iBDisc, iUDisc, iBBuild, iUBuild;

                    string baseVer = update.Substring(0, 8);
                    string updateVer = update.Substring(8, 8);

                    if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    {
                        return "AutoUpdate: FAIL: The base version of " + update + " is screwy.";
                    }

                    if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    {
                        return "AutoUpdate: FAIL: The update version of " + update + " is screwy.";
                    }

                    if (iBDisc != iUDisc)
                    {
                        return "AutoUpdate: FAIL: The package " + update + " was propped with an old version of titlemgr and will never be synced again.";
                    }

                    if (iBDisc != iDisc)
                        continue; //for a  different disc

                    //we should never get here
                    if (iBBuild > iUBuild)
                    {
                        return "AutoUpdate: FAIL: Update " + update + " has a higher update than build version. ";
                    }

                    //remember this package so we can update uodb correctly
                    if (!baseVers.Contains(baseVer))
                        baseVers.Add(baseVer);

                    //we also need to make sure that all update versions can be updated to the new high
                    if (!baseVers.Contains(updateVer))
                        baseVers.Add(updateVer);

                    //if we have a new high, then set it
                    if (iUBuild > iHighestBuild)
                    {
                        iHighestBuild = iUBuild;
                        strHighestVer = update;
                    }

                    if (IsFullUpdate(titleid, update))
                        bHaveFull = true;

                    if (iUBuild > iHighestFullBuild && IsFullUpdate(titleid, update))
                    {
                        iHighestFullBuild = iUBuild;
                        strHighestFullVer = update;
                    }

                }//each update

                //insert all baseversions

                version = versionIni.GetSetting("VERSION", "Initial");
                GetDiscBuild(version, out iVDisc, out iVBuild);

                if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(version))
                    baseVers.Add(version);

                strVersions = versionIni.GetSetting("VERSION", "Additional");

                if (strVersions.Length > 0)
                {
                    string [] rVersions = strVersions.Split(';');
                    foreach (string strV in rVersions)
                    {
                        GetDiscBuild(strV, out iVDisc, out iVBuild);
                        if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(strV))
                            baseVers.Add(strV);
                    }
                }

                if (null == strHighestVer)
                {
                    //CTitleMgrApp.WriteLine("FAIL: Can't find a highest ver for disc " + iDisc.ToString());
                    continue;
                }

                uint iHighestVersion = CombineVersion(iHighestBuild, iDisc);
                uint iHighestFullVersion = CombineVersion(iHighestFullBuild, iDisc);

                CheckTransfer(strHighestVer);

                CheckTransfer(strHighestFullVer);

                foreach (string strBaseVer in baseVers)
                {
                    uint baseVer = UInt32.Parse(strBaseVer, NumberStyles.HexNumber);

                    //establish base row if not there
                    if (baseVer <= iHighestFullVersion && bHaveFull)
                    {
                        //this is a full update, so set the full field
                        CheckTitleVersion(baseVer, iHighestFullVersion, true);
                    }

                    CheckTitleVersion(baseVer, iHighestVersion, false);

                    if (!CheckUpdatePackageLocations(baseVer, strHighestVer)) //make sure sql2 file matches
                        return "AutoUpdates: FAIL - Disc " + iDisc.ToString() + "." + baseVer.ToString() +
                                " does not match with sql2 file";


                } //each update for this disc

            } //each disc

            return "AutoUpdates: Passed";
        }

        public static void CheckTransfer(string offerid)
        {
            if (offerid == null || offerid.Length == 0)
                return;

            string dir = Environment.CurrentDirectory + "\\" + titleid;
            string strSql2File = dir + "\\" +  offerid + ".sql2";
            StreamReader reader = new StreamReader(strSql2File);
            string line = reader.ReadLine();
            reader.Close();

            if (line == null || line.IndexOf("subscriptions") >= 0)
            {
                return;
            }

            Ini ctl = new Ini(dir + "\\" + offerid + ".control");
            //dli = downloadserver index
            string siteString = ctl.GetSetting("PACKAGE", "SITE");

            if (siteString == "all")
                siteString = "1";

            string [] sites = siteString.Split(';');

            foreach (string site in sites)
            {
                string dlServerString = _servers.GetSetting("SITE." + site, "DOWNLOADSERVERS");

                string [] dlServers = dlServerString.Split(';');

                foreach (string server in dlServers)
                {
                    //make sure the local pkg file matches the remote pkg file
                    if (server.Length == 0)
                        continue;

                    string localPkgFile = dir + "\\" + offerid + ".xcp";
                    string remotePkgFile = server + "\\" + titleid + "\\" + offerid + ".xcp";

                    if (!File.Exists(localPkgFile))
                        throw new ApplicationException("Content: FAIL - Can't find local package file " + localPkgFile);

                    if (!File.Exists(remotePkgFile))
                        throw new ApplicationException("Content: FAIL - Can't find remote package file " + remotePkgFile);

                    StreamReader local = new StreamReader(localPkgFile);
                    StreamReader remote = new StreamReader(remotePkgFile);

                    string sLocal = local.ReadToEnd();
                    string sRemote = remote.ReadToEnd();

                    if (sLocal != sRemote)
                        throw new ApplicationException("Content: FAIL - pkg " + offerid + " does not match remote file on " + server);

                } //each download server in the site

            } //site
        }

        public static void CheckTitleVersion(uint baseVer, uint iUpgradeVer, bool full)
        {
            SqlCommand cmd = new SqlCommand("p_svc_difftest_get_version", _uodbServer);
            cmd.CommandType = CommandType.StoredProcedure;
            // return param
            SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
            rval.Direction = ParameterDirection.ReturnValue;

            SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id",
                Int32.Parse(titleid, NumberStyles.HexNumber));

            SqlParameter sqlVersion = cmd.Parameters.Add("@i_base_version",
                (int)baseVer);

            SqlParameter sqlUpdate = cmd.Parameters.Add("@i_update_version", SqlDbType.Int);
            sqlUpdate.Direction = ParameterDirection.Output;

            SqlParameter sqlBeta = cmd.Parameters.Add("@i_beta_version", SqlDbType.Int);
            sqlBeta.Direction = ParameterDirection.Output;

            SqlDataReader reader = cmd.ExecuteReader();

            bool found = false;
            if ((int)(rval.Value) == 0)
                found = true;


            try
            {
                if (!found || sqlUpdate.Value == null || sqlBeta.Value == null)
                    throw new ApplicationException("Cannot find find baseVer " + baseVer .ToString() + " for " + titleid);

                if (full)
                {
                    if ((int)iUpgradeVer != (int)(sqlUpdate.Value))
                    {
                        throw new ApplicationException("Update ver expected " + iUpgradeVer.ToString() +
                            " but received " + ((int)sqlUpdate.Value).ToString("x"));
                    }
                }
                else
                {
                    if ((int)iUpgradeVer != (int)(sqlBeta.Value))
                    {
                        throw new ApplicationException("Beta ver expected " + iUpgradeVer.ToString() +
                            " but received " + ((int)sqlBeta.Value).ToString("x"));
                    }
                }

            }
            catch (Exception e)
            {
                Console.WriteLine("Weird: " + e.ToString());
            }
            finally
            {
                reader.Close();
            }
        }

        static public bool IsFullUpdate(string strTitleID, string strPackageID)
        {
            string ctlFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strPackageID + ".control";

            Ini ctlIni = new Ini(ctlFile);

            if (ctlIni.GetSetting("PACKAGE", "FULL").ToUpper() == "TRUE")
                return true;
            else
                return false;
        }

        public static string TestMessage()
        {
            //tough - this involves going through each language file in titleid\message dir
            //then finding the corresponding message file on every message server
            //then make sure the title description matches what is in there...

            //do foreach file in message dir
            string msgdir = Environment.CurrentDirectory + "\\" + titleid + "\\message";

            string [] files = Directory.GetFiles(msgdir, "*.xml");

            foreach (string file in files)
            {
                //in each of these files is a title description
                //get that description and match it in FILE in each msgfd

                string localdesc = GetTitleDescription(file);

                string msgline = _servers.GetSetting("SERVERS", "MSGFD");
                string [] pmsg = msgline.Split(';');

                string last_field = file.Substring(msgdir.Length + 1);

                foreach (string msg in pmsg)
                {
                    //get the right file
                    string fname = "\\\\" + msg + "\\d$\\webroot\\msgxml\\" + last_field;

                    //Console.WriteLine("Remote name: " + fname);

                    string remotedesc = GetTitleDescription(fname);

                    if (remotedesc != localdesc)
                    {
                        return "Message: FAIL - Description in " + last_field + " does not match remote file";
                    }

                    //Console.WriteLine("Match on " + last_field + ": " + remotedesc);
                }
            }

            return "Message: Passed";
        }

        public static string GetTitleDescription(string file)
        {
            //this function looks in a file for the titledescription for the titleid
            //if it can't find it, returns ""

            XmlDocument doc = new XmlDocument();
            doc.Load(file);

            XmlNodeList msgStringsNodes = doc.SelectNodes("msgstrings");

            //we only want to get from the first node
            XmlNode msgStringsNode = msgStringsNodes.Item(0);

            if(msgStringsNode.NodeType != XmlNodeType.Element)
                return "";

            XmlElement msgStringsElem = (XmlElement)msgStringsNode;

            //make sure we are looking at something type 1 (the title is type 1)
            int nType = Int32.Parse(msgStringsElem.GetAttribute("type"));
            if(nType != 1)
                return "";

            string langStr = msgStringsElem.GetAttribute("language");
            if(langStr == null)
            {
                return "";
            }

            int nLang = Int32.Parse(langStr);

            string longTitleIDString = Int64.Parse(titleid, NumberStyles.HexNumber).ToString();

            XmlNode msgMappingNode = msgStringsElem.SelectSingleNode("child::msgmapping[attribute::id=\"" + longTitleIDString + "\"]");
            if(msgMappingNode != null)
            {
                if(msgMappingNode.NodeType != XmlNodeType.Element)
                    return "";

                XmlElement msgMappingElem = (XmlElement)msgMappingNode;

                return msgMappingElem.InnerText;
            }

            return "";
        }

        public static string TestMatch()
        {
            //all we can really do for match is make sure that they are in the db

            //the other setting for match requires generating SQL and then uploading it to db
            //testing this would require CHANGING the database, so it's not worth it

            //there is already a sp in the database, p_match_title_get_all which does exactly that
            //it is less efficient than writing my own stored procedure which checks for the existance of a single title
            //however, the less impact I have on the database, the better - if we decide to go the more efficient route,
                //that is easily accomplished

            string xmsFile = Environment.CurrentDirectory + "\\" + titleid + "\\matchsp\\" + titleid + ".xms";
            if(!File.Exists(xmsFile))
                return "Match: Passed"; //you're only in match if this file exists




            Ini matchini = new Ini(Environment.CurrentDirectory + "\\" + titleid + "\\config\\match.ini");
            int index = Int32.Parse(matchini.GetSetting("SETTINGS", "MATCHDB"));

            //find our db
            string matchline = _servers.GetSetting("SERVERS", "MATCHDB");
            string [] pmatch = matchline.Split(';');
            string match = pmatch[index];
            string npdb = _servers.GetSetting("SERVERS", "NPDB");

            SqlDataReader reader = RunSqlQuery(npdb, "npdb", "exec p_match_title_get_all");

            int ntitleid  = 0;
            try
            {
                ntitleid = Int32.Parse(titleid, NumberStyles.HexNumber);

                while (reader.Read())
                {
                    if (ntitleid == reader.GetInt32(0))
                    {
                        return "Match: Passed";
                    }
                }
            }
            finally
            {
                reader.Close();
            }

            try
            {
                reader = RunSqlQuery(match, "xmatch", "Select * FROM t_match_sessions_" + ntitleid.ToString());
                reader.Close();
            }
            catch(Exception)
            {
                return "Match: FAIL - Table t_match_sessions_" + ntitleid.ToString() + " does not exist.";
            }

            return "Match: FAIL - Title not found in matchdb";

        }

        public static string TestLeaderBoards()
        {
            //get the index of the db (db list in servers.ini)
            if (File.Exists(Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.xml"))
            {
                return "Stats: Skipped - Difftest doesn't have stats.xml support yet.";
            }

            Ini statsini = new Ini(Environment.CurrentDirectory + "\\" + titleid + "\\config\\stats.ini");
            int index = Int32.Parse(statsini.GetSetting("SETTINGS", "STATSDB"));

            //find our db
            string statsline = _servers.GetSetting("SERVERS", "STATSDB");
            string [] pstats = statsline.Split(';');
            string stats = pstats[index];
            string hr = "";


            string ntitleid = (Int32.Parse(titleid, NumberStyles.HexNumber)).ToString(); //used in sql command

            SqlDataReader reader = RunSqlQuery(stats, "xstats", "exec p_Stats_QueryLeaderBoards " + ntitleid);

            try
            {
                int count = 0;

                //make sure everything in the db matches up with what's in ini file
                while (reader.Read())
                {
                    //leaderbrd # in GetInt32(0)
                    //type in GetByte(1)
                    count++;

                    int num = reader.GetInt32(0);
                    int type = (int)reader.GetByte(1);

                    string initype = statsini.GetSetting("LEADERBOARDS", num.ToString());

                    if (Int32.Parse(initype) != type)
                    {
                        hr =  "Stats: FAIL - Leaderboard " + num.ToString() + " doesn't match from server";
                        goto Done;
                    }
                }

                StringDictionary lbSection = statsini.GetSection("LEADERBOARDS");

                if (lbSection.Count != count)
                {
                    hr = "Stats: FAIL - There are leaderboards in the ini file NOT in the db";
                    goto Done;
                }
            }
            finally
            {
                reader.Close();
            }
            hr = "Stats: Passed";

Done:
            return hr;
        }

        public static string TestBounty()
        {
            //make sure that if Bounty=DATE is in versions.ini than a row exists in the bounty table
            //Also, if Bounty=DATE does NOT exist, then it shouldn't be in the bounty table

            string dir = Environment.CurrentDirectory + "\\" + titleid + "\\config\\";

            Ini version = new Ini(dir + "versions.ini");

            if (version.GetSetting("VERSION", "MakeExempt") != "") //sync needs to make them exempt
                return "Bounty: FAIL - Title marked as MakeExempt=1 - need to run sync";

            string date = version.GetSetting("STATUS", "EXEMPT");

            //date = null implies not exempt
            //string query = "SELECT * FROM t_xprof_bounty_exempt_titles WHERE i_title_id = 0x" + titleid;
            SqlCommand cmd = new SqlCommand("p_xprof_difftest_get_exempt_title", _profServer);
            cmd.CommandType = CommandType.StoredProcedure;
            // return param
            SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
            rval.Direction = ParameterDirection.ReturnValue;

            SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id",
                Int32.Parse(titleid, NumberStyles.HexNumber));

            SqlDataReader reader = cmd.ExecuteReader();

            bool found = false;
            if ((int)(rval.Value) == 1)
                found = true;
            reader.Close();

            if (found)
            {
                if (date == "")
                    return "Bounty: FAIL - Exempt in db but it shouldn't be";
            }
            else
            {
                if (date != "")
                    return "Bounty: FAIL - Not exempt in db, but it should be";
            }

            return "Bounty: Passed";
        }


        public static string TestServiceID()
        {
            try
            {
                ArrayList services = new ArrayList();
                ArrayList servers = new ArrayList();

                int i; //my counter

                int nTitleId = Int32.Parse(titleid, NumberStyles.HexNumber);

                //
                //  Do we have any work to do?
                //

                string serviceIdIniPath = Environment.CurrentDirectory + "\\" + titleid + "\\config\\serviceid.ini";
                if(!File.Exists(serviceIdIniPath))
                {
                    //if there is no serviceid.ini file then the database has to be up to date
                    return "Services: Passed";
                }


                //
                //  Get list of uodb hash buckets.
                //

                string WSClientIniPath = Environment.CurrentDirectory + "\\wsclient.ini";

                string [] hashBuckets = null;

                if(File.Exists(WSClientIniPath))
                {
                    Ini WSClientIni = new Ini(WSClientIniPath);
                    string hashBucketList = WSClientIni.GetSetting("Webstore", "HashBuckets").Trim();
                    if(hashBucketList != null && hashBucketList.Length != 0)
                    {
                        if(hashBucketList.IndexOf(',') < 0)
                        {
                            hashBuckets = hashBucketList.Split(';');
                        }
                        else
                        {
                            //Console.WriteLine("_uodbClient.ini should contain ';' separated values! Please modify the file!!.");
                            return "Services: FAIL - bad wsclient.ini file";
                        }
                    }
                }

                if(hashBuckets == null)
                    hashBuckets = new string[] { "1" };

                //
                //  Load serviceid.ini file
                //

                Ini serviceIdIni = new Ini(serviceIdIniPath);
                Hashtable serviceIds = serviceIdIni.Sections;

                //
                //  Find all the services, add them to the array
                //

                foreach(DictionaryEntry section in serviceIds)
                {
                    //
                    //  Get section and derive service id from it
                    //

                    string sectionName = section.Key.ToString();

                    if (sectionName.IndexOf("SERVICE") >= 0)
                    {
                        SService s = new SService();


                        s.id = sectionName.Split('.')[1];

                        string machine = serviceIdIni.GetSetting(sectionName, "MACHINE_ONLY");

                        if (machine == "TRUE")
                            s.machine_only = 1;
                        else
                            s.machine_only = 0;

                        s.service_description = serviceIdIni.GetSetting(sectionName, "SERVICE_DESCRIPTION");
                        s.service_name = serviceIdIni.GetSetting(sectionName, "SERVICE_NAME");

                        string [] sites;
                        string [] versions;

                        sites = serviceIdIni.GetSetting(sectionName, "SITES").Split(';');
                        versions = serviceIdIni.GetSetting(sectionName, "VERSIONS").Split(';');

                        if (sites.Length != versions.Length)
                        {
                            return "FAIL: Bad serviceid.ini - sites.length != versions.length";
                        }

                        string strPort = serviceIdIni.GetSetting(sectionName, "PORT");

                        s.port = Int32.Parse(strPort);

                        s.triplet = new STriplet[sites.Length];

                        for (i = 0; i < sites.Length; i++)
                        {
                            s.triplet[i].site = Int32.Parse(sites[i]);
                            s.triplet[i].version = Int32.Parse(versions[i]);
                        }

                        string faketitle = serviceIdIni.GetSetting(sectionName, "TITLEID");
                        if (faketitle.Length > 0)
                            s.faketitle = faketitle;
                        else
                            s.faketitle = titleid;
                        string offerids = serviceIdIni.GetSetting(sectionName, "OFFERIDS");

                        if (offerids != null && offerids.Length > 0)
                        {
                            s.offerids = offerids.Split(';');
                        }
                        else
                            s.offerids = new string[0];

                        services.Add(s);

                    } //created the service
                }

                //
                //  Now, find all the servers, add them to the array
                //

                serviceIds = serviceIdIni.Sections;

                foreach(DictionaryEntry section in serviceIds)
                {
                    //
                    //  Get section and derive server id from it
                    //

                    string sectionName = section.Key.ToString();

                    SServer s;

                    if (sectionName.IndexOf("SERVER") >= 0)
                    {
                        //get the id (part of the section name)
                        s.id = Int32.Parse(sectionName.Split('.')[1]);

                        //there is a list of service ids - find the service they are, and assign them
                        string [] serviceids = serviceIdIni.GetSetting(sectionName, "SERVICEIDS").Split(';');

                        s.services = new SService[serviceids.Length];

                        for (int j = 0; j < serviceids.Length; j++)
                        {
                            for (i = 0; i < services.Count; i++)
                            {
                                if (((SService)services[i]).id == serviceids[j])
                                {
                                    s.services[j] = (SService)services[i];
                                    break;
                                }
                            }

                            if (i == services.Count)
                            {
                                //Console.WriteLine("Service not found for server " + s.id + " with id " + s.id.ToString());
                                return "Services: FAIL - bad ini file";
                            }
                        }

                        StringDictionary settings = serviceIdIni.GetSection(sectionName);


                        s.interfaces = new SInterface[settings.Count - 1]; //subtract 1 for the SERVICEIDS
                        int icount = 0;

                        foreach(DictionaryEntry setting in settings)
                        {
                            //find all those that start with interface_<id> - and map them to the interfaces
                            string settingName = setting.Key.ToString();

                            if (settingName.IndexOf("ADDRESS") < 0)
                                continue;


                            string iface = serviceIdIni.GetSetting(sectionName, settingName);

                            SInterface face;

                            //id is part of setting name
                            face.id = settingName.Split('_')[1];

                            string [] ip_port = iface.Split(':');

                            //this are the value (ip:port)
                            face.ip = ip_port[0];
                            face.port = Int32.Parse(ip_port[1]);

                            s.interfaces[icount++] = face;
                        }

                        servers.Add(s);

                    } //created the server

                }

                //we have now populated the services, and the servers arraylists
                //should be easy to populate uodb now...

                for(i = 0; i < services.Count; i++)
                {
                    //insert into t_services
                    SService s = (SService)services[i];

                    if (!GetTServices(Int32.Parse(s.id), "sg", "S" + s.id, s.service_description, s.machine_only))
                        return "Services: FAIL - missing " + s.id + "-" + s.service_description + s.machine_only + " in tservices";

                    //foreach triplet insert it into service_instances, along with the default port
                    foreach (STriplet t in s.triplet)
                    {
                        //insert the triplet (now doublet) into the service_instances table
                        if (!GetTServiceInstances(Int32.Parse(s.id), Int32.Parse(s.faketitle, NumberStyles.HexNumber),
                            t.version, t.site,
                            s.port, 1))
                            return "Services: FAIL - missing " + s.id + " in tserviceinstances";

                    } //each triplet

                    //insert each offer the service has
                    foreach (string offer in s.offerids)
                    {
                        string strOffer = offer;

                        if (offer.Length > 2 && offer.IndexOf("0x") >= 0)
                            strOffer = offer.Substring(2);

                        if (!GetTOfferServices(Int64.Parse(strOffer, NumberStyles.HexNumber), Int32.Parse(s.id)))
                            return "Services: FAIL - missing " + strOffer + " in offerservices";

                    } //each offer
                } //each service

            }
            catch (Exception e)
            {
                return "Services: FAIL - " + e.Message;
            }

            return "Services: Passed";
        }

        private static bool GetTServices(int id, string name, string domain, string desc, int machine_only)
        {
          /*
                    @i_service_id      int
                    ,@i_machine_only    int
                    ,@vc_description    nvarchar(30)
                    ,@vc_service_name   nvarchar(30)
            */

            /*
            _uodb.StoredProc = "p_askdc_get_service";

            _uodb.AddParameter(ParamType.RETVAL, 0);
            _uodb.AddParameter(ParamType.INPUT, id);
            _uodb.AddParameter(ParamType.INPUT, machine_only);
            _uodb.AddParameter(ParamType.INPUT, desc, (uint)desc.Length);
            _uodb.AddParameter(ParamType.INPUT, domain, (uint)domain.Length);
            */

            SqlDataReader reader = null;
            bool found;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_service", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;
                SqlParameter sqlService = cmd.Parameters.Add("@i_service_id", id);
                SqlParameter sqlMachine = cmd.Parameters.Add("@i_machine_only", machine_only);
                SqlParameter sqlDesc = cmd.Parameters.Add("@vc_description", desc);
                SqlParameter sqlDomain = cmd.Parameters.Add("@vc_kerb_domain_name", domain);

                reader = cmd.ExecuteReader();
                found = false;
                if ((int)rval.Value == 0)
                    found = true;
            }
            catch(Exception e )
            {
                Console.WriteLine("Failed s " + e.Message);
                return false;
            }
            finally
            {
                if (reader != null)
                    reader.Close();

            }

            if (!found)
                return false;

            return true;
        }

        private static bool GetTOfferServices(long offerid, int service_id)
        {
           /*
                  @bi_offer_id       bigint
                  ,@i_service_id      int
            */
            /*
            _uodb.StoredProc = "p_askdc_get_offer_services";

            _uodb.AddParameter(ParamType.RETVAL, 0);
            _uodb.AddParameter(ParamType.INPUT, offerid);
            _uodb.AddParameter(ParamType.INPUT, service_id);
            */
            SqlDataReader reader = null;
            bool found = false;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_services", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;
                SqlParameter sqlService = cmd.Parameters.Add("@i_service_id", service_id);
                SqlParameter sqlOffer = cmd.Parameters.Add("@bi_offer_id", offerid);

                reader = cmd.ExecuteReader();
                if ((int)rval.Value == 0)
                    found = true;
            }
            catch(Exception e )
            {
                Console.WriteLine("Failed s " + e.Message);
                return false;
            }
            finally
            {
                if (reader != null)
                    reader.Close();

            }

            if (!found)
                return false;

            return true;
        }

        private static bool GetTServiceInstances(int service_id, int titleid, int version, int site,
            int port, int online)
        {

            /*
                 @i_service_id      int
                ,@i_title_id        int
                ,@i_site_id         int
                ,@i_title_version   int
                ,@i_port            int
            */

            /*
            _uodb.StoredProc = "p_askdc_get_service_instance";

            _uodb.AddParameter(ParamType.RETVAL, 0);
            _uodb.AddParameter(ParamType.INPUT, service_id);
            _uodb.AddParameter(ParamType.INPUT, titleid);
            _uodb.AddParameter(ParamType.INPUT, site);
            _uodb.AddParameter(ParamType.INPUT, version);
            _uodb.AddParameter(ParamType.INPUT, port);
            */
            SqlDataReader reader = null;
            bool found = false;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_service_instances", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;
                SqlParameter sqlService = cmd.Parameters.Add("@i_service_id", service_id);
                SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id", titleid);
                SqlParameter sqlVersion = cmd.Parameters.Add("@i_title_version", version);

                reader = cmd.ExecuteReader();
                if ((int)rval.Value == 0)
                    found = true;
            }
            catch(Exception e )
            {
                Console.WriteLine("Failed s " + e.Message);
                return false;
            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }

            reader.Close();
            if (!found)
                return false;

            return true;
        }

        public static void Help()
        {
            Console.WriteLine("Usage: DiffTest.exe /titleid:<titleid> [/once]");
            Console.WriteLine("");
        }

        public static SqlDataReader RunSqlQuery(string server, string database, string sqlcommand)
        {
            string connStr = "Server=" + server + ";Database=" + database;

            connStr += ";Integrated Security=true";

            SqlConnection conn = new SqlConnection(connStr);
            conn.Open();

            SqlCommand cmd = new SqlCommand(sqlcommand, conn);
            return cmd.ExecuteReader();
        }

        public static bool CheckTitleOffers(string offerid)
        {
            bool hr = false;
            SqlDataReader reader = null;
            /*
            _uodb.StoredProc = "p_xbos_load_offer_titles";

            _uodb.AddParameter(ParamType.RETVAL, 0); //hr
            _uodb.AddParameter(ParamType.INPUT, Int64.Parse(offerid, NumberStyles.HexNumber));
            */
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_title_offer", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                SqlParameter sqlTitle = cmd.Parameters.Add("@i_title_id",
                    Int32.Parse(titleid, NumberStyles.HexNumber));
                SqlParameter sqlOffer = cmd.Parameters.Add("@bi_offer_id",
                    Int64.Parse(offerid, NumberStyles.HexNumber));

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) == 0)
                    hr = true;
            }
            catch (Exception e)
            {
                Console.WriteLine("Weird: " + e.ToString());
            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }

            return hr;
        }

        public static bool CheckOffers(string offerid)
        {

            DateTime sd = DateTime.Now;
            DateTime ed = DateTime.Now;
            bool hr = false;


            SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_dates", _uodbServer);
            cmd.CommandType = CommandType.StoredProcedure;

            // return param
            SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
            rval.Direction = ParameterDirection.ReturnValue;

            SqlParameter sqlOffer = cmd.Parameters.Add("@bi_offer_id",
                Int64.Parse(offerid, NumberStyles.HexNumber));
            SqlParameter sqlStartDate = cmd.Parameters.Add("@dt_start_date",
                SqlDbType.DateTime);
            sqlStartDate.Direction = ParameterDirection.Output;
            SqlParameter sqlEndDate = cmd.Parameters.Add("@dt_end_date",
                SqlDbType.DateTime);
            sqlEndDate.Direction = ParameterDirection.Output;


            SqlDataReader reader = cmd.ExecuteReader();

            if ((int)(rval.Value) != 0)
                goto Done;

            string ctlFile = Environment.CurrentDirectory + "\\" + titleid + "\\" + offerid + ".control";

            Ini ctlIni = new Ini(ctlFile);

            sd = (DateTime)sqlStartDate.Value;
            string startDate = ctlIni.GetSetting("Content", "StartDate").Trim();
            if (startDate != null && startDate.Length > 0)
            {
                if (sd != Convert.ToDateTime(startDate))
                    throw new ApplicationException("FAIL: The start date for " + offerid + " is wrong. " + sd.ToString("MM-dd-yyyy"));
            }

            ed = (DateTime)sqlEndDate.Value;
            string endDate = ctlIni.GetSetting("Content", "EndDate").Trim();
            if (endDate != null && endDate.Length > 0)
            {
                if (ed != Convert.ToDateTime(endDate))
                    throw new ApplicationException("FAIL: The end date for " + offerid + " is wrong." + sd.ToString("MM-dd-yyyy"));
            }

            hr = true;

Done:
            reader.Close();
            return hr;
        }

        public static bool CheckUpdatePackageLocations(uint baseVer, string strHighestVer)
        {
            StreamReader  sr = null;
            string strSQL2File = Environment.CurrentDirectory + "\\" + titleid + "\\" + strHighestVer + ".sql2";

            //don't run this if baseVer = HighestVer
            string updateVer = strHighestVer.Substring(8, 8);
            uint highVer = UInt32.Parse(updateVer, NumberStyles.HexNumber);
            if (baseVer == highVer)
                return true;

            sr = File.OpenText(strSQL2File);

            string strFileContent = sr.ReadToEnd();
            sr.Close();
            string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

            bool passed = true;
            foreach (string strProc in strStoredProcedures)
            {
                try
                {
                    string [] paramsArray = Regex.Split(strProc, "[,]");

                    for(int i = 0 ; i < paramsArray.Length; i++)
                    {
                        paramsArray[i] = paramsArray[i].Trim();
                        paramsArray[i] = paramsArray[i].Replace("'", "");
                        if (paramsArray[i].Length > 2 && paramsArray[i].Substring(0, 2) == "0x")
                            paramsArray[i] = paramsArray[i].Substring(2);
                    }

                    string[] strFirst = Regex.Split(paramsArray[0], "\\s+");

                    if (strFirst.Length != 2)
                        continue;

                    string strSPName = strFirst[0];
                    paramsArray[0] = strFirst[1];

                    switch (strSPName)
                    {
                        case "p_svc_insert_title_update_packages":
                            CheckParamsTitleUpdatePackages(paramsArray, baseVer);
                            break;
                        case "p_svc_insert_title_update_locations":
                            CheckParamsTitleUpdateLocations(paramsArray, baseVer);
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.ToString());
                    passed = false;
                }
            }

            return passed;
        }

        public static void CheckParamsTitleUpdatePackages(string [] paramsArray, uint baseVer)
        {
            SqlDataReader reader = null;
            try
            {
                /*
                @i_title_id             int,
                @i_title_base_version   int,
                @i_title_update_version int,
                @i_package_size         int,
                @i_install_size         int,
                @vb_update_sym_key      varbinary(16),
                @vb_public_key          varbinary(284)
                */

                if (paramsArray.Length < 7)
                    throw new Exception("Params array is too small: " + paramsArray.Length.ToString());

                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_title_update_packages", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                SqlParameter sqlOffer = cmd.Parameters.Add("@i_title_id",
                    Int32.Parse(titleid, NumberStyles.HexNumber));

                cmd.Parameters.Add("@i_title_base_version", (int)baseVer);
                cmd.Parameters.Add("@i_title_update_version", Int32.Parse(paramsArray[2], NumberStyles.HexNumber));

                SqlParameter sqlPackageSize = cmd.Parameters.Add("@i_package_size",
                            SqlDbType.Int);
                sqlPackageSize.Direction = ParameterDirection.Output;

                SqlParameter sqlInstallSize = cmd.Parameters.Add("@i_install_size",
                            SqlDbType.Int);
                sqlInstallSize.Direction = ParameterDirection.Output;

                SqlParameter sqlUpdateKey = cmd.Parameters.Add("@vb_update_sym_key", "");
                sqlUpdateKey.SqlDbType = SqlDbType.VarBinary;
                sqlUpdateKey.Direction = ParameterDirection.Output;

                SqlParameter sqlPublicKey = cmd.Parameters.Add("@vb_public_key", "");
                sqlPublicKey.SqlDbType = SqlDbType.VarBinary;
                sqlPublicKey.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new Exception("Update package " + baseVer.ToString() + " -> " + paramsArray[2] + " not in the database");


                if ((int)(sqlPackageSize.Value) != HexParse(paramsArray[3]))
                    throw new ApplicationException("Package size differs for update " + baseVer.ToString() + " -> " + paramsArray[2]);

                if ((int)(sqlInstallSize.Value) != HexParse(paramsArray[4]))
                    throw new ApplicationException("Package install size differs for update " + baseVer.ToString() + " -> " + paramsArray[2]);

                if (CompareBytes(sqlUpdateKey.Value, paramsArray[5]))
                    throw new ApplicationException("Symmetric key differs for update " + baseVer.ToString() + " -> " + paramsArray[2] +
                        ": " + sqlUpdateKey.Value.ToString() + " vs " + paramsArray[5]);

                if (CompareBytes(sqlPublicKey.Value, paramsArray[6]))
                    throw new ApplicationException("Public key differs for update " + baseVer.ToString() + " -> " + paramsArray[2] +
                        ": " + sqlPublicKey.Value.ToString() + " vs " + paramsArray[6]);

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static void CheckParamsTitleUpdateLocations(string [] paramsArray, uint baseVer)
        {
            SqlDataReader reader = null;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_title_update_locations", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                SqlParameter sqlOffer = cmd.Parameters.Add("@i_title_id",
                    Int32.Parse(titleid, NumberStyles.HexNumber));

                cmd.Parameters.Add("@i_title_base_version", (int)baseVer);
                cmd.Parameters.Add("@i_title_update_version", Int32.Parse(paramsArray[2], NumberStyles.HexNumber));
                SqlParameter sqlRank = cmd.Parameters.Add("@i_location_rank",  Int32.Parse(paramsArray[3], NumberStyles.HexNumber));

                SqlParameter sqlXRL = cmd.Parameters.Add("@vc_XRL", SqlDbType.VarChar, 500);
                sqlXRL.SqlDbType = SqlDbType.VarChar;
                sqlXRL.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new Exception("Update location " + baseVer.ToString() + " -> " + paramsArray[2] +
                        " with rank " + paramsArray[3] + " not in the database");

                //char [] chars = (char [])(sqlXRL.Value);
                string str = cmd.Parameters["@vc_XRL"].Value.ToString();

                if (str.ToUpper() != paramsArray[4].ToUpper())
                    throw new ApplicationException("XRL differs for location " + baseVer.ToString() + " -> " +
                        paramsArray[2] + " with rank " + paramsArray[3] + ": " + str.ToUpper() +
                                " vs " + paramsArray[4].ToUpper());

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static bool CompareBytes(object bytes, string param)
        {
            byte [] symBuffer = (byte[]) bytes;
            int length = symBuffer.Length;
            string strHex = ByteToHexStr(symBuffer, length);
            if (param.IndexOf("0x") == 0)
                strHex = "0x" + strHex;

            if (strHex != param)
            {
                return false;
            }

            return true;
        }

        public static bool CompBytes(SqlDataReader reader, string param, int index)
        {
            byte [] symBuffer = new byte[param.Length];
            long length = reader.GetBytes(index, 0, symBuffer, 0, symBuffer.Length);
            string strHex = ByteToHexStr(symBuffer, length);
            if (param.IndexOf("0x") == 0)
                strHex = "0x" + strHex;

            if (strHex != param)
                return false;

            return true;
        }

        public static bool CheckSqlFile(string offerid)
        {
            //go through the sql file making sure it matches up
            string strSQL2File = Environment.CurrentDirectory + "\\" + titleid + "\\" + offerid + ".sql2";
            StreamReader sr = File.OpenText(strSQL2File);

            string strFileContent = sr.ReadToEnd();
            string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

            bool passed = true;

            foreach (string strProc in strStoredProcedures)
            {
                try
                {
                    string [] paramsArray = Regex.Split(strProc, "[,]");

                    for(int i = 0 ; i < paramsArray.Length; i++)
                    {
                        paramsArray[i] = paramsArray[i].Trim();
                        paramsArray[i] = paramsArray[i].Replace("'", "");
                    }

                    string[] strFirst = Regex.Split(paramsArray[0], "\\s+");

                    if (strFirst.Length != 2)
                        continue;

                    string strSPName = strFirst[0];
                    paramsArray[0] = strFirst[1];

                    switch (strSPName)
                    {
                        case "p_svc_insert_offers":
                        case "p_svc_insert_subscriptions":
                            CheckParamsInsertOffers(paramsArray, offerid);
                            break;
                        case "p_svc_insert_offer_descriptions":
                            CheckParamsInsertOfferDescriptions(paramsArray, offerid);
                            break;
                        case "p_svc_insert_offer_description_details":
                            CheckParamsInsertOfferDescriptionDetails(paramsArray, offerid);
                            break;
                        case "p_svc_insert_offer_locations":
                            CheckParamsInsertOfferLocations(paramsArray, offerid);
                            break;
                        case "p_svc_insert_offer_regions":
                            CheckParamsInsertOfferRegions(paramsArray, offerid);
                            break;
                        case "p_svc_insert_offer_relations":
                            CheckParamsInsertOfferRelations(paramsArray, offerid);
                            break;
                        case "p_svc_offer_change_dates":
                            CheckParamsChangeOfferDates(paramsArray, offerid);
                            break;
                        default:
                            throw new System.Exception("Error:  Invalid procedure name: " + strSPName );
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.ToString());
                    passed = false;
                }
            }

            return passed;
        }

        public static void CheckParamsInsertOfferDescriptions(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                /*
                @bi_offer_id            bigint,
                @vb_enum_blob           varbinary(8000),
                @i_description_index    int

                */

                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_descriptions", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));
                cmd.Parameters.Add("@i_description_index", Int32.Parse(paramsArray[2]));

                SqlParameter blob = cmd.Parameters.Add("@vb_enum_blob", SqlDbType.VarBinary, 8000);
                blob.SqlDbType = SqlDbType.VarBinary;
                blob.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new Exception("Offer description for " + offerid +
                        " with index " + paramsArray[2] + " not in the database");

                if (!CompareBytes(blob.Value, paramsArray[1]))
                    throw new ApplicationException("Description blob differs in descriptions " + paramsArray[2] +
                        " in offer " + offerid + " with " + blob.Value.ToString());

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static void CheckParamsInsertOfferDescriptionDetails(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                /*
                @bi_offer_id            bigint,
                @vb_details_blob        varbinary(8000),
                @i_description_index    int,
                @i_order                int
                */

                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_description_details", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));
                cmd.Parameters.Add("@i_order", Int32.Parse(paramsArray[3]));

                SqlParameter index = cmd.Parameters.Add("@i_description_index", SqlDbType.Int);
                index.Direction = ParameterDirection.Output;

                SqlParameter blob = cmd.Parameters.Add("@vb_details_blob", SqlDbType.VarBinary, 8000);
                blob.Direction = ParameterDirection.Output;


                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new Exception("Offer description detail for " + offerid +
                        " with order " + paramsArray[3] + " not in the database");

                if (!CompareBytes(blob.Value, paramsArray[1]))
                    throw new ApplicationException("Detail blob differs in desc details " + paramsArray[3] + " in offer " + offerid);

                if ((int)(index.Value) != Int32.Parse(paramsArray[2]))
                    throw new ApplicationException("Index differs in details " + paramsArray[3] + " in offer " + offerid);

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static void CheckParamsInsertOfferLocations(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                /*
                @bi_offer_id            bigint,
                @i_location_rank        int,
                @vc_XRL                 nvarchar(4000)

                */
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_locations", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));
                cmd.Parameters.Add("@i_location_rank", Int32.Parse(paramsArray[1]));

                SqlParameter xrl = cmd.Parameters.Add("@vc_XRL", SqlDbType.VarChar, 256);
                xrl.SqlDbType = SqlDbType.VarChar;
                xrl.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new ApplicationException("Offer " + offerid + " and location " + paramsArray[1] + " not in the database");

                if (xrl.Value.ToString().ToUpper() != paramsArray[2].ToUpper())
                    throw new ApplicationException("XRL does not match in location " + paramsArray[1] + " from " + offerid);
            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }

        }

        public static void CheckParamsInsertOfferRegions(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                /*
                @bi_offer_id               bigint,
                @ti_country_id             tinyint,
                @vc_billing_offer_id       nvarchar(36),
                @i_price_whole             int,
                @i_price_fractional        int,
                @si_specific_offer_details smallint
               */
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_regions", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));
                cmd.Parameters.Add("@ti_country_id", Int32.Parse(paramsArray[1]));

                SqlParameter boid = cmd.Parameters.Add("@vc_billing_offer_id", SqlDbType.VarChar, 36);
                boid.SqlDbType = SqlDbType.VarChar;
                boid.Direction = ParameterDirection.Output;

                SqlParameter price_whole = cmd.Parameters.Add("@i_price_whole", SqlDbType.Int);
                price_whole.Direction = ParameterDirection.Output;
                SqlParameter price_fractional = cmd.Parameters.Add("@i_price_fractional", SqlDbType.Int);
                price_fractional.Direction = ParameterDirection.Output;
                SqlParameter details = cmd.Parameters.Add("@si_specific_offer_details", SqlDbType.Int);
                details.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new ApplicationException("Offer " + offerid + " and location " + paramsArray[1] + " not in the database");

                if ((string)(boid.Value).ToString().ToUpper() != paramsArray[2].ToUpper())
                    throw new ApplicationException("BOID does not match in region " + paramsArray[1] + " from " + offerid +
                        " with boid " + boid.Value.ToString() );

                if ((int)(price_whole.Value) != Int32.Parse(paramsArray[3]))
                    throw new ApplicationException("Price whole does not match in region " + paramsArray[1] + " from " + offerid);

                if ((int)(price_fractional.Value) != Int32.Parse(paramsArray[4]))
                    throw new ApplicationException("Price fractional does not match in region " + paramsArray[1] + " from " + offerid);

                if ((int)(details.Value) != HexParse(paramsArray[5]))
                    throw new ApplicationException("Specific details does not match in region " + paramsArray[1] + " from " + offerid);

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static void CheckParamsInsertOfferRelations(string [] paramsArray, string offerid)
        {
            return; //not yet implemented on the server
        }

        public static void CheckParamsChangeOfferDates(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offer_dates", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));

                SqlParameter start_date = cmd.Parameters.Add("@dt_start_date", SqlDbType.DateTime);
                start_date.SqlDbType = SqlDbType.DateTime;
                start_date.Direction = ParameterDirection.Output;
                SqlParameter end_date = cmd.Parameters.Add("@dt_end_date", SqlDbType.DateTime);
                end_date.SqlDbType = SqlDbType.DateTime;
                end_date.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new ApplicationException("Offer " + offerid + " and location " + paramsArray[1] + " not in the database");

                if ((DateTime)start_date.Value != Convert.ToDateTime(paramsArray[1]))
                    throw new ApplicationException("Start date does not match date from " + offerid);

                if ((DateTime)end_date.Value != Convert.ToDateTime(paramsArray[2]))
                    throw new ApplicationException("End date does not match date from " + offerid);

            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static void CheckParamsInsertOffers(string [] paramsArray, string offerid)
        {
            SqlDataReader reader = null;
            try
            {
                SqlCommand cmd = new SqlCommand("p_svc_difftest_get_offers", _uodbServer);
                cmd.CommandType = CommandType.StoredProcedure;

                // return param
                SqlParameter rval = cmd.Parameters.Add("@ReturnValue", SqlDbType.Int);
                rval.Direction = ParameterDirection.ReturnValue;

                cmd.Parameters.Add("@bi_offer_id", Int64.Parse(offerid, NumberStyles.HexNumber));

                SqlParameter i_ESRB_id = cmd.Parameters.Add("@i_ESRB_id", SqlDbType.Int);
                i_ESRB_id.Direction = ParameterDirection.Output;
                SqlParameter b_cancelable = cmd.Parameters.Add("@b_cancelable", SqlDbType.TinyInt);
                b_cancelable.Direction = ParameterDirection.Output;
                SqlParameter i_package_size = cmd.Parameters.Add("@i_package_size", SqlDbType.Int);
                i_package_size.Direction = ParameterDirection.Output;
                SqlParameter i_install_size = cmd.Parameters.Add("@i_install_size", SqlDbType.Int);
                i_install_size.Direction = ParameterDirection.Output;
                SqlParameter vb_sym_key = cmd.Parameters.Add("@vb_sym_key", SqlDbType.VarBinary, 8000);
                vb_sym_key.Direction = ParameterDirection.Output;
                SqlParameter i_bitfilter = cmd.Parameters.Add("@i_bitfilter", SqlDbType.Int);
                i_bitfilter.Direction = ParameterDirection.Output;
                SqlParameter vc_biling_svc_component_id = cmd.Parameters.Add("@vc_billing_svc_component_id",
                    SqlDbType.VarChar, 36);
                vc_biling_svc_component_id.SqlDbType = SqlDbType.VarChar;
                vc_biling_svc_component_id.Direction = ParameterDirection.Output;
                SqlParameter i_offer_type_id = cmd.Parameters.Add("@i_offer_type_id", SqlDbType.Int);
                i_offer_type_id.Direction = ParameterDirection.Output;
                SqlParameter i_offer_frequency_id = cmd.Parameters.Add("@i_offer_frequency_id", SqlDbType.Int);
                i_offer_frequency_id.Direction = ParameterDirection.Output;
                SqlParameter vc_friendly_name = cmd.Parameters.Add("@vc_friendly_name", SqlDbType.VarChar, 150);
                vc_friendly_name.SqlDbType = SqlDbType.VarChar;
                vc_friendly_name.Direction = ParameterDirection.Output;
                SqlParameter vb_public_key = cmd.Parameters.Add("@vb_public_key", SqlDbType.VarBinary, 500);
                vb_public_key.SqlDbType = SqlDbType.VarBinary;
                vb_public_key.Direction = ParameterDirection.Output;
                SqlParameter i_policy_flags = cmd.Parameters.Add("@i_policy_flags", SqlDbType.Int);
                i_policy_flags.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                if ((int)(rval.Value) != 0)
                    throw new ApplicationException("Offer " + offerid + " not in the database");

                if (i_ESRB_id.Value.ToString().ToUpper() != paramsArray[2].ToUpper())
                    throw new ApplicationException("ESRB doesn't match in sql2 file in offer " + offerid);

                if (b_cancelable.Value.ToString() != paramsArray[3])
                    throw new ApplicationException("Cancelable doesn't match in sql2 file in offer " + offerid +
                        " bit " + b_cancelable.Value.ToString());

                if (i_package_size.Value.ToString() != paramsArray[4])
                    throw new ApplicationException("Package size doesn't match in sql2 file in offer " + offerid);

                if (i_install_size.Value.ToString() != paramsArray[5])
                    throw new ApplicationException("Install size doesn't match in sql2 file in offer " + offerid);

                if (!CompareBytes(vb_sym_key.Value, paramsArray[6]))
                    throw new ApplicationException("Symmetric key doesn't match in sql2 file in offer " + offerid);

                if ((int)(i_bitfilter.Value) != HexParse(paramsArray[7]))
                    throw new ApplicationException("Bitfilter doesn't match in sql2 file in offer " + offerid);

                if (vc_biling_svc_component_id.Value.ToString().ToUpper() != paramsArray[8].ToUpper())
                    throw new ApplicationException("Billing component id doesn't match in sql2 file in offer " + offerid);

                if ((int)(i_offer_type_id.Value) != HexParse(paramsArray[9]))
                    throw new ApplicationException("Offert type doesn't match in sql2 file in offer " + offerid);

                if ((int)(i_offer_frequency_id.Value) != HexParse(paramsArray[10]))
                    throw new ApplicationException("Offer Frequency doesn't match in sql2 file in offer " + offerid);

                if (vc_friendly_name.Value.ToString() != paramsArray[13])
                    throw new ApplicationException("Friendly name doesn't match in sql2 file in offer " + offerid);

                if (!CompareBytes(vb_public_key.Value, paramsArray[14]))
                    throw new ApplicationException("Public key doesn't match in sql2 file in offer " + offerid);

                if ((int)(i_policy_flags.Value) != HexParse(paramsArray[15]))
                    throw new ApplicationException("Policy flags doesn't match in sql2 file in offer " + offerid);



            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }

        public static string ByteToHexStr(byte [] bHash, long length)
        {
            string strHash = "";

            for (int j = 0; j < bHash.Length && j < length; j++)
                strHash += bHash[j].ToString("X2");

            return strHash;
        }

        public static int HexParse(string number)
        {
            if (number.IndexOf("0x") == 0)
                return Int32.Parse(number.Substring(2), NumberStyles.HexNumber);
            else
                return Int32.Parse(number, NumberStyles.HexNumber);

        }

        public static Queue GetTitleList()
        {
            Queue titleIDs = new Queue();

            string [] titleids;

            string srcPath = Environment.CurrentDirectory;

            titleids = Directory.GetDirectories(srcPath);
            for (int i = 0; i < titleids.GetLength(0); i++)
            {
                titleids[i] = Path.GetFileNameWithoutExtension(titleids[i]);
            }


            foreach(string strTitle in titleids)
            {
                if (strTitle.Length == 8)
                {
                    try
                    {
                        Int32.Parse(strTitle, NumberStyles.HexNumber);
                        titleIDs.Enqueue(strTitle);
                    }
                    catch (Exception)
                    {
                    }
                }
            }

            return (titleIDs);
        }

        public static string RunCommandLine(string file, string args, string workingDir)
        {
            string output;

            Process p = new Process();
            p.StartInfo.WorkingDirectory = workingDir;
            p.StartInfo.FileName = file;
            p.StartInfo.Arguments = args;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.Start();

            output = p.StandardOutput.ReadToEnd();

            p.WaitForExit();

            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\common\XSCLeaderboard.cs ===
using System;
using System.Collections;

using xonline.tools.framework;
using xonline.common.leaderboard;

namespace xonline.tools.toolsuite
{


    public class XscLeaderboard
    {
        /// <summary>
        /// Extract leaderboards of type 'individual' from the XSC file for the given titleID
        /// </summary>
        /// <param name="xscPath">Path of XSC file to be read</param>
        /// <param name="titleID">titleID of title for which leaderboards need to be extracted</param>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXSCLeaderboardConfiguration( string xscPath, uint titleID )
        {
            //task: refactor to move this code out of "framework", into common/xscutil, remove log dependency
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            ArrayList leaderboardList = new ArrayList();
            uint[] lbIds;

            // Extract regular leaderboards from the XSC file
            lbIds = xsc.LBGetList();
            foreach (uint lbId in lbIds)
            {
                LeaderboardSettings lb = ExtractLeaderboard( xsc, titleID, lbId, LbType.Regular);
                leaderboardList.Add(lb);
            }

            // Extract competition leaderboards from the XSC file
            lbIds = xsc.CompGetList();
            foreach (uint lbId in lbIds)
            {
                LeaderboardSettings lb = ExtractLeaderboard( xsc, titleID, lbId, LbType.Competition);
                leaderboardList.Add(lb);
            }

            // return array of LeaderboardSettings objects
            return leaderboardList;
        }


        public static Hashtable GetXSCLeaderboardValueFormats( string xscPath )
        {
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            // Extract leaderboard IDs from the XSC file
            uint[] indLBIDs = xsc.LBGetList(); // Get leaderboards of type 'individual'

            // hashtable, key=lbID, value=SortedList of attributes
            Hashtable rawAttribs = new Hashtable();

            // Add each leaderboard of type 'individual' to the leaderboardList
            for ( int i = 0; i < indLBIDs.Length; i++ )
            {
                // Get LB ID
                int iLb = (int)indLBIDs[i];

                // LBAttrGetList returns empty list if attributes are not found
                rawAttribs.Add( iLb, xsc.LBValueGetList( (uint)iLb ) );
            }

            return rawAttribs;
        }

        public static LeaderboardSettings ExtractLeaderboard( CXsc xsc, uint titleID, uint lbId, LbType type )
        {
            ELBReset lbReset=0;
            uint uiAttachCount=0, uiMaxAttachSize=0, uiDecayDays=0, uiMaxRatingCount=0;
            bool bRequireArbitration=false, bIsTeam=false;
            int topEntries = 100;
            CELOConfig eloConfig = new CELOConfig();

            // For each LBConfig values, fill up a new LeaderboardSettings object

            //task: figure out maxRatCount and "top entries" retrieve different values from same XML ...
            //NOTE: topEntries and uiMaxRatingCount pull from the same XML element, they just
            //      do different transformations.  We use TopEntries, since it's correct.
            bool ret;
            if (type == LbType.Regular)
            {
                ret = xsc.LBConfigGet(
                    lbId,
                    ref lbReset,
                    ref uiAttachCount,
                    ref uiMaxAttachSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bRequireArbitration,
                    ref bIsTeam,
                    ref topEntries,
                    ref eloConfig);
            }
            else
            {
                ret = xsc.CompConfigGet(
                    lbId,
                    ref lbReset,
                    ref uiAttachCount,
                    ref uiMaxAttachSize,
                    ref uiDecayDays,
                    ref bRequireArbitration,
                    ref bIsTeam,
                    ref eloConfig);

            }

            if (!ret)
            {
                throw new Exception("Could not get Leaderboard configuration for Leaderboard ID " + lbId);
            }

            LeaderboardSettings lbSettings = new LeaderboardSettings();
            lbSettings.Type = type;
            lbSettings.Arbitrated = bRequireArbitration;
            lbSettings.DecayDays = (int)uiDecayDays;
            lbSettings.LastReset = DateTime.UtcNow;
            lbSettings.LBServer = "";
            lbSettings.LeaderboardID = (int)lbId;
            lbSettings.MaxAttachments = (int)uiAttachCount;
            lbSettings.MaxAttachmentSize = (int) uiMaxAttachSize;
            lbSettings.ResetType = (byte)lbReset;
            lbSettings.TeamView = bIsTeam;
            lbSettings.TitleID = titleID;
            lbSettings.TopEntries = topEntries;


            //
            // ELOConfig
            //

            // ELOCtable
            // Concatenate ELO rating values in a string from the CELOMaxWeightRatingRange[] array
            string sEloCtable = ""; // CTable string to supply to sproc
            foreach(CELOMaxWeightRatingRange rating in eloConfig.rgMaxWeightRatings)
            {
                sEloCtable += rating.uiStart.ToString() + ":" + rating.uiMaxWeight.ToString() + ",";
            }

            // Remove last comma
            if (sEloCtable != "") sEloCtable = sEloCtable.Remove(sEloCtable.Length-1,1);
            // Now that we have the string, set it in the object
            if (sEloCtable != "")
                lbSettings.EloCtable = sEloCtable;
            else
                lbSettings.EloCtable = "0:40"; // default value

            // EloE - exponentialBase
            //
            if (eloConfig.exponentialBase == EELOExponentialBase.e)
                lbSettings.EloE = "E";
            else
                lbSettings.EloE = "10"; // default value

            // EloK - RatingScaleFactor
            //
            if ((int)eloConfig.uiRatingScaleFactor > 0)
                lbSettings.EloK = (int)eloConfig.uiRatingScaleFactor;
            else
                lbSettings.EloK = 100; // default value

            // EloNew - InitialPlayerRating
            //
            if ((int)eloConfig.uiInitialPlayerRating > 0)
                lbSettings.EloNew = (int)eloConfig.uiInitialPlayerRating;
            else
                lbSettings.EloNew = 500; // default value;


            //
            // webdb config
            //

            // leaderboard descriptions
            SortedList sl = xsc.LBDescGetList( lbId );
            lbSettings.Descriptions = new LocalizedDescription[sl.Count];
            for (int i = 0; i < sl.Count; i++)
            {
                lbSettings.Descriptions[i] = new LocalizedDescription();
                lbSettings.Descriptions[i].Locale = (string)sl.GetKey(i);
                lbSettings.Descriptions[i].Description = (string)sl.GetByIndex(i);
            }

            // raw attributes
            sl = xsc.LBAttrGetList( lbId );
            lbSettings.RawAttributes = new RawAttribute[sl.Count];
            for (int i = 0; i < sl.Count; i++)
            {
                lbSettings.RawAttributes[i] = new RawAttribute();
                lbSettings.RawAttributes[i].Index = (int)(uint)sl.GetKey(i);
                lbSettings.RawAttributes[i].IsPuid = (bool)sl.GetByIndex(i);
            }


            // formats
            string[] names = xsc.LBValueGetList( lbId );
            lbSettings.Columns = new LbColumn[names.Length];

            for (int i = 0; i < names.Length; i++)
            {
                LbColumn col = new LbColumn();
                col.Name = names[i];

                EWebValueReturnType returnType = EWebValueReturnType.String;

                xsc.LBValueGet(lbId, names[i], ref returnType, ref col.Formula);
                col.ReturnType = (int)returnType;

                sl = xsc.LBValueDescGetList(lbId, names[i]);
                col.Descriptions = new LocalizedDescription[sl.Count];

                for (int j = 0; j < col.Descriptions.Length; j++)
                {
                    col.Descriptions[j] = new LocalizedDescription();
                    col.Descriptions[j].Locale = (string)(sl.GetKey(j));
                    col.Descriptions[j].Description = (string)(sl.GetByIndex(j));
                }

                lbSettings.Columns[i] = col;
            }

            return lbSettings;
        }
/*
        /// <summary>
        /// Extract competition templates from the XSC file for the given titleID
        /// </summary>
        /// <param name="xscPath">Path of XSC file to be read</param>
        /// <param name="titleID">titleID of title for which templates need to be extracted</param>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXSCCompetitionConfiguration( string xscPath, uint titleID )
        {
            //task: refactor to move this code out of "framework", into common/xscutil, remove log dependency
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            ArrayList leaderboardList = new ArrayList();

            // Extract leaderboards of type 'competitions'
            uint[] compLBIDs = xsc.CompGetList();
            ExtractCompetitionTemplates( titleID, compLBIDs, leaderboardList, xsc );

            // return array of LeaderboardSettings objects
            return leaderboardList;
        }
    */

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\destroytitle\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_4_none_12.4.56.0_none_2759e4a443f69403
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.manifest
XP_MANIFEST_PATH=manifests\x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.cat
XP_CATALOG_PATH=manifests\x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75.cat
XP_PAYLOAD_PATH=x86__common_4_no-public-key_12.4.56.0_x-ww_e448aa75
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlemgr\unittest\v3xsd\StatsV3xml.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.titlemgr.unittest.v3xsd  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute("Title", Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class CTitle {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LeaderboardContainer")]
        public CLeaderboardContainer[] LeaderboardContainer;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string TitleID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string UnitLeaderboardDecayConstant;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Version;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="language")]
        public string Default_Locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLeaderboardContainer {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Leaderboard")]
        public CLeaderboard[] Leaderboard;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public LeaderboardTypeType type;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLeaderboard {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string Reset;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string DecayDays;
        
        /// <remarks/>
        public bool TopOneHundred;
        
        /// <remarks/>
        public bool Arbitrate;
        
        /// <remarks/>
        public CELO ELO;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public CLocalizedName[] Names;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("FormattedValue", IsNullable=false)]
        public CFormattedValue[] FormattedValues;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Attribute", IsNullable=false)]
        public CAttribute[] RawAttributes;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="integer")]
        public string ID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CELO {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string InitialPlayerRating;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
        public string RatingScaleFactor;
        
        /// <remarks/>
        public ELOExponentialBaseType ExponentialBase;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("MaxWeightRatingRange", IsNullable=false)]
        public CMaxWeightRatingRange[] MaxWeightRatingRangeArray;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum ELOExponentialBaseType {
        
        /// <remarks/>
        E,
        
        /// <remarks/>
        e,
        
        /// <remarks/>
        [System.Xml.Serialization.XmlEnumAttribute("10")]
        Item10,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CMaxWeightRatingRange {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string start;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="nonNegativeInteger")]
        public string maxweight;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CAttribute {
        
        /// <remarks/>
        public bool PUID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string Index;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CFormattedValue {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedName", IsNullable=false)]
        public CLocalizedName[] Names;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="positiveInteger")]
        public string NameID;
        
        /// <remarks/>
        public FormattedValueReturnType Type;
        
        /// <remarks/>
        public string FriendlyAdminName;
        
        /// <remarks/>
        public string Formula;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public class CLocalizedName {
        
        /// <remarks/>
        public string Name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="language")]
        public string Locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum FormattedValueReturnType {
        
        /// <remarks/>
        Integer,
        
        /// <remarks/>
        Float,
        
        /// <remarks/>
        Percent,
        
        /// <remarks/>
        Gamertag,
        
        /// <remarks/>
        Timestamp,
        
        /// <remarks/>
        Milliseconds,
        
        /// <remarks/>
        TenMilliseconds,
        
        /// <remarks/>
        HundredMilliseconds,
        
        /// <remarks/>
        Seconds,
        
        /// <remarks/>
        Minutes,
        
        /// <remarks/>
        Hours,
        
        /// <remarks/>
        Days,
        
        /// <remarks/>
        String,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    public enum LeaderboardTypeType {
        
        /// <remarks/>
        individual,
        
        /// <remarks/>
        units,
        
        /// <remarks/>
        teams,
        
        /// <remarks/>
        competitions,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_livecontent_none_12.4.56.0_none_1dc2ec8993eed64f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livecontent
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.manifest
XP_MANIFEST_PATH=manifests\x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.cat
XP_CATALOG_PATH=manifests\x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.cat
XP_PAYLOAD_PATH=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livecontent,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\propxbox1update.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.IO;
using System.Xml;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.protocol;
using xonline.common.config;

namespace Microsoft.Ems.Tools.LiveContent 
{
    public enum PlatformCode : byte {
       xbox1 = (byte)ConsoleTypeEnum.Xbox1,
       xenon = (byte)ConsoleTypeEnum.Xenon,
       pc    = (byte)ConsoleTypeEnum.PC,
    }

    /// <summary>
    /// Execute the update propping comands
    /// </summary>
    public class CPropXbox1Update
    {
        public static bool defaultUpdate = false;
        public static bool isNFLFever2003 = false;
        public static bool doTransfer = true;

        public static int RebuildUpdate(string strTitle, string strUpdatePath, string strControlFile, bool bModifyAllFiles, bool bFull)
        {
            string strRebuildFile  = "RebuildUpdate.exe";
            int hr = CPropXbox1Utils.HR_SUCCEEDED;
            
            try
            {
                //
                //  Do the working files exist?
                //
                CPropXbox1Utils.VerifyExists(strUpdatePath);
                CPropXbox1Utils.VerifyExists(strControlFile);
                
                Ini updateIni = new Ini(strControlFile);
                string strKey = updateIni.GetSetting("Autoupd", "Key");
                string strSite = updateIni.GetSetting("Package", "Site");
                string strType = updateIni.GetSetting("Package", "Type");
                bool   bSiteUpdateControlFile = false;

                if (strType != "AutoUpdate")
                    bSiteUpdateControlFile = true;

                string [] sites = strSite.Split(';');
                string strXRLRoots = "";

                foreach(string site in sites)
                {
                    int nSite = Int32.Parse(site);

                    IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.download, nSite);

                    if(strXRLRoots.Length != 0)
                        strXRLRoots += ";";

                    strXRLRoots += vii.IPAddressString + ":" + vii.Port + "/content";
                }

                //
                // Prepare the .control file expected by RebuildContent
                //

                Ini tmpIni = new Ini();
                tmpIni.SetSetting("Autoupd", "XRLRoot", strXRLRoots);
                tmpIni.Save(strControlFile + ".tmp");

                string strArgs = "\"" + strUpdatePath + "\" \"" + strControlFile + ".tmp\"" + " ";

                //
                // Retail signed
                //
                strArgs += "-R ";

                if (defaultUpdate)
                    strArgs += "-T:" + strTitle + " ";
                
                if(CPropXbox1Utils.uiKeyLength == strKey.Length)
                {
                    strArgs += strKey;
                }

                //
                // Run rebuild update on the packet
                //
                Console.WriteLine("Args for RebuildUpdate: " + strArgs);

                Output o = new Output("Normal");
                hr = Command.RunCommandLine(strRebuildFile, strArgs, Path.GetDirectoryName(strUpdatePath), o);

                //
                // Delete the temporary .tmp file
                //
                File.Delete(strControlFile + ".tmp");

                if(CPropXbox1Utils.HR_SUCCEEDED != hr)
                {
                    throw(new ApplicationException("RebuildUpdate failed!"));
                }

                CPropXbox1Utils.VerifyExists(strUpdatePath + ".xbx");
                Ini xbxIni = new Ini(strUpdatePath + ".xbx");

                string strTitleID = CPropXbox1Utils.ExtractID(xbxIni.GetSetting("All", "TitleID"), 8);
                string strBaseVersion = CPropXbox1Utils.ExtractID(xbxIni.GetSetting("All", "BaseVersion"), 8);
                string strUpdateVersion = CPropXbox1Utils.ExtractID(xbxIni.GetSetting("All", "UpdateVersion"), 8);

                if(strTitle.ToLower() != strTitleID.ToLower())
                {
                    throw new ApplicationException("The input title ID(" + strTitle + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                bool isDash = false;
                if (strTitleID.ToUpper() == CPropXbox1Utils.XBOX1DASHID)
                    isDash = true;

                //make sure that the versions are decent
                uint iBaseDisc, iBaseBuild, iUpdateDisc, iUpdateBuild;

                if (GetDiscBuild(strBaseVersion, out iBaseDisc, out iBaseBuild) == false)
                    throw new ApplicationException("The base version of the update is corrupted.");
                
                if (GetDiscBuild(strUpdateVersion, out iUpdateDisc, out iUpdateBuild) == false)
                    throw new ApplicationException("The update version of the update is corrupted.");

                if (iUpdateDisc != iBaseDisc && !isDash)
                    throw new ApplicationException("The update version and base version don't match on disc number.");

                if (iUpdateBuild < iBaseBuild)
                    throw new ApplicationException("The update build is lower than the base build.");

                //make sure we don't have a higher version number already in TitleVault
                ArrayList rUpdates = GetUpdates(strTitle); //get a list of enabled updates
                CTitleVersion [] versions = CUODBUpdate.GetTitleVersions(strTitleID);

                foreach (CTitleVersion v in versions)
                {
                    uint iBDisc, iUDisc, iBBuild, iUBuild;

                    if (GetDiscBuild(v.BaseVersion, out iBDisc, out iBBuild) == false)
                        continue;

                    if (GetDiscBuild(v.BetaVersion, out iUDisc, out iUBuild) == false)
                        continue;

                    if (iBDisc != iUDisc)
                        continue; //this was propped with an old version of titlemgr - we should do something here

                    if (iBDisc != iBaseDisc)
                        continue; //for a  different disc

                    if (iUBuild > iUpdateBuild)
                        throw new ApplicationException("There is already an update with a higher version in the TitleVault. " + v.BetaVersion.ToString("X"));

                    if (iUBuild == iUpdateBuild && !defaultUpdate && !isDash)
                        Console.WriteLine("There is already an update with this version in the TitleVault.  Overwriting..");

                    //we should never get here
                    if (iBBuild > iUpdateBuild)
                        throw new ApplicationException("There is already an update with a higher version in the TitleVault. " + v.BetaVersion.ToString("X"));

                }

                //  Move files to TitleVault
                string strPackageID = strBaseVersion + strUpdateVersion;

                if(bModifyAllFiles)
                {
                    CPropXbox1Utils.TitleVaultWorkPackage(strUpdatePath, strTitleID, strPackageID);
                }

                if(bModifyAllFiles || bSiteUpdateControlFile)
                {
                    CPropXbox1Utils.TitleVaultWorkControl(strControlFile, strTitleID, strPackageID, BillingState.CURRENT, false, bSiteUpdateControlFile, false);
                }
                
                CPropXbox1Utils.BillingWorkSQL2(strUpdatePath + ".sql2", strTitleID, strPackageID);

                //erase that file for next time
                if (defaultUpdate)
                    File.Delete(strUpdatePath);

                // update uodb
                uint baseVersion = UInt32.Parse(strBaseVersion, NumberStyles.HexNumber);
                uint updateVersion = UInt32.Parse(strUpdateVersion, NumberStyles.HexNumber);

                // copy files to download servers
                CPropXbox1Utils.Transfer(strTitleID, strPackageID);

                // Update title versions
                CUODBUpdate.InsertTitleVersion(strTitleID, baseVersion, updateVersion, bFull);

                // Update title update locations
                CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVersion, strPackageID);

                // flush xkdc cache
                CPropXbox1Utils.UpdateXKDCCache();
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = CPropXbox1Utils.HR_FAILED;
            }
            finally
            {
                CPropXbox1Utils.CleanUpWorkingFolder(strUpdatePath);
            }

            return (hr);
                
        }

        public static int RebuildUpdate(string strTitle, string strUpdatePath, string strSite, bool bFull)
        {
            int hr = CPropXbox1Utils.HR_SUCCEEDED;

            try
            {
                //
                //  Does the specified source file exist?
                //
                CPropXbox1Utils.VerifyExists(strUpdatePath);
                CPropXbox1Utils.VerifySites(strSite);
                
                Ini controlIni = new Ini();

                controlIni.SetSetting("Package", "Site", strSite);
                controlIni.SetSetting("Package", "Type", "AutoUpdate");

                controlIni.Save(strUpdatePath + ".control2");

                hr = RebuildUpdate(strTitle, strUpdatePath, strUpdatePath + ".control2", true, bFull);
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                hr = CPropXbox1Utils.HR_FAILED;
            }
            
            return (hr);
        }

        public static uint CombineVersion(uint iHighestBuild, uint iDisc)
        {
            if (isNFLFever2003)
                return ( (iHighestBuild << 16) | iDisc);

            return ( (iHighestBuild << 8) | iDisc);

        }

        public static bool GetDiscBuild(string version, out uint disc, out uint build)
        {
            if (version .Length != 8)
            {
                disc = 0;
                build = 0;
                return false;
            }

            return GetDiscBuild(UInt32.Parse(version, NumberStyles.HexNumber), out disc, out build);
        }

        public static bool GetDiscBuild(uint version, out uint disc, out uint build)
        {
            if (isNFLFever2003)
            {
                build = version & 0xFFFF0000;
                disc  = version & 0x0000FFFF;
            }
            else
            {
                build = version & 0xFFFFFF00;
                disc  = version & 0x000000FF;
            }

            return true;
        }

        public static ArrayList GetVersions(string strTitleID)
        {
            ArrayList versions = new ArrayList();
            string versionsFile = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\versions.ini";
            Ini versionIni = new Ini(versionsFile);

            string version = versionIni.GetSetting("VERSION", "Initial");
            versions.Add(version);
    
            string strVersions = versionIni.GetSetting("VERSION", "Additional");

            if (strVersions.Length > 0)
            {
                string [] rVersions = strVersions.Split(';');
                foreach (string strV in rVersions)
                {
                    versions.Add(strV);
                }
            }

            return versions;
        }

        public static void DashSync()
        {
            string strTitleID = CPropXbox1Utils.XBOX1DASHID;
            ArrayList rUpdates = GetUpdates(strTitleID);

            //add all base and additional versions
            ArrayList versions = GetVersions(strTitleID);

            try
            {
                foreach (string strVersion in versions)
                {
                    CPropXbox1Utils.BeginTransactions();
                    uint version = UInt32.Parse(strVersion, NumberStyles.HexNumber);
                    CUODBUpdate.InsertTitleVersion(strTitleID, version, version, true); 
                    CPropXbox1Utils.CommitTransactions();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                CPropXbox1Utils.RollbackTransactions();
            }

            try
            {
                foreach (string update in rUpdates)
                {

                    string strBaseVer = update.Substring(0, 8);
                    string strUpdateVer = update.Substring(8, 8);

                    uint baseVer = UInt32.Parse(strBaseVer, NumberStyles.HexNumber);
                    uint updateVer = UInt32.Parse(strUpdateVer, NumberStyles.HexNumber);

                    //process this update
                    if (doTransfer)
                    {
                        CPropXbox1Utils.BeginTransactions();
                        CPropXbox1Utils.Transfer(strTitleID, update);
                        CPropXbox1Utils.CommitTransactions();
                    }

                    //insert base row
                    CPropXbox1Utils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, baseVer, true); 
                    CPropXbox1Utils.CommitTransactions();

                    if (IsFullUpdate(strTitleID, update))
                    {
                        CPropXbox1Utils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, updateVer, true); 
                        CPropXbox1Utils.CommitTransactions();
                    }
                    else
                    {
                        CPropXbox1Utils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, updateVer, false); 
                        CPropXbox1Utils.CommitTransactions();
                    }

                    CPropXbox1Utils.BeginTransactions();
                    CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, update);
                    CPropXbox1Utils.CommitTransactions();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                CPropXbox1Utils.RollbackTransactions();
            }

        }

        public static void Sync(string strTitleID)
        {
            //do separate sync for dash
            if (strTitleID.ToUpper() == CPropXbox1Utils.XBOX1DASHID.ToUpper())
            {
                DashSync();
                return;
            }

            //get a list of package IDs for each disc
            ArrayList rUpdates = GetUpdates(strTitleID); //get a list of enabled updates

            //get a list of all the discs we need to prop updates for
            ArrayList rDiscs = new ArrayList();
            foreach (string update in rUpdates)
            {
                uint iBDisc, iBBuild,
                        iUDisc, iUBuild;
                string baseVer = update.Substring(0, 8);
                string updateVer = update.Substring(8, 8);

                if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    continue;

                if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    continue;

                if (iBDisc != iUDisc)
                    continue; //this was propped with an old version of titlemgr - we should do something here

                if (!rDiscs.Contains(iBDisc))
                    rDiscs.Add(iBDisc);
            }

            //insert all baseversions
            string versionsFile = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\versions.ini";
            Ini versionIni = new Ini(versionsFile);

            string version = versionIni.GetSetting("VERSION", "Initial");
            uint iVBuild, iVDisc;
            GetDiscBuild(version, out iVDisc, out iVBuild);


            if (!rDiscs.Contains(iVDisc))
                rDiscs.Add(iVDisc);
                
            string strVersions = versionIni.GetSetting("VERSION", "Additional");

            if (strVersions.Length > 0)
            {
                string [] rVersions = strVersions.Split(';');
                foreach (string strV in rVersions)
                {
                    GetDiscBuild(strV, out iVDisc, out iVBuild);
                    if (!rDiscs.Contains(iVDisc))
                        rDiscs.Add(iVDisc);
                }
            }

            foreach (uint iDisc in rDiscs)
            {
            
                ArrayList baseVers = new ArrayList();
                uint iHighestBuild = 0;
                uint iHighestFullBuild = 0;

                string strHighestVer = null;
                string strHighestFullVer = null;

                bool bHaveFull = false;

                foreach (string update in rUpdates)
                {
                    uint iBDisc, iUDisc, iBBuild, iUBuild;

                    string baseVer = update.Substring(0, 8);
                    string updateVer = update.Substring(8, 8);

                    if (GetDiscBuild(baseVer, out iBDisc, out iBBuild) == false)
                    {
                        Console.WriteLine("The base version of " + update + " is screwy.");
                        continue;
                    }

                    if (GetDiscBuild(updateVer, out iUDisc, out iUBuild) == false)
                    {
                        Console.WriteLine("The update version of " + update + " is screwy.");
                        continue;
                    }

                    if (iBDisc != iUDisc)
                    {
                        Console.WriteLine("The package " + update + " was propped with an old version of titlemgr and will never be synced again.");
                        continue;
                    }

                    if (iBDisc != iDisc)
                        continue; //for a  different disc

                    //we should never get here
                    if (iBBuild > iUBuild)
                    {
                        Console.WriteLine("Update " + update + " has a higher update than build version. ");
                        continue;
                    }

                    //remember this package so we can update uodb correctly
                    if (!baseVers.Contains(baseVer))
                        baseVers.Add(baseVer);
                
                    //we also need to make sure that all update versions can be updated to the new high
                    if (!baseVers.Contains(updateVer))
                        baseVers.Add(updateVer);
                
                    //if we have a new high, then set it
                    if (iUBuild > iHighestBuild)
                    {
                        iHighestBuild = iUBuild;
                        strHighestVer = update;
                    }
                    
                    if (IsFullUpdate(strTitleID, update))
                        bHaveFull = true;
                
                    if (iUBuild > iHighestFullBuild && IsFullUpdate(strTitleID, update))
                    {
                        iHighestFullBuild = iUBuild;
                        strHighestFullVer = update;
                    }
                
                }//each update
            
                //insert all baseversions
                
                version = versionIni.GetSetting("VERSION", "Initial");
                GetDiscBuild(version, out iVDisc, out iVBuild);

                /*
                bool bFullPack = true, bPack = true;

                if (null == strHighestVer)
                    bPack = false;
                if (null == strHighestFullVer)
                    bFullPack = false;
                */
                /*
                
                if (null == strHighestVer && iVDisc == iDisc)
                {
                    strHighestVer = version;
                    iHighestBuild = iVBuild;
                }

                if (null == strHighestFullVer && iVDisc == iDisc)
                {
                    strHighestFullVer = version;
                    iHighestFullBuild = iVBuild;
                }

                */

                if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(version))
                    baseVers.Add(version);
                
                strVersions = versionIni.GetSetting("VERSION", "Additional");

                if (strVersions.Length > 0)
                {
                    string [] rVersions = strVersions.Split(';');
                    foreach (string strV in rVersions)
                    {
                        GetDiscBuild(strV, out iVDisc, out iVBuild);
                        if (iVDisc == iDisc && iVBuild < iHighestBuild && !baseVers.Contains(strV))
                            baseVers.Add(strV);

                        /*
                        if (null == strHighestVer && iVDisc == iDisc)
                        {
                            strHighestVer = strV;
                            iHighestBuild = iVBuild;
                        }

                        if (null == strHighestFullVer && iVDisc == iDisc)
                        {
                            strHighestFullVer = strV;
                            iHighestFullBuild = iVBuild;
                        }
                        */
                    }
                }

                if (null == strHighestVer)
                {
                    //Console.WriteLine("FAIL: Can't find a highest ver for disc " + iDisc.ToString());
                    continue;
                }

                uint iHighestVersion = CombineVersion(iHighestBuild, iDisc);
                uint iHighestFullVersion = CombineVersion(iHighestFullBuild, iDisc);

                Console.WriteLine("Highest build for disc " + iDisc.ToString() + " is " + strHighestVer);
                
                if (doTransfer)
                    CPropXbox1Utils.Transfer(strTitleID, strHighestVer);

                if (null != strHighestFullVer && doTransfer)
                    CPropXbox1Utils.Transfer(strTitleID, strHighestFullVer);

            
                //CUODBUpdate.InsertTitleVersion(strTitleID, iHighestBuild, iHighestBuild, true);

                //prop the highest update
                //UODBWork(strTitleID, strHighestVer, UODBAction.UPDATE_TRANSFER);
                //we don't want to reprop the highest version - it is already in there
                //baseVers.Remove(strHighestVer.Substring(0, 8));

                //now we have to update t_title_versions for each other update (beta only)
                //we also have to point to their offer locations/packages


                try
                {
                    foreach (string strBaseVer in baseVers)
                    {
                        Console.WriteLine("Inserting " + strBaseVer + " with Highest's stats");

                        uint baseVer = UInt32.Parse(strBaseVer, NumberStyles.HexNumber);

                        //establish base row if not there
                        CPropXbox1Utils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, baseVer, true); 
                        CPropXbox1Utils.CommitTransactions();

                        if (baseVer <= iHighestFullVersion && bHaveFull)
                        {
                            //this is a full update, so set the full field
                            CPropXbox1Utils.BeginTransactions();
                            CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, iHighestFullVersion, true);
                            CPropXbox1Utils.CommitTransactions();

                            CPropXbox1Utils.BeginTransactions();
                            CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, strHighestFullVer);
                            CPropXbox1Utils.CommitTransactions();
                        }
                        
                        //update the beta field to the row
                        CPropXbox1Utils.BeginTransactions();
                        CUODBUpdate.InsertTitleVersion(strTitleID, baseVer, iHighestVersion, false);
                        CPropXbox1Utils.CommitTransactions();

                        CPropXbox1Utils.BeginTransactions();
                        CUODBUpdate.InsertUpdatePackageLocations(strTitleID, baseVer, strHighestVer);
                        CPropXbox1Utils.CommitTransactions();

                    } //each update for this disc

                }                
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.Message);
                    CPropXbox1Utils.RollbackTransactions();
                }

                Console.WriteLine("Disc " + iDisc.ToString() +" Sync: Success");

            } //each disc

            Console.WriteLine("AutoUpdate Sync: Success");
        }

        static public void MakeFootball(string titleID)
        {
            string strFile = Config.GetSetting(Setting.titlevault_root) + "\\" + titleID + "\\versions.ini";
            Ini vIni = new Ini(strFile);
            vIni.SetSetting("VERSION", "FOOTBALL", "TRUE");

//            sd.Edit(strFile);

            vIni.Save(strFile);
            
//            sd.Submit(strFile, "Set football version info");

            Console.WriteLine("Successfully set July version info (football) on title " + titleID);
        }

        static public void AddBaseVer(string titleid, string strVersion)
        {   

            try
            {
                CPropXbox1Utils.VerifyVersion(strVersion);

                string versionFile = Config.GetSetting(Setting.titlevault_root) + "\\" + titleid + "\\versions.ini";

                if (!File.Exists(versionFile))
                {
                    Console.WriteLine("FAIL: " + versionFile + " does not exist.");
                    return;
                }

                Ini versionIni = new Ini(versionFile);

                string versions = versionIni.GetSetting("Version", "Additional");

                string [] current_vers = versions.Split(';');
                foreach(string ver in current_vers)
                {
                    if (ver == strVersion)
                    {
                        Console.WriteLine("This version(" + strVersion + ") has already been added to " + titleid);
                        return;
                    }
                }

                if (versions.Length > 0)
                    versions += ";";

                versions += strVersion;
                versionIni.SetSetting("Version", "Additional", versions);
                versionIni.Save(versionFile);

                //insert that version into uodb
                uint iVersion = UInt32.Parse(strVersion, NumberStyles.HexNumber);

                try
                {
                    CPropXbox1Utils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(titleid, iVersion, iVersion, true);
                    CPropXbox1Utils.CommitTransactions();
                }
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.Message);
                    CPropXbox1Utils.RollbackTransactions();
                }

                Console.WriteLine("Added version " + strVersion + " to title " + titleid);

            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
        }


        static public void ChangeBaseVer(string titleid, string strVersion)
        {   

            try
            {
                CPropXbox1Utils.VerifyVersion(strVersion);

                string versionFile = Config.GetSetting(Setting.titlevault_root) + "\\" + titleid + "\\versions.ini";

                if (!File.Exists(versionFile))
                {
                    Console.WriteLine("FAIL: " + versionFile + " does not exist.");
                    return;
                }

                Ini versionIni = new Ini(versionFile);

                versionIni.SetSetting("Version", "Initial", strVersion);
                versionIni.Save(versionFile);

                //insert that version into uodb
                uint iVersion = UInt32.Parse(strVersion, NumberStyles.HexNumber);
                try
                {
                    CPropXbox1Utils.BeginTransactions();
                    CUODBUpdate.InsertTitleVersion(titleid, iVersion, iVersion, true);
                    CPropXbox1Utils.CommitTransactions();
                }
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.Message);
                    CPropXbox1Utils.RollbackTransactions();
                }

                Console.WriteLine("Updated base version to " + strVersion);
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
        }

        static public bool IsFullUpdate(string strTitleID, string strPackageID)
        {
            string ctlFile = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\" + strPackageID + ".control";

            Ini ctlIni = new Ini(ctlFile);

            if (ctlIni.GetSetting("PACKAGE", "FULL").ToUpper() == "TRUE")
                return true;
            else
                return false;
        }

        /// <summary>
        /// MakeFull does the following:
        /// 1.  Consistency checks:
        ///     a.  Make sure title id is in titlevault.
        ///     b.  Make sure requested update is specified correctly, exists, and is not already full.
        /// 2.  Update version to be full.
        /// 3.  Flush front door caches.
        /// </summary>
        /// <param name="titleid"></param>
        /// <param name="packageid"></param>
        /// <param name="full"></param>
        static public bool MakeFull(string titleid, string packageid, string platform, Guid betaGroupId, bool bReassign, bool bReload)
        {
            string titlePath = Path.Combine(Config.GetSetting(Setting.titlevault_root), titleid);
            if(!Directory.Exists(titlePath))
            {
                Console.WriteLine("FAIL:  Title does not exist in title vault.");
                return false;
            }

            //  Crack the package id to get the base and update version of the package
            if(packageid.Length != 16)
            {
                Console.WriteLine("FAIL: Package must be specified as xxxxxxxxyyyyyyyy where xxxxxxxx is the base version in hex and yyyyyyyy is the update version in hex.");
                return false;
            }

            uint baseVersion = UInt32.Parse(packageid.Substring(0, 8), NumberStyles.HexNumber);
            uint updateVersion = UInt32.Parse(packageid.Substring(8, 8), NumberStyles.HexNumber);
            PlatformCode platformCode;

            //  Get the approapriate platform code
            try {
               platformCode = (PlatformCode)Enum.Parse(typeof(PlatformCode), platform.ToLower());
            }
            catch (ArgumentException) {
               Console.WriteLine("FAIL: invalid value specified for platform.");
               return false;
            }

            // Make sure the update to assign has already been propped as selective.
            CTitleVersion [] selectiveVersions = CUODBUpdate.GetTitleVersions(titleid, (int)updateVersion, new Guid("1A75281C-6B30-4BA8-80C6-66B339F2BA89"));
            if(selectiveVersions.Length == 0)
            {
                Console.WriteLine("FAIL:  Specified version was not propped to the selective group.  No actions will be performed.  Try propping the update package as selective.");
                return false;
            }

            if(!bReassign)
            {
                //  Make sure this isn't already a full version and isn't lower than an existing version
                // If we're branching to a new beta group it may not have any full versions already.  So 0 versions is okay.
                CTitleVersion [] versions = CUODBUpdate.GetTitleVersions(titleid, (int)baseVersion, betaGroupId);

                foreach(CTitleVersion v in versions)
                {
                    if(v.UpdateVersion > updateVersion)
                    {
                        Console.WriteLine("FAIL:  A higher update version is already propped for this group.");
                        return false;
                    }

                    if(v.UpdateVersion == updateVersion)
                    {
                        Console.WriteLine("This update is already a full update in the database.  No changes needed.");
                        return false;
                    }

                    break;
                }
            }

            //
            //  Finally, update the database and refresh the front doors
            //

            CUODBUpdate.InsertTitleVersion(titleid, baseVersion, updateVersion, (byte)platformCode, betaGroupId);

            if(bReload)
            {
                CPropXbox1Utils.UpdateUACSCache();
                CPropXbox1Utils.UpdateXBOSCache();
                CPropXbox1Utils.UpdateXKDCCache();
            }

            if(betaGroupId == Guid.Empty)
            {
                Console.WriteLine("MakeFull: Successfully assigned version {0:X8} to production",
                        updateVersion);
            }
            else
            {
                Console.WriteLine("Assign: Successfully assigned version {0:X8} to group {1}",
                        updateVersion,
                        betaGroupId);
            }

            return true;
        }

        public static ArrayList GetUpdates(string strTitle)
        {
            ArrayList rUpdates = new ArrayList();
            string path = Path.Combine(Config.GetSetting(Setting.titlevault_root), strTitle);

            if(Directory.Exists(path))
            {
                string [] files = Directory.GetFiles(path, "*.control");

                foreach (string file in files)
                {
                    string strID = Path.GetFileNameWithoutExtension(file);

                    if (CPropXbox1Utils.IsIDContent(strTitle, strID) == false)
                        rUpdates.Add(strID);
                }
            }

            return rUpdates;
        }

        public static void BuildDefaultUpdate(string strTitleID, ref string strDefaultUpdatePath)
        {
            Console.WriteLine("Building default autoupdate for " + strTitleID);

            //clear out the old update stuff
            Console.WriteLine("Cleaning up old dir");

            Output o = new Output("Normal");
            Command.RunCommandLine("delnode.exe", "/q " + strTitleID, strDefaultUpdatePath, o);

            //now create the update dir and put the necessary files there
            Console.WriteLine("Copying files from \\new");
            Directory.CreateDirectory(strDefaultUpdatePath + "\\" + strTitleID);
            string [] patchFiles = Directory.GetFiles(strDefaultUpdatePath + "\\new");
            foreach (string file in patchFiles)
            {
                Console.WriteLine("Copying " + file + " to " + Path.GetFileName(file));
                File.Copy(file, strDefaultUpdatePath + "\\" + strTitleID + "\\" + Path.GetFileName(file));
            }

            //make and old dir if it doesn't exist
            if (!Directory.Exists(strDefaultUpdatePath + "\\old"))
                Directory.CreateDirectory(strDefaultUpdatePath + "\\old");

            //now cert the xbe that we just copied
            Console.WriteLine("Cert..");
            File.SetAttributes(strDefaultUpdatePath + "\\" + strTitleID + "\\default.xbe", FileAttributes.Normal);
            string strArgs = "/in:" + strTitleID + "\\default.xbe ";
            strArgs += "/testid:0x" + strTitleID + " ";
            strArgs += "/testversion:0x00000299";

            Command.RunCommandLine("xbecert.exe", strArgs, strDefaultUpdatePath, o);

            //now run xpatch to create the diff
            Console.WriteLine("Xpatch");
            strArgs = "-c old " + strTitleID + " ";
            strArgs += strTitleID + "\\diff";
            Command.RunCommandLine("xpatch.exe", strArgs, strDefaultUpdatePath, o);

            //now build the update
            Console.WriteLine("BuildUpdate");
            string strUpdatePackage = Path.Combine(strDefaultUpdatePath, "update.pkg");
            strArgs = strUpdatePackage + " update.xbx " + strTitleID + "\\diff " + strTitleID;
            Command.RunCommandLine("BuildUpdate.exe", strArgs, strDefaultUpdatePath, o);

            Console.WriteLine("");

            strDefaultUpdatePath = strUpdatePackage;
        }

        public static bool DisabledUpdate(string strTitleID,string update)
        {
            string strPath = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\" + update + ".control";

            if (!File.Exists(strPath))
            {
                throw new ApplicationException("Cannot find the update " + strPath);
            }

            Ini ctlIni = new Ini(strPath);

            if ("TRUE" == ctlIni.GetSetting("PACKAGE", "DISABLED"))
                return true;

            return false;
        }

        public static void EnableUpdate(string strTitleID, string strID)
        {
            //to remove an update from the database all we have to do is set it to disabled
            string strPath = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\" + strID;

            if (!File.Exists(strPath + ".xcp"))
            {
                throw new ApplicationException("Cannot find the update " + strID);
            }

            if (CPropXbox1Utils.IsIDContent(strTitleID, strID))
            {
                throw new ApplicationException("You cannot enable content this way.  This is for enabling autoupdates.");
            }

            Ini ctlIni = new Ini(strPath + ".control");

            ctlIni.SetSetting("PACKAGE", "DISABLED", "FALSE");
            ctlIni.Save(strPath + ".control");

            Console.WriteLine("Successfully enabled " + strID);
        }

        public static void RemoveUpdate(string strTitleID, string strID)
        {

            Console.WriteLine("FAIL: Removing an update is disabled.  Prop a higher version of the autoupdate.");
            return;

            /*
            //to remove an update from the database all we have to do is set it to disabled
            string strPath = onfig.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\" + strID;

            if (!File.Exists(strPath + ".pkg"))
            {
                throw new ApplicationException("Cannot find the update " + strID);
            }

            if (CPropXbox1Utils.IsIDContent(strTitleID, strID))
            {
                throw new ApplicationException("You cannot remove content this way.  This is for removing autoupdates.");
            }

            CSourceDepot sd = new CSourceDepot();
            
            sd.Edit(strPath + ".control");

            Ini ctlIni = new Ini(strPath + ".control");

            ctlIni.SetSetting("PACKAGE", "DISABLED", "TRUE");
            ctlIni.Save(strPath + ".control");

            sd.Submit(strPath + ".control", "Disabling " + strPath);
              
            Console.WriteLine("Successfully disabled " + strID);
            */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\destroytitle\destroytitle.cs ===
using System;
using System.Data;
using System.Data.SqlClient;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.tools;
using xonline.common.tools.console;
using xonline.tools.framework;

namespace xonline.tools.toolsuite
{
    /// <summary>
    /// Command line code for the Deploy Title tool
    /// </summary>
    class DestroyTitle
    {

        static void Usage()
        {
            Console.WriteLine( "" );
            Console.WriteLine( "Tool to completely remove a title's initial configuration in the Xbox Live Service " );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "    DestroyTitle /title:<title> " );
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <titleID>     - The title ID you want to DESTROY (e.g. hexadecimal number 0xfffed000 )" );
            Console.WriteLine( "" );
        }


        [STAThread]
        static int Main(string[] args)
        {

            //task: these next 20 lines appear in all console tools.. is there a way to factor this out?
            string [] rgstrCmdLineTags = 
            {
                "?", 
                "title",      // hex titleID
            };
            
            // this allows NT Events to work... 
            XomLoggingControl.Init();

            NamedArgParser ArgParser = new NamedArgParser( rgstrCmdLineTags );

            #region Validate commandline args
            // Parse any command line arguments, returns false if there are extras
            if ( !ArgParser.Parse( args ) )
            {
                Usage();
                return -1;
            }

            // Did the user request usage information?        
            //task: should I just log all the stuff, and output a single string at the end?
            if ( 0 == ArgParser.Count ||
                null != ArgParser[ "?" ] )
            {
                Usage();
                return 0;
            }

            uint titleID = 0;
            try
            {
                CTitleId ctitleid = new CTitleId( System.Convert.ToString( ArgParser[ "title" ] ) );
                titleID = ctitleid.uiTitleId;
                Console.WriteLine("Just converted titleid" + titleID );
            }
            catch ( OverflowException )
            {
                Console.WriteLine( "The TitleID you entered was too large." );
                return -1;
            }
            catch ( Exception e )
            {
                Console.WriteLine( "There was a problem converting the  TitleID you entered: " + e );
                return -1;
            }            

            #endregion

            //task: Add CheckReady stuff here to confirm all DB's are up and reachable.

            //task: HOW SHOULD THIS WORK?  E.G. WILL IT DELETE LEADERBOARDS?

            Console.WriteLine( "Commencing destruction of title... " );

            //Delete a title from UODB, WebDB, NPDB, etc... 
            uint titleID = 0;
            try
            {
                CTitleId ctitleid = new CTitleId( System.Convert.ToString( argParser[ "titleid" ] ) );
                titleID = ctitleid.uiTitleId;
            }
            catch ( OverflowException )
            {
                Console.WriteLine( "The TitleID you entered was too large." );
                return -1;
            }
            catch ( Exception e )
            {
                Console.WriteLine( "There was a problem converting the  TitleID you entered: " + e );
                return -1;
            } 

            //so small, yet so devastating 
            Title.DestroyTitle( titleID );

            Console.WriteLine( "Feature not implemented yet!" );                
            return -1;

            //task: should any confirmation be done that the title has been removed from all locations?

            return 1;
        } // main

    } // Destroy title

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_livecontent_none_12.4.56.0_none_1dc2ec8993eed64f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livecontent
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.manifest
XP_MANIFEST_PATH=manifests\x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.cat
XP_CATALOG_PATH=manifests\x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3.cat
XP_PAYLOAD_PATH=x86_livecontent_no-public-key_12.4.56.0_x-ww_5c5276c3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livecontent,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\CUODBUpdate.cs ===
using System;
using System.Collections;
using System.IO;
using System.Web;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using Microsoft.Webstore.WstClient;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.sql.webstore;
using xonline.common.config;


namespace Microsoft.Ems.Tools.LiveContent 
{
    class CTitleVersion
    {
        private uint _baseVersion;
        private uint _updateVersion;
        private uint _betaVersion;

        public CTitleVersion() : this(0, 0, 0)
        {
        }

        public CTitleVersion(CTitleVersion v) : this(v.BaseVersion, v.UpdateVersion, v.BetaVersion)
        {
        }

        public CTitleVersion(uint baseVersion, uint updateVersion, uint betaVersion)
        {
            _baseVersion = baseVersion;
            _updateVersion = updateVersion;
            _betaVersion = betaVersion;
        }

        public uint BaseVersion
        {
            get { return _baseVersion; }
        }

        public uint UpdateVersion
        {
            get { return _updateVersion; }
        }

        public uint BetaVersion
        {
            get { return _betaVersion; }
        }
    }

    /// <summary>
    /// Takes the .sql2 file generated by the RebuildUpdate tool and updates UODB
    /// </summary>
    class CUODBUpdate
    {
        static public void Exec(string strSQL2File)
        {
            StreamReader  sr = null;
            int nWSClients = 0;
            WSClient[] wsClients = null;
            bool bRollback = false;
            
            try
            {
                wsClients = CPropXbox1Utils.GetUODBWebstoreClients();
                nWSClients = wsClients.Length;

                sr = File.OpenText(strSQL2File);

                string strFileContent = sr.ReadToEnd();
                string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

                if(strStoredProcedures.Length < 4)
                {
                    throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
                }
                
                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].ClearParameters();
                    wsClients[k].PartitionType = WstPartitionType.Physical;
                    wsClients[k].Partition = k;
                    wsClients[k].BeginTransaction();
                }

                int hr = CPropXbox1Utils.HR_SUCCEEDED;      
                
                //
                // Execute all stored procedures
                //
                for(int i = 1 ; i < strStoredProcedures.GetLength(0); i++)
                {
                    for(int k = 0; (k < nWSClients) && (CPropXbox1Utils.HR_SUCCEEDED == hr); k++)
                    {
                        ParseQueryString(wsClients[k], strStoredProcedures[i]);
                        wsClients[k].ExecuteNonQuery();
                        hr = wsClients[k].GetIntParameter("@RETVAL");
                        wsClients[k].ClearParameters();

                        if(CPropXbox1Utils.HR_FAILED_NO_TITLE == hr)
                        {
                            throw new ApplicationException("Inexistent titleID!");
                        }
                        else if(CPropXbox1Utils.HR_FAILED_TITLE_VERSION == hr)
                        {
                            throw new ApplicationException("Base version in update package doesn't exist in UODB");
                        }
                    }
                }

                for(int k = 0; k < nWSClients; k++)
                {
                    wsClients[k].CommitTransaction();
                }

                Console.WriteLine("Success!");
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                bRollback = true;
            }
            finally
            {
                if(null != sr)
                {
                    sr.Close();
                }
            }

            if(bRollback)
            {
                if(null != wsClients)
                {
                    for(int k = 0; k < nWSClients; k++)
                    {
                        try
                        {
                            wsClients[k].RollbackTransaction();
                        }
                        catch(Exception)
                        {
                        }
                    }
                }

            }
            
        }
        
        /// <summary>
        /// ParseQueryString():
        /// Parses given query string and sets up the webstore client for the stored procedure call.
        /// </summary>
        private static void ParseQueryString(WSClient ws, string strStoredProc)
        {
            try
            {
                string[] paramsArray = Regex.Split(strStoredProc, "[,]");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_title_update_packages":
                        ParseParamsTitleUpdatePackages(ws, paramsArray);
                        break;
                    case "p_svc_insert_title_update_locations":
                        ParseParamsTitleUpdateLocations(ws, paramsArray);
                        break;
                    case "p_svc_insert_title_versions":
                        ParseParamsInsertTitleVersions(ws, paramsArray);
                        break;
                    default:
                        throw new System.Exception("Error:  Invalid procedure name: " + strSPName );
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString


        private static void ParseQueryString(WSClient ws, string strStoredProc, uint baseVer)
        {
            try
            {
                string[] paramsArray = Regex.Split(strStoredProc, "[,]");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_title_update_packages":
                        ParseParamsTitleUpdatePackages(ws, paramsArray, baseVer);
                        break;
                    case "p_svc_insert_title_update_locations":
                        ParseParamsTitleUpdateLocations(ws, paramsArray, baseVer);
                        break;
                    default:
                        ws.StoredProc = "";
                        break;
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString

        private static void AddBinaryParam(WSClient ws, string strParamName, string strParam)
        {
            int nSize = strParam.Length / 2 - 1;
            byte[] binaryData = new byte[nSize];
            for(int k = 0 ; k < nSize; k++)
            {                               
                string strTmp = strParam.Substring(2 * (k + 1), 2);
                byte bChar = Convert.ToByte(strTmp, 16);
                binaryData[k] = bChar;
            }
            ws.AddParameter(strParamName, binaryData);
        }

        private static void ParseParamsTitleUpdatePackages(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 4:
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                        case 5:
                            AddBinaryParam(ws, "@vb_update_sym_key", paramsArray[i]);
                            break;
                        case 6:
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdatePackages(WSClient ws, string[] paramsArray, uint baseVer)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    //Console.WriteLine("Adding param " + paramsArray[i] + " to update_pacs");
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            Console.WriteLine("Adding int " + iParam.ToString());
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            Console.WriteLine("Base " + baseVer.ToString());
                            ws.AddParameter("@i_title_base_version", baseVer);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            Console.WriteLine("Adding int " + iParam.ToString());
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            Console.WriteLine("Adding def " + paramsArray[i]);
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 4:
                            Console.WriteLine("Adding def " + paramsArray[i]);
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                        case 5:
                            Console.WriteLine("Adding bin " + paramsArray[i]);
                            AddBinaryParam(ws, "@vb_update_sym_key", paramsArray[i]);
                            break;
                        case 6:
                            Console.WriteLine("Adding bin " + paramsArray[i]);
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdateLocations(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            break;
                        case 4:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsTitleUpdateLocations(WSClient ws, string[] paramsArray, uint baseVer)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    Console.WriteLine("Adding param " + paramsArray[i] + " to update_locs");
                    
                    switch(i)
                    {
                        case 1:
                            ws.AddParameter("@i_title_base_version", baseVer);
                            break;
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_update_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            break;
                        case 4:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }


        private static void ParseParamsInsertTitleVersions(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 1:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_base_version", iParam);
                            break;
                        case 2:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_new_version", iParam);
                            break;
                        case 3:
                            ws.AddParameter("@i_version_flag", paramsArray[i]);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsCleanAutoupdates(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.StoredProc = "dbo.p_svc_clean_autoupdates";
                ws.AddParameter("@i_title_id", Convert.ToInt32(paramsArray[0], 16));
                ws.AddParameter("@i_base_version", Convert.ToInt32(paramsArray[1], 16));
                ws.AddParameter("@i_new_version", Convert.ToInt32(paramsArray[2], 16));
            }
            catch(System.Exception)
            {
                throw;
            }
        }
  
        /// <summary>
        /// This variant of GetTitleVersions returns all versions for the
        /// specified title.
        /// </summary>
        /// <param name="strTitleID"></param>
        /// <returns></returns>
        public static CTitleVersion [] GetTitleVersions(string strTitleID)
        {
            return GetTitleVersions(strTitleID, -1);
        }

        /// <summary>
        /// This variant of GetTitleVersions returns version information
        /// for the specified base version.
        /// </summary>
        /// <param name="strTitleID"></param>
        /// <param name="baseVersion"></param>
        /// <returns></returns>
        public static CTitleVersion [] GetTitleVersions(string strTitleID, int baseVersion)
        {
            return GetTitleVersions(strTitleID, baseVersion, Guid.Empty);
        }

        public static CTitleVersion [] GetTitleVersions(string strTitleID, int baseVersion, Guid betaGroup)
        {
            int titleId = Int32.Parse(strTitleID, NumberStyles.HexNumber);

            WSClient client = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

            client.StoredProc = "dbo.p_svc_get_title_versions";

            client.AddParameter(ParamType.INPUT, "@i_title_id", titleId);
            client.AddParameter(ParamType.INPUT, "@i_base_version", baseVersion);
            client.AddParameter(ParamType.INPUT, "@uid_beta_group_id", betaGroup);

            WstDataReader reader = client.Execute();

            ArrayList versions = new ArrayList();
            while(reader.Read())
            {
                versions.Add(new CTitleVersion((uint)reader.GetInt32(0), (uint)reader.GetInt32(1), (uint)reader.GetInt32(2)));
            }

            CTitleVersion [] returnVersions = (CTitleVersion[])versions.ToArray(typeof(CTitleVersion));

            return returnVersions;
        }

        public static void InsertTitleVersion(string strTitleID, uint baseVer, uint iHighestVer, bool bFullUpdate)
        {
            if(bFullUpdate)
            {
                InsertTitleVersion(strTitleID, baseVer, iHighestVer, (byte)PlatformCode.xbox1, Guid.Empty);
            }
            else
            {
                InsertTitleVersion(strTitleID, baseVer, iHighestVer, (byte)PlatformCode.xbox1, new Guid("1A75281C-6B30-4BA8-80C6-66B339F2BA89"));
            }
        }

        public static void InsertTitleVersion(string strTitleID, uint baseVer, uint iHighestVer, byte platform, Guid betaGroupId)
        {
            int nWSClients = 0;
            WSClient[] wsClients = null;

            Console.WriteLine("Inserting t_title_versions from " + baseVer.ToString() + 
                " to " + iHighestVer.ToString() + " for " + betaGroupId.ToString());

            int iTitleID = Int32.Parse(strTitleID, NumberStyles.HexNumber);
            
            try
            {
                CPropXbox1Utils.BeginTransactions();

                wsClients = CPropXbox1Utils.GetTransactionWebstoreClients();
                nWSClients = wsClients.Length;

                for(int k = 0; k < nWSClients; k++)
                {
                    //for each client, insert t_title_versions from base to highest

                    wsClients[k].StoredProc = "dbo.p_svc_insert_title_versions";
                    
                    wsClients[k].AddParameter(ParamType.INPUT, "@i_title_id", iTitleID);
                    wsClients[k].AddParameter(ParamType.INPUT, "@i_base_version", baseVer);
                    wsClients[k].AddParameter(ParamType.INPUT, "@i_new_version", iHighestVer);
                    wsClients[k].AddParameter(ParamType.INPUT, "@uid_beta_group_id", betaGroupId);
                    wsClients[k].AddParameter(ParamType.INPUT, "@ti_console_type_id", platform);

                    wsClients[k].ExecuteNonQuery();
                }

                CPropXbox1Utils.CommitTransactions();
            }
            catch
            {
                CPropXbox1Utils.RollbackTransactions();
                throw;
            }
        }

        public static void InsertUpdatePackageLocations(string strTitleID, uint baseVer, string  strHighestVer)
        {
            StreamReader  sr = null;
            int nWSClients = 0;
            WSClient[] wsClients = null;
        
            string strSQL2File = Config.GetSetting(Setting.titlevault_root) + "\\" + strTitleID + "\\" + strHighestVer + ".sql2";

            //don't run this if baseVer = HighestVer
            string updateVer = strHighestVer.Substring(8, 8);
            if (baseVer == UInt32.Parse(updateVer, NumberStyles.HexNumber))
                return;

            sr = File.OpenText(strSQL2File);

            string strFileContent = sr.ReadToEnd();
            sr.Close();
            string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

            if(strStoredProcedures.Length < 4)
            {
                throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
            }
        
            int hr = CPropXbox1Utils.HR_SUCCEEDED;      
        
            //
            // Execute all stored procedures
            //
            for(int i = 1 ; i < strStoredProcedures.GetLength(0); i++)
            {
                try
                {
                    CPropXbox1Utils.BeginTransactions();

                    wsClients = CPropXbox1Utils.GetTransactionWebstoreClients();
                    nWSClients = wsClients.Length;

                    for(int k = 0; (k < nWSClients) && (CPropXbox1Utils.HR_SUCCEEDED == hr); k++)
                    {
                        ParseQueryString(wsClients[k], strStoredProcedures[i], baseVer);
                    
                        //insert t_offers
                    
                        if (wsClients[k].StoredProc == "")
                            continue;

                        wsClients[k].ExecuteNonQuery();

                        hr = wsClients[k].GetIntParameter("@RETVAL");

                        if(CPropXbox1Utils.HR_FAILED_NO_TITLE == hr)
                        {
                            throw new ApplicationException("Inexistent titleID!");
                        }
                        else if(CPropXbox1Utils.HR_FAILED_TITLE_VERSION == hr)
                        {
                            throw new ApplicationException("Base version in update package doesn't exist in UODB");
                        }
                    }

                    //
                    //  Need to commit trans, clear parameters, reset partition and start new trans
                    //  for next iteration.
                    //

                    CPropXbox1Utils.CommitTransactions();
                }
                catch
                {
                    CPropXbox1Utils.RollbackTransactions();
                    throw;
                }
            }

            Console.WriteLine("Success!");

        } //insertpackagelocations
    } //class
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\CUODBContent.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using Microsoft.Webstore.WstClient;
using System.Collections;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using xonline.common.xboxofferutil;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.sql.webstore;
using xonline.common.config;

namespace Microsoft.Ems.Tools.LiveContent
{
    /// <summary>
    /// Takes the .sql2 file generated by the RebuildContent tool and updates UODB
    /// </summary>
    class CUODBContent
    {
        static int p_svc_insert_offers_count = 0;
        static int p_svc_insert_offer_descriptions_count = 0;
        static int p_svc_insert_offer_description_details_count = 0;
        static int p_svc_insert_offer_locations_count = 0;
        static int p_svc_insert_offer_regions_count = 0;

        static public void Exec(string strSQL2File, string strOfferID)
        {
            XboxContentOffer xo = new XboxContentOffer();
            Exec(strSQL2File, strOfferID, ref xo);
        }

        static public void Exec(string strSQL2File, string strOfferID, ref XboxContentOffer xo)
        {
            StreamReader  sr = null;
            WSClient wsClient = null;

            // Reset
            p_svc_insert_offers_count = 0;
            p_svc_insert_offer_descriptions_count = 0;
            p_svc_insert_offer_description_details_count = 0;
            p_svc_insert_offer_locations_count = 0;
            p_svc_insert_offer_regions_count = 0;
            
            try
            {
                //  We create a dummy object for the purposes of not having to rewrite ParseQueryString at this time.
                wsClient = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                long lOfferID = Convert.ToInt64(strOfferID, 16);

                sr = File.OpenText(strSQL2File);

                string strFileContent = sr.ReadToEnd();

                string[] strStoredProcedures = Regex.Split(strFileContent, "exec");

                if(strStoredProcedures.Length < 4)
                {
                    throw new ApplicationException("Invalid .sql2 file: " + strSQL2File);
                }
                
                //
                // Execute all other stored procedures
                //
                for(int i = 1 ; i < strStoredProcedures.GetLength(0); i++)
                {
                    wsClient.ClearParameters();
                
                    ParseQueryString(wsClient, strStoredProcedures[i], ref xo);
                }
                
                Console.WriteLine("Success!");

            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if(null != sr)
                {
                    sr.Close();
                }
            }
        }


        /// <summary>
        /// ParseQueryString():
        /// Parses given query string and sets up the webstore client for the stored procedure call.
        /// </summary>
        private static void ParseQueryString(WSClient ws, string strStoredProc)
        {
            XboxContentOffer xo = new XboxContentOffer();
            ParseQueryString(ws, strStoredProc, ref xo);
        }

        private static void ParseQueryString(WSClient ws, string strStoredProc, ref XboxContentOffer xo)
        {
            try
            {
                // Note - this is a hack. We're splitting on any comma at the
                // end of a line. This works because xmltosql puts each parameter
                // on it's own line. However, if xmltosql changes in the future
                // such that it puts multiple parameters on a single line 
                // (which would be a perfectly reasonable thing to do) 
                // this will break. But for now, this will allow ops to prop
                // content packages that have commas in the friendly name.
                string[] paramsArray = Regex.Split(strStoredProc, @",\s*\r\n");
            
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                    paramsArray[i] = paramsArray[i].Trim('\'');
                }

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                // set the stored procedure.
                ws.StoredProc = strSPName;

                switch (strSPName)
                {
                    case "p_svc_insert_offers":
                        XboxOfferBasicInfo xobi = xo.xboxOfferBasicInfo;
                        ParseParamsInsertOffers(ws, paramsArray, ref xobi);
                        break;
                    case "p_svc_insert_subscriptions":
                        ParseParamsInsertSubscriptions(ws, paramsArray);
                        break;
                    case "p_svc_insert_offer_descriptions":
                        XboxOfferDescriptionCollection xodc = xo.xboxOfferDescriptionCollection;
                        ParseParamsInsertOfferDescriptions(ws, paramsArray, ref xodc);
                        break;
                    case "p_svc_insert_offer_description_details":
                        XboxOfferDescriptionDetailsCollection xoddc = xo.xboxOfferDescriptionDetailsCollection;
                        ParseParamsInsertOfferDescriptionDetails(ws, paramsArray, ref xoddc);
                        break;
                    case "p_svc_insert_offer_locations":
                        XboxOfferLocationsCollection xolc = xo.xboxOfferLocationsCollection;
                        ParseParamsInsertOfferLocations(ws, paramsArray, ref xolc);
                        break;
                    case "p_svc_insert_offer_regions":
                        XboxOfferRegionsCollection xorc = xo.xboxOfferRegionsCollection;
                        ParseParamsInsertOfferRegions(ws, paramsArray, ref xorc);
                        break;
                    case "p_svc_insert_offer_relations":
                        ParseParamsInsertOfferRelations(ws, paramsArray);
                        break;
                    case "p_svc_offer_change_dates":
                        ParseParamsChangeOfferDates(ws, paramsArray);
                        break;
                    default:
                        throw new System.Exception("Error:  Invalid procedure name: " + strSPName );
                }
            }
            catch (System.Exception)
            {
                throw;
            }
        } // end ParseQueryString

        public static void AddBinaryParam(WSClient ws, string strParamName, string strParam)
        {
            int nSize = strParam.Length / 2 - 1;
            byte[] binaryData = new byte[nSize];
            for(int k = 0 ; k < nSize; k++)
            {                               
                string strTmp = strParam.Substring(2 * (k + 1), 2);
                byte bChar = Convert.ToByte(strTmp, 16);
                binaryData[k] = bChar;
            }
            ws.AddParameter(strParamName, binaryData);
        }

        private static void ParseParamsInsertOffers(WSClient ws, string[] paramsArray, ref XboxOfferBasicInfo xobi)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        // bigint in hexa
                        case 1://bi_offer_id 
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            xobi.offerID = lParam;
                            break;
                        case 2://i_ESRB_id
                            ws.AddParameter("@i_ESRB_id", paramsArray[i]);
                            xobi.ESRB = Convert.ToByte(paramsArray[i]);
                            break;
                        case 3://b_cancelable
                            byte bParam = Convert.ToByte(paramsArray[i]);
                            ws.AddParameter("@b_cancelable", bParam);
                            break;
                        // binaries
                        case 6: //vb_sym_key
                            AddBinaryParam(ws, "@vb_sym_key", paramsArray[i]);
                            xobi.symKey = paramsArray[i];
                            break;
                        case 14://vb_public_key
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            xobi.publicKey = paramsArray[i];
                            break;
                        // int in decimal
                        case 4:
                            int dParam = Int32.Parse(paramsArray[i]);
                            ws.AddParameter("@i_package_size", dParam);
                            xobi.packageSize = (UInt32)dParam;
                            break;
                        case 5:
                            dParam = Int32.Parse(paramsArray[i]);
                            ws.AddParameter("@i_install_size", dParam);
                            xobi.installSize = (UInt32)dParam;
                            break;
                        // int in hex
                        case 0: //i_title_id
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            xobi.titleID = iParam;
                            break;
                        case 7: //i_bitfilter
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_bitfilter", iParam);
                            xobi.bitFilter = iParam;
                            break;
                        case 15://i_policy_flags
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_policy_flags", iParam);
                            xobi.policyFlags = (UInt32)iParam;
                            break;
                        case 9://i_offer_type_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_type_id", iParam);
                            xobi.offerTypeID = (UInt32)iParam;
                            break;
                        case 10://i_offer_frequency_id 
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_frequency_id", iParam);
                            break;
                        // datetime
                        case 11: //dt_start_date
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            xobi.startDate = dt;
                            break;
                        case 12: //dt_end_date
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            xobi.endDate = dt;
                            break;
                        //strings
                        case 8: // vc_billing_svc_component_id
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_billing_svc_component_id", str);
                            xobi.billingSvcComponentID = str;
                            break;
                        case 13:// vc_friendly_name
                            str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_friendly_name", str);
                            xobi.friendlyName = str;
                            break;
                    }
                }
                p_svc_insert_offers_count++;
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertSubscriptions(WSClient ws, string[] paramsArray)
        {
            try
            {
                ws.AddParameter( ParamType.RETVAL, "@RETVAL", 0 );

                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                            // bigint in hexa
                        case 1://bi_offer_id 
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                            // plain ints
                        case 2://i_ESRB_id
                            ws.AddParameter("@i_ESRB_id", paramsArray[i]);
                            break;
                        case 3://b_cancelable
                            byte bParam = Convert.ToByte(paramsArray[i]);
                            ws.AddParameter("@b_cancelable", bParam);
                            break;
                        case 4://i_package_size
                            ws.AddParameter("@i_package_size", paramsArray[i]);
                            break;
                        case 5://i_install_size
                            ws.AddParameter("@i_install_size", paramsArray[i]);
                            break;
                            // binaries
                        case 6: //vb_sym_key
                            AddBinaryParam(ws, "@vb_sym_key", paramsArray[i]);
                            break;
                        case 14://vb_public_key
                            AddBinaryParam(ws, "@vb_public_key", paramsArray[i]);
                            break;
                            // int in hexa
                        case 0: //i_title_id
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_title_id", iParam);
                            break;
                        case 7: //i_bitfilter
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_bitfilter", iParam);
                            break;
                        case 15://i_policy_flags
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_policy_flags", iParam);
                            break;
                        case 9://i_offer_type_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_type_id", iParam);
                            break;
                        case 10://i_offer_frequency_id
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_offer_frequency_id", iParam);
                            break;
                            // datetime
                        case 11: //dt_start_date
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            break;
                        case 12: //dt_end_date
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            break;
                            //strings
                        case 8: // vc_billing_svc_component_id
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_billing_svc_component_id", str);
                            break;
                        case 13:// vc_friendly_name
                            str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_friendly_name", str);
                            break;
                        case 16: //si_global_offer_details
                            short wParam = Convert.ToInt16(paramsArray[i], 16);
                            ws.AddParameter("@si_global_offer_details", wParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }
   
        private static void ParseParamsInsertOfferDescriptions(WSClient ws, string[] paramsArray, ref XboxOfferDescriptionCollection xodc)
        {
            XboxOfferDescription xod = new XboxOfferDescription();
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            xod.liveOfferID = lParam;
                            break;
                        case 1:
                            AddBinaryParam(ws, "@vb_enum_blob", paramsArray[i]);
                            xod.detailsBlob = paramsArray[i];
                            break;
                        case 2:
                            ws.AddParameter("@i_description_index", paramsArray[i]);
                            xod.descriptionIndex = Convert.ToUInt32(paramsArray[i]);
                            break;
                    }
                }

                //Update the Collection as needed
                CollectionAddOrInsert(ref p_svc_insert_offer_descriptions_count, xodc, xod);
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferDescriptionDetails(WSClient ws, string[] paramsArray, ref XboxOfferDescriptionDetailsCollection xoddc)
        {
            XboxOfferDescriptionDetails xodd = new XboxOfferDescriptionDetails();
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            xodd.liveOfferID = lParam;
                            break;
                        case 1:
                            AddBinaryParam(ws, "@vb_details_blob", paramsArray[i]);
                            xodd.detailsBlob = paramsArray[i];
                            break;
                        case 2:
                            ws.AddParameter("@i_description_index", paramsArray[i]);
                            xodd.descriptionIndex = Convert.ToUInt32(paramsArray[i]);
                            break;
                        case 3:
                            ws.AddParameter("@i_order", paramsArray[i]);
                            xodd.order = Convert.ToUInt32(paramsArray[i]);
                            break;
                    }
                }

                //Update the Collection as needed
                CollectionAddOrInsert(ref p_svc_insert_offer_description_details_count, xoddc, xodd);
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferLocations(WSClient ws, string[] paramsArray, ref XboxOfferLocationsCollection xolc)
        {
            XboxOfferLocations xol = new XboxOfferLocations();
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            xol.offerID = lParam;
                            break;
                        case 1:
                            ws.AddParameter("@i_location_rank", paramsArray[i]);
                            xol.locationRank = Convert.ToUInt32(paramsArray[i]);
                            break;
                        case 2:
                            string str = paramsArray[i].Replace("'","");
                            ws.AddParameter("@vc_XRL", str);
                            xol.XRL = str;
                            break;
                    }
                }

                //Update the Collection as needed
                CollectionAddOrInsert(ref p_svc_insert_offer_locations_count, xolc, xol);
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferRegions(WSClient ws, string[] paramsArray, ref XboxOfferRegionsCollection xorc)
        {
            bool fSkip = true;
            p_svc_insert_offer_regions_count++;
            // Determined what Regions will already be correct in the OfferFile
            // so we don't update xorc collection here, and skip GUID validation
            if(xorc.Count == 0)
                fSkip = false;

            try
            {
                string guid = "";
                long price = 0;
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            ws.AddParameter("@ti_country_id", paramsArray[i]);
                            break;
                        case 2:
                            string str = paramsArray[i].Replace("'","");
                            guid = str;
                            ws.AddParameter("@vc_billing_offer_id", str);
                            break;
                        case 3:
                            if (guid.Length == 0)
                            {
                                price = Int32.Parse(paramsArray[i]);
                                if (price > 0 && !fSkip) // if fSkip==true, then OfferFile will address this
                                    throw new ApplicationException("There is a price but no GUID for region " 
                                            + paramsArray[1] + " in offer " + paramsArray[0]);
                            }
                            ws.AddParameter("@i_price_whole", paramsArray[i]);
                            break;
                        case 4:
                            if (guid.Length == 0)
                            {
                                price = Int32.Parse(paramsArray[i]);
                                if (price > 0 && !fSkip) // if fSkip==true, then OfferFile will address this
                                    throw new ApplicationException("There is a price but no GUID for region " 
                                            + paramsArray[1] + " in offer " + paramsArray[0]);
                            }
                            ws.AddParameter("@i_price_fractional", paramsArray[i]);
                            break;
                        case 5:
                            byte bParam = Convert.ToByte(paramsArray[i], 16);
                            ws.AddParameter("@si_specific_offer_details", bParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsInsertOfferRelations(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_related_offer_id", lParam);
                            break;
                        case 2:
                            int iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_relation_type_id", iParam);
                            break;
                        case 3:
                            iParam = Convert.ToInt32(paramsArray[i], 16);
                            ws.AddParameter("@i_convert_mode", iParam);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void ParseParamsChangeOfferDates(WSClient ws, string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 0:
                            long lParam = Convert.ToInt64(paramsArray[i], 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            break;
                        case 1:
                            DateTime dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_start_date", dt);
                            break;
                        case 2:
                            dt = Convert.ToDateTime(paramsArray[i]);
                            ws.AddParameter("@dt_end_date", dt);
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private static void CollectionAddOrInsert(ref int count, IList arr, Object obj)
        {
            if(arr.Count > count)
                arr[count] = obj; 
            else
                arr.Add(obj);

            count++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\propxbox1utils.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.content;

namespace Microsoft.Ems.Tools.LiveContent
{
    public enum UODBAction { LEAVE, UPDATE, DELETE, UPDATE_TRANSFER };

    public enum BillingState {CURRENT, SPS_NOT_READY, SPS_READY};

    public class CUODBID
    {
        private string m_strID;
        private UODBAction m_action;

        //
        //  Constructor
        //
        public CUODBID(string strID, UODBAction action)
        {
            m_strID = strID;
            m_action = action;
        }

        //
        //  Properties
        //
        public string ID
        {
            get { return m_strID; }
            set { m_strID = value; }
        }

        public UODBAction Action
        {
            get { return m_action; }
            set { m_action = value; }
        }

        public override int GetHashCode()
        {
            return StringComparer.CurrentCultureIgnoreCase.GetHashCode(m_strID);
        }

        public override bool Equals(object obj)
        {
            Debug.Assert( obj is CUODBID );
            CUODBID uodbID = (CUODBID)obj;
            return (StringComparer.CurrentCultureIgnoreCase.Compare(m_strID, uodbID.m_strID) == 0);
        }

    }

    /// <summary>
    /// Utils for propping content / update packages
    /// </summary>
    internal class CPropXbox1Utils
    {
        public static string XBOX1DASHID = "FFFE0000";

        public const uint uiIDLength      = 16;
        public const uint uiKeyLength     = 32;
        public const uint uiVersionLength = 8;
        public const uint uiTitleLength   = 8;

        public static int HR_FAILED               = Convert.ToInt32("0x8007000D", 16);
        public static int HR_FAILED_NO_TITLE      = Convert.ToInt32("0x80156001", 16);
        public static int HR_FAILED_TITLE_VERSION = Convert.ToInt32("0x80156002", 16);
        public static int HR_FAILED_INSERT        = Convert.ToInt32("0x80156002", 16);
        public static int HR_FAILED_NO_OFFER      = Convert.ToInt32("0x80156003", 16);
        public static int HR_SUCCEEDED            = 0x00000000;
        public static int HR_EXIT                 = 0x00000001;

        public static WSClient[] _wsClients = null;
        public static WSClient[] _transClients = null;

        public static WSClient   _wsClient = null;

        public static WSClient[] GetTransactionWebstoreClients()
        {
            return _transClients;
        }

        public static void BeginTransactions()
        {
            if (null == _transClients)
            {
                //  We create a dummy object for the purposes of getting number of partitions.
                WSClient wsDummy = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);

                _transClients = new WSClient[wsDummy.PhysicalPartitions];

                for(int k = 0 ; k < _transClients.Length; k++)
                {
                    // init the webstore objects
                    _transClients[k] = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                }
            }

            for(int k = 0; k < _transClients.Length; k++)
            {
                Console.WriteLine("Beginning transaction for " + k.ToString());
                _transClients[k].ClearParameters();
                _transClients[k].PartitionType = WstPartitionType.Physical;
                _transClients[k].Partition = k;
                _transClients[k].BeginTransaction();
            }
        }

        public static void RollbackTransactions()
        {
            for(int k = 0; k < _transClients.Length; k++)
            {
                try
                {
                    Console.WriteLine("Rolling transaction for " + k.ToString());
                    _transClients[k].ClearParameters();
                    _transClients[k].RollbackTransaction();
                }
                catch (Exception)
                {
                }
            }
        }

        public static void CommitTransactions()
        {
            for(int k = 0; k < _transClients.Length; k++)
            {
                Console.WriteLine("Committing transaction for " + k.ToString());
                _transClients[k].ClearParameters();
                _transClients[k].CommitTransaction();
            }
        }

        public static WSClient[] GetUODBWebstoreClients()
        {
            if(null == _wsClients)
            {
                //  We create a dummy object for the purposes of getting number of partitions.
                WSClient wsDummy = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);

                _wsClients = new WSClient[wsDummy.PhysicalPartitions];

                for(int k = 0 ; k < _wsClients.Length; k++)
                {
                    // init the webstore objects
                    _wsClients[k] = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                }
            }

            for(int k = 0; k < _wsClients.Length; k++)
            {
                _wsClients[k].ClearParameters();
            }

            return(_wsClients);
        }

#if false
        public static WSClient GetUODBWebstoreClient()
        {
            if(null == _wsClient)
            {
                // init the webstore object
                _wsClient = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                _wsClient.Partition = WSClient.ALL_PARTITIONS;
            }

            _wsClient.ClearParameters();

            return(_wsClient);
        }
#endif

        public static string ExtractID(string strOriginal, int iLength)
        {
            string strID = strOriginal.Trim();
            strID = strID.Replace(",", "");
            strID = strID.Replace("0x", "");
            strID = strID.PadLeft(iLength, '0');

            return (strID);
        }

        public static void VerifyExists(string strFilePath)
        {
            if(!File.Exists(strFilePath))
            {
                throw new ApplicationException("File not found! " + strFilePath);
            }
        }

        public static bool IsSubscription(string strTitleID, string offer)
        {
            string sqlfile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + offer + ".sql2";
            StreamReader reader = new StreamReader(sqlfile);
            string line = reader.ReadLine();
            reader.Close();
            if (line.IndexOf("subscriptions") > 0)
                return true;
            else
                return false;
        }

        public static void VerifyExistsDir(string strDirPath)
        {
            if(!Directory.Exists(strDirPath))
            {
                throw new ApplicationException("Dir not found! " + strDirPath);
            }
        }

        public static void VerifySites(string strInputSite)
        {
            if("all" == strInputSite.ToLower())
            {
                return;
            }

            string [] strSites = strInputSite.Split(';');

            foreach(string strSite in strSites)
            {
                uint uiSite = Convert.ToUInt16(strSite);

                Config.GetVirtualInterface(VirtualInterface.download, (int)uiSite);
            }
        }

        public static void VerifyVersion(string strVersion)
        {
            if(uiVersionLength != strVersion.Length)
            {
                throw new ApplicationException("Invalid initial version: " + strVersion);
            }
            Convert.ToInt32(strVersion, 16);
        }

        public static void VerifyID(string strID)
        {
            if(uiIDLength != strID.Length)
            {
                throw new ApplicationException("Invalid ID: " + strID);
            }
            Convert.ToInt64(strID, 16);
        }

        public static void VerifyXRL(string strXRL)
        {
            if(0 == strXRL.Length)
            {
                throw new ApplicationException("Invalid XRL: " + strXRL);
            }
        }

        public static void VerifyKey(string strKey)
        {
            if(uiKeyLength != strKey.Length)
            {
                throw new ApplicationException("Invalid Key: " + strKey);
            }
        }

        public static void VerifyDate(string strDate)
        {
            if(0 == strDate.Length)
            {
                throw new ApplicationException("Invalid Date: " + strDate);
            }
            Convert.ToDateTime(strDate);
        }

        public static bool IsIDContent(string strTitleID, string strID)
        {
            Ini controlIni = new Ini(Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strID + ".control");

            string type = controlIni.GetSetting("Package", "Type");

            if (type == "Content")
                return true;

            if (type == "AutoUpdate")
                return false;

            return (strID.ToLower().StartsWith(strTitleID.ToLower()));
        }

        public static bool IsIDTitle(string strTitleID)
        {
            bool bTitle = false;

            if(uiTitleLength == strTitleID.Length)
            {
                try
                {
                    Convert.ToInt32(strTitleID, 16);
                    bTitle = true;
                }
                catch(Exception)
                {
                }
            }

            return (bTitle);
        }

        //  Very simple check to make sure the file is not a subscription
        public static void VerifyOffer(string strSqlFile)
        {
            using(StreamReader reader = new StreamReader(strSqlFile))
            {
                string strContents = reader.ReadToEnd();
                if(strContents.IndexOf("p_svc_insert_subscriptions") != -1)
                {
                    throw new ApplicationException("Xbox 1 subscriptions are not processed using LiveContent.  Use LiveOffer instead.");
                }
            }
        }

        public static void VerifyRegions(string strSqlFile, string strSite)
        {
            
            ArrayList siteRegions = new ArrayList();

            //  Read in region list for the specified site
            using (SqlConnection npdbConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                npdbConn.Open();

                SqlCommand cmd = npdbConn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_config_get_site_regions";
                cmd.Parameters.AddWithValue("@vc_environment", Config.Environment);
                cmd.Parameters.AddWithValue("@i_site_id", Int32.Parse(strSite));

                SqlDataReader dbReader = cmd.ExecuteReader();

                while(dbReader.Read())
                {
                    int iRegion = dbReader.GetInt32(0);
                    siteRegions.Add(iRegion);
                }
            }

            StreamReader reader = new StreamReader(strSqlFile);

            string strContents = reader.ReadToEnd();

            reader.Close();

            Console.WriteLine("Splitting by exec");
            string [] rProcs = Regex.Split(strContents, "exec");

            foreach (string strProc in rProcs)
            {
                if (strProc.Length == 0)
                    continue;

                Console.WriteLine("Splitting by , for " + strProc);

                string[] paramsArray = Regex.Split(strProc, "[,]");

                //Console.WriteLine("Trimming for " + strProc);

                for(int i = 0 ; i < paramsArray.Length; i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }

                Console.WriteLine("Splitting by spaces for " + strProc);

                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");

                Console.WriteLine("Accessing 0 and 1" + strProc);

                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];

                if (strSPName != "p_svc_insert_offer_regions")
                    continue;

                Console.WriteLine("Accessing params1 " + strProc);

                bool bFoundRegion = false;

                foreach(int iCurRegion in siteRegions)
                {
                    if(iCurRegion == Int32.Parse(paramsArray[1]))
                    {
                        bFoundRegion = true;
                        break;
                    }
                }

                if(!bFoundRegion)
                    throw new ApplicationException("Region(" + paramsArray[1] + ") is not under SITE." + strSite + ". Please place a different site first in the list.");
            }
        }

        private static void TitleVaultWorkFile(string strTitleID, string strFromFilePath, string strToFileName)
        {
            string titleVaultRoot = Path.Combine(Config.GetSetting( Setting.titlevault_root ), strTitleID);
            if(!Directory.Exists(titleVaultRoot))
            {
                Directory.CreateDirectory(titleVaultRoot);
            }

            TitleVault.TitleVaultCopy(titleVaultRoot, strFromFilePath, strToFileName);
        }

        public static void TitleVaultWorkPackage(string strFilePath, string strTitleID, string strPackageID)
        {
            try
            {
                //
                // Copy files to title vault.
                //

                Console.WriteLine("Copying package to TitleVault...");

                string strPKGFileName = strPackageID.ToUpper() + ".pkg";
                string strXCPFileName = strPackageID.ToUpper() + ".xcp";

                TitleVaultWorkFile(strTitleID, strFilePath, strPKGFileName);
                TitleVaultWorkFile(strTitleID, strFilePath + ".new", strXCPFileName);

                Console.WriteLine("Success");
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
            }
        }

//        public static bool VersionExists(string strTitleID, string strBaseVersion)
//        {
//            //See if the pair titleid/baseversion exists in uodb
//
//            int hr = 0;
//            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
//
//            ws.ClearParameters();
//            ws.StoredProc = "dbo.p_svc_get_title_versions";
//            ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
//            int iParam = Convert.ToInt32(strTitleID, 16);
//            ws.AddParameter("@i_title_id", iParam);
//            iParam = Convert.ToInt32(strBaseVersion, 16);
//            ws.AddParameter("@i_base_version", iParam);
//
//            ws.ExecuteNonQuery();
//            hr = ws.GetIntParameter("@RETVAL");
//
//            ws.Close();
//
//            if (hr == 0)
//                return false;
//
//            return true;
//        }

        public static void SetContentControl(string strControlFilePath, BillingState state, bool bPremium, bool bWriteSites)
        {
            Ini controlIni = new Ini(strControlFilePath);

            controlIni.SetSetting("Billing", "Premium", (bPremium)?"YES":"NO");
            controlIni.SetSetting("Package", "Type", "Content");

            switch(state)
            {
                case BillingState.SPS_NOT_READY:
                    controlIni.SetSetting("Billing", "SPS", "NotReady");
                    break;
                case BillingState.SPS_READY:
                    controlIni.SetSetting("Billing", "SPS", "Ready");
                    break;
            }

            controlIni.Save(strControlFilePath);
        }

        public static void SetAutoupdControl(string strControlFilePath, bool bWriteSites)
        {
            Ini controlIni = new Ini(strControlFilePath);

            controlIni.SetSetting("Package", "Type", "AutoUpdate");


            controlIni.Save(strControlFilePath);
        }


        public static void TitleVaultWorkControl(string strControlFilePath, string strTitleID, string strPackageID, BillingState state, bool bPremium, bool bWriteSites, bool bContent)
        {
            try
            {
                //
                // Check all the files in the repository
                //

                Console.WriteLine("Copying control file to TitleVault...");

                string strControlFile = strPackageID.ToUpper() + ".control";

                if(bContent == true)
                {
                    SetContentControl(strControlFilePath, state, bPremium, bWriteSites);
                }
                else
                {
                    SetAutoupdControl(strControlFilePath, bWriteSites);
                }

                TitleVaultWorkFile(strTitleID, strControlFilePath, strControlFile);

                Console.WriteLine("Success");

            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
            }
        }

        public static void BillingWorkSQL2(string strSQL2FilePath, string strTitleID, string strPackageID)
        {
            try
            {
                //
                // Check all the files in the repository
                //

                Console.WriteLine("Copying sql2 file to TitleVault..");

                string strSQL2File = strPackageID.ToUpper() + ".sql2";

//                Ini controlIni = new Ini(strControlFile);
//
//                bool bPremium = (controlIni.GetSetting("Billing", "Premium").ToUpper() == "YES");
//
//                if(bPremium)
//                {
//                    Ini billingIni = new Ini(strBillingFile);
//                    if (billingIni.GetSetting("Template", "Required").ToUpper() != "YES")
//                    {
//                        CPropXbox1Content.ModifyBillingContent(strSQL2FilePath, strBillingFile);
//                        string strNewSQL2File = strSQL2FilePath + ".new";
//                        File.Copy(strNewSQL2File, strSQL2FilePath, true);
//                        File.Delete(strNewSQL2File);
//                    }
//                }

                TitleVaultWorkFile(strTitleID, strSQL2FilePath, strSQL2File);

                Console.WriteLine("Success");
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
            }
        }

        public static void CleanUpWorkingFolder(string strFilePath)
        {
            //
            // Clean up the current directory
            //

            File.Delete(strFilePath + ".new");
            File.Delete(strFilePath + ".cab");
            File.Delete(strFilePath + ".ops");
            File.Delete(strFilePath + ".sql");
            File.Delete(strFilePath + ".sql2");
            File.Delete(strFilePath + ".xbx");
            File.Delete(strFilePath + ".control2");
        }

        public static void UpdateXKDCCache()
        {
            //
            // Update XKDC cache
            //
            string [] XKDCArray = Config.GetServerListByInterface(Interface.kdcsvc);

            if((0 == XKDCArray.Length) || ("" == XKDCArray[0]))
            {
                Console.WriteLine("FAIL: Servers.ini: No XKDC IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < XKDCArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.RunCommand(XKDCArray[iIndex], "exec :xkdc reload\r\n");
                    Console.WriteLine(XKDCArray[iIndex] + ":  " + output);
                }
            }
        }

        public static void UpdateXBOSCache()
        {
            //
            // Update XBOS cache
            //
            string [] XBOSArray = Config.GetServerListByInterface(Interface.xbos_int);

            if((0 == XBOSArray.Length) || ("" == XBOSArray[0]))
            {
                Console.WriteLine("Servers.ini: No XBOS IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < XBOSArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.RunCommand(XBOSArray[iIndex], "exec :xbos cacheflush\r\n");
                    Console.WriteLine(XBOSArray[iIndex] + ":  " + output);
                }
            }
        }

        public static void UpdateUACSCache()
        {
            //
            // Update UACS cache
            //
            string [] UACSArray = Config.GetServerListByInterface(Interface.xuacs_int);

            if((0 == UACSArray.Length) || ("" == UACSArray[0]))
            {
                Console.WriteLine("Servers.ini: No UACS IP addresses!");
            }
            else
            {
                for(int iIndex = 0; iIndex < UACSArray.Length; ++iIndex)
                {
                    string output = CMgmtCommand.RunCommand(UACSArray[iIndex], "exec :xuacs cacheflush\r\n");
                    Console.WriteLine(UACSArray[iIndex] + ":  " + output);
                }
            }
        }



        public static bool TransferWork(string strTitleID, string strID)
        {
            string root = Config.GetSetting(Setting.titlevault_root);

            string strRelativePath = "\\" + strTitleID.ToLower() + "\\" + strID.ToLower();
            string strPackageFile = root + strRelativePath + ".xcp";
            string strControlFile = root + strRelativePath + ".control";
            string strSql2File = root + strRelativePath + ".sql2";
            string strSite = null;

            bool bRet = true;

            try
            {
                //
                //  Do the working file exist?
                //
                CPropXbox1Utils.VerifyExists(strControlFile);
                CPropXbox1Utils.VerifyExists(strPackageFile);

                //
                // Is it a subscription?
                StreamReader reader = new StreamReader(strSql2File);
                string line = reader.ReadLine();
                reader.Close();

                if (line == null || line.IndexOf("subscriptions") >= 0)
                {
                    Console.WriteLine("Skipping transfer of subscription: " + strID);
                    return true;
                }

                Ini controlIni = new Ini(strControlFile);

                string strBillingState = controlIni.GetSetting("Billing", "SPS");

                if("NOTREADY" == strBillingState.ToUpper())
                {
                    throw new ApplicationException("Packet in SPSNotReady billing state can not be transferred!");
                }


                strSite = controlIni.GetSetting("Package", "Site");

                if("" == strSite)
                {
                    strSite = "1";
                }

                //
                // Transfer the files
                //

                XICPackageInfo pkgInfo = new XICPackageInfo(0);
                pkgInfo.TitleID = UInt32.Parse(strTitleID, NumberStyles.HexNumber);
                pkgInfo.ContentID = BitConverter.GetBytes(UInt64.Parse(strID, NumberStyles.HexNumber));
                Array.Reverse(pkgInfo.ContentID);

                XICPackage pkg = new XICPackage(pkgInfo, strPackageFile);

                Console.WriteLine("Transferring " + strPackageFile + " to the locations...");
                XICDistributer dist = new XICDistributer();
                dist.DistributePackage(pkg, true);

            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                bRet = false;
            }

            return (bRet);
        }

        public static string [] GetPackageList(string strTitlePath, string strPackageID)
        {
            string [] strPackageIDs;

            if(strPackageID.ToLower() == "all")
            {
                strPackageIDs = Directory.GetFiles(strTitlePath, "*.control");
                for (int i = 0; i < strPackageIDs.GetLength(0); i++)
                {
                    strPackageIDs[i] = Path.GetFileNameWithoutExtension(strPackageIDs[i]);
                }
            }
            else
            {
                strPackageIDs = strPackageID.Split(';');
            }

            return (strPackageIDs);
        }

        public static int Transfer(string strTitleID, string strPackageID)
        {
            int hr = HR_SUCCEEDED;
            string srcPath = Config.GetSetting(Setting.titlevault_root);

            try
            {
                //
                //  Get the list of title ids we are transferring
                //
                //                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);
                //
                //                if(null == strPackageID)
                //                {
                //                    strPackageID = "all";
                //                }
                //                if((titleIDs.Count > 1) && ("all" != strPackageID))
                //                {
                //                    Console.WriteLine("Ignoring /packageid option...");
                //                    strPackageID = "all";
                //                }
                //
                //                foreach(string strTitle in titleIDs)
                //                {

                //
                //  Get the list of package ids we are transferring
                //
                string strTitlePath = srcPath + "\\" + strTitleID.ToLower();
                string [] packageIDs = GetPackageList(strTitlePath, strPackageID);

                foreach(string strPackage in packageIDs)
                {
                    try
                    {
                        string strPackagePath = strTitlePath + "\\" + strPackage;
                        string strPackageFile = strPackagePath + ".xcp";
                        string strControlFile = strPackagePath + ".control";

                        //                            sd.Sync(strPackageFile);
                        //                            sd.Sync(strControlFile);

                        TransferWork(strTitleID, strPackage);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAIL: " + e.Message);
                    }
                }
                //                }
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }
            finally
            {
            }

            return (hr);
        }

        //        public static int CleanOffer(string strOfferID)
        //        {
        //            int hr = HR_SUCCEEDED;
        //
        //            try
        //            {
        //                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
        //                {
        //                    c.Open();
        //
        //                    for (int i=0; i < c.SqlPartitions.Count; i++)
        //                    {
        //                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        //                        ws.PhysicalPartition = i;
        //                        ws.StoredProc = "dbo.p_svc_clean_offers";
        //
        //                        long lParam = Convert.ToInt64(strOfferID, 16);
        //                        ws.AddParameter("@bi_offer_id", lParam);
        //
        //                        ws.ExecuteNonQuery();
        //                        ws.Close();
        //                    }
        //                }
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //                hr = HR_FAILED;
        //            }
        //
        //            return (hr);
        //        }
        //
        //        public static int EnumerateOffers(string strTitlePath)
        //        {
        //            int hr = HR_SUCCEEDED;
        //
        //            try
        //            {
        //                string strTitleID = Path.GetFileName(strTitlePath);
        //                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
        //
        //                ws.StoredProc = "dbo.p_svc_enumerate_offers";
        //                ws.AddParameter("@i_title_id", Convert.ToInt32("0x" + strTitleID, 16));
        //
        //                WstDataReader rs = ws.Execute();
        //
        //                FileStream fs = new FileStream(strTitlePath + "\\offers.txt", FileMode.Create, FileAccess.Write);
        //                StreamWriter sw = new StreamWriter(fs);
        //
        //                while( rs.Read() )
        //                {
        //                    sw.WriteLine(ExtractID(Convert.ToString(rs.GetInt64(0),16), 16));
        //                }
        //
        //                rs.Close();
        //                sw.Close();
        //                fs.Close();
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //                hr = HR_FAILED;
        //            }
        //
        //            return (hr);
        //        }
        //
        //        public static void Sync(string strTitlePath, bool bReloadCache)
        //        {
        //            string strTitleID = Path.GetFileName(strTitlePath);
        //
        //            try
        //            {
        //
        //                //
        //                // Run insert title
        //                //
        //                if (HR_FAILED == InsertTitle(strTitlePath))
        //                {
        //                    throw new ApplicationException("Failed to insert title in the database");
        //                }
        //
        //                if (HR_FAILED == EnumerateOffers(strTitlePath))
        //                {
        //                    throw new ApplicationException("Failed to enumerate offers for title " + strTitlePath);
        //                }
        //
        //                string strOffersFile = strTitlePath + "\\offers.txt";
        //
        //                StreamReader sr = File.OpenText(strOffersFile);
        //
        //                ArrayList actions = new ArrayList();
        //                string strLine = sr.ReadLine();
        //                while( null != strLine )
        //                {
        //                    CUODBID action = new CUODBID(strLine, UODBAction.DELETE);
        //                    actions.Add(action);
        //                    strLine = sr.ReadLine();
        //                }
        //
        //                sr.Close();
        //
        //                //
        //                // Delete the offers.txt file created previous step
        //                //
        //                File.Delete(strOffersFile);
        //
        //                string [] controlFiles = Directory.GetFiles(strTitlePath, "*.control");
        //
        //                for(int iIndex = 0; iIndex < controlFiles.Length; iIndex++)
        //                {
        //                    //only do content
        //                    string strID = Path.GetFileNameWithoutExtension(controlFiles[iIndex]);
        //
        //                    if (!IsIDContent(strTitleID, strID))
        //                    {
        //                        continue;
        //                    }
        //
        //                    //see if it is sps=notready
        //                    Ini ctlIni = new Ini(controlFiles[iIndex]);
        //                    if (ctlIni.GetSetting("BILLING", "SPS").ToUpper() == "NOTREADY")
        //                    {
        //                        Console.WriteLine("NOTE: Skipping NotReady " + strID);
        //                        continue;
        //                    }
        //
        //                    CUODBID action = null;
        //                    if (Console.Transfer)
        //                        action = new CUODBID(strID, UODBAction.UPDATE_TRANSFER);
        //                    else
        //                        action = new CUODBID(strID, UODBAction.UPDATE);
        //
        //                    int nIndex = actions.IndexOf(action);
        //
        //                    if(-1 != nIndex)
        //                    {
        //                        actions.RemoveAt(nIndex);
        //                    }
        //
        //                    actions.Add(action);
        //                }
        //
        //                //do all content related actions
        //                foreach(CUODBID action in actions)
        //                {
        //                    if(CPropXbox1Utils.IsIDContent(strTitleID, action.ID))
        //                    {
        //                        if(!CPropXbox1Content.UODBWork(strTitleID, action.ID, action.Action))
        //                        {
        //                            throw new ApplicationException("Update UODB for " + action.ID);
        //                        }
        //                    }
        //                }
        //
        //                CPropXbox1Update.Sync(strTitleID); //autoupdates get a special sync now
        //
        //                if(bReloadCache)
        //                {
        //                    UpdateXKDCCache();
        //                    UpdateXBOSCache();
        //                    UpdateUACSCache();
        //                }
        //
        //                Console.WriteLine("Content Sync: Success");
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //        }

        //        public static void Export(string strExportPath, string strTitleID)
        //        {
        //            CSourceDepot sd;
        //
        //            try
        //            {
        //                sd = new CSourceDepot();
        //
        //                Console.WriteLine("Copying files...");
        //                //
        //                // Check all the files in the repository
        //                //
        //                string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
        //                strExportPath += "\\" + strTitleID.ToUpper();
        //
        //                sd.Sync(strTitlePath + "\\...");
        //                sd.Finished();
        //
        //                if(!Directory.Exists(strTitlePath))
        //                {
        //                    throw (new ApplicationException("The title " + strTitleID + " doesn't exist in the repository!"));
        //                }
        //
        //                //
        //                //  Create destination directory if necessary
        //                //
        //                if(!Directory.Exists(strExportPath))
        //                {
        //                    Directory.CreateDirectory(strExportPath);
        //                }
        //
        //                //
        //                // Copy everything under the title under the export path
        //                //
        //                CopyDirectory(strTitlePath, strExportPath, false);
        //
        //                Console.WriteLine("Success!");
        //
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //            finally
        //            {
        //                sd = null;
        //            }
        //        }

        public static void CopyFiles(string strSrcDir, string strPattern , string strDestDir)
        {
            //
            // All the classes that refer to Directory in .NET have a Move method, but not a Copy
            //
            string [] strFiles;

            if(null == strPattern)
            {
                strFiles = Directory.GetFiles(strSrcDir);
            }
            else
            {
                strFiles = Directory.GetFiles(strSrcDir, strPattern);
            }

            foreach(string strFile in strFiles)
            {
                string strDestFile = strDestDir + "\\" + Path.GetFileName(strFile);
                File.Copy( strFile, strDestFile, true);
                File.SetAttributes(strDestFile, FileAttributes.Normal);
            }
        }

        public static void CopyDirectory(string strSrcDir, string strDestDir, bool bCopyFiles)
        {
            if(!Directory.Exists(strDestDir))
            {
                Directory.CreateDirectory(strDestDir);
            }

            if(bCopyFiles)
            {
                CopyFiles(strSrcDir, null, strDestDir);
            }

            // make a reference to a directory
            DirectoryInfo diSrc = new DirectoryInfo(strSrcDir);

            // get a reference to each directory in that directory
            DirectoryInfo[] diArr = diSrc.GetDirectories();

            foreach (DirectoryInfo di in diArr)
            {
                string strDir = di.FullName;
                string strTargetDir = strDestDir + "\\" + Path.GetFileName(strDir);

                CopyDirectory(strDir, strTargetDir, true);
            }
        }

        //        public static void CopyDirectoryInRepository(CSourceDepot sd, string strSrcDir, string strDestDir, bool bOverwrite, bool bCopyFiles)
        //        {
        //            Console.WriteLine("Importing " + strSrcDir + " into " + strDestDir + "...");
        //            if(!Directory.Exists(strDestDir))
        //            {
        //                Directory.CreateDirectory(strDestDir);
        //            }
        //
        //            if(bCopyFiles)
        //            {
        //                string [] strFiles = Directory.GetFiles(strSrcDir);
        //
        //                foreach(string strFile in strFiles)
        //                {
        //                    string strDestFile = strDestDir + "\\" + Path.GetFileName(strFile);
        //                    if(File.Exists(strDestFile))
        //                    {
        //                        string strLine = "y";
        //                        if(!bOverwrite)
        //                        {
        //                            if(File.GetLastWriteTime(strDestFile) > File.GetLastWriteTime(strFile))
        //                            {
        //                                Console.WriteLine(Path.GetFileName(strFile) + " already exists and is more recent.");
        //                            }
        //                            Console.WriteLine("Overwrite existing file " + Path.GetFileName(strFile) + "?(y/n/a)");
        //                            strLine = Console.ReadLine();
        //                            if("a" == strLine)
        //                            {
        //                                strLine = "y";
        //                                bOverwrite = true;
        //                            }
        //
        //                        }
        //                        if("y" == strLine)
        //                        {
        //                            sd.Edit(strDestFile);
        //                            File.Copy( strFile, strDestFile, true);
        //                            sd.Submit(strDestFile, "titlemgr: Imported " + strDestFile);
        //                            Console.WriteLine("Overwritten " + strDestFile);
        //                        }
        //                    }
        //                    else
        //                    {
        //                        File.Copy( strFile, strDestFile);
        //                        File.SetAttributes(strDestFile, FileAttributes.Normal);
        //                        sd.Add(strDestFile);
        //                        sd.Submit(strDestFile, "titlemgr: Imported " + strDestFile);
        //                        Console.WriteLine("Added " + strDestFile);
        //                    }
        //                }
        //            }
        //
        //            // make a reference to a directory
        //            DirectoryInfo diSrc = new DirectoryInfo(strSrcDir);
        //
        //            // get a reference to each directory in that directory
        //            DirectoryInfo[] diArr = diSrc.GetDirectories();
        //
        //            foreach (DirectoryInfo di in diArr)
        //            {
        //                string strDir = di.FullName;
        //                string strTargetDir = strDestDir + "\\" + Path.GetFileName(strDir);
        //
        //                CopyDirectoryInRepository(sd, strDir, strTargetDir, bOverwrite, true);
        //            }
        //        }
        //
        //        public static void Import(string strImportPath, bool bOverwrite)
        //        {
        //            CSourceDepot sd;
        //
        //            try
        //            {
        //                if(!Directory.Exists(strImportPath))
        //                {
        //                    throw (new ApplicationException("Invalid path: " + strImportPath));
        //                }
        //
        //                sd = new CSourceDepot();
        //
        //                // make a reference to a directory
        //                DirectoryInfo diSrc = new DirectoryInfo(strImportPath);
        //
        //                // get a reference to each directory in that directory
        //                DirectoryInfo[] diArr = diSrc.GetDirectories();
        //
        //                foreach (DirectoryInfo di in diArr)
        //                {
        //                    string strDir = di.FullName;
        //                    string strTargetDir = Environment.CurrentDirectory + "\\" + Path.GetFileName(strDir);
        //
        //                    sd.Sync(strTargetDir + "\\...");
        //
        //                    CopyDirectoryInRepository(sd, strDir, strTargetDir, bOverwrite, false);
        //
        //                    sd.Finished();
        //                }
        //
        //                Console.WriteLine("Success!");
        //
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //            finally
        //            {
        //                sd = null;
        //            }
        //        }

        public static bool IsInArray(string [] strArray, string str)
        {
            foreach(string strIt in strArray)
            {
                if(strIt.ToLower() == str.ToLower())
                {
                    return (true);
                }
            }

            return (false);
        }


        public static int UODBUpdate(string strTitleID, string strPackageID, bool bReloadCache)
        {

            int hr = HR_SUCCEEDED;
            string srcPath = Config.GetSetting(Setting.titlevault_root);
            bool bChangesMade = false;

            try
            {
                //
                //  Get the list of title ids we are updating
                //
                //                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);
                //
                //                if(null == strPackageID)
                //                {
                //                    strPackageID = "all";
                //                }
                //                if((titleIDs.Count > 1)&& ("all" != strPackageID))
                //                {
                //                    Console.WriteLine("Ignoring /offerid option...");
                //                    strPackageID = "all";
                //                }
                //
                //                foreach(string strTitle in titleIDs)
                //                {

                //
                //  Get the list of package ids we are updating
                //
                string strTitlePath = srcPath + "\\" + strTitleID.ToLower();
                string [] packageIDs = GetPackageList(strTitlePath, strPackageID);

                foreach(string strPackage in packageIDs)
                {
                    string strPackagePath = strTitlePath + "\\" + strPackage;
                    string strSQL2File = strPackagePath + ".sql2";

                    //                        sd.Sync(strSQL2File);

                    if(IsIDContent(strTitleID, strPackage))
                    {
                        CPropXbox1Content.UODBWork(Path.GetDirectoryName(strPackagePath), strTitleID, strPackageID, UODBAction.UPDATE);
                    }
                }

                //do autoupdates, but no transfer
                bool oldTransfer = CPropXbox1Update.doTransfer;
                CPropXbox1Update.doTransfer = false;
                CPropXbox1Update.Sync(strTitleID);
                CPropXbox1Update.doTransfer = oldTransfer;

                // when we're all done, reload the caches
                bChangesMade = true;
                //                }

                Console.WriteLine("UODBUpdate: Success");
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = HR_FAILED;
            }
            finally
            {
                if((HR_SUCCEEDED == hr) && bChangesMade && bReloadCache)
                {
                    CPropXbox1Utils.UpdateXBOSCache();
                    CPropXbox1Utils.UpdateXKDCCache();
                    CPropXbox1Utils.UpdateUACSCache();
                }
            }

            return (hr);
        }

        //        public static int SetLocations(string strTitleID, string strPackageID,
        //                                       string strXRLRoot, string strDownloadServers)
        //        {
        //
        //            int hr = HR_SUCCEEDED;
        //            string srcPath = Environment.CurrentDirectory;
        //
        //            try
        //            {
        //                //
        //                //  Get the list of title ids we are changing locations for
        //                //
        ////                Queue titleIDs = CTitleMgrApp.GetTitleList(strTitleID);
        ////
        ////                if(null == strPackageID)
        ////                {
        ////                    strPackageID = "all";
        ////                }
        ////                if((titleIDs.Count > 1)&& ("all" != strPackageID))
        ////                {
        ////                    Console.WriteLine("Ignoring /packageid option...");
        ////                    strPackageID = "all";
        ////                }
        ////
        ////                foreach(string strTitle in titleIDs)
        ////                {
        //
        //                    //
        //                    //  Get the list of package ids we are changing locations for
        //                    //
        //                    string strTitlePath = srcPath + "\\" + strTitleID.ToLower();
        //                    string [] packageIDs = GetPackageList(strTitlePath, strPackageID);
        //
        //                    foreach(string strPackage in packageIDs)
        //                    {
        //                        string strPackagePath = strTitlePath + "\\" + strPackage;
        //                        string strPackageFile = strPackagePath + ".pkg";
        //                        string strControlFile = strPackagePath + ".control";
        //
        ////                        sd.Sync(strPackageFile);
        ////                        sd.Sync(strControlFile);
        //
        //                        VerifyExists(strPackageFile);
        //                        VerifyExists(strControlFile);
        //
        ////                        sd.Edit(strControlFile);
        //
        //                        Ini controlIni = new Ini(strControlFile);
        //
        //                        VerifyXRL(strXRLRoot);
        //
        //                        if(IsIDContent(strTitleID, strPackage))
        //                        {
        //                            controlIni.SetSetting("Content", "XRLRoot", strXRLRoot);
        //                            if(null != strDownloadServers)
        //                            {
        //                                CPropXbox1Utils.VerifyXRL(strDownloadServers);
        //                                controlIni.SetSetting("Content", "DownloadServers", strDownloadServers);
        //                            }
        //                        }
        //                        else
        //                        {
        //                            controlIni.SetSetting("Autoupd", "XRLRoot", strXRLRoot);
        //                            if(null != strDownloadServers)
        //                            {
        //                                CPropXbox1Utils.VerifyXRL(strDownloadServers);
        //                                controlIni.SetSetting("Autoupd", "DownloadServers", strDownloadServers);
        //                            }
        //                        }
        //
        //                        controlIni.Save(strControlFile);
        ////                        sd.Submit(strControlFile, "TitleMgr: Set locations");
        //                        Console.WriteLine("Submitted changes to the control file " + strControlFile);
        //
        //                        if(IsIDContent(strTitleID, strPackage))
        //                        {
        //                            CPropXbox1Content.RebuildContent(strTitleID, strPackageFile, strControlFile, false, false, null, null);
        //                        }
        //                        else
        //                        {
        //                            CPropXbox1Update.RebuildUpdate(strTitleID, strPackageFile, strControlFile, false);
        //                        }
        //                    }
        ////                }
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //                hr = HR_FAILED;
        //            }
        //            finally
        //            {
        //            }
        //
        //            return (hr);
        //        }
        //    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\propxbox1content.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using xonline.common.xboxofferutil;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.sql.sqlclient;


namespace Microsoft.Ems.Tools.LiveContent
{
    /// <summary>
    /// Execute the content propping comands
    /// </summary>
    public class CPropXbox1Content
    {
        public enum OfferTypes
        {
            CONTENT,
            SUBSCRIPTION,
            BASE_SUBSCRIPTION,
            MAX_TYPES
        };

        public static int RebuildContent(
            string strTitle,
            string strContentPath,
            string strControlFile,
            bool bModifyAllFiles,
            bool bDefaultOffer,
            string strOfferPath,
            string strStartDate,
            string strEndDate)
        {
            string strRebuildFile = "rebuildcontent.exe";
            int hr = CPropXbox1Utils.HR_SUCCEEDED;
            string strBillingFile = Path.Combine(Path.GetDirectoryName(strContentPath), "billing.ini");

            try
            {
                //
                //  Do the working files exist?
                //
                CPropXbox1Utils.VerifyExists(strContentPath);
                CPropXbox1Utils.VerifyExists(strControlFile);

                Ini controlIni = new Ini(strControlFile);
                string strAlternateOfferID = controlIni.GetSetting("Content", "OfferID");
                string strKey = controlIni.GetSetting("Content", "Key");
                string strSite = controlIni.GetSetting("Package", "Site");
                string strType = controlIni.GetSetting("Package", "Type");
                bool bSiteUpgrade = false;

                if (strSite.ToUpper() == "ALL")
                    throw new ApplicationException("You have to specifically order your sites for content.");

                string[] sites = strSite.Split(';');
                string strXRLRoots = "";

                foreach (string site in sites)
                {
                    int nSite = Int32.Parse(site);

                    IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.download, nSite);

                    if (strXRLRoots.Length != 0)
                        strXRLRoots += ";";

                    strXRLRoots += vii.IPAddressString + ":" + vii.Port + "/content";
                }

                //
                // Prepare the .control file expected by RebuildContent
                //
                Ini tmpIni = new Ini();
                tmpIni.SetSetting("Content", "XRLRoot", strXRLRoots);
                tmpIni.Save(strControlFile + ".tmp");

                string strArgs = "\"" + strContentPath + "\" \"" + strControlFile + ".tmp\"" + " ";

                //
                // Retail signed
                //
                strArgs += "-R ";

                if (CPropXbox1Utils.uiIDLength == strAlternateOfferID.Length)
                {
                    strArgs += "-O:" + strAlternateOfferID + " ";
                }
                if (CPropXbox1Utils.uiKeyLength == strKey.Length)
                {
                    strArgs += strKey;
                }

                //
                // Run rebuild content on the packet
                //
                Output o = new Output("Normal");
                o.ConsoleLogging = LoggingLevel.Error;
                hr = Command.RunCommandLine(strRebuildFile, strArgs, Environment.CurrentDirectory, o);

                //
                // Delete the temporary .tmp file
                //
                File.Delete(strControlFile + ".tmp");

                if (CPropXbox1Utils.HR_SUCCEEDED != hr)
                {
                    throw (new ApplicationException("RebuildContent failed!"));
                }

                string strMainSite = strSite;

                if (strMainSite.IndexOf(';') > 0)
                    strMainSite = strMainSite.Substring(0, strMainSite.IndexOf(';'));

                CPropXbox1Utils.VerifyOffer(strContentPath + ".sql2");

                CPropXbox1Utils.VerifyRegions(strContentPath + ".sql2", strMainSite);

                CPropXbox1Utils.VerifyExists(strContentPath + ".xbx");
                Ini xbxIni = new Ini(strContentPath + ".xbx");

                string strTitleID = CPropXbox1Utils.ExtractID(xbxIni.GetSetting("All", "TitleID"), 8);
                string strOfferID = CPropXbox1Utils.ExtractID(xbxIni.GetSetting("All", "OfferingID"), 16);
                string strPremium = xbxIni.GetSetting("All", "Premium").ToUpper();
                long lTitleID = Convert.ToInt64(xbxIni.GetSetting("All", "TitleID"), 16);
                long lOfferID = Convert.ToInt64(xbxIni.GetSetting("All", "OfferingID"), 16);

                if (strTitle.ToLower() != strTitleID.ToLower())
                {
                    throw new ApplicationException("The input title ID(" + strTitle + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                if (!CPropXbox1Utils.IsIDContent(strTitleID, strOfferID))
                {
                    throw new ApplicationException("The offer ID(" + strOfferID + ") does not match the title ID of the package(" + strTitleID + ")!");
                }

                if (bModifyAllFiles)
                {
                    CPropXbox1Utils.TitleVaultWorkPackage(strContentPath, strTitleID, strOfferID);
                }

                if (bModifyAllFiles || bSiteUpgrade)
                {
                    string strBillingState = controlIni.GetSetting("Billing", "SPS").ToUpper();

                    BillingState state = BillingState.CURRENT;
                    if ("" == strBillingState)
                    {
                        Ini billingIni = new Ini(strBillingFile);
                        string strTemplateRequired = billingIni.GetSetting("Template", "Required").ToUpper();

                        if ("YES" == strTemplateRequired)
                        {
                            state = BillingState.SPS_NOT_READY;
                        }
                        else
                        {
                            state = BillingState.SPS_READY;
                        }
                    }

                    bool bPremium = (strPremium == "YES");

                    if (!bPremium)
                        state = BillingState.SPS_READY;

                    CPropXbox1Utils.TitleVaultWorkControl(strControlFile, strTitleID, strOfferID, state, bPremium, bSiteUpgrade, true);
                }

                //if start date < now, have start date = now
                UpdateStartDate(strContentPath + ".sql2", strStartDate, strEndDate);
                CPropXbox1Utils.BillingWorkSQL2(strContentPath + ".sql2", strTitleID, strOfferID);

                //                if (bDefaultTemplate)
                //                    ProcessDefaultTemplate(strTitleID, strOfferID);

                Console.WriteLine("RebuildContent: " + strOfferID + ": Success");
                Console.WriteLine("Starting transfer and UODB work now...");

                // Get contents of .offer file
                XboxContentOffer xo = null;
                XboxOffers xos = null;

                if (strOfferPath != null)
                {
                    xos = GetXbox1Offer(strTitleID, strOfferID, strContentPath, (strPremium == "YES"), bDefaultOffer, ref strOfferPath);

                    // Verify we have at least one good Content Offer
                    if (xos.__XboxContentOffer == null)
                    {
                        throw new Exception(string.Format("Invalid OfferFile. Please verify that there is 1 Content Offer in your OfferFile?"));
                    }

                    xo = xos.XboxContentOffer;

                    // Validate that we have a true default offerfile
                    if (bDefaultOffer && ((UInt64)xo.xboxOfferBasicInfo.titleID != 0xFFFFFFFF || (UInt64)xo.xboxOfferBasicInfo.offerID != 0xFFFFFFFFFFFFFFFF))
                    {
                        throw new Exception(string.Format("Invalid default OfferFile. Please verify that you are using the default OfferFile."));
                    }
                }
                else
                {
                    // Old case where nothing is supposed to happen to the offer file
                    xo = new XboxContentOffer();
                }

                // Push info into UODB and update XboxOffer XML data accordingly
                UODBWork(strContentPath, strTitleID, strOfferID, UODBAction.UPDATE, ref xo);

                // Store contents of .offer file
                if (strOfferPath != null)
                {
                    // Make sure OfferID was updated everywhere
                    if (bDefaultOffer)
                        UpdateXbox1Offer(ref xo, lOfferID);

                    StoreXbox1Offer(xos, strOfferPath);
                }

                //  Transfer packages

                CPropXbox1Utils.Transfer(strTitleID, strOfferID);

            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = CPropXbox1Utils.HR_FAILED;
            }
            finally
            {
                CPropXbox1Utils.CleanUpWorkingFolder(strContentPath);
            }

            return (hr);

        }

        public static int RebuildContent(string strTitle, string strContentPath, string strSite, string strOfferID,
            string strStartDate, string strEndDate, bool bDefaultOffer, string strOfferPath)
        {
            int hr = CPropXbox1Utils.HR_SUCCEEDED;

            try
            {
                //
                //  Does the specified source file exist?
                //
                CPropXbox1Utils.VerifyExists(strContentPath);
                CPropXbox1Utils.VerifySites(strSite);

                Ini controlIni = new Ini();

                controlIni.SetSetting("Package", "Site", strSite);

                if (null != strOfferID)
                {
                    CPropXbox1Utils.VerifyID(strOfferID);
                    controlIni.SetSetting("Content", "OfferID", strOfferID);
                }

                if (null != strStartDate)
                {
                    CPropXbox1Utils.VerifyDate(strStartDate);
                    controlIni.SetSetting("Content", "StartDate", strStartDate);
                }

                if (null != strEndDate)
                {
                    CPropXbox1Utils.VerifyDate(strEndDate);
                    controlIni.SetSetting("Content", "EndDate", strEndDate);
                }

                controlIni.Save(strContentPath + ".control2");

                hr = RebuildContent(strTitle, strContentPath, strContentPath + ".control2", true, bDefaultOffer, strOfferPath, strStartDate, strEndDate);
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = CPropXbox1Utils.HR_FAILED;
            }

            return (hr);
        }

        //public static void ProcessDefaultTemplate(string strTitleID, string strOfferID)
        private static XboxOffers GetXbox1Offer(string strTitleID, string strOfferID, string strContentPath, bool bPremium, bool bDefaultOffer, ref string strOfferPath)
        {
            string premiumOfferFormat = "{0}Premium{1}Content.offer";
            string freeOfferFormat = "{0}Free{1}Content.offer";
            string offerFile = "";
            string destFile = "";

            if (bDefaultOffer && strOfferPath == String.Empty) // then /adddefault cmd-switch was used
            {
                if (bPremium)
                {
                    offerFile = String.Format(premiumOfferFormat, "", "Default");
                    destFile = String.Format(premiumOfferFormat, strOfferID + "_", "");
                }
                else
                {
                    offerFile = String.Format(freeOfferFormat, "", "Default");
                    destFile = String.Format(freeOfferFormat, strOfferID + "_", "");
                }

                // Using same directory as pkg files
                offerFile = Path.Combine(Path.GetDirectoryName(strContentPath), offerFile);
                destFile = Path.Combine(Path.GetDirectoryName(strContentPath), destFile);

                // Make a copy first, to same location that the content is in
                File.Copy(offerFile, destFile, true);

                strOfferPath = destFile; // now use this as the offerpath
            }

            // Now update the .offer file with the correct values.  
            CPropXbox1Utils.VerifyExists(strOfferPath);

            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));
            XmlReader validatingReader = XboxOfferUtil.CreateValidatingReader(strOfferPath);
            XboxOffers xo = (XboxOffers)serializer.Deserialize(validatingReader);
            validatingReader.Close();

            return xo;

            //CPropXbox1Content.InjectBoids(strTitleID, strOfferID);
        }

        private static void StoreXbox1Offer(XboxOffers xo, string file)
        {
            // Store the XboxOffer, i.e. Serialize it out to file...
            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));

            StreamWriter streamWriter = new StreamWriter(file);
            XmlWriter writer = new XmlTextWriter(streamWriter.BaseStream, null); // null defaults to UTF8
            serializer.Serialize(writer, xo);
            writer.Close();
        }

        private static void UpdateXbox1Offer(ref XboxContentOffer xo, long lOfferID)
        {
            XboxOfferBasicInfo xobi = xo.xboxOfferBasicInfo;
            xobi.offerID = lOfferID;

            foreach (XboxOfferDescription xod in xo.xboxOfferDescriptionCollection)
            {
                xod.liveOfferID = lOfferID;
            }

            foreach (XboxOfferDescriptionDetails xods in xo.xboxOfferDescriptionDetailsCollection)
            {
                xods.liveOfferID = lOfferID;
            }

            foreach (XboxOfferLocations xol in xo.xboxOfferLocationsCollection)
            {
                xol.offerID = lOfferID;
            }

            foreach (XboxOfferRegions xor in xo.xboxOfferRegionsCollection)
            {
                xor.liveOfferID = lOfferID;
            }
        }

        //        public static void ProcessDefaultTemplate(string strTitleID, string strOfferID)
        //        {
        //            string controlFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" + strOfferID + ".control";
        //            string premiumTemplateFile = Environment.CurrentDirectory + "\\DefaultPackages\\PremiumTemplate.xls";
        //            string freeTemplateFile = Environment.CurrentDirectory + "\\DefaultPackages\\FreeTemplate.xls";
        //
        //            Ini controlIni = new Ini(controlFile);
        //            string premium = controlIni.GetSetting("BILLING", "PREMIUM");
        //            if (premium == "YES")
        //            {
        //                CPropXbox1Content.SubmitTemplate(strTitleID, strOfferID, premiumTemplateFile, true);
        //            }
        //            else
        //            {
        //                CPropXbox1Content.SubmitTemplate(strTitleID, strOfferID, freeTemplateFile, true);
        //            }
        //
        //            CPropXbox1Content.InjectBoids(strTitleID, strOfferID);
        //        }

        public static void UpdateStartDate(string sqlFile, string strStartDate, string strEndDate)
        {
            if (!File.Exists(sqlFile))
                throw new Exception("Can't find file: " + sqlFile);

            StreamReader sr = new StreamReader(sqlFile);

            Console.WriteLine("Setting dates: " + strStartDate + " -> " + strEndDate);

            string line;
            ArrayList lines = new ArrayList();
            int done = 0;
            while ((line = sr.ReadLine()) != null)
            {
                //first date is start date
                string[] parts = line.Split('/');
                if (parts.Length == 3 && done == 0)
                {
                    //it's a date
                    line = line.Replace("'", "");
                    line = line.Replace(",", "");
                    DateTime dt = Convert.ToDateTime(line);
                    if (strStartDate != null)
                        dt = Convert.ToDateTime(strStartDate);

                    if (DateTime.Compare(dt, DateTime.Now) < 0)
                        dt = DateTime.Now;

                    line = "    '" + dt.ToString("MM/dd/yyyy") + "',";

                    done = 1;
                }
                else if (parts.Length == 3 && done == 1)
                { //second date is end date
                    if (strEndDate != null)
                    {
                        DateTime dt = Convert.ToDateTime(strEndDate);
                        line = "    '" + dt.ToString("MM/dd/yyyy") + "',";
                    }
                    done = 2;
                }
                lines.Add(line);
            }
            sr.Close();

            //write the lines out again
            StreamWriter wr = new StreamWriter(sqlFile);

            for (int i = 0; i < lines.Count; i++)
                wr.WriteLine((string)(lines[i]));
            wr.Close();
        }
        private static bool VerifyOfferExistence(long offerId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by offer id
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_verify_offer_exists";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                uint hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
        }
        private static void DashUODBUpdate(string strOfferID)
        {
            int hr = CPropXbox1Utils.HR_SUCCEEDED;
            bool offerExists = true;
            Ini billingIni = new Ini(Environment.CurrentDirectory + "\\Billing.ini");
            long lParam = Convert.ToInt64(strOfferID, 16);

            string strSites = billingIni.GetSetting("BaseSubscription", "Sites");

            if ("" != strSites)
            {
                string[] strSiteArray = strSites.Split(';');

                foreach (string strSite in strSiteArray)
                {
                    using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                    {
                        c.Open();

                        for (int i = 0; i < c.SqlPartitions.Count; i++)
                        {
                            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                            ws.PhysicalPartition = i;
                            ws.StoredProc = "dbo.p_svc_insert_offer_services";
                            ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);

                            ws.AddParameter("@bi_offer_id", lParam);
                            ws.AddParameter("@i_site_id", strSite);
                            ws.ExecuteNonQuery();

                            hr = ws.GetIntParameter("@RETVAL");
                            ws.Close();

                            if (CPropXbox1Utils.HR_SUCCEEDED != hr)
                            {
                                throw new ApplicationException("UODB: Nonexistent offer ID:" + strOfferID);
                            }
                        }
                    }
                }
            }

            string strVouchers = billingIni.GetSetting("BaseSubscription", "Vouchers");

            if ("" != strVouchers)
            {
                string[] strVoucherArray = strVouchers.Split(';');
                offerExists = VerifyOfferExistence(lParam);
                if (offerExists)
                {
                    foreach (string strVoucher in strVoucherArray)
                    {
                        using (WstConnection c = new WstConnection(ConfigUtil.TokendbWebstoreApp))
                        {
                            c.Open();

                            for (int i = 0; i < c.SqlPartitions.Count; i++)
                            {
                                WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                                ws.PhysicalPartition = i;
                                ws.StoredProc = "dbo.p_svc_add_voucher";
                                CUODBContent.AddBinaryParam(ws, "@bin_voucher_hash", strVoucher); // hash value of the voucher
                                ws.AddParameter("@bi_offer_id", lParam);//offer id
                                ws.AddParameter("@i_use_count", -1);// i_use_count
                                ws.AddParameter("@i_voucher_status_id", 0); //i_voucher_status_id)
                                ws.ExecuteNonQuery();
                                ws.Close();
                            }
                        }
                    }
                }
            }
        }

        public static bool UODBWork(string strContentPath, string strTitleID, string strOfferID, UODBAction action)
        {
            XboxContentOffer xo = new XboxContentOffer();
            return UODBWork(strContentPath, strTitleID, strOfferID, action, ref xo);
        }

        public static bool UODBWork(string strContentPath, string strTitleID, string strOfferID, UODBAction action, ref XboxContentOffer xo)
        {
            bool bRet = true;

            try
            {
                //                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToLower();

                if (UODBAction.DELETE == action)
                {
                    //
                    // Run clear offer
                    //
                    //CPropXbox1Content.ChangeDates(strTitleID, strOfferID, DateTime.Now.ToString(), DateTime.Now.ToString(), true);

                    using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                    {
                        c.Open();

                        for (int i = 0; i < c.SqlPartitions.Count; i++)
                        {
                            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                            ws.PhysicalPartition = i;
                            ws.StoredProc = "dbo.p_svc_offer_change_dates";

                            long lParam = Convert.ToInt64(strOfferID, 16);
                            ws.AddParameter("@bi_offer_id", lParam);
                            DateTime dt = DateTime.Now;
                            ws.AddParameter("@dt_start_date", dt); //startdate
                            ws.AddParameter("@dt_end_date", dt); //end date

                            ws.ExecuteNonQuery();
                            ws.Close();
                        }
                    }

                    /*
                    if (CPropXbox1Utils.HR_FAILED == CPropXbox1Utils.CleanOffer(strOfferID))
                    {
                        Console.WriteLine("FAIL: Failed to clear offer " + strOfferID + " in the database");
                        bRet = false;
                    }

                    Console.WriteLine("strOfferID: Sucessfully disabled from UODB.");

                    if(bRet)
                    {
                        //
                        // Remove it from the downloadservers
                        //
                        //CPropXbox1Utils.RemovePackagesFromDL(strTitleID, strOfferID);
                        //Console.WriteLine("strOfferID: Sucessfully removed from the download servers.");
                    }

                    */
                    return (bRet);
                }

                string strSQL2File = strContentPath + ".sql2";
                string strControlFile = strContentPath + ".control2";


                //
                //  Do the working files exist?
                //

                CPropXbox1Utils.VerifyExists(strSQL2File);
                CPropXbox1Utils.VerifyExists(strControlFile);

                Ini controlIni = new Ini(strControlFile);
                string strBillingState = controlIni.GetSetting("Billing", "SPS");

                if ("NOTREADY" == strBillingState.ToUpper())
                {
                    throw new ApplicationException("Packet in SPSNotReady billing state can not be propped to UODB!");
                }

                //
                // Transfer files first if that is the case
                //
                if (UODBAction.UPDATE_TRANSFER == action)
                {
                    bRet = CPropXbox1Utils.TransferWork(strTitleID, strOfferID);
                }

                if (bRet)
                {
                    Console.WriteLine(strOfferID + ": Updating UODB ... \r\n");
                    //
                    // Update UODB
                    //
                    CUODBContent.Exec(strSQL2File, strOfferID, ref xo);

                    //
                    // Flush front door caches
                    //
                    CPropXbox1Utils.UpdateXKDCCache();
                    CPropXbox1Utils.UpdateXBOSCache();
                    CPropXbox1Utils.UpdateUACSCache();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                bRet = false;
            }
            finally
            {
            }
            return (bRet);
        }


        public static int ChangeDates(string strTitleID, string strOfferID, string strStartDate, string strEndDate, bool bReloadCache)
        {
            int hr = CPropXbox1Utils.HR_SUCCEEDED;

            try
            {
                //
                // Sync the control and sql2 files from the repository
                //
                string strControlFile = Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                    "\\" + strOfferID.ToLower() + ".control";
                string strSQL2File = Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                    "\\" + strOfferID.ToLower() + ".sql2";
                string strPath = Environment.CurrentDirectory + "\\" + strTitleID.ToLower();

                //                sd.Sync(strControlFile);
                //                sd.Sync(strSQL2File);

                //
                //  Do the working files exist?
                //
                CPropXbox1Utils.VerifyExists(strControlFile);
                CPropXbox1Utils.VerifyExists(strSQL2File);

                //                sd.Edit(strControlFile);
                //                sd.Edit(strSQL2File);

                Ini controlIni = new Ini(strControlFile);

                if (null != strStartDate)
                {
                    CPropXbox1Utils.VerifyDate(strStartDate);
                    controlIni.SetSetting("Content", "StartDate", strStartDate);
                }
                else
                    strStartDate = controlIni.GetSetting("Content", "StartDate");

                if (null != strEndDate)
                {
                    CPropXbox1Utils.VerifyDate(strEndDate);
                    controlIni.SetSetting("Content", "EndDate", strEndDate);
                }
                else
                    strEndDate = controlIni.GetSetting("Content", "EndDate");

                if (strEndDate == null || strStartDate == null ||
                    strEndDate.Length == 0 || strStartDate.Length == 0)
                {
                    throw new ApplicationException("Please specify both a start date and an end date");
                }
                if (Convert.ToDateTime(strStartDate) > Convert.ToDateTime(strEndDate))
                {
                    throw new ApplicationException("You cannot specify a start date " + strStartDate +
                        " that is later than the end date " + strEndDate);
                }

                controlIni.Save(strControlFile);

                //
                // Modify the .sql2 file
                //
                // remove any instances of p_svc_offer_change_dates
                StreamReader reader = new StreamReader(strSQL2File);
                ArrayList list = new ArrayList();

                //add every line except lines from change_dates .. blank line
                string line;
                bool addLine = true;
                while ((line = reader.ReadLine()) != null)
                {
                    if (line.Trim().Length == 0)
                        addLine = true;

                    if (line.IndexOf("p_svc_offer_change_dates") >= 0)
                        addLine = false;

                    if (addLine)
                        list.Add(line);
                }

                reader.Close();

                StreamWriter sw = new StreamWriter(strSQL2File);
                for (int i = 0; i < list.Count; i++)
                    sw.WriteLine(list[i]);

                //append the changedate
                sw.WriteLine("");
                sw.WriteLine("exec p_svc_offer_change_dates");
                sw.WriteLine("    0x" + strOfferID + ",");
                if (null == strStartDate)
                {
                    sw.WriteLine("    null,");
                }
                else
                {
                    sw.WriteLine("    " + strStartDate + ",");
                }
                if (null == strEndDate)
                {
                    sw.WriteLine("    null");
                }
                else
                {
                    sw.WriteLine("    " + strEndDate);
                }

                sw.Close();

                //
                //  Submit changes
                //
                Console.WriteLine("Submitting changes to the repository...");
                //                sd.Submit(Environment.CurrentDirectory + "\\" + strTitleID.ToLower() +
                //                    "\\...", "titlemgr: Updated dates package for " + strOfferID);
                Console.WriteLine("Success");

                Console.WriteLine(strOfferID + ": Updating UODB ...");

                using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    c.Open();

                    for (int i = 0; i < c.SqlPartitions.Count; i++)
                    {
                        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                        ws.PhysicalPartition = i;
                        ws.StoredProc = "dbo.p_svc_offer_change_dates";

                        long lParam = Convert.ToInt64(strOfferID, 16);
                        ws.AddParameter("@bi_offer_id", lParam);
                        DateTime dt = Convert.ToDateTime(strStartDate);
                        ws.AddParameter("@dt_start_date", dt);
                        dt = Convert.ToDateTime(strEndDate);
                        ws.AddParameter("@dt_end_date", dt);

                        ws.ExecuteNonQuery();
                        ws.Close();
                    }
                }

                Console.WriteLine("Successfully changed dates and updated uodb.");

                if (bReloadCache)
                {
                    CPropXbox1Utils.UpdateXBOSCache();
                    CPropXbox1Utils.UpdateUACSCache();
                    CPropXbox1Utils.UpdateXKDCCache();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
                hr = CPropXbox1Utils.HR_FAILED;
            }
            finally
            {
            }

            return (hr);
        }

        public static bool AddDefault(string strTitleID, string strPackagePath, string strSites)
        {
            bool bRet = true;

            Console.WriteLine("Adding default content packages for " + strTitleID + "...");

            string[] sites = strSites.Split(';');

            if (!Directory.Exists(strPackagePath))
            {
                throw new ApplicationException("Default packages directory does not exist! (" + strPackagePath + ")");
            }

            foreach (string strSite in sites)
            {
                try
                {
                    string strStartIndex = "00000001";

                    int nOfferIndex = Convert.ToInt32(strStartIndex, 16);

                    string[] strFiles = Directory.GetFiles(strPackagePath, "*.pkg");
                    foreach (string strFile in strFiles)
                    {
                        string strRealFile = strPackagePath + "\\" + Path.GetFileName(strFile);
                        string strOfferID = strTitleID + CPropXbox1Utils.ExtractID(nOfferIndex.ToString("X"), 8);
                        RebuildContent(
                            strTitleID,
                            strRealFile,
                            strSite,
                            strOfferID,
                            null,
                            null,
                            true,
                            "");
                        nOfferIndex++;
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("FAIL: " + e.Message);
                    bRet = false;
                }
            }

            return (bRet);
        }

        //        public static void RemoveDefault(string strTitleID)
        //        {
        //            string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
        //
        //            try
        //            {
        //                CSync.RemoveTitles(strTitlePath, false);
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //        }


        //        public static void SubmitTemplate(string strTitleID, string strOfferID, string strInitialTemplate, bool bResubmit)
        //        {
        //            string strTitlePath = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper();
        //            string strControlFile =  strTitlePath + "\\" + strOfferID.ToUpper() + ".boids";
        //
        //            string strSPSFile =  strTitlePath + "\\" + strOfferID.ToUpper() + ".sps";
        //            string strBOIDsFile = Environment.CurrentDirectory + "\\Billing.ini";
        //
        //            bool bSPSFileExists = false;
        //            bool bBOIDSFileExists = false;
        //
        //            try
        //            {
        //                //
        //                //  Do the working files exist?
        //                //
        //                CPropXbox1Utils.VerifyExists(strInitialTemplate);
        //                CPropXbox1Utils.VerifyExists(strBOIDsFile);
        //
        //                Ini billingIni = new Ini(strBOIDsFile);
        //
        //                string strTemplateRequired = billingIni.GetSetting("Template", "Required").ToUpper();
        //
        //                if (strOfferID.Length != 16)
        //                {
        //                    throw new Exception("All offerid's must be 16 characters long.");
        //                }
        //                if("YES" != strTemplateRequired)
        //                {
        //                    throw new ApplicationException("Template submitting is not allowed for this environment! Exiting...");
        //                }
        //
        //                if(!CPropXbox1Utils.IsIDContent(strTitleID, strOfferID))
        //                {
        //                    throw new ApplicationException("The offer ID(" + strOfferID + ") does not match the title ID of the package(" + strTitleID + ")!");
        //                }
        //
        //                bSPSFileExists = File.Exists(strSPSFile);
        //
        //                if(bSPSFileExists && !bResubmit)
        //                {
        //                    throw new ApplicationException("Template already exists in repository." +
        //                        "If you are sure you want to overwrite it, try the /resubmit option." +
        //                        "/resubmit will cause the template information to be submitted to UODB.  Make sure it matches SPS!!");
        //                }
        //
        //                if(!File.Exists(strControlFile))
        //                {
        //                    bBOIDSFileExists = false;
        //                }
        //                else
        //                {
        //                    bBOIDSFileExists = true;
        ////                    sd.Edit(strControlFile);
        //                }
        //
        //                if(bSPSFileExists)
        //                {
        //                    Console.WriteLine("Checking out \"" + strSPSFile + "\".");
        ////                    sd.Edit(strSPSFile);
        //                }
        //
        //                FillSPSFile(strOfferID, strInitialTemplate, strSPSFile, strControlFile);
        //
        //                if (!bBOIDSFileExists) //it was just created with FillSPSFile
        ////                    sd.Add(strControlFile);
        //
        //                if (!bSPSFileExists)
        //                {
        //                    Console.WriteLine("Adding \"" + strSPSFile + "\".");
        ////                    sd.AddBinary(strSPSFile);
        //                }
        //
        //                //
        //                // Submitting changes to the repository
        //                //
        //                Console.WriteLine("Submitting changes to the repository...");
        //
        ////                sd.Submit(strSPSFile, "titlemgr: Updated sps package for " + strOfferID);
        ////                sd.Submit(strControlFile, "titlemgr: Updated control package for " + strOfferID);
        //
        //                /*if(File.Exists(strSQL2File))
        //                {
        //                    sd.Submit(strSQL2File, "titlemgr: Updated sql2 package for " + strOfferID);
        //                }
        //                */
        //
        //                Console.WriteLine("SUCCESS: Template stored in the repository.");
        //
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //
        //                //delete the .boids file
        ////                sd.Revert(strSPSFile);
        ////                sd.Revert(strControlFile);
        //                if (!bBOIDSFileExists)
        //                    File.Delete(strControlFile);
        //            }
        //            finally
        //            {
        //            }
        //
        //        }

        //        public static bool FillSPSFile(string strOfferID, string strInitialFile,
        //                                       string strSPSFile, string strControlFile)
        //        {
        //            Excel.Application oXL = null;
        //            string strBillingFile = Environment.CurrentDirectory + "\\Billing.ini";
        //            bool bValidSPSFile = false;
        //
        //
        //            try
        //            {
        //                Ini billingIni = new Ini(strBillingFile);
        //
        //                //Start Excel and get Application object.
        //                Console.WriteLine("Starting Excel to read template spreadsheet file");
        //                oXL = new Excel.Application();
        //
        //                if (oXL == null)
        //                {
        //                    throw new ApplicationException("Can't instantiate Excel object.  Please install Excel and make sure Excel.dll is ok");
        //                }
        //
        //                oXL.UserControl = true;
        //                oXL.Visible = false;
        //
        //                //Get a new workbook.
        //                Console.WriteLine("Opening the Excel workbook in file '"
        //                    + strInitialFile
        //                    + "'");
        //                Excel._Workbook oWB = (Excel._Workbook)(oXL.Workbooks.Open(
        //                    strInitialFile, Missing.Value, Missing.Value,Missing.Value,
        //                    Missing.Value,Missing.Value, Missing.Value,Missing.Value,
        //                    Missing.Value,Missing.Value, Missing.Value,Missing.Value,
        //                    Missing.Value,Missing.Value, Missing.Value));
        //
        //                Console.WriteLine("Getting pricing worksheet (2nd sheet) from Excel workbook");
        //                Excel._Worksheet oPricingSheet = (Excel._Worksheet)oWB.Sheets[2];
        //
        //                //
        //                // First validate the info in the spreadsheet
        //                //
        //                Excel.Range oRange = oPricingSheet.get_Range("A1", Missing.Value);
        //
        //                Console.WriteLine("Retrieving 'XOfferID' from the pricing worksheet");
        //                Excel.Range oXOIDRange = oRange.Find("XOfferID", Missing.Value,
        //                    Missing.Value,XlLookAt.xlPart,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oXOIDRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'XOfferID' on pricing worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                Excel.Range oXOID = oPricingSheet.get_Range(oPricingSheet.Cells[oXOIDRange.Row, oXOIDRange.Column + 1],
        //                                         oPricingSheet.Cells[oXOIDRange.Row, oXOIDRange.Column + 1]);
        //
        //                string strSPSOfferID = oXOID.Text.ToString();
        //
        //                Console.WriteLine("'XOfferID' is '"
        //                    + strSPSOfferID
        //                    + "'");
        //
        //                if (strSPSOfferID.Length < 2)
        //                {
        //                    throw new ApplicationException("'XOfferID' on the pricing worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "' of '"
        //                        + strSPSOfferID
        //                        + "' is too short to be valid.");
        //                }
        //                if(strSPSOfferID.Substring(2).ToLower() != "baadf00d" && strSPSOfferID.Substring(2).ToLower() != strOfferID.ToLower())
        //                {
        //                    throw new ApplicationException("'XOfferID' on the pricing worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "' of '"
        //                        + strSPSOfferID.Substring(2).ToLower()
        //                        + "' does not match the offer id from the command line of '"
        //                        + strOfferID.ToLower()
        //                        + "'");
        //                }
        //
        //                Console.WriteLine("Finding 'Tax in SRP' column on the pricing worksheet");
        //                Excel.Range oTaxRange = oRange.Find("Tax in SRP", Missing.Value,
        //                    Missing.Value,XlLookAt.xlPart,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oTaxRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'Tax in SRP' column on pricing worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                int nTaxesColumn = oTaxRange.Row + 1;
        //
        //                //
        //                // Rest of the billing validations ....
        //                //
        //
        //
        //                //
        //                // Fill in the information
        //                //
        //                Console.WriteLine("Getting offering worksheet (3rd sheet) from Excel workbook");
        //                Excel._Worksheet oOfferingSheet = (Excel._Worksheet)oWB.Sheets[3];
        //
        //                oRange = oOfferingSheet.get_Range("A1", Missing.Value);
        //
        //                Console.WriteLine("Finding 'Country' cell on the offering worksheet");
        //                Excel.Range oCountryRange = oRange.Find("Country", Missing.Value,
        //                    Missing.Value,XlLookAt.xlWhole,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oCountryRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'Country' cell on offering worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                int nColumn = oCountryRange.Column + 1;
        //
        //                int nCountryRow = oCountryRange.Row;
        //
        //                Console.WriteLine("Finding 'SPS Offer ID' cell on the offering worksheet");
        //                Excel.Range oBOIDsRange = oRange.Find("SPS Offer ID", Missing.Value,
        //                    Missing.Value,XlLookAt.xlPart,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oBOIDsRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'SPS Offer ID' cell on offering worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                int nBOIDRow = oBOIDsRange.Row;
        //
        //                Console.WriteLine("Finding 'UODB End User Price' cell on the offering worksheet");
        //                Excel.Range oPriceRange = oRange.Find("UODB End User Price", Missing.Value,
        //                    Missing.Value,XlLookAt.xlWhole,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oPriceRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'UODB End User Price' cell on offering worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                int nPriceRow = oPriceRange.Row;
        //
        //                Console.WriteLine("Finding 'Purchase' cell on the offering worksheet");
        //                Excel.Range oPurchaseRange = oRange.Find("Purchase", Missing.Value,
        //                    Missing.Value,XlLookAt.xlWhole,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oPurchaseRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'Purchase' cell on offering worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                int nPurchaseRow = oPurchaseRange.Row;
        //
        //                Console.WriteLine("Finding 'Service Component ID' cell on the offering worksheet");
        //                Excel.Range oBSCIDRange = oRange.Find("Service Component ID", Missing.Value,
        //                    Missing.Value,XlLookAt.xlWhole,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                if(null  == oBSCIDRange)
        //                {
        //                    throw new ApplicationException("Unable to find 'Service Component ID' cell on offering worksheet of Excel billing template '"
        //                        + strInitialFile
        //                        + "'");
        //                }
        //
        //                Console.WriteLine("Finding 'Cancel Flag (Y/N)' cell on the offering worksheet");
        //                Excel.Range oCancelFlagRange = oRange.Find("Cancel Flag (Y/N)", Missing.Value,
        //                    Missing.Value,XlLookAt.xlWhole,
        //                    Missing.Value, XlSearchDirection.xlNext,
        //                    Missing.Value, Missing.Value, Missing.Value);
        //
        //                bool bCancelRowPresent;
        //                int nCancelFlagRow = -1;
        //                if(null  == oCancelFlagRange)
        //                {
        //                    Console.WriteLine("Warning: Template "
        //                        + strInitialFile
        //                        + " does not contain Cancel Flag row. "
        //                        + "Offer will not be cancellable by the end user in any region.");
        //                    bCancelRowPresent = false;
        //                }
        //                else
        //                {
        //                    bCancelRowPresent = true;
        //                    nCancelFlagRow = oCancelFlagRange.Row;
        //                }
        //
        //                Ini BOIDsIni = new Ini();
        //
        //                //
        //                // Check to see if a BSCID is needed
        //                //
        //                int nBSCIDRow = oBSCIDRange.Row;
        //                oBSCIDRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nBSCIDRow, nColumn], oOfferingSheet.Cells[nBSCIDRow, nColumn]);
        //                string strBSCID = oBSCIDRange.Text.ToString();
        //                Console.WriteLine("'Service Component ID' on offering worksheet is '"
        //                    + strBSCID
        //                    + "'");
        //                if(null != strBSCID)
        //                {
        //                    //BSCID has been passed, save it to .boids
        //
        //                    if(strBSCID.IndexOf("N/A") >= 0)
        //                    {
        //                        //they want a BSCID, but one isn't passed
        //                        strBSCID = Guid.NewGuid().ToString();
        //                        Console.WriteLine("'Service Component ID' on offering worksheet is 'N/A', generated new Service Component ID of '"
        //                            + strBSCID
        //                            + "'");
        //                    }
        //
        //                    Console.WriteLine("Setting BSCID="
        //                        + strBSCID
        //                        + " in OFFER section of BOIDs ini file");
        //                    BOIDsIni.SetSetting("OFFER", "BSCID", strBSCID);
        //                }
        //
        //                while(nColumn < oOfferingSheet.Columns.Count)
        //                {
        //                    Console.WriteLine("Examining column '"
        //                        + nColumn
        //                        + "' in offering worksheet");
        //
        //                    oCountryRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nCountryRow, nColumn], oOfferingSheet.Cells[nCountryRow, nColumn]);
        //                    oPriceRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nPriceRow, nColumn], oOfferingSheet.Cells[nPriceRow, nColumn]);
        //                    oPurchaseRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nPurchaseRow, nColumn], oOfferingSheet.Cells[nPurchaseRow, nColumn]);
        //                    string strCountry = oCountryRange.Text.ToString();
        //                    string strPrice = oPriceRange.Text.ToString();
        //                    string strPurchase = oPurchaseRange.Text.ToString();
        //                    string strCancelFlag = "N"; // default to not cancelable
        //                    if (bCancelRowPresent)
        //                    {
        //                        oCancelFlagRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nCancelFlagRow, nColumn], oOfferingSheet.Cells[nCancelFlagRow, nColumn]);
        //                        strCancelFlag = oCancelFlagRange.Text.ToString();
        //                    }
        //
        //                    if((0 == strCountry.Length))
        //                    {
        //                        Console.WriteLine("'Country' was empty. Finished reading columns");
        //                        break;
        //                    }
        //
        //                    if (strPurchase == null || strPurchase.Length == 0
        //                        || strPrice == null || strPrice.Length ==0)
        //                    {
        //                        // if any of the required information is missing, ignore this region
        //                        Console.WriteLine("'Purchase' or 'Price' was blank for 'Country' '"
        //                            + strCountry
        //                            + "', skipping this column");
        //                        nColumn++;
        //                        continue;
        //                    }
        //
        //                    Console.WriteLine("'Country' is '"
        //                        + strCountry
        //                        + "', 'UODB End User Price' is '"
        //                        + strPrice
        //                        + "' 'Purchase' is '"
        //                        + strPurchase
        //                        + "' 'Cancel Flag' is '"
        //                        + strCancelFlag
        //                        + "'");
        //
        //                    string strRegion = billingIni.GetSetting("RegionsMapping", strCountry);
        //
        //                    if (strRegion.Length == 0)
        //                    {
        //                        //the region isn't in billing.ini
        //                        throw new ApplicationException("Unable to find Country '"
        //                            + strCountry
        //                            + "' in the [RegionsMapping] section of billing.ini");
        //                    }
        //                    Console.WriteLine("'Region code for Country '"
        //                        + strCountry
        //                        + "' is '"
        //                        + strRegion
        //                        + "'");
        //
        //                    //
        //                    // Check for a valid number
        //                    //
        //                    try
        //                    {
        //                        Convert.ToInt32(strRegion, 10);
        //                    }
        //                    catch
        //                    {
        //                        throw new ApplicationException("Unable to parse region code '"
        //                            + strRegion
        //                            + "' as a decimal integer");
        //                    }
        //
        //                    //
        //                    // Generate GUIDs for the region
        //                    //
        //                    string strBOID;
        //                    Excel.Range oBOIDRange = oOfferingSheet.get_Range(oOfferingSheet.Cells[nBOIDRow, nColumn],
        //                        oOfferingSheet.Cells[nBOIDRow, nColumn]);
        //                    strBOID = oBOIDRange.Text.ToString();
        //                    Console.WriteLine("'SPS Offer ID' in spreadsheet is currently '"
        //                        + strBOID
        //                        + "'");
        //
        //                    if (strBOID.Trim().Length == 0)
        //                    {
        //                        // there is currently no BOID defined for this country, so generate one
        //                        // and save it to the spreadsheet
        //                        strBOID = Guid.NewGuid().ToString();
        //                        oOfferingSheet.Cells[nBOIDRow, nColumn] = strBOID;
        //                        Console.WriteLine("'SPS Offer ID' was blank. Generated new SPS Offer ID of '"
        //                            + strBOID
        //                            + "' and saved to offering worksheet");
        //                    }
        //
        //                    if(null != strBSCID)
        //                    {
        //                        Console.WriteLine("Saving 'Service Component ID' of '"
        //                            + strBSCID
        //                            + "' to offering worksheet");
        //                        oOfferingSheet.Cells[nBSCIDRow, nColumn] = strBSCID;
        //                    }
        //
        //                    Console.WriteLine("Setting BOID="
        //                        + strBOID
        //                        + " in ["
        //                        + strRegion
        //                        + "] section of BOIDs ini file");
        //                    BOIDsIni.SetSetting(strRegion, "BOID", strBOID);
        //
        //                    //
        //                    // The price need to be valid
        //                    //
        //                    try
        //                    {
        //                        Convert.ToDouble(strPrice);
        //                    }
        //                    catch
        //                    {
        //                        throw new ApplicationException("Unable to parse price code '"
        //                            + strPrice
        //                            + "' as a double precision floating point number");
        //                    }
        //                    Console.WriteLine("Setting Price="
        //                        + strPrice
        //                        + " in ["
        //                        + strRegion
        //                        + "] section of BOIDs ini file");
        //                    BOIDsIni.SetSetting(strRegion, "Price", strPrice);
        //
        //                    //
        //                    // The Cancel Flag must be "Y" or "N"
        //                    // If the cancel row was not present because we're dealing with
        //                    // an old billing template we'll have set it to "N" by default
        //                    strCancelFlag = strCancelFlag.Trim().ToUpper();
        //                    if (strCancelFlag != "Y"
        //                        && strCancelFlag != "N")
        //                    {
        //                        throw new ApplicationException("Cancel Flag must be either Y or N. "
        //                            + " Cancel flag in spreadsheet is '"
        //                            + strCancelFlag
        //                            + "'");
        //                    }
        //
        //                    Console.WriteLine("Setting CancelFlag="
        //                        + strCancelFlag
        //                        + " in ["
        //                        + strRegion
        //                        + "] section of BOIDs ini file");
        //                    BOIDsIni.SetSetting(strRegion, "CancelFlag", strCancelFlag);
        //
        //                    //
        //                    // Record the taxes - look in the pricing spreadsheet
        //                    //
        //                    Console.WriteLine("Looking for tax information on Pricing worksheet for country '"
        //                        + strCountry
        //                        + "'");
        //
        //                    Excel.Range oPTaxRange = oPricingSheet.get_Range("A1", Missing.Value);
        //
        //                    Excel.Range oCountryCell = oPTaxRange.Find(strCountry, Missing.Value,
        //                        Missing.Value,XlLookAt.xlWhole,
        //                        Missing.Value, XlSearchDirection.xlNext,
        //                        Missing.Value, Missing.Value, Missing.Value);
        //                    if (oCountryCell == null)
        //                    {
        //                        throw new ApplicationException("Unable to find Country '"
        //                            + strCountry
        //                            + "' on Pricing worksheet");
        //                    }
        //
        //                    int nPCountryRow = oCountryCell.Row;
        //
        //                    Excel.Range oPFCol = oPTaxRange.Find("Price Pass/Fail", Missing.Value,
        //                        Missing.Value,XlLookAt.xlWhole,
        //                        Missing.Value, XlSearchDirection.xlNext,
        //                        Missing.Value, Missing.Value, Missing.Value);
        //
        //                    if (oPFCol == null)
        //                    {
        //                        throw new ApplicationException("Unable to find 'Price Pass/Fail' on Pricing worksheet");
        //                    }
        //
        //                    int nPFColumn = oPFCol.Column;
        //
        //                    Excel.Range oPFCell = oPricingSheet.get_Range(oPricingSheet.Cells[nPCountryRow, nPFColumn], oPricingSheet.Cells[nPCountryRow, nPFColumn]);
        //                    string strPF = oPFCell.Text.ToString();
        //
        //                    if (strPF.Trim().ToUpper() != "OK")
        //                    {
        //                        throw new ApplicationException("'Price Pass/Fail' for Country '"
        //                            + strCountry
        //                            + "' on Pricing worksheet is '"
        //                            + strPF
        //                            + "'. It must be set to 'OK'");
        //                    }
        //
        //                    Excel.Range oTaxNameCol = oPTaxRange.Find("Tax in SRP?", Missing.Value,
        //                        Missing.Value,XlLookAt.xlWhole,
        //                        Missing.Value, XlSearchDirection.xlNext,
        //                        Missing.Value, Missing.Value, Missing.Value);
        //
        //                    if (oTaxNameCol == null)
        //                    {
        //                        throw new ApplicationException("Unable to find 'Tax in SRP?' on Pricing worksheet");
        //                    }
        //
        //                    int nPColumn = oTaxNameCol.Column;
        //
        //                    Excel.Range oTaxCell = oPricingSheet.get_Range(oPricingSheet.Cells[nPCountryRow, nPColumn], oPricingSheet.Cells[nPCountryRow, nPColumn]);
        //                    string strTaxSetting = oTaxCell.Text.ToString();
        //
        //
        //                    // The XONLINE_TAX_TYPE enum from xonline.h defines the tax types
        //                    // that billing understands. It is repeated here for reference:
        //                    //
        //                    //  typedef enum {
        //                    //    NO_TAX = 0,
        //                    //    DEFAULT,
        //                    //    GST,
        //                    //    VAT,
        //                    //    TAX_NOT_APPLICABLE
        //                    //} XONLINE_TAX_TYPE;
        //                    //
        //                    Console.WriteLine("Read 'Tax in SRP?' value of of '"
        //                        + strTaxSetting
        //                        + "' for region '"
        //                        + strRegion
        //                        + "'");
        //                    if (strTaxSetting.Trim().ToUpper().Equals("PLUS APPLICABLE TAXES"))
        //                    {
        //                        Console.WriteLine("Setting Tax=0 in ["
        //                            + strRegion
        //                            + "] section of BOIDs ini file");
        //                        BOIDsIni.SetSetting(strRegion, "Tax", "0");
        //                    }
        //                    else if (strTaxSetting.Trim().ToUpper().Equals("GST INCLUDED"))
        //                    {
        //                        Console.WriteLine("Setting Tax=2 in ["
        //                            + strRegion
        //                            + "] section of BOIDs ini file");
        //                        BOIDsIni.SetSetting(strRegion, "Tax", "2");
        //                    }
        //                    else if (strTaxSetting.Trim().ToUpper().Equals("VAT INCLUDED"))
        //                    {
        //                        Console.WriteLine("Setting Tax=3 in ["
        //                            + strRegion
        //                            + "] section of BOIDs ini file");
        //                        BOIDsIni.SetSetting(strRegion, "Tax", "3");
        //                    }
        //                    else if (strTaxSetting.Trim().ToUpper().Equals("TAX NOT APPLICABLE"))
        //                    {
        //                        Console.WriteLine("Setting Tax=4 in ["
        //                            + strRegion
        //                            + "] section of BOIDs ini file");
        //                        BOIDsIni.SetSetting(strRegion, "Tax", "4");
        //                    }
        //                    else
        //                    {
        //                        // we didn't understand the content of the tax field, so whine loudly
        //                        throw new ApplicationException("Could not understand tax setting of '"
        //                            + strTaxSetting
        //                            + "' for region '"
        //                            + strRegion
        //                            + "'. The allowable values are: 'PLUS APPLICABLE TAXES', 'GST INCLUDED', 'VAT INCLUDED', and 'TAX NOT APPLICABLE'");
        //                    }
        //
        //                    nColumn++;
        //                }
        //
        //                Console.WriteLine("Saving updated spreadsheet to '"
        //                    + strSPSFile
        //                    + "'");
        //                if (File.Exists(strSPSFile))
        //                    File.Delete(strSPSFile);
        //                oWB.SaveAs(strSPSFile ,Missing.Value,Missing.Value, Missing.Value,Missing.Value,
        //                    Missing.Value,XlSaveAsAccessMode.xlNoChange, Missing.Value ,Missing.Value,
        //                    Missing.Value,Missing.Value, Missing.Value);
        //
        //                BOIDsIni.Save(strControlFile);
        //
        //                bValidSPSFile = true;
        //            }
        //            finally
        //            {
        //                if(null != oXL)
        //                {
        //                    //saving this file as a temp b/c otherwise excel prompts you to save
        //                    oXL.Save(Environment.CurrentDirectory + "\\temp.tmp");
        //                    File.Delete(Environment.CurrentDirectory + "\\temp.tmp");
        //                    oXL.Quit();
        //                }
        //            }
        //
        //            return (bValidSPSFile);
        //        }

        public static void InjectBoids(string strTitleID, string strID)
        {
            string strSQL2File = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".sql2";
            string strBOIDsFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".boids";
            string strCTLFile = Environment.CurrentDirectory + "\\" + strTitleID + "\\" +
                strID + ".control";

            try
            {
                ModifyBillingContent(strSQL2File, strBOIDsFile);

                //copy the new to the sql2
                //                sd.Edit(strSQL2File);
                File.Copy(strSQL2File + ".new", strSQL2File, true);
                File.Delete(strSQL2File + ".new");
                //                sd.Submit(strSQL2File, "New billing info injected");

                //                sd.Edit(strCTLFile);
                Ini ctlIni = new Ini(strCTLFile);
                ctlIni.SetSetting("BILLING", "SPS", "READY");
                ctlIni.Save(strCTLFile);
                //                sd.Submit(strCTLFile, "SPS is ready");

            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }

            Console.WriteLine("Boids injected successfully");
        }

        public static void ModifyBillingContent(string strSQL2File, string strBOIDsFile)
        {
            StreamReader sr = null;
            StreamWriter sw = null;
            FileStream fsr = null;
            FileStream fsw = null;

            string strNewSQL2File = strSQL2File + ".new";

            try
            {
                Ini BOIDsIni = new Ini(strBOIDsFile);

                string strID = Path.GetFileNameWithoutExtension(strBOIDsFile);

                fsr = new FileStream(strSQL2File, FileMode.Open, FileAccess.Read);

                if (File.Exists(strNewSQL2File))
                    File.Delete(strNewSQL2File);
                fsw = new FileStream(strNewSQL2File, FileMode.CreateNew, FileAccess.Write);
                sr = new StreamReader(fsr);
                sw = new StreamWriter(fsw);

                int nOfferRegionSPLine = 0; // stored procedure not found yet
                int nInsertSubscriptionsSPLine = -1; //stored procedure not found yet
                string strLine = sr.ReadLine();
                string strRegionNumber = null;
                string strPrice = null;
                int lineNum = 0;
                OfferTypes offerType = OfferTypes.CONTENT;

                //get BSCID
                string strBSCID = BOIDsIni.GetSetting("OFFER", "BSCID");
                if (strBSCID.Length == 0)
                    strBSCID = "";


                while (null != strLine)
                {
                    if (nOfferRegionSPLine > 0)
                    {
                        if (strBOIDsFile.IndexOf(".boids") < 0)
                        {
                            switch (nOfferRegionSPLine)
                            {
                                case 2: // region number
                                    strRegionNumber = strLine.Replace(',', ' ').Trim();
                                    break;
                                case 3:// BOID
                                    if (strBOIDsFile.IndexOf(".boids") < 0)
                                    {
                                        switch (offerType)
                                        {
                                            case OfferTypes.SUBSCRIPTION:
                                                strLine = "    '" + BOIDsIni.GetSetting("Subscription." + strRegionNumber, "BOID") + "',";
                                                break;
                                            case OfferTypes.BASE_SUBSCRIPTION:
                                                strLine = "    '" + BOIDsIni.GetSetting("BaseSubscription." + strRegionNumber, "BOID") + "',";
                                                break;
                                            default:
                                                strLine = "    '" + BOIDsIni.GetSetting("Content." + strRegionNumber, "BOID") + "',";
                                                break;
                                        }
                                    }
                                    break;
                                case 4: // whole price - keep these the same

                                    break;
                                case 5: //fractional price

                                    break;
                                case 6:
                                    nOfferRegionSPLine = -1;
                                    if (strLine == null || strLine.Length == 0)
                                        strLine = "0x000";
                                    break;
                            }
                        }

                        //we are deleting all previous region info
                        nOfferRegionSPLine++;

                        if (nOfferRegionSPLine == 8)
                            nOfferRegionSPLine = -1;
                    }
                    else
                    {
                        if (0 < strLine.IndexOf("p_svc_insert_offer_regions"))
                        {
                            nOfferRegionSPLine = 1; // found stored proc
                        }

                    }

                    if (nInsertSubscriptionsSPLine > 0)
                    {
                        switch (nInsertSubscriptionsSPLine)
                        {
                            case 1: //Titleid
                                if (0 < strLine.ToUpper().IndexOf(CPropXbox1Utils.XBOX1DASHID))
                                {
                                    //
                                    // Dash subscription
                                    //
                                    offerType = OfferTypes.BASE_SUBSCRIPTION;
                                }
                                else
                                {
                                    offerType = OfferTypes.SUBSCRIPTION;
                                }
                                break;
                            case 9:// BSCID
                                if (offerType != OfferTypes.BASE_SUBSCRIPTION)
                                {
                                    //not the dash
                                    strLine = "    '" + BOIDsIni.GetSetting("PremiumSubscription", "BSCID") + "',";
                                }
                                else
                                {
                                    //dash uses base ID
                                    strLine = "    '" + BOIDsIni.GetSetting("BaseSubscription", "BSCID") + "',";
                                }
                                break;
                            case 10:
                                nInsertSubscriptionsSPLine = -1;
                                break;
                        }

                        nInsertSubscriptionsSPLine++;
                    }
                    else
                    {
                        if (0 < strLine.IndexOf("p_svc_insert_subscriptions"))
                        {
                            nInsertSubscriptionsSPLine = 1; // found stored proc
                        }
                    }

                    //change BSCID line
                    lineNum++;
                    if (lineNum == 10)
                        strLine = "    '" + strBSCID + "',";

                    //
                    // Write the line
                    // Unless there is a .boids file and we are in a region
                    //
                    if (nOfferRegionSPLine == 0 || strBOIDsFile.IndexOf(".boids") < 0)
                        sw.WriteLine(strLine);

                    //have we erased the region, start writing again
                    if (nOfferRegionSPLine < 0)
                        nOfferRegionSPLine = 0;
                    //
                    // Read another line
                    //
                    strLine = sr.ReadLine();
                }

                //add region info from BOIDS file
                if (strBOIDsFile.IndexOf(".boids") >= 0)
                {
                    Hashtable hashRegions = BOIDsIni.Sections;

                    //
                    //  Find all the services, add them to the array
                    //

                    foreach (DictionaryEntry section in hashRegions)
                    {
                        //
                        //  Get section and derive service id from it
                        //

                        strRegionNumber = section.Key.ToString();

                        try
                        {
                            if (strRegionNumber == "OFFER")
                            {
                                continue;
                            }

                            Int32.Parse(strRegionNumber);

                            //if this didn't throw an exception, we have a region

                            string strBoid = BOIDsIni.GetSetting(strRegionNumber, "BOID");

                            if (strBoid.Length == 0)
                                throw new ApplicationException("Bad BOID in region " + strRegionNumber);

                            string strPriceWhole, strPricePart;
                            string[] strPrices = null;

                            strPrice = BOIDsIni.GetSetting(strRegionNumber, "PRICE");

                            if (strPrice.Length == 0)
                                throw new ApplicationException("Bad Price in region " + strRegionNumber);

                            strPrices = strPrice.Split('.');

                            strPriceWhole = strPrices[0];
                            if (strPrices.Length == 2)
                            {
                                strPricePart = strPrices[1];
                            }
                            else
                                strPricePart = "0";

                            if (strPricePart.Length == 1)
                                strPricePart += "0";

                            if (strPriceWhole.Length == 0 || strPricePart.Length == 0)
                                throw new ApplicationException("Bad Price in region " + strRegionNumber);

                            string strTax = BOIDsIni.GetSetting(strRegionNumber, "TAX");
                            string strCancelFlag = BOIDsIni.GetSetting(strRegionNumber, "CancelFlag");

                            //
                            // si_specific_offer_details column in t_offer_regions stores both
                            // the tax type, and a flag that indicates if the offer can be cancelled
                            // by the user in the dashboard.
                            //
                            // The tax type is stored in the low 3 bits (mask: 0x0007)
                            // The cancel flag is tored in the 4th bit (mask: 0x0008)
                            int iTax = 0;
                            try
                            {
                                iTax = Int32.Parse(strTax);
                            }
                            catch (Exception e)
                            {
                                throw new ApplicationException(
                                    "Unable to parse TAX setting in boids.ini file for region "
                                    + strRegionNumber,
                                    e);
                            }

                            // make sure that only the lower three bits have been
                            // used to store this tax type
                            if ((iTax & 0xFFFF8) != 0)
                            {
                                throw new ApplicationException(
                                    "Invalid TAX setting in boids.ini file for region "
                                    + strRegionNumber
                                    + " of "
                                    + iTax.ToString());
                            }

                            int iCancelFlag = 0;
                            if (strCancelFlag == "Y")
                            {
                                iCancelFlag = 0x0008;
                            }

                            int iSpecificOfferDetails = (iTax | iCancelFlag);
                            string strSpecificOfferDetails = iSpecificOfferDetails.ToString("X");

                            sw.WriteLine("exec p_svc_insert_offer_regions"); //command
                            sw.WriteLine("    0x" + strID + ","); //offer id
                            sw.WriteLine("    " + strRegionNumber + ","); //region
                            sw.WriteLine("    '" + strBoid + "',"); //boid
                            sw.WriteLine("    " + strPriceWhole + ","); //price whole
                            sw.WriteLine("    " + strPricePart + ","); //price part
                            sw.WriteLine("    0x" + strSpecificOfferDetails); //tax & cancel flag
                            sw.WriteLine(""); //blank line at the end


                        }
                        catch (FormatException)
                        {
                            //we only want to catch the Int32 exception
                            //Console.WriteLine(e.ToString());
                        }
                    }
                } //if we are in a boids file, add regions from there

            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if (null != sr)
                {
                    sr.Close();
                }

                if (null != sw)
                {
                    sw.Close();
                }

                if (null != fsr)
                {
                    fsr.Close();
                }

                if (null != fsw)
                {
                    fsw.Close();
                }

            }


        }


        //        public static void SetBillingState(string strTitleID, string strOfferID, string strSPSState)
        //        {
        //            string strControlFile = Environment.CurrentDirectory + "\\" + strTitleID.ToUpper()
        //                 + "\\" + strOfferID.ToUpper() + ".control";
        //
        //            try
        //            {
        //                if(!File.Exists(strControlFile))
        //                {
        //                    throw new ApplicationException("Path not found: " + strControlFile);
        //                }
        //
        //                if(("READY" != strSPSState.ToUpper()) && ("NOTREADY" != strSPSState.ToUpper()))
        //                {
        //                    throw new ApplicationException("Invalid SPS state specified: " + strSPSState);
        //                }
        //
        //                Console.WriteLine("Checking out \"" + strControlFile + "\".");
        ////                sd.Edit(strControlFile);
        //
        //                Ini controlIni = new Ini(strControlFile);
        //
        //                controlIni.SetSetting("Billing", "SPS", strSPSState);
        //
        //                controlIni.Save(strControlFile);
        //
        //                Console.WriteLine("Submitting out \"" + strControlFile + "\".");
        ////                sd.Submit(strControlFile, "TitleMgr: changing billing states.");
        //                Console.WriteLine("Success!");
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //            finally
        //            {
        //            }
        //        }
        //
        //        public static void Renew(string titleID, string from, string to, string sMode)
        //        {
        //            //add insert_offer_relations to sql2 file
        //            string path = Environment.CurrentDirectory + "\\" + titleID + "\\";
        //            string [] fromOffers = from.Split(';');
        //            if (!File.Exists(path + to + ".control"))
        //            {
        //                throw new Exception("To offer " + to + " does not belong to " + titleID);
        //            }
        //
        //            if (!CPropXbox1Utils.IsSubscription(titleID, to))
        //            {
        //                throw new Exception("You can only renew subscriptions. To offer " + to + " is content.");
        //            }
        //
        //            foreach(string offer in fromOffers)
        //            {
        //                if (!File.Exists(path + offer + ".control"))
        //                {
        //                    Console.WriteLine("From offer " + offer + " does not belong to " + titleID);
        //                    continue;
        //                }
        //                if (!CPropXbox1Utils.IsSubscription(titleID, offer))
        //                {
        //                    Console.WriteLine("You can only renew subscriptions. From offer " + offer + " is content.");
        //                    continue;
        //                }
        //                string sqlfile = path + to + ".sql2";
        //                //see if relation exists
        //                StreamReader reader = new StreamReader(sqlfile);
        //                string line;
        //
        //                bool found;
        //                found = false;
        //
        //                int number;
        //                number = 0;
        //
        //                ArrayList lines = new ArrayList();
        //                while ((line = reader.ReadLine()) != null)
        //                {
        //                    if (line.Trim() == "exec p_svc_insert_offer_relations")
        //                    {
        //                        // we've found an offer relations stored proc
        //
        //                        // write the stored proc name line to the output array
        //                        lines.Add(line);
        //
        //                        // the next three lines contain the "to" offerid
        //                        // the "from" offerid, and the relation type
        //                        string sToLine = reader.ReadLine();
        //                        string sFromLine = reader.ReadLine();
        //                        number += 2;
        //
        //                        // the first two lines don't get changed no matter what
        //                        // so add them to the output array list
        //                        lines.Add(sToLine);
        //                        lines.Add(sFromLine);
        //
        //                        // now, check to see if this is the offer relation
        //                        // we're interested in
        //                        if (sToLine.Trim().Substring(2).ToUpper() == (to.ToUpper() + ",")
        //                            && sFromLine.Trim().Substring(2).ToUpper() == (offer.ToUpper() + ","))
        //                        {
        //                            // this is the offer we're interested in
        //                            found = true;
        //
        //                            // the 3rd line of the proc is the relation parameter
        //                            string sRelationLine = reader.ReadLine();
        //                            number++;
        //
        //                            // the 4th line may or may not be the convert mode,
        //                            // because it's a new optional parameter that wasn't
        //                            // there before tsunami. Therefore all the pre-tsunami
        //                            // sql2 files in the repository don't have it. We
        //                            // can tell if it's there, because the previous line
        //                            // will end with a comma if there's another parameter
        //                            // to come
        //                            string sRelationLineTrim = sRelationLine.Trim();
        //                            if (sRelationLineTrim[sRelationLineTrim.Length-1] == ',')
        //                            {
        //                                // there's already a fourth line, so we don't
        //                                // need to add a comma to the third
        //                                lines.Add(sRelationLine);
        //
        //                                // get the fourth line so the reader is properly
        //                                // positioned
        //                                reader.ReadLine();
        //                                number++;
        //                            }
        //                            else
        //                            {
        //                                // there are currently only three lines. Append
        //                                // a comma to the third line, and add the fourth
        //                                lines.Add(sRelationLine+",");
        //                            }
        //
        //                            // output the correct 4th line
        //                            lines.Add("    0x" + sMode);
        //                        }
        //                    }
        //                    else
        //                    {
        //                        if (number == 10)
        //                        {
        //                            line = "    0x0004,";
        //                        }
        //
        //                        lines.Add(line);
        //
        //                        number++;
        //                    }
        //                }
        //
        //                reader.Close();
        //
        ////                sd.Edit(sqlfile);
        //                StreamWriter writer = new StreamWriter(sqlfile);
        //
        //                for (int k = 0; k < lines.Count; k++)
        //                    writer.WriteLine(lines[k]);
        //
        //                if (!found)
        //                {
        //                    //the stored proc is not in the sql2 file yet
        //                    Console.WriteLine("Adding relation " + offer + " to " + sqlfile);
        //
        //                    writer.WriteLine("");
        //                    writer.WriteLine("exec p_svc_insert_offer_relations");
        //                    writer.WriteLine("    0x" + to + ",");
        //                    writer.WriteLine("    0x" + offer + ",");
        //                    writer.WriteLine("    3,");
        //                    writer.WriteLine("    0x" + sMode);
        //                }
        //                else
        //                {
        //                    Console.WriteLine("Offer relation from " + offer + " to " + to + " updated.");
        //                }
        //
        //                writer.Close();
        ////                sd.Submit(sqlfile, "Added offer relation from " + offer + " to " + to);
        //            }
        //        }
        //
        //        public static void Voucher(string titleid, string offers, bool add)
        //        {
        //            string path = Environment.CurrentDirectory + "\\" + titleid + "\\";
        //            string [] Offers = offers.Split(';');
        //            foreach (string offer in Offers)
        //            {
        //                Console.WriteLine("Checking: " + offer);
        //
        //                string sqlfile = path + offer + ".sql2";
        //                if (!File.Exists(sqlfile))
        //                {
        //                    Console.WriteLine("Can't find sql file: " + sqlfile);
        //                    continue;
        //                }
        //
        //                ArrayList lines = new ArrayList();
        //                StreamReader reader = new StreamReader(sqlfile);
        //                string line = "";
        //                int i = 0;
        //                try
        //                {
        //                    while ((line = reader.ReadLine()) != null)
        //                    {
        //                        if (i == 16)
        //                        {
        //                            //on policy flags
        //
        //                            //if there is a comma at end of line, replace it
        //                            bool comma = false;
        //                            if (line.IndexOf(",") > 0)
        //                            {
        //                                comma = true;
        //                                line = line.Replace(",","");
        //                            }
        //                            int policy = Int32.Parse(line.Trim().Substring(2), NumberStyles.HexNumber);
        //                            if (add)
        //                                policy |= 0x200;
        //                            else
        //                                policy &= ~0x200;
        //                            line = "    0x" + policy.ToString("x");
        //                            if (comma)
        //                                line += ",";
        //                        }
        //
        //                        i++;
        //                        lines.Add(line);
        //                    }
        //                }
        //                catch(Exception e)
        //                {
        //                    Console.WriteLine("Error checking line: " + line + ". " + e.Message);
        //                    continue;
        //                }
        //                finally
        //                {
        //                    reader.Close();
        //                }
        //
        ////                sd.Edit(sqlfile);
        //
        //                StreamWriter writer = new StreamWriter(sqlfile);
        //                for(int k = 0; k < lines.Count; k++)
        //                    writer.WriteLine(lines[k]);
        //                writer.Close();
        //
        ////                sd.Submit(sqlfile, "titlemgr: updated policy flags on voucher: " + add.ToString());
        //
        //                Console.WriteLine("Set voucher status to " + add + " on: " + offer);
        //            }
        //        }
        //
        //        public static void SyncOffer(string titleid, string offer)
        //        {
        //            try
        //            {
        //                Console.WriteLine("Syncing single offer: " + offer);
        //
        //                string strFileBase = Environment.CurrentDirectory + "\\" + titleid + "\\" + offer;
        //                if (!File.Exists(strFileBase + ".sql2"))
        //                    throw new Exception("FAIL: file not found - " + strFileBase + ".sql2");
        //
        //                //first transfer the file
        //                CPropXbox1Utils.Transfer(titleid, offer);
        //
        //                //now do uodb work
        //                CUODBContent.Exec(strFileBase + ".sql2");
        //
        //                //reload front doors
        //                CPropXbox1Utils.UpdateXKDCCache();
        //                CPropXbox1Utils.UpdateXBOSCache();
        //                CPropXbox1Utils.UpdateUACSCache();
        //            }
        //            catch(Exception e)
        //            {
        //                Console.WriteLine("FAIL: " + e.Message);
        //            }
        //        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\tools\command.cs ===
using System;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;

namespace Microsoft.Ems.Tools.LiveContent
{

	public class Command
	{
		public static int RunOSqlCommand(string server, string database, string sqlfile, string workingDir, Output logger)
		{
		    string sqlParams = "-S " + server + " -i \"" + sqlfile + "\" -d " + database + " -n";

		    // Using integrated
		    sqlParams += " -E";

		    return RunCommandLine("osql.exe", sqlParams, workingDir, logger);
		}

		public static int RunSqlCommand(string server, string database, string sqlcommand)
		{
		    string connStr = "Server=" + server + ";Database=" + database;

		    // Using integrated
		    connStr += ";Integrated Security=true";

		    SqlConnection conn = new SqlConnection(connStr);
		    conn.Open();

		    SqlCommand cmd = new SqlCommand(sqlcommand, conn);

		    int hr = cmd.ExecuteNonQuery();

		    conn.Close();

		    return hr;
		    
		}

		public static SqlDataReader RunSqlQuery(string server, string database, string sqlcommand)
		{
		    string connStr = "Server=" + server + ";Database=" + database;

		    // Using integrated
		    connStr += ";Integrated Security=true";

		    SqlConnection conn = new SqlConnection(connStr);
		    conn.Open();

		    SqlCommand cmd = new SqlCommand(sqlcommand, conn);

		    return cmd.ExecuteReader();
		}

		public static int RunCommandLine(string file, string args, string workingDir, Output logger)
		{
		    Process p = new Process();
		    p.StartInfo.WorkingDirectory = workingDir;
		    p.StartInfo.FileName = file;
		    p.StartInfo.Arguments = args;
		    p.StartInfo.CreateNoWindow = true;
		    p.StartInfo.UseShellExecute = false;
		    p.StartInfo.RedirectStandardOutput = true;
		    p.StartInfo.RedirectStandardError = true;
		    p.Start();

		    string output = p.StandardOutput.ReadToEnd();
		    output += p.StandardError.ReadToEnd();

		    if (output.IndexOf("FAIL") >= 0)
		    	logger.Log(output, LogType.Error);
		    else
			logger.Log(output, LogType.Information);

		    p.WaitForExit();

		    return p.ExitCode;           
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\tools\cmgmtcommand.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;

namespace Microsoft.Ems.Tools.LiveContent
{
	/// <summary>
	/// 
	/// </summary>
	public class CMgmtCommand
	{
        // Change this static member to control timeouts of command execution
        public static int TimeoutMilliseconds = 60000; // 60 seconds

        public static string RunCommand(string target, string command)
        {
            TcpClient client = new TcpClient();
            string result = null;
            
            try
            {
                client.NoDelay = true;
                client.Connect(target, 4100);

                client.ReceiveTimeout = TimeoutMilliseconds;
                client.SendTimeout = TimeoutMilliseconds;

                NetworkStream stream = client.GetStream();
                StreamReader reader = new StreamReader(stream);

                if(stream.CanWrite && stream.CanRead)
                {
                    byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                    stream.Write(sendBytes, 0, sendBytes.Length);

                    //  Second line is the response text, this is what we return
                    result = reader.ReadLine();

                    result = reader.ReadLine();
                    
                }
                else
                    return null;
            }
            catch (Exception e)
            {
                //sb.Append("FAIL: CMgmtCommand - " + e.Message + "\r\n");
                result = "FAIL: " + e.Message;
            }
            finally
            {
                client.Close();
            }

            return result;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\tools\csv.cs ===
//This class was initially generated for the use of Categories for Avatar ingestion
//but can be expanded out for future use as needed

using System;
using System.Collections;
using System.Collections.Generic;

using System.Collections.Specialized;
using System.IO;
using System.Text;

namespace Microsoft.Ems.Tools.LiveContent
{
    /// <summary>
    ///  Generates a single array of strings that are parsed out of a CSV file
    /// </summary>
    internal class LiveContentCategoriesCsv
    {
        private List<String> csvValues = new List<String>();

        #region Constants
        public const char  csvDelimiters = ',';
        #endregion

        /// <summary>
        ///  Csv Class Constructor
        /// </summary>
        /// <param name="CsvPath"></param>
        public LiveContentCategoriesCsv(string CsvPath)
        {
            csvValues = new List<string>();
            CsvRead(CsvPath, Encoding.Default);
        }


        /// <summary>
        ///  Csv Class Constructor
        /// </summary>
        /// <param name="CsvPath"></param>
        /// <param name="fileEncoding"></param>
        public LiveContentCategoriesCsv(string CsvPath, Encoding fileEncoding)
        {
            csvValues = new List<string>();
            CsvRead(CsvPath, fileEncoding);
        }


        /// <summary>
        /// called by the class constructor to read and parse the 
        /// csv file into a list of strings
        /// </summary>
        /// <param name="CsvPath"></param>
        /// <param name="fileEncoding"></param>
        private void CsvRead(string csvPath, Encoding fileEncoding)
        {
            string line;

            if (csvPath == null || (!File.Exists(csvPath)))
            {
                throw new Exception("ERROR: " + csvPath + " csv file not found");
            }

            using (StreamReader reader = new StreamReader(csvPath, fileEncoding))
            {
                try
                {
                    for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                    {
                        foreach (string value in line.Split(csvDelimiters))
                        {
                            if (value != null && value != string.Empty)
                            {
                                csvValues.Add(value);
                            }//end if                        
                        }//end foreach                    
                    }//end for

                }//end try       
                catch (Exception)
                {
                    throw new Exception("ERROR: parsing csv file");
                }
            }//using
        }//end method

        /// <summary>
        /// returns a list of strings of the values parsed from the csv file
        /// </summary>
        public List<String> CsvValues
        {
            get
            {
                return csvValues;
            }
        }
    }//end class
}//end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\GameOfferHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Globalization;
using Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using CatalogWebServiceProxy = Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using System.Data.SqlClient;
using System.Collections;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.offerutil;
using Microsoft.Ems.Tools.LiveTools.Common.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.title;

namespace Microsoft.Ems.Tools.LiveOfferTool
{
    /// <summary>
    /// Helper class for all Game related operations on EMS CatalogDB
    /// </summary>
    public static class GameOfferHelper
    {
        static GameOfferHelper()
        {
            // before we do any operations with the Catalog webservice, set the right url for this environment
            IVirtualInterfaceInfo virtualInterface = null;

            try
            {
                virtualInterface = Config.GetVirtualInterface(VirtualInterface.contentIngestion, Site.main);
            }
            catch (ApplicationException) // this is thrown if the setting doesn't exist
            {
            }

            if ((virtualInterface != null)
                && !String.IsNullOrEmpty(virtualInterface.Url.AbsoluteUri)
                && !String.IsNullOrEmpty(virtualInterface.VDir))
            {
                CatalogServicesInternal.Init();
                CatalogServices.Catalog.Url = virtualInterface.Url.AbsoluteUri + virtualInterface.VDir + "/CatalogServices.asmx";
            }
        }


        /// <summary>
        /// Helper method that will create or update a Game Content entry in CatalogDB
        /// from the specified information
        /// </summary>
        /// <param name="contentOffer">Class from the .offer file that contains information about the game content offers</param>
        /// <param name="content">Class from the .offer file that contains information about the game content package</param>
        public static void CreateGameContent(ContentOffer contentOffer, Content content)
        {
            if (contentOffer == null)
                throw new ArgumentNullException("contentOffer is required to create GameContent in the catalog");
            if (contentOffer.offerBasicInfo == null)
                throw new ArgumentException("offerBasicInfo for contentOffers is required.");
            if (content == null)
                throw new ArgumentNullException("content");

            CategoryCollection categoryCollection = contentOffer.categoryCollection;
            OfferBasicInfo offerInfo = contentOffer.offerBasicInfo;
            ContentOfferType offerType = contentOffer.contentOfferType;
            OfferConsumableInfo offerConsumableInfo = contentOffer.__offerConsumableInfo;
            string gameContentMediaIdOverride = contentOffer.gameContentMediaId;

            try
            {
                ulong offerID = OfferManager.ParseUlong(offerInfo.offerID);
                uint bitFilter = OfferManager.ParseUint(offerInfo.bitFilter);
                long installSize = (long)content.installSize;
                long packageSize = (long)content.packageSize;
                byte[] contentID = OfferManager.HexStringToByteArray(content. contentID);
                byte[] symKey = OfferManager.HexStringToByteArray(content.symKey);
                byte[] publicKey = OfferManager.HexStringToByteArray(content.publicKey);
                uint supportedGameRegionMaskId = CatalogConstants.GameRegionMaskUnrestricted; //default

                //if game region is specified in the offer file
                if (content.gameRegion != 0)
                {
                    supportedGameRegionMaskId = content.gameRegion;
                }

                ushort publisher;
                uint titleId;
                int gameContentMediaType;
                Guid gameId, gameContentId;
                
                GetIdsForGameContent(offerID, offerType, offerInfo, offerConsumableInfo, gameContentMediaIdOverride, out publisher, out titleId, out gameId, out gameContentId, out gameContentMediaType);
                bool inheritRatings = contentOffer.__inheritRating;
                bool canInheritRatings = CanInheritRating(gameContentMediaType);
                //Do not implictly set the inheritrating flag if mediatype cannot inherit ratings
                if (canInheritRatings)
                {
                    if (!contentOffer.__inheritRatingSpecified)
                    {
                        inheritRatings = (contentOffer.__ratingCollection == null) || (contentOffer.__ratingCollection.Count == 0);
                    }
                }
                //Donot allow inherit for mediatypes which are games
                if (!canInheritRatings && inheritRatings)
                {
                    throw new ArgumentException(string.Format("Error - Offer {0} inheritrating cannot be set to true for GameMediaType {1}", offerID.ToString("x"), gameContentMediaType));
                }
                RatingCollection ratings = contentOffer.__ratingCollection;

                //Assigning the Package Type ID
                int packageTypeId = (int)GetGameContentPackageType(content.packageType, gameContentMediaType);

                //Assigning the ProviderId
                int providerId = GetProviderIdByExternalId(publisher.ToString("X4"));

                if (providerId == 0)
                    throw new ArgumentException(String.Format("Game publisher '{0}' for liveTitleID does not exist as a Provider in CatalogDB", publisher.ToString("X4")));

                // Create Game Content
                GameContent gameContent = CatalogServices.Catalog.GetGameContent(gameContentId);
                if (gameContent == null)
                {
                    gameContent = new GameContent();
                    gameContent.Id = gameContentId;
                    gameContent.Modified = InsertDataChangeType.Add;

                    Console.WriteLine(" Adding new GameContent {0}", gameContentId);
                }
                else
                {
                    gameContent.Modified = InsertDataChangeType.Update;

                    Console.WriteLine(" Updating GameContent {0}", gameContentId);
                }

                gameContent.GameMediaId = gameId;
                gameContent.ContentBitFilter = (int)bitFilter;
                gameContent.EffectiveLiveTitleId = (int)OfferManager.ParseUint(offerInfo.primaryTitleID);

                gameContent.MediaTypeId = gameContentMediaType;
                gameContent.MetadataProviderId = providerId;
                gameContent.VisibilityStatusId = CatalogConstants.VisibilityStatusLive;
                gameContent.VisibilityDate = CatalogConstants.VisibilityDateForGameMedia;
                gameContent.GeoCheckPolicy = offerInfo.requiresGeofencing;

                // Create Media Locales
                CreateGameContentLocales(offerInfo, publisher, gameContent);
                
                gameContent.InheritRating = inheritRatings;
                if (inheritRatings && ratings != null)
                {
                    ratings.Clear();
                }

                // Create Media Ratings
                CreateGameContentRatings(offerInfo, ratings, gameContent);

                // Create Media Categories
                CreateGameContentCategories(bitFilter, gameContent, offerType, categoryCollection);


                // Create the Game Content Instance                
                gameContent.Instances = CreateGameContentInstances(contentID, installSize, packageSize, symKey, publicKey, supportedGameRegionMaskId, packageTypeId, content.contentLocationCollection);

                // if its a Game Consumable, set the appropiate information
                if (gameContent.MediaTypeId == CatalogConstants.MediaType360ConsumableContent)
                {
                    gameContent.Consumable = true;
                    gameContent.LiveTitleAssetId = (int)offerConsumableInfo.assetID;
                }
                else
                {
                    gameContent.Consumable = false;
                }

                // Create Media Contributors
                gameContent.Contributors = CreateGameContentContributors(contentOffer.creatorContributorId);

                string imageLocation = null;

                // Put the offer banner image into the Catalog DB
                foreach (OfferCultureDetails offerCultureDetails in offerInfo.offerCultureDetailsCollection)
                {
                    if (!String.IsNullOrEmpty(offerCultureDetails.imageFilePath))
                    {
                        imageLocation = offerCultureDetails.imageFilePath;
                        break;
                    }
                }

                // if its a Avatar Item, ingest the appropriate image metadata
                if (gameContent.MediaTypeId == CatalogConstants.MediaTypeAvatarItem)
                {
                    // Images were ingested previously, need to setup the image in the DB. Format will be like:
                    // http://avatar.xboxlive.com/global/t.<titleId>/avataritem/<guid>/<suffix>

                    // Ingest 64x64 image
                    string url = ImageInserter.GetAvatarUrl(titleId, gameContentId, AvatarItemImageProp.SmallIconSuffix);
                    ImageInserter.InsertImage(url, titleId, CatalogConstants.AvatarUniqueIdSmallImage, offerID, CatalogConstants.ImageSizeLegacyGameTitleImage, CatalogConstants.ImageFormatPng, 0, gameContent, true);

                    // Ingest 128x128 image
                    url = ImageInserter.GetAvatarUrl(titleId, gameContentId, AvatarItemImageProp.MediumIconSuffix);
                    ImageInserter.InsertImage(url, titleId, CatalogConstants.AvatarUniqueIdMediumImage, offerID, CatalogConstants.ImageSizeMedThumbnail, CatalogConstants.ImageFormatPng, 0, gameContent, true);
                    
                    // Ingest 300x300 image
                    url = ImageInserter.GetAvatarUrl(titleId, gameContentId, AvatarItemImageProp.LargeIconSuffix);
                    ImageInserter.InsertImage(url, titleId, CatalogConstants.AvatarUniqueIdLargeImage, offerID, CatalogConstants.ImageSizeXboxTvPoster, CatalogConstants.ImageFormatPng, 0, gameContent, true);
                }

                if (!String.IsNullOrEmpty(imageLocation)
                    && File.Exists(imageLocation))
                {
                    // Grab where its going to and insert into the catalog DB
                    string titleRoot = Path.Combine(Path.GetFullPath(Config.GetSetting(Setting.titlevault_root)), titleId.ToString("X8"));
                    // toDir is where the image will be copied to                        
                    string toDir = Path.Combine(titleRoot, Path.GetFileName(imageLocation));

                    // url is the fileUrl to be used in the catalog for this image
                    // offer banner (420x95): global/t:<titleId>/marketplace/0/<offerId>
                    string url = String.Format("{0}{1}/marketplace/0/{2}", ImageInserter.BaseUrlForImages, titleId.ToString("x"), offerID.ToString("x"));

                    ImageInserter.InsertImage(imageLocation, toDir, url, titleId, 0, offerID, gameContent);                     
                }

                CatalogServices.Catalog.SaveGameContent(gameContent);

                // Add Media Relationships to this Game Content
                AddMediaRelationshipsToGameContent(offerInfo, gameId, gameContentId);
            }
            catch (SqlException e)
            {
                Console.WriteLine("SQLException occurred in creating Game Content entity: " + e.Message + "  STACK: " + e.StackTrace);
                throw;
            }
        }
        /// <summary>
        /// Returns true if mediatype supports rating inheritence, else false
        /// </summary>
        /// <param name="mediaType"></param>
        /// <returns>bool</returns>
        private static bool CanInheritRating(int mediaType)
        {
            return !(mediaType == CatalogConstants.MediaType360ArcadeGame || mediaType == CatalogConstants.MediaType360Game || mediaType == CatalogConstants.MediaTypeCommunityGame || mediaType == CatalogConstants.MediaTypeXbox1Game);
        }
        private static void CreateGameContentRatings(OfferBasicInfo offerInfo, RatingCollection ratings, GameContent gameContent)
        {
            if (offerInfo == null)
                throw new ArgumentNullException("offerInfo");
            if (gameContent == null)
                throw new ArgumentNullException("gameContent");

            // when the Game and GameContent is modeled using the same media 
            // for example Arcade, XNA, Xbox Originals, etc.
            // output a warning if there's a rating here and skip writing the offer rating to the database

            if (gameContent.Id == gameContent.GameMediaId)
            {
                if ((ratings != null) && (ratings.Count > 0))
                {
                    Console.WriteLine("Warning - Ignoring Ratings from offer {0} since they can override the existing ratings on the Game. To set ratings, update the Game and reprop it.", offerInfo.offerID);
                }
                return;
            }
            
            Dictionary<int, MediaRating> dictionaryRatings = new Dictionary<int, MediaRating>();

            if (gameContent.RatingValues != null)
            {
                foreach (MediaRating mediaRating in gameContent.RatingValues)
                {
                    mediaRating.Modified = DataChangeType.Delete;
                    dictionaryRatings.Add(mediaRating.RatingValueId, mediaRating);
                }
            }

            foreach (Rating rating in ratings)
            {
                int ratingId = GameIdMapping.GetRatingValueId(rating.ratingId, rating.ratingSystemId);
                MediaRating mediaRating = null;

                if (dictionaryRatings.ContainsKey(ratingId))
                {
                    mediaRating = dictionaryRatings[ratingId];
                    mediaRating.Modified = DataChangeType.Update;
                }
                else
                {
                    mediaRating = new MediaRating();
                    mediaRating.Modified = DataChangeType.Add;
                    mediaRating.RatingValueId = ratingId;
                    dictionaryRatings.Add(ratingId, mediaRating);
                }

                #region special case (bug 37096)
                // double prop GRB and KMRB values
                // this region can be deleted once console moves to only use GRB rating system
                if ((15001 <= ratingId) && (ratingId <= 15004))
                {
                    // will give a rating id between 11001 and 11004, which is KMRB
                    int kmrbRatingId = ratingId - 4000;

                    if (dictionaryRatings.ContainsKey(kmrbRatingId))
                    {
                        mediaRating = dictionaryRatings[kmrbRatingId];
                        mediaRating.Modified = DataChangeType.Update;
                    }
                    else
                    {
                        mediaRating = new MediaRating();
                        mediaRating.Modified = DataChangeType.Add;
                        mediaRating.RatingValueId = kmrbRatingId;
                        dictionaryRatings.Add(kmrbRatingId, mediaRating);
                    }
                }
                #endregion
            }

            MediaRating[] mediaRatings = new MediaRating[dictionaryRatings.Count];
            dictionaryRatings.Values.CopyTo(mediaRatings, 0);
            gameContent.RatingValues = mediaRatings;
        }

        /// <summary>
        /// Helper method that will create or update an Offer for Game Content in CatalogDB
        /// from the specified information
        /// </summary>
        /// <param name="contentOffer">Class from the .offer file that contains information about the game content offers</param>
        /// <param name="content">Class from the .offer file that contains information about the game content package</param>
        public static void CreateGameOffer(ContentOffer contentOffer, Content content)
        {
            if (contentOffer == null)
                throw new ArgumentNullException("contentOffer is required to create Offers in the catalog");
            if (contentOffer.offerBasicInfo == null)
                throw new ArgumentException("offerBasicInfo for contentOffers is required.");
            if (content == null)
                throw new ArgumentNullException("content");
            if (contentOffer.offerDMPInfo == null)
                throw new ArgumentException("offerDmpInfo for contentOffers is required.");

            OfferBasicInfo offerInfo = contentOffer.offerBasicInfo;
            ContentOfferType offerType = contentOffer.contentOfferType;
            OfferDMPInfo offerDmpInfo = contentOffer.offerDMPInfo;
            OfferContentInfo offerContentInfo = contentOffer.offerContentInfo;
            OfferConsumableInfo offerConsumableInfo = contentOffer.__offerConsumableInfo;
            string gameContentMediaIdOverride = contentOffer.gameContentMediaId;

            try
            {
                ulong offerID = OfferManager.ParseUlong(offerInfo.offerID);
                ushort publisher;
                uint titleId;
                int gameContentMediaType;
                Guid gameId, gameContentId;

                GetIdsForGameContent(offerID, offerType, offerInfo, offerConsumableInfo, gameContentMediaIdOverride, out publisher, out titleId, out gameId, out gameContentId, out gameContentMediaType);

                int providerId = GetProviderIdByExternalId(publisher.ToString("X4"));

                if (providerId == 0)
                    throw new ArgumentException(String.Format("Game publisher '{0}' for liveTitleID does not exist as a Provider in CatalogDB", publisher.ToString("X4")));


                Guid gameOfferId = GameIdMapping.GetGuidForOffer(offerID);
                
                // Create Offer
                CatalogWebServiceProxy.Offer offer = CatalogServices.Catalog.GetOffer(gameOfferId);
                
                if (offer == null)
                {
                    offer = new CatalogWebServiceProxy.Offer();
                    offer.Id = gameOfferId;
                    offer.Modified = InsertDataChangeType.Add;

                    Console.WriteLine(" Adding new offer {0}", gameOfferId);
                }
                else
                {
                    offer.Modified = InsertDataChangeType.Update;

                    Console.WriteLine(" Updating existing offer {0}", gameOfferId);
                }

                offer.MediaId = gameContentId;
                offer.Name = offerInfo.friendlyName;
                offer.OfferType = OfferMode.Game;

                // Create Offer Stores
                offer.Stores = CreateOfferStores(offerInfo.consoleType);

                // Create the Offer Instance
                offer.Instances = CreateOfferInstances(offer.Instances, offerInfo, offerDmpInfo, offerContentInfo, offerConsumableInfo, offerID, providerId, gameContentId, gameContentMediaType);

                CatalogServices.Catalog.SaveOffer(offer);

            }
            catch (SqlException e)
            {
                Console.WriteLine("SQLException occurred in creating Game entity: " + e.Message + "  STACK: " + e.StackTrace);
                throw;
            }
        }

        private static MediaContributor[] CreateGameContentContributors(string creatorContributorId)
        {
            MediaContributor[] contributors = null;

            if (!String.IsNullOrEmpty(creatorContributorId))
            {
                Guid contributorId = new Guid(creatorContributorId);

                // Insert contributor if missing
                Contributor contributor = CatalogServices.Catalog.GetContributor(contributorId);
                if (contributor == null)
                {
                    contributor = new Contributor();
                    contributor.Id = contributorId;
                    contributor.Modified = DataChangeType.Add;
                    contributor.MetadataProviderId = CatalogConstants.ProviderMicrosoft;
                    CatalogServices.Catalog.SaveContributor(contributor);
                }

                // add MediaContributor
                MediaContributor mediaContributor = new MediaContributor();
                mediaContributor.Modified = DataChangeType.Add;
                mediaContributor.ContributorId = contributorId;
                mediaContributor.RoleId = CatalogConstants.RoleCreator;
                mediaContributor.SortOrder = MediaContributorSortOrderDefault;
                mediaContributor.IsPrimary = true;
                mediaContributor.Character = CatalogConstants.ContributorCharacterForCommunityGame;

                contributors = new MediaContributor[] { mediaContributor };
            }

            return contributors;
        }

        private static OfferInstance[] CreateOfferInstances(OfferInstance[] existingOfferInstances, OfferBasicInfo offerInfo, OfferDMPInfo offerDmpInfo, OfferContentInfo offerContentInfo, OfferConsumableInfo offerConsumableInfo, ulong offerId, int providerId, Guid gameContentId, int gameContentMediaType)
        {
            if (offerInfo == null)
                throw new ArgumentNullException("offerInfo");
            if (offerDmpInfo == null)
                throw new ArgumentNullException("offerDmpInfo");
            if (offerContentInfo == null)
                throw new ArgumentNullException("offerContentInfo");
            if ((offerInfo.offerRegionInfoCollection == null || offerInfo.offerRegionInfoCollection.Count == 0) &&
                (existingOfferInstances == null || existingOfferInstances.Length == 0))
                throw new ArgumentException("Offer " + offerId + " should have at least 1 valid offerRegionInf element to be propped for the first time");

            Dictionary<Guid, OfferInstance> dictionaryOfferInstances = new Dictionary<Guid,OfferInstance>(offerInfo.offerRegionInfoCollection.Count);

            if (existingOfferInstances != null)
            {
                // fill the existing offer instances into the dictionary
                foreach (OfferInstance existingOfferInstance in existingOfferInstances)
                {
                    existingOfferInstance.VisibilityStatusId = CatalogConstants.VisibilityStatusDelete;
                    existingOfferInstance.Modified = InsertDataChangeType.Update;
                    dictionaryOfferInstances.Add(existingOfferInstance.Id, existingOfferInstance);
                    Console.WriteLine("  Marking as deleted offer instance = {0}, country code {1}", existingOfferInstance.Id, existingOfferInstance.CountryCode); 
                }
            }

            foreach (OfferRegionInfo offerRegionInfo in offerInfo.offerRegionInfoCollection)
            {
                if (offerRegionInfo.__paymentTypePoints != null)
                {
                    CreateOfferInstance(offerInfo, offerRegionInfo, offerDmpInfo, offerContentInfo, offerConsumableInfo, offerId, providerId, gameContentId, gameContentMediaType, CatalogConstants.PaymentTypePoints, dictionaryOfferInstances);
                }

                //Create Credit Card Offers
                if (offerRegionInfo.__paymentTypeCreditCard != null)
                {
                    CreateOfferInstance(offerInfo, offerRegionInfo, offerDmpInfo, offerContentInfo, offerConsumableInfo, offerId, providerId, gameContentId, gameContentMediaType, CatalogConstants.PaymentTypeCreditCard, dictionaryOfferInstances);
                }

                // always create an offer instance for Tokens, so tokens can be generated for all offers without having
                // to reprop to add this support.
                CreateOfferInstance(offerInfo, offerRegionInfo, offerDmpInfo, offerContentInfo, offerConsumableInfo, offerId, providerId, gameContentId, gameContentMediaType, CatalogConstants.PaymentTypeToken, dictionaryOfferInstances);
            }

            OfferInstance[] instances = new OfferInstance[dictionaryOfferInstances.Count];
            dictionaryOfferInstances.Values.CopyTo(instances, 0);
            return instances;
        }

        private static OfferInstance CreateOfferInstance(OfferBasicInfo offerInfo, OfferRegionInfo offerRegionInfo, OfferDMPInfo offerDmpInfo, OfferContentInfo offerContentInfo, OfferConsumableInfo offerConsumableInfo, ulong offerId, int providerId, Guid gameContentId, int gameContentMediaType, int paymentTypeId, Dictionary<Guid, OfferInstance> dictionaryOfferInstances)
        {
            if (offerInfo == null)
                throw new ArgumentNullException("offerInfo");
            if (offerDmpInfo == null)
                throw new ArgumentNullException("offerDmpInfo");
            if (offerContentInfo == null)
                throw new ArgumentNullException("offerContentInfo");
            if (dictionaryOfferInstances == null)
                throw new ArgumentNullException("dictionaryOfferInstances");
            if (offerRegionInfo == null)
                throw new ArgumentException("offerRegionInfo");
            
            string countryCode = GetCountryCode(offerRegionInfo.countryID);
            Guid offerInstanceId = GameIdMapping.GetGuidForOfferInstance(offerId, GetUserTypeId(offerRegionInfo.liveTier), offerRegionInfo.countryID, paymentTypeId);
            OfferInstance offerInstance;

            if (dictionaryOfferInstances.ContainsKey(offerInstanceId))
            {
                offerInstance = dictionaryOfferInstances[offerInstanceId];
                offerInstance.Modified = InsertDataChangeType.Update;
            }
            else
            {
                offerInstance = new OfferInstance();
                offerInstance.Modified = InsertDataChangeType.Add;
                offerInstance.Id = offerInstanceId;
                dictionaryOfferInstances[offerInstanceId] = offerInstance;
            }

            // only output a sample offerinstance to not clutter the output
            if (countryCode == CatalogConstants.CountryCodes.US.ToString())
            {
                Console.WriteLine("  Sample OfferInstance = {0}", offerInstance.Id);
                Console.WriteLine("   using userType = {0}  paymentType = {1}  countryCode = {2}",
                    GetUserTypeId(offerRegionInfo.liveTier),
                    paymentTypeId,
                    countryCode);
                Console.WriteLine(String.Empty);
            }

            offerInstance.PaymentTypeId = paymentTypeId;
            if (paymentTypeId != CatalogConstants.PaymentTypeCreditCard)
            {
                offerInstance.Price = (int)offerRegionInfo.paymentTypePoints.priceInPoints;
            }
            else
            {
                offerInstance.Price = CreateConcatenatedPriceForCreditCard((int)offerRegionInfo.paymentTypeCreditCard.priceWhole, (int)offerRegionInfo.paymentTypeCreditCard.priceFractional, offerId);
            }
            offerInstance.StartDateTime = offerRegionInfo.startDate;
            offerInstance.EndDateTime = offerRegionInfo.endDate;
            offerInstance.CountryCode = countryCode;
            offerInstance.PricingRuleId = 0;
            offerInstance.ReportingRetailValue = (int)offerRegionInfo.paymentTypePoints.priceInPoints;
            offerInstance.Sku = offerDmpInfo.sku.sku;
            offerInstance.VisibilityLevelId = GetVisibilityLevelId(offerInfo.offerEnumerationType, paymentTypeId);
            offerInstance.VisibilityStatusId = CatalogConstants.VisibilityStatusLive;

            if (offerRegionInfo.__paymentTypeSCGToken != null)
            {
                if (!string.IsNullOrEmpty(offerRegionInfo.__paymentTypeSCGToken.__boid))
                {
                    if (!OfferUtil.IsGUID(offerRegionInfo.__paymentTypeSCGToken.__boid))
                    {
                        throw new ArgumentException(string.Format("Billing Offer Id {0} within paymentTypeSCGToken must either be an emptystring/Guid", offerRegionInfo.__paymentTypeSCGToken.__boid));
                    }
                }
                offerInstance.ExternalOfferInstanceId = (offerRegionInfo.__paymentTypeSCGToken.__boid == null) ? string.Empty : offerRegionInfo.__paymentTypeSCGToken.__boid;
            }

            // create Offer Instance User Type
            offerInstance.UserTypes = CreateOfferInstanceUserTypes(offerRegionInfo.liveTier);

            // create Provider Term
            CreateProviderTerms(offerRegionInfo, offerContentInfo, offerConsumableInfo, offerId, providerId, offerInfo.consoleType, gameContentId, gameContentMediaType, paymentTypeId, offerInstance);
        
            return offerInstance;
        }
        /// <summary>
        /// Creates a decimal price from unsigned int whole and fractional price
        /// </summary>
        /// <param name="wholePrice"></param>
        /// <param name="fractionalPrice"></param>
        /// <returns></returns>
        private static decimal CreateConcatenatedPriceForCreditCard(int wholePrice, int fractionalPrice,ulong offerid)
        {
            string totalConcatenatedPrice = wholePrice + "." + fractionalPrice;
            decimal totalPrice;
            if (decimal.TryParse(totalConcatenatedPrice, out totalPrice))
            {
                totalPrice = Math.Round(totalPrice, 4);//Round it to four to be consistent with database schema
            }
            else
            {
                throw new ArgumentException(string.Format("Error - OfferId {0} Unparsable price values detected for CreditCard Offers", offerid.ToString("x")));
            }
            return totalPrice;
        }

        private static void CreateProviderTerms(OfferRegionInfo offerRegionInfo, OfferContentInfo offerContentInfo, OfferConsumableInfo offerConsumableInfo, ulong offerId, int providerId, ConsoleType consoleType, Guid gameContentId, int gameContentMediaType, int paymentTypeId, OfferInstance offerInstance)
        {
            if (offerRegionInfo == null)
                throw new ArgumentNullException("offerRegionInfo");
            if (offerContentInfo == null)
                throw new ArgumentNullException("offerContentInfo");
            if (offerInstance == null)
                throw new ArgumentNullException("offerInstance");

            Dictionary<Guid, ProviderTerm> dictionaryProviderTerms = new Dictionary<Guid, ProviderTerm>();

            // add any existing ProviderTerm and mark it to be deleted
            if (offerInstance.ProviderTerms != null)
            {
                foreach (ProviderTerm pt in offerInstance.ProviderTerms)
                {
                    pt.Modified = DataChangeType.Delete;
                    dictionaryProviderTerms.Add(pt.Id, pt);
                }
            }

            Guid providerTermId = GameIdMapping.GetGuidForOfferInstance(offerId, GetUserTypeId(offerRegionInfo.liveTier), offerRegionInfo.countryID, paymentTypeId);
            ProviderTerm providerTerm = null;

            // Games Ingestion only uses 1 ProviderTerm for each OfferInstance
            if (dictionaryProviderTerms.ContainsKey(providerTermId))
            {
                providerTerm = dictionaryProviderTerms[providerTermId];
                providerTerm.Modified = DataChangeType.Update;
            }
            else
            {
                providerTerm = new ProviderTerm();
                providerTerm.Modified = DataChangeType.Add;
                providerTerm.Id = providerTermId;
                dictionaryProviderTerms.Add(providerTermId, providerTerm);
            }

            providerTerm.MediaId = gameContentId;
            providerTerm.StartDateTime = offerRegionInfo.startDate;
            providerTerm.EndDateTime = offerRegionInfo.endDate;
            providerTerm.CountryCode = GetCountryCode(offerRegionInfo.countryID);

            //Check if the providerId has been defined other wise use the inferred providerid from title.
            if (offerRegionInfo.__providerIdSpecified)
            {
                int providerIdSpecified=(int)offerRegionInfo.providerId;
                if (Provider.Get(providerIdSpecified) == null)
                    throw new Exception(String.Format("Error - couldn't find the Provider {0} in the Catalog.", providerIdSpecified));
                providerTerm.ProviderId = providerIdSpecified;
            }
            else
            {
                providerTerm.ProviderId = providerId;
            }

            providerTerm.ExternalProviderContentId = offerContentInfo.contentID;
            providerTerm.DRMLicenseIssuerId = CatalogConstants.ProviderMicrosoft;
            providerTerm.ExternalDRMLicenseIssuerContentId = gameContentId.ToString();
            providerTerm.AutomaticallyGenerateOffer = false;
            providerTerm.ModifiedBy = CatalogConstants.ProviderTermModifiedBy;
            if (paymentTypeId != CatalogConstants.PaymentTypeCreditCard)
            {
                providerTerm.WholesalePrice = (int)offerRegionInfo.paymentTypePoints.priceInPoints;
            }
            else
            {
                providerTerm.WholesalePrice = CreateConcatenatedPriceForCreditCard((int)offerRegionInfo.paymentTypeCreditCard.priceWhole, (int)offerRegionInfo.paymentTypeCreditCard.priceFractional, offerId);
            }

            // create Provider Term Media Instances
            CreateProviderTermMediaInstances(offerContentInfo, offerConsumableInfo, consoleType, providerTerm, gameContentMediaType);

            ProviderTerm[] providerTerms = new ProviderTerm[dictionaryProviderTerms.Count];
            dictionaryProviderTerms.Values.CopyTo(providerTerms,0);
            offerInstance.ProviderTerms = providerTerms;
        }

        private static void CreateProviderTermMediaInstances(OfferContentInfo offerContentInfo, OfferConsumableInfo offerConsumableInfo, ConsoleType consoleType, ProviderTerm providerTerm, int gameContentMediaType)
        {
            if (offerContentInfo == null)
                throw new ArgumentNullException("offerContentInfo");
            if (providerTerm == null)
                throw new ArgumentNullException("providerTerm");

            Dictionary<Guid, ProviderTermMediaInstance> dictionaryProviderTermMediaInstance = new Dictionary<Guid, ProviderTermMediaInstance>();

            // add any existing ProviderTermMediaInstance and mark it to be deleted
            if (providerTerm.MediaInstances != null)
            {
                foreach (ProviderTermMediaInstance ptmi in providerTerm.MediaInstances)
                {
                    ptmi.Modified = DataChangeType.Delete;
                    dictionaryProviderTermMediaInstance.Add(ptmi.MediaInstanceId, ptmi);
                }
            }

            byte[] contentId = OfferManager.HexStringToByteArray(offerContentInfo.contentID);
            Guid mediaInstanceId = GameIdMapping.GetGuidForGameContentInstance(contentId);
            ProviderTermMediaInstance providerTermMediaInstance = null;

            // Games Ingestion only uses 1 ProviderTermMediaInstance for each ProviderTerm
            if (dictionaryProviderTermMediaInstance.ContainsKey(mediaInstanceId))
            {
                providerTermMediaInstance = dictionaryProviderTermMediaInstance[mediaInstanceId];
                providerTermMediaInstance.Modified = DataChangeType.Update;
            }
            else
            {
                providerTermMediaInstance = new ProviderTermMediaInstance();
                providerTermMediaInstance.Modified = DataChangeType.Add;
                providerTermMediaInstance.MediaInstanceId = mediaInstanceId;
                dictionaryProviderTermMediaInstance.Add(mediaInstanceId, providerTermMediaInstance);
            }

            providerTermMediaInstance.LicenseTypeId = GetLicenseTypeId(gameContentMediaType, offerContentInfo.licenseLevel);
            
            // create ProviderTermGameContentInstances
            providerTermMediaInstance.GameContentInstances = CreateProviderTermGameContentInstances(offerContentInfo);

            // create ProviderTermGameContentAssetInstances
            providerTermMediaInstance.GameContentAssetInstances = CreateProviderTermGameContentAssetInstances(offerConsumableInfo);

            // create ProviderTermMediaInstanceClients
            providerTermMediaInstance.ClientTypes = CreateProviderTermMediaInstanceClients(consoleType);

            ProviderTermMediaInstance[] mediaInstances = new ProviderTermMediaInstance[dictionaryProviderTermMediaInstance.Count];
            dictionaryProviderTermMediaInstance.Values.CopyTo(mediaInstances, 0);
            providerTerm.MediaInstances = mediaInstances;
        }

        private static ProviderTermMediaInstanceClientType[] CreateProviderTermMediaInstanceClients(ConsoleType consoleType)
        {
            ProviderTermMediaInstanceClientType providerTermMediaInstanceClientType = new ProviderTermMediaInstanceClientType();
            providerTermMediaInstanceClientType.Modified = DataChangeType.Add;
            providerTermMediaInstanceClientType.ClientTypeId = GetClientTypeId(consoleType);

            return new ProviderTermMediaInstanceClientType[] { providerTermMediaInstanceClientType };
        }

        private static ProviderTermGameContentInstanceAsset[] CreateProviderTermGameContentAssetInstances(OfferConsumableInfo offerConsumableInfo)
        {
            if (offerConsumableInfo == null)
                return null;

            ProviderTermGameContentInstanceAsset providerTermGameContentInstanceAsset = new ProviderTermGameContentInstanceAsset();
            providerTermGameContentInstanceAsset.Modified = DataChangeType.Add;
            providerTermGameContentInstanceAsset.AssetId = (int)offerConsumableInfo.assetID;
            providerTermGameContentInstanceAsset.Quantity = (int)offerConsumableInfo.quantity;

            return new ProviderTermGameContentInstanceAsset[] { providerTermGameContentInstanceAsset };
        }

        private static ProviderTermGameContentInstance[] CreateProviderTermGameContentInstances(OfferContentInfo offerContentInfo)
        {
            if (offerContentInfo == null)
                throw new ArgumentNullException("offerContentInfo");

            ProviderTermGameContentInstance providerTermGameContentInstance = new ProviderTermGameContentInstance();
            providerTermGameContentInstance.Modified = DataChangeType.Add;
            providerTermGameContentInstance.LicenseExtensionBits = (int)offerContentInfo.licenseExtensionBits;

            return new ProviderTermGameContentInstance[] { providerTermGameContentInstance };
        }

        private static OfferInstanceUserType[] CreateOfferInstanceUserTypes(LiveTier liveTier)
        {
            OfferInstanceUserType offerInstanceUserType = new OfferInstanceUserType();
            offerInstanceUserType.Modified = DataChangeType.Add;
            offerInstanceUserType.UserTypeId = GetUserTypeId(liveTier);

            return new OfferInstanceUserType[] { offerInstanceUserType };
        }

        private static OfferStore[] CreateOfferStores(ConsoleType consoleType)
        {
            OfferStore offerStore = new OfferStore();
            offerStore.Modified = DataChangeType.Add;

            if (consoleType == ConsoleType.PC)
                offerStore.StoreId = CatalogConstants.OfferStoreGamesForWindows;            
            else
                offerStore.StoreId = CatalogConstants.OfferStoreXbox;

            return new OfferStore[] { offerStore };
        }

        private static MediaInstance[] 
            CreateGameContentInstances(byte[] contentId, long installSize, long packageSize, byte[] encryptedSymKey, byte[] encryptedPublicKey, uint supportedGameRegionMaskId, int packageTypeId, ContentLocationCollection contentLocationCollection)
        {
            if (contentId == null)
                throw new ArgumentNullException("contentId");
            if (contentLocationCollection == null)
                throw new ArgumentNullException("contentLocationCollection");

            GameContentInstance gameContentInstance = new GameContentInstance();
            gameContentInstance.Modified = InsertDataChangeType.Add;
            gameContentInstance.Id = GameIdMapping.GetGuidForGameContentInstance(contentId);
            Console.WriteLine("  GameContentInstanceId = {0}", gameContentInstance.Id);
            // set Game Content Instance properties
            gameContentInstance.LiveContentId = contentId;
            gameContentInstance.InstallSize = installSize;
            gameContentInstance.PackageSize = packageSize;
            gameContentInstance.PackageTypeId = packageTypeId;
            gameContentInstance.EncryptedKey = new GameContentInstanceEncryptedKey();
            gameContentInstance.EncryptedKey.Modified = DataChangeType.Add;
            gameContentInstance.EncryptedKey.EncryptedSymKey = encryptedSymKey;
            gameContentInstance.EncryptedKey.EncryptedPublicKey = encryptedPublicKey;
            gameContentInstance.SupportedGameRegionMaskId = (int)supportedGameRegionMaskId;
            
            

            // set Media Instance properties
            gameContentInstance.IsAcquirable = true;
            gameContentInstance.IsAdSupported = false;
            gameContentInstance.IsPreview = false;

            gameContentInstance.GameContentInstanceFiles = CreateGameContentInstanceFiles(contentId, contentLocationCollection);

            return new MediaInstance[] { gameContentInstance };
        }

        private static GameContentInstanceFile[] CreateGameContentInstanceFiles(byte[] contentId, ContentLocationCollection contentLocationCollection)
        {            
            if (contentLocationCollection == null)
                throw new ArgumentNullException("contentLocationCollection");
                        
            if (contentLocationCollection.Count > 0)
            {
                GameContentInstanceFile[] gameContentInstanceFiles = new GameContentInstanceFile[contentLocationCollection.Count];

                for (int i = 0; i < gameContentInstanceFiles.Length; i++)
                {
                    gameContentInstanceFiles[i] = new GameContentInstanceFile();
                    gameContentInstanceFiles[i].Modified = DataChangeType.Add;
                    gameContentInstanceFiles[i].Id = GameIdMapping.GetGuidForGameContentInstanceFile(contentId, (int)contentLocationCollection[i].rank);
                    gameContentInstanceFiles[i].FileUrl = contentLocationCollection[i].xrl;
                    gameContentInstanceFiles[i].SortOrder = (int)contentLocationCollection[i].rank;
                }

                return gameContentInstanceFiles;
            }

            return new GameContentInstanceFile[0];
        }

        /// <summary>
        /// This method adds a Media Relationship for one or more Games (titles) to a GameContent.
        /// OfferBasicInfo class contains a primaryTitleGameId and a list of associated TitleIDs.
        /// This method should be called after a game content is saved.
        /// </summary>
        /// <param name="offerInfo"></param>
        /// <param name="primaryTitleGameId"></param>
        /// <param name="gameContentId"></param>
        private static void AddMediaRelationshipsToGameContent(OfferBasicInfo offerInfo, Guid primaryTitleGameId, Guid gameContentId)
        {
            if (offerInfo == null)
                throw new ArgumentNullException("offerInfo");

            // use a dictionary to only add relationships once
            Dictionary<Guid, int> dictionary = new Dictionary<Guid, int>();
            // add relationship for primary title
            dictionary.Add(primaryTitleGameId, CatalogConstants.GamesIngestionRelationshipSortOrderForPrimaryGame);
            // add relationships for associated titles
            foreach (string s in offerInfo.associatedTitleIDCollection)
            {
                Guid associatedTitleGuid = GameIdMapping.GetGuidForGame(GetConsoleTypeEnumValue(offerInfo.consoleType), OfferManager.ParseUint(s));

                if (!dictionary.ContainsKey(associatedTitleGuid))
                    dictionary.Add(associatedTitleGuid, CatalogConstants.GamesIngestionRelationshipSortOrder);
            }

            // create Media Relationships for each entry in the dictionary
            List<MediaRelationship> relationships = new List<MediaRelationship>(dictionary.Count);

            foreach (Guid guid in dictionary.Keys)
            {
                AddMediaRelationshipsToGameContent(guid, gameContentId, dictionary[guid]);
            }
        }

        private static void AddMediaRelationshipsToGameContent(Guid gameId, Guid gameContentId, int sortOrder)
        {
            Game game = CatalogServices.Catalog.GetGame(gameId);
            if (game == null)
                return; // Skip this guid, it might be a Game Demo, which is not represented in CatalogDB

            foreach (MediaRelationship mr in game.Relationships)
            {
                if ((mr.RelatedMediaId == gameContentId)
                    && (mr.MediaRelationshipTypeId == CatalogConstants.RelationshipMediaToAssociatedDownload)
                    && (mr.SortOrder == sortOrder))
                {
                    // relationship already exist, no need to save
                    return;
                }
            }

            // add new media relationship
            MediaRelationship relationship = new MediaRelationship();
            relationship.MediaRelationshipTypeId = CatalogConstants.RelationshipMediaToAssociatedDownload;
            relationship.RelatedMediaId = gameContentId;
            relationship.SortOrder = sortOrder;
            relationship.Modified = DataChangeType.Update;

            game.AddRelationship(relationship);
            game.Modified = InsertDataChangeType.Update;

            CatalogServices.Catalog.SaveGame(game);
        }

        /// <summary>
        /// Retrieves all categories of a specified CategorySystem and 
        /// adds them to the dictionary of Categories to Delete
        /// </summary>
        /// <param name="categoryValuesToDelete"></param>
        /// <param name="categorySystemId"></param>
        /// <param name="boolSubCategories"></param>
        private static void UpdateCategoriesToDelete(Dictionary<int, Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category> categoryValuesToDelete, int categorySystemId, bool includeSubCategories)
        {
            if(categoryValuesToDelete == null)
                throw new ArgumentNullException("categoryValuesToDelete");

            CategorySystem categorySystem = CatalogServices.Catalog.GetCategorySystem(categorySystemId);
            
            if (categorySystem == null)
                throw new Exception(String.Format("Error - couldn't get the Category System {0} from the Catalog.", categorySystemId));

            foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category category in categorySystem.Categories)
            {
                categoryValuesToDelete.Add(category.Id, category);

                if (includeSubCategories)
                {
                    UpdateSubCategoriesToDelete(categoryValuesToDelete, category);                    
                }
            }
        }

        /// <summary>
        /// Recurrsive statment used to add sub categories 
        /// to the dictionary of Categories to Delete
        /// </summary>
        /// <param name="categoryValuesToDelete"></param>
        /// <param name="category"></param>
        private static void UpdateSubCategoriesToDelete(Dictionary<int, Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category> categoryValuesToDelete, Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category category)
        {
            if (categoryValuesToDelete == null)
                throw new ArgumentNullException("categoryValuesToDelete");

            if(!categoryValuesToDelete.ContainsKey(category.Id))
                categoryValuesToDelete.Add(category.Id, category);

            if (category.Categories.Length > 0)
            {
                foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category subCategory in category.Categories)
                {
                    UpdateSubCategoriesToDelete(categoryValuesToDelete, subCategory);
                }
            } 
        }

        /// <summary>
        /// Checks the given CategoryId to check and apply if it 
        /// needs to be update or added to the dictionary of categories
        /// </summary>
        /// <param name="categoryId"></param>
        /// <param name="dictionaryCategories"></param>
        private static void UpdateCategoriesToAdd(int categoryId, Dictionary<int, MediaCategory> dictionaryCategories)
        {
            if (dictionaryCategories == null)
                throw new ArgumentNullException("dictionaryCategories");

            if (dictionaryCategories.ContainsKey(categoryId))
            {
                dictionaryCategories[categoryId].Modified = DataChangeType.Update;
            }
            else
            {
                MediaCategory mediaCategory = new MediaCategory();
                mediaCategory.Modified = DataChangeType.Add;
                mediaCategory.CategoryId = categoryId;
                dictionaryCategories[categoryId] = mediaCategory;
            }
        }

        private static void CreateGameContentCategories(uint bitFilter, GameContent gameContent, ContentOfferType offerType, CategoryCollection categoryCollection)
        {
            if (gameContent == null)
                throw new ArgumentNullException("gameContent");

            Dictionary<int, MediaCategory> dictionaryCategories = new Dictionary<int, MediaCategory>();
            Dictionary<int, Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category> categoryValuesToDelete = new Dictionary<int, Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Category>();

            // delete any existing mediaCategories 
            if (gameContent.Categories != null)
            {
                // delete any existing mediaCategories for publisher bits
                UpdateCategoriesToDelete(categoryValuesToDelete, CatalogConstants.MediaCategorySystemContentBitFilter, false);

                // delete any existing mediaCategories for avatar categories
                if (offerType == ContentOfferType.AvatarItem)
                {
                    UpdateCategoriesToDelete(categoryValuesToDelete, CatalogConstants.MediaCategorySystemAvatarBase, true);
                    UpdateCategoriesToDelete(categoryValuesToDelete, CatalogConstants.MediaCategorySystemAvatarExtended, true);
                }

                // add the existing MediaCategories
                foreach (MediaCategory existingMediaCategory in gameContent.Categories)
                {
                    dictionaryCategories[existingMediaCategory.CategoryId] = existingMediaCategory;

                    // set Deleted when needed
                    if (categoryValuesToDelete.ContainsKey(existingMediaCategory.CategoryId))
                    {
                        existingMediaCategory.Modified = DataChangeType.Delete;
                    }
                }
            }

            //delete exisiting AvatarGender
            if (gameContent.AvatarItem != null)
            {
                gameContent.AvatarItem.Modified = DataChangeType.Delete;
            }


            // each Content Offer can have only 1-bit of 32 set in the bitFilter
            // this would map to one MediaCategory entry
            if (bitFilter > 0)
            {
                uint x = bitFilter;
                for (int i = 1; i <= 32; i++)
                {
                    if ((x & 1) == 1)
                    {
                        int categoryId = GetBitFilterCategoryId(i);
                        UpdateCategoriesToAdd(categoryId, dictionaryCategories);

                        // assuming only one bit can be set, so we break
                        break;
                    }
                    else
                    {
                        x = x >> 1;
                    }
                }
            }

            //Adding Avatar Categories from offer file
            if (categoryCollection != null)
            {
                foreach (xonline.common.offerutil.Category category in categoryCollection)
                {
                    int categoryId = (int)category.categoryId;

                    //Avatar Extended
                    if (category.externalType == 0)
                    {
                        UpdateCategoriesToAdd(categoryId, dictionaryCategories);
                    }
                    //Avatar Body Type
                    else if (category.externalType == CatalogConstants.ExternalFeedMappingObjectAvatarBodyType)
                    {
                        if (gameContent.AvatarItem == null)
                        {
                            gameContent.AvatarItem = new GameContentAvatarItem();
			    //setting to delete so it can pass the next if statment check
                            gameContent.AvatarItem.Modified = DataChangeType.Delete;  
                        }

			//Checking to see if value has already been set
                        if (gameContent.AvatarItem.Modified != DataChangeType.Delete)
                        {
                            throw new ArgumentException("More than one AvatarBodyType found, only one allowed");
                        }

                        gameContent.AvatarItem.AvatarBodyTypeId = categoryId;
                        gameContent.AvatarItem.Modified = DataChangeType.Add;
                    }
                    else //Avatar Base
                    {  
                        //update the categoryId with the proper mapping
                        int avatarBaseCategoryId = CatalogServices.Catalog.GetCatalogId(categoryId.ToString(), CatalogConstants.ExternalFeedSourceIdLiveTools, (int)category.externalType);

                        if (avatarBaseCategoryId == -1)
                        {
                            throw new ArgumentException(String.Format("Category value {0} could not be mapped to AvatarBase Category in CatalogDb", categoryId));
                        }

                        UpdateCategoriesToAdd(avatarBaseCategoryId, dictionaryCategories);
                    }
                }
            }
            MediaCategory[] categories = new MediaCategory[dictionaryCategories.Count];
            dictionaryCategories.Values.CopyTo(categories, 0);
            gameContent.Categories = categories;
        }

        private static void CreateGameContentLocales(OfferBasicInfo offerInfo, ushort publisher, GameContent gameContent)
        {
            if (offerInfo == null)
                throw new ArgumentNullException("offerInfo");

            Dictionary<string, int> localeLookup = MediaLocaleHelper.CreateLocaleLookupTable();

            int localesCount = localeLookup.Count;

            Dictionary<int, MediaLocale> dictionaryMediaLocales = new Dictionary<int, MediaLocale>(localesCount);
            List<MediaLocaleMap> mediaLocaleMapsList = new List<MediaLocaleMap>(localesCount);
            Dictionary<int, MediaLocale> dictionaryFullGameMediaLocales = null;

            if (gameContent.Locales != null)
            {
                // fill the existing offer instances into the dictionary
                // don't delete any existing locales because they might be referenced by a different offer
                foreach (MediaLocale existingMediaLocale in gameContent.Locales)
                {
                    dictionaryMediaLocales.Add(existingMediaLocale.Lcid, existingMediaLocale);
                }
            }

            foreach (OfferCultureDetails details in offerInfo.offerCultureDetailsCollection)
            {
                int lcid = GameIdMapping.GetLcidFromUODBCultureId((int)details.culture);

                if (!localeLookup.ContainsValue(lcid))
                {
                    // skip any lcid that doesn't exist in CatalogDB and output a warning
                    Console.WriteLine(" Warning - offer {0} contains locale information for lcid={1} that is not supported in CatalogDB and will be ignored.",
                        offerInfo.offerID,
                        lcid);
                    continue;
                }

                MediaLocale mediaLocale = null;

                if (dictionaryMediaLocales.ContainsKey(lcid))
                {
                    mediaLocale = dictionaryMediaLocales[lcid];
                    mediaLocale.Modified = DataChangeType.Update;
                }
                else
                {
                    mediaLocale = new MediaLocale();
                    mediaLocale.Modified = DataChangeType.Add;
                    mediaLocale.Lcid = lcid;
                    // add the MediaLocale to the dictionary
                    dictionaryMediaLocales.Add(lcid, mediaLocale);
                }

                // create MediaLocaleMap to itself
                MediaLocaleMap mediaLocaleMap = new MediaLocaleMap();                
                mediaLocaleMap.Lcid = lcid;
                mediaLocaleMap.Modified = DataChangeType.Add;
                mediaLocale.MappedLcids = new MediaLocaleMap[] { mediaLocaleMap };

                // for certain cases (see LSG 5674 for more info)
                // get the values from the actual Game for the GameContent
                // instead of using the values from the offer file

                if ((gameContent.MediaTypeId == CatalogConstants.MediaType360ArcadeDemo)
                    || (gameContent.MediaTypeId == CatalogConstants.MediaType360ArcadeGame)
                    || (gameContent.MediaTypeId == CatalogConstants.MediaTypeCommunityGame)
                    || (gameContent.MediaTypeId == CatalogConstants.MediaType360Game))
                {
                    // only initialize the dictionary once
                    if (dictionaryFullGameMediaLocales == null)
                        InitializeGameMediaLocalesDictionary(gameContent.GameMediaId , out dictionaryFullGameMediaLocales);

                    MediaLocale mediaLocaleFromFullGame = dictionaryFullGameMediaLocales[lcid];

                    // Game should have a map for all locales
                    if (mediaLocaleFromFullGame == null)
                        throw new Exception(String.Format("Game {0} does not have a MediaLocaleMap for all locales. This needs to be fixed before ingesting content.", gameContent.GameMediaId));

                    // sort title
                    mediaLocale.TitleSort = mediaLocaleFromFullGame.TitleSort;

                    // reduced title
                    mediaLocale.ReducedTitle = mediaLocaleFromFullGame.ReducedTitle;

                    // reduced description
                    mediaLocale.ReducedDescription = mediaLocaleFromFullGame.ReducedDescription;
                }
                else
                {
                    // For most types of game content do set these properties
                    // sort title
                    MediaLocaleHelper.SetTitleSortProperty(mediaLocale, details.name);

                    // reduced title
                    MediaLocaleHelper.SetReducedTitleProperty(mediaLocale, details.name);
 
                    // reduced description
                    MediaLocaleHelper.SetReducedDescriptionProperty(mediaLocale, details.sellText);
                }

                // always set Title and Description
                MediaLocaleHelper.SetTitleProperty(mediaLocale, details.name);
                MediaLocaleHelper.SetDescriptionProperty(mediaLocale, details.sellText);
            }

            MediaLocale[] mediaLocales = new MediaLocale[dictionaryMediaLocales.Count];

            dictionaryMediaLocales.Values.CopyTo(mediaLocales, 0);

            gameContent.Locales = mediaLocales;

            
        }

        private static void InitializeGameMediaLocalesDictionary(Guid gameMediaId, out Dictionary<int, MediaLocale> dictionaryFullGameMediaLocales)
        {
            Game game = CatalogServices.Catalog.GetGame(gameMediaId);

            dictionaryFullGameMediaLocales = new Dictionary<int, MediaLocale>(game.Locales.Length);

            // add each MediaLocale referenced by a MediaLocaleMap
            foreach (MediaLocale mediaLocale in game.Locales)
            {
                foreach (MediaLocaleMap mediaLocaleMap in mediaLocale.MappedLcids)
                {
                    dictionaryFullGameMediaLocales.Add(mediaLocaleMap.Lcid, mediaLocale);
                }
            }
        }

        private static int GetProviderIdByExternalId(string externalId)
        {
            // Check for entity/provider mapping
            return CatalogServices.Catalog.GetCatalogId(externalId, CatalogConstants.ExternalFeedSourceIdLiveTools, CatalogConstants.ExternalFeedMappingObjectEntity);
        }

        private static void GetIdsForGameContent(ulong offerId, ContentOfferType offerType, OfferBasicInfo offerInfo, OfferConsumableInfo offerConsumableInfo, string gameContentMediaIdOverride,
            out ushort publisher, out uint titleId, out Guid gameMediaId, out Guid gameContentMediaId, out int gameContentMediaType)
        {
            titleId = OfferManager.ParseUint(offerInfo.primaryTitleID);
            publisher = GameIdMapping.GetPublisher(titleId);
            gameMediaId = Guid.Empty;

            gameContentMediaType = GetGameContentMediaType(offerType, offerId, titleId, publisher, offerConsumableInfo != null);

            // for certain media types, the primary titleID is a demo title that doesn't exist in CatalogDB, so we need to use the associated title
            if ((gameContentMediaType == CatalogConstants.MediaType360GameDemo)
                || (gameContentMediaType == CatalogConstants.MediaTypeXbox1Game)
                || (gameContentMediaType == CatalogConstants.MediaTypeCommunityGame))
            {
                if (offerInfo.associatedTitleIDCollection.Count == 0)
                {
                    if (gameContentMediaType == CatalogConstants.MediaType360GameDemo)
                    {
                        // for title demo offers, if there isn't an associated title id then we should try to use
                        // the primary title id if it exists
                        gameMediaId = GameIdMapping.GetGuidForGame(GetConsoleTypeEnumValue(offerInfo.consoleType), titleId);

                        //validate the game exists
                        if (CatalogServices.Catalog.GetGame(gameMediaId) == null)
                        {
                            throw new ArgumentException(String.Format(
                                    "Error - Game {0} (from Primary Title {1}) does not exist in CatalogDB and there are no associated Titles to use instead for Offer {2}. This is required for Game Content being added.\n",
                                    gameMediaId,
                                    titleId.ToString("X8"),
                                    offerId.ToString("x")));
                        }
                    }
                    else
                    {
                        throw new ArgumentException(String.Format(
                            "Error - Offer {0} requires to have an associated TitleId for CatalogDB.",
                            offerId.ToString("x")));
                    }
                }

                foreach (string s in offerInfo.associatedTitleIDCollection)
                {
                    Guid associatedTitleGuid = GameIdMapping.GetGuidForGame(GetConsoleTypeEnumValue(offerInfo.consoleType), OfferManager.ParseUint(s));

                    if (CatalogServices.Catalog.GetGame(associatedTitleGuid) != null)
                    {
                        Console.WriteLine("Using associated title {0} as gameMediaId for Game Content being added.", associatedTitleGuid);
                        gameMediaId = associatedTitleGuid;
                        break;
                    }
                }

                if (gameMediaId == Guid.Empty)
                {
                    throw new ArgumentException(String.Format(
                        "Error - Offer {0} requires to have an associated TitleId that exists in CatalogDB.",
                        offerId.ToString("x")));
                }
            }
            else if ((gameContentMediaType == CatalogConstants.MediaType360ArcadeDemo) && (titleId == XNALauncher))
            {
                // for XNA Trials will have the XNA Launcher as the primary title and we should use the associated title
                if (offerInfo.associatedTitleIDCollection.Count == 0)
                {
                    throw new ArgumentException(String.Format(
                        "Error - Offer {0} requires to have an associated TitleId for CatalogDB.",
                        offerId.ToString("x")));
                }

                foreach (string s in offerInfo.associatedTitleIDCollection)
                {
                    Guid associatedTitleGuid = GameIdMapping.GetGuidForGame(GetConsoleTypeEnumValue(offerInfo.consoleType), OfferManager.ParseUint(s));

                    if (CatalogServices.Catalog.GetGame(associatedTitleGuid) != null)
                    {
                        Console.WriteLine("Using associated title {0} as gameMediaId for Game Content being added.", associatedTitleGuid);
                        gameMediaId = associatedTitleGuid;
                        break;
                    }
                }

                if (gameMediaId == Guid.Empty)
                {
                    throw new ArgumentException(String.Format(
                        "Error - Offer {0} requires to have an associated TitleId that exists in CatalogDB.",
                        offerId.ToString("x")));
                }
            }
            else
            {
                gameMediaId = GameIdMapping.GetGuidForGame(GetConsoleTypeEnumValue(offerInfo.consoleType), titleId);

                //validate the game exists
                if (CatalogServices.Catalog.GetGame(gameMediaId) == null)
                {
                    throw new ArgumentException(String.Format(
                            "Error - Game {0} does not exist in CatalogDB and is required for Game Content being added.\n TitleId = {1}\n ConsoleType = {2}",
                            gameMediaId,
                            titleId.ToString("X8"),
                            offerInfo.consoleType));
                }
            }

            if (!String.IsNullOrEmpty(gameContentMediaIdOverride))
            {
                try
                {
                    gameContentMediaId = new Guid(gameContentMediaIdOverride);
                }
                catch (Exception e)
                {
                    throw new Exception("Error - The gameContentMediaId value could not be parsed succesfully.", e);
                }
            }
            else
            {
                gameContentMediaId = GameIdMapping.GetGuidForGameContent(gameContentMediaType, offerId, gameMediaId);
            }
        }

        #region CatalogDB Mapping methods

        private static int GetBitFilterCategoryId(int bitNumber)
        {
            return CatalogConstants.MediaCategorySystemContentBitFilter + bitNumber;
        }

        private static int GetClientTypeId(ConsoleType consoleType)
        {
            if (consoleType == ConsoleType.PC)
                return CatalogConstants.ClientTypePC;
            return CatalogConstants.ClientTypeXBox360;
        }

        private static int GetConsoleTypeEnumValue(ConsoleType consoleType)
        {
            switch (consoleType)
            {
                case ConsoleType.Xbox360: return (int)ConsoleTypeEnum.Xenon;
                case ConsoleType.PC: return (int)ConsoleTypeEnum.PC;

                default:
                    return 0;
            }
        }

        /// <summary>
        /// Maps the UODB Country Id to EMS Country code
        /// </summary>
        /// <param name="countryId"></param>
        /// <returns></returns>
        private static string GetCountryCode(int countryId)
        {
            string countryCode = string.Empty;
            switch (countryId)
            {
                case (2): countryCode=CatalogConstants.CountryCodes.AL.ToString(); break;
                case (27): countryCode = CatalogConstants.CountryCodes.DZ.ToString(); break;
                case (4): countryCode = CatalogConstants.CountryCodes.AR.ToString(); break;
                case (3): countryCode = CatalogConstants.CountryCodes.AM.ToString(); break;
                case (6): countryCode = CatalogConstants.CountryCodes.AU.ToString(); break;
                case (5): countryCode = CatalogConstants.CountryCodes.AT.ToString(); break;
                case (7): countryCode = CatalogConstants.CountryCodes.AZ.ToString(); break;
                case (10): countryCode = CatalogConstants.CountryCodes.BH.ToString(); break;
                case (14): countryCode = CatalogConstants.CountryCodes.BY.ToString(); break;
                case (8): countryCode = CatalogConstants.CountryCodes.BE.ToString(); break;
                case (15): countryCode = CatalogConstants.CountryCodes.BZ.ToString(); break;
                case (12): countryCode = CatalogConstants.CountryCodes.BO.ToString(); break;
                case (13): countryCode = CatalogConstants.CountryCodes.BR.ToString(); break;
                case (11): countryCode = CatalogConstants.CountryCodes.BN.ToString(); break;
                case (9): countryCode = CatalogConstants.CountryCodes.BG.ToString(); break;
                case (16): countryCode = CatalogConstants.CountryCodes.CA.ToString(); break;
                case (19): countryCode = CatalogConstants.CountryCodes.CL.ToString(); break;
                case (20): countryCode = CatalogConstants.CountryCodes.CN.ToString(); break;
                case (21): countryCode = CatalogConstants.CountryCodes.CO.ToString(); break;
                case (22): countryCode = CatalogConstants.CountryCodes.CR.ToString(); break;
                case (41): countryCode = CatalogConstants.CountryCodes.HR.ToString(); break;
                case (23): countryCode = CatalogConstants.CountryCodes.CZ.ToString(); break;
                case (25): countryCode = CatalogConstants.CountryCodes.DK.ToString(); break;
                case (26): countryCode = CatalogConstants.CountryCodes.DO.ToString(); break;
                case (28): countryCode = CatalogConstants.CountryCodes.EC.ToString(); break;
                case (30): countryCode = CatalogConstants.CountryCodes.EG.ToString(); break;
                case (95): countryCode = CatalogConstants.CountryCodes.SV.ToString(); break;
                case (29): countryCode = CatalogConstants.CountryCodes.EE.ToString(); break;
                case (33): countryCode = CatalogConstants.CountryCodes.FO.ToString(); break;
                case (32): countryCode = CatalogConstants.CountryCodes.FI.ToString(); break;
                case (34): countryCode = CatalogConstants.CountryCodes.FR.ToString(); break;
                case (36): countryCode = CatalogConstants.CountryCodes.GE.ToString(); break;
                case (24): countryCode = CatalogConstants.CountryCodes.DE.ToString(); break;
                case (37): countryCode = CatalogConstants.CountryCodes.GR.ToString(); break;
                case (38): countryCode = CatalogConstants.CountryCodes.GT.ToString(); break;
                case (40): countryCode = CatalogConstants.CountryCodes.HN.ToString(); break;
                case (39): countryCode = CatalogConstants.CountryCodes.HK.ToString(); break;
                case (42): countryCode = CatalogConstants.CountryCodes.HU.ToString(); break;
                case (49): countryCode = CatalogConstants.CountryCodes.IS.ToString(); break;
                case (46): countryCode = CatalogConstants.CountryCodes.IN.ToString(); break;
                case (43): countryCode = CatalogConstants.CountryCodes.ID.ToString(); break;
                case (48): countryCode = CatalogConstants.CountryCodes.IR.ToString(); break;
                case (47): countryCode = CatalogConstants.CountryCodes.IQ.ToString(); break;
                case (44): countryCode = CatalogConstants.CountryCodes.IE.ToString(); break;
                case (45): countryCode = CatalogConstants.CountryCodes.IL.ToString(); break;
                case (50): countryCode = CatalogConstants.CountryCodes.IT.ToString(); break;
                case (51): countryCode = CatalogConstants.CountryCodes.JM.ToString(); break;
                case (53): countryCode = CatalogConstants.CountryCodes.JP.ToString(); break;
                case (52): countryCode = CatalogConstants.CountryCodes.JO.ToString(); break;
                case (58): countryCode = CatalogConstants.CountryCodes.KZ.ToString(); break;
                case (54): countryCode = CatalogConstants.CountryCodes.KE.ToString(); break;
                case (56): countryCode = CatalogConstants.CountryCodes.KR.ToString(); break;
                case (57): countryCode = CatalogConstants.CountryCodes.KW.ToString(); break;
                case (55): countryCode = CatalogConstants.CountryCodes.KG.ToString(); break;
                case (63): countryCode = CatalogConstants.CountryCodes.LV.ToString(); break;
                case (59): countryCode = CatalogConstants.CountryCodes.LB.ToString(); break;
                case (64): countryCode = CatalogConstants.CountryCodes.LY.ToString(); break;
                case (60): countryCode = CatalogConstants.CountryCodes.LI.ToString(); break;
                case (61): countryCode = CatalogConstants.CountryCodes.LT.ToString(); break;
                case (62): countryCode = CatalogConstants.CountryCodes.LU.ToString(); break;
                case (69): countryCode = CatalogConstants.CountryCodes.MO.ToString(); break;
                case (67): countryCode = CatalogConstants.CountryCodes.MK.ToString(); break;
                case (72): countryCode = CatalogConstants.CountryCodes.MY.ToString(); break;
                case (70): countryCode = CatalogConstants.CountryCodes.MV.ToString(); break;
                case (71): countryCode = CatalogConstants.CountryCodes.MX.ToString(); break;
                case (66): countryCode = CatalogConstants.CountryCodes.MC.ToString(); break;
                case (68): countryCode = CatalogConstants.CountryCodes.MN.ToString(); break;
                case (65): countryCode = CatalogConstants.CountryCodes.MA.ToString(); break;
                case (74): countryCode = CatalogConstants.CountryCodes.NL.ToString(); break;
                case (76): countryCode = CatalogConstants.CountryCodes.NZ.ToString(); break;
                case (73): countryCode = CatalogConstants.CountryCodes.NI.ToString(); break;
                case (75): countryCode = CatalogConstants.CountryCodes.NO.ToString(); break;
                case (77): countryCode = CatalogConstants.CountryCodes.OM.ToString(); break;
                case (81): countryCode = CatalogConstants.CountryCodes.PK.ToString(); break;
                case (78): countryCode = CatalogConstants.CountryCodes.PA.ToString(); break;
                case (85): countryCode = CatalogConstants.CountryCodes.PY.ToString(); break;
                case (79): countryCode = CatalogConstants.CountryCodes.PE.ToString(); break;
                case (80): countryCode = CatalogConstants.CountryCodes.PH.ToString(); break;
                case (82): countryCode = CatalogConstants.CountryCodes.PL.ToString(); break;
                case (84): countryCode = CatalogConstants.CountryCodes.PT.ToString(); break;
                case (83): countryCode = CatalogConstants.CountryCodes.PR.ToString(); break;
                case (86): countryCode = CatalogConstants.CountryCodes.QA.ToString(); break;
                case (87): countryCode = CatalogConstants.CountryCodes.RO.ToString(); break;
                case (88): countryCode = CatalogConstants.CountryCodes.RU.ToString(); break;
                case (89): countryCode = CatalogConstants.CountryCodes.SA.ToString(); break;
                case (91): countryCode = CatalogConstants.CountryCodes.SG.ToString(); break;
                case (93): countryCode = CatalogConstants.CountryCodes.SK.ToString(); break;
                case (92): countryCode = CatalogConstants.CountryCodes.SI.ToString(); break;
                case (109): countryCode = CatalogConstants.CountryCodes.ZA.ToString(); break;
                case (31): countryCode = CatalogConstants.CountryCodes.ES.ToString(); break;
                case (90): countryCode = CatalogConstants.CountryCodes.SE.ToString(); break;
                case (18): countryCode = CatalogConstants.CountryCodes.CH.ToString(); break;
                case (96): countryCode = CatalogConstants.CountryCodes.SY.ToString(); break;
                case (101): countryCode = CatalogConstants.CountryCodes.TW.ToString(); break;
                case (97): countryCode = CatalogConstants.CountryCodes.TH.ToString(); break;
                case (100): countryCode = CatalogConstants.CountryCodes.TT.ToString(); break;
                case (98): countryCode = CatalogConstants.CountryCodes.TN.ToString(); break;
                case (99): countryCode = CatalogConstants.CountryCodes.TR.ToString(); break;
                case (102): countryCode = CatalogConstants.CountryCodes.UA.ToString(); break;
                case (1): countryCode = CatalogConstants.CountryCodes.AE.ToString(); break;
                case (35): countryCode = CatalogConstants.CountryCodes.GB.ToString(); break;
                case (103): countryCode = CatalogConstants.CountryCodes.US.ToString(); break;
                case (104): countryCode = CatalogConstants.CountryCodes.UY.ToString(); break;
                case (105): countryCode = CatalogConstants.CountryCodes.UZ.ToString(); break;
                case (106): countryCode = CatalogConstants.CountryCodes.VE.ToString(); break;
                case (107): countryCode = CatalogConstants.CountryCodes.VN.ToString(); break;
                case (108): countryCode = CatalogConstants.CountryCodes.YE.ToString(); break;
                case (110): countryCode = CatalogConstants.CountryCodes.ZW.ToString(); break;
                  
            }
            if (countryCode == string.Empty)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "No mapping countryCode present for UODB CountryId : {0}", countryId), "CountryId");
            }
            return countryCode;
        }

        private static int GetLicenseTypeId(int gameContentMediaType, LicenseLevel licenseLevel)
        {
            // For Avatar Marketplace hardcode the License Type to 12 and don't allow other offer types to use this value also
            if (gameContentMediaType == CatalogConstants.MediaTypeAvatarItem)
                return CatalogConstants.RestrictedToUserOnlyOffline;

            if (licenseLevel == LicenseLevel.RestrictedToMachine)
                return CatalogConstants.RestrictedToMachine;
            if (licenseLevel == LicenseLevel.RestrictedToUserAndMachine)
                return CatalogConstants.RestrictedToUserAndMachine;
            if (licenseLevel == LicenseLevel.Unrestricted)
                return CatalogConstants.Unrestricted;
            throw new ArgumentException("For gameContentMediaType: " + gameContentMediaType + "Invalid LicenseLevel: " + licenseLevel);
        }

        private static int GetUserTypeId(LiveTier liveTier)
        {
            if (liveTier == LiveTier.Gold)
                return CatalogConstants.UserTypeGold;
            if (liveTier == LiveTier.FamilyGold)
                return CatalogConstants.UserTypeFamilyGold;
            return CatalogConstants.UserTypeSilver;
        }

        private static int GetVisibilityLevelId(OfferEnumerationType offerEnumerationType, int paymentTypeId)
        {
            // bug 4725
            // Prop Token Offer Instances with VisibilityLevel = NeverEnumerate
            if (paymentTypeId == CatalogConstants.PaymentTypeToken)
                return CatalogConstants.VisibilityLevelNeverEnumerate;

            if (offerEnumerationType == OfferEnumerationType.AlwaysEnumerateExceptInPartnerNetDash)
                return CatalogConstants.VisibilityLevelNoEnumerateInPartnernet;
            if (offerEnumerationType == OfferEnumerationType.NeverEnumerate)
                return CatalogConstants.VisibilityLevelNeverEnumerate;

            return CatalogConstants.VisibilityLevelDefault;
        }

        private static int GetGameContentMediaType(ContentOfferType offerType, ulong offerId, uint titleId, ushort publisher, bool isConsumables)
        {
            switch (offerType)
            {
                case ContentOfferType.GameContent:
                    {
                        if ((titleId == XNALauncher)
                            || GameIdMapping.IsXNAPublisher(publisher))
                        {
                            if ((offerId & 0x000000000000000F) == 0)
                                return CatalogConstants.MediaType360ArcadeDemo;
                            return CatalogConstants.MediaTypeCommunityGame;
                        }

                        // Identify Xbox Originals if they use the Fusion TitleId
                        if (titleId == FusionTitleId)
                            return CatalogConstants.MediaTypeXbox1Game;

                        if (isConsumables)
                            return CatalogConstants.MediaType360ConsumableContent;
                        
                        return CatalogConstants.MediaType360InGameContent;
                    }

                case ContentOfferType.GameDemo:
                    return CatalogConstants.MediaType360GameDemo;

                case ContentOfferType.GameTrailer:
                    return CatalogConstants.MediaTypeGameTrailer;

                case ContentOfferType.Theme:
                    return CatalogConstants.MediaType360Theme;

                case ContentOfferType.FullGame:
                    return CatalogConstants.MediaType360Game;

                case ContentOfferType.Tile:
                    return CatalogConstants.MediaTypeGamerTile;

                case ContentOfferType.Arcade:
                    // the (the least-significant DWORD) of the offer ID is the key.
                    // 00000000 is the trial, and 00000001 is the full. This is ALWAYS the case.
                    if ((offerId & 0x000000000000000F) == 0)
                        return CatalogConstants.MediaType360ArcadeDemo;
                    return CatalogConstants.MediaType360ArcadeGame;

                case ContentOfferType.Video:
                    return CatalogConstants.MediaTypeGameVideo;

                case ContentOfferType.AvatarItem:
                    return CatalogConstants.MediaTypeAvatarItem;
            }

            throw new ArgumentException("Invalid contentOfferType: " + offerType);
        }

        private static int GetGameContentPackageType(ContentPackageType packageType, int gameContentMediaType)
        {
            switch (packageType)
            {
                case ContentPackageType.Cab:
                    return CatalogConstants.PackageTypeCab;

                case ContentPackageType.SvodUncompressed:
                    return CatalogConstants.PackageTypeSvodUncompressed;

                case ContentPackageType.SvodCompressed:
                    return CatalogConstants.PackageTypeSvodCompressed;

                // Back-Compat case for existing Offers in TitleVault from
                // pre-Spring2009 where only 2 packageTypes were known
                case ContentPackageType.Undefined:
                {
                    if(gameContentMediaType == CatalogConstants.MediaTypeXbox1Game)
                        return CatalogConstants.PackageTypeSvodUncompressed;
                    else
                        return CatalogConstants.PackageTypeCab;
                }
                   
            }

            throw new ArgumentException("Invalid contentPackageType: " + packageType);
        }

        #endregion

        #region Constants

        const uint FusionTitleId = 0xFFFE07D2; // Fusion or Back Compat title for 360
        const uint XNALauncher = 0x584E07D2; // XNA Launcher

        static readonly int MediaContributorSortOrderDefault = 1;

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\tools\ini.cs ===
//
// Iniuration settings
//  
//  Provides global management of config settings.
// 
//  To use:
//
//      Ini.GetSetting("foo"); 
//          - returns the string value of 'foo' as specified
//            in the [global] section of the assembly's ini file, 
//            or empty string if not found.
//
//      Ini.GetSetting("mysection", "foo");
//          - same as above, but gets the setting from the 
//            specified section of the ini file.
//         
//  Ini files:
//      typical windows ini file format:
// 
//          ; this is a comment
//          [global]
//          MyFirstSetting=a value
//
//          [another section]
//          MyOtherSetting=another Value
//  
//      everything to the left of the first "=" is the name,
//      everything to the right is the value.
//
//      Note: all setting names/sections are case insensitive.
//
//  File name:
//      The ini file has the same name as the 
//      assembly this code is compiled, with the extension ".ini"
//
//  Location:
//      The same directory as the assembly is checked first.
//      If not found, the parent directory is checked.
//      If still not found, a warning event is logged, and all
//       calls to GetSetting() return an empty string.
//  
//  

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;

namespace Microsoft.Ems.Tools.LiveContent
{

public class Ini
{
    private Hashtable _configSections = null;
    private bool _bChanged = false;

    #region Constants
    public static readonly string SectionAll = "All";
    public static readonly string PlatformSetting = "Platform";
    public static readonly string ContentIdSetting = "ContentID";
    public static readonly string ContentPackageType = "ContentPackageType";
    public static readonly string PlatformValueGFWL = "0x10";
    public static readonly string InstallSizeSetting = "installsize";
    public static readonly string BaseVersionSetting = "baseversion";
    public static readonly string UpdateVersionSetting = "updateversion";
    public static readonly string AvatarAssetIDSetting = "AvatarAssetID";

    #endregion

    public string GetSetting(string setting)
    {
        return GetSetting("global", setting);
    }
    
    /// <summary>
    ///  Adds, changes or removes a setting.  Pass in a null value
    ///  to remove a setting
    /// </summary>
    /// <param name="section"></param>
    /// <param name="setting"></param>
    /// <param name="value"></param>

    public void SetSetting(string section, string setting, string value)
    {
        if(_configSections == null)
        {
            if(value == null)
                return;

            _configSections = new Hashtable();
        }

        StringDictionary sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if(sectionSettings == null)
        {
            if(value == null)
                return;

            sectionSettings = new StringDictionary();
            _configSections[section.ToUpper()] = sectionSettings;
        }

        if(value != null)
            sectionSettings[setting.ToUpper()] = value;
        else
            sectionSettings.Remove(setting.ToUpper());

        _bChanged = true;
    }

    public void Save(string IniPath)
    {
        StreamWriter writer = File.CreateText(IniPath);

        try
        {
            foreach(DictionaryEntry section in _configSections)
            {
                writer.WriteLine("[" + section.Key.ToString().ToUpper() + "]");

                StringDictionary sd = (StringDictionary)section.Value;

                foreach(DictionaryEntry setting in sd)
                {
                    writer.WriteLine(setting.Key.ToString().ToUpper() + "=" + setting.Value.ToString());
                }

                writer.WriteLine("");
            }
        }
        finally
        {
            writer.Close();
        }

        _bChanged = false;
    }

    public string GetSetting(string section, string setting)
    {
        StringDictionary sectionSettings;
        string val = "";
        
        if (_configSections == null)
        {
            goto Cleanup;
        }        
        
        sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if (sectionSettings == null)
        {
            goto Cleanup;
        }
        
        val = sectionSettings[setting.ToUpper()];
        if(val == null)
            val = "";
        
Cleanup:        
        return val;
    }




    public Ini(string iniPath)
    {
        Init(iniPath, Encoding.Default);
    }

    public Ini(string iniPath, Encoding fileEncoding)
    {
        Init(iniPath, fileEncoding);
    }

    public Ini()
    {
        Init(null, Encoding.Default);
    }

    private void Init(string iniPath, Encoding fileEncoding)
    {
        StreamReader reader = null;
        string line;
        Hashtable configSections = null;
        string currentSection = "global";
        string name;
        string val;
        int n;
        
        
        if(iniPath != null)
        {
            try
            {
                if (!File.Exists(iniPath))
                {
                    return;
                }

                if (fileEncoding == Encoding.Default)
                {
                    reader = File.OpenText(iniPath);
                }
                else
                {
                    reader = new StreamReader(iniPath, fileEncoding);
                }
                
                for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                {
                    line = line.Trim();
                
                    // emtpy line
                    if (line == "")
                        continue;
                    
                    // comment
                    if (line.StartsWith(";"))
                        continue;
                
                    // new section    
                    if (line.StartsWith("["))
                    {
                    
                        n = line.IndexOf(']');
                        if (n <= 1)
                        {
                            return;
                        }
                    
                        currentSection = line.Substring(1, n-1).ToUpper();
                        continue;
                    }
                
                    line = line.Trim();
                
                    // continuation char
                
                    while (line.EndsWith("\\"))
                    {
                        // REVIEW: is this correct?
                        line = line.Substring(0, line.Length-1);
                    
                        string line2 = reader.ReadLine();
                        if (line2 == null)
                        {
                            return;
                        }
                    
                        line += line2.TrimEnd(null);
                    }
                
                
                    // name/value pair
                    n = line.IndexOf("=");
                    if (n <= 0)
                    {
                        return;
                    }
                
                    name = line.Substring(0, n).Trim().ToUpper();
                
                    if (n < line.Length-1)
                    {
                        val = line.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        val = "";
                    }
                
                    if (configSections == null)
                    {
                        configSections = new Hashtable();
                    }
                    if (configSections[currentSection] == null)
                    {
                        configSections[currentSection] = new StringDictionary();
                    }
                
                    ((StringDictionary)(configSections[currentSection]))[name] = val;
                
                }
                _configSections = configSections;
            }
            finally
            {
                if(null != reader)
                {
                    reader.Close();
                }
            }
        }
    }
    
    public StringDictionary GetSection(string section)
    {
        return (_configSections == null ? null : (StringDictionary)_configSections[section.ToUpper()]);
    }

    public bool Changed
    {
        get
        {
            return _bChanged;
        }
    }

    public Hashtable Sections
    {
        get
        {
            return _configSections;
        }
    }
}

internal class IniUtil
{
    public static string[,] GetParams(string str)
    {
        string[] pairs = str.Split( new char[] { ';' } );
        string[] param;
        string[,] paramList = new string[pairs.Length, 2];
        char[] pairDelim = new char[] { '=' };

        for (int n = 0; n < pairs.Length; n++)
        {
            param = pairs[n].Split( pairDelim );

            if (param.Length != 2)
            {
                return null;
            }

            paramList[n,0] = param[0].ToUpper();
            paramList[n,1] = param[1];
        }

        return paramList;

    }
    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\tools\Output.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Collections;

namespace Microsoft.Ems.Tools.LiveContent
{
	public enum LoggingLevel
	{
		Error = 0,            
		Normal = 1,
		Verbose = 2
	};

	public enum LogType
	{
		Error = 0,
		Information = 1,
		Debug = 2
	} 

	/// <summary>
	/// Class that handles output to: {eventlog, log file, console, SQL?}
	/// 
	/// Upon creation you can set the verbosity.
	/// 
	/// Error	:= outputs only errors
	/// LoggingLevel.Verbose := outputs errors, LogType.Information, and LoggingLevel.Verbose to the logging medium
	/// LoggingLevel.Normal	:= outputs errors, and LogType.Information 	
	/// 
	/// I made this class non static so that in the future we could have multiple 
	/// instances of this class.  (example: for a tools framework).
	/// </summary>
	public class Output
	{

		private ArrayList _loggers = new ArrayList();	  

		#region Constructors
       
		/// <summary>
		/// Default logging.
		/// 
		/// Console:  Normal
		/// Log File: none
		/// EventLog: Error
		/// </summary>
		public Output(string source)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error));
		}

		/// <summary>
		/// Default logging.
		/// like above
		/// </summary>
		public Output(string source, long errorID, long successID)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error, errorID, successID));
		}

		/// <summary>
		/// Default logging.
		/// 
		/// Console:  LoggingLevel.Normal
		/// Log File: LoggingLevel.Verbose
		/// EventLog: Error
		/// </summary>
		public Output(string source, string filePath)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new FileLogger(source, LoggingLevel.Verbose, filePath));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error));
		}

		/// <summary>
		/// Default logging.
		/// like above
		/// </summary>
		public Output(string source, string filePath, long errorID, long successID)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new FileLogger(source, LoggingLevel.Verbose, filePath));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error, errorID, successID));
		}
		#endregion


		#region PropertyLevels
		public LoggingLevel ConsoleLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is ConsoleLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is ConsoleLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}

		public LoggingLevel EventLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is EventLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is EventLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}

		public LoggingLevel FileLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is FileLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is FileLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}
		#endregion

		public void Log(string str, LogType type)
		{
			foreach(Logger logger in _loggers)
			{
				if (logger.shouldLog(type))
					logger.Log(str, type);
			}
		}

		/// <summary>
		/// force log to everywhere
		/// </summary>
		/// <param name="str"></param>
		/// <param name="type"></param>
		public void LogAll(string str, LogType type)
		{
			foreach(Logger logger in _loggers)
			{
				logger.Log(str, type);
			}
		}
	}

	/// <summary>
	/// Abstract Logger class.  Any Logger must inherit this.
	/// 
	/// Key function is bool shouldLog(type).
	/// </summary>
	internal abstract class Logger
	{
		protected string _source = "not set";
		protected LoggingLevel _level;

		public Logger(string source, LoggingLevel level)
		{
			_source = source;
			_level = level;
		}

		public void Log(string str, LogType type)
		{
			if(shouldLog(type))
				internalLog(str, type);
		}

		public LoggingLevel Level
		{
			get
			{
				return _level;
			}
			set
			{
				_level = value;
			}
		}

		protected abstract void internalLog(string str, LogType type);

		public virtual bool shouldLog(LogType type)
		{
			if(_level == LoggingLevel.Verbose) return true;

			if(_level == LoggingLevel.Normal && type == LogType.Debug) return false;

			return true; // this is an error
		}


		protected string prependType(string str, LogType type)
		{
			string temp = "";

			if(type == LogType.Error)
				temp = "Error: ";
			else if(type == LogType.Information)
				temp = "Information: ";
			else if(type == LogType.Debug)
				temp = "Debug: ";

			return temp + str;
		}
	}

	internal class ConsoleLogger : Logger
	{
		public ConsoleLogger(string source, LoggingLevel level) : base(source, level)
		{
		}

		protected override void internalLog(string str, LogType type)
		{
			System.Console.WriteLine(prependType(str, type));
		}
	}

	internal class FileLogger : Logger
	{
		private StreamWriter _sw;
		private string _path;

		public FileLogger(string source, LoggingLevel level, string path) : base(source, level) 
		{
			_source = source;
			_level = level;
			_path = path;
	
			_sw = File.CreateText(_path);
			_sw.WriteLine(Environment.CommandLine);
		}
        
		protected override void internalLog(string str, LogType type)
		{
			_sw.WriteLine(prependType(str, type));
		}
	}


	internal class EventLogger : Logger
	{
		private EventLog _eventlog;
		private long _successId = 0x8000C418L; // 0x8000C418L TODO! set a default TOOL success
		private long _errorId = 0x8000C419L;   // 0x8000C419L TODO! set a default TOOL fail

		public EventLogger(string source, LoggingLevel level) : base(source, level)
		{
			_eventlog = new EventLog();
			_eventlog.Source = _source; 
		}

		public EventLogger(string source, LoggingLevel level, long errorId, long successId) : base(source, level)
		{			
			_errorId = errorId;
			_successId = successId;		
			_eventlog = new EventLog();
			_eventlog.Source = _source; 
		}

		protected override void internalLog(string str, LogType type)
		{
			if(type == LogType.Debug) return;

			int id = 0;
			EventLogEntryType t = EventLogEntryType.Error;
			if (type == LogType.Error)
			{
				unchecked
				{
					id = (int)(_errorId & 65535);
				}
			}
			else
			{
				unchecked
				{
					id = (int)(_successId & 65535);
				}
				t = EventLogEntryType.Information;
			}

			_eventlog.WriteEntry(str, t, id);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\liveoffer.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------ 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offerutil;
using xonline.common.xboxofferutil;

namespace Microsoft.Ems.Tools.LiveOfferTool
{
    /// <summary>
    /// Note: class name "LiveOffer" is already in use in common\offerutil\LiveOfferSchema.cs
    ///       Therefore, to avoid naming confusion we'll use an alternate name here
    /// </summary>
    public static class LiveOfferTool
    {
        static Hashtable _offersToExpire = null;
        static DateTime _offerExpiration;

        /// <summary>flag for checking XRL before propping offer</summary>
        static bool _checkXrl = true;
        /// <summary>timeout interval for content XRL checking</summary>
        static int _timeoutSeconds = 60;
        /// <summary>index of the next content location to verify</summary>
        static int _nextContentIndex = 0;
        /// <summary>collection of content locations to check</summary>
        static List<ContentLocation> _contentList = new List<ContentLocation>();
        /// <summary>maximum number of content verification threads</summary>
        static int _maxThreads = 4;
        /// <summary>list of content verification threads</summary>
        static List<Thread> _contentThreadList = new List<Thread>();
        /// <summary>set to true when at least one content XRL has been verified</summary>
        static bool _contentVerified = false;

        static string[] namedArgumentList = new string[]
            {
                "?",
                "action",
                "file",
                "noreload",
                "notransaction",
                "overwriteDMPSettings",
                "sleep",
                "titleid",
                "verbose",
                "expiration",
                "skipxrl",
                "timeout"
            };

        static int PropLiveOffer(string file, string titleid, OfferManager.TargetDB eTargetDB)
        {
            int count = 0;
            if (titleid == null)
            {
                Console.WriteLine(string.Format("Required /titleid: parameter was not found"));
                return -1;
            }

            XmlSerializer serializer = new XmlSerializer(typeof(LiveOffer));
            XmlReader validatingReader = OfferUtil.CreateValidatingReader(file);
            LiveOffer lo = (LiveOffer)serializer.Deserialize(validatingReader);

            // Validate that the file titleid matches the command line titleid
            // File titleid is located at /LiveOffer/contentOffer/offerBasicInfo/primaryTitleID
            //
            //  promotionalPointsOffer - promotionalPointsOfferCollection[0].offerBasicInfo
            //  pointsBundleOffer - pointsBundleOfferCollection[0].offerBasicInfo
            //  gamertagChangeOffer - gamertagChangeOfferCollection[0].offerBasicInfo
            //  gameplayOffer - gameplayOfferCollection[0].offerBasicInfo
            //
            // titleCollection[0].titleID
            // liveSubscriptionCollection[0].subscriptionBasicInfo.titleIDCollection
            // gameSubscriptionCollection[0].subscriptionBasicInfo.titleIDCollection
            //
            //  File titleid typical format is 0xffff0055

            foreach (ContentOffer co in lo.contentOfferCollection)
            {
                if (co.offerBasicInfo != null && co.offerBasicInfo.primaryTitleID != null)
                {
                    if (!CompareTitleIDs(co.offerBasicInfo.primaryTitleID, titleid)) return -1;
                }

                // validate ratings
                ValidateContentOfferRatings(co);
            }
            foreach (PromotionalPointsOffer ppo in lo.promotionalPointsOfferCollection)
            {
                if (ppo.offerBasicInfo != null && ppo.offerBasicInfo.primaryTitleID != null)
                {
                    if (!CompareTitleIDs(ppo.offerBasicInfo.primaryTitleID, titleid)) return -1;
                }
            }
            foreach (PointsBundleOffer pbo in lo.pointsBundleOfferCollection)
            {
                if (pbo.offerBasicInfo != null && pbo.offerBasicInfo.primaryTitleID != null)
                {
                    if (!CompareTitleIDs(pbo.offerBasicInfo.primaryTitleID, titleid)) return -1;
                }
            }
            foreach (GamertagChangeOffer gco in lo.gamertagChangeOfferCollection)
            {
                if (gco.offerBasicInfo != null && gco.offerBasicInfo.primaryTitleID != null)
                {
                    if (!CompareTitleIDs(gco.offerBasicInfo.primaryTitleID, titleid)) return -1;
                }
            }
            foreach (GameplayOffer go in lo.gameplayOfferCollection)
            {
                if (go.offerBasicInfo != null && go.offerBasicInfo.primaryTitleID != null)
                {
                    if (!CompareTitleIDs(go.offerBasicInfo.primaryTitleID, titleid)) return -1;
                }
            }
            foreach (Title t in lo.titleCollection)
            {
                if (t.titleID != null)
                {
                    if (!CompareTitleIDs(t.titleID, titleid)) return -1;
                }
            }

            foreach (LiveSubscription ls in lo.liveSubscriptionCollection)
            {
                if (ls.subscriptionBasicInfo != null && ls.subscriptionBasicInfo.titleIDCollection.Count > 0)
                {
                    if (!ContainsTitleID(ls.subscriptionBasicInfo.titleIDCollection, titleid)) return -1;
                }
            }
            foreach (GameSubscription gs in lo.gameSubscriptionCollection)
            {
                if (gs.subscriptionBasicInfo != null && gs.subscriptionBasicInfo.titleIDCollection.Count > 0)
                {
                    if (!ContainsTitleID(gs.subscriptionBasicInfo.titleIDCollection, titleid)) return -1;
                }
            }
            foreach (PcAccountCreationOffer paco in lo.pcAccountCreationOfferCollection)
            {
                if (paco.titleID != null)
                {
                    if (!CompareTitleIDs(paco.titleID, titleid)) return -1;
                }
            }

            Console.WriteLine("XML parsed successfully");

            string mode = Config.GetSetting(Setting.liveoffer_ContentCheckMode).ToLower();
            if (!mode.Equals("off") && _checkXrl)
            {
                // check content availability
                Console.WriteLine("Content Check Mode: " + mode);

                // Note: The verify check treats all ContentLocations equally. Technically this 
                // can cause an issue when multiple Content nodes are present in the OfferFile,
                // but the POR since 2005 is that OfferFiles never have more than one Content node.
                foreach (Content c in lo.contentCollection)
                {
                    Console.WriteLine("Verifying content XRLs for {0}...", c.friendlyName);
                    foreach (ContentLocation cl in c.contentLocationCollection)
                    {
                        _contentList.Add(cl);
                    }
                }

                // spawn threads and wait for verification of any content XRL
                for (int i = 0; i < _contentList.Count && i < _maxThreads; ++i)
                {
                    Thread t = new Thread(new ThreadStart(VerifyContentXrl));
                    _contentThreadList.Add(t);
                }
                foreach (Thread t in _contentThreadList)
                {
                    t.Start();
                }
                foreach (Thread t in _contentThreadList)
                {
                    t.Join();
                }
                if (!_contentVerified)
                {
                    return -1;
                }
            }

            // Change the working directory to the offer file location
            string prevWorkDir = Environment.CurrentDirectory;
            try
            {
                Environment.CurrentDirectory = Path.GetDirectoryName(Path.GetFullPath(file));

                OfferManager.Target = eTargetDB;

                if (OfferManager.ValidateImageSizes(lo))
                {
                    count = OfferManager.PropLiveOffer(lo);

                    validatingReader.Close();
                    MoveFilesToTitleVault(file, titleid, count);
                }
                else
                {
                    validatingReader.Close();
                    Console.WriteLine("LiveOffer.PropLiveOffer() error: aborting, offer will not be propped; one or more images were not the correct size or format.  See errors above.");
                    return -1;
                }
            }
            finally
            {
                // Restore previous working directory
                Environment.CurrentDirectory = prevWorkDir;
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("done");

            return 0;
        }

        /// <summary>
        /// Validates that the ratings for a ContentOffer element are valid.
        /// Only one rating value per rating system is allowed.
        /// </summary>
        /// <param name="co"></param>
        static bool ValidateContentOfferRatings(ContentOffer co)
        {
            if ((co.__ratingCollection != null) && (co.__ratingCollection.Count > 0))
            {
                // If there are ratings, there should not be any inheritance
                if (co.__inheritRatingSpecified && co.__inheritRating)
                {
                    throw new ArgumentException(string.Format("Error - offer {0} inherits ratings and has ratings values which are not allowed together.", co.offerBasicInfo.offerID));
                }

                Dictionary<uint, Rating> dictionary = new Dictionary<uint, Rating>(co.__ratingCollection.Count);

                foreach (Rating r in co.__ratingCollection)
                {
                    try
                    {
                        dictionary.Add(r.ratingSystemId, r);
                    }
                    catch (ArgumentException e)
                    {
                        throw new ArgumentException(string.Format("Error - offer {0} has multiple rating values for ratingSystemId {1} which is not allowed.", co.offerBasicInfo.offerID, r.ratingSystemId), e);
                    }
                }
            }
            return true;
        }


        /// <summary>
        /// Gets the next content XRL for an HTTP thread to verify.
        /// </summary>
        /// <returns>content XRL to check</returns>
        static string GetNextXrl()
        {
            lock (_contentList)
            {
                if (_nextContentIndex < _contentList.Count)
                {
                    return _contentList[_nextContentIndex++].xrl;
                }
                else
                {
                    return null;
                }
            }
        }


        /// <summary>
        /// Method used by HTTP request threads to check content XRLs.
        /// </summary>
        static void VerifyContentXrl()
        {
            // by default, content download servers have external-facing addresses that require proxy access
            string mode = Config.GetSetting(Setting.liveoffer_ContentCheckMode).ToLower();
            bool externalProxy = true, errorReported = false;
            WebProxy proxy = null;
            if (mode.Equals("external"))
            {
                externalProxy = true;
                proxy = new WebProxy(Config.GetSetting(Setting.billing_proxy), true);
            }
            else if (mode.Equals("internal"))
            {
                externalProxy = false;
            }

            for (string xrl = GetNextXrl(); xrl != null; xrl = GetNextXrl())
            {
                HttpWebResponse httpRep = null;
                errorReported = false;

                try
                {
                    // Post
                    HttpWebRequest httpReq = (HttpWebRequest)WebRequest.Create(xrl);
                    if (externalProxy)
                    {
                        httpReq.Proxy = proxy;
                    }
                    httpReq.Method = "HEAD";
                    httpReq.Timeout = _timeoutSeconds * 1000;

                    // Get response
                    httpRep = (HttpWebResponse)httpReq.GetResponse();

                    Console.WriteLine("Content exists at XRL: {0}", xrl);

                    // upon success, notify caller, abort other threads, and exit
                    _contentVerified = true;
                    foreach (Thread t in _contentThreadList)
                    {
                        if (t != Thread.CurrentThread)
                        {
                            t.Abort();
                        }
                    }
                    return;
                }
                catch (WebException we)
                {
                    Console.WriteLine("Failed XRL check: {0}, status={1}", xrl, we.Status);
                    if (we.Status == WebExceptionStatus.ProtocolError)
                    {
                        Console.WriteLine("Status Code: {0}", ((HttpWebResponse)we.Response).StatusCode);
                        Console.WriteLine("Status Description: {0}", ((HttpWebResponse)we.Response).StatusDescription);
                    }
                    errorReported = true;
                }
                catch (ThreadAbortException)
                {
                    Console.WriteLine("Aborting XRL check: {0}", xrl);
                    errorReported = true;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Failed XRL check: {0}, message={1}", xrl, e.Message);
                    errorReported = true;
                }
                finally
                {
                    if (!_contentVerified && !errorReported)
                    {
                        Console.WriteLine("Failed XRL check: {0}, no error details available", xrl);
                    }

                    if (httpRep != null)
                    {
                        httpRep.Close();
                    }
                }
            }
        }


        /// <summary>
        /// Used by PropLiveOffer to compare a file Title ID with one passed in on the command line
        /// </summary>
        /// <param name="fileTitleID">Title ID from an offer file</param>
        /// <param name="titleid">Title ID from the command line</param>
        /// <returns>False if the Title IDs are specified and do not match; true otherwise.</returns>
        static bool CompareTitleIDs(string fileTitleID, string titleid)
        {
            if (!String.Equals(RemoveHexPrefix(fileTitleID), titleid, StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine("LiveOffer error (aborting): /titleid " + titleid + " parameter does not match the titleid in the offer file, which was " + fileTitleID);
                return false;
            }
            return true;
        }

        static bool ContainsTitleID(ArrayList fileTitleIDs, string titleID)
        {
            foreach (string fileTitleID in fileTitleIDs)
            {
                if (String.Equals(RemoveHexPrefix(fileTitleID), titleID, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }

            Console.Write("LiveOffer error (aborting): /titleid " + titleID + " parameter does not match any of the title IDs in the offer file, which were ");
            foreach (string fileTitleID in fileTitleIDs)
            {
                Console.Write(" " + fileTitleID);
            }
            Console.WriteLine();
            return false;
        }

        static string RemoveHexPrefix(string value)
        {
            return (value.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
                ? value.Substring(2)
                : value;
        }

        static int ValidateOfferFile(string file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(LiveOffer));
            XmlReader validatingReader = OfferUtil.CreateValidatingReader(file);
            LiveOffer lo = (LiveOffer)serializer.Deserialize(validatingReader);

            Console.WriteLine("XML parsed successfully");

            return 0;
        }

        static int ValidateXboxOfferFile(string file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));
            XmlReader validatingReader = XboxOfferUtil.CreateValidatingReader(file);
            XboxOffers lo = (XboxOffers)serializer.Deserialize(validatingReader);

            Console.WriteLine("XML parsed successfully");

            return 0;
        }

        static bool OfferNeedsExpiration(ulong offerId)
        {
            return (_offersToExpire == null || _offersToExpire.ContainsKey(offerId));
        }

        static DateTime GetExpirationForOffer(ulong offerId)
        {
            if (_offersToExpire == null)
                return _offerExpiration;
            else if (_offersToExpire.ContainsKey(offerId))
                return (DateTime)_offersToExpire[offerId];
            else
                return DateTime.MaxValue;
        }

        static void OfferExpired(ulong offerId)
        {
            if (_offersToExpire != null)
            {
                _offersToExpire.Remove(offerId);
            }
        }

        static void ExpireOffer(OfferBasicInfo o, ref bool offerChanged)
        {
            ulong offerId = OfferManager.ParseUlong(o.offerID);

            if (OfferNeedsExpiration(offerId))
            {
                DateTime offerExpirationDateTime = GetExpirationForOffer(offerId);
                OfferManager.ExpireOfferBasicInfo(o, offerExpirationDateTime);
                OfferExpired(offerId);
                Console.WriteLine(string.Format("Offer {0} set to expire on {1}.", offerId.ToString("X"), offerExpirationDateTime.ToString("MM/dd/yyyy HH:mm:ss")));
                offerChanged = true;
            }
        }

        static void ExpireOfferFromUODBandCatalogDB(Dictionary<string, Content> contentDictionary, ContentOffer contentOffer, OfferBasicInfo o, ref bool offerChanged)
        {
            ulong offerId = OfferManager.ParseUlong(o.offerID);
            DateTime offerExpirationDateTime = GetExpirationForOffer(offerId);

            if (OfferNeedsExpiration(offerId))
            {
                //epires offer in UODB
                OfferManager.ExpireOfferBasicInfo(o, offerExpirationDateTime);

                //expire offer in CatalogDb
                OfferManager.ExpireOfferFromCatalogDB(contentDictionary, contentOffer, offerExpirationDateTime);

                OfferExpired(offerId);
                Console.WriteLine(string.Format("Offer {0} set to expire on {1}.", offerId.ToString("X"), offerExpirationDateTime.ToString("MM/dd/yyyy HH:mm:ss")));
                offerChanged = true;
            }
        }

        static void ExpireSubscription(SubscriptionBasicInfo s, ref bool offerChanged)
        {
            ulong offerId = OfferManager.ParseUlong(s.offerID);

            if (OfferNeedsExpiration(offerId))
            {
                DateTime offerExpirationDateTime = GetExpirationForOffer(offerId);
                OfferManager.ExpireSubscriptionBasicInfo(s, offerExpirationDateTime);
                OfferExpired(offerId);
                Console.WriteLine(string.Format("Subscription {0} set to expire on {1}.", offerId.ToString("X"), offerExpirationDateTime.ToString("MM/dd/yyyy HH:mm:ss")));
                offerChanged = true;
            }
        }

        static int ExpireOffersInFile(string expirationFile, string titleid, OfferManager.TargetDB eTargetDB)
        {
            if (expirationFile == null)
            {
                Console.WriteLine("Required -file: parameter was not found.");
                return -1;
            }

            if (!File.Exists(expirationFile))
            {
                Console.WriteLine(string.Format("The specified file (\"{0}\") does not exist.", expirationFile));
                return -1;
            }

            _offersToExpire = new Hashtable();

            //
            //  Read in all offers from specified file.  Each line in this file
            //  should be in the form <offerid>,<expiration_date>, where <offerid>
            //  is the offer id in hexadecimal, and <expiration_date> is in the
            //  following format:
            //
            //      MM/DD/YY HH:mm:ss
            //

            using (StreamReader expirationFileReader = new StreamReader(expirationFile))
            {

                string expirationLine = expirationFileReader.ReadLine();
                for (int lineNumber = 1; expirationLine != null; ++lineNumber)
                {
                    try
                    {
                        string[] expirationParts = expirationLine.Split(',');
                        if (expirationParts.Length != 2)
                        {
                            Console.WriteLine(string.Format("Line number {0} is invalid, offer id and expiration date expected:\r\n\t\"{1}\"\tProcessing will continue and this line will be ignored.",
                                lineNumber, expirationLine));
                            continue;
                        }

                        ulong offerId;
                        DateTime offerExpirationTime;

                        try
                        {
                            string offerIdPart = RemoveHexPrefix(expirationParts[0]);
                            offerId = UInt64.Parse(offerIdPart, NumberStyles.HexNumber);
                        }
                        catch
                        {
                            Console.WriteLine(string.Format("Line number {0} is invalid.  Offer id must be a valid hexadecimal number:\r\n\t\"{1}\"\tProcessing will continue and this line will be ignored.",
                                lineNumber, expirationParts[0]));
                            continue;
                        }

                        try
                        {
                            offerExpirationTime = DateTime.Parse(expirationParts[1]);
                        }
                        catch
                        {
                            Console.WriteLine(string.Format("Line number {0} is invalid.  Expiration date/time must be in the format \"MM/dd/yyyy HH:mm:ss\":\r\n\t\"{1}\"\tProcessing will continue and this line will be ignored.",
                                lineNumber, expirationParts[1]));
                            continue;
                        }

                        _offersToExpire.Add(offerId, offerExpirationTime);
                    }
                    finally
                    {
                        expirationLine = expirationFileReader.ReadLine();
                    }
                }
            }

            if (_offersToExpire.Count == 0)
            {
                Console.WriteLine(string.Format("No valid expiration entries were found in {0}.  Exiting.", expirationFile));
                return 0;
            }

            Console.WriteLine("Finished reading offer expiration file.");

            int retCode = ExpireOffers(titleid, eTargetDB);
            if (retCode == 0)
            {

                //
                //  Report on any offers in the expiration file that weren't found
                //  in offer files.
                //

                if (_offersToExpire.Count != 0)
                {
                    Console.WriteLine("The following offer ids were specified in the offer expiration file, but were not found in any offer file for the specified title:");

                    foreach (DictionaryEntry de in _offersToExpire)
                    {
                        Console.WriteLine("\t{0}", ((ulong)de.Key).ToString("X"));
                    }
                }
            }

            return retCode;
        }

        static int ExpireAllOffers(string titleid, string expiration, OfferManager.TargetDB eTargetDB)
        {
            if (expiration == null)
            {
                Console.WriteLine("Required -expiration: parameter was not found.");
                return -1;
            }

            try
            {
                _offerExpiration = DateTime.Parse(expiration);
            }
            catch
            {
                Console.WriteLine(string.Format("The -expiration: parameter could not be parsed into a valid DateTime: {0}", expiration));
                return -1;
            }

            return ExpireOffers(titleid, eTargetDB);
        }

        static int ExpireOffers(string titleid, OfferManager.TargetDB eTargetDB)
        {
            //
            //  It should be impossible to get to this point and have the following
            //  condition be true.  But if it happens, stop immediately because
            //  this condition will cause all of a title's offers to be set to
            //  DateTime.MaxValue.
            //

            if (_offersToExpire == null && _offerExpiration == DateTime.MaxValue)
            {
                Console.WriteLine("No expiration file entries to process, and no valid expiration date on the command line.  Exiting.");
                return -1;
            }

            if (titleid == null)
            {
                Console.WriteLine("Required -titleid: parameter was not found.");
                return -1;
            }

            //  Get canonicalized titlevault root path.
            string titleRoot = Path.Combine(Path.GetFullPath(Config.GetSetting(Setting.titlevault_root)), titleid);

            if (!Directory.Exists(titleRoot))
            {
                Console.WriteLine(string.Format("There is no directory for the specified title id (\"{0}\") in title vault.", titleid));
                return -1;
            }

            OfferManager.Target = eTargetDB;

            //
            //  Now iterate through all the offers in titlevault for the specified title
            //  update any offers we find that match the file we just read in.
            //

            string tempRoot = Path.Combine(Path.GetTempPath(), "LiveOffer_" + Guid.NewGuid().ToString());
            Directory.CreateDirectory(tempRoot);

            try
            {
                foreach (string offerFile in Directory.GetFiles(titleRoot, "*.offer"))
                {
                    try
                    {
                        //
                        //  Copy the offer file to a temporary location we can prop from.
                        //

                        string tempOfferFile = Path.Combine(tempRoot, Path.GetFileName(offerFile));

                        int count = 0;
                        bool offerFileChanged = false;

                        //
                        //  If the temp working file exists, make sure it's overwritable.
                        //

                        if (File.Exists(tempOfferFile))
                        {
                            FileAttributes attrs = File.GetAttributes(tempOfferFile);
                            File.SetAttributes(tempOfferFile, attrs & ~(FileAttributes.ReadOnly));
                        }

                        //
                        //  Copy the offer file from titlevault to the temp
                        //  working directory.
                        //

                        File.Copy(offerFile, tempOfferFile, true);

                        //
                        //  Now load in the file and start looking for offers that need to be
                        //  modified.
                        //

                        XmlSerializer serializer = new XmlSerializer(typeof(LiveOffer));
                        XmlReader validatingReader = OfferUtil.CreateValidatingReader(tempOfferFile);
                        LiveOffer lo = (LiveOffer)serializer.Deserialize(validatingReader);
                        validatingReader.Close();

                        //
                        //  Loop through each kind of offer in the offer file looking for matches
                        //

                        foreach (PromotionalPointsOffer o in lo.promotionalPointsOfferCollection)
                        {
                            count++;
                            ExpireOffer(o.__offerBasicInfo, ref offerFileChanged);
                        }

                        // A Content object can't be added in CatalogDB, it needs some information from
                        // the offer, so only add content that is referenced by an offer and don't add offers
                        // that don't have a content specified in the same file
                        Dictionary<string, Content> contentDictionary = new Dictionary<string, Content>(lo.contentCollection.Count);

                        foreach (Content content in lo.contentCollection)
                        {
                            contentDictionary[content.contentID] = content;
                        }

                        foreach (ContentOffer o in lo.contentOfferCollection)
                        {
                            count++;
                            ExpireOfferFromUODBandCatalogDB(contentDictionary, o, o.__offerBasicInfo, ref offerFileChanged);

                        }


                        foreach (PointsBundleOffer o in lo.pointsBundleOfferCollection)
                        {
                            count++;
                            ExpireOffer(o.__offerBasicInfo, ref offerFileChanged);
                        }

                        foreach (GamertagChangeOffer o in lo.gamertagChangeOfferCollection)
                        {
                            count++;
                            ExpireOffer(o.__offerBasicInfo, ref offerFileChanged);
                        }

                        foreach (GameplayOffer o in lo.gameplayOfferCollection)
                        {
                            count++;
                            ExpireOffer(o.__offerBasicInfo, ref offerFileChanged);
                        }

                        foreach (LiveSubscription s in lo.liveSubscriptionCollection)
                        {
                            count++;
                            ExpireSubscription(s.__subscriptionBasicInfo, ref offerFileChanged);
                        }

                        foreach (GameSubscription s in lo.gameSubscriptionCollection)
                        {
                            count++;
                            ExpireSubscription(s.__subscriptionBasicInfo, ref offerFileChanged);
                        }

                        //  PcAccountCreationOffer doesn't have expiration info, we only loop
                        //  through these to keep count accurate.

                        foreach (PcAccountCreationOffer s in lo.pcAccountCreationOfferCollection)
                        {
                            count++;
                        }

                        if (offerFileChanged)
                        {
                            //
                            //  The offer changed, so we need to save it, and push the
                            //  changes to title vault.  StoreOffer shouldn't fail,
                            //  because we previously copied from title vault to that 
                            //  location.  MoveFilesToTitleVault might throw and exception
                            //  at which point we want to emit a message saying that failed.
                            //

                            OfferUtil.StoreOffer(lo, tempOfferFile);

                            try
                            {
                                MoveFilesToTitleVault(tempOfferFile, titleid, count);
                            }
                            catch (Exception e)
                            {
                                Console.WriteLine("Failed to move offer file {0} to {1}.\r\nThe file will be left in the temp directory and should be manually returned to TitleVault.\r\nException details:\r\n{2}\r\n",
                                    tempOfferFile, titleRoot, e.ToString());
                                continue;
                            }

                            File.Delete(tempOfferFile);
                        }
                        else
                        {
                            //  The offer file didn't change, remove the temp copy.
                            File.Delete(tempOfferFile);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Exception caught while processing {0}, proceeding to next offer file.\r\nDetails:\r\n\r\n{1}", offerFile, e.ToString());
                        continue;
                    }
                }

                Console.WriteLine("Finished processing all offer files for {0}.", titleid);
            }
            finally
            {
                if (Directory.GetFiles(tempRoot, "*.offer").Length == 0)
                    Directory.Delete(tempRoot, true);
                else
                {
                    Console.WriteLine("Modified offer files in temp working directory \"{0}\" were not saved to title vault.  Please manually move these offer files to \"{1}\".",
                        tempRoot,
                        titleRoot);
                }
            }

            Console.WriteLine("Finished.\r\n");

            return 0;
        }

        static int PropXboxOffer(string file, string titleid, OfferManager.TargetDB eTargetDB)
        {
            if (titleid == null)
            {
                Console.WriteLine(string.Format("Required /titleid: parameter was not found"));
                return -1;
            }

            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));
            XmlReader validatingReader = XboxOfferUtil.CreateValidatingReader(file);
            XboxOffers xo = (XboxOffers)serializer.Deserialize(validatingReader);

            // Validate that the file titleid matches the command line titleid
            if (xo.__XboxContentOffer != null && xo.__XboxContentOffer.__xboxOfferBasicInfo != null && xo.XboxContentOffer.xboxOfferBasicInfo.titleID != 0)
            {
                uint fileTitleID = (uint)xo.XboxContentOffer.xboxOfferBasicInfo.titleID;
                uint argTitleID = uint.Parse(titleid, System.Globalization.NumberStyles.AllowHexSpecifier);
                if (fileTitleID != argTitleID)
                {
                    Console.WriteLine("LiveOffer error (aborting): /titleid " + argTitleID + " parameter does not match the titleid in the offer file, which was " + fileTitleID + ", for file " + file);
                    return -1;
                }
            }
            else
            {
                Console.WriteLine("LiveOffer.PropXboxOffer() warning: skipping titleid validation, as the titleid was not found in offer file " + file);
            }

            Console.WriteLine("XML parsed successfully");

            // Change the working directory to the offer file location
            string prevWorkDir = Environment.CurrentDirectory;
            try
            {
                Environment.CurrentDirectory = Path.GetDirectoryName(Path.GetFullPath(file));

                OfferManager.Target = eTargetDB;
                int count = OfferManager.PropXboxOffers(xo);
                validatingReader.Close();
                MoveFilesToTitleVault(file, titleid, count);
            }
            finally
            {
                // Restore previous working directory
                Environment.CurrentDirectory = prevWorkDir;
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("done");

            return 0;
        }

        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("  liveoffer -action:reload [-verbose]");
            Console.WriteLine("  liveoffer -action:validate -file:<offer-file-to-check> [-verbose]");
            Console.WriteLine("  liveoffer -action:validatexbox -file:<offer-file-to-check> [-verbose]");
            Console.WriteLine("  liveoffer -action:prop -file:<Xbox360-offer-file-to-prop> -titleid:<titleid in hex> [-overwriteDMPSettings] [-noreload] [-notransaction] [-verbose] [-skipxrl] [-timeout:<n seconds>]");
            Console.WriteLine("  liveoffer -action:propxbox -file:<Xbox-offer-file-to-prop> -titleid:<titleid in hex> [-noreload] [-notransaction] [-verbose]");
            Console.WriteLine("  liveoffer -action:expire -file:<offer-expiration-file> -titleid:<titleid in hex> [-noreload] [-verbose]");
            Console.WriteLine("  liveoffer -action:expireall -titleid:<titleid in hex> -expiration:<datetime> [-noreload] [-verbose]");
        }

        //task: will probably want to move this elsewhere eventually
        static void ResetFrontDoor(string serverInterface, string process, string component, string command, int timeout)
        {
            int result = 0;

            //need to loop through each of the servers in the Virtual Interface...
            string[] serverList = Config.GetServerListByInterface(serverInterface);
            string[] responses = null;
            Console.WriteLine("Resetting Front Doors... ");
            foreach (string server in serverList)
            {
                try
                {
                    //get server info to get IP address, should never get NULL info
                    Console.WriteLine(" " + server);
                    IInterfaceInfo svrIFaceInfo = Config.GetInterface(server, serverInterface);
                    XomAdminSession xmgmt = new XomAdminSession(svrIFaceInfo.IPAddress);
                    xmgmt.SendCommand(process, component, command, timeout, out responses, out result);
                }
                catch (Exception e)
                {
                    Console.WriteLine("There was a serious error while reloading front doors:");
                    Console.WriteLine("  Error was : " + e.Message + "\n" + e.StackTrace);
                }
            }
            Console.WriteLine("\n Attempted to reset all " + serverInterface.ToString() + " front doors");
        }

        static int MoveFilesToTitleVault(string offerFile, string titleID, int count)
        {
            int fileCount = 0;
            string strCount = String.Format("_[{0}]", count);
            string targetfile = Path.GetFileName(offerFile);

            if (targetfile.LastIndexOf(strCount) == -1)// check if file already has [<count>] text appended or not
            {
                targetfile = Path.GetFileNameWithoutExtension(offerFile) + strCount + Path.GetExtension(offerFile);
            }

            string titleRoot = Path.Combine(Path.GetFullPath(Config.GetSetting(Setting.titlevault_root)), titleID);
            string titleOldPath = Path.Combine(titleRoot, "OLD");
            Console.WriteLine("\nMoving source files to TitleVault location:  " + titleRoot);

            if (!Directory.Exists(titleRoot))
            {
                Directory.CreateDirectory(titleRoot);
            }

            if (!Directory.Exists(titleOldPath))
            {
                Directory.CreateDirectory(titleOldPath);
            }

            // Copy over OfferCultureDetail images, if any
            string[] iFPs = OfferManager.ImageFilePaths;
            foreach (string s in iFPs)
            {
                // Protect ourself since STUtil doesn't return a failcode if the file was missing
                if (File.Exists(s))
                {
                    TitleVault.TitleVaultCopy(titleRoot, s, Path.GetFileName(s));

                    string toDir = Path.Combine(titleRoot, Path.GetFileName(s));
                    Console.WriteLine("   Copied image file " + toDir + " to TitleVault.");
                    fileCount++;
                }
            }

            TitleVault.TitleVaultCopy(titleRoot, offerFile, targetfile);
            fileCount++;
            Console.WriteLine("   Copied offer file " + targetfile + " to TitleVault.");

            return fileCount;
        }

        static int Main(string[] rawArgs)
        {
            int retCode = 0;
            string sleep = null;

            try
            {
                // Parse and validate command line arguments
                NamedArgParser args = new NamedArgParser(namedArgumentList);
                if (!args.Parse(rawArgs))
                {
                    if (String.IsNullOrEmpty(args.InvalidArgText) || rawArgs.Length == 0)
                    {
                        Usage();
                    }
                    else
                    {
                        Console.WriteLine("Unrecognized or duplicate argument \"" + args.InvalidArgText + "\".  Run \"LiveOffer.exe /?\" for usage information.");
                    }
                    return -1;
                }

                // Check if the user requested usage info
                if (0 == args.Count || null != args["?"])
                {
                    Usage();
                    return 0;
                }

                Console.WriteLine("\r\n         L  I  V  E    O  F  F  E  R");
                Console.WriteLine("\r\n                       v " + Assembly.GetExecutingAssembly().GetName().Version.ToString());
                Console.WriteLine("\r\n=================================================\r\nCommand Line Arguments were: ");
                foreach (object thisArg in args.Keys)
                {
                    if (((string)args[thisArg.ToString()]) == String.Empty)
                    {
                        //for switches that don't supply an argument
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(20, ' ') + "    Was Present ");
                    }
                    else
                    {
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(20, ' ') + "    had the value '{0}'", (string)args[thisArg.ToString()]);
                    }
                }
                Console.WriteLine(Environment.NewLine);
                Console.WriteLine("Exe location: " + Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location));
                Console.WriteLine("\r\n===================");

                /////////////////
                // Just to give time to attach in the debugger, if you don't have a VC# Project ready-made...
                sleep = args["sleep"];
                if (sleep != null)
                    System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
                /////////////////                     

                string action = args["action"];
                if (action == null)
                    action = String.Empty;

                OfferManager.TargetDB eTargetdb;
                eTargetdb = OfferManager.TargetDB.uodb;

                if (args["overwriteDMPSettings"] != null)
                    OfferManager.OverwriteDMPSettings = true;

                // XENON 99218: LiveOffer: Remove/make it so that we don't use distributed transactions
                // if (args["notransaction"] != null)
                OfferManager.UseTransaction = false;

                bool resetNeeded = false, resetAllowed = true;

                if (args["noreload"] != null)
                    resetAllowed = false;

                string titleID = args["titleid"];
                if (!String.IsNullOrEmpty(titleID))
                {
                    titleID = RemoveHexPrefix(titleID).ToLower();
                }

                if (args["skipxrl"] != null)
                {
                    _checkXrl = false;
                }

                if (args["timeout"] != null)
                {
                    _timeoutSeconds = Int32.Parse(args["timeout"]);
                }

                switch (action.ToLower())
                {
                    case "reload":
                        resetNeeded = true;
                        break;

                    case "validate":
                        retCode = ValidateOfferFile(args["file"]);
                        break;

                    case "prop":
                        retCode = PropLiveOffer(args["file"], titleID, eTargetdb);
                        resetNeeded = (retCode == 0 ? resetAllowed : false);
                        break;
                    case "propxbox":
                        Console.WriteLine(Environment.NewLine);
                        Console.WriteLine("Legacy Xbox 1 title and offer data will only be added to UODB because it is not supported in CatalogDB.");
                        retCode = PropXboxOffer(args["file"], titleID, eTargetdb);
                        resetNeeded = (retCode == 0 ? resetAllowed : false);
                        break;

                    case "validatexbox":
                        Console.WriteLine(Environment.NewLine);
                        Console.WriteLine("Legacy Xbox 1 title and offer data will only be added to UODB because it is not supported in CatalogDB.");
                        retCode = ValidateXboxOfferFile(args["file"]);
                        break;

                    case "expire":
                        retCode = ExpireOffersInFile(args["file"], titleID, eTargetdb);
                        resetNeeded = (retCode == 0 ? resetAllowed : false);
                        break;

                    case "expireall":
                        retCode = ExpireAllOffers(titleID, args["expiration"], eTargetdb);
                        resetNeeded = (retCode == 0 ? resetAllowed : false);
                        break;

                    default:
                        Usage();
                        break;
                }

                if (resetNeeded)
                {
                    ResetFrontDoor(Interface.xbos_int, String.Empty, "xbos", "cacheflush", 10000);
                    ResetFrontDoor(Interface.xuacs_int, String.Empty, "xuacs", "cacheflush", 10000);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                Usage();
                retCode = -1;
            }

            /////////////////
            // Just to give time to view debug output...
            if (sleep != null)
                System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
            /////////////////   

            return retCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveContent\livecontent.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------ 

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.config;
using xonline.common.content;
using xonline.common.mgmt;
using xonline.common.offerutil;
using CatalogWebService = Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;

namespace Microsoft.Ems.Tools.LiveContent
{
    /// <summary>
    /// Command line code for the system check tool
    /// </summary>
    public class LiveContentTool
    {

        #region Member variables

        protected PackageBuilder packageBuilder;
        protected NamedArgParser argCommandParse;
        protected DownloadServerList serverList;
        protected uint expectedTitleID;
        protected string outputPath;
        protected string[] offerPath = { null, null };
        protected ulong[] offerID = { 0, 0 };
        protected bool defaultOffer = false;
        protected bool useDefaultOffer = false;
        bool updateContentId = true;
        protected string xicExtensionSuffix;
        protected int versionFlag;
        protected Guid betaGroupId = Guid.Empty;
        string avatarAssetIdSetting;

        // flags accessed across the distributor and content-installer threads.
        protected static bool isXPKG = false;
        protected static bool skipSvodCompression = false;

        //Generated during build or sign
        protected XICPackage[] builtContentPackages;
        protected string[] builtContentFiles;
        protected string builtRedirecteePackage;
        protected string[] builtManifestFiles;

        static readonly string ContentxbxFileName = "content.xbx";
        static readonly string CategoriesFileName = "$CabExtract\\Content\\categories.csv";

        protected static string[] namedArgumentList = new string[]
        {
            "?",
            "action",
            "package",
            "titleid",
            "site",
            "platform",
            "update",
            "overwrite",
            "adddefault",
            "offerfile",
            "offerid", // note: for Xbox1 a simple flag wound work, but for Xenon we need the overridden OfferID
            "offerfile2",   // only used for Xbox360 Trailer CABs, which output 2 Content Packages.
            "offerid2",     // only used for Xbox360 Trailer CABs, which output 2 Content Packages.
            "isdefaultoffer",  // offer file(s) given are defaults -- more fields to update.
            "startdate",
            "enddate",
            "shares",
            "xrls",
            "tempdir",
            "noreload",
            "timeout",
            "usedefaultoffer",
            "verbose",
            "skipsvodcompression",
            "group",
        };

        protected static string usageText =
            //2345678901234567890123456789012345678901234567890123456789012345678901234567890
            //--------+---------+---------+---------+---------+---------+---------+---------+
            "Tool used to build and prop Xbox Content to Live\n\n" +
            "Usage:\n" +
            "   LiveContent.exe /action:(build|xbox1content|xbox1update|assign|reassign|makefull)\n" +
            "                   /package:<filepath>\n" +
            "                   /titleid:<titleid>\n" +
            "                   /site:<site1>[;<site2>...]\n" +
            "                   /platform:(xbox1|xenon|pc)\n" +
            "                   [/group:<group guid id without dashes>]\n" +
            "                   [/verbose]\n" +
            "                   [/update:(full|selective)]\n" +
            "                   [/overwrite]\n" +
            "                   [/noreload]\n" +
            "                   [/timeout:<millis>]\n" +
            "                   [/adddefault]\n" +
            "                   [/startdate:<date>] [/enddate:<date>]\n" +
            "                   [/offerfile:<offerfilepath> /offerid:<offerid>\n" +
            "                       [/offerfile2:<offerfilepath2> /offerid2:<offerid2>]\n" +
            "                       [/isdefaultoffer:(yes|no)]]\n" +
            "                       [/usedefaultoffer]\n" +
            "                       [/skipsvodcompression]\n" +
            "                   [(/shares:<share1>[;<share2>...] /xrls:<xrl1>[;<xrl2>...])]\n" +
            "      action\n" +
            "          build        - build a vanilla cab submission into a content package.\n" +
            "          xbox1content - rebuild and prop xbox 1 content files.\n" +
            "          xbox1update  - rebuild and prop xbox 1 autoupdates.\n" +
            "          makefull     - convert a selective update into a global update.  In\n" +
            "                         this case, use the /package switch to specify the\n" +
            "                         package id that is being converted.\n" +
            "          assign       - assign an update that's already been propped as\n" +
            "                         selective to a group.  use the /package flag like makefull.\n" +
            "          reassign     - reassign an older update to a group that has already\n" +
            "                         has a newer version propped.  Like assign but can\n" +
            "                         specify previous builds.  Consoles that have already\n" +
            "                         taken the update will be able to log in,\n" +
            "                         but no new consoles will take the update.\n" +
            "      package   - input package, for build this is a cab, for sign this is an\n" +
            "                  unsigned content package.  For adddefault this is a path\n" +
            "                  to the directory containing the default packages or updates.\n" +
            "                  For makefull this is the package id of the previously\n" +
            "                  submitted update i.e. \"0000000100000101\".\n" +
            "      titleid   - hexadecimal titleid (no leading 0x).  Required for\n" +
            "                  xbox1content, xbox1update and makefull.  For the build action\n" +
            "                  if titleid is 0, then no title id check is made otherwise\n" +
            "                  a sanity check will be made before propping content\n" +
            "      site      - site index for virtual IP for download virtual interface for xbox 1 content\n" +
            "      group     - specifies the group to push the update to for the assign action\n" +
            "      platform  - specifies the target platform for the makefull action\n" +
            "                  this flag is only required when makefull is specified.\n" +
            "          xbox1        - targets an xbox 1 console (case insensitive).\n" +
            "          xenon        - targets an xbox 360 console (case insensitive).\n" +
            "          pc           - targets a panorama pc (case insensitive).\n" +
            "      update    - flag to control how update packages are installed\n" +
            "          full         - the update is a full update\n" +
            "          selective    - the update is a selective update (default)\n" +
            "      overwrite - overwrites package on CDN server if it already exists. if\n" +
            "                  this flag is not specified and the package already exists\n" +
            "                  then that package copy will be skipped\n" +
            "      adddefault- adds default packages or updates for the specified title.  In\n" +
            "                  this case /package specifies the directory containing the\n" +
            "                  default packages or updates, instead of the package filename.\n" +
            "      offerfile - input offer, to be updated with generated ContentID.\n" +
            "      offerid   - hexadecimal offerid (no leading 0x). OfferID will be\n" +
            "                  validated against what is in the offerfile itself,\n" +
            "                  or in the special default-offer case, the titleID and offerID\n" +
            "                  in the offerfile will also get updated along with the\n" +
            "                  generated contentID.\n" +
            "      offerfile2 - 2nd input offer, only for Xbox360 Trailer CABs, which\n" +
            "                  output a 2nd XCP for the Low-Res trailer content.\n" +
            "      offerid2  - 2nd hexadecimal offerid (no leading 0x). Use with a Trailer\n" +
            "                  packages for the Low-Res trailer. Similar to offerid.\n" +
            "      isdefaultoffer - is package being built with default offerfile(s).\n" +
            "          no           - offerfile should contain data for this offerID\n" +
            "          yes          - titleID and offerID in the offerfile will\n" +
            "                       be updated along with the generated contentID.\n" +
            "      usedefaultoffer - LiveContent should grab a default offer and customize\n" +
            "                  it for this package.  Not supported for Video or Game Trailer\n" +
            "                  content types.\n" +
            "      skipsvodcompression - LiveContent should not compress the SVOD package\n" +
            "                  for this Xbox Original or Xbox 360 Game content type.\n" +
            "      startdate - The time/date that the package(s) become available.\n" +
            "      enddate   - The time/date that the package(s) become unavailable.\n" +
            "                  startdate and enddate apply to xbox 1 content only.\n" +
            "      shares    - Custom list of share locations, if specified content is\n" +
            "                  pushed here instead of shares present in npdb.\n" +
            "                  i.e. /shares:1.2.3.4\\download_content\n" +
            "      xrls      - Custom list of xrls, if specified these values will be\n" +
            "                  propped to uodb instead of values present in npdb.\n" +
            "                  i.e. /xrls:1.2.3.4:3074/content\n" +
            "      tempdir   - Location of temporary directory to use while building\n" +
            "                  the package.  This is optional, and if omitted a unique\n" +
            "                  directory will be created using the system temp directory.\n" +
            "      noreload  - skips reloading front door caches (xbos, xkdc, uacs)\n" +
            "      timeout   - Control timeout in milliseconds of network commands\n" +
            "      verbose   - Display logging messages for non-error cases\n" +
            "      ?         - shows this usage message.";

        protected bool abortFlag;

        #endregion

        #region XML Offer Updates

        static string DefaultOffersDir
        {
            get
            {
                string defaultOffersDir = Path.Combine(Config.GetSetting(Setting.titlevault_root), Config.Environment);
                defaultOffersDir = Path.Combine(defaultOffersDir, "ZDefault");
                return defaultOffersDir;
            }
        }

        static ContentPackageType PackageType
        {
            get
            {
                ContentPackageType packageType;

                if (!isXPKG)
                    packageType = ContentPackageType.Cab;
                else
                {
                    if (skipSvodCompression)
                        packageType = ContentPackageType.SvodUncompressed;
                    else
                        packageType = ContentPackageType.SvodCompressed;
                }

                return packageType;
            }
        }

        static void ValidateOffer(LiveOffer lo, string file, ulong offerID, bool bDefaultOffer, XboxContentTypes contentType)
        {
            // Agreed upon contraint with LiveContent and LiveOffer PMs (9/12/05) -- only at most one Content section allowed
            if (lo.contentCollection.Count > 1)
                throw new Exception(string.Format("only one Content section allowed in .Offer file: {0}", file));

            // Make sure we have a ContentOffer to begin with
            if (lo.contentOfferCollection.Count == 0)
            {
                throw new Exception(string.Format("at least one ContentOffer section required in .Offer file: {0}", file));
            }
            // Validate that we have a true default offerfile
            else if (bDefaultOffer)
            {
                if (String.Compare(lo.contentOfferCollection[0].offerBasicInfo.primaryTitleID, "0xFFFFFFFF", true) != 0
                    || String.Compare(lo.contentOfferCollection[0].offerBasicInfo.offerID, "0xFFFFFFFFFFFFFFFF", true) != 0)
                {
                    throw new Exception(string.Format("invalid default .Offer file: {0} - verify that you are using a valid default OfferFile.", file));
                }
            }
            // Validate that we have an Content-OfferFile that matched the OfferID
            else
            {
                bool found = false, typematch = true;
                ContentOfferType cof = (ContentOfferType)0;
                foreach (ContentOffer co in lo.contentOfferCollection)
                {
                    if (String.Compare(co.offerBasicInfo.offerID, "0x" + offerID.ToString("X"), true) == 0)
                        found = true;

                    // Ensure all the offer's ContentOfferType matches the packages ContentType, except for Avatar. For Avatar
                    // content we force the ContentOfferType to be Avatar. Method UpdateOffer updates the offer
                    if (!
                        (
                        (co.contentOfferType == ContentOfferType.Arcade && contentType == XboxContentTypes.Arcade) ||
                        (co.contentOfferType == ContentOfferType.GameContent && contentType == XboxContentTypes.MarketPlace) ||
                        (co.contentOfferType == ContentOfferType.GameDemo && contentType == XboxContentTypes.GameDemo) ||
                        (co.contentOfferType == ContentOfferType.GameTrailer && contentType == XboxContentTypes.GameTrailer) ||
                        (co.contentOfferType == ContentOfferType.Theme && contentType == XboxContentTypes.ThematicSkin) ||
                        (co.contentOfferType == ContentOfferType.Tile && contentType == XboxContentTypes.GamerPicture) ||
                        (co.contentOfferType == ContentOfferType.Video && contentType == XboxContentTypes.Video) ||
                        (co.contentOfferType == ContentOfferType.FullGame && contentType == XboxContentTypes.Xbox360Title) ||
                        (co.contentOfferType == ContentOfferType.GameContent && contentType == XboxContentTypes.XboxTitle)
                        )
                        &&
                        (
                        contentType != XboxContentTypes.AvatarItem // Accept the fact that the offer may not match the content type for Avatar
                        )
                       )
                    {
                        typematch = false;
                    }

                    cof = co.contentOfferType;

                    try
                    {
                        Convert.ToUInt32(co.offerBasicInfo.primaryTitleID, 16);
                    }
                    catch (FormatException)
                    {
                        throw new Exception(string.Format("invalid PrimaryTitleId: {0} - verify correct primary title id", co.offerBasicInfo.primaryTitleID));
                    }
                }

                if (!found)
                    throw new Exception(string.Format("invalid .Offer file: {0} - verify that this OfferFile is for offerID: {1:X16}", file, offerID));

                if (!typematch)
                    throw new Exception(string.Format("invalid .Offer file: {0} - the CAB contentType ({2}) does not match the Offer ContentOfferType ({3}) for offerID: {1:X16}", file, offerID, contentType, cof));
            }
        }

        static LiveOffer SelectDefaultOfferFile(XboxContentTypes contentType)
        {

            string[] offerFiles = Directory.GetFiles(DefaultOffersDir, "*.offer");

            foreach (string offerFileName in offerFiles)
            {
                bool foundMatch = false;
                string offerFilePath = Path.Combine(DefaultOffersDir, offerFileName);

                LiveOffer lo = OfferUtil.LoadOffer(offerFilePath);

                if (lo == null)
                    continue;

                foreach (ContentOffer co in lo.contentOfferCollection)
                {
                    //  The content types defined in the XSD don't match what we use, so
                    //  we need to do this yucky checking

                    foundMatch =
                        (co.contentOfferType == ContentOfferType.Arcade && contentType == XboxContentTypes.Arcade) ||
                        (co.contentOfferType == ContentOfferType.GameContent && contentType == XboxContentTypes.MarketPlace) ||
                        (co.contentOfferType == ContentOfferType.GameDemo && contentType == XboxContentTypes.GameDemo) ||
                        (co.contentOfferType == ContentOfferType.GameTrailer && contentType == XboxContentTypes.GameTrailer) ||
                        (co.contentOfferType == ContentOfferType.Theme && contentType == XboxContentTypes.ThematicSkin) ||
                        (co.contentOfferType == ContentOfferType.Tile && contentType == XboxContentTypes.GamerPicture) ||
                        (co.contentOfferType == ContentOfferType.Video && contentType == XboxContentTypes.Video) ||
                        (co.contentOfferType == ContentOfferType.AvatarItem && contentType == XboxContentTypes.AvatarItem);

                    if (!foundMatch)
                        break;
                }

                if (foundMatch)
                {
                    ValidateOffer(lo, offerFilePath, 0, true, contentType);
                    return lo;
                }
            }

            throw new Exception("Could not find a default offer file in \"" + DefaultOffersDir + "\" for ContentType = " + contentType.ToString() + ".");
        }

        static void CopyOfferImages(LiveOffer lo, string srcPath, string destPath)
        {
            if (!Directory.Exists(srcPath))
                throw new Exception("Source directory \"" + srcPath + "\" does not exist.");

            if (!Directory.Exists(destPath))
                throw new Exception("Destination directory \"" + destPath + "\" does not exist.");

            StringCollection fileList = new StringCollection();

            //  Iterate through all the images and get a list of distinct files to be copied.
            //  Note that the files will be copied only, and not renamed.
            foreach (ContentOffer offer in lo.contentOfferCollection)
            {
                if (offer.offerBasicInfo == null || offer.offerBasicInfo.offerCultureDetailsCollection == null)
                    continue;

                foreach (OfferCultureDetails details in offer.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (!fileList.Contains(details.imageFilePath.ToLower()))
                        fileList.Add(details.imageFilePath.ToLower());
                }
            }

            //  Now copy all the files referenced
            foreach (string fileName in fileList)
            {
                File.Copy(Path.Combine(srcPath, fileName), Path.Combine(destPath, fileName), true);
            }
        }

        static LiveOffer GetOffer(string file, ulong offerID, bool bDefaultOffer, XboxContentTypes contentType)
        {
            if (!File.Exists(file))
                throw new Exception(string.Format("cannot find .Offer file: {0}", file));

            LiveOffer lo = OfferUtil.LoadOffer(file);

            if (lo == null)
                throw new Exception(string.Format("Failed to load .Offer file: {0}", file));

            ValidateOffer(lo, file, offerID, bDefaultOffer, contentType);

            return lo;
        }

        static void UpdateOfferBasicInfo(ref OfferBasicInfo obi, string Offer, string Title, string FriendlyName)
        {
            obi.offerID = Offer;
            obi.primaryTitleID = Title;
            obi.friendlyName = FriendlyName;

            foreach (OfferCultureDetails ocd in obi.offerCultureDetailsCollection)
            {
                // Check if text already pre-fixed with FriendlyName
                if (String.Compare(ocd.name, 0, FriendlyName, 0, FriendlyName.Length) != 0)
                {
                    ocd.name = FriendlyName + " " + ocd.name;
                    ocd.sellText = FriendlyName + " " + ocd.sellText;
                }
            }
        }

        static void UpdateSubscriptionBasicInfo(ref SubscriptionBasicInfo sbi, string Offer, string Title, string FriendlyName)
        {
            sbi.offerID = Offer;
            sbi.titleIDCollection.Clear();
            sbi.titleIDCollection.Add(Title);
            sbi.friendlyName = FriendlyName;

            foreach (OfferCultureDetails ocd in sbi.offerCultureDetailsCollection)
            {
                // Check if text already pre-fixed with FriendlyName
                if (String.Compare(ocd.name, 0, FriendlyName, 0, FriendlyName.Length) != 0)
                {
                    ocd.name = FriendlyName + " " + ocd.name;
                    ocd.sellText = FriendlyName + " " + ocd.sellText;
                }
            }
        }

        static bool UpdateOffer(ref LiveOffer lo, uint lTitleID, ulong lOfferID, bool bDefaultOffer, XICPackage pkg, Guid? gameContentMediaId, CategoryCollection builtCategoryCollection)
        {
            return UpdateOffer(ref lo, lTitleID, lOfferID, bDefaultOffer, pkg, gameContentMediaId, builtCategoryCollection, true /*updateContentId*/);
        }


        /// <summary>
        /// Method that updates the .offer file loaded with the content package information
        /// </summary>
        /// <param name="lo">.offer file loaded</param>
        /// <param name="lTitleID">live title id</param>
        /// <param name="lOfferID">offer id</param>
        /// <param name="bDefaultOffer">use default offer values</param>
        /// <param name="pkg">content package</param>
        /// <param name="gameContentMediaId">gameContentMediaId to use in the Catalog</param>
        /// <param name="updateContentId">This flag is used to control if we should update the ContentId and other related properties from the Offer File. The default should be TRUE.</param>

        static bool UpdateOffer(ref LiveOffer lo, uint lTitleID, ulong lOfferID, bool bDefaultOffer, XICPackage pkg, Guid? gameContentMediaId, CategoryCollection builtCategoryCollection, bool updateContentId)
        {
            String hexfmt1 = "0x{0}", hexfmt2 = "0x{0:x8}";
            String strOfferID, strTitleID;

            strOfferID = String.Format(hexfmt2, lOfferID);
            strTitleID = String.Format(hexfmt2, lTitleID);

            // Need to update TitleID/OfferID if Default Offer file in use
            if (bDefaultOffer)
            {
                foreach (Title t in lo.titleCollection)
                    t.titleID = strTitleID;

                foreach (PointsBundleOffer obj in lo.pointsBundleOfferCollection)
                    UpdateOfferBasicInfo(ref obj.__offerBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);

                foreach (GamertagChangeOffer obj in lo.gamertagChangeOfferCollection)
                    UpdateOfferBasicInfo(ref obj.__offerBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);

                foreach (GameplayOffer obj in lo.gameplayOfferCollection)
                    UpdateOfferBasicInfo(ref obj.__offerBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);

                foreach (PromotionalPointsOffer obj in lo.promotionalPointsOfferCollection)
                    UpdateOfferBasicInfo(ref obj.__offerBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);

                foreach (xonline.common.offerutil.LiveSubscription obj in lo.liveSubscriptionCollection)
                    UpdateSubscriptionBasicInfo(ref obj.__subscriptionBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);

                foreach (GameSubscription obj in lo.gameSubscriptionCollection)
                    UpdateSubscriptionBasicInfo(ref obj.__subscriptionBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);
            }

            // Make sure we have a Content object to work with
            Content c = null;
            if (lo.contentCollection.Count == 0)
                c = lo.contentCollection.Add();
            else
                c = lo.contentCollection[0];

            if (updateContentId)
            {
                // Fill in Content node
                c.contentID = String.Format(hexfmt1, pkg.ContentIDString);
                c.packageSize = (UInt64)pkg.PackageSize;
                c.installSize = (UInt64)pkg.InstallSize;
                c.symKey = String.Format(hexfmt1, pkg.SymmetricKeyString);
                c.publicKey = String.Format(hexfmt1, pkg.PublicKeyString);
                c.friendlyName = pkg.FriendlyName;

                c.packageType = PackageType;
                c.gameRegion = pkg.GameRegion;
            }

            // Fill in Content Locations
            DownloadServerList dsl = new DownloadServerList();
            int rank = 0;
            foreach (string location in dsl.XRLLocations)
            {
                ContentLocation cl = null;
                if (c.contentLocationCollection.Count > rank)
                    cl = c.contentLocationCollection[rank];
                else
                    cl = c.contentLocationCollection.Add();

                cl.rank = (UInt32)rank++;
                cl.xrl = PackageInstaller.XRLPath(pkg, location);
            }

            if (updateContentId)
            {
                // Update Offer Collection(s)
                ulong offerCount = 0;
                foreach (ContentOffer co in lo.contentOfferCollection)
                {
                    // Force the ContentOfferType to be AvatarItem when the package type is Avatar
                    if (pkg.ContentType == XboxContentTypes.AvatarItem)
                    {
                        co.contentOfferType = ContentOfferType.AvatarItem;
                    }

                    if (bDefaultOffer)
                    {
                        if (pkg.ContentType == XboxContentTypes.Arcade)
                            strOfferID = String.Format(hexfmt2, lOfferID + offerCount);

                        UpdateOfferBasicInfo(ref co.__offerBasicInfo, strOfferID, strTitleID, pkg.FriendlyName);
                    }

                    co.offerContentInfo.contentID = String.Format(hexfmt1, pkg.ContentIDString);

                    ++offerCount;
                }
            }

            foreach (ContentOffer contentOffer in lo.contentOfferCollection)
            {
                if (gameContentMediaId.HasValue)
                {
                    // validation for specific offer types
                    if (contentOffer.contentOfferType == ContentOfferType.AvatarItem)
                    {
                        // make sure the primary title id in the offer matches the last 8 digits in the Avatar Asset Id.
                        string primaryTitleId = contentOffer.offerBasicInfo.primaryTitleID;

                        if (primaryTitleId.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
                        {
                            primaryTitleId = primaryTitleId.Substring(2, 8);
                        }

                        string assetId = gameContentMediaId.Value.ToString();

                        if (!String.Equals(primaryTitleId, assetId.Substring(assetId.Length - 8), StringComparison.InvariantCultureIgnoreCase))
                        {
                            Console.WriteLine("ERROR: The primary title id in the .offer file needs to match with the title id from the Avatar AssetId in the content package.");
                            return false;
                        }
                    }

                    contentOffer.gameContentMediaId = gameContentMediaId.Value.ToString();
                }
                else
                {
                    contentOffer.gameContentMediaId = null;
                }

                //Clear Categories
                //Will need to be done before the Categories from the Avatar Bin file have been inserted
                contentOffer.categoryCollection.Clear();

                //Add Catagories found from the categories.csv file
                foreach (Category cat in builtCategoryCollection)
                {
                    contentOffer.categoryCollection.Add(cat);
                }
            }

            return true;
        }
        #endregion

        LiveContentTool()
        {
            serverList = new DownloadServerList();

            packageBuilder = null;
            builtContentPackages = null;

            argCommandParse = null;
            abortFlag = false;

            xicExtensionSuffix = ".new";

            outputPath = "";
        }

        bool ParseSharesAndXRLs(string Shares, string XRLs)
        {
            string[] shares = Shares.Split(';');
            string[] xrls = XRLs.Split(';');

            for (int c = 0; c < shares.Length; c++)
            {
                if (0 == shares[c].Length)
                {
                    Console.WriteLine("ERROR: /shares format is invalid '{0}'", Shares);
                    return false;
                }

                shares[c] = "\\\\" + shares[c];
            }

            for (int c = 0; c < xrls.Length; c++)
            {
                if (0 == xrls[c].Length)
                {
                    Console.WriteLine("ERROR: /xrls format is invalid '{0}'", XRLs);
                    return false;
                }

                xrls[c] = "http://" + xrls[c];
            }

            //DownloadServerList will use the given share names and xrl paths
            serverList.ShareNames = shares;
            serverList.XRLLocations = xrls;

            return true;
        }

        int Execute(NamedArgParser argList)
        {
            string packagePath = "";
            string sites = "";
            string strTitle;
            string[] strOffer = { null, null };
            bool bFull = false;
            bool ReloadFlag = true;

            PackageInstaller.Target = PackageInstaller.TargetDB.uodb;

            argCommandParse = argList;

            if (null != argCommandParse["noreload"])
                ReloadFlag = false;

            // Override the timeout of the xmgmt interface used by this tool.
            if (null != argCommandParse["timeout"])
            {
                try
                {
                    CMgmtCommand.TimeoutMilliseconds = Int32.Parse(argCommandParse["timeout"]);
                }
                catch (Exception)
                {
                    Console.WriteLine("ERROR: /timeout value was not a valid integer");
                    return -1;
                }
            }

            if ((null == argCommandParse["action"]))
            {
                Console.WriteLine("ERROR: /action was not specified.");
                return -1;
            }

            if (null == argCommandParse["package"])
            {
                Console.WriteLine("ERROR: /package flag is missing.");
                return -1;
            }

            if (null != argCommandParse["group"])
            {
                try
                {
                    betaGroupId = new Guid(argCommandParse["group"]);
                }
                catch
                {
                    Console.WriteLine("ERROR: invalid value specified for /group, try passing a Guid!");
                    return -1;
                }
            }


            if (null != argCommandParse["update"])
            {
                argCommandParse["update"] = argCommandParse["update"].ToLower();

                if ("full" == argCommandParse["update"])
                    bFull = true;
                else if ("selective" == argCommandParse["update"])
                    bFull = false;
                else
                {
                    Console.WriteLine("ERROR: invalid value specified for /update ({0}), select from {full, selective}",
                            argCommandParse["update"]);
                    return -1;
                }
            }

            //Checking for presence of customly specified shares and xrls
            if ((null == argCommandParse["shares"]) ^ (null == argCommandParse["xrls"]))
            {
                Console.WriteLine("ERROR: /shares and /xrls must be used together");
                return -1;
            }
            else if ((null != argCommandParse["shares"]) & (null != argCommandParse["xrls"]))
            {
                if (!ParseSharesAndXRLs(argCommandParse["shares"], argCommandParse["xrls"]))
                    return -1;
            }

            packagePath = argCommandParse["package"];
            offerPath[0] = argCommandParse["offerfile"];
            offerPath[1] = argCommandParse["offerfile2"];
            sites = argCommandParse["site"];

            if (Directory.Exists(argCommandParse["tempdir"]))
            {
                outputPath = argCommandParse["tempdir"];
            }
            else
            {
                outputPath = Path.Combine(Path.GetTempPath(), "temp_livecontent_build");
            }

            if (!Directory.Exists(outputPath))
                Directory.CreateDirectory(outputPath);

            Guid guid = Guid.NewGuid();
            outputPath = Path.Combine(outputPath, guid.ToString());

            //Checking the title ID
            strTitle = argCommandParse["titleid"];
            if (strTitle == null)
            {
                Console.WriteLine("ERROR: /titleid flag is missing.");
                return -1;
            }

            //Checking the site list
            try
            {
                this.serverList.ParseSiteList(Config.GetSetting(Setting.livecontent_sites));
            }
            catch (Exception e)
            {
                Console.WriteLine("ERROR: failed to parse site list " + e.ToString());
                return -1;
            }

            strOffer[0] = argCommandParse["offerid"];
            strOffer[1] = argCommandParse["offerid2"];

            //remove any leading "0x" characters from titleid and offerid values
            if (strTitle.StartsWith("0x"))
            {
                strTitle = strTitle.Substring(2);
            }
            if (strOffer[0] != null && strOffer[0].StartsWith("0x"))
            {
                strOffer[0] = strOffer[0].Substring(2);
            }
            if (strOffer[1] != null && strOffer[1].StartsWith("0x"))
            {
                strOffer[1] = strOffer[1].Substring(2);
            }

            //Checking that offer path is specified if offerid was
            if (offerPath[0] == null && strOffer[0] != null)
            {
                Console.WriteLine("ERROR: /offerfile is missing, but /offerid is specified");
                return -1;
            }

            //Checking that offerid is specified if offer path was
            if (offerPath[0] != null && strOffer[0] == null)
            {
                Console.WriteLine("ERROR: /offerid is missing, but /offerfile is specified");
                return -1;
            }

            //Checking that 2nd offer path is specified only if 1st one was
            if (offerPath[0] == null && offerPath[1] != null)
            {
                Console.WriteLine("ERROR: /offerfile is missing, but /offerfile2 is specified");
                return -1;
            }

            //Checking that 2nd offeris is specified only if 1st one was
            if (strOffer[0] == null && strOffer[1] != null)
            {
                Console.WriteLine("ERROR: /offerid is missing, but /offerid2 is specified");
                return -1;
            }

            //Checking that 2nd offer path is specified if 2nd offerid was
            if (offerPath[1] == null && strOffer[1] != null)
            {
                Console.WriteLine("ERROR: /offerfile2 is missing, but /offerid2 is specified");
                return -1;
            }

            //Checking that 2nd offerid is specified if 2nd offer path was
            if (offerPath[1] != null && strOffer[1] == null)
            {
                Console.WriteLine("ERROR: /offerid2 is missing, but /offerfile2 is specified");
                return -1;
            }

            //Check for offer file existence before beginning work
            if (offerPath[0] != null && strOffer[0] != null)
            {
                if (File.Exists(offerPath[0]) == false)
                {
                    Console.WriteLine("ERROR: /offerfile is specified but does not exist");
                    return -1;
                }
            }
            if (offerPath[1] != null && strOffer[1] != null)
            {
                if (File.Exists(offerPath[1]) == false)
                {
                    Console.WriteLine("ERROR: /offerfile2 is specified but does not exist");
                    return -1;
                }
            }

            // default offer?
            if ("yes" == argCommandParse["isdefaultoffer"])
                defaultOffer = true;

            if (argCommandParse["usedefaultoffer"] != null)
            {
                useDefaultOffer = true;
                defaultOffer = true;
            }

            if (argCommandParse["skipsvodcompression"] != null)
            {
                skipSvodCompression = true;
            }


            // Xbox Originals and Xbox 360 Games - these packages are passed to LiveContent as .xpkg files
            if (Path.GetExtension(packagePath).Equals(PackageBuilder.GamesOnDemandExtension, StringComparison.InvariantCultureIgnoreCase))
            {
                // Track which type of package we're using
                isXPKG = true;
            }

            //Version flag begin set
            versionFlag = bFull ? 0 : 1;

            try
            {
                if ("build" == argCommandParse["action"])
                {
                    Console.WriteLine("Building in '{0}'", outputPath);

                    expectedTitleID = 0; // init, so we know which failed to parse
                    try
                    {
                        expectedTitleID = uint.Parse(strTitle, NumberStyles.HexNumber);

                        if (strOffer[0] != null)
                        {
                            offerID[0] = ulong.Parse(strOffer[0], NumberStyles.HexNumber);

                            // only used for Trailer CABs which produce 2 packages
                            if (strOffer[1] != null)
                            {
                                offerID[1] = ulong.Parse(strOffer[1], NumberStyles.HexNumber);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("failed to parse {0} -- {1}", (expectedTitleID == 0 ? "titleid" : "offerid"), e.Message);
                        return -1;
                    }

                    try { packageBuilder = new PackageBuilder(packagePath); }
                    catch (Exception e)
                    {
                        Console.WriteLine("ERROR: could not initialize PackageBuilder '{0}'", e.Message);
                        return -1;
                    }

                    if (!Distributer("Distributer"))
                    {
                        return -1;
                    }

                    if (ReloadFlag)
                    {
                        Console.WriteLine("Updating front door caches (xbos, xkdc, uacs) ...");

                        CPropXbox1Utils.UpdateXBOSCache();
                        CPropXbox1Utils.UpdateXKDCCache();
                        CPropXbox1Utils.UpdateUACSCache();
                    }

                    Console.WriteLine("Package(s) built and deployed succesfully.");
                    Console.WriteLine("Worker thread have completed, application terminating");
                }
                else if ("xbox1content" == argCommandParse["action"])
                {
                    if (null == argCommandParse["site"])
                    {
                        Console.WriteLine("ERROR: /site flag is missing.");
                        return -1;
                    }

                    if (argCommandParse["adddefault"] == null)
                    {
                        return CPropXbox1Content.RebuildContent(strTitle, packagePath, sites, strOffer[0], argCommandParse["startdate"], argCommandParse["enddate"], defaultOffer, offerPath[0]);
                    }
                    else
                    {
                        if (CPropXbox1Content.AddDefault(strTitle, packagePath, sites))
                            return 0;
                        else
                            return -1;
                    }
                }
                else if ("xbox1update" == argCommandParse["action"])
                {
                    try
                    {
                        if (null == argCommandParse["site"])
                        {
                            Console.WriteLine("ERROR: /site flag is missing.");
                            return -1;
                        }

                        if (argCommandParse["adddefault"] != null)
                        {
                            CPropXbox1Update.BuildDefaultUpdate(strTitle, ref packagePath);
                            CPropXbox1Update.defaultUpdate = true;
                        }

                        return CPropXbox1Update.RebuildUpdate(strTitle, packagePath, sites, bFull);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("ERROR: " + e.Message);
                        return -1;
                    }
                }
                else if ("makefull" == argCommandParse["action"] ||
                        "assign" == argCommandParse["action"] ||
                        "reassign" == argCommandParse["action"])
                {
                    string platform = argCommandParse["platform"];
                    bool bReassign = ("reassign" == argCommandParse["action"]);

                    if (null == platform)
                    {
                        Console.WriteLine("ERROR: /platform is missing, /platform must be specified with /action:makefull");
                        return -1;
                    }

                    if ("makefull" == argCommandParse["action"] &&
                        betaGroupId != Guid.Empty)
                    {
                        Console.WriteLine("ERROR: /makefull specified with a group.  /makefull operates on the production group only.  try assign to assign something propped as selective to a group.");
                        return -1;
                    }

                    if ("assign" == argCommandParse["action"] &&
                        betaGroupId == Guid.Empty)
                    {
                        Console.WriteLine("ERROR: /assign specified without a group, or with the production group.  This would push something out to production.  If you really want to do this, do the /makefull command.");
                        return -1;
                    }

                    //  We need to figure out if this is xbox 1 or xbox 360
                    if (!CPropXbox1Update.MakeFull(strTitle, packagePath, platform, betaGroupId, bReassign, ReloadFlag))
                    {
                        return -1;
                    }
                }
                else
                {
                    Console.WriteLine("ERROR: invalid action specified.");
                    return -1;
                }
            }
            finally
            {
                if (Directory.Exists(outputPath))
                {
                    Directory.Delete(outputPath, true);
                }
            }

            return 0;
        }

        #region Thread Worker functions

        void DistributerWorkerThread()
        {
            string tag = "Distributer";

            if (Distributer(tag))
                Console.WriteLine("SUCCESS: Distribute content finished normally");
            else
                Console.WriteLine("FAILED : Distribute content encountered errors");
        }

        bool Distributer(string tag)
        {
            XICDistributer distributer = new XICDistributer();
            bool OverwriteFlag = false;
            bool result;
            Ini xbxIni = null;

            if (null != argCommandParse["overwrite"])
            {
                OverwriteFlag = true;
            }

            try
            {
                Console.WriteLine("Building content package...");




                // Xbox Originals and Xbox 360 Games - these packages are passed to LiveContent as .xpkg files
                // and crackcab.dll already knows how to handle them.
                // Don't try to extract the content.xbx filename because that action will fail
                if (!isXPKG)
                {
                    if (!Directory.Exists(outputPath))
                        Directory.CreateDirectory(outputPath);

                    string contentXbxFilePath = Path.Combine(outputPath, ContentxbxFileName);

                    // try to extract content.xbx file from cab
                    // this file should be required
                    if (!packageBuilder.ExtractFile(outputPath, ContentxbxFileName) || !File.Exists(contentXbxFilePath))
                    {
                        Console.WriteLine("ERROR: Could not extract content.xbx from package.");
                        return false;
                    }

                    // set updateContentId flag if this package is a GFWL Content Package
                    // the tool should be able to inspect the CAB file submitted and check the content.XBX file for the following line: Platform=0x10
                    xbxIni = new Ini(contentXbxFilePath, Encoding.Unicode);
                }

                bool isGFWLPackage = false;
                bool isGFWLUpdate = false;

                if (xbxIni != null)
                {
                    isGFWLPackage = xbxIni.GetSetting(Ini.SectionAll, Ini.PlatformSetting) == Ini.PlatformValueGFWL;

                    if (isGFWLPackage)
                    {
                        if (xbxIni.GetSetting(Ini.SectionAll, Ini.ContentPackageType).Length != 10)
                            throw new Exception("ERROR: ContentPackageType in content.xbx is required to be 10 hex digits");

                        uint contentTypeId = uint.Parse(xbxIni.GetSetting(Ini.SectionAll, Ini.ContentPackageType).Substring(2, 8), NumberStyles.HexNumber);

                        isGFWLUpdate = contentTypeId == (uint)XboxContentTypes.Installer;
                    }

                    // get other settings here
                    this.avatarAssetIdSetting = xbxIni.GetSetting(Ini.SectionAll, Ini.AvatarAssetIDSetting);
                }

                if (isGFWLPackage && !isGFWLUpdate)
                {
                    // set this flag to false, so that the contentId info in the .offer file is not changed
                    this.updateContentId = false;

                    // create a XICPackageInfo and XICPackage to simulate that a package was created
                    // GFWL don't want a .xic but they want to prop their own .cab files submitted
                    // this is needed so that the distributer can push the package to download location
                    XICPackageInfo packageInfo = new XICPackageInfo();
                    packageInfo.TitleID = expectedTitleID;
                    if (xbxIni.GetSetting(Ini.SectionAll, Ini.ContentPackageType).Length != 10)
                        throw new Exception("ERROR: ContentPackageType in content.xbx is required to be 10 hex digits");
                    packageInfo.ContentTypeID = uint.Parse(xbxIni.GetSetting(Ini.SectionAll, Ini.ContentPackageType).Substring(2, 8), NumberStyles.HexNumber);
                    packageInfo.ContentID = XICPackage.HexStringToByteArray(xbxIni.GetSetting(Ini.SectionAll, Ini.ContentIdSetting));
                    packageInfo.Platform = (byte)PlatformTypes.PC;
                    packageInfo.BaseVersion = uint.Parse(xbxIni.GetSetting(Ini.SectionAll, Ini.BaseVersionSetting).Substring(2, 8), NumberStyles.HexNumber);
                    packageInfo.UpdateVersion = uint.Parse(xbxIni.GetSetting(Ini.SectionAll, Ini.UpdateVersionSetting).Substring(2, 8), NumberStyles.HexNumber);

                    if (String.IsNullOrEmpty(xbxIni.GetSetting(Ini.SectionAll, Ini.InstallSizeSetting)))
                    {
                        packageInfo.InstallSize = 0;
                    }
                    else
                    {
                        packageInfo.InstallSize = long.Parse(xbxIni.GetSetting(Ini.SectionAll, Ini.InstallSizeSetting));
                    }

                    FileInfo fileInfo = new FileInfo(packageBuilder.Path);
                    packageInfo.PackageSize = fileInfo.Length;
                    // Keys are not used for GFWL packages
                    packageInfo.SymmetricKey = new byte[0];
                    packageInfo.PublicKey = new byte[0];

                    XICPackage package = new XICPackage(packageInfo, packageBuilder.Path);
                    // set that we want the package to be distributed with the original file name
                    package.SaveAsFileName = Path.GetFileName(packageBuilder.Path);
                    package.VersionFlag = versionFlag;

                    builtContentPackages = new XICPackage[] { package };

                    XICDistributer Distributer = new XICDistributer();

                    if (!Distributer.DistributePackage(package, OverwriteFlag))
                    {
                        Console.WriteLine("ERROR: Package distribution failed");
                        return false;
                    }
                }
                else
                {
                    BuildMethods buildMethod = BuildMethods.StfImageExeNoTimeStampAvatarMarketplace; // default for all types

                    // override for Uncompressed SVODs
                    if (isXPKG && PackageType == ContentPackageType.SvodUncompressed)
                    {
                        buildMethod = BuildMethods.UnCompressedSvodImage;
                    }

                    result = packageBuilder.BuildPackage(
                        outputPath,
                        out builtContentPackages,
                        out builtContentFiles,
                        out builtRedirecteePackage,
                        out builtManifestFiles,
                        expectedTitleID,
                        xicExtensionSuffix,
                        buildMethod
                        );
                    if (false == result)
                    {
                        Console.WriteLine(
                            "ERROR: Build operation failed '{0}'.",
                            packageBuilder.Error
                            );
                        return false;
                    }

                    //Setting the versionFlag -- this is required for full/selective versioning of title updates
                    foreach (XICPackage Package in builtContentPackages)
                    {
                        Package.VersionFlag = versionFlag;

                        // If this is an installer package, sanity checks the
                        // manifests as well
                        if (Package.ContentType == XboxContentTypes.Installer)
                        {
                            // If we have some manifest files, try to process them first
                            if (builtManifestFiles != null && builtManifestFiles.Length > 0)
                            {
                                SystemManifest manifest = new SystemManifest(
                                    builtManifestFiles[0],
                                    Package.UpdateVersion
                                    );
                                if (manifest.ValidateManifest() == false)
                                {
                                    Console.WriteLine("ERROR: Manifest couldn't be validated");
                                    return false;
                                }
                            }
                        }
                    }


                    //Now push the packages to the DL servers
                    if (!XICParallelDistributer.DistributePackages(builtContentPackages, OverwriteFlag))
                    {
                        Console.WriteLine("ERROR: Package distribution failed");
                        return false;
                    }
                }

                //Allow databases to be written to.
                if (!ContentInstaller(tag))
                {
                    return false;
                }

                //Displaying Package Information
                Console.WriteLine("Displaying Built Content Package Information.\n");
                for (int c = 0; c < builtContentPackages.Length; c++)
                {
                    Console.WriteLine("Package ({0}/{1})\n{2}\nContentID:\n{3}\n\n",
                            c + 1, builtContentPackages.Length, "".PadLeft(79, '*'), builtContentPackages[c].ContentIDString);
                }

            }
            catch (Exception e)
            {
                Console.WriteLine("EXCEPTION: {0}\n\n{1}\n", e.Message, e.StackTrace);
                XICParallelDistributer.DestroyPackages(builtContentPackages);
                return false;
            }

            return true;
        }

        void ContentInstallerWorkerThread()
        {
            string tag = "Installer";

            if (ContentInstaller(tag))
            {
                Console.WriteLine("SUCCESS: Content installer updater finished normally");
            }
            else
            {
                Console.WriteLine("FAILED : Content installer encountered errors");
            }
        }

        bool ContentInstaller(string tag)
        {
            PackageInstaller Installer;
            string targetFile;
            string titleRoot = TitleVault.GetTitleVaultRootPath(expectedTitleID);

            uint count = 0;
            foreach (XICPackage Package in builtContentPackages)
            {
                Installer = PackageInstallerLogic.GetInstaller(Package);

                Console.WriteLine("Installing content package {0} of {1}...",
                    count + 1, builtContentPackages.Length);


                AvatarItemInstaller avatarItemInstaller = Installer as AvatarItemInstaller;
                if (avatarItemInstaller != null)
                {
                    if (string.IsNullOrEmpty(this.avatarAssetIdSetting))
                    {
                        Console.WriteLine("ERROR: AvatarItem package is missing a valid Avatar Asset Id setting in the content.xbx of the package.");
                        return false;
                    }

                    try
                    {
                        avatarItemInstaller.AvatarAssetId = new Guid(this.avatarAssetIdSetting);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("ERROR: AvatarItem package has an invalid Avatar Asset Id in the content.xbx of the package. " + e);
                        return false;
                    }
                }

                if (!Installer.Install(Package, builtContentFiles, builtRedirecteePackage, builtManifestFiles))
                {
                    Console.WriteLine("FAILED: could not prop content to uodb");
                    return false;
                }

                //
                // Update .Offer file.  One Offer File per Content Package
                //
                if (offerPath.Length > count && offerPath[count] != null)
                {
                    LiveOffer lo = GetOffer(offerPath[count], offerID[count], defaultOffer, Package.ContentType);
                    if (!UpdateOffer(ref lo, expectedTitleID, offerID[count], defaultOffer, Package, Installer.GameContentMediaId, BuildCategories(Installer), this.updateContentId))
                    {
                        Console.WriteLine("ERROR: could not update offer {0}", offerPath[count]);
                        return false;
                    }
                    OfferUtil.StoreOffer(lo, offerPath[count]);
                }
                else if (useDefaultOffer)
                {
                    LiveOffer lo;

                    if (Package.ContentType == XboxContentTypes.GameTrailer || Package.ContentType == XboxContentTypes.Video)
                    {
                        Console.WriteLine("FAILED:  /useDefaultOffer option is not supported for Videos or Game Trailers.");
                        return false;
                    }

                    offerID[count] = Package.OfferID;
                    string defaultOfferPath = Path.Combine(Path.GetDirectoryName(packageBuilder.Path), "0x" + Path.GetFileNameWithoutExtension(packageBuilder.Path) + ".offer");

                    //  Look in titlevault for a previously submitted offer

                    string[] offerFiles = Directory.GetFiles(titleRoot, "0x" + Path.GetFileNameWithoutExtension(packageBuilder.Path) + "*.offer");
                    if (offerFiles.Length > 1)
                    {
                        Console.WriteLine("FAILED: found multiple OFFER files in titlevault that could be used with this CAB.");
                        return false;
                    }
                    else if (offerFiles.Length == 1)
                    {
                        lo = OfferUtil.LoadOffer(offerFiles[0]);
                        CopyOfferImages(lo, Path.GetDirectoryName(offerFiles[0]), Path.GetDirectoryName(packageBuilder.Path));
                        Console.WriteLine("Using offer file from titlevault: {0}", offerFiles[0]);
                    }
                    else
                    {
                        lo = SelectDefaultOfferFile(Package.ContentType);
                        CopyOfferImages(lo, DefaultOffersDir, Path.GetDirectoryName(packageBuilder.Path));
                        Console.WriteLine("Created default offer file: {0}", defaultOfferPath);
                    }

                    if (!UpdateOffer(ref lo, expectedTitleID, offerID[count], true, Package, Installer.GameContentMediaId, BuildCategories(Installer)))
                    {
                        Console.WriteLine("ERROR: could not update offer {0}", defaultOfferPath);
                        return false;
                    }

                    OfferUtil.StoreOffer(lo, defaultOfferPath);

                }

                count++;
            }

            //
            //  If everything's still cool at this point, we can go ahead and push the files
            //  into title vault
            //
            //  Package file will be renamed as [OfferID]_[ContentID].cab (if there is an offer and a Content Id)
            //  or [OfferID]_[Input cab filename]
            //  or [ContentID].cab (for 360 title updates)
            //  or [Input cab filename] (for PC title updates)
            //

            count = 0; // reset
            foreach (XICPackage Package in builtContentPackages)
            {
                string contentIdString = Package.ContentIDString;

                // only use content Id if its valid
                if (!String.IsNullOrEmpty(contentIdString) && (contentIdString != "0000000000000000000000000000000000000000"))
                {
                    targetFile = Package.ContentIDString + ".cab";
                }
                else
                {
                    targetFile = Path.GetFileName(packageBuilder.Path);
                }

                // Prepend said CAB-name with XOID, for TitleVault, if possible
                if (offerID.Length > count && offerID[count] != 0)
                {
                    targetFile = offerID[count].ToString("X") + "_" + targetFile;
                }

                // Copy into TitleVault
                if ((Package.ContentType != XboxContentTypes.Xbox360Title)
                    && (Package.ContentType != XboxContentTypes.XboxTitle))
                {
                    if (!Directory.Exists(titleRoot))
                        Directory.CreateDirectory(titleRoot);

                    TitleVault.TitleVaultCopy(titleRoot,
                        packageBuilder.Path,
                        targetFile);
                }

                count++;
            }

            return true;
        }


        CategoryCollection BuildCategories(PackageInstaller installer)
        {
            //Avatar cabs may include a Categories.csv file that will 
            //contain AvatarExtended category information
            //We will invoke crackcab.dll to pull this information out.
            CategoryCollection builtCategoryCollection = new CategoryCollection();
            string categoriesCsvPath = Path.Combine(outputPath, CategoriesFileName);

            if (File.Exists(categoriesCsvPath))
            {
                LiveContentCategoriesCsv csvCategories = new LiveContentCategoriesCsv(categoriesCsvPath);

                foreach (string value in csvCategories.CsvValues)
                {
                    Category cat = new Category();
                    cat.externalType = 0;  //No Mapping for AvatarExtended Categories

                    try
                    {
                        cat.categoryId = uint.Parse(value);
                    }
                    catch (FormatException)
                    {
                        throw new Exception(string.Format("invalid categoryId: {0} - verify category value", cat.categoryId));
                    }

                    builtCategoryCollection.Add(cat);
                }
            }

            AvatarItemInstaller avatarItemInstaller = installer as AvatarItemInstaller;
            if (avatarItemInstaller != null)
            {
                Category subcategoryMask = new Category();
                subcategoryMask.categoryId = avatarItemInstaller.SubcategoryMask;
                subcategoryMask.externalType = (uint)CatalogWebService.CatalogConstants.ExternalFeedMappingObjectAvatarCategory;
                builtCategoryCollection.Add(subcategoryMask);

                Category bodyMask = new Category();
                bodyMask.categoryId = avatarItemInstaller.BodyMask;
                bodyMask.externalType = (uint)CatalogWebService.CatalogConstants.ExternalFeedMappingObjectAvatarBodyType;
                builtCategoryCollection.Add(bodyMask);
            }

            return builtCategoryCollection;
        }
        #endregion

        static void Usage()
        {
            Console.WriteLine(usageText);
        }

        [STAThread]
        static int Main(string[] args)
        {
            try
            {
                LiveContentTool contentTool;
                // allows Events / logging to work...
                XomLoggingControl.Init();

                try
                {
                    NamedArgParser argParser = new NamedArgParser(namedArgumentList);

                    #region Validate commandline args

                    // Parse any command line arguments, returns false if there are extras
                    if (!argParser.Parse(args))
                    {
                        if (String.IsNullOrEmpty(argParser.InvalidArgText))
                        {
                            Usage();
                        }
                        else
                        {
                            Console.WriteLine("Unrecognized or duplicate argument \"" + argParser.InvalidArgText + "\".  Run \"LiveContent.exe /?\" for usage information.");
                        }
                        return -1;
                    }

                    // Did the user request usage information?
                    //task: should I just log all the stuff, and output a single string at the end?
                    if (0 == argParser.Count || null != argParser["?"])
                    {
                        Usage();
                        return 0;
                    }

                    #endregion

                    contentTool = new LiveContentTool();

                    return contentTool.Execute(argParser);
                }
                finally
                {
                    XomLoggingControl.Close();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("LiveContent encountered an exception.  Details follow:\r\n");
                Console.WriteLine(e.ToString());
                return -1;
            }
        } // main

    } // deploy title

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_liveoffer_none_12.4.56.0_none_517e47296679f648
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=liveoffer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.manifest
XP_MANIFEST_PATH=manifests\x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.cat
XP_CATALOG_PATH=manifests\x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.cat
XP_PAYLOAD_PATH=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=liveoffer,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_liveoffer_none_12.4.56.0_none_517e47296679f648
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=liveoffer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.manifest
XP_MANIFEST_PATH=manifests\x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.cat
XP_CATALOG_PATH=manifests\x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6.cat
XP_PAYLOAD_PATH=x86_liveoffer_no-public-key_12.4.56.0_x-ww_3698b2e6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=liveoffer,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\leaderboard\leaderboard.cs ===
using System;
using System.Collections;


namespace Microsoft.Ems.Tools.LiveTitle
{
    public enum LbType
    {
        Regular,
        Competition
    }


    // Copied from \server\stats\lbs\lb.h
    public enum LbResetType
    {
        LbResetTypeNever         = 0,
        LbResetTypeWeekly        = 1,
        LbResetTypeMonthly       = 2,
        LbResetTypeBimonthly     = 3,
        LbResetTypeQuarterly     = 4,
        LbResetTypeSemiannually  = 5,
        LbResetTypeAnnually      = 6
    }

    // contains all NPDB settings about leaderboards
    // lots more info is in XLAST that we don't need while configuring the service
    public class LeaderboardSettings
    {
        public LbType   Type;                   // leaderboard type

        public string   LBServer;
        public uint     TitleID;                // titleid
        public int      LeaderboardID;          // LB id
//        public string FriendlyName;           // friendlyName
        public byte     ResetType;              // bResetType
        public int      MaxAttachments;         // iAttCount,  == maxAttachments
        public int      MaxAttachmentSize;      // iMaxAttSize, == maxAttachmentSize
        public int      DecayDays;              // entryExpiration or iDecayDays
        public int      TopEntries;             // iMaxRatCount, == topEntries;; 1 or 0 for Xenon M3
        public string   EloE;                   // Elo settings... still needed for Xbox 1 back-compat
        public int      EloK;                   //
        public int      EloNew;                 //
        public string   EloCtable;              //
        public bool     TeamView;               // IsTeam,
        public bool     Arbitrated;             // bReqArbitration
        public DateTime LastReset;              // Last reset date for this leaderboard

        // WebDB stuff
        public LocalizedDescription[] Descriptions = new LocalizedDescription[0];    // list of leaderboard descriptions
        public RawAttribute[]         RawAttributes = new RawAttribute[0];   // list of raw attributes
        public LbColumn[]             Columns = new LbColumn[0];         // list of column formats

        public const string UnknownServer = "Unknown";

        public LeaderboardSettings()
        {
            //task: constructor need to do anything?
        }

        public LeaderboardSettings( string lbserver, uint titleID, int leaderboardID, byte resetType, int maxAttchments, int maxAttchmentSize,
                            int decayDays, int topEntries, bool isTeamView, bool isArbitrated, DateTime lastReset )
        {
            //somewhere, there's a .Net style guide author who's very happy to see this use of casing...
            Type = LbType.Regular;
            LBServer = lbserver;
            TitleID = titleID;
            LeaderboardID = leaderboardID;
            ResetType = resetType;
            MaxAttachments = maxAttchments;
            MaxAttachmentSize = maxAttchmentSize;
            DecayDays = decayDays;
            TopEntries = topEntries;
            TeamView = isTeamView;
            Arbitrated = isArbitrated;
            LastReset = lastReset;
            EloE = "10";
            EloK = 100;
            EloNew = 500;
            EloCtable = "0:40";
        }

        public LeaderboardSettings( string lbserver, uint titleID, int leaderboardID, byte resetType, int maxAttchments, int maxAttchmentSize,
                            int decayDays, string eloE, int eloK, int eloNew, string eloCtable,
                            int topEntries, bool isTeamView, bool isArbitrated, DateTime lastReset )
        {
            Type = LbType.Regular;

            //somewhere, there's a .Net style guide author who's very happy to see this use of casing...
            LBServer = lbserver;
            TitleID = titleID;
            LeaderboardID = leaderboardID;
            ResetType = resetType;
            if ( eloE.Length > 2 )
            {
                throw new ArgumentException( "EloE value can only be 2 characters long" );
            }
            EloE = eloE;
            EloK = eloK;
            EloNew = eloNew;
            EloCtable = eloCtable;
            MaxAttachments = maxAttchments;
            MaxAttachmentSize = maxAttchmentSize;
            DecayDays = decayDays;
            TopEntries = topEntries;
            TeamView = isTeamView;
            Arbitrated = isArbitrated;
            LastReset = lastReset;
        }

    } //leaderboard

    public class LbColumn
    {
        public string Name;
        public int ReturnType;
        public string Formula;
        public LocalizedDescription[] Descriptions;

        // xlast fields
        public uint AttributeId;
        public uint PropertyId;
        public string Aggregation;

        public LbColumn(string szNameIn, uint attributeIdIn, string FormulaIn)
        {
            Name = szNameIn;
            AttributeId = attributeIdIn;
            Formula = FormulaIn;
        }

        public LbColumn()
        {
            
        }
    }

    public class LocalizedDescription
    {
        public string Locale;
        public string Description;

        public LocalizedDescription(string LocaleIn, string DescriptionIn)
        {
            Locale = LocaleIn;
            Description = DescriptionIn;
        }

        public LocalizedDescription()
        {
            
        }
    }

    public class RawAttribute
    {
        public int  Index;
        public bool IsPuid;
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_livetitle_none_12.4.56.0_none_541e73b0e41d0226
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.manifest
XP_MANIFEST_PATH=manifests\x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.cat
XP_CATALOG_PATH=manifests\x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.cat
XP_PAYLOAD_PATH=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetitle,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\GameHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using System.Data.SqlClient;
using System.Collections;
using System.Globalization;
using System.IO;
using Microsoft.Ems.Tools.LiveTools.Common;
using Microsoft.Ems.Tools.LiveTools.Common.Utilities;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.title;
using xonline.common.xlastutil;

namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// Helper class for all Game related operations on EMS CatalogDB
    /// </summary>
    public static class GameHelper
    {
        static GameHelper()
        {
            // before we do any operations with the Catalog webservice, set the right url for this environment

            IVirtualInterfaceInfo virtualInterface = null;

            try
            {
                virtualInterface = Config.GetVirtualInterface(VirtualInterface.contentIngestion, Site.main);
            }
            catch (ApplicationException) // this is thrown if the setting doesn't exist
            {
            }

            if ((virtualInterface != null)
                && !String.IsNullOrEmpty(virtualInterface.Url.AbsoluteUri)
                && !String.IsNullOrEmpty(virtualInterface.VDir))
            {
                CatalogServicesInternal.Init();
                CatalogServices.Catalog.Url = virtualInterface.Url.AbsoluteUri + virtualInterface.VDir + "/CatalogServices.asmx";
            }
        }

        public static bool CheckReadyCatalogDB(out string output)
        {
            string url = CatalogServices.Catalog.Url;

            try
            {
                CatalogServices.Catalog.GetLocale();
                output = "CatalogDB ready.";
                return true;
            }
            catch(Exception e)
            {
                output = String.Format("Exception when using URL='{0}' {1}", url, e.Message);
                return false;
            }
        }
        
        /// <summary>
        /// Helper method that will create or update a Game entry in CatalogDB
        /// from the specified information
        /// </summary>
        /// <param name="liveTitleID">This is the identifier for a Game Title</param>
        /// <param name="titleType">This is the type of game title being added</param>
        /// <param name="consoleTypes">These are the supported consoles for the game. Each console will be a new media entry.</param>
        /// <param name="localizedStrings">This class contains the locale specific strings used by this game.</param>
        /// <param name="stringLibrary">This utility class is used to get the mapped locales from UODB</param>
        /// <param name="pi">This class contains information about the game.</param>
        /// <param name="isMarketplaceProject">True if this is a marketplace only project or False if its a full game project</param>
        /// <param name="procInfo">Contains trace information</param>
        /// <param name="images">Contains the images associated with this title<param>
        /// <param name="xlastPath">Path to xlast input file</param>
        public static void CreateGame(
            uint liveTitleID, 
            ulong titleType, 
            ConsoleTypeEnum[] consoleTypes, 
            LocalizedStrings localizedStrings,
            StringLibrary stringLibrary, 
            ProductInformation pi,
            bool isMarketplaceProject, 
            ref StringBuilder procInfo, 
            Images images, 
            string xlastPath)
        {
            if (consoleTypes == null)
                throw new ArgumentNullException("consoleTypes");
            if (localizedStrings == null)
                throw new ArgumentNullException("localizedStrings");
            if (pi == null)
                throw new ArgumentNullException("pi");
            
            // CatalogDB doesn't need Demo Titles
            if (titleType == TitleTypeDemo)
            {
                Console.WriteLine("Title {0} will not be added as a Game to CatalogDB because it is marked with TitleType = Demo.");
                return;
            }

            ushort publisher = GameIdMapping.GetPublisher(liveTitleID);
            int providerId = GetProviderIdByExternalId(localizedStrings, publisher.ToString("X4"), pi.publisherStringId);

            foreach (ConsoleTypeEnum consoleType in consoleTypes)
            {
                Guid gameId = GameIdMapping.GetGuidForGame((int)consoleType, liveTitleID);

                Console.WriteLine("   Adding title {0} with console type {1}({2}) as Game.",
                    liveTitleID.ToString("x8"), ((int)consoleType), consoleType.ToString());

                // Create Game
                Game game = CatalogServices.Catalog.GetGame(gameId);
                if (game == null)
                {
                    game = new Game();
                    game.Id = gameId;
                    game.Modified = InsertDataChangeType.Add;
                }
                else
                {
                    game.Modified = InsertDataChangeType.Update;
                }

                game.LiveTitleId = (int)liveTitleID;
                game.MediaTypeId = GetGameMediaType(titleType, consoleType, publisher, isMarketplaceProject, pi.Genre);
                game.MetadataProviderId = providerId;
                game.VisibilityStatusId = CatalogConstants.VisibilityStatusLive;
                game.VisibilityDate = CatalogConstants.VisibilityDateForGameMedia;
                game.GeoCheckPolicy = false;

                // Create Game and Media Locales
                CreateGameLocales(localizedStrings, stringLibrary, pi.sellTextStringId, pi.genreTextStringId, pi.developerStringId,pi.publisherStringId, game);

                // Create Media Ratings
                game.RatingValues = CreateGameRatings(pi, game);

                // Create Media Categories
                game.Categories = CreateGameCategories(localizedStrings,pi, publisher, game);                

                // Create Media Contributors
                game.Contributors = CreateGameContributors(game.MediaTypeId, pi, game.GameLocales, game.Locales);

                // Inserting images into CatalogDB
                SaveImages(images, xlastPath, liveTitleID, game);

                CatalogServices.Catalog.SaveGame(game);

                Console.WriteLine("   Game {0} Added Completed", gameId.ToString());
            }
        }

        private static void SaveImages(Images images, string xlastPath, uint liveTitleID, Media gameMedia)
        {
            string titleRoot = LiveTitle.TitleVaultDir(liveTitleID, false);
            FileInfo xlastFileInfo = new FileInfo(xlastPath);
            string localPath = xlastFileInfo.Directory.FullName;
            if ((null != images) && (null != images.Image))
            {
                foreach (xonline.common.xlastutil.Image img in images.Image)
                {
                    // Only ingest icon images and marketplace images
                    if (img.id == IconIdGame || img.id == IconIdMarketplace)
                    {
                        //bug 44000 - system titles can have an empty path
                        if (String.IsNullOrEmpty(img.Path))
                        {
                            Console.WriteLine("   --> Empty image path encountered. This is only ok for System titles.");
                        }
                        else
                        {
                            FileInfo imgPath = new FileInfo(img.Path);
                            string imageLocation = Path.Combine(xlastPath, imgPath.Name);
                            if (File.Exists(imageLocation))
                            {
                                // toDir is where the image will be copied to
                                string toDir = Path.Combine(titleRoot, imgPath.Name);
                                // url is the fileUrl to be used in the catalog for this image
                                string url = null;

                                switch (img.id)
                                {
                                    case IconIdGame:
                                        // game icon (64x64):    //global/t:<titleid>/icon/0/8000
                                        url = String.Format("{0}{1}/icon/0/8000", ImageInserter.BaseUrlForImages, liveTitleID.ToString("x"));
                                        break;
                                    case IconIdMarketplace:
                                        // mktplc icon (420x95):  //global/t:<titleid>/marketplace/0/1
                                        url = String.Format("{0}{1}/marketplace/0/1", ImageInserter.BaseUrlForImages, liveTitleID.ToString("x"));
                                        break;
                                }

                                if (String.IsNullOrEmpty(url))
                                    throw new Exception(String.Format("Error - Url for Image {0} is required to be added to CatalogDB.", img.Path));
                                
                                ImageInserter.InsertImage(imageLocation, toDir, url, liveTitleID, img.id, 0, gameMedia);
                            }
                            else
                            {
                                Console.WriteLine("      Serious Error - image file |" + localPath + "\\" + imgPath.Name + " not found! ");
                            } //file exist

                        } // file not blank
                    }

                } //foreach image

            } //if images exist
            else
            {
                Console.WriteLine("   No images found in XLAST file, this could be a problem!");
            }
        }

        private static int GetProviderIdByExternalId(LocalizedStrings localizedStrings, string externalId, ushort publisherStringId)
        {
            // Check for entity/provider mapping
            int catalogId = CatalogServices.Catalog.GetCatalogId(externalId, CatalogConstants.ExternalFeedSourceIdLiveTools, CatalogConstants.ExternalFeedMappingObjectEntity);

            if (catalogId == -1)
            {
                Dictionary<string, int> localeLookup = MediaLocaleHelper.CreateLocaleLookupTable();

                string englishLocalePublisherName = string.Empty;
                foreach (LocalizedString localizedString in localizedStrings.LocalizedString)
                {
                    // Only interested in publisher localized strings
                    if (localizedString.id == publisherStringId)
                    {
                        foreach (Translation translation in localizedString.Translation)
                        {
                            int lcid = 0;
                            // add special case that is also in the tools
                            if (translation.locale == LocaleCodeChineseTraditional)
                                lcid = zhTWLcid;
                            else if (localeLookup.ContainsKey(translation.locale))
                                lcid = localeLookup[translation.locale];

                            if (lcid == CatalogConstants.LcidUs)
                            {
                                englishLocalePublisherName = translation.Value;
                                break;
                            }
                        }

                        // if we get to this point with no publisher string
                        // that means that there was no english translation,
                        // so pick the first translation since it is required
                        if (String.IsNullOrEmpty(englishLocalePublisherName))
                        {
                            foreach (Translation translation in localizedString.Translation)
                            {
                                if (!String.IsNullOrEmpty(translation.Value))
                                {
                                    englishLocalePublisherName = translation.Value;
                                    break;
                                }
                            }
                        }

                        break;
                    }
                }

                if (String.IsNullOrEmpty(englishLocalePublisherName))
                {
                    throw new ArgumentException("Publisher Name is missing from file and it is required for CatalogDB.");
                }

                Entity e = new Entity();
                e.ExternalEntityId = externalId;
                e.Id = catalogId = CatalogServices.Catalog.GetAvailableEntityId();
                e.IsProvider = true;
                e.Name = englishLocalePublisherName;
                e.Modified = DataChangeType.Add;
                CatalogServices.Catalog.SaveEntity(e);

                ExternalFeedMapping feedMapping = new ExternalFeedMapping();
                feedMapping.ExternalId = externalId;
                feedMapping.ExternalFeedSourceId = CatalogConstants.ExternalFeedSourceIdLiveTools;
                feedMapping.ExternalFeedmappingObjectId = CatalogConstants.ExternalFeedMappingObjectEntity;
                feedMapping.CatalogId = catalogId; // Use the categoryId we just created
                feedMapping.Modified = DataChangeType.Add;
                CatalogServices.Catalog.SaveExternalFeedMapping(feedMapping);
            }

            return catalogId;
        }

        private static MediaContributor[] CreateGameContributors(int gameMediaTypeId, ProductInformation pi, GameLocale[] gameLocales, MediaLocale[] locales)
        {        
            if (pi == null)
                throw new ArgumentNullException("pi");
            if (gameLocales == null)
                throw new ArgumentNullException("gameLocales");
            if (locales == null)
                throw new ArgumentNullException("locales");

            MediaContributor[]  contributors = null;
            
            if ((gameMediaTypeId == CatalogConstants.MediaTypeCommunityGame) && (pi.creatorContributorId != null))
            {
                Guid contributorId = new Guid(pi.creatorContributorId);

                // Upsert contributor
                Contributor contributor = CatalogServices.Catalog.GetContributor(contributorId);
                DataChangeType modified;
                if (contributor == null)
                {
                    contributor = new Contributor();
                    contributor.Id = contributorId;
                    modified = DataChangeType.Add;
                }
                else
                {
                    modified = DataChangeType.Update;
                }

                contributor.MetadataProviderId = CatalogConstants.ProviderMicrosoft;
                contributor.Locales = CreateContributorLocales(gameLocales, locales);
                contributor.Modified = modified;
                CatalogServices.Catalog.SaveContributor(contributor);

                // add MediaContributor
                MediaContributor mediaContributor = new MediaContributor();
                mediaContributor.Modified = DataChangeType.Add;
                mediaContributor.ContributorId = contributorId;
                mediaContributor.RoleId = CatalogConstants.RoleCreator;
                mediaContributor.SortOrder = 1;
                mediaContributor.IsPrimary = true;
                mediaContributor.Character = CatalogConstants.ContributorCharacterForCommunityGame;

                contributors = new MediaContributor[] { mediaContributor };
            }

            return contributors;
        }

        private static ContributorLocale[] CreateContributorLocales(GameLocale[] gameLocales, MediaLocale[] locales)
        {
            if (gameLocales == null)
                throw new ArgumentNullException("gameLocales");
            if (locales == null)
                throw new ArgumentNullException("locales");

            Dictionary<int, string> dictionaryDevelopers = new Dictionary<int, string>(gameLocales.Length);

            foreach (GameLocale gameLocale in gameLocales)
            {
                dictionaryDevelopers[gameLocale.Lcid] = gameLocale.Developer;
            }

            List<ContributorLocale> contributorLocales = new List<ContributorLocale>(locales.Length);

            for (int i = 0; i < locales.Length; i++)
            {
                if ((locales[i].Modified == DataChangeType.Add) || (locales[i].Modified == DataChangeType.Update))
                {
                    ContributorLocale contributorLocale = new ContributorLocale();
                    contributorLocale.Modified = DataChangeType.Add;
                    contributorLocale.Lcid = locales[i].Lcid;

                    if (dictionaryDevelopers.ContainsKey(contributorLocale.Lcid))
                    {
                        contributorLocale.DisplayName = contributorLocale.SortName = dictionaryDevelopers[contributorLocale.Lcid];
                    }
                    else
                    {
                        contributorLocale.DisplayName = contributorLocale.SortName = String.Empty;
                    }

                    contributorLocale.TargetingLocales = new ContributorLocaleMap[locales[i].MappedLcids.Length];
                    for (int j = 0; j < locales[i].MappedLcids.Length; j++)
                    {
                        contributorLocale.TargetingLocales[j] = new ContributorLocaleMap();
                        contributorLocale.TargetingLocales[j].Modified = DataChangeType.Add;
                        contributorLocale.TargetingLocales[j].Lcid = locales[i].MappedLcids[j].Lcid;
                    }

                    contributorLocales.Add(contributorLocale);
                }
            }

            return contributorLocales.ToArray();
        }

        private static MediaCategory[] CreateGameCategories(LocalizedStrings localizedStrings, ProductInformation pi, ushort publisherId, Game game)
        {           
            // we need to create MediaCategories for genres
            Dictionary<int, MediaCategory> dictionaryCategories = new Dictionary<int, MediaCategory>();

            if (game.Categories != null)
            {
                foreach (MediaCategory mediaCategory in game.Categories)
                {
                    mediaCategory.Modified = DataChangeType.Delete;
                    dictionaryCategories.Add(mediaCategory.CategoryId, mediaCategory);
                }
            }

            #region add/update categories for Genre

            //---------------------------------------------------------------------
            // Now create record(s) for the genre's found in the ProductInformation
            // NOTE: There's a corner case where NO genre's are specified, in which 
            // case the pi.Genre collection won't exist (will be null instead of 
            // being empty) so we must protect the loop below.  
            // 
            if ((pi != null) && (pi.Genre != null))
            {
                foreach (Genre genre in pi.Genre)
                {
                    int categoryId = GetGenreCategoryId(genre.genreId);

                    if (categoryId == 0)
                        continue; // if categoryId is 0 it means we should ignore it in CatalogDB

                    MediaCategory category = null;

                    if (dictionaryCategories.ContainsKey(categoryId))
                    {
                        category = dictionaryCategories[categoryId];
                        category.Modified = DataChangeType.Update;
                    }
                    else
                    {
                        category = new MediaCategory();
                        category.Modified = DataChangeType.Add;
                        category.CategoryId = categoryId;
                        dictionaryCategories.Add(categoryId, category);
                    }
                }
            }

            #endregion

            #region add/update category for game publisher

            Dictionary<string, int> localeLookup = MediaLocaleHelper.CreateLocaleLookupTable();

            // Get the categoryId associated with this publisher
            int catalogId = CatalogServices.Catalog.GetCatalogId(Convert.ToString(publisherId, 16), CatalogConstants.ExternalFeedSourceIdLiveTools, CatalogConstants.ExternalFeedMappingObjectCategory);
            
            // A catalogId of -1 impllies that it does not yet exist in the cataog. Need to create it.
            if (catalogId == -1)
            {
                // Get a new category ID
                catalogId = CatalogServices.Catalog.GetAvailableCategoryId();

                // Create the locales and the locale maps for all the localized strings
                Dictionary<int, CategoryLocale> dictionaryCategoryLocales = new Dictionary<int, CategoryLocale>();
                Dictionary<int, CategoryLocaleMap> dictionaryCategoryLocaleMaps = new Dictionary<int, CategoryLocaleMap>();
                // now go through all translations and add them to the category locale list
                foreach (LocalizedString localizedString in localizedStrings.LocalizedString)
                {
                    // Only interested in publisher localized strings
                    if (localizedString.id == pi.publisherStringId)
                    {
                        foreach (Translation translation in localizedString.Translation)
                        {
                            int lcid;

                            // add special case that is also in the tools
                            if (translation.locale == LocaleCodeChineseTraditional)
                                lcid = zhTWLcid;
                            else
                                lcid = localeLookup[translation.locale];


                                                        
                            // Create/add new locale to the list
                            CategoryLocale cl = new CategoryLocale();
                            cl.Lcid = lcid;
                            cl.Modified = DataChangeType.Add;
                            cl.Name = translation.Value;
                            dictionaryCategoryLocales[lcid] = cl;

                            // Map all locales that exist back to its translation
                            CategoryLocaleMap clm = new CategoryLocaleMap();
                            clm.FromLcid = lcid;
                            clm.ToLcid = lcid;
                            clm.Modified = DataChangeType.Add;
                            dictionaryCategoryLocaleMaps[lcid] = clm;
                        }
                    }
                }

                // Ensure that each locale is mapped
                Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale[] locales = CatalogServices.Catalog.GetLocale();
                foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale locale in locales)
                {
                    if (!dictionaryCategoryLocaleMaps.ContainsKey(locale.LCID))
                    {
                        CategoryLocaleMap clm = new CategoryLocaleMap();
                        clm.FromLcid = locale.LCID;
                        clm.ToLcid = CatalogConstants.LcidUs;
                        clm.Modified = DataChangeType.Add;
                        dictionaryCategoryLocaleMaps[locale.LCID] = clm;
                    }
                }

                // Fill in the rest and save
                Category c = new Category();
                CategoryLocaleMap[] categoryLocaleMaps = new CategoryLocaleMap[dictionaryCategoryLocaleMaps.Count];
                dictionaryCategoryLocaleMaps.Values.CopyTo(categoryLocaleMaps, 0);
                c.CategoryLocaleMap = categoryLocaleMaps;
                c.CategorySystemId = CatalogConstants.CategorySystemPublisher;
                c.Id = catalogId; // Use generated category Id
                CategoryLocale[] categoryLocales = new CategoryLocale[dictionaryCategoryLocales.Count];
                dictionaryCategoryLocales.Values.CopyTo(categoryLocales, 0);
                c.Locales = categoryLocales;
                c.ParentCategoryId = null; // No parent
                c.Modified = DataChangeType.Add;
                CatalogServices.Catalog.SaveCategory(c);

                // Construct and save the external mapping
                ExternalFeedMapping feedMapping = new ExternalFeedMapping();
                feedMapping.ExternalId = Convert.ToString(publisherId, 16);
                feedMapping.ExternalFeedSourceId = CatalogConstants.ExternalFeedSourceIdLiveTools;
                feedMapping.ExternalFeedmappingObjectId = CatalogConstants.ExternalFeedMappingObjectCategory;
                feedMapping.CatalogId = catalogId; // Use the categoryId we just created
                feedMapping.Modified = DataChangeType.Add;
                CatalogServices.Catalog.SaveExternalFeedMapping(feedMapping);
            }

            // create a MediaCategory
            MediaCategory newCategory = null;

            if (dictionaryCategories.ContainsKey(catalogId))
            {
                newCategory = dictionaryCategories[catalogId];
                newCategory.Modified = DataChangeType.Update;
            }
            else
            {
                newCategory = new MediaCategory();
                newCategory.Modified = DataChangeType.Add;
                newCategory.CategoryId = catalogId;
                dictionaryCategories.Add(catalogId, newCategory);
            }

            #endregion

            MediaCategory[] categories = new MediaCategory[dictionaryCategories.Count];
            dictionaryCategories.Values.CopyTo(categories, 0);
            return categories;
        }

        private static MediaRating[] CreateGameRatings(ProductInformation pi, Game game)
        {
            Dictionary<int, MediaRating> dictionaryRatings = new Dictionary<int, MediaRating>();

            if (game.RatingValues != null)
            {
                foreach (MediaRating mediaRating in game.RatingValues)
                {
                    mediaRating.Modified = DataChangeType.Delete;
                    dictionaryRatings.Add(mediaRating.RatingValueId, mediaRating);
                }
            }
            if (pi.Rating != null)
            {
                foreach (Rating rating in pi.Rating)
                {
                    int ratingId = GameIdMapping.GetRatingValueId(rating.ratingId, rating.ratingSystemId);
                    MediaRating mediaRating = null;

                    if (dictionaryRatings.ContainsKey(ratingId))
                    {
                        mediaRating = dictionaryRatings[ratingId];
                        mediaRating.Modified = DataChangeType.Update;
                    }
                    else
                    {
                        mediaRating = new MediaRating();
                        mediaRating.Modified = DataChangeType.Add;
                        mediaRating.RatingValueId = ratingId;
                        dictionaryRatings.Add(ratingId, mediaRating);
                    }

                    #region special case (bug 37096)
                    // double prop GRB and KMRB values
                    // this region can be deleted once console moves to only use GRB rating system
                    if ((15001 <= ratingId) && (ratingId <= 15004))
                    {
                        // will give a rating id between 11001 and 11004, which is KMRB
                        int kmrbRatingId = ratingId - 4000;

                        if (dictionaryRatings.ContainsKey(kmrbRatingId))
                        {
                            mediaRating = dictionaryRatings[kmrbRatingId];
                            mediaRating.Modified = DataChangeType.Update;
                        }
                        else
                        {
                            mediaRating = new MediaRating();
                            mediaRating.Modified = DataChangeType.Add;
                            mediaRating.RatingValueId = kmrbRatingId;
                            dictionaryRatings.Add(kmrbRatingId, mediaRating);
                        }
                    }
                    #endregion
                }
            }

            MediaRating[] ratings = new MediaRating[dictionaryRatings.Count];
            dictionaryRatings.Values.CopyTo(ratings, 0);
            return ratings;
        }

        private static void CreateGameLocales(LocalizedStrings localizedStrings, StringLibrary stringLibrary, ushort descriptionId, ushort customGenreId, ushort developerId, ushort publisherId, Game game)
        {            
            if (localizedStrings == null)
                throw new ArgumentNullException("localizedStrings");
            if (localizedStrings.SupportedLocale == null)
                throw new ArgumentException("LocalizedStrings object does not have a valid SupportedLocale property");
            if (game == null)
                throw new ArgumentNullException("game");

            #region gather data needed

            Dictionary<string, int> localeLookup = MediaLocaleHelper.CreateLocaleLookupTable();

            // LocalizedStrings organizes the translations by ID - Locale
            // but we need them to be in Locale - ID format, so use a temporary
            // structure to get them this way
            Dictionary<int,Dictionary<int, string>> translationsByLcidId = new Dictionary<int,Dictionary<int,string>>(localizedStrings.SupportedLocale.Length);

            // initialize for all the supported locales
            foreach (SupportedLocale supportedLocale in localizedStrings.SupportedLocale)
            {
                int lcid = -1;

                // add special case that is also in the tools
                if (supportedLocale.locale == LocaleCodeChineseTraditional)
                    lcid = zhTWLcid;
                else if (localeLookup.ContainsKey(supportedLocale.locale))
                    lcid = localeLookup[supportedLocale.locale];

                if (lcid == -1)
                    throw new ArgumentException(String.Format("SupportedLocale {0} does not exist in CatalogDB and needs to be added to support translations to that locale.", supportedLocale.locale));

                if (translationsByLcidId.ContainsKey(lcid))
                {
                    if (lcid != zhTWLcid)
                        throw new ArgumentException("Duplicate SupportedLocale " + supportedLocale.locale);
                }
                else
                {
                    translationsByLcidId.Add(lcid, new Dictionary<int, string>());
                }
            }

            // get the default locale
            int defaultLcid = (localizedStrings.defaultLocale == LocaleCodeChineseTraditional) ? zhTWLcid : localeLookup[localizedStrings.defaultLocale];

            // now go through all translations and add them to our dictionary
            foreach (LocalizedString localizedString in localizedStrings.LocalizedString)
            {
                foreach (Translation translation in localizedString.Translation)
                {
                    int lcid = -1;

                    // add special case that is also in the tools
                    if (translation.locale == LocaleCodeChineseTraditional)
                        lcid = zhTWLcid;
                    else if (localeLookup.ContainsKey(translation.locale))
                        lcid = localeLookup[translation.locale];

                    if (lcid == -1)
                        throw new ArgumentException(String.Format("Translation for locale {0} with ID = {1} is invalid because the locale does not exist in CatalogDB.", translation.locale, localizedString.id));

                    if (!translationsByLcidId.ContainsKey(lcid))
                        throw new ArgumentException(String.Format("Translation for locale {0} with ID = {1} is invalid because the locale is not a SupportedLocale.", translation.locale, localizedString.id));

                    if (translationsByLcidId[lcid].ContainsKey(localizedString.id) && (lcid != zhTWLcid))
                        throw new ArgumentException(String.Format("Duplicate ID {0} in LocalizedStrings.", localizedString.id));

                    translationsByLcidId[lcid][localizedString.id] = translation.Value;
                }
            }

            #endregion

            #region create GameLocales or MediaLocales

            Dictionary<int, MediaLocale> dictionaryMediaLocales = new Dictionary<int, MediaLocale>(translationsByLcidId.Count);
            if (game.Locales != null)
            {
                // fill the existing offer instances into the dictionary
                foreach (MediaLocale existingMediaLocale in game.Locales)
                {
                    existingMediaLocale.Modified = DataChangeType.Delete;
                    dictionaryMediaLocales.Add(existingMediaLocale.Lcid, existingMediaLocale);
                }
            }

            Dictionary<int, GameLocale> dictionaryGameLocales = new Dictionary<int, GameLocale>(translationsByLcidId.Count);
            if (game.GameLocales != null)
            {
                // fill the existing offer instances into the dictionary
                foreach (GameLocale existingGameLocale in game.GameLocales)
                {
                    existingGameLocale.Modified = DataChangeType.Delete;
                    dictionaryGameLocales.Add(existingGameLocale.Lcid, existingGameLocale);
                }
            }

            Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale[] locales = CatalogServices.Catalog.GetLocale();

            foreach (int lcid in translationsByLcidId.Keys)
            {
                MediaLocale mediaLocale;
                if (dictionaryMediaLocales.ContainsKey(lcid))
                {
                    mediaLocale = dictionaryMediaLocales[lcid];
                    mediaLocale.Modified = DataChangeType.Update;
                }
                else
                {
                    mediaLocale = new MediaLocale();
                    mediaLocale.Modified = DataChangeType.Add;
                    mediaLocale.Lcid = lcid;
                    dictionaryMediaLocales.Add(lcid, mediaLocale);
                }

                GameLocale gameLocale;
                if (dictionaryGameLocales.ContainsKey(lcid))
                {
                    gameLocale = dictionaryGameLocales[lcid];
                    gameLocale.Modified = DataChangeType.Update;
                }
                else
                {
                    gameLocale = new GameLocale();
                    gameLocale.Modified = DataChangeType.Add;
                    gameLocale.Lcid = lcid;
                    dictionaryGameLocales.Add(lcid, gameLocale);
                }
               
                if (translationsByLcidId[lcid].ContainsKey(customGenreId))
                    gameLocale.CustomGenre = translationsByLcidId[lcid][customGenreId];
                if (translationsByLcidId[lcid].ContainsKey(developerId))
                    gameLocale.Developer = translationsByLcidId[lcid][developerId];
                if (translationsByLcidId[lcid].ContainsKey(publisherId))
                    gameLocale.Publisher = translationsByLcidId[lcid][publisherId];

                if (translationsByLcidId[lcid].ContainsKey(LocalizedStringTitleNameId))
                {
                    MediaLocaleHelper.SetTitleProperties(mediaLocale, translationsByLcidId[lcid][LocalizedStringTitleNameId]);
                }

                if (translationsByLcidId[lcid].ContainsKey(descriptionId))
                {
                    MediaLocaleHelper.SetDescriptionProperties(mediaLocale, translationsByLcidId[lcid][descriptionId]);
                }
            }

            // create default GameLocales
            foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale locale in locales)
            {
                GameLocale gameLocale = null;

                if (!dictionaryGameLocales.ContainsKey(locale.LCID))
                {
                    gameLocale = new GameLocale();
                    gameLocale.Modified = DataChangeType.Add;
                    gameLocale.Lcid = locale.LCID;
                    dictionaryGameLocales.Add(locale.LCID, gameLocale);
                }
                else if (dictionaryGameLocales[locale.LCID].Modified == DataChangeType.Delete)
                {
                    gameLocale = dictionaryGameLocales[locale.LCID];
                    gameLocale.Modified = DataChangeType.Update;
                }

                if (gameLocale != null)
                {    
                    if (translationsByLcidId[defaultLcid].ContainsKey(customGenreId))
                        gameLocale.CustomGenre = translationsByLcidId[defaultLcid][customGenreId];
                    if (translationsByLcidId[defaultLcid].ContainsKey(developerId))
                        gameLocale.Developer = translationsByLcidId[defaultLcid][developerId];
                    if (translationsByLcidId[defaultLcid].ContainsKey(publisherId))
                        gameLocale.Publisher = translationsByLcidId[defaultLcid][publisherId];
                }
            }

            // set the MediaLocales and GameLocales arrays to the game object
            MediaLocale[] mediaLocales = new MediaLocale[dictionaryMediaLocales.Count];
            dictionaryMediaLocales.Values.CopyTo(mediaLocales, 0);
            game.Locales = mediaLocales;

            GameLocale[] gamelocales = new GameLocale[dictionaryGameLocales.Count];
            dictionaryGameLocales.Values.CopyTo(gamelocales, 0);
            game.GameLocales = gamelocales;

            MediaLocale defaultMediaLocale = null;
            // dictionary to keep track of which lcids are being mapped
            Dictionary<int, int> dictionaryMappedLcids = new Dictionary<int, int>();

            //adding MediaLocalMapsList to the MediaLocale which is also the default instance.
            foreach (MediaLocale mediaLocale in mediaLocales)
            {
                // only assign MediaLocaleMap to locales we are adding or updating
                if ((mediaLocale.Modified == DataChangeType.Add)
                    || (mediaLocale.Modified == DataChangeType.Update))
                {
                    if (defaultLcid == mediaLocale.Lcid)
                    {
                        defaultMediaLocale = mediaLocale;
                    }

                    List<MediaLocaleMap> mediaLocaleMapsList = new List<MediaLocaleMap>();

                    // try to get the right locale to map here
                    string localeCodeForLookup = (mediaLocale.Lcid == zhTWLcid) ? LocaleCodeChineseTraditional : mediaLocale.LocaleCode;

                    int uodbLanguageId = (int)stringLibrary.locales[localeCodeForLookup];

                    if (uodbLanguageId == 0)
                    {
                        // if the language Id is 0 in the string library
                        // that means those languages are not "live enabled"
                        // and those MediaLocales can only be mapped to themselves
                        // (more details see comments in StringLibrary.cs)
                        MediaLocaleMap mediaLocaleMap = new MediaLocaleMap();
                        mediaLocaleMap.Lcid = mediaLocale.Lcid;
                        mediaLocaleMap.Modified = DataChangeType.Add;
                        mediaLocaleMapsList.Add(mediaLocaleMap);

                        // keep track of which lcids are mapped
                        dictionaryMappedLcids.Add(mediaLocaleMap.Lcid, mediaLocaleMap.Lcid);
                    }
                    else
                    {
                        // get the mapped locales from the StringLibrary class
                        // these are derived from the supportedLocales info in the xlast and UODB
                        ArrayList mappedLocales = (ArrayList)stringLibrary.cultures[uodbLanguageId];
                        mediaLocale.MappedLcids = new MediaLocaleMap[mappedLocales.Count];

                        for (int i = 0; i < mappedLocales.Count; i++)
                        {
                            MediaLocaleMap mediaLocaleMap = new MediaLocaleMap();
                            mediaLocaleMap.Lcid = GameIdMapping.GetLcidFromUODBCultureId((int)mappedLocales[i]);
                            mediaLocaleMap.Modified = DataChangeType.Add;
                            mediaLocaleMapsList.Add(mediaLocaleMap);

                            // keep track of which lcids are mapped
                            dictionaryMappedLcids.Add(mediaLocaleMap.Lcid, mediaLocaleMap.Lcid);
                        }
                    }

                    mediaLocale.MappedLcids = mediaLocaleMapsList.ToArray();
                }
            }

            if (defaultMediaLocale != null)
            {
                //add unmapped locales to be mapped to the default locale
                List<MediaLocaleMap> mediaLocaleMapsList = new List<MediaLocaleMap>(defaultMediaLocale.MappedLcids);

                foreach (Locale locale in locales)
                {
                    if (!dictionaryMappedLcids.ContainsKey(locale.LCID))
                    {
                        MediaLocaleMap mediaLocaleMap = new MediaLocaleMap();
                        mediaLocaleMap.Lcid = locale.LCID;
                        mediaLocaleMap.Modified = DataChangeType.Add;
                        mediaLocaleMapsList.Add(mediaLocaleMap);
                    }
                }

                defaultMediaLocale.MappedLcids = mediaLocaleMapsList.ToArray();
            }

            #endregion
        }

        #region CatalogDB Mapping methods
       
        /// <summary>
        /// Gets the Catalog Genre Id based on UODB id
        /// </summary>
        /// <param name="genreId"></param>
        /// <returns></returns>
        private static int GetGenreCategoryId(uint genreId)
        {
            int catalogGenreId = -1;
            switch (genreId)
            {
                case 102000000:
                case 116010000:
                case 117010000:
                case 103000000:
                case 117020000:
                    catalogGenreId = 3002; break;  //Action & Adventure
                
                case 116020000:
                    catalogGenreId = 3018; break;  //Card & Board
                
                case 116030000:
                case 116070000:
                    catalogGenreId = 3019; break;  //Classics

                case 701000000:
                    catalogGenreId = 3016; break;  //Demo
                
                /* 
                This genre (Educational) does not exist in the UODB genre system. The
                numbers used in the case are also not present in UODB. They are placed here in case something
                changes in UODB between now and release and we must add them to the map. Feel free
                to remove as needed per policy/practice. 
                */
                case 999999998:
                    catalogGenreId = 3020; break;  //Educational

                case 105000000:
                case 116090000:
                case 116120000:
                case 117030000:
                case 116080000:
                    catalogGenreId = 3005; break;  //Family 
                
                case 106000000:
                case 117040000:
                    catalogGenreId = 3006; break;  //Fighting
                
                case 108000000:
                case 117050000:
                    catalogGenreId = 3007; break;  //Music

                case 104000000:
                case 116170000:
                case 116150000:
                case 101000000:
                case 117060000:
                case 702000000:
                    catalogGenreId = 3001; break;  //Other
                
                case 109000000:
                case 117070000:
                    catalogGenreId = 3008; break;  //Platformer
                
                case 116040000:
                case 116100000:
                    catalogGenreId = 3022; break;  //Puzzle & Trivia
                
                case 110000000:
                case 116130000:
                case 117080000:
                    catalogGenreId = 3009; break;  //Racing & Flying
                
                case 111000000:
                case 116140000:
                case 117090000:
                    catalogGenreId = 3010; break;  //Role Playing
                
                case 112000000:
                case 116160000:
                case 117100000:
                    catalogGenreId = 3011; break;  //Shooter
                
                case 113000000:
                case 117110000:
                case 115000000:
                case 116060000:
                case 117130000:
                    catalogGenreId = 3012; break;  //Strategy & Simulation
                
                case 114000000:
                case 116050000:
                case 116110000:
                case 117120000:
                    catalogGenreId = 3013; break;  //Sports & Recreation
                
                case 116000000:
                    catalogGenreId = 0; break;    //Xbox LIVE Arcade - IGNORE
                
                case 117000000:
                    catalogGenreId = 0; break;    //Xbox Originals - IGNORE

                case 501000000:
                    catalogGenreId = 3308; break;  //Movie Trailers and Short Films
                case 501010000:
                    catalogGenreId = 3309; break;  //Movie Trailers
                case 501020000:
                    catalogGenreId = 3310; break;  //Behind the Scenes
                case 501030000:
                    catalogGenreId = 3311; break;  //Short Films

                case 502000000:
                    catalogGenreId = 3312; break;  //Television
                case 502010000:
                    catalogGenreId = 3313; break;  //Television Shows
                case 502020000:
                    catalogGenreId = 3314; break;  //Music and Short Videos
                case 502020100:
                    catalogGenreId = 3315; break;  //Sports
                case 502020200:
                    catalogGenreId = 3316; break;  //Music Videos
                case 502020300:
                    catalogGenreId = 3317; break;  //Xbox 360 Exclusives
                case 502020400:
                    catalogGenreId = 3318; break;  //More Entertainment
 
                case 503000000:
                    catalogGenreId = 3304; break;  //Gaming Community Videos
                case 503010000:
                    catalogGenreId = 3305; break;  //Animation and Machinima
                case 503020000:
                    catalogGenreId = 3306; break;  //Event Videos
                case 503030000:
                    catalogGenreId = 3307; break;  //Behind the Scenes

                case 504000000:
                    catalogGenreId = 3301; break;  //Game Tips and Support Videos
                case 504010000:
                    catalogGenreId = 3302; break;  //Support Videos
                case 504020000:
                    catalogGenreId = 3303; break;  //Game Help and Tips

            }
            
            if (catalogGenreId == -1)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "No mapping CatalogId present for UODB GenreId : {0}", genreId), "genreId");
            }
            return catalogGenreId;
        }

        private static int GetGameMediaType(ulong titleType, ConsoleTypeEnum consoleType, ushort publisher, bool isMarketplaceProject, Genre[] genres)
        {
            if (GameIdMapping.IsXNAPublisher(publisher))
                return CatalogConstants.MediaTypeCommunityGame;

            if (GameIdMapping.IsServerBackedGame(publisher))
                return CatalogConstants.MediaTypeServerBackedGame;

            if (isMarketplaceProject)
            {
                bool isXboxOriginalGenre = false;
                bool isNotGameGenre = false;

                if (genres != null)
                {
                    foreach (Genre genre in genres)
                    {
                        if ((genre.genreId >= 117000000) && (genre.genreId <= 117130000))
                        {
                            isXboxOriginalGenre = true;
                        }
                        if ((genre.genreId < 101000000) || (genre.genreId > 115000000))
                        {
                            isNotGameGenre = true;
                        }
                    }
                }

                // xbox originals
                if (isXboxOriginalGenre)
                    return CatalogConstants.MediaTypeXbox1Game;
                
                // pre-release xlast game
                if (!isNotGameGenre)
                    return CatalogConstants.MediaType360Game;

                // other marketplace content
                return CatalogConstants.MediaTypeMarketplaceContent;
            }

            switch (titleType)
            {
                case TitleTypeSystem:
                    // Xenon and PC Games use same media type. Offers will go into different stores, that is how the content can be identified.
                    if ((consoleType == ConsoleTypeEnum.Xenon) || (consoleType == ConsoleTypeEnum.PC))
                        return CatalogConstants.MediaType360Game;
                    if (consoleType == ConsoleTypeEnum.Marketplace)
                        throw new NotSupportedException("System titleType is not yet supported for consoleType = Marketplace in CatalogDB.");
                    if (consoleType == ConsoleTypeEnum.Xbox1)
                        throw new NotSupportedException("System titleType is not yet supported for consoleType = Xbox1 in CatalogDB.");
                    if (consoleType == ConsoleTypeEnum.XboxCom)
                        throw new NotSupportedException("System titleType is not yet supported for consoleType = XboxCom in CatalogDB.");
                    break;
                    
                case TitleTypeFull:
                    // Xenon and PC Games use same media type. Offers will go into different stores, that is how the content can be identified.
                    if ((consoleType == ConsoleTypeEnum.Xenon) || (consoleType == ConsoleTypeEnum.PC))
                        return CatalogConstants.MediaType360Game;
                    if (consoleType == ConsoleTypeEnum.Marketplace)
                        throw new NotSupportedException("Full titleType is not yet supported for consoleType = Marketplace in CatalogDB.");
                    if (consoleType == ConsoleTypeEnum.Xbox1)
                        throw new NotSupportedException("Full titleType is not yet supported for consoleType = Xbox1 in CatalogDB.");
                    if (consoleType == ConsoleTypeEnum.XboxCom)
                        throw new NotSupportedException("Full titleType is not yet supported for consoleType = XboxCom in CatalogDB.");
                    break;
                case TitleTypeDemo:
                    // ignore Demo Titles
                    // since they will not be modeled in the Game table in CatalogDB
                    return -1;

                case TitleTypeDownloadable:
                    return CatalogConstants.MediaType360ArcadeGame;
            }

            throw new ArgumentException("Invalid titleType: " + titleType);
        }

        #endregion

        #region LiveTitle or UODB Constants

        const int GenreIdXboxOriginals = 117000000;
        const int zhTWLcid = 1028;

        const string LocaleCodeChineseTraditional = "zh-CHT"; //XLAST_CHINESE_LOCALE_CODE        
        const ushort LocalizedStringTitleNameId = 32768; // The id to get the game title is hardcoded in the tools

        const ulong TitleTypeSystem = 0;
        const ulong TitleTypeFull = 1;
        const ulong TitleTypeDemo = 2;
        const ulong TitleTypeDownloadable = 3;

        const ulong IconIdGame = (ulong)32768;  //  0x8000 = Game Icon image ID (related to X_IMAGEID_GAME in xam.x)
        const ulong IconIdMarketplace = (ulong)32772; // '0x8004 = Marketplace Icon image ID  (related to X_IMAGEID_GAME_MARKETPLACE in xam.x)

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_livetitle_none_12.4.56.0_none_541e73b0e41d0226
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.manifest
XP_MANIFEST_PATH=manifests\x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.cat
XP_CATALOG_PATH=manifests\x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2.cat
XP_PAYLOAD_PATH=x86_livetitle_no-public-key_12.4.56.0_x-ww_9e2a9ce2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetitle,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\Title\TitleVersion.cs ===
using System;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.config;

namespace Microsoft.Ems.Tools.LiveTitle
{
    public class TitleVersion
    {
        public uint TitleID;
        public int Base;
        public int Update;
        public Guid BetaGroup;
        public ConsoleTypeEnum ConsoleType;


        public TitleVersion()
        {
        }

        public TitleVersion( uint titleID, int baseVersion, int updateVersion, Guid betaGroup, ConsoleTypeEnum consoleType )
        {
            TitleID = titleID;
            Base = baseVersion;
            Update = updateVersion;
            BetaGroup = betaGroup;
            ConsoleType = consoleType;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveOffer\offerutil\OfferManager.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------ 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Text;
using Microsoft.Subscriptions.Data;
using Microsoft.Webstore.WstClient;
using xonline.common.billing;
using xonline.common.config;
using xonline.common.offer;
using xonline.common.offerutil;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.xboxofferutil;

namespace Microsoft.Ems.Tools.LiveOfferTool
{
    public static class OfferManager
    {
        // this is a static utility class
        static OfferManager()
        {
            #region TargetHelperCodeInit
            // Init ServerName/ConnectString Helper Arrays
            TargetStrings[0] = "";
            TargetStrings[1] = ConfigUtil.UodbWebstoreApp;

            // Init Database TargetType Helper Arrays
            TargetTypes[0] = TargetType.unknown;
            TargetTypes[1] = TargetType.webstore;

            // Init Database Target names Helper Arrays
            TargetDBs[0] = TargetDB.unknown;
            TargetDBs[1] = TargetDB.uodb;
            #endregion

            imageFilePaths = new ArrayList();
            imageServerPaths = new Hashtable();
        }

        /// <summary>
        /// Target Databases to Prop.
        /// </summary>
        public enum TargetDB
        {
            unknown = 0x00,
            uodb = 0x01,
            all = 0xff   // important, bitwise!!!
        }

        #region TargetHelperCode
        public enum TargetType
        {
            unknown = 0x00,
            webstore = 0x01,
            sql = 0x02
        }

        const int maxTypes = 3;

        static string[] TargetStrings = new string[maxTypes];

        static TargetType[] TargetTypes = new TargetType[maxTypes];

        static TargetDB[] TargetDBs = new TargetDB[maxTypes];

        static ISpilConnectionManager GetConnectionManager(int tdbsindex)
        {
            ISpilConnectionManager spm = null;

            // Get which connection type we require, from our list, and create one
            switch (TargetTypes[tdbsindex])
            {
                case TargetType.webstore:
                    spm = new WebStoreConnectionManager();
                    break;
                case TargetType.sql:
                    spm = new SimpleConnectionManager((string)null);
                    break;
                default: // default to webstore, with default settings in the generated code
                    spm = new WebStoreConnectionManager();
                    break;
            }
            return spm;
        }

        static void ConfigureSvcOffer(SvcOffer so, int tdbsindex)
        {
            if (so != null)
            {
                // Get which string param we need to se, and do so
                switch (TargetTypes[tdbsindex])
                {
                    case TargetType.webstore:
                        so.StoreName = TargetStrings[tdbsindex];
                        break;
                    case TargetType.sql:
                        so.ConnectionString = TargetStrings[tdbsindex];
                        break;
                    default: // leave default settings in the generated code as is
                        break;
                }
            }
            return;
        }

        static String ContextToString(DataStoreContext ctx)
        {
            return ContextToString(ctx, "");
        }

        static String ContextToString(DataStoreContext ctx, string targetname)
        {
            if (ctx.Command == null)
                return (string)"No DataStoreContext.Command available for SqlParameter dump.";

            SqlParameter param = new SqlParameter();

            StringBuilder str = new StringBuilder();
            str.AppendFormat("dbo.{0} /*({1})*/", ctx.Command.CommandText, targetname);

            for (int j = 0; j < ctx.Command.Parameters.Count; j++)
            {
                param = (SqlParameter)ctx.Command.Parameters[j];

                if (param.Direction != ParameterDirection.ReturnValue)
                {
                    if (j > 0) // skip first one
                        str.Append(",");

                    if (((INullable)param.Value).IsNull)
                    {
                        str.AppendFormat(" {0}={1}", param.ParameterName, "null");
                    }
                    else
                    {
                        switch (param.SqlDbType)
                        {
                            case SqlDbType.Binary:
                            case SqlDbType.VarBinary:
                            case SqlDbType.Image:
                                str.AppendFormat(" {0}=0x{1}", param.ParameterName, ByteConvert.ToString((byte[])(SqlBinary)param.Value));
                                break;
                            case SqlDbType.Char:
                            case SqlDbType.DateTime:
                            case SqlDbType.NChar:
                            case SqlDbType.NText:
                            case SqlDbType.NVarChar:
                            case SqlDbType.SmallDateTime:
                            case SqlDbType.Text:
                            case SqlDbType.VarChar:
                                str.AppendFormat(" {0}='{1}'", param.ParameterName, param.Value);
                                break;
                            default:
                                str.AppendFormat(" {0}={1}", param.ParameterName, param.Value);
                                break;

                        }
                    }
                }
            }

            return str.ToString();
        }

        static void ErrorCheck(DataStoreContext ctx, string targetname, bool bAlreadyThrown)
        {
            // check for errors (only last execution of the SP has its retval easily exposed, unless we move away from the NonQuery version)
            uint hr = (uint)DataStoreComponent.GetReturnValue(ctx);
            if (HResult.Failed(hr) && !bAlreadyThrown)
            {
                string msg = ContextToString(ctx, targetname) + " failed with hr = 0x" + hr.ToString("x");
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_144, msg);
            }

            Console.WriteLine();
            Console.WriteLine(ContextToString(ctx, targetname));
        }

        #endregion

        static TargetDB target = TargetDB.all; // not really thread-safe. but this class is only used in single-threaded LiveOffer utility

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static TargetDB Target
        {
            get
            {
                return target;
            }
            set
            {
                target = value;