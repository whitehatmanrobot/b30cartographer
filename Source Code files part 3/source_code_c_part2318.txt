pp(psDmaRead, (USHORT*));
    
    return TRUE;
}



BOOL NV4ScreenToMem16to8bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    //ULONG*          pulDmaRead;        // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NV_XLATE_INIT                        // Initialize cached xlate values
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem16to8bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_8BPP),
              "NV4ScreenToMem16to8bppBlt: Dst bitmap format must be 8bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_16BPP),
              "NV4ScreenToMem16to8bppBlt: Src bitmap format must be 16bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem16to8bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    psDmaRead = (USHORT*) pulDmaRead_start;

    ScreenToMem8bpp(psDmaRead, (USHORT*));
    
    return TRUE;
}


//******************************************************************************
//  ------------------------------------------------------------------
//              END OF NV4ScreenToMem*to*bppBlt FUNCTIONS
//  ------------------------------------------------------------------
//******************************************************************************

    
    
//******************************Public*Routine**********************************
//
// Function: NV4DmaPushDMAGetScreenBits
//
// Routine Description:
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID NV4DmaPushDMAGetScreenBits(
PDEV*       ppdev,
DSURF*      pdsurfSrc,
SURFOBJ*    psoDst,
RECTL*      prclDst,
POINTL*     pptlSrc)        // Absolute coordinates!

    {
    LONG            cyScan;
    LONG            lDstDelta;
    LONG            lSrcDelta;
    BYTE*           pjDst;
    BYTE*           pjSrc;
    LONG            cjScan;
    LONG            width,height;
    RECTL           rclSrc;
    ULONG           OffsetFromSource;
    ULONG           DstOffset;
    ULONG           SrcOffset;
    NvNotification* pNotifier;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Setup the 'source' rectangle to read from
    // Note, the prclDst that is passed into here has already
    // been derived from the clip rectangle (no clipping necessary in this function)
    //**************************************************************************

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = pptlSrc->x + (prclDst->right  - prclDst->left);
    rclSrc.bottom = pptlSrc->y + (prclDst->bottom - prclDst->top);

    //**************************************************************************
    // Get width and height of source rectangle
    //**************************************************************************

    width  = (rclSrc.right  - rclSrc.left);
    height = (rclSrc.bottom - rclSrc.top);


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        lSrcDelta  = pdsurfSrc->LinearStride;
        pjSrc      = pdsurfSrc->LinearPtr;
        }
    else
        {
        lSrcDelta   = ppdev->lDelta;
        pjSrc       = ppdev->pjScreen;
        }

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle 
    //**************************************************************************

    OffsetFromSource = ( (rclSrc.top  * lSrcDelta) + CONVERT_TO_BYTES(rclSrc.left, ppdev)) ;   
    pjSrc += OffsetFromSource;
                
    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle 
    //**************************************************************************

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + (prclDst->top  * lDstDelta)
                                          + CONVERT_TO_BYTES(prclDst->left, ppdev);
                                          
    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES(width, ppdev);
    cyScan = height;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(11)));  

    //**************************************************************************
    // Calculate the offset from the beginning of the DMA Buffer Base
    //**************************************************************************

    DstOffset = (ULONG)(pjDst - (BYTE *)ppdev->pMemToMemBuffer);
    SrcOffset = (ULONG)(pjSrc - ppdev->pjFrameBufbase);

    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
        }

    //**********************************************************************
    // Set methods for memory_to_memory dma blit
    //   NV039_OFFSET_IN                                            
    //   NV039_OFFSET_OUT                                           
    //   NV039_PITCH_IN                                             
    //   NV039_PITCH_OUT                                            
    //   NV039_LINE_LENGTH_IN                                       
    //   NV039_LINE_COUNT                                           
    //   NV039_FORMAT                                               
    //   NV039_BUFFER_NOTIFY                                        
    //**********************************************************************

    //**************************************************************************
    // Set notifier to 'BUSY' value (use second notification structure)
    //**************************************************************************

    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
    NV_DMA_FIFO = SrcOffset;        // Offset In
    NV_DMA_FIFO = DstOffset;        // Offset Out
    NV_DMA_FIFO = lSrcDelta;        // Pitch In
    NV_DMA_FIFO = lDstDelta;        // Pitch Out
    NV_DMA_FIFO = cjScan;           // Line Length In
    NV_DMA_FIFO = cyScan;           // Line Count
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
    NV_DMA_FIFO = 0;                // Set Buffer Notify and kickoff

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    //**************************************************************************
    // Wait for DMA to be completed (use second notification structure)
    //**************************************************************************

    while ( pNotifier->status != 0 );
    

    return;
    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer8to32bpp
//
//  Routine Description: Does 8bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer8to32bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   DwordCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        NextScan = (&(SrcBits[(LONG)(xsrc + (ysrc*BytesPerSrcScan))]));

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {

            DwordCount = clip_width;
            SrcPtr = NextScan;

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+2)));  

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)

                {
                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************

                for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
                    {
                    NV_DMA_FIFO = pulXlate[*SrcPtr++];    
                    }
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                }

            if (DwordCount>0)
                {
                
                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************

                while (DwordCount > 0)
                    {
                    NV_DMA_FIFO = pulXlate[*SrcPtr++];
                    DwordCount--;
                    }
                }

            NextScan+=BytesPerSrcScan;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }

        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...

    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer4to32bpp
//
//  Routine Description: Does 4bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image. 
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer4to32bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   DwordCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = &(SrcBits[(LONG)(((xsrc)>>1) + (ysrc*BytesPerSrcScan))]);

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ((clip_y <<16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {
            DwordCount = clip_width;
            SrcPtr = NextScan;

            NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+4)));  
            
            if (xsrc & 1)
                {
                NV_DMAPUSH_START(1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
                NV_DMA_FIFO = pulXlate[(*(SrcPtr)) & 0xf];
                DwordCount--;
                SrcPtr++;
                }

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)

                {
            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

                for (i=0; i < ((MAX_INDEXED_IMAGE_DWORDS)/2) ; i++)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];    
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) & 0xf];
                    SrcPtr++;
                    }
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                }

            if (DwordCount>0)
                {
            
            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

                while (DwordCount >= 2)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];    
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) & 0xf];
                    SrcPtr++;
                    DwordCount -= 2;
                    }

                if (DwordCount > 0)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];
                    DwordCount--;
                    }
                }

            NextScan+=BytesPerSrcScan;

        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...
    }


//******************************************************************************
//
//  Function:   NV4DmaPushXfer8to16bpp
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer8to16bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj
)
    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    ULONG   temp;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   WordCount;
    ULONG   ByteCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = (&(SrcBits[xsrc + (ysrc*BytesPerSrcScan)]));

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );
        NV_DMA_FIFO = ( (clip_height <<16) | (clip_width+1)&0xfffe);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {

            ByteCount = clip_width;
            WordCount = ByteCount>>1;
            SrcPtr = NextScan;

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount+1)>>1)+1));  
            NV_DMAPUSH_START((ByteCount+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

            while (WordCount > 0)
                {
                temp = pulXlate[*SrcPtr++];
                NV_DMA_FIFO = pulXlate[*SrcPtr++]<<16 | temp;
                WordCount--;
                }
                
            if (ByteCount&1)
                {
                temp = pulXlate[*SrcPtr];
                NV_DMA_FIFO = temp;
                }

            NextScan+=BytesPerSrcScan;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }

        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...

    }


//******************************************************************************
//
//  Function:   NV4DmaPushXfer4to16bpp
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushXfer4to16bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj
)
    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    ULONG   temp;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   ByteCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;
    DECLARE_DMA_FIFO;


    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  

        //************************************************************************
        // Check if 4bpp bitmap starting x is odd. In this case, we will add 1 to
        // width and start drawing the bitmap as if it were even, and use hardware
        // clipping to take care of it.
        //************************************************************************
    
        if ((xsrc&1))
            {
        //*********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //*********************************************************************

       
            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = ((0 << 16) | clip_x);
            NV_DMA_FIFO = (((ppdev->cyMemory)<<16) | clip_width);

            ppdev->NVClipResetFlag=TRUE;
            clip_width++;
            clip_x--;
            xsrc--;
            }

        //********************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to do it
        // as little as possible!
        //********************************************************************

        else if (ppdev->NVClipResetFlag)
            {

        //*********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //*********************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 

            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = (&(SrcBits[(LONG)((xsrc>>1) + (ysrc*BytesPerSrcScan))]));

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ((clip_y <<16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ( (clip_height <<16) | (clip_width+1)&0xfffe);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {
            ByteCount = clip_width>>1;
            SrcPtr = NextScan;


            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((clip_width+1)>>1)+1));  
            NV_DMAPUSH_START((clip_width+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

            while (ByteCount > 0)
                {
                temp = pulXlate[(*SrcPtr) >> 4];    
                NV_DMA_FIFO = (pulXlate[(*SrcPtr) & 0xf]) <<16 | temp;
                SrcPtr++;
                ByteCount--;
                }

            if (clip_width&1)
                {
                temp = pulXlate[(*SrcPtr) >> 4];    
                NV_DMA_FIFO = temp;
                }

            NextScan+=BytesPerSrcScan;

        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...
    }

//******************************************************************************
//
//  Function:   NV4DmaPushFastXfer8to32
//
//  Routine Description: Does 8bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFastXfer8to32(   // Type FastXFER
PDEV*       ppdev,
RECTL*      prcl,               // Array of relative coordinates destination rectangles
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
XLATEOBJ*   pxlo)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    BYTE    *SrcPtr;
    ULONG   clip_x;
    ULONG   clip_width;
    ULONG   i;

    DECLARE_DMA_FIFO;
    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) (psoSrc->lDelta) & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

    clip_x = prcl->left;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

    clip_width = (prcl->right - prcl->left) & 0xffff;

    //**********************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**********************************************************************

    SrcPtr = (BYTE *)(&(SrcBits[pptlSrc->x + ((pptlSrc->y)*(psoSrc->lDelta))]));

    //**********************************************************************
    // Check if we've got enough room in the push buffer
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE((ULONG)(clip_width + 7));  

    //**********************************************************************
    // Initialize the ImageFromCpu object
    //**********************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**********************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**********************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = (((prcl->top) << 16) | (clip_x & 0xffff));
    NV_DMA_FIFO = ((1 << 16) | clip_width);
    NV_DMA_FIFO = ((1 << 16) | clip_width);

    //**********************************************************************
    // Output one scanline - only 1
    //**********************************************************************

    if (clip_width >= MAX_INDEXED_IMAGE_DWORDS)

        {
        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************

        NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

        //**************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**************************************************************

        for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
            {
            NV_DMA_FIFO = pulXlate[*SrcPtr++];    
            }
        clip_width -= MAX_INDEXED_IMAGE_DWORDS;
        }

    if (clip_width > 0)
        {
        
        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************

        NV_DMAPUSH_START(clip_width, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

        //**************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**************************************************************

        while (clip_width > 0)
            {
            NV_DMA_FIFO = pulXlate[*SrcPtr++];
            clip_width--;
            }

        }

    //******************************************************************
    // Kickoff buffer
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer

    }

//******************************************************************************
//
//  Function:   NV4DmaPushFastXfer8to16
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFastXfer8to16(   // Type FastXFER
PDEV*       ppdev,
RECTL*      prcl,               // Array of relative coordinates destination rectangles
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
XLATEOBJ*   pxlo)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    ULONG   temp;
    BYTE    *SrcPtr;
    ULONG   WordCount;
    ULONG   ByteCount;
    LONG    clip_x;
    ULONG   clip_width;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) (psoSrc->lDelta & 0x3)),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

    clip_x = prcl->left;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

    clip_width = prcl->right - clip_x;
    WordCount = clip_width>>1;

    //**********************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**********************************************************************

    SrcPtr = (BYTE *)(&(SrcBits[pptlSrc->x + ((pptlSrc->y)*(psoSrc->lDelta))]));

    //**********************************************************************
    // Check if we've got enough room in the push buffer
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE((ULONG)(WordCount+7));  

    //**********************************************************************
    // Initialize the ImageFromCpu object
    //**********************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**********************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**********************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = (((prcl->top) <<16) | (clip_x & 0xffff));
    NV_DMA_FIFO = ((1 << 16) | clip_width);
    NV_DMA_FIFO = ((1 << 16) | (clip_width+1)&0xfffe);

    //**************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************

    NV_DMAPUSH_START((clip_width+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

    //**************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_COLOR(0)
    //     NV061_COLOR(1)
    //     NV061_COLOR(2)
    //      ...
    //**************************************************************

    while (WordCount > 0)
        {
        temp = pulXlate[*SrcPtr++];
        NV_DMA_FIFO = pulXlate[*SrcPtr++]<<16 | temp;
        WordCount--;
        }
        
    if (clip_width&1)
        {
        temp = pulXlate[*SrcPtr];
        NV_DMA_FIFO = temp;
        }

    //******************************************************************
    // Kickoff buffer after each scanline
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer

    }

//******************************************************************************
//
//  Function:   NV4DmaPushIndexedImage
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushIndexedImage(    // Type FNXFER

    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern
    BLENDOBJ*   pBlendObj)

    {

    BYTE* pjSrcScan0;

    ULONG lutEntries;
    ULONG sourcePixelDepth;
    LONG  BytesPerSrcScan;
    ULONG BytesPerDstScan;
    ULONG ScanInc;
    ULONG Rop3;
    ULONG temp;
    LONG  xsrc,ysrc;
    ULONG xsrcOffset;
    ULONG AlignMask;
    BYTE  *NextScan;
    ULONG *ScanPtr;
    ULONG yscan;
    ULONG SizeInWidth;
    LONG  clip_x,clip_y;
    ULONG clip_width,clip_height;
    ULONG *pulXlate;
    ULONG *currentLut;
    ULONG i;
    ULONG TempPixelData;
    ULONG LoopCount;
    ULONG DwordCount;
    ULONG ByteCount;
    ULONG tempId;
    ULONG savedId;
    ULONG lutOffset;
    ULONG notifierIndex;
    ULONG red5;
    ULONG green6;
    ULONG blue5;

    DECLARE_DMA_FIFO;
    
    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get ready to translate the 4bpp colors
    //**************************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");

    //**************************************************************************
    // Force channelsync          
    // BugFix for Indexed image   
    // blits when OGL running,    
    // for NV < NV10              
    // bug #20000720-213841       
    //**************************************************************************
    if ( OglIsEnabled(ppdev) && 
         ppdev->CurrentClass.ChannelDMA == NV04_CHANNEL_DMA ) 
    {
        ppdev->oglLastChannel = -1;           
        ppdev->pfnWaitForChannelSwitch(ppdev);
    }                                         

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    sourcePixelDepth = psoSrc->iBitmapFormat;

    //**************************************************************************
    // Get pointer to start of source bitmap
    //**************************************************************************

    pjSrcScan0 = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;
    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************
    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Each LUT is associated with an indexed image operation. To improve
    // performance, there are multiple indexed image objects with an associated
    // LUT. This is necessary because the LUT can't be updated before an operation
    // has completed; otherwise it will be corrupted. There is a notifier assoicated
    // with each indexed image operation. This code checks for a completed
    // operation so it can use that indexed image object and associated LUT. This
    // is much faster than waiting for the engine idle, or even waiting for the
    // previous indexed image operation to be completed.
    //**************************************************************************

    //**************************************************************************
    // Wait for completed indexed image object.
    //**************************************************************************

    notifierIndex = (ppdev->NvLastIndexedImageNotifier + 1)&(MAX_INDEXED_IMAGE_NOTIFIERS-1);
    
    while (TRUE)
        {
        if (((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[notifierIndex*sizeof(NvNotification)])))->status
                                             != NV064_NOTIFICATION_STATUS_IN_PROGRESS)
            break;      // operation has completed - free to re-use.
        notifierIndex = (notifierIndex+1)&(MAX_INDEXED_IMAGE_NOTIFIERS-1); // check next indexed image object
        }

    //**************************************************************************
    // Load LUT associated with indexed image object.
    //**************************************************************************

    ppdev->NvLastIndexedImageNotifier = notifierIndex;
    lutOffset = notifierIndex << 10;        // each LUT is max of 1024 bytes

    pulXlate  =  pxlo->pulXlate;
    currentLut = (ULONG *) ((BYTE*)(ppdev->NvDmaIndexedImageLut) + lutOffset);
    lutEntries = pxlo->cEntries;
    
    if (ppdev->iBitmapFormat == BMF_32BPP)  // destination pixel format 32bpp
        {
        while (lutEntries--)
            *currentLut++ = *pulXlate++;
        }
    else
        {
        //**********************************************************************
        // In 16bpp, indexed image hardware will dither when using R5G6B5. 
        // So we must use X8R8G8B8 instead to get the exact desired results
        //**********************************************************************
           
        while (lutEntries--)
            {     
            temp    = *pulXlate++;
            blue5   = temp & 0x001f;            // Get bottom 5 bits
            green6  = temp & 0x07e0;            // Get middle 6 bits
            red5    = temp & 0xf800;            // Get top 5 bits
            
            blue5   <<=3;                       // Convert R5G6B5 to X8R8G8B8
            green6  <<=5;                       
            red5    <<=8;                        
 
            *currentLut++ = (red5 | green6 | blue5);    // Store LUT data
            }
        }

    //************************************************************************
    // Get push buffer information    
    //************************************************************************

    INIT_LOCAL_DMA_FIFO;

    while (TRUE)
        {
        
    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

    //**********************************************************************
    // Top left coordinate of source bitmap on source surface
    //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y  - prclDst->top;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

    //***********************************************************************
    // Check if we've got enough room in the push buffer
    //***********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(13))); 

    //************************************************************************
    // For the X86, check if 4bpp bitmap starting x is odd. In this case, we
    // will add 1 to width and start drawing the bitmap as if it were even,
    // and use hardware clipping to take care of it.
    //************************************************************************

    //************************************************************************
    // The IA64 has a different problem, but can use the same solution.
    // The processor will fault on unaligned addresses.  So reuse the code,
    // but with more stringent alignment requirements.
    //************************************************************************

#ifdef _WIN64
        if (sourcePixelDepth == BMF_4BPP)
           AlignMask = 0x7;
        else
           AlignMask = 0x3;
#else
        if (sourcePixelDepth == BMF_4BPP)
           AlignMask = 0x1;
        else
           AlignMask = 0x0;
#endif
        xsrcOffset = xsrc & AlignMask;
        if (xsrcOffset)
           {
           xsrc &= ~AlignMask;
        
       //*********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //*********************************************************************

           NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
           NV_DMA_FIFO = ((0 << 16) | clip_x);
           NV_DMA_FIFO = (((ppdev->cyMemory)<<16) | clip_width);

           ppdev->NVClipResetFlag=TRUE;

           // adjust clip_x, clip_width - used for Dst x and width from here on
           clip_x -= xsrcOffset;
           clip_width += xsrcOffset;
           } 

    //************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //************************************************************************

        else if (ppdev->NVClipResetFlag)
           {

       //*********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //*********************************************************************

           NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
           NV_DMA_FIFO = 0;
           NV_DMA_FIFO = ppdev->dwMaxClip; 

           ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
           }

    //**********************************************************************
    // Get ptr to start of SRC. For 4bpp case, there are 2 pixels per byte.
    //**********************************************************************

        if (sourcePixelDepth == BMF_4BPP)
            {
            SizeInWidth = ((clip_width + 7) & 0xfff8);
            NextScan = (&(pjSrcScan0[(LONG)((xsrc>>1) + ysrc*BytesPerSrcScan)]));
            LoopCount = (clip_width+1) >> 3;    // Each loop handles 8 pels
            ByteCount = ((clip_width+1) & 7) >>1;   // extra bytes in bitmap
            }
        else
            {
            SizeInWidth = ((clip_width + 3) & 0xfffc);
            NextScan = (&(pjSrcScan0[(LONG)((xsrc) + ysrc*BytesPerSrcScan)]));
            LoopCount = clip_width >> 2;        // Each loop handles 4 pels
            ByteCount = clip_width & 3;         // extra bytes in bitmap
            }
        
        BytesPerDstScan = (LoopCount*4) + ByteCount;            
        
    //**********************************************************************
    // Set the following methods for INDEXED_IMAGE_FROM_CPU
    //     ROP
    //     SET_OBJECT and restore later
    //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_SET_OBJECT, DD_INDEXED_IMAGE1_FROM_CPU+notifierIndex);

    //**********************************************************************
    // Set the following methods for INDEXED_IMAGE_FROM_CPU
    //     NV064_INDEX_FORMAT
    //     NV064_LUT_OFFSET
    //     NV064_POINT     
    //     NV064_SIZE_OUT  
    //     NV064_SIZE_IN 
    //**********************************************************************

        NV_DMAPUSH_START(5, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDEX_FORMAT);
        if (sourcePixelDepth == BMF_4BPP)
            NV_DMA_FIFO = NV064_INDEX_FORMAT_SVGA65_I4;
        else
            NV_DMA_FIFO = NV064_INDEX_FORMAT_LE_I8;
        NV_DMA_FIFO = lutOffset;        // byte offset

        NV_DMA_FIFO = ((clip_y << 16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ((clip_height <<16) | SizeInWidth);

    //**********************************************************************
    // Output 1 scanline at a time.
    //**********************************************************************

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        //**********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,clip_height, (ULONG *)NextScan,ScanInc);
        UPDATE_LOCAL_DMA_COUNT;

#else   // ifdef _x86_

        for (yscan=0; yscan < clip_height; yscan++)
            {
            DwordCount = LoopCount;
            ScanPtr = (ULONG*) NextScan;
            
            
        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time.
        // For very high resolutions, there is the possibility of exceeding this
        // maximum once per scanline; typically, it will never happen.
        //**********************************************************************

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)
                {

        //**********************************************************************
        // Check if we've got enough room in the push buffer and write 1792 dwords
        //**********************************************************************
        
                NV_DMAPUSH_CHECKFREE(((ULONG)(MAX_INDEXED_IMAGE_DWORDS+1)));  

                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
    
        //**********************************************************************
        // Set the following methods for INDEXED_IMAGE_FROM_CPU
        //     NV064_INDICES(0)
        //     NV064_INDICES(1)
        //     NV064_INDICES(2)
        //      ...
        //**********************************************************************
    
                for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
                    NV_DMA_FIFO = ScanPtr[i];    
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                ScanPtr += MAX_INDEXED_IMAGE_DWORDS;

                }

            if (DwordCount > 0)
                {
                NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+1)));  

                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
    
        //**********************************************************************
        // Set the following methods for INDEXED_IMAGE_FROM_CPU
        //     NV064_INDICES(0)
        //     NV064_INDICES(1)
        //     NV064_INDICES(2)
        //      ...
        //**********************************************************************
    
                for (i=0; i<DwordCount; i++)
                    NV_DMA_FIFO = ScanPtr[i];    
                }
                
            if (ByteCount > 0)
                {
                ScanPtr += DwordCount;
                TempPixelData = 0;
                for (i=0; i<ByteCount; i++)
                    TempPixelData |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                NV_DMAPUSH_CHECKFREE(((ULONG)(2)));  

                NV_DMAPUSH_START(1, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
                NV_DMA_FIFO = TempPixelData;
                }
                
            NextScan += BytesPerSrcScan;
            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;
            }

#endif  // ifdef else _X86_

        //******************************************************************
        // Restore channel and send data on thru to the DMA push buffer
        //******************************************************************

            if (--c == 0)
                {

        //*******************************************************************
        // Use a notifier so that the next time we get into indexed image
        // we can check if this is finished instead of doing an engine wait.
        //*******************************************************************

                ((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[notifierIndex*sizeof(NvNotification)])))->status = NV064_NOTIFICATION_STATUS_IN_PROGRESS;

                NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_NOTIFY       , NV064_NOTIFY_WRITE_ONLY);
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_NO_OPERATION , 0x00000000);

                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OBJECT, DD_IMAGE_FROM_CPU);

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);
                return;
                }

            prcl++;

        } // while (TRUE)
    }


//******************************************************************************
//
//  Function:   NV4DmaPushStretchCopy
//
//  Routine Description:
//      Private escape function for Desktop Manager zoom feature.
//      Performs a vidmem-to-vidmem unclipped SRCCOPY stretched blit.
//      Implements the ESC_NV_DESKMGR_ZOOMBLIT escape.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL NV4DmaPushStretchCopy(     // Type FNSTRETCHCOPY

    PDEV*       ppdev,
    ULONG       uSmooth,        // Non-zero for a smoothed copy.
    int         iScale,         // Scale factor.
    RECTL*      prclSrc,        // Source rectangle.
    RECTL*      prclDst,        // Destination rectangle.
    int         iClips,         // Number of destination clips (0 is OK).
    RECTL*      prclClips)      // Destination clips (NULL OK if zero clips).

    {
    unsigned uSrcColorFormat;
    unsigned uDstPoint, uDstSize;
    unsigned uClipPoint, uClipSize;
    unsigned uDSDX;
    unsigned uSrcPoint, uSrcSize, uSrcOffset;
    unsigned uInFormat;
    unsigned x, y, i;
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    // The modeswitch counter is odd whenever modeset/powersave is in progress.
    if (ppdev->dwGlobalModeSwitchCount & 1)
        return TRUE;

    // Safety check.
    ASSERTDD(ppdev->CurrentClass.ScaledImageFromMemory != 0,
             "No scaled image class available in NV4DmaPushStretchCopy");

    // Compute the private color format.
    if (ppdev->iBitmapFormat == BMF_32BPP)
        uSrcColorFormat = NV089_SET_COLOR_FORMAT_LE_A8R8G8B8;
    else if (ppdev->iBitmapFormat == BMF_16BPP)
        uSrcColorFormat = NV089_SET_COLOR_FORMAT_LE_R5G6B5;
    else
        // Unsupported color format: bail.
        return FALSE;

    // Compute destination point and size.
    uDstPoint = (((unsigned) prclDst->top) << 16) |
                    (unsigned) prclDst->left;
    x = (unsigned) (prclDst->right - prclDst->left);
    y = (unsigned) (prclDst->bottom - prclDst->top);
    uDstSize = (y << 16) | x;
    // Compute scale factor.
    uDSDX = (unsigned) ((0x100000 + (iScale >> 1)) / iScale);

    // Compute source point, size, and offset.
    // There are significant restrictions on the range of the source size
    // so we adjust the source offset and point to compensate.
    // Adjust the source offset.
    x = (unsigned) (prclSrc->left & ~0x0000001f);
    y = (unsigned) (prclSrc->top & ~0x00000001);
    uSrcOffset = y * (unsigned) ppdev->lDelta +
                 x * (unsigned) ppdev->cjPelSize;
    // Compute the new source size.
    x = (((unsigned) prclSrc->right) - x + 1) & ~1;
    y = ((unsigned) prclSrc->bottom) - y;
    uSrcSize = (y << 16) | x;
    // Adjust the source point.
    x = (unsigned) (prclSrc->left & 0x0000001f);
    y = (unsigned) (prclSrc->top & 0x00000001);
    uSrcPoint = (y << 20) | (x << 4);

    // Compute the image in format.
    uInFormat = ((unsigned) ppdev->lDelta) |
                (NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16);
    if (uSmooth)
        uInFormat |= (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24);
    else
        uInFormat |= (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);

    // Specify source and destination buffers--in this case the primary buffer.
    ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
    ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);

    // Sync our locals back after ppdev has been modified by the above calls.
    INIT_LOCAL_DMA_FIFO;

    // Get enough room in the pushbuffer; err on the side of caution.
    NV_DMAPUSH_CHECKFREE(((ULONG)(16 * iClips + 24)));

    // Load our object into the spare subchannel.
    if (ppdev->dDrawSpareSubchannelObject != DD_SCALED_IMAGE_FROM_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),
                          DD_SCALED_IMAGE_FROM_MEMORY);
        ppdev->dDrawSpareSubchannelObject = DD_SCALED_IMAGE_FROM_MEMORY;
        }

    // Program the object's non-volatile methods.
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_DMA_NOTIFIES,
                      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_DMA_IMAGE,
                      DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_SURFACE,
                      DD_PRIMARY_IMAGE_IN_MEMORY);

    // Loop over all the destination clip rectangles.
    i = 0;
    do
        {
        // Compute clip point and size.
        if (iClips)
            {
            uClipPoint = (((unsigned) prclClips[i].top) << 16) |
                            (unsigned) prclClips[i].left;
            x = (unsigned) (prclClips[i].right - prclClips[i].left);
            y = (unsigned) (prclClips[i].bottom - prclClips[i].top);
            uClipSize = (y << 16) | x;
            }
        // If no clips are specified then use the destination rectangle.
        else
            {
            uClipPoint = uDstPoint;
            uClipSize = uDstSize;
            }

        NV_DMAPUSH_START(8, DD_SPARE, NV089_SET_COLOR_FORMAT);
        NV_DMA_FIFO = uSrcColorFormat;              // NV089_SET_COLOR_FORMAT
        NV_DMA_FIFO = NV089_SET_OPERATION_SRCCOPY;  // NV089_SET_OPERATION
        NV_DMA_FIFO = uClipPoint;                   // NV089_CLIP_POINT
        NV_DMA_FIFO = uClipSize;                    // NV089_CLIP_SIZE
        NV_DMA_FIFO = uDstPoint;                    // NV089_IMAGE_OUT_POINT
        NV_DMA_FIFO = uDstSize;                     // NV089_IMAGE_OUT_SIZE
        NV_DMA_FIFO = uDSDX;                        // NV089_DS_DX
        NV_DMA_FIFO = uDSDX;                        // NV089_DT_DY
        NV_DMAPUSH_START(4, DD_SPARE, NV089_IMAGE_IN_SIZE);
        NV_DMA_FIFO = uSrcSize;                     // NV089_IMAGE_IN_SIZE
        NV_DMA_FIFO = uInFormat;                    // NV089_IMAGE_IN_FORMAT
        NV_DMA_FIFO = uSrcOffset;                   // NV089_IMAGE_IN_OFFSET
        NV_DMA_FIFO = uSrcPoint;                    // NV089_IMAGE_IN

        } while (++i < (unsigned) iClips);

    // Kick off the pushbuffer.
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    // Success!
    return TRUE;
    }


//*********************************************************************
//
//  Function:   NV4DmaPushColorKeyBlt
//
//  Routine Description:
//      Colorkey blit on a list of rectangles. Especially used in
//      the OpenGL overlay mergeblit.
//
//      NOTE: Only initialized in 16 and 32 bpp!
//
//      NOTE: Needs surface src and dst to be set outside!
//
//  Arguments:
//
//  Return Value:
//
//      None.
// 
//*********************************************************************
VOID NV4DmaPushColorKeyBlt(
    PPDEV        ppdev,
    LONG         c,            // Number of rects in prcl
    RECTL       *prcl,         // Array of relative coordinates destination rectangles
    POINTL      *pptlSrc,      // Original unclipped source point
    RECTL       *prclDst,      // Original unclipped destination rectangle
    ULONG        ulColorRef)   // 32bit ARGB color key reference value
{  
    NvU32   ulColorFormat; // Class 57 color format of colorkey
    NvU32   ulColorKey;    // Class 57 colorkey
    ULONG   red, green, blue;
    LONG    dx;            // Add delta to destination to get source
    LONG    dy;           
    ULONG   width,height;
    ULONG   xsrc,ysrc;
    ULONG   xdst,ydst;
  
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    ASSERT(0!=c); // don't call me if you don't need
    ASSERT(NULL!=prcl   );
    ASSERT(NULL!=pptlSrc);
    ASSERT(NULL!=prclDst);

    //
    // setup color key object
    //
    if (2==ppdev->cjPelSize)
    {
        blue        = (ulColorRef & 0x00FF0000) >> (16 + 3);   // 5 bits of B            
        green       = (ulColorRef & 0x0000FF00) >> (8 + 2);    // 6 bits of G                       
        red         = (ulColorRef & 0x000000FF) >> 3;          // 5 bits of R                 

        ulColorKey    = (NvU32)( ((red << 11) | (green << 5) | blue) | 0xFFFF0000 );
        ulColorFormat = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
    } 
    else 
    {
        ASSERT(4==ppdev->cjPelSize);

        blue        = (ulColorRef & 0x00FF0000) >> 16;               
        green       = (ulColorRef & 0x0000FF00) >> 8;               
        red         = (ulColorRef & 0x000000FF);               

        ulColorKey    = (NvU32)( ((red << 16) | (green << 8) | blue | 0xFF000000) );
        ulColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
    }

    NV_DMAPUSH_CHECKFREE((ULONG)(6));

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_IMAGE_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, ulColorFormat)
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR,        ulColorKey);

    for ( /* c */; c > 0; c--)
    {
        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        xdst = prcl->left;
        ydst = prcl->top;

        width = prcl->right - xdst;
        height = prcl->bottom - ydst;

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        NV_DMAPUSH_CHECKFREE((ULONG)(8));
        //
        // do the transparent blt
        //
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT_COLORKEY);
        NV_DMAPUSH_START(3, DD_SPARE, NV05F_CONTROL_POINT_IN);
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );              // NV05F_CONTROL_POINT_IN 
        NV_DMA_FIFO = ( (ydst << 16) | (xdst & 0xffff) );              // NV05F_CONTROL_POINT_OUT
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));            // NV05F_SIZE             

        prcl++;
    }

    NV_DMAPUSH_CHECKFREE((ULONG)(4));
    //
    // disable colorkey again
    //
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0); // color key disabled

    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);
}


//******************************************************************************
//
// Function: NV4DmaPushAlphaPreserve
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     bStart - True if beginning AlphaPreserveMode, False if ending
//     bFromCpu - True if blt source is system memory
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4DmaPushAlphaPreserve(
    PPDEV       ppdev,
    BOOL        bStart,
    BOOL        bFromCpu)
{
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE((ULONG)(8));

    if (bStart) 
        {
        if (bFromCpu) 
            {
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_SRCCOPY);
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
            }
        else
            {
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION, NV05F_SET_OPERATION_SRCCOPY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);
            }
        }
    else
        {
        if (bFromCpu) 
            {
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_ROP_AND);
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);
            }
        else
            {
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION, NV05F_SET_OPERATION_ROP_AND);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);   
            }
        }

    UPDATE_PDEV_DMA_COUNT;

    // For performance reasons, don't kick off this tiny bit of data now (NV4_DmaPushSend(ppdev);)
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
//  Function:   NV4CheckAlphaBlendOK
//
//  Routine Description:
//
//      For given state in PDEV, check if HW can do the blend 
//
//  Arguments:
//
//     ppdev - Pointer to the physical device structure
//
//  Return Value: 
//
//      TRUE if HW capable, FALSE if not
//
//******************************************************************************

BOOL NV4CheckAlphaBlendOK(
    PDEV*   ppdev)
{
    // Check for state/hw combinations which don't support alpha blending
    // In 16bpp, need better than NV04 so we can turn dither off
    // Note NV04_IMAGE_FROM_CPU works fine for 32bpp, but not 16bpp, since it has no way to turn off
    //   dither.  So we support alpha in 32bpp and can punt (by returning FALSE here) in 16bpp.  
    // HOWEVER, there are no DCT failures on pre-NV10 hw in 16bpp even though we can't disable dither.
    //   THEREFORE, the punt is disabled. The code remains in case we find a failure and want to punt for old HW.
    #if 0
    if ((ppdev->CurrentClass.ContextSurfaces2D == NV04_CONTEXT_SURFACES_2D) &&
        (ppdev->iBitmapFormat == BMF_16BPP))
        {
        return FALSE;
        }
    else
    #endif
        {
        // all else, we can do
        return TRUE;
        }
}   


//******************************************************************************
//
//  Function:   NV4DmaPushCopyAlphaBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of alpha blended rectangles.
//      A modified version of NV4DmaPushCopyBlt, that uses class 077 (NV4_SCALED_IMAGE_FROM_MEMORY)
//
//  Arguments:
//
//  Return Value: 
//
//      TRUE if successful, FALSE if caller must punt operation to GDI
//
//******************************************************************************

BOOL NV4DmaPushCopyAlphaBlt(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ* pBlendObj)
{
    LONG    clipx,clipy,clipwidth,clipheight;
    LONG    xdst,ydst,width,height;
    LONG    dx,dy;
    LONG    xsrc,ysrc;
    ULONG   constAlpha;

    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************
    ASSERTDD(pBlendObj, "Expect valid pBlendObj on alphablend blts");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),"Expect only a rop2");

    // DD_ALPHA_IMAGE_FROM_MEMORY is either NV04_SCALED_IMAGE_FROM_MEMORY(077) or NV10_SCALED_IMAGE_FROM_MEMORY(089)
    // Routine uses NV077 offsets for methods common to each class, and 089 for NV10-only features
    // We should return an error here if we need an NV10 feature but the class is pre-NV10 (meaning hw is pre-NV10)
    //   Caller knows error return means not-supported and will punt to GDI
    // Note NV04_SCALED_IMAGE_FROM_MEMORY works fine for 32bpp, but not 16bpp, since it has no way to turn off
    //   dither.  We support alpha in 32bpp and can punt (by returning FALSE here) in 16bpp.  
    // HOWEVER, there are no DCT failures on pre-NV10 hw in 16bpp even though we can't disable dither.
    //   THEREFORE, the punt is disabled. The code remains in case we find a failure and want to punt for old HW.
    // Finally, note it turns out we could call NV4CheckAlphaBlendOK since it and the check for NV04_SCALED_IMAGE are 
    //   the same for current hardware.  However, we leave the separate specific check SCALED_IMAGE support since it 
    //   was already there and in case future hardware has varying SCALED_IMAGE support
    #if 0 // Disable punt : let pre-NV10 proceed w/ dither on
    if ((ppdev->CurrentClass.AlphaImageFromMemory == NV04_SCALED_IMAGE_FROM_MEMORY) &&
        (ppdev->iBitmapFormat == BMF_16BPP))
        {
        return FALSE;
        }
    #endif
            
    // Check if we've got enough room in the push buffer for largest possible output
    NV_DMAPUSH_CHECKFREE((ULONG)((13*2) + (12*c)));

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop4 & 0xff);

    // Setup Blender - load alpha value into all bytes since hw uses each byte as an independent alpha value
    constAlpha = pBlendObj->BlendFunction.SourceConstantAlpha & 0x000000FF;
    constAlpha |= constAlpha << 8;
    constAlpha |= constAlpha << 16;

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV072_SET_BETA_FACTOR,  constAlpha);

    // if 32bpp, use color format with valid alpha for destination (primary)
    if (ppdev->iBitmapFormat==BMF_32BPP) 
        {
        // set back to default LE_X8R8G8B8 (32bpp) at the end
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT,  NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_IMAGE_BLIT);
        }

    // Load Alpha image object into the spare subchannel
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_ALPHA_IMAGE_FROM_MEMORY);
    ppdev->dDrawSpareSubchannelObject = DD_ALPHA_IMAGE_FROM_MEMORY;

    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_SURFACE,      DD_PRIMARY_IMAGE_IN_MEMORY);

    if (pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA) 
        {
        // Source has valid alpha
        ASSERTDD(ppdev->iBitmapFormat==BMF_32BPP, "Alphablend CopyBlts w/ SrcAlpha must be 32bpp");
        NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);
        }
    else
        {
        // Source has no alpha - use format having no alpha, where source alpha defaults to 0xff by HW
        if (ppdev->iBitmapFormat==BMF_32BPP) 
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_X8R8G8B8);
            }
            else
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_R5G6B5);
            // For post NV4 hw, turn dither off for the blend
            if (ppdev->CurrentClass.AlphaImageFromMemory != NV04_SCALED_IMAGE_FROM_MEMORY)
                {
                NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_COLOR_CONVERSION, NV089_SET_COLOR_CONVERSION_TRUNCATE);
                }
            
            }
        }

    // Do a copy blit for each clip rectangle
    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************
        
        // Set Clip point and size for Screen boundaries
        clipx = prcl->left;
        if (prcl->right > ppdev->cxScreen)
            {
            clipwidth = ppdev->cxScreen - clipx; 
            }
        else
            {
            clipwidth = prcl->right - clipx;
           
            if (clipx < 0)
                {
                clipwidth += clipx; // subtract (add neg. x) distance from x start to screen left
                clipx = 0;
                }
            }

        clipy = prcl->top;
        if (prcl->bottom > ppdev->cyScreen)
            {
            clipheight = ppdev->cyScreen - clipy; 
            }
        else
            {
            clipheight = prcl->bottom - clipy;
            
            if (clipy < 0)
                {
                clipheight += clipy; // subtract (add neg. y) distance from y start to screen top
                clipy = 0;
                }
            }

        NV_DMAPUSH_START(6, DD_SPARE, NV077_CLIP_POINT);
        NV_DMA_FIFO = ((clipy << 16)|(clipx & 0xffff));         // NV077_CLIP_POINT
        NV_DMA_FIFO = ((clipheight << 16)|(clipwidth & 0xffff));// NV077_CLIP_SIZE

        // Use original unclipped origin, size for image size
        xdst = prcl->left;
        ydst = prcl->top;
        width = prcl->right - xdst;
        height = prcl->bottom - ydst;
        
        NV_DMA_FIFO = ((ydst << 16)|(xdst & 0xffff));   // NV077_IMAGE_OUT_POINT
        NV_DMA_FIFO = ((height << 16)|(width & 0xffff));// NV077_IMAGE_OUT_SIZE
        NV_DMA_FIFO = 0x100000;                         // NV077_DELTA_DU_DX = 1.0 - no scaled blts supported yet
        NV_DMA_FIFO = 0x100000;                         // NV077_DELTA_DV_DY = 1.0 - no scaled blts supported yet

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        // width, height are w.r.t SrcOffset, so add src x,y
        width  += xsrc;
        height += ysrc;
        
        // Class restriction - width must be a multiple of 2
        width = (width + 1) & ~1;

        NV_DMAPUSH_START(4, DD_SPARE, NV077_IMAGE_IN_SIZE);
        NV_DMA_FIFO = (height << 16) | width;           // NV077_IMAGE_IN_SIZE
        NV_DMA_FIFO = ((unsigned) ppdev->CurrentSourcePitch) |  // NV077_IMAGE_IN_FORMAT
                        (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                        (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);
        NV_DMA_FIFO = ppdev->CurrentSourceOffset;       // NV077_IMAGE_IN_OFFSET
        NV_DMA_FIFO = (ysrc << 20) | (xsrc << 4);       // NV077_IMAGE_IN

        prcl++;

    } while (--c != 0);

    // if 32bpp, restore color format which was changed at entry
    if (ppdev->iBitmapFormat==BMF_32BPP) 
        {
        // restore defaults
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT,  NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_IMAGE_BLIT);
        }

    // Update global push buffer count
    UPDATE_PDEV_DMA_COUNT;

    // Send data on thru to the DMA push buffer
    NV4_DmaPushSend(ppdev);

    return TRUE;

}


//******************************************************************************
//
// Function: NV4DmaPushSetColorKey
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     colorformat - non-zero colorformat format if Set key, 0 if disabling color keying
//     iTransColor - The color key 
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4DmaPushSetColorKey(
    PPDEV       ppdev,
    ULONG       colorformat, // 0 means disable
    ULONG       iTransColor)
{
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE((ULONG)(10));

    if (colorformat)
        {
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_COLOR_KEY, DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_COLOR_KEY, DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, colorformat ==  BMF_32BPP ?
                                                            NV057_SET_COLOR_FORMAT_LE_A8R8G8B8 :
                                                            NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
        // iTransColor already in surface's color format - set Alpha non-zero to activate color key check in NV hardware
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR,        iTransColor | (0xff << 24));
        }
    else
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0); // color key disabled
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_COLOR_KEY, 0);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_COLOR_KEY, 0);
        ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;
        }

    UPDATE_PDEV_DMA_COUNT;

    // For performance reasons, don't kick off this tiny bit of data now (NV4_DmaPushSend(ppdev);)
}


#endif // (_WIN32_WINNT >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV4DDRW.C
//
// Abstract:
//
//     Implements all NV4 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

#include "nv4_ref.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// We'll add the 565 bitmap format functions here
// (We'll use the NV3 functions for 555 format)
//******************************************************************************

#define MASK_OUT_OTHER_CHANNELS         0xFFFFFFFE
#define OFFSET_NV_PFIFO_BASE            (0x2000)
#define OFFSET_NV_PFIFO_DMA_REG         (0x2508-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1    (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS   (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_PUSH (0x3220-OFFSET_NV_PFIFO_BASE)
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100
#define CACHE1_PUSH1_MODE_DMA           0x100
#define CACHE1_STATUS_LOW_MARK_EMPTY    0x010

#define OFFSET_NV_PGRAPH_DEBUG_3                     (0x0040008C - 0x00400000)
#define POSTDITHER_2D_ENABLE                          0x00001000
#define PREDITHER_2D_ENABLE                           0x00004000

//
//#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da
//
//#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
//#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5
//
//#define OFFSET_PRMVIO_SRX_REG                       0x3c4
//#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
//#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
//#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0
//
//#define NV_SR_UNLOCK_VALUE                          0x00000057
//#define NV_SR_LOCK_VALUE                            0x00000099
//


//******************************************************************************
// Forward Declarations
//******************************************************************************

ULONG NV4_VBlankIsActive(PDEV *);
ULONG NV4_DisplayIsActive(PDEV *);
ULONG NV4_GraphicsEngineBusy(PDEV *);
VOID NV4_WaitWhileVBlankActive(PDEV * );
VOID NV4_WaitWhileDisplayActive(PDEV * );
VOID NV4_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV4_DmaPushSend(PDEV *);
VOID MagicDelay ();

//******************************************************************************
// External Declarations
//******************************************************************************

extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

//******************************************************************************
//
// Function: NV4_VBlankIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_VBlankIsActive(PDEV*   ppdev)

    {
    //**************************************************************************
    // Get VBLANK status
    //**************************************************************************
    if (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK))
        return(TRUE);
    return(FALSE);

    }


//******************************************************************************
//
// Function: NV4_DisplayIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_DisplayIsActive(PDEV*   ppdev)

    {
    //**************************************************************************
    // Get DISPLAY status
    //**************************************************************************
    if (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK))
        return(FALSE);
    return(TRUE);
    }

#pragma optimize("",off)    // Need this so we only do ULONG reads from the hw

//******************************************************************************
//
// Function: NV4_ChannelIsGdi()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

ULONG NV4_ChannelIsGdi(PDEV *ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  regValue;

    pfifoDmaReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);

    regValue = READ_REGISTER_ULONG(pfifoDmaReg);
    if ((regValue & MASK_OUT_OTHER_CHANNELS) == 0) // if its GDI return TRUE
        {
        return(1); // GDI channel
        }

    return(0); // not GDI channel
    }

//******************************************************************************
//
// Function: NV4_WaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitForChannelSwitch(PDEV*   ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  *pfifoCache1Push1;
    volatile ULONG  *pfifoCache1Status;
    volatile ULONG  *pfifoCache1DmaPush;
    volatile ULONG  *GrStatusReg;
    volatile ULONG  regValue;

    if (!ppdev->PFIFORegs)
        {
        ppdev->oglLastChannel = GDI_CHANNEL_ID;
        return;
        }

    if (ppdev->oglLastChannel == GDI_CHANNEL_ID)
        {
        return;
        }
    
    pfifoDmaReg        = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);
    pfifoCache1Push1   = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
    pfifoCache1Status  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_STATUS);
    pfifoCache1DmaPush = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_PUSH);

    //
    // Wait for all DMA push channels to be not busy.
    // TODO: wait on DirectDraw PIO channel...
    // TODO: in these loops we should not just hammer the bus, we should probably do a sleep...
    //
    regValue = READ_REGISTER_ULONG(pfifoDmaReg);
    // Assume that GDI is channel 0 and wait for all other channels to go to 0 (not active)
    while (regValue)
        {
        MagicDelay ();
        regValue = READ_REGISTER_ULONG(pfifoDmaReg);
        }

    //
    // If its not the GDI channel then wait for DMA push to complete in FIFO
    //
    regValue = READ_REGISTER_ULONG(pfifoCache1Push1);
    if ((regValue & CACHE1_PUSH1_MODE_DMA) && ((regValue & 0x1F) != GDI_CHANNEL_ID))
        {
        regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
        while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0)
            {
            MagicDelay ();
            regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
            }
        regValue = READ_REGISTER_ULONG(pfifoCache1Status);
        while ((regValue & CACHE1_STATUS_LOW_MARK_EMPTY) == 0)
            {
            MagicDelay ();
            regValue = READ_REGISTER_ULONG(pfifoCache1Status);
            }
        }

    GrStatusReg = ppdev->GrStatusReg;

    while (*GrStatusReg)
        {
        MagicDelay ();
        }

    // On NV15 there is a one cycle bubble between the fifo and the gfx
    // engine where the status register may indicate idle.  Reading it
    // twice ensures that we won't hit the bubble.
    while (*GrStatusReg)
        {
        MagicDelay ();
        }

    return;
    }
#pragma optimize("",on)


//******************************************************************************
//
// Function: NV4_GraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_GraphicsEngineBusy(PDEV*   ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    ULONG           intr;

    if (ppdev == NULL)
        return FALSE;

    pfifoDmaReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);

    //
    // Return DMA push register status
    // FIXME: TODO check DirectDraw PIO channel...
    //

    intr = READ_REGISTER_ULONG(pfifoDmaReg);
    if  (intr)
        return(TRUE);
    else
        return(FALSE);
    }


//******************************************************************************
//
// Function: NV4_WaitWhileVBlankActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileVBlankActive(PDEV*   ppdev)

    {
    while (NV4_VBlankIsActive(ppdev))
        MagicDelay();
    }

//******************************************************************************
//
// Function: NV3_WaitWhileDisplayActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileDisplayActive(PDEV*   ppdev)

    {
    while (NV4_DisplayIsActive(ppdev))
        MagicDelay();
    }


//******************************************************************************
//
// Function: NV4_WaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    if (ppdev == NULL)
        return;

    NV4_WaitForChannelSwitch(ppdev);

    ppdev->NVFreeCount = 0;

    }


//******************************************************************************
//
// Function: NV4_DmaPushWaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushWaitForChannelSwitch(PDEV*   ppdev)

    {

    if (ppdev == NULL)
        return;

    NV4_WaitForChannelSwitch(ppdev);

    return;
    }

//******************************************************************************
//
// Function: NV4_DmaPushGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_DmaPushGraphicsEngineBusy(PDEV*   ppdev)

    {
    volatile ULONG *GrStatusReg;

// TODO: Update this code for NV4 !!

    //**************************************************************************
    // It's possible that the device may have been disabled, and this function
    // still gets called (when pjmmbase == NULL). So make sure we don't
    // try to access the user channel if it doesn't exist!
    //**************************************************************************

    //**************************************************************************
    // Get pointer to graphics status register
    //**************************************************************************

    GrStatusReg = ppdev->GrStatusReg;

    //**************************************************************************
    // Wait for graphics engine to to finish
    //
    // WARNING: The compiler will generate code that reads the
    //          bottom BYTE of the CONFIG0 REG. We need to be
    //          aware of this in case we need to use registers
    //          which REQUIRE entire DWORD reads. To make sure we read
    //          an ENTIRE Dword, we can set a bit in the highest
    //          byte. This will force a DWORD read.  Also, we
    //          know that Bit 31 will ALWAYS be 0 for PFB_CONFIG_0
    //          register. So, no harm done. As always, check the LISTING !!
    //**************************************************************************

    if  (*GrStatusReg)  //& (NV_PGRAPH_STATUS_STATE_BUSY | 0x80000000))
        return(TRUE);
    else
        return(FALSE);
    }

 
//******************************************************************************
//
// Function: NV4_DmaPushWaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DmaPushWaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    DECLARE_DMA_FIFO;

    // HW is not intialized yet.
    if((ppdev == NULL) || (!ppdev->bEnabled) || (ppdev->NVSignature != NV_SIGNATURE))
        return;

    //**************************************************************************
    // MAKE SURE that the RM is done updating the palette registers
    // before we start freeing the contexts associated with the colormap object
    // (Make sure the 2nd notifier array entry (index 1) is zero)
    // See NV4DmaPushSetPalette for more information
    //**************************************************************************
    if (ppdev->iBitmapFormat == BMF_8BPP)
        while ( (volatile)(((NvNotification *) (&(ppdev->Notifiers->DmaToMem[NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY*sizeof(NvNotification)])))->status) != NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS );

    //*************************************************************************************************************************
    // Here is the sequence of opearations we do to ensure we syncronize correctly with other channels and the graphics engines.
    // what we will do.
    // 1.   Do a channelswitch to make sure GDI is the current channel.
    // 2.   Do a notifier to make sure the GDI channel's pushbuffer and hardware FIFO is empty and that the graphics engine
    //      is idle.
    // 3.   Read the Graphics status register to make sure the graphics engine is idle. This third step is not really
    //      necessary as the notifier should guarantee us that the graphics engine is idle but it should not hurt.
    // 4.   Finally, Set the CachedGet Pointer to be equal to the CachedPut pointer as the pushbuffer is guaranteed to be
    //      empty at this point.
    //*************************************************************************************************************************

    //**********************************
    // First do a channel switch to GDI
    //**********************************
    ppdev->pfnWaitForChannelSwitch(ppdev);

    //*********************************************************************************************************
    // Using the notifier method is the most guaranteed way of making sure our channel has finished rendering.
    // We use a notifier to make sure the
    // engine is no longer busy. We'll just send a NO-OP (using the
    // RECT_AND_TEXT object) and wait for the notifier to complete.
    //*********************************************************************************************************
    INIT_LOCAL_DMA_FIFO;
    if (ppdev->nvDmaFifo == NULL)
        return;
    ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status = NV04A_NOTIFICATION_STATUS_IN_PROGRESS;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(4)));

    //**************************************************************************
    // Send the NO-OP on thru
    //**************************************************************************
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,  NV04A_NOTIFY       , NV04A_NOTIFY_WRITE_ONLY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,  NV04A_NO_OPERATION , 0x00000000);

    //**************************************************************************
    // Kickoff the DMA push operation immediately
    // Make sure to update the DMA put pointer first
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    //**************************************************************************
    // Wait for completion...
    //**************************************************************************
    while ( ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status == NV04A_NOTIFICATION_STATUS_IN_PROGRESS);

    //*****************************************************************************************************************
    // Now read the graphics status register. This is strictly not necessary since we are using the notifier above, but
    // it should not hurt.
    //*****************************************************************************************************************
    while (NV4_DmaPushGraphicsEngineBusy(ppdev));

    //*************************************************************************************************
    // Now we know that our push buffer is empty. So set the Get pointer to be equal to the put pointer
    //*************************************************************************************************
    ppdev->nvDmaCachedGet = ppdev->nvDmaCachedPut;
}

 
//******************************************************************************
//
// Function: NV4_AcquireOglMutex
//
// Routine Description:
//
//     Acquire the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID NV4_AcquireOglMutex(PDEV *ppdev)
{
}

//******************************************************************************
//
// Function: NV4_ReleaseOglMutex
//
// Routine Description:
//
//     Release the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_ReleaseOglMutex(PDEV *ppdev)
{
}


//******************************************************************************
//
// Function: nvDDrawSynWithNvGdiDrv 
//
// Routine Description:
//     This funciton is called by nvDDraw to syn. rendering
//     
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
void __cdecl nvDDrawSynWithNvGdiDrv(PDEV*   ppdev)
{
    ppdev->pfnWaitEngineBusy(ppdev);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4textc.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV4TEXTC.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// We'll add the 565 bitmap format functions here 
// (We'll use the NV3 functions for 555 format)
//******************************************************************************


//******************************************************************************
// Extern declarations
//******************************************************************************

extern void NV4_DrawFastGlyphs (SURFOBJ*, STROBJ*, FONTOBJ*, RECTL*,
                                GLYPHPOS*, ULONG);
extern VOID vClipSolid(PDEV* ,LONG ,RECTL *,ULONG ,CLIPOBJ*);
extern RECTL grclMax;
extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


//*****************************************************************************
//
// Function: NV4DmaPushTextOut()
//
// Routine Description:
//
//   Outputs text using the 'buffer expansion' method.  The CPU draws to a
//   1bpp buffer, and the result is colour-expanded to the screen using the
//   hardware.
//
//   Note that this is x86 only ('vFastText', which draws the glyphs to the
//   1bpp buffer, is writen in Asm).
//
//   If you're just getting your driver working, this is the fastest way to
//   bring up working accelerated text.  All you have to do is write the
//   'Xfer1bpp' function that's also used by the blt code.  This
//   'bBufferExpansion' routine shouldn't need to be modified at all.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************


BOOL NV4DmaPushTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)

    {
    PDEV*           ppdev;
    ULONG           cGlyphOriginal;
    BOOL            bMore;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgpOriginal;
    BYTE            iDComplexity;
    CLIPENUM        ce;
    RECTL           rclOpaque;

    RECTL*          prclClip;
    ULONG           Color1;

    ULONG           x,y;
    ULONG           width,height;
    ULONG           AlphaEnableValue;

    DECLARE_DMA_FIFO;
    
    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    //*************************************************************************
    // Get push buffer information    
    //*************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //*************************************************************************
    // Determine the ALPHA_CHANNEL enable value
    //*************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //*************************************************************************
    // Make sure ROP is correct.
    // NOTE: needed below in case there is no rectangle.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //*************************************************************************
    // Check if we need to draw the opaque rectangle first
    //*************************************************************************

    if (prclOpaque != NULL)
        {

        //*********************************************************************
        // Opaque Initialization - No clipping necessary
        //*********************************************************************

        if (iDComplexity == DC_TRIVIAL)
            {

DrawOpaqueRect:

            x = prclOpaque->left;
            y = prclOpaque->top;
            width = prclOpaque->right - x;
            height = prclOpaque->bottom - y;

            NV_DMAPUSH_START (3, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);

            NV_DMA_FIFO = (AlphaEnableValue | pboOpaque->iSolidColor);
            NV_DMA_FIFO = (x << 16) | y;
            NV_DMA_FIFO = (width << (16) | height);
            }

        //*********************************************************************
        // Opaque Initialization - Check for single clipping rectangle
        //*********************************************************************

        else if (iDComplexity == DC_RECT)
            {
            if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
                }
            }

        //*********************************************************************
        // Opaque Initialization - Check for multiple rectangles to be drawn
        //*********************************************************************

        else
            {
            //*****************************************************************
            // WARNING: Make sure to update the global push buffer count here
            //          first, because vClipSolid ALSO updates the buffer Count
            //*****************************************************************


            UPDATE_PDEV_DMA_COUNT;
            vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);

            //*****************************************************************
            // WARNING: Now make sure our local DMA Count has been updated
            //          because we'll use it below!
            //*****************************************************************

            UPDATE_LOCAL_DMA_COUNT;
            }
        }    // if (prclOpaque != NULL)

//*****************************************************************************
//
//      Handles any strings that need to be clipped.
//
//*****************************************************************************

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //*************************************************************************
    // Since we are using Class D of the monster text class, we don't
    // have to specify color 0 (It's always transparent)
    // We only need to get and specify the color for the '1' bits.
    //
    // NV4: Class D is now gone in NV4, but we can simulate it by
    //      using Class C and Class E.  Just use Class C but send
    //      SizeIn, SizeOut, and Point to Class E.
    //*************************************************************************

    Color1 = pboFore->iSolidColor | AlphaEnableValue; // Visible

    //*************************************************************************
    // NOTE: ROP set correctly above.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2))); 
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_C, Color1);

    do  {

        //*********************************************************************
        // pstro->pgp points to the GLYPHPOS array for the whole string.
        // If it is NONZERO, then enumeration is not needed.  There's
        // just one batch of glyphs
        //*********************************************************************

        if (pstro->pgp != NULL)
            {
            //*****************************************************************
            // There's only the one batch of glyphs, so save ourselves
            // a call:
            //
            // pgpOriginal   --> GLYPHPOS (contains glyph definition and src
            //                   origin
            // cGlyphOriginal -> Number of glyphs in the string object
            // bMoreGlyphs    -> Since there's only one batch, don't enumerate
            //*****************************************************************

            pgpOriginal    = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs    = FALSE;
            }
        else
            {
            //*****************************************************************
            // Get next batch of GLYPHPOS structures
            //*****************************************************************

            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
            }

        //*********************************************************************
        // Check if we have any glyphs to output
        //*********************************************************************

        if (cGlyphOriginal > 0)
            {
            //*****************************************************************
            // Simple clipping case - either none or rectangular
            //*****************************************************************

            if (iDComplexity != DC_COMPLEX)
                {
                //*************************************************************
                // grclMax essentially means to ignore clipping
                // Otherwise, use the bounds specified in the CLIP Object
                //*************************************************************
    
                if (iDComplexity == DC_TRIVIAL)
                    prclClip = &grclMax;
                else
                    prclClip = &pco->rclBounds;

                UPDATE_PDEV_DMA_COUNT;

                NV4_DrawFastGlyphs (pso,
                                    pstro,
                                    pfo,
                                    prclClip,
                                    pgpOriginal,
                                    cGlyphOriginal);
            
                NV4_DmaPushSend(ppdev);
                UPDATE_LOCAL_DMA_COUNT;
                }

            //*****************************************************************
            //
            // Complex clipping case
            //
            // pco           -> Clip Object
            // FALSE         -> only parts relevant to the current drawing
            //                  operation should be enumerated.  Otherwise,
            //                  the whole region should be enumerated (TRUE)
            // CT_RECTANGLES -> Region is to be enumerated as a list of
            //                  rectangles
            //*****************************************************************
    
            else
                {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            //*****************************************************************
            // Get the next clip rectangle to be enumerated from clip region.
            // (ce holds the clip rectangle)
            //*****************************************************************
    
                do  {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                //**************************************************************
                // Draw glyphs for each clipping rectangle
                //**************************************************************

                    for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
                        {
                            UPDATE_PDEV_DMA_COUNT;

                            NV4_DrawFastGlyphs (pso,
                                                pstro,
                                                pfo,
                                                prclClip,
                                                pgpOriginal,
                                                cGlyphOriginal);
                    
                            NV4_DmaPushSend(ppdev);
                            UPDATE_LOCAL_DMA_COUNT;

                        } // For prclClip...

                    } while (bMore);  // do while loop

                } // else (complex clipping case)

            } // if (cglyphoriginal)...
        
        } while (bMoreGlyphs); // main do while loop

    return (TRUE);

    }

#ifdef _WIN64
//*****************************************************************************
//
// Function: NV4_DrawFastGlyphs()
//
// Routine Description:
//
//   C version for IA64 bringup.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

#define MAX_MONO_DWORDS    128   // sizeof Color1C array in Nv04GdiRectangleText

void NV4_DrawFastGlyphs (
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
RECTL*    prclClip,
GLYPHPOS* pgpParm,
ULONG     glyphCount)
    {
    PDEV*           ppdev;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    POINTL          ptlOrigin;
    ULONG           ulCharInc;
    ULONG           height;
    ULONG           width;
    ULONG           widthByteAligned;
    ULONG           widthBytes;
    ULONG           widthDwords;
    ULONG           glyphDwordsTotal;
    ULONG           glyphDwordsIter;
    ULONG*          glyphData;
    ULONG           i, j;

    DECLARE_DMA_FIFO;
    
    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //*************************************************************************
    // Get push buffer information    
    //*************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    NV_DMAPUSH_CHECKFREE((ULONG)(6 + glyphCount));  

    NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_CLIP_POINT0_C);
    NV_DMA_FIFO = (prclClip->top << 16)    | prclClip->left;
    NV_DMA_FIFO = (prclClip->bottom << 16) | prclClip->right;
    
    //*************************************************************************
    // Trivial rejection
    //*************************************************************************

    if ((prclClip->right  < pstro->rclBkGround.left) ||
        (prclClip->bottom < pstro->rclBkGround.top) ||
        (prclClip->left   > pstro->rclBkGround.right) ||
        (prclClip->top    > pstro->rclBkGround.bottom))
        {
            return;
        }
   
    ulCharInc = pstro->ulCharInc;

    for (i = 0, pgp = pgpParm;
         i < glyphCount;
         i++, pgp = (GLYPHPOS *)((BYTE *)pgp + sizeof(GLYPHPOS)))
        {
            pgb = pgp->pgdf->pgb;
            if ((ulCharInc == 0) || (i == 0))
                {
                ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;
                }
            else
                {
                ptlOrigin.x += ulCharInc;
                }
            //*****************************************************************
            // Eliminate beginning glyphs that are clipped on the left
            //*****************************************************************
            if ((ptlOrigin.x + pgb->sizlBitmap.cx) <= prclClip->left)
                continue;

            height = pgb->sizlBitmap.cy & 0xffff;            

            if ((height==0) ||
                (ptlOrigin.x > prclClip->right) ||
                (ptlOrigin.y > prclClip->bottom))
                {
                continue;
                }

            width = pgb->sizlBitmap.cx & 0xffff;

            widthByteAligned = (width + 7) & 0xfff8;
            widthBytes = widthByteAligned >> 3;
            glyphDwordsTotal = ((widthBytes * height) + 3) >> 2;
            
            NV_DMAPUSH_CHECKFREE((ULONG)(4));
    
            NV_DMAPUSH_START (3, RECT_AND_TEXT_SUBCHANNEL, NV04A_SIZE_IN_E);
            NV_DMA_FIFO = height << 16 | widthByteAligned;
            NV_DMA_FIFO = height << 16 | width;
            NV_DMA_FIFO = (ptlOrigin.y << 16) | (ptlOrigin.x & 0xffff);
    
            glyphData = (ULONG *)pgb->aj;

            do  {
                glyphDwordsIter = min(glyphDwordsTotal, MAX_MONO_DWORDS);

                NV_DMAPUSH_CHECKFREE((ULONG)(glyphDwordsIter + 1));

                NV_DMAPUSH_START(glyphDwordsIter,
                                 RECT_AND_TEXT_SUBCHANNEL,
                                 NV04A_MONOCHROME_COLOR1_C(0));
                
                for (j = 0; j < glyphDwordsIter; j++)
                    {
                    NV_DMA_FIFO = *glyphData++;
                    }
                glyphDwordsTotal -= glyphDwordsIter;

                } while (glyphDwordsTotal > 0);
        }
    UPDATE_PDEV_DMA_COUNT;
    }
#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvdoublebuf.h ===
#ifndef _NVDOUBLEBUF_H
#define _NVDOUBLEBUF_H
/**************************************************************************
** nvdoublebuf.h
**
** Export file for nvdoublebuf.c. Declare exported functions.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 12.10.2000: New
**************************************************************************/

BOOL bDoublePumped(PPDEV ppdev, ULONG ulSurfaceOffset);
void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets);
void NV_DisableDoubleBufferMode(PPDEV  ppdev);
BOOL NV_AddDoubleBufferSurface(PPDEV ppdev, ULONG ulSurfaceOffset);
BOOL NV_RemoveDoubleBufferSurface(PPDEV ppdev, ULONG ulSurfaceOffset);
VOID NV_InitDoubleBufferSavedProcs(PPDEV ppdev);


#endif // _NVDOUBLEBUF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvdoublebuf.c ===
//******************************Module*Header*******************************
// Module Name: nvdoublebuf.c
//
// Double buffer, windowed full screen flipping support.
//
// Copyright (c) 1998 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "Nvcm.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvReg.h"
#include "cliplist.h"
#include "oglsync.h"

//
// Export:
//
#include "nvdoublebuf.h"


/*
#define DOUBLE_PASS(PROC) {                             \
    ULONG FirstBufferOffset = ppdev->CurrentDestOffset; \
    ppdev->DoubleBuffer.SavedProcs.PROC;                \
    if (ppdev->CurrentDestOffset <                      \
        (ppdev->ulPrimarySurfaceOffset +                \
         (ppdev->lDelta * ppdev->cyScreen))) {          \
            ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.SecondBufferOffset + ppdev->CurrentDestOffset, ppdev->CurrentDestPitch); \
            ppdev->DoubleBuffer.SavedProcs.PROC;                                                           \
            ppdev->pfnSetDestBase(ppdev, FirstBufferOffset, ppdev->CurrentDestPitch);                      \
    }                                                                                                      \
}
*/
#define DBL_SRC  0x0001
#define DBL_DEST 0x0002
#define DBL_PSO  0x0004

#define NOPFN 0 // NOP function used as call prior to double pumped PROC

//*************************************************************************
// DOUBLE_PASS
// 
// macro to douple pump low level GDI functions to all buffers in 
// ppdev->DoubleBuffer.MultiBufferOffsets.
// 
// PSO          optional SURFOBJ*
//              NOTE: call macro with '0' if not used!
// PROC         function including parameter list that has to be called
// PREPROC      optional code called prior to the double pumped PROC
//              NOTE: call macro with 'NOPFN' if not used!
// RET_STRING   optional code that is placed in front of the PROC call
//              used to set return values.
//              NOTE: Call macro with ';' if not used!
// Examples: code below
//*************************************************************************
#define DOUBLE_PASS(PSO,PROC,PREPROC,RET_STRING) {           \
    int i;                                                   \
    unsigned int doubleFlags;                                \
    ULONG LastDestOffset = ppdev->CurrentDestOffset;         \
    ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     \
    VOID  *LastPSOPtr = NULL;                                \
    if ((PSO) && ((SURFOBJ*)(PSO))->dhsurf) {                \
        LastPSOPtr = ((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr; \
    }                                                        \
    doubleFlags = GetDoubleFlags(ppdev,(SURFOBJ*)(PSO));     \
    RET_STRING ppdev->DoubleBuffer.SavedProcs.PROC;          \
    for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       \
        if (doubleFlags & DBL_SRC) {                         \
            ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  \
                LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch);           \
        }                                                                                               \
        if (doubleFlags & DBL_DEST) {                                                                   \
            ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    \
                LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);               \
        }                                                    \
        if (doubleFlags & DBL_PSO) {                         \
            (char *)((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr = (char *) LastPSOPtr +              \
                ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                ppdev->ulPrimarySurfaceOffset;               \
        }                                                    \
        if (doubleFlags & (DBL_DEST|DBL_PSO)) {              \
            PREPROC;                                         \
            RET_STRING ppdev->DoubleBuffer.SavedProcs.PROC;  \
        }                                                    \
    }                                                        \
    if (doubleFlags & DBL_SRC) {                             \
        ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); \
    }                                                                                \
    if (doubleFlags & DBL_DEST) {                                                    \
        ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       \
    }                                                                                \
    if (doubleFlags & DBL_PSO) {                                                     \
        ASSERTDD(NULL != LastPSOPtr, "Bad LastPSOPtr");                              \
        ((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr = LastPSOPtr;                 \
    }                                                                                \
}

unsigned int GetDoubleFlags(PDEV* ppdev, SURFOBJ *pso)
{
    unsigned int doubleFlags = 0;
    NvU32        maxOffset;
    NvU32        newOffset;
    NvS32        delta;

    maxOffset = (ppdev->ulPrimarySurfaceOffset +                
                 (ppdev->lDelta * ppdev->cyScreen));

    if ((ppdev->CurrentSourceOffset >= ppdev->ulPrimarySurfaceOffset) &&
        (ppdev->CurrentSourceOffset < maxOffset)) {
        doubleFlags |= DBL_SRC;
    }
    if ((ppdev->CurrentDestOffset >= ppdev->ulPrimarySurfaceOffset) &&
        (ppdev->CurrentDestOffset < maxOffset)) {
        doubleFlags |= DBL_DEST;
    }
    // If only the source offset is inside of the primary
    // surface while the destination offset is offscreen, then
    // we have to make sure that we blit from memory that 
    // is actually onscreen since OpenGL may
    // have flipped the visible surface.  PaulP 10/11/2000
    if (doubleFlags == DBL_SRC) {
        if (OGL_FLIPPED()) {
            // The visible surface is flipped to the backbuffer
            // Need to set the source to the backbuffer.
            delta = ppdev->ulFlipBase - ppdev->ulPrimarySurfaceOffset;
            newOffset = ppdev->CurrentSourceOffset + delta;
            ppdev->pfnSetSourceBase(ppdev, newOffset, ppdev->CurrentSourcePitch);
        }
    }
    if (pso && pso->dhsurf) {
        VOID *LinearPtr = ((DSURF*)pso->dhsurf)->LinearPtr;
        if (((PUCHAR)LinearPtr >= ppdev->pjScreen) &&
            ((PUCHAR)LinearPtr < ppdev->pjFrameBufbase + maxOffset)) {
            doubleFlags |= DBL_PSO;
        }
    }

    return doubleFlags;
}

VOID NVDmaPushFillSolid_DBLBUF(       // Type FNFILL
    PDEV*           ppdev,
    LONG            c,              // Can't be zero
    RECTL*          prcl,           // List of rectangles to be filled, in relative
                                    //   coordinates
    ULONG           rop4,           // rop4
    RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
    POINTL*         pptlBrush)      // Not used

{
    DOUBLE_PASS(0,pfnFillSolid(ppdev, c, prcl, rop4, rbc, pptlBrush),NOPFN,;);
}


VOID NVDmaPushFillPatFast_DBLBUF(            // Type FNFILL
    PDEV*           ppdev,
    LONG            c,              // Can't be zero
    RECTL*          prcl,           // List of rectangles to be filled, in relative
                                    //   coordinates
    ULONG           rop4,           // rop4
    RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
    POINTL*         pptlBrush)      // Pattern alignment

{
    DOUBLE_PASS(0,pfnFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush),NOPFN,;);
}


VOID NVDmaPushXfer1bpp_DBLBUF(       // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // List of destination rectangles, in relative
                            //   coordinates
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,     // Solid Color of pattern
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer1bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXfer4bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // Array of relative coordinates destination rectangles
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,
    BLENDOBJ*   pBlendObj)  // Not used
{
    DOUBLE_PASS(0,pfnXfer4bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXferNative_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // Array of relative coordinates destination rectangles
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,
    BLENDOBJ*   pBlendObj)  // Not used
{
    DOUBLE_PASS(0,pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
/*    {                       
        unsigned int i, doubleFlags;                             
        ULONG LastDestOffset = ppdev->CurrentDestOffset;         
        ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     
        doubleFlags = GetDoubleFlags(ppdev);                     
        ppdev->DoubleBuffer.SavedProcs.pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj);                     
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       
            if (doubleFlags & DBL_SRC) {                         
                ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  
                    LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch); 
            }                                                                                               
            if (doubleFlags & DBL_DEST) {                                                                   
                ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    
                    LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);     
            }                                                    
            if (doubleFlags & DBL_DEST) {                                   
                ppdev->DoubleBuffer.SavedProcs.pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj);  
            }                                                    
        }                                                        
        if (doubleFlags & DBL_SRC) {                             
            ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); 
        }                                                                                
        if (doubleFlags & DBL_DEST) {                                                    
            ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       
        }                                                                                
    }
    */
}


VOID NVDmaPushCopyBlt_DBLBUF(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ *pBlendObj)
{
    DOUBLE_PASS(0,pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj),NOPFN,;);
/*    {                       
        unsigned int i, doubleFlags;                             
        ULONG LastDestOffset = ppdev->CurrentDestOffset;         
        ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     
        doubleFlags = GetDoubleFlags(ppdev);                     
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj);                     
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       
            if (doubleFlags & DBL_SRC) {                         
                ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  
                    LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch); 
            }                                                                                               
            if (doubleFlags & DBL_DEST) {                                                                   
                ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    
                    LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);     
            }                                                    
            if (doubleFlags & DBL_DEST) {                                   
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj);  
            }                                                    
        }                                                        
        if (doubleFlags & DBL_SRC) {                             
            ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); 
        }                                                                                
        if (doubleFlags & DBL_DEST) {                                                    
            ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       
        }                                                                                
    }
*/
}


VOID NVDmaPushXfer4to16bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer4to16bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}



VOID NVDmaPushXfer8to16bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer8to16bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXfer4to32bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer4to32bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}



VOID NVDmaPushXfer8to32bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer8to32bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushFastXfer8to32_DBLBUF(   // Type FastXFER
    PDEV*       ppdev,
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    XLATEOBJ*   pxlo)
{
    DOUBLE_PASS(0,pfnFastXfer8to32(ppdev, prcl, psoSrc, pptlSrc,pxlo),NOPFN,;);
}


VOID NVDmaPushFastXfer8to16_DBLBUF(   // Type FastXFER
    PDEV*       ppdev,
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    XLATEOBJ*   pxlo)
{
    DOUBLE_PASS(0,pfnFastXfer8to16(ppdev, prcl, psoSrc, pptlSrc,pxlo),NOPFN,;);
}

VOID NVDmaPushIndexedImage_DBLBUF(    // Type FNXFER

    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnIndexedImage(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushMemToScreenBlt_DBLBUF(
    PDEV*   ppdev,
    SURFOBJ* psoSrc,
    POINTL* pptlSrc,
    RECTL*  prclDst)
{
    DOUBLE_PASS(0,pfnMemToScreenBlt(ppdev, psoSrc, pptlSrc, prclDst),NOPFN,;);
}

VOID NVDmaPushMemToScreenWithPatternBlt_DBLBUF(
    PDEV*   ppdev,
    SURFOBJ* psoSrc,
    POINTL* pptlSrc,
    RECTL*  prclDst,
    ULONG rop3,
    RBRUSH_COLOR   *rbc,
    RECTL*  prclClip)
{
    DOUBLE_PASS(0,pfnMemToScreenPatternBlt(ppdev, psoSrc, pptlSrc, prclDst, rop3, rbc, prclClip),NOPFN,;);
}


BOOL NVDmaPushTextOut_DBLBUF(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque)
{
    PDEV*  ppdev;
    BOOL retval;
    
    ppdev = (PDEV*) pso->dhpdev;

    // need to reset STROBJ in the case it was enumerated but not started properly
    DOUBLE_PASS(0,pfnTextOut(pso, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque),STROBJ_vEnumStart(pstro),retval =);
    return retval;
}


//
//  Function bFlippingBufferAdjustPass
//
//  Function sets psoSrc-bufferoffset to ICD's frontbuffer if psoSrc
//  is our Primary and calls unflipped function
//
//  return value: return value of given  unflipped function
//
//  MSchwarzer 12/10/2000: new
//
BOOL bFlippingBufferAdjustPass( 
    FNSCRNTOMEM*    pfnScreenToMem,
    PDEV*           ppdev,
    LONG            c,
    RECTL*          prcl,
    SURFOBJ*        psoSrc,
    SURFOBJ*        psoDst,
    POINTL*         pptlSrc,
    RECTL*          prclDst,
    XLATEOBJ*       pxlo)
{
    BOOL bRet;
    PVOID pvLastSourceOffset;

    ASSERT(ppdev);
    ASSERT(psoSrc);
    ASSERT(psoSrc->dhsurf);     // Src is our Screen => we have an dhsurf !
    ASSERT(pfnScreenToMem);

    pvLastSourceOffset = ((DSURF*)psoSrc->dhsurf)->LinearPtr;

    // do we blt from Primary ?
    // if( STYPE_DEVICE == psoSrc->iType ) //: another possibility to test
    if(pvLastSourceOffset == ppdev->pjScreen)
    {
        if(OGL_FLIPPED()) 
        {
            // The visible surface is flipped to the backbuffer => set the source to the backbuffer.
            ((DSURF*)psoSrc->dhsurf)->LinearPtr = ppdev->pjScreen + ppdev->ulFlipBase;
        }
    }

    bRet = pfnScreenToMem(ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    // reset base of PSO
    ((DSURF*)psoSrc->dhsurf)->LinearPtr = pvLastSourceOffset;

    return bRet;
}


//
//  Function NVScreenTo1bppMemBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenTo1bppMemBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenTo1bppMemBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenTo1bppMemBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenTo1bppMemBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMemBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMemBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMemBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMemBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMemBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem16to4bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem16to4bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem16to4bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem16to4bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem16to4bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem32to4bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem32to4bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem32to4bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem32to4bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem32to4bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem16to8bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem16to8bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem16to8bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem16to8bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem16to8bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem32to8bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem32to8bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem32to8bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem32to8bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem32to8bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}



VOID NVScreenToScreenWithPatBlt_DBLBUF(
    
    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    BRUSHOBJ*   pbo,                // Brush object
    POINTL*     pptlBrush,          // Brush start coordinate in the pattern bits.
    ROP4        rop4)               // Op that describes the blit (must be 1 byte max)
{
    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt != NVScreenToScreenWithPatBlt_DBLBUF);

    DOUBLE_PASS(0,pfnScreenToScreenWithPatBlt(ppdev, c, parcl, pptlSrc, prclDst, pbo, pptlBrush, rop4),NOPFN,;);
}



BOOL NVDmaPushStrokePath_DBLBUF(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV*  ppdev;
    BOOL retval;
    
    ppdev = (PDEV*) pso->dhpdev;

    // need to reset PATHOBJ in the case it was enumerated but not started properly
    DOUBLE_PASS(pso,pfnStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix),PATHOBJ_vEnumStart(ppo),retval =);
    return retval;
}


BOOL NVDmaPushLineTo_DBLBUF(
    SURFOBJ*    pso,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL*      prclBounds,
    MIX         mix)
{
    PDEV*  ppdev;
    BOOL retval;

    ppdev = (PDEV*) pso->dhpdev;
    
    DOUBLE_PASS(0,pfnLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix),NOPFN,retval =);
    return TRUE;
}

static unsigned int 
GetEngDoubleFlags(PDEV *ppdev, 
                  SURFOBJ *psoSrc, SURFOBJ *psoDst,
                  PVOID *oldSrcBits, PVOID *oldSrcScan,
                  PVOID *oldDstBits, PVOID *oldDstScan)
{
    unsigned int  doubleFlags = 0;
    NvU32         maxOffset;
    NvS32         delta;

    if (ppdev == NULL) {
        return doubleFlags;
    }

    maxOffset = (ppdev->ulPrimarySurfaceOffset +                
                 (ppdev->cyScreen * ppdev->lDelta ));
    
    // Check if destination is within the front screen
    // Now using pvScan0 instead of pvBits because Eng is using it, too. Had a bluescreen because
    // our code didn't set up pso->pvBits correctly.
    if (psoDst && ((PUCHAR)psoDst->pvScan0 >= ppdev->pjScreen) &&   /***********/
        ((PUCHAR)psoDst->pvScan0 <  ppdev->pjFrameBufbase + maxOffset)) {
        doubleFlags |= DBL_DEST;
        *oldDstBits = psoDst->pvBits;
        *oldDstScan = psoDst->pvScan0;
    }

    // Check if source is within the front screen
    if (psoSrc && ((PUCHAR)psoSrc->pvScan0 >= ppdev->pjScreen) &&
        ((PUCHAR)psoSrc->pvScan0 <  ppdev->pjFrameBufbase + maxOffset)) {
        doubleFlags |= DBL_SRC;
        *oldSrcBits = psoSrc->pvBits;
        *oldSrcScan = psoSrc->pvScan0;
    }
    // If only the source offset is inside of the primary
    // surface while the destination offset is offscreen, then
    // we have to make sure that we blit from memory that 
    // is actually onscreen since OpenGL may
    // have flipped the visible surface.  PaulP 10/11/2000
    if (doubleFlags == DBL_SRC) {
        if (OGL_FLIPPED()) {
            // The visible surface is flipped to the backbuffer
            // Need to set the source to the backbuffer.
            delta = ppdev->ulFlipBase - ppdev->ulPrimarySurfaceOffset;
            (char *) psoSrc->pvBits  += delta;
            (char *) psoSrc->pvScan0 += delta;
        }
    }
    return doubleFlags;
}


#define ENG_DOUBLE_PASS(PROC,PREPROC,RET_STRING) {           \
    int i;                                                   \
    unsigned int doubleFlags;                                \
    PVOID oldSrcBits, oldSrcScan;                            \
    PVOID oldDstBits, oldDstScan;                            \
    doubleFlags = GetEngDoubleFlags(ppdev,psoSrc,psoDst,&oldSrcBits,&oldSrcScan,&oldDstBits,&oldDstScan);     \
    RET_STRING PROC;                                         \
    if (ppdev != NULL) {                                     \
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {   \
            if (doubleFlags & DBL_SRC) {                                                                      \
                (char *) psoSrc->pvBits = (char *) oldSrcBits + ppdev->DoubleBuffer.MultiBufferOffsets[i] -   \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
                (char *) psoSrc->pvScan0 = (char *) oldSrcScan + ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
            }                                                                                                 \
            if (doubleFlags & DBL_DEST) {                                                                     \
                (char *) psoDst->pvBits = (char *) oldDstBits + ppdev->DoubleBuffer.MultiBufferOffsets[i] -   \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
                (char *) psoDst->pvScan0 = (char *) oldDstScan + ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
            }                                                \
            if (doubleFlags & DBL_DEST) {                    \
                PREPROC;                                     \
                RET_STRING PROC;                             \
            }                                                \
        }                                                    \
        if (doubleFlags & DBL_SRC) {                         \
            psoSrc->pvBits  = oldSrcBits;                    \
            psoSrc->pvScan0 = oldSrcScan;                    \
        }                                                    \
        if (doubleFlags & DBL_DEST) {                        \
            psoDst->pvBits  = oldDstBits;                    \
            psoDst->pvScan0 = oldDstScan;                    \
        }                                                    \
    }                                                        \
}


BOOL APIENTRY NV_EngBitBlt_DBLBUF(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngBitBlt(psoDst,psoSrc,psoMask,pco,pxlo,prclTrg,pptlSrc,pptlMask,pbo,pptlBrush,rop4),NOPFN,retval &=);

    return retval;
}

BOOL APIENTRY NV_EngCopyBits_DBLBUF(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngCopyBits(psoDst,psoSrc,pco,pxlo,prclDest,pptlSrc),NOPFN,retval &=);

    return retval;
}

BOOL APIENTRY NV_EngTextOut_DBLBUF(
    SURFOBJ  *psoDst,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;

    // need to reset STROBJ in the case it was enumerated but not started properly
    ENG_DOUBLE_PASS(EngTextOut(psoDst,pstro,pfo,pco,prclExtra,prclOpaque,pboFore,pboOpaque,pptlOrg,mix),STROBJ_vEnumStart(pstro),retval &=);

    return retval;
}

BOOL APIENTRY NV_EngStrokePath_DBLBUF(
    SURFOBJ   *psoDst,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;
    
    // need to reset PATHOBJ in the case it was enumerated but not started properly
    ENG_DOUBLE_PASS(EngStrokePath(psoDst,ppo,pco,pxo,pbo,pptlBrushOrg,plineattrs,mix),PATHOBJ_vEnumStart(ppo),retval &=);

    return retval;
}

BOOL APIENTRY NV_EngLineTo_DBLBUF(
    SURFOBJ   *psoDst,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;
    
    ENG_DOUBLE_PASS(EngLineTo(psoDst,pco,pbo,x1,y1,x2,y2,prclBounds,mix),NOPFN,retval &=);

    return retval;
}

#if _WIN32_WINNT >= 0x0500
BOOL APIENTRY NV_EngAlphaBlend_DBLBUF(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDest,prclSrc,pBlendObj),NOPFN,retval &=);

    return retval;
    
}

BOOL APIENTRY NV_EngTransparentBlt_DBLBUF(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    ULONG         iTransColor,
    ULONG         Reserved)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngTransparentBlt(psoDst,psoSrc,pco,pxlo,prclDest,prclSrc,iTransColor,Reserved),NOPFN,retval &=);

    return retval;
    
}
#endif


//*************************************************************************
// NV_InitDoubleBufferSavedProcs
// 
// Initialize the SaveProcs structure with all non double pumping 
// hardware functions.
//*************************************************************************
VOID NV_InitDoubleBufferSavedProcs(PPDEV ppdev)
{
    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=ppdev->pfnFillSolid);

    ppdev->DoubleBuffer.SavedProcs.pfnFillSolid              = ppdev->pfnFillSolid;
    ppdev->DoubleBuffer.SavedProcs.pfnFillPat                = ppdev->pfnFillPat;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer1bpp               = ppdev->pfnXfer1bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4bpp               = ppdev->pfnXfer4bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXferNative             = ppdev->pfnXferNative;
    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt                = ppdev->pfnCopyBlt;
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4to16bpp           = ppdev->pfnXfer4to16bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer8to16bpp           = ppdev->pfnXfer8to16bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4to32bpp           = ppdev->pfnXfer4to32bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer8to32bpp           = ppdev->pfnXfer8to32bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to32          = ppdev->pfnFastXfer8to32;
    ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to16          = ppdev->pfnFastXfer8to16;
    ppdev->DoubleBuffer.SavedProcs.pfnIndexedImage           = ppdev->pfnIndexedImage;
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt         = ppdev->pfnMemToScreenBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenPatternBlt  = ppdev->pfnMemToScreenPatternBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnTextOut                = ppdev->pfnTextOut;
    ppdev->DoubleBuffer.SavedProcs.pfnSetPalette             = ppdev->pfnSetPalette;           
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnStrokePath             = ppdev->pfnStrokePath;
    ppdev->DoubleBuffer.SavedProcs.pfnLineTo                 = ppdev->pfnLineTo;

    ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt     = ppdev->pfnScreenTo1BppMemBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt         = ppdev->pfnScreenToMemBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt = ppdev->pfnScreenToMem16to4bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt = ppdev->pfnScreenToMem32to4bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt = ppdev->pfnScreenToMem16to8bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt = ppdev->pfnScreenToMem32to8bppBlt;

    ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt = ppdev->pfnScreenToScreenWithPatBlt;
}


//*************************************************************************
// NV_CopyPrimaryToDoubleBuffer
// 
// Copy entire screen from primary to fullscreen surface with given offset.
//*************************************************************************
VOID NV_CopyPrimaryToDoubleBuffer(
    PPDEV ppdev, 
    ULONG ulSurfaceOffset)
{
    POINTL  ptlSrc;
    RECTL   rcl;

    ASSERT(NULL!=ppdev);
    ASSERT(ppdev->ulPrimarySurfaceOffset!=ulSurfaceOffset);

    // First copy the front buffer to the multi buffers
    rcl.left   = 0;
    rcl.top    = 0;
    rcl.right  = ppdev->cxScreen;
    rcl.bottom = ppdev->cyScreen;
    ptlSrc.x   = 0;
    ptlSrc.y   = 0;

    OglSyncEngineUsingPDEV(ppdev);

    ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);

    // Hmm, can we assume that our dest surface has the same stride as the primary?
    ppdev->pfnSetDestBase(ppdev, ulSurfaceOffset, ppdev->lDelta);

    //
    // We only copy the GDI to the other buffers, not the OpenGL client which 
    // already might have a different content!
    //

    if (   (ppdev->OglNegativeClipList.c > 0)
        && (ulSurfaceOffset == ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        DISPDBG((3, "NV_CopyPrimaryToDoubleBuffer: copy %d exclusive primary to 0x%x", ppdev->OglNegativeClipList.c, ulSurfaceOffset));

        ASSERT(ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC);
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, ppdev->OglNegativeClipList.c, ppdev->OglNegativeClipList.prcl, 0xcccc, &ptlSrc, &rcl, NULL);
    }
    else
    {
        DISPDBG((3, "NV_CopyPrimaryToDoubleBuffer: copy primary to 0x%x", ulSurfaceOffset));
        // This will copy the entire screen to the back or other buffers
        // destroying their content. Visible backs are overwritten!
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rcl, 0xcccc, &ptlSrc, &rcl, NULL);
    }

    // finish blit
    ppdev->pfnWaitEngineBusy(ppdev);
}


//*************************************************************************
// NV_ClearDoubleBuffer
// 
// Clear entire fullscreen surface with given offset.
//*************************************************************************
VOID NV_ClearDoubleBuffer(
    PPDEV ppdev, 
    ULONG ulSurfaceOffset)
{
    RECTL   rcl;
    RBRUSH_COLOR rbc = {0};        // Realized brush or solid colour

    ASSERT(NULL!=ppdev);
    ASSERT(ppdev->ulPrimarySurfaceOffset!=ulSurfaceOffset); // never want to clear primary

    // First copy the front buffer to the multi buffers
    rcl.left   = 0;
    rcl.top    = 0;
    rcl.right  = ppdev->cxScreen;
    rcl.bottom = ppdev->cyScreen;

    rbc.iSolidColor = 0;

    // Hmm, can we assume that our dest surface has the same stride as the primary?
    ppdev->pfnSetDestBase(ppdev, ulSurfaceOffset, ppdev->lDelta);
    if (ppdev->OglNegativeClipList.c > 0)
    {
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, ppdev->OglNegativeClipList.c, ppdev->OglNegativeClipList.prcl, 0xF0F0, rbc, NULL);
    }
    else
    {
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, &rcl, 0xF0F0, rbc, NULL);
    }

    // finish blit
    ppdev->pfnWaitEngineBusy(ppdev);
}



//*************************************************************************
// NV_InitDoubleBufferMode
// 
// Initializes double buffer mode for the given buffers and resets the 
// function pointer list to DBLBUF functions.
//*************************************************************************
void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets)
{
    LONG    i;
    POINTL  ptlSrc;
    RECTL   prclDst;
    RECTL   rcl;
    DWORD   dwStatus;

    ASSERT(NULL != ppdev);
    ASSERT(0 != NumBuffers);
    ASSERT(NULL != MultiBufferOffsets);
    ASSERT(!ppdev->DoubleBuffer.bEnabled);

    if (ppdev->DoubleBuffer.bEnabled) {
        return;
    }

    ASSERT(0 == ppdev->DoubleBuffer.NumBuffers);

    ppdev->DoubleBuffer.bEnabled = TRUE;

    if (NumBuffers > NV_MAX_BUFFERS) {
        ASSERTDD(NumBuffers <= NV_MAX_BUFFERS,"Too many buffers");
        NumBuffers = NV_MAX_BUFFERS;
    }

    ppdev->DoubleBuffer.NumBuffers = NumBuffers;

    // need this buffer to exchange front to back when disabling flippingmode
    NVHEAP_ALLOC(dwStatus, ppdev->ulTempOffscreenBufferOffset, ppdev->lDelta, TYPE_IMAGE);
    if(dwStatus==0)
        ppdev->ulTempOffscreenBufferSize = ppdev->lDelta;
    else
    {
        ppdev->ulTempOffscreenBufferSize = 0;
        DISPDBG((0,"could not allocate temporary offscreen buffer in NV_InitDoubleBufferMode"));
    }

    for (i=0; i<NumBuffers; i++) {
        ASSERT(MultiBufferOffsets[i] != ppdev->ulPrimarySurfaceOffset);
        ppdev->DoubleBuffer.MultiBufferOffsets[i] = MultiBufferOffsets[i];
        NV_CopyPrimaryToDoubleBuffer(ppdev, MultiBufferOffsets[i]);
    }

    // Initialize save SavedProcs
    NV_InitDoubleBufferSavedProcs(ppdev);

    ppdev->pfnFillSolid              = NVDmaPushFillSolid_DBLBUF;
    ppdev->pfnFillPat                = NVDmaPushFillPatFast_DBLBUF;
    ppdev->pfnXfer1bpp               = NVDmaPushXfer1bpp_DBLBUF;   
    ppdev->pfnXfer4bpp               = NVDmaPushXfer4bpp_DBLBUF;   
    ppdev->pfnXferNative             = NVDmaPushXferNative_DBLBUF; 
    ppdev->pfnCopyBlt                = NVDmaPushCopyBlt_DBLBUF;    
                                                              
    ppdev->pfnXfer4to16bpp           = NVDmaPushXfer4to16bpp_DBLBUF; 
    ppdev->pfnXfer8to16bpp           = NVDmaPushXfer8to16bpp_DBLBUF; 
    ppdev->pfnXfer4to32bpp           = NVDmaPushXfer4to32bpp_DBLBUF; 
    ppdev->pfnXfer8to32bpp           = NVDmaPushXfer8to32bpp_DBLBUF; 
    ppdev->pfnFastXfer8to32          = NVDmaPushFastXfer8to32_DBLBUF; 
    ppdev->pfnFastXfer8to16          = NVDmaPushFastXfer8to16_DBLBUF; 
    ppdev->pfnIndexedImage           = NVDmaPushIndexedImage_DBLBUF;
                                                              
    ppdev->pfnMemToScreenBlt         = NVDmaPushMemToScreenBlt_DBLBUF;           
    ppdev->pfnMemToScreenPatternBlt  = NVDmaPushMemToScreenWithPatternBlt_DBLBUF;
    ppdev->pfnTextOut                = NVDmaPushTextOut_DBLBUF;
                                                              
    ppdev->pfnStrokePath             = NVDmaPushStrokePath_DBLBUF;
    ppdev->pfnLineTo                 = NVDmaPushLineTo_DBLBUF;

    ppdev->pfnScreenTo1BppMemBlt     = NVScreenTo1bppMemBlt_DBLBUF;
    ppdev->pfnScreenToMemBlt         = NVScreenToMemBlt_DBLBUF;
    ppdev->pfnScreenToMem16to4bppBlt = NVScreenToMem16to4bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem32to4bppBlt = NVScreenToMem32to4bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem16to8bppBlt = NVScreenToMem16to8bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem32to8bppBlt = NVScreenToMem32to8bppBlt_DBLBUF;     

    ppdev->pfnScreenToScreenWithPatBlt = NVScreenToScreenWithPatBlt_DBLBUF;

    ppdev->pfnEngBitBlt     = NV_EngBitBlt_DBLBUF;
    ppdev->pfnEngCopyBits   = NV_EngCopyBits_DBLBUF;
    ppdev->pfnEngTextOut    = NV_EngTextOut_DBLBUF;
    ppdev->pfnEngLineTo     = NV_EngLineTo_DBLBUF;
    ppdev->pfnEngStrokePath = NV_EngStrokePath_DBLBUF;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = NV_EngAlphaBlend_DBLBUF;
    ppdev->pfnEngTransparentBlt = NV_EngTransparentBlt_DBLBUF;
#endif
}


//*************************************************************************
// NV_DisableDoubleBufferMode
// 
// disables double pumping to all buffers, restores function pointers
//*************************************************************************
void NV_DisableDoubleBufferMode(PDEV *ppdev)
{
    ASSERT(NULL != ppdev);

    if (!ppdev->DoubleBuffer.bEnabled) {
        return;
    }
    ppdev->DoubleBuffer.bEnabled = FALSE;

    ASSERT(0!=ppdev->DoubleBuffer.NumBuffers);

#if DBG
    {
        LONG i;
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {
            NV_ClearDoubleBuffer(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i]);
        }
    }
#endif

    ppdev->DoubleBuffer.NumBuffers = 0;

    // free temporary doublebuffer-tempbuffer
    if(0!=ppdev->ulTempOffscreenBufferSize)
        NVHEAP_FREE(ppdev->ulTempOffscreenBufferOffset);
    ppdev->ulTempOffscreenBufferSize   = 0;
    ppdev->ulTempOffscreenBufferOffset = 0;

    ppdev->pfnFillSolid              = ppdev->DoubleBuffer.SavedProcs.pfnFillSolid              ;
    ppdev->pfnFillPat                = ppdev->DoubleBuffer.SavedProcs.pfnFillPat                ;
    ppdev->pfnXfer1bpp               = ppdev->DoubleBuffer.SavedProcs.pfnXfer1bpp               ;
    ppdev->pfnXfer4bpp               = ppdev->DoubleBuffer.SavedProcs.pfnXfer4bpp               ;
    ppdev->pfnXferNative             = ppdev->DoubleBuffer.SavedProcs.pfnXferNative             ;
    ppdev->pfnCopyBlt                = ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt                ;
                                                                                  
    ppdev->pfnXfer4to16bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer4to16bpp           ;
    ppdev->pfnXfer8to16bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer8to16bpp           ;
    ppdev->pfnXfer4to32bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer4to32bpp           ;
    ppdev->pfnXfer8to32bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer8to32bpp           ;
    ppdev->pfnFastXfer8to32          = ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to32          ;
    ppdev->pfnFastXfer8to16          = ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to16          ;
    ppdev->pfnIndexedImage           = ppdev->DoubleBuffer.SavedProcs.pfnIndexedImage           ;
                                                                                  
    ppdev->pfnMemToScreenBlt         = ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt         ;
    ppdev->pfnMemToScreenPatternBlt  = ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenPatternBlt  ;
    ppdev->pfnTextOut                = ppdev->DoubleBuffer.SavedProcs.pfnTextOut                ;
                                                                                  
    ppdev->pfnStrokePath             = ppdev->DoubleBuffer.SavedProcs.pfnStrokePath             ;
    ppdev->pfnLineTo                 = ppdev->DoubleBuffer.SavedProcs.pfnLineTo                 ;

    ppdev->pfnScreenTo1BppMemBlt     = ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt     ;
    ppdev->pfnScreenToMemBlt         = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt         ;
    ppdev->pfnScreenToMem16to4bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt ;     
    ppdev->pfnScreenToMem32to4bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt ;     
    ppdev->pfnScreenToMem16to8bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt ;     
    ppdev->pfnScreenToMem32to8bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt ;     

    ppdev->pfnScreenToScreenWithPatBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt ;     

    ppdev->pfnEngBitBlt     = EngBitBlt;
    ppdev->pfnEngCopyBits   = EngCopyBits;
    ppdev->pfnEngTextOut    = EngTextOut;
    ppdev->pfnEngLineTo     = EngLineTo;
    ppdev->pfnEngStrokePath = EngStrokePath;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = EngAlphaBlend;
#endif
}

//
// bDoublePumped
// 
// returns true if the surface offset belongs to a surface that is 2D double pumped
// 
BOOL bDoublePumped(PPDEV ppdev, ULONG ulSurfaceOffset)
{
    BOOL bRet=FALSE; // default exit: not double pumped
    LONG i;

    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglSingleBackDepthSupported
        && (   ppdev->bOglSingleBackDepthCreated
            || ppdev->bOglOverlaySurfacesCreated
            || ppdev->ulOglActiveViews != 0) )
    {
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) 
        {
            ASSERT(ppdev->DoubleBuffer.bEnabled);
            if (ulSurfaceOffset == ppdev->DoubleBuffer.MultiBufferOffsets[i])
            {
                // this surface is double pumped
                bRet=TRUE;
                break;
            }
        }
    }

    return bRet;
}


//*************************************************************************
// NV_AddDoubleBufferSurface
// 
// Adds a surface to the double pumping code and activates double 
// buffering if not enabled.
// Returns TRUE if succeeded.
//*************************************************************************
BOOL NV_AddDoubleBufferSurface(
    PPDEV  ppdev, 
    ULONG  ulSurfaceOffset)
{
    BOOL bRet = FALSE;

    if (   ppdev->bOglSingleBackDepthSupported
        && ppdev->bOglSingleBackDepthCreated)
    {
        ASSERT(!bDoublePumped(ppdev, ulSurfaceOffset));
        ASSERT(ulSurfaceOffset != ppdev->ulPrimarySurfaceOffset);
        ASSERT(ppdev->DoubleBuffer.NumBuffers >= 0);

        if (ppdev->DoubleBuffer.bEnabled)
        {
            // Already active, just add a buffer and initialize it
            NV_CopyPrimaryToDoubleBuffer(ppdev, ulSurfaceOffset);

            ppdev->DoubleBuffer.MultiBufferOffsets[ppdev->DoubleBuffer.NumBuffers] = ulSurfaceOffset;
            ASSERT(ppdev->DoubleBuffer.NumBuffers < NV_MAX_BUFFERS);
            ppdev->DoubleBuffer.NumBuffers++;
        }
        else
        {
            NV_InitDoubleBufferMode(ppdev, 1, &ulSurfaceOffset);
        }

        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// NV_RemoveDoubleBufferSurface
// 
// remove the surface with the given offset from the double pumping list 
// and deactivate double buffering if it was the last buffer. 
// Returns TRUE if succeeded.
//*************************************************************************
BOOL NV_RemoveDoubleBufferSurface(
    PPDEV  ppdev, 
    ULONG  ulSurfaceOffset)
{
    LONG i;
    BOOL bRet = FALSE;

    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglSingleBackDepthSupported
        && ppdev->bOglSingleBackDepthCreated)
    {
        ASSERT(bDoublePumped(ppdev, ulSurfaceOffset));
        ASSERT(ulSurfaceOffset != ppdev->ulPrimarySurfaceOffset);
        ASSERT(ppdev->DoubleBuffer.NumBuffers > 0);

        if (1 == ppdev->DoubleBuffer.NumBuffers)
        {
            NV_DisableDoubleBufferMode(ppdev);
        }
        else if (0 != ppdev->DoubleBuffer.NumBuffers)
        {
            // find offset in list (cannot fail!)
            for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) 
            {
                if (ulSurfaceOffset == ppdev->DoubleBuffer.MultiBufferOffsets[i])
                {
                    break;
                }
            }

            #if DBG
            // clear surface and remove it from list
            NV_ClearDoubleBuffer(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i]);
            #endif

            // move all ohter entries down to fill the hole
            for (/* i */; i<ppdev->DoubleBuffer.NumBuffers-1; i++) 
            {
                ppdev->DoubleBuffer.MultiBufferOffsets[i] = ppdev->DoubleBuffer.MultiBufferOffsets[i+1];
            }

            ppdev->DoubleBuffer.NumBuffers--;
        }

        ASSERT(ppdev->DoubleBuffer.NumBuffers >= 0);
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvinithw.c ===
//******************************************************************************
//
// Module Name:
//
//     NVINITHW.C
//
// Abstract:
//
//     Initialization of HW routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996-2000  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
//    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"
#include "oglDD.h"
#include "oglOverlay.h"
#include "oglutils.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"
extern BOOL InitMultiMon(PDEV *ppdev);
extern void InduceAndUpdateDeviceScanning (PPDEV ppdev);
extern VOID NV_WaitForOneVerticalRefresh(PDEV*);


VOID NV4_DmaPushSend(PDEV *);
VOID NV_DmaPush_Wrap(PDEV *, ULONG );
VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG);

BOOL NVInitDmaPushHardware(PDEV *);
VOID NVReleaseDmaPushHardware(PDEV *ppdev,BOOL InitDmaPushHardwareFailFlag);
void NvValidateCaps(PDEV* ppdev);
BOOL bClassSupported(PDEV *ppdev, NvU32 classID);

#ifdef NV3
BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);
#endif // NV3

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3224-OFFSET_NV_PFIFO_BASE)

#define NO_MAPPING                                  ((PVOID)1)

//******************************************************************************
//
//  Function:   bAssertModeHardware
//
//  Routine Description:
//
//      Sets the appropriate hardware state for graphics mode or full-screen.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)

    {
    BYTE*                   pjIoBase;
    BYTE*                   pjMmBase;
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    BYTE                    jExtendedMemoryControl;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMiscState;
    Nv3ChannelPio           *nv;
    ULONG                   i;
    PVOID                   frameBuffer;
    ULONG                   status;
    TV_CURSOR_ADJUST_INFO   CursorAdjustInfo;
    NV_DESKTOP_INFO         DeskTopInfo;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;
    BOOLEAN                 bVirtualDesktopEnabled;
    ULONG                   ulData;
    DWORD                   dwStatus;

    //**************************************************************************
    // bEnable == TRUE  --> Set the graphics mode
    // bEnable == FALSE --> Reset the adapter into a known state, NTVDM will take over
    //**************************************************************************
    if (bEnable)
        {

        //**********************************************************************
        // Call the miniport via an IOCTL to set the graphics mode.
        //
        // ppdev->ulMode is the REQUESTED mode which is initialized
        // in bInitializeModeFields
        //
        //**********************************************************************

        ppdev->lDelta = 0;

        // Initialize the multi-mon info.
        if(!InitMultiMon(ppdev))
            goto bAssertModeHardware_ReturnFalse;

        ppdev->ulDesktopMode |=  NV_ENABLE_CLASS_SET_MODE;
        DeskTopInfo.ulDesktopModeIndex = ppdev->ulMode;
        DeskTopInfo.ulDesktopMode = ppdev->ulDesktopMode;
        DeskTopInfo.ulTwinView_State = ppdev->TwinView_State;

        DeskTopInfo.ulDesktopWidth = ppdev->cxScreen;
        DeskTopInfo.ulDesktopHeight = ppdev->cyScreen;

        DeskTopInfo.ulNumberDacsOnBoard = ppdev->ulNumberDacsOnBoard;
        DeskTopInfo.ulNumberDacsConnected = ppdev->ulNumberDacsConnected;
        DeskTopInfo.ulNumberDacsActive = ppdev->ulNumberDacsActive;

        DeskTopInfo.ulConnectedDeviceMask = ppdev->ulConnectedDeviceMask;
        DeskTopInfo.ulAllDeviceMask = ppdev->ulAllDeviceMask;
        

        for(i = 0; i < NV_NO_DACS; i++)
        {
            DeskTopInfo.ulDisplayWidth[i] = ppdev->rclCurrentDisplay[i].right - ppdev->rclCurrentDisplay[i].left;
            DeskTopInfo.ulDisplayHeight[i] = ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top;
            DeskTopInfo.ulDisplayRefresh[i] = ppdev->ulRefreshRate[i];
            DeskTopInfo.ulDisplayPixelDepth[i] = ppdev->cBitsPerPel;
            DeskTopInfo.ulDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];
            DeskTopInfo.ulDeviceMask[i] = ppdev->ulDeviceMask[i];
            DeskTopInfo.ulDeviceType[i] = ppdev->ulDeviceType[i];
            DeskTopInfo.ulTVFormat[i] = ppdev->ulTVFormat[i];
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_DESKTOP_INFO_MODE,
                       &DeskTopInfo,  // input buffer
                       sizeof(NV_DESKTOP_INFO),
                       &bVirtualDesktopEnabled,
                       sizeof(BOOLEAN),
                       &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed IOCTL_VIDEO_SET_DESKTOP_INFO_MODE"));
        }
        else if (ReturnedDataLength == sizeof(BOOLEAN))
        {
            if(bVirtualDesktopEnabled)
            {
                DISPDBG((5, "bAssertModeHardware - Support DualView"));
            }
        }

        nvPitch.Width = ppdev->cxScreen;
        nvPitch.Height = ppdev->cyScreen;
        nvPitch.Depth = ppdev->cjPelSize * 8;

        if (NvConfigGetEx(ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS))) 
        {
            DISPDBG((0,"bAssertModeHardware - Cannot get pitch value from RM"));  // ERROR ???
            // IF RM cannot calculate the pitch, it will be in trouble to allocate the primary surface late on.
            goto bAssertModeHardware_ReturnFalse;
        }

        ppdev->lDelta = nvPitch.Pitch;

        // clean up the heap first.
        if(!ppdev->ulEnableDualView)
            NVHEAP_DESTROY();

        NVHEAP_ALLOC_TILED(dwStatus,ppdev->ulPrimarySurfaceOffset, (DWORD)nvPitch.Pitch, (DWORD)ppdev->cyScreen, MEM_TYPE_PRIMARY);
        //
        // Under Dualview, it is likely to fail allocation of frame buffer.
        // Suppose both viws are on.  And 2nd view holds big chunk of DDraw surface, which leave no room for the 1st view to getting bigger.
        // Under such a case, 1st can only shrink.  If it tries to expand, OS DrvChangeDisplaySetting will try again on a fall back res at 
        // 640x480.
        //
        if (dwStatus != 0)
        {
            DISPDBG((0, "bAssertModeHardware - Failed to allocate video memory for frame buffer.  Pitch=0x%08x, cyScreen=0x%08x", nvPitch.Pitch, ppdev->cyScreen));
            if (ppdev->ulEnableDualView)
                return FALSE;
            else
                goto bAssertModeHardware_ReturnFalse;
        }

        ppdev->pjScreen = ppdev->pjFrameBufbase + ppdev->ulPrimarySurfaceOffset;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_CURRENT_MODE,
                               &ppdev->ulMode,  // input buffer
                               sizeof(DWORD),
                               &ppdev->bHwVidOvl,
                               sizeof(BOOLEAN),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto bAssertModeHardware_ReturnFalse;
            }
        else if (ReturnedDataLength != sizeof(BOOLEAN))
            {
            //****************************************************************
            // Miniport didn't know if we can do hw video overlay. Assume we can!
            //****************************************************************
                ppdev->bHwVidOvl = TRUE;

            }

#ifndef NV3
        // Using VIDEO_OVERLAY class, the HW should be able to handle it
        ppdev->bHwVidOvl = TRUE;
#endif

#if _WIN32_WINNT < 0x0500
        if(ppdev->ulNumberDacsActive > 1)
            ppdev->bHwVidOvl = FALSE;
#endif
        //**********************************************************************
        // After we've set the mode, get the information and
        // put it in the VideoModeInfo structure
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_CURRENT_MODE,
                               NULL,
                               0,
                               &VideoModeInfo,
                               sizeof(VideoModeInfo),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto bAssertModeHardware_ReturnFalse;
            }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
        #endif


        //**********************************************************************
        // Also get the necessary cursor adjustments
        // (when we're running on a TV)
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO,
                               NULL,
                               0,
                               &CursorAdjustInfo,
                               sizeof(CursorAdjustInfo),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - failed VIDEO_QUERY_TV_CURSOR_ADJUST"));
            goto bAssertModeHardware_ReturnFalse;
            }

        //**********************************************************************
        // Store these values in the pdev structure for all to see
        //**********************************************************************

        ppdev->MonitorType  = CursorAdjustInfo.MonitorType;
        ppdev->Underscan_x  = CursorAdjustInfo.Underscan_x;
        ppdev->Underscan_y  = CursorAdjustInfo.Underscan_y;
        ppdev->Scale_x      = CursorAdjustInfo.Scale_x;
        ppdev->Scale_y      = CursorAdjustInfo.Scale_y;
        ppdev->FilterEnable = CursorAdjustInfo.FilterEnable;
        ppdev->TVCursorMin  = CursorAdjustInfo.TVCursorMin;
        ppdev->TVCursorMax  = CursorAdjustInfo.TVCursorMax;

        //**********************************************************************
        // The following variables are determined only after the initial modeset:
        //
        // NV1 / NV3 / NV4:
        //      flCaps is returned to the display driver and denotes whether
        //      NV1 / NV3 / NV4 was found by the miniport
        //
        //**********************************************************************

        ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;
        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
#ifndef RM_HEAPMGR
        ppdev->lDelta   = VideoModeInfo.ScreenStride;
#else
        //************************************************************
        // If we are using the RM heap manager, ask the RM for the
        // pitch. Fallback to using the pitch in the mode table if
        // the RM call fails. For NV3, the RM will return success,
        // but will always return a pitch value of 0, so we have
        // to check for this and fallback to the default pitch.
        //************************************************************
        if(!ppdev->lDelta)
        {
            if (NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFG_PRIMARY_SURFACE_PITCH, &ppdev->lDelta)) 
            {
                ppdev->lDelta = VideoModeInfo.ScreenStride;
            }
            if (!ppdev->lDelta)
                ppdev->lDelta = VideoModeInfo.ScreenStride;
            else
                VideoModeInfo.ScreenStride = ppdev->lDelta;
        }
#endif

        //**********************************************************************
        // Get the frame buffer length from the RM
        //**************************************************************************
        //frameBuffer = ppdev->pjScreen;
        frameBuffer = NO_MAPPING;

        ppdev->hFrameBuffer = DD_FRAME_BUFFER_OBJECT_HANDLE;
        status = NvAllocMemory(ppdev->hDriver,
                                     ppdev->hClient,
                                     ppdev->hDevice,
                                     ppdev->hFrameBuffer,
                                     NV01_MEMORY_LOCAL_USER,
                                     0,
                                     &frameBuffer,
                                     &ppdev->cbFrameBuf);

        if (status != NVOS02_STATUS_SUCCESS)
            {
            DISPDBG((1, "Failed bAssertModeHardware"));
            goto bAssertModeHardware_ReturnFalse;
            }

        ASSERTDD(status == NVOS02_STATUS_SUCCESS,
                     "bAssertModeHardware: Failed to allocate memory");

        //**********************************************************************
        // Save the frame buffer size in bytes rounded to the next lowest 4K boundary.
        // Compute the Frame Buffer size (in scanlines) based on the rounded size in
        // bytes.
        //**********************************************************************
        ppdev->cbFrameBuf += 1;
        ppdev->cyMemory = ppdev->cbFrameBuf / ppdev->lDelta;

        if (ppdev->cyMemory > MAX_CY_MEMORY_VALUE)
            ppdev->cyMemory = MAX_CY_MEMORY_VALUE;

        // Max. Clip value:((ppdev->cyMemory)<<16) | (0x7fff)
        ppdev->dwMaxClip = ((ppdev->cyMemory)<<16) | (0x7fff);

        DISPDBG((1, "NVDD: Get channel pointer from RM"));

        //**********************************************************************
        // NV3 uses the old style patchcord initialization
        // (and it must use the old style Resource Manager too)
        // NV4 no longer uses patchcord initialization
        // (and must use the new NV4 Resource Manager)
        //**********************************************************************
#ifdef NV3
        if (!bNV3CreateStdPatches(ppdev))
            goto bAssertModeHardware_ReturnFalse;
#else
        //******************************************************************
        // New NV4 architecture no longer uses patchcords
        //******************************************************************

        ppdev->DmaPushEnabled2D = TRUE;        // Always enabled for now
        ppdev->fontCacheEnabled = FALSE;       // Always disabled for now
                                               //   since not as fast
        //**************************************************************
        // Use DMA Pusher functionality for 2d
        //**************************************************************

        if (!NVInitDmaPushHardware(ppdev)) {
            goto bAssertModeHardware_ReturnFalse;
        }
#endif // NV3

        //**************************************************************
        // Validate capabilities based on classes we allocated.
        //**************************************************************
        NvValidateCaps(ppdev);
        
        //**************************************************************
        // Initialize heap size info.
        //**************************************************************
        NVHEAP_INFO();

        //**********************************************************************
        // Make sure that Clipping rectangle gets reset by the first hardware function
        // By default, the clipping rectangle should include ALL of video memory
        // (including offscreen). Whenever we change it, we need to set this flag.
        // So, by setting it here, the first function we get to will reset
        // the clipping rectangle.  Also, make sure that pattern gets reset.
        //**********************************************************************

        ppdev->NVClipResetFlag=1;
        ppdev->NVPatternResetFlag=1;

        //**********************************************************************
        // Make sure to reset pitches and offsets across modesets!
        //**********************************************************************

        ppdev->CurrentSourceOffset = 0;
        ppdev->CurrentSourcePitch  = 0;
        ppdev->CurrentDestOffset   = 0;
        ppdev->CurrentDestPitch    = 0;

        //**********************************************************************
        // Display the current mode for our convenience on the debugger
        //**********************************************************************

        DISPDBG((1, "cxMemory: %lx  cyMemory: %lx", ppdev->cxMemory, ppdev->cyMemory));
        DISPDBG((1, "cxScreen: %lx  cyScreen: %lx", ppdev->cxMemory, ppdev->cyMemory));
        DISPDBG((1, "ldelta: %lx ", ppdev->lDelta));

        //**********************************************************************
        // Set the CAPS_SW_POINTER to specify a software cursor if necessary,
        // and make the necessary modifications to pointer.c
        //
        // ppdev->flCaps |= CAPS_SW_POINTER;
        //
        //**********************************************************************

        //**********************************************************************
        // Turn off hardware cursor when running in 960x720 modes
        // (Because we're limited to 46k of PRAMIN instance memory,
        // and cursor caching takes up a lot of it)
        //**********************************************************************

        if ((ppdev->cxScreen == 960) && (ppdev->cyScreen == 720))
            ppdev->flCaps |= CAPS_SW_POINTER;


        //**********************************************************************
        // Do some parameter checking on the values that the miniport
        // returned to us:
        //**********************************************************************

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");

        OglEnableModeSwitchUpdate(ppdev);

        // Now induce the device scan by the miniport to rebuild the possible device options for each head.
        // InduceAndUpdateDeviceScanning(ppdev);

        NvHwSpecific(ppdev);

        ppdev->bEnabled = TRUE;

        }

    else

        {
        OglDisableModeSwitchUpdate(ppdev);


#ifdef NV3

        //******************************************************************
        // Normally, we would wait on the videocolormap buffer notifier
        // to make sure palette writes are done before deleting the patch/contexts.
        // (ie...palette writes occur during vblank, so we must not delete the
        // associated colormap context until the palette writes are completed)
        // However notifiers for the video colormap are not yet implemented.
        // So for now, we have to wait for at least one vertical refresh to occur ,
        // to make sure all the palette writes have completed.
        // Without this sync, the rm colormap notify routine in the vblank handler
        // could potentially crash.
        //******************************************************************

        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);

        vNV3DestroyStdPatches(ppdev, FALSE);

#else
        ASSERTDD(ppdev->DmaPushEnabled2D,"NV4 and up need DmaPushEnabled");
        //**************************************************************
        // Normally, we would wait on the videocolormap buffer notifier
        // to make sure palette writes are done before deleting the patch/contexts.
        // (ie...palette writes occur during vblank, so we must not delete the
        // associated colormap context until the palette writes are completed)
        // However notifiers for the video colormap are not yet implemented.
        // So for now, we have to wait for at least one vertical refresh to occur ,
        // to make sure all the palette writes have completed.
        // Without this sync, the rm colormap notify routine in the vblank handler
        // could potentially crash.
        //**************************************************************

        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);

        if (ppdev->iBitmapFormat != BMF_8BPP) 
        {
            if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SAVE_GAMMA_VALUES,
                           ppdev->ajClutData,  
                           sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256,
                           NULL,
                           0,
                           &ReturnedDataLength))
            {
                DISPDBG((1, "bAssertModeHardware - IOCTL_VIDEO_POSTMODE_SET failed"));
            }
        }

        //**********************************************************************
        // We've been asked to go full-screen DOS, but if we're not the VGA 
        // controller- which is possible in multimon- then another card will go 
        // into full-screen DOS. Painting black on our framebuffer avoids screen 
        // corruption. Its just cosmetic.
        //**********************************************************************
        EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_CLEAR_FRAMEBUFFER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn);

    
        NVReleaseDmaPushHardware(ppdev, TRUE);
        //**************************************************************
        // Release DMA Pusher functionality
        //**************************************************************

#endif // NV3

        NVHEAP_FREE(ppdev->ulPrimarySurfaceOffset);
        ppdev->ulDesktopMode = 0;

        //**********************************************************************
        // Invalidate cursor cache.
        //**********************************************************************
        for (i=0; i<NUM_CACHED_CURSORS; i++)
            ppdev->SavedCursorCheckSums[i] = 0;


        //**********************************************************************
        // For NV4, when using DMA Push, palette writes
        // (using video colormap) get queued up and don't
        // actually get written until the next vertical blank.
        // Normally, we would wait on the video colormap buffer notifier
        // to make sure the palette writes are done, before resetting
        // the device (calling int 10h).  However notifiers for the video
        // colormap are currrently not functional.  So for now, we'll
        // wait for at least one vertical refresh to occur , to make sure
        // all the palette writes have completed.
        //**********************************************************************

        if (ppdev->iBitmapFormat == BMF_8BPP) {
            NV_WaitForOneVerticalRefresh(ppdev);
        }

        //**********************************************************************
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
            {
            DISPDBG((1, "bAssertModeHardware - Failed reset IOCTL"));
            goto bAssertModeHardware_ReturnFalse;
            }
    }

    //**************************************************************************
    // AssertModeHardware call succeeded.
    //**************************************************************************

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

    //**************************************************************************
    // AssertModeHardware call failed.
    //**************************************************************************

bAssertModeHardware_ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   bEnableHardware
//
//  Routine Description:
//
//      Puts the hardware in the requested mode and initializes it.
//
//      Note: Should be called before any access is done to the hardware from
//            the display driver.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

BOOL bEnableHardware(
PDEV*   ppdev)

    {
    BYTE*                       pjIoBase;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[16];
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MEMORY                AliVidMem;
    VIDEO_MEMORY_INFORMATION    AliVidMemInfo;
    DWORD                       ReturnedDataLength;
    UCHAR*                      pj;
    USHORT*                     pw;
    ULONG*                      pd;
    ULONG                       i, j;
    ULONG                       ulOffset;
#ifdef PERFTEST
    ULONG* nvptr;
#endif

    //**************************************************************************
    // Create semaphore.  This is mainly used by the
    // ACQUIRE_CRTC_CRITICAL_SECTION macros for an asynchronous cursor.
    //**************************************************************************

    ppdev->csCrtc = EngCreateSemaphore();
    if (ppdev->csCrtc == 0)
        {
        DISPDBG((1, "bEnableHardware - Error creating CRTC semaphore"));
        goto bEnableHardware_ReturnFalse;
        }

    // OpenGL code: Allocate NV3 FIFO semaphore
    ppdev->csFifo = EngCreateSemaphore();
    if (ppdev->csFifo == 0)
        {
        DISPDBG((1, "bEnableHardware - Error creating FIFO semaphore"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // Get virtual addresses for the following memory ranges
    //
    // Currently, we'll be giving the display driver
    // public access to 5 ranges (in addition to the frame buffer)
    //
    //     1) NV User Channel 0  (64k)
    //     2) Graphics Status register (to check for Engine Busy)
    //     3) Vertical Blank (PFB_CONFIG_0 register)
    //     4) Frame Buffer Start Address (for page flipping)
    //     5) DAC cursor registers
    //
    // The Dumb Frame buffer ptr is mapped separately in VIDEO_MAP_VIDEO_MEMORY
    //
    // UPDATE: Looks like we'll be needing access to more and more privileged
    //         registers (at least until we get a full resource manager working)
    //         It's becoming a little ugly...but can't be helped right now..
    //         We're programming straight to NV registers, instead of using
    //         objects the way NV was meant to be programmed.
    //
    //     - PRMCIO Registers
    //     - PRMVIO Registers
    //     - PRAMDAC Registers
    //     - PRAMIN Registers
    //     - TEXTURE BUFFER AREA
    //     - PGRAPH Registers
    //     - DMA BUFFER AREA
    //
    //**************************************************************************

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                           NULL,                      // input buffer
                           0,
                           VideoAccessRange,         // output buffer
                           sizeof(VideoAccessRange),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Initialization error mapping IO port base"));
        goto bEnableHardware_ReturnFalse;
        }

    //  Initialize function ptrs and mmio here as soon as we got all necessary info.

    //**************************************************************************
    // Initialize the memory ranges. They're DIFFERENT depending
    // on which chip we're running on, because some ranges that exist
    // on one chip, may not exist on the other
    //**************************************************************************

    ppdev->NvBaseAddr = (volatile DWORD *) VideoAccessRange[0].VirtualAddress;
    ppdev->GrStatusReg = (volatile DWORD *) VideoAccessRange[1].VirtualAddress;
    ppdev->FbConfig0Reg = (volatile DWORD *) VideoAccessRange[2].VirtualAddress;
    ppdev->FbStartAddr = (volatile DWORD *) 0x0;
    ppdev->DACRegs = (volatile DWORD *) 0x0;
    ppdev->PRMCIORegs = (volatile UCHAR *) VideoAccessRange[5].VirtualAddress;
    ppdev->PRMVIORegs = (volatile UCHAR *) VideoAccessRange[6].VirtualAddress;
    ppdev->PRAMDACRegs = (volatile DWORD *) VideoAccessRange[7].VirtualAddress;

    ppdev->PGRAPHRegs = (volatile DWORD *) VideoAccessRange[10].VirtualAddress;
    ppdev->PFIFORegs = (volatile DWORD *) VideoAccessRange[11].VirtualAddress;

#ifdef NV3
    //**********************************************************************
    // Init DMA push length register to 0
    //**********************************************************************
    if (ppdev->PFIFORegs) {
        volatile ULONG *DmaPushLengthReg;
        
        DmaPushLengthReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
        *DmaPushLengthReg = 0;
    }
#endif // NV3

    //**********************************************************************
    // DMA buffer is NO LONGER allocated in the miniport.
    // It's now allocated in EnablePDEV, so do NOT initialize it here.
    // (VideoAccessRange[11] is ZERO)
    //**********************************************************************

    DISPDBG((1, "pjMmBase: 0x%p  ", ppdev->pjMmBase));
    DISPDBG((1, "GrStatusReg: 0x%p  ", ppdev->GrStatusReg));
    DISPDBG((1, "FbConfig0Reg: 0x%p  ", ppdev->FbConfig0Reg));
    DISPDBG((1, "FbStartAddr: 0x%p  ", ppdev->FbStartAddr));
    DISPDBG((1, "DACRegs: 0x%p  ", ppdev->DACRegs));
    DISPDBG((1, "PRMCIORegs: 0x%p  ", ppdev->PRMCIORegs));
    DISPDBG((1, "PRMVIORegs: 0x%p  ", ppdev->PRMVIORegs));
    DISPDBG((1, "PRAMDACRegs: 0x%p  ", ppdev->PRAMDACRegs));
    DISPDBG((1, "PRAMINRegs: 0x%p  ", ppdev->PRAMINRegs));
    DISPDBG((1, "PGRAPHRegs: 0x%p  ", ppdev->PGRAPHRegs));
    DISPDBG((1, "PFIFORegs: 0x%p  ", ppdev->PFIFORegs));


    //**************************************************************************
    // Now set the pointers to the hardware specific functions
    //**************************************************************************
#ifdef NV3
    ppdev->pfnSetDestBase           = NV3_SetDestBase;
    ppdev->pfnSetSourceBase         = NV3_SetSourceBase;

    ppdev->pfnFillSolid             = NV3FillSolid;
    ppdev->pfnFillPat               = NV3FillPatFast;
    ppdev->pfnXfer1bpp              = NV3Xfer1bpp;
    ppdev->pfnXfer4bpp              = NV3Xfer4bpp;
    ppdev->pfnXferNative            = NV3XferNative;
    ppdev->pfnCopyBlt               = NV3CopyBlt;

    ppdev->pfnXfer4to16bpp          = NULL;
    ppdev->pfnXfer8to16bpp          = NULL;
    ppdev->pfnXfer4to32bpp          = NULL;
    ppdev->pfnXfer8to32bpp          = NULL;
    ppdev->pfnIndexedImage          = NULL;   

    ppdev->pfnMemToScreenBlt        = NV3MemToScreenBlt;
    ppdev->pfnMemToScreenPatternBlt = NV3MemToScreenWithPatternBlt;
    ppdev->pfnTextOut               = NV3TextOut;
    ppdev->pfnSetPalette            = NV3SetPalette;

    ppdev->pfnScreenTo1BppMemBlt    = NULL;
    ppdev->pfnGetScreenBits         = NULL;
    ppdev->pfnScreenToMemBlt        = NULL;
    ppdev->pfnScreenToMem16to4bppBlt= NULL;  
    ppdev->pfnScreenToMem32to4bppBlt= NULL; 
    ppdev->pfnScreenToMem16to8bppBlt= NULL; 
    ppdev->pfnScreenToMem32to8bppBlt= NULL; 
    ppdev->pfnScreenToScreenWithPatBlt= NULL;


    ppdev->pfnWaitEngineBusy        = NV3_WaitWhileGraphicsEngineBusy;
    ppdev->pfnWaitForChannelSwitch  = NV3_WaitForChannelSwitch;
    ppdev->pfnDmaPushGo             = NV3_DmaPushGo;
    ppdev->pfnStrokePath            = NV1StrokePath;

    ppdev->pfnAcquireOglMutex       = NV3_AcquireOglMutex;
    ppdev->pfnReleaseOglMutex       = NV3_ReleaseOglMutex;

    ppdev->pfnLineTo                = NV1LineTo;
    ppdev->pfnStretchCopy           = NULL;
#else // NV3

    //**************************************************************
    // Use DMA pusher
    //**************************************************************

    ppdev->pfnSetDestBase           = NV4_DmaPushSetDestBase;  // Needed for newer 565 functions
    ppdev->pfnSetSourceBase         = NV4_DmaPushSetSourceBase;

    ppdev->pfnFillSolid             = NV4DmaPushFillSolid;
    ppdev->pfnFillPat               = NV4DmaPushFillPatFast;
    ppdev->pfnXfer1bpp              = NV4DmaPushXfer1bpp;
    ppdev->pfnXfer4bpp              = NV4DmaPushXfer4bpp;
    ppdev->pfnXferNative            = NV4DmaPushXferNative;
    ppdev->pfnCopyBlt               = NV4DmaPushCopyBlt;

    ppdev->pfnXfer4to16bpp          = NV4DmaPushXfer4to16bpp;
    ppdev->pfnXfer8to16bpp          = NV4DmaPushXfer8to16bpp;
    ppdev->pfnXfer4to32bpp          = NV4DmaPushXfer4to32bpp;
    ppdev->pfnXfer8to32bpp          = NV4DmaPushXfer8to32bpp;
    ppdev->pfnFastXfer8to32         = NV4DmaPushFastXfer8to32;
    ppdev->pfnFastXfer8to16         = NV4DmaPushFastXfer8to16;
    
    ppdev->pfnIndexedImage          = NV4DmaPushIndexedImage;

    ppdev->pfnMemToScreenBlt        = NV4DmaPushMemToScreenBlt;
    ppdev->pfnMemToScreenPatternBlt = NV4DmaPushMemToScreenWithPatternBlt;
    ppdev->pfnTextOut               = NV4DmaPushTextOut;
    ppdev->pfnSetPalette            = NV4DmaPushSetPalette;

    ppdev->pfnScreenTo1BppMemBlt    = NV4ScreenTo1bppMemBlt;
    ppdev->pfnGetScreenBits         = NV4DmaPushDMAGetScreenBits;
    ppdev->pfnScreenToMemBlt        = NV4ScreenToMemBlt;
    ppdev->pfnScreenToMem16to4bppBlt= NV4ScreenToMem16to4bppBlt;     
    ppdev->pfnScreenToMem32to4bppBlt= NV4ScreenToMem32to4bppBlt;     
    ppdev->pfnScreenToMem16to8bppBlt= NV4ScreenToMem16to8bppBlt;     
    ppdev->pfnScreenToMem32to8bppBlt= NV4ScreenToMem32to8bppBlt;     
    ppdev->pfnScreenToScreenWithPatBlt= NV4ScreenToScreenWithPatBlt; 

    ppdev->pfnWaitEngineBusy        = NV4_DmaPushWaitWhileGraphicsEngineBusy;
    ppdev->pfnWaitForChannelSwitch  = NV4_DmaPushWaitForChannelSwitch;
    ppdev->pfnDmaPushGo             = NULL;
    ppdev->pfnStrokePath            = NV4DmaPushStrokePath;
    ppdev->pfnLineTo                = NV4DmaPushLineTo;
    ppdev->pfnStretchCopy           = NV4DmaPushStretchCopy;

    ppdev->pfnAcquireOglMutex = NV4_AcquireOglMutex;
    ppdev->pfnReleaseOglMutex = NV4_ReleaseOglMutex;
#endif // NV3

    //**************************************************************************
    // Memory ranges For NV1 vs NV3 will be initialized AFTER
    // AssertModeHardware so we'll know which chip we're currently running on.
    // These values are stored in VideoAccessRange[] array.
    // So don't overwrite them until we extract them later in this function !
    //**************************************************************************


    //**************************************************************************
    // Allocate 64k for a 'Dummy' user channel so that we can profile
    // performance.  We'll use this instead of the NV user channel
    // when we don't want to send data to NV (i.e. so we can measure
    // performance of the software code by itself)
    //**************************************************************************
#ifdef PERFTEST
    ppdev->TestChannelFlag=0;
    ppdev->TestChannelPtr = EngAllocMem(FL_ZERO_MEMORY, 0x10000, ALLOC_TAG);
    if (ppdev->TestChannelPtr == NULL)
        {
        DISPDBG((1, "DrvEnablePDEV - Failed EngAllocMem"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // For each of the 8 subchannels, we set the 'FreeCount' register to 0xffff.
    // This effectively tells the software code that there's always plenty
    // of space in the FIFO (i.e...measure performance for hardware which
    // never has it's FIFO busy)
    //**************************************************************************

    nvptr = ppdev->TestChannelPtr;

    //**************************************************************************
    // Each sub-channel is 8k (nvptr is a pointer to ULONG values)
    // 'FreeCount' register exists 16 bytes after beginning of subchannel
    //**************************************************************************

    *(nvptr+(2048*0)+4) = 0xffffffff;
    *(nvptr+(2048*1)+4) = 0xffffffff;
    *(nvptr+(2048*2)+4) = 0xffffffff;
    *(nvptr+(2048*3)+4) = 0xffffffff;
    *(nvptr+(2048*4)+4) = 0xffffffff;
    *(nvptr+(2048*5)+4) = 0xffffffff;
    *(nvptr+(2048*6)+4) = 0xffffffff;
    *(nvptr+(2048*7)+4) = 0xffffffff;
#endif // ifdef PERFTEST

    //**************************************************************************
    // Get the linear memory address range for the FRAME buffer
    //**************************************************************************

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                           &VideoMemory,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &VideoMemoryInfo,  // output buffer
                           sizeof(VideoMemoryInfo),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Error mapping buffer address"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // Record the Frame Buffer Linear Address in our PDEV structure.
    //**************************************************************************

    ppdev->pjFrameBufbase  = (BYTE*) VideoMemoryInfo.FrameBufferBase;

    //**************************************************************************
    // If necessary , map an IO port to workaround an ALI chipset cache issue
    //**************************************************************************

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI,
                           &AliVidMem,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &AliVidMemInfo,  // output buffer
                           sizeof(AliVidMemInfo),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Error mapping IO port for ALI"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // We use the FrameBufferBase field  to return the IO base.
    // We use the FrameBufferlength field to signal if an ALI chipset is present of not.
    //**************************************************************************

    // No need to worry about ALI on IA64
#ifndef _WIN64
    ppdev->AliFixupIoBase   = (ULONG)(AliVidMemInfo.FrameBufferBase);
    ppdev->AliFixupIoNeeded = AliVidMemInfo.FrameBufferLength;
#else
    ppdev->AliFixupIoNeeded = FALSE;
#endif

    //**************************************************************************
    // Identifying
    // NV1 vs NV3:  We won't know what chip version of NV we're using until
    //              AFTER the first modeset occurs (in AssertModeHardware).
    //              That is, the miniport will store the CHIP ID information
    //              in the ppdev->flCaps field during QUERY_CURRENT_VIDEO_MODE
    //              (See DriverSpecificAttributeFlags)
    //**************************************************************************
    {
    union
    {
        ULONG osName;
        char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
    } nameBuffer;

    // set the device handle
    ppdev->hDevice = DD_DEVICE_OBJECT_HANDLE;

    // escape the device class to the device reference
    ppdev->hDevClass = NV03_DEVICE_XX;
    nameBuffer.osName = ppdev->ulDeviceReference;

    // register the client and allocate a device
    ppdev->hClient = 0;
    if (NvAllocRoot(ppdev->hDriver, NV01_ROOT, &ppdev->hClient) != NVOS01_STATUS_SUCCESS)
        {
        DISPDBG((2, "NVDD: Cannot register as client to resource manager"));
        goto bEnableHardware_ReturnFalse;
        }


    if (NvAllocDevice(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, ppdev->hDevClass, nameBuffer.devName) != NVOS06_STATUS_SUCCESS)
        {
        DISPDBG((2, "NVDD: Cannot allocate a device"));
        NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
        goto bEnableHardware_ReturnFalse;
        }
    }

    if (!AllocDmaPushBuf(ppdev))
        goto bEnableHardware_ReturnFalse;

    if (!AllocMemOncePerPdev(ppdev))
        goto bEnableHardware_ReturnFalse;

    // initialize the Gamma default values
    for(i = 0; i < NV_NO_DACS; i++)
    {
        ulOffset = i*256;
   
        for(j = 0 ; j < 256; j++)
        {
            ppdev->ajClutData[j + ulOffset].Red   = (UCHAR)j;   
            ppdev->ajClutData[j + ulOffset].Green = (UCHAR)j;
            ppdev->ajClutData[j + ulOffset].Blue  = (UCHAR)j; 
            ppdev->ajClutData[j + ulOffset].Unused = 0;
        }
    }

    //**************************************************************************
    // Now we can set the mode, and fill in the videomode information structure
    // as well as important PPDEV values
    //**************************************************************************

    if (!bAssertModeHardware(ppdev, TRUE))
        goto bEnableHardware_ReturnFalse;

#ifndef NV3
    //**********************************************************
    // Determine the NV Architecture revision.
    //**********************************************************
    NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFG_ARCHITECTURE, (ULONG *)(&(ppdev->dwDeviceVersion)));

    if (ppdev->dwDeviceVersion == NV_DEVICE_VERSION_4)
    {
        ULONG dwRevision;
        NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_REVISION, &dwRevision);
        if (dwRevision >= 1) ppdev->dwDeviceVersion = NV_DEVICE_VERSION_5;

       // The intermittent bug, 20001023-154559, hang the Graphic engine while performing INDEXED_IMAGE_FROM_CPU on NV5 only.
       // Disabling (NV4 and NV5 only) the Screen to memory blt would make HW happy for INDEXED_IMAGE_FROM_CPU.
       ppdev->pfnScreenToMemBlt        = NULL;
    }

#endif // !NV3

    
    //**************************************************************************
    // All done, return successful
    //**************************************************************************

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

    //**************************************************************************
    // Function failed
    //**************************************************************************

bEnableHardware_ReturnFalse:
    ASSERTDD(FALSE, "Failed bEnableHardware");

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   vDisableHardware
//
//  Routine Description:
//
//      Undoes anything done in bEnableHardware.
//      Note: In an error case, we may call this before bEnableHardware is
//            completely done.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

VOID vDisableHardware(
PDEV*   ppdev)

    {
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[15];

    FreeMemOncePerPdev(ppdev);
    FreeDmaPushBuf(ppdev);

    NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
    ppdev->hClient = 0;

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Unlock the OpenGL mutex and free it up.
    //
    //**************************************************************************
    DestroyOglGlobalMemory(ppdev);

    //**************************************************************************
    // Free up pointer to frame buffer memory
    //**************************************************************************

    if (ppdev->pjFrameBufbase)
    {
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjFrameBufbase;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                               VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
        ppdev->pjFrameBufbase = ppdev->pjScreen = NULL;
    }


    //**************************************************************************
    // Free up pointer to IO base for the ALI fixup
    //**************************************************************************

    if (ppdev->AliFixupIoBase)
    {
        VideoMemory[0].RequestedVirtualAddress = (PVOID)(ULONG_PTR)ppdev->AliFixupIoBase;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI,
                               VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI"));
        }

        ppdev->AliFixupIoBase   = 0;
        ppdev->AliFixupIoNeeded = FALSE;
    }

    //**************************************************************************
    // Free up the memory ranges. They're DIFFERENT depending
    // on which chip we're running on, because some ranges that exist
    // on one chip, may not exist on the other.
    //**************************************************************************

    //**************************************************************************
    // Free up pointer to NV device memory range
    //**************************************************************************

    if (ppdev->NvBaseAddr)
    {
        VideoMemory[0].RequestedVirtualAddress = (PVOID)(ppdev->NvBaseAddr);
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                               VideoMemory,
                               sizeof(VideoMemory),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
        }
        ppdev->NvBaseAddr = NULL;
    }

#ifdef PERFTEST
    if (ppdev->TestChannelPtr)
        EngFreeMem(ppdev->TestChannelPtr);
    ppdev->TestChannelPtr = NULL;
#endif  // ifdef PERFTEST
    if (ppdev->csCrtc)
        EngDeleteSemaphore(ppdev->csCrtc);
    if (ppdev->csFifo)
        EngDeleteSemaphore(ppdev->csFifo); // OpenGL code: free NV3 FIFO semaphore
    ppdev->csCrtc = ppdev->csFifo = NULL;
    }

//******************************************************************************
//
//  Function:   NvGetSupportedClasses
//
//  Routine Description:
//      Queries the resman for a list of supported classes on current hardware.
//      Fills in the ppdev->nvClassList and ppdev->nvNumClasses with this info
//
//  Arguments:
//      PDEV *
//
//  Return Value:
//
//      TRUE on success
//
//******************************************************************************

BOOL NvGetSupportedClasses(PDEV *ppdev) {
    
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS nvClassListParams;
    
    //**************************************************************************
    // Query the Resman for a list of supported classes
    //
    // First call RM to get the number of supported classes
    // Then call RM again to get fill a preallocated buffer with the class list
    //**************************************************************************
    ppdev->nvNumClasses = 0;
    
    if (ppdev->nvClassList != NULL) {
        EngFreeMem(ppdev->nvClassList);
        ppdev->nvClassList = NULL;
    }
    
    nvClassListParams.numClasses = 0;
    nvClassListParams.classBuffer = NULL;

    if (NVOS_CGE_STATUS_SUCCESS != 
        NvConfigGetEx (ppdev->hDriver,
                       ppdev->hClient,
                       ppdev->hDevice,
                       NV_CFGEX_GET_SUPPORTED_CLASSES, 
                       &(nvClassListParams),
                       sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS)
                       )) {
        ASSERTDD(0,"Failed to get list of supported classes");
        return (FALSE);
    }
    ASSERTDD(nvClassListParams.numClasses > 0,"RM reported 0 supported classes");
    
    nvClassListParams.classBuffer = 
        EngAllocMem(0, nvClassListParams.numClasses * sizeof(NvU32), ALLOC_TAG);

    if (NULL == nvClassListParams.classBuffer) {
        return (FALSE);
    }
    
    if (NVOS_CGE_STATUS_SUCCESS != 
        NvConfigGetEx (ppdev->hDriver,
                       ppdev->hClient,
                       ppdev->hDevice,
                       NV_CFGEX_GET_SUPPORTED_CLASSES, 
                       &(nvClassListParams),
                       sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS)
                       )) {
        ASSERTDD(0,"Failed to get list of supported classes");
        return (FALSE);
    }

    ppdev->nvClassList  = nvClassListParams.classBuffer;
    ppdev->nvNumClasses = nvClassListParams.numClasses;

    return TRUE;
}

//******************************************************************************
//
//  Function:   NvAllocDmaMemory
//
//  Routine Description:
//      Machine independent wrapper to allocate memory that will be accessed
//      by the adapter.  On 64 bit systems, the RM allocates the memory to
//      ensure that the memory will be addressible by the adapter.  On systems
//      that do not support physical addresses > 32 bits, a EngAllocMem()
//      works fine.
//
//  Return Value:
//
//       NVOS02_STATUS_SUCCESS on success
//
//******************************************************************************

ULONG NvAllocDmaMemory(PDEV *ppdev, PVOID *pAddress, ULONG hMemory, ULONG numBytes)
{
#if defined(_WIN64)
    ULONG limit = ROUND_TO_PAGES(numBytes) - 1;
    ULONG status;

    *pAddress = NULL;
    return (NvAllocMemory(ppdev->hDriver,
                         ppdev->hClient,
                         ppdev->hDevice,
                         hMemory,
                         NV01_MEMORY_SYSTEM,
                         DRF_DEF(OS02, _FLAGS, _LOCATION, _PCI) |
                         DRF_DEF(OS02, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS),
                         pAddress,
                         &limit));
#else
    *pAddress = EngAllocMem(FL_ZERO_MEMORY, numBytes, ALLOC_TAG);
    if (*pAddress == NULL) {
        return NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
    } else {
        return NVOS02_STATUS_SUCCESS;
    }
#endif
}

//******************************************************************************
//
//  Function:   NvFreeDmaMemory
//
//  Routine Description:
//      Machine independent wrapper to free memory allocated with the
//      routine above.
//
//  Return Value:
//
//       NVOS00_STATUS_SUCCESS on success
//
//******************************************************************************
ULONG NvFreeDmaMemory(PDEV *ppdev, ULONG hMemory, PVOID pAddress)
{
#if defined(_WIN64)
    return (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, hMemory));
#else
    EngFreeMem(pAddress);
    return NVOS00_STATUS_SUCCESS;
#endif
}

//******************************************************************************
//
//  Function: NVInitDmaPushHardware
//
//  Routine Description:
//      Initializes DMA Push objects for NV4 and greater.
//
//  Arguments:
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

BOOL NVInitDmaPushHardware(
PDEV *ppdev)
    {
    Nv04ControlDma* nvDmaChannel;
    ULONG           i;
    ULONG           ReturnedDataLength;
    ULONG           status;

    DISPDBG((1, "NV_DISP:  Setting up NV4 and greater hardware for DMA Pusher..."));

    ppdev->bNVInitDmaCompleted = FALSE;

    if(!NvSetupContextDma(ppdev))
        goto NVInitDmaPushHardware_ReturnFalse;

    //**************************************************************************
    // Init local DMA push variables
    //**************************************************************************

    ppdev->nvDmaCount       = 0;
    ppdev->nvDmaCachedGet   = 0;
    ppdev->nvDmaCachedPut   = 0;
    ppdev->nvDmaPreviousPut = 0;
    ppdev->nvDmaWrapFlag    = FALSE;
    ppdev->nvDmaCachedFreeCount = (ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING;
    ppdev->DmaPushBufCanUseSize = ppdev->nvDmaCachedFreeCount;

    //**************************************************************************
    // Allocate the DMA push channel
    //
    // DMA channel alloc parameters (NVOS07_PARAMETERS):
    //  IN  HANDLE hDriver  Driver Handle
    //  IN  V032 hObject;   unique, user defined handle
    //  IN  V032 hDevice;   currently unused -- use 0
    //  IN  V032 hClass;    currently unused -- use 0
    //  IN  V032 hError;    handle used to allocate the error notifier DMA context
    //  IN  V032 hBuffer;   handle used to allocate the data buffer DMA context
    //  IN  U032 offset;    initial offset into the buffer
    //  OUT P064 pChannel;  ptr to DMA push channel
    //
    //**************************************************************************

    ppdev->hDmaChannel = 0x11111111;  // Unique Handle

    //**************************************************************************
    // After this call, nvDmaChannel will contain the pointer to the DMA push channel
    //**************************************************************************

    ppdev->hDmaChannel = DD_DMA_CHANNEL_OBJECT_HANDLE;
    
    //**************************************************************************
    // Create Pushbuffer Channel DMA
    //**************************************************************************
    {
        NvU32 classes[] = {NV10_CHANNEL_DMA,NV04_CHANNEL_DMA, 0};
        ULONG fail = TRUE;

        for (i=0; classes[i] != 0; i++) {
            if (bClassSupported(ppdev,classes[i])) {
                if (NvAllocChannelDma(ppdev->hDriver,
                                      ppdev->hClient,
                                      ppdev->hDevice,
                                      ppdev->hDmaChannel,
                                      classes[i],
                                      NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER,
                                      NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF,
                                      0,
                                      (PVOID)&nvDmaChannel) == NVOS07_STATUS_SUCCESS) {
                    fail = FALSE;
                    break;
                }
            }
        }
        if (fail) {
            DISPDBG((0, "NVDD: Cannot allocate DMA push channel"));
            goto NVInitDmaPushHardware_ReturnFalse;
        } else {
            ppdev->CurrentClass.ChannelDMA = classes[i];
        }
    }

    ppdev->nvDmaChannel = (ULONG *)nvDmaChannel;
    
    if(!NvSetupHwObjects(ppdev))
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot setup HW Objects"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }


    //**************************************************************************
    // Create VIDEO_LUT_CURSOR_DAC object and setup DAC
    //**************************************************************************
    
    if (!NvInitialDac(ppdev)) 
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot initialize DAC"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }

    if (!NvInitHwObjects(ppdev)) 
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot initialize HW Objects"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }

    ppdev->bNVInitDmaCompleted = TRUE;

    return TRUE;



NVInitDmaPushHardware_ReturnFalse:

    //**************************************************************************
    // Remove ALL DMA contexts that we previously allocated!
    //**************************************************************************

    NVReleaseDmaPushHardware(ppdev,TRUE);
    return(FALSE);

} // end of NVInitDmaPushHardware()



//******************************************************************************
//
//  Function: NVReleaseDmaPushHardware
//
//  Routine Description:
//
//  Arguments:
//      A pointer to the physical device
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

VOID NVReleaseDmaPushHardware(
    PDEV *ppdev,
    BOOL InitDmaPushHardwareFailedFlag
)
{
    if(ppdev->bNVInitDmaCompleted)
        ppdev->pfnWaitEngineBusy(ppdev);

    //**************************************************************************
    // Ensure hw has completed processing prior to destroying objects.
    //
    // MAKE SURE that the RM is done updating the palette registers
    // before we start freeing the contexts associated with the colormap object
    // (Make sure the 2nd notifier array entry (index 1) is zero)
    //**************************************************************************

    //**************************************************************************
    // If we're releasing DMA contexts because InitDmaPushHardware failed,
    // then the pfnWaitEngineBusy ptr may *NOT* have been initialized.
    // So in this case, don't do a WaitForEnginebusy.
    //**************************************************************************

    if (InitDmaPushHardwareFailedFlag == FALSE)
        if(ppdev->bNVInitDmaCompleted)
            ppdev->pfnWaitEngineBusy(ppdev);

    NvFreeContextDma(ppdev);

    //**************************************************************************
    // Free up the DMA push channel
    //**************************************************************************
    if (ppdev->nvDmaChannel !=NULL)
        {

        NvFree(ppdev->hDriver,
               ppdev->hClient,
               ppdev->hDevice,
               ppdev->hDmaChannel);
        ppdev->nvDmaChannel = NULL;
        }

    return;
}

//******************************************************************************
//
//  Function: AllocDmaPushBuf(PDEV *)
//
//  Routine Description: Attempts to allocate push buf from AGP memory, if
//  there is no AGP memory it falls back to allocating the push buf from
//  system memory.
//  Allocate the DMA push BUFFER (at the very minimum, it should be 8k or larger)
//  Then allocate the DMA Context for the DMA push buffer
//
//  PushBufTotalSize should at the very minimum be large enough to hold
//  the largest possible scanline (width = 2k at 32bpp = 2048*4 = 8k)
//
//  Arguments:
//
//  Return Value:
//            TRUE or FALSE
//
//
//******************************************************************************
BOOL AllocDmaPushBuf(PDEV *ppdev)
{

ULONG   cbPushBuf = ppdev->DmaPushBufTotalSize - 1;
int i;

#if (defined(GDI_AGP_PUSHBUF) && (_WIN32_WINNT >= 0x0500) && (defined(NV4)))

// Attempt to alloc AGP mem to determine if AGP is enabled. Currently we don't
// use AGP mem for the GDI pushbuf. To enable the AGP GDI pushbuf,
// #define GDI_AGP_PUSHBUF.

    if (NvAllocMemory(ppdev->hDriver,
                        ppdev->hClient,
                        ppdev->hDevice,
                        NV_AGP_PUSHBUF_OBJECT_HANDLE,
                        NV01_MEMORY_SYSTEM,
                        (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) | DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
                        (PVOID *)&(ppdev->AgpHeapBase),
                        &cbPushBuf))
    {
        ppdev->bAgp = FALSE;
        ppdev->AgpHeapBase = NULL;
        // AGP allocation failed;  will allocate it as NON-AGP device
    }
    else
    {
        ppdev->bAgp = TRUE;
        ppdev->nvDmaFifo = ppdev->AgpPushBuffer = ppdev->AgpHeapBase;

        goto DoneDmaPushAllocation;
    }
#endif

    //**********************************************************************
    // This is not an AGP device.
    //**********************************************************************
    ppdev->DmaPushBufMinSize   = 0x0;                 // Unused
    for(i = 0; i < 4; i++)
    {
        ppdev->DmaPushBufTotalSize = (DMAPUSH_BUFFER_SIZE >> i);
        if (NvAllocDmaMemory(ppdev,
                         &ppdev->nvDmaFifo,
                         NV_SYS_PUSHBUF_OBJECT_HANDLE,
                         ppdev->DmaPushBufTotalSize) != NVOS02_STATUS_SUCCESS)
        {
            DISPDBG((0, "AllocDmaPushBuf: Failed to allocate a %d byte DMA Push buffer", ppdev->DmaPushBufTotalSize));
        }
        else
        {
            goto DoneDmaPushAllocation;
        }
    }

    DISPDBG((0, "AllocDmaPushBuf: Failed to allocate DMA Push buffer"));
    ppdev->nvDmaFifo = NULL;
    return(FALSE);

DoneDmaPushAllocation:

    //**************************************************************************
    // Get location of a DWORD near the very end of the DMA Push buffer.
    // This is needed to workaround a VIA chipset problem.
    // The goal is to flush the chipset's locality/cache.
    // (This is part of the 'Flush Write-Combine Fix')
    // Back off 16 bytes from the end just to be safe.
    //**************************************************************************

    ppdev->nvDmaFlushFixDwordPtr = (ULONG *) ((BYTE *)(ppdev->nvDmaFifo) + ppdev->DmaPushBufTotalSize - 16);
    return(TRUE);


}

//******************************************************************************
//
//  Function: FreeDmaPushBuf(PDEV *)
//
//  Routine Description: 
//
//  Arguments:
//
//  Return Value:
//            None
//
//******************************************************************************
VOID FreeDmaPushBuf(PDEV * ppdev)
{
    if (ppdev->nvDmaFifo != NULL)
    {
// Free DMA push buffer.

#if (_WIN32_WINNT >= 0x0500) && (defined(NV4))
        if (ppdev->AgpPushBuffer)
            {
            ULONG   ReturnedDataLength;
            NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_AGP_PUSHBUF_OBJECT_HANDLE);
            ppdev->AgpPushBuffer = NULL;
            }
        else
#endif  // #if _WIN32_WINNT >= 0x0500
        if (NvFreeDmaMemory(ppdev, NV_SYS_PUSHBUF_OBJECT_HANDLE, ppdev->nvDmaFifo) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "NVDD: Cannot free DMA push buffer"));
        }
        ppdev->nvDmaFifo = NULL;
     }


}

//******************************************************************************
//
//  Function: AllocMemOncePerPdev(PDEV *)
//
//  Routine Description: Allocating necessary memory once for members in a PDEV
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
BOOL AllocMemOncePerPdev(PDEV * ppdev)
{
    //**************************************************************************
    // Allocate the indexed image LUT buffer and context (system memory)
    //**************************************************************************

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->NvDmaIndexedImageLut,
                         NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE,
                         INDEXED_IMAGE_LUT_BUFFER_SIZE) != NVOS02_STATUS_SUCCESS)

    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate indexed image LUT buffer"));
        return(FALSE);
    }

    //**************************************************************************
    // Create our generic temporary buffer, which may be used by any
    // component. (mainly used by memory to memory format object)
    //
    // NOTE: Add 4K to buffer since there appears to be some hardware problem
    // with the Mem to Mem class that requires some additional space
    //**************************************************************************

    ppdev->MemToMemBufferSize = MEM_TO_MEM_BUFFER_SIZE;

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->pMemToMemBuffer,
                         NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE,
                         MEM_TO_MEM_BUFFER_SIZE + (4*1024)) != NVOS02_STATUS_SUCCESS)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate pMemToMemBuffer"));
        return(FALSE);
    }

    //**************************************************************************
    // Allocate our local copy of palette data
    //**************************************************************************

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->ajClutData,
                         NV_CLUT_DATA_OBJECT_HANDLE,
                         sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256) != NVOS02_STATUS_SUCCESS)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate ajClutData"));
        return(FALSE);
    }

    if (!NvGetSupportedClasses(ppdev)) 
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot Get Support Nv Classes"));
        return FALSE;
    }

    //*************************************************************************
    // Allocate memory used for notifiers
    //*************************************************************************

    if (NvAllocDmaMemory(  ppdev,
                           &ppdev->Notifiers,
                           NV_NOTIFIERS_OBJECT_HANDLE,
                           sizeof(NV_NOTIFIERS)))
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate notifier memory"));
        return(FALSE);
    }

#if defined(_WIN64)
    //*************************************************************************
    // Allocate memory used to save floating point state prior to OpenGL escape
    //*************************************************************************

    ppdev->fpStateSize = EngSaveFloatingPointState(NULL, 0);
    ppdev->fpState = EngAllocMem(0, ppdev->fpStateSize, ALLOC_TAG);
    if (ppdev->fpState == NULL)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate memory for floating point state"));
        return(FALSE);
    }
#endif
    
    return(TRUE);


}


//******************************************************************************
//
//  Function: FreeMemOncePerPdev(PDEV *)
//
//  Routine Description: free memory for members in a PDEV
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
VOID FreeMemOncePerPdev(PDEV * ppdev)
{
    //**************************************************************************
    // De-allocate memory for Indexed Image LUT buffer
    //**************************************************************************

    if (ppdev->NvDmaIndexedImageLut != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE, ppdev->NvDmaIndexedImageLut) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free indexed image LUT buffer"));
        }
        ppdev->NvDmaIndexedImageLut = NULL;
    }

    //**************************************************************************
    // Free our generic temporary buffer, which may be used by any
    // component. (mainly used by memory to memory format object)
    //**************************************************************************

    if (ppdev->pMemToMemBuffer != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE, ppdev->pMemToMemBuffer) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free pMemToMemBuffer"));
        }
        ppdev->pMemToMemBuffer = NULL;
    }

    //**************************************************************************
    // Free our local copy of palette data
    //**************************************************************************

    if(ppdev->ajClutData != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_CLUT_DATA_OBJECT_HANDLE, ppdev->ajClutData) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free ajClutData"));
        }
        ppdev->ajClutData = NULL;
    }

    //*************************************************************************
    // Free notifier memory
    //*************************************************************************

    if(ppdev->Notifiers != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_NOTIFIERS_OBJECT_HANDLE, ppdev->Notifiers) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free notifier memory"));
        }
        ppdev->Notifiers = NULL;
    }

    //**************************************************************************
    // Free nvidia class list structure
    //**************************************************************************
    if(ppdev->nvClassList)
    {
        EngFreeMem(ppdev->nvClassList);
        ppdev->nvClassList = NULL;
    }

#if defined(_WIN64)
    //*************************************************************************
    // Free memory used to save floating point state
    //*************************************************************************

    if (ppdev->fpState != NULL)
    {
        EngFreeMem(ppdev->fpState);
        ppdev->fpState = NULL;
    }
#endif

}

//******************************************************************************
//
//  Function: NvValidateCaps
//
//  Routine Description: Validates all capabilities based on what classes were
//                       created in NVInitHardwareDmaPush()
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

void NvValidateCaps(PDEV* ppdev) 
{
        // Query the graphics caps from the RM
    if (NvConfigGet(ppdev->hDriver,
                    ppdev->hClient,
                    ppdev->hDevice,
                    NV_CFG_GRAPHICS_CAPS,
                    &ppdev->hwGfxCaps)
        == NVOS13_STATUS_SUCCESS) {
        // Coolio!
    } else {
        ppdev->hwGfxCaps = 0;
    }
    
#ifdef NV3
    ppdev->ulSurfaceAlign = NV3_BYTE_ALIGNMENT_PAD;
    ppdev->ulSurfaceBitAlign = NV3_BIT_ALIGNMENT;
    ppdev->cxSurfaceMax = (8192 - NV3_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
#else
    
    OglReadRegistry(ppdev);

    //******************************************************************
    // Set surface alignment
    //*************************************************************
    
    if (ppdev->CurrentClass.ContextSurfaces2D == NV10_CONTEXT_SURFACES_2D) {
        ppdev->ulSurfaceAlign = NV10_BYTE_ALIGNMENT_PAD;
        ppdev->ulSurfaceBitAlign = NV10_BIT_ALIGNMENT;
        ppdev->cxSurfaceMax = (65536 - NV10_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
    } else if (ppdev->CurrentClass.ContextSurfaces2D == NV04_CONTEXT_SURFACES_2D) {
        ppdev->ulSurfaceAlign = NV4_BYTE_ALIGNMENT_PAD;
        ppdev->ulSurfaceBitAlign = NV4_BIT_ALIGNMENT;
        ppdev->cxSurfaceMax = (8192 - NV4_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
    } else {
        ASSERTDD(0,"NvValidateCaps: Unsupported CONTEXT_SURFACES_2D");
    }
    
    //**************************************************************************
    // A little bit of validation based on what type of VIDEO_LUT_CURSOR_DAC
    // object we allocated.
    //**************************************************************************
    if (ppdev->CurrentClass.VideoLutCursorDac == NV10_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC) {
        ppdev->ulMaxHwCursorDepth = 32;
        ppdev->ulMaxHwCursorSize = 64;
        if (ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC) {
            ppdev->bSupportAlphaCursor = TRUE;
        } else {
            ppdev->bSupportAlphaCursor = FALSE;
        }
    } else {
        ppdev->ulMaxHwCursorDepth = 16;
        ppdev->ulMaxHwCursorSize = 32;
    }
    {
        int i;
        NvU32 classes11[] = { NV11_CELSIUS_PRIMITIVE };
        NvU32 classes20[] = { NV20_KELVIN_PRIMITIVE };
        
        ppdev->oglColor32Depth16 = FALSE;
        ppdev->oglColor16Depth32 = FALSE;
        ppdev->oglMultisample = FALSE;
        for (i=0; i < (sizeof(classes11)/sizeof(NvU32)); i++) {
            if (bClassSupported(ppdev,classes11[i])) {
                ppdev->oglColor32Depth16 = TRUE;
            }
        }
        for (i=0; i < (sizeof(classes20)/sizeof(NvU32)); i++) {
            if (bClassSupported(ppdev,classes20[i])) {
                ppdev->oglColor32Depth16 = TRUE;
                ppdev->oglColor16Depth32 = TRUE;
                ppdev->oglMultisample = TRUE;
            }
        }
    }
#endif    
}

//******************************************************************************
//
//  Function: NvSetupContextDma(PDEV *)
//
//  Routine Description: Allocating Context Dma
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
#define SETUP_CTX_DMA(ppdev, ID, pAddr, size)                                                       \
{                                                                                                   \
    if (NvAllocContextDma(ppdev->hDriver,                                                           \
                          ppdev->hClient,                                                           \
                          ID,                                                                       \
                          NV01_CONTEXT_DMA,                                                         \
                          NVOS03_FLAGS_ACCESS_READ_WRITE,                                           \
                          (PVOID)(pAddr),                                                           \
                          size                                                                      \
                          ))                                                                        \
    {                                                                                               \
        DISPDBG((0, "NvSetupContextDma: Cannot allocate context dma for handle ID %08xh", ID));     \
        return(FALSE);                                                                              \
    }                                                                                               \
}                                                                                                   

BOOL NvSetupContextDma(PDEV * ppdev)
{
    ULONG i;

    SETUP_CTX_DMA(ppdev,DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,              ppdev->pjFrameBufbase,             ppdev->cbFrameBuf);
    SETUP_CTX_DMA(ppdev,NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY, ppdev->Notifiers->Primary2d,       sizeof(NvNotification)*5 - 1);
    SETUP_CTX_DMA(ppdev,NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,   ppdev->Notifiers->DmaToMem,        sizeof(NvNotification)*2 - 1);
    SETUP_CTX_DMA(ppdev,NV_WIN_INDEXED_IMAGE_CONTEXT,                    ppdev->NvDmaIndexedImageLut,       INDEXED_IMAGE_LUT_BUFFER_SIZE - 1);
    SETUP_CTX_DMA(ppdev,DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER,        ppdev->Notifiers->MemToMem,        sizeof(NvNotification)*2 - 1);
    SETUP_CTX_DMA(ppdev,DD_TEMP_BUFFER_CONTEXT_DMA,                      ppdev->pMemToMemBuffer,            ppdev->MemToMemBufferSize+4*1024-1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF,              ppdev->nvDmaFifo,                  ppdev->DmaPushBufTotalSize - 1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER,           ppdev->Notifiers->DmaPushBufErr,   sizeof(NvNotification) - 1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER,    ppdev->Notifiers->VideoLutCursorDac,sizeof(NvNotification)*9-1);

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        SETUP_CTX_DMA(ppdev,NV_WIN_COLORMAP_CONTEXT + ppdev->ulDeviceDisplay[i],
                            &ppdev->ajClutData[ppdev->ulDeviceDisplay[i]*256],
                            (256 * sizeof(VIDEO_CLUTDATA)) - 1);
    }

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        SETUP_CTX_DMA(ppdev, NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY+i,
                             &(ppdev->Notifiers->DmaToMemIndexedImage[i*sizeof(NvNotification)]),
                             sizeof(NvNotification) - 1);
    }

    return(TRUE);
}

//******************************************************************************
//
//  Function: NvFreeContextDma(PDEV *)
//
//  Routine Description: Free Allocated Context Dma
//
//  Arguments:
//
//  Return Value:
//      None
//
//******************************************************************************
#define FREE_CTX_DMA(ppdev, ID)                                                                 \
{                                                                                               \
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, ID) != NVOS00_STATUS_SUCCESS)    \
    {                                                                                           \
        DISPDBG((1, "NvFreeContextDma: Cannot free DMA context of handle %d", ID));             \
    }                                                                                           \
}

VOID NvFreeContextDma(PDEV * ppdev)
{
    ULONG i;

    FREE_CTX_DMA(ppdev, DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    FREE_CTX_DMA(ppdev, NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    FREE_CTX_DMA(ppdev, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    FREE_CTX_DMA(ppdev, NV_WIN_INDEXED_IMAGE_CONTEXT);                   
    FREE_CTX_DMA(ppdev, DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER);
    FREE_CTX_DMA(ppdev, DD_TEMP_BUFFER_CONTEXT_DMA);                     
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF);             
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER);          
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        FREE_CTX_DMA(ppdev,NV_WIN_COLORMAP_CONTEXT + ppdev->ulDeviceDisplay[i]);
    }

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        FREE_CTX_DMA(ppdev, NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY+i);
    }
}


//******************************************************************************
//
//  Function: NvInitHwObject(PDEV *)
//
//  Routine Description: Initializing hw Objects
//
//  Arguments:
//
//  Return Value:
//      None
//
//******************************************************************************
BOOL NvInitHwObjects(PDEV * ppdev)
{
    ULONG i;
    ULONG color0, color1;
    ULONG videoFmt;

    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Determine black and white colors
    //**************************************************************************

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            videoFmt =  NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            ppdev->AlphaEnableValue = NV_ALPHA_1_32;
            break;
        case BMF_16BPP:

            if (ppdev->flGreen == 0x03e0)
                {
                //**************************************************************
                // 5:5:5 format
                //**************************************************************

                color0 =    NV_ALPHA_1_16 | 0x00000000;     // BLACK
                color1 =    NV_ALPHA_1_16 | 0x00007fff;     // WHITE
                videoFmt =  NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
                ppdev->AlphaEnableValue = NV_ALPHA_1_16;        // 5:5:5 format
                }
            else
                {
                //**************************************************************
                // 5:6:5 format
                //**************************************************************

                color0 =   (NV_ALPHA_1_565 | 0x00000000);       // BLACK
                color1 =   (NV_ALPHA_1_565 | 0x0000ffff);       // WHITE
                videoFmt = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
                ppdev->AlphaEnableValue = NV_ALPHA_1_565;       // 5:6:5 format
                }

            break;
        case BMF_8BPP:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            videoFmt =  NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            ppdev->AlphaEnableValue = NV_ALPHA_1_08;
            break;

        default:
            return(FALSE);
    }

    //**************************************************************************
    // Setup ROP5 SOLID
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(10)));

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NVFFF_SET_OBJECT(0),               DD_ROP5_SOLID);

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5,                 0xcccc);

    //**************************************************************************
    // Setup IMAGE BLACK RECTANGLE
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_IMAGE_BLACK_RECTANGLE);

    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_POINT,                     0);
    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_SIZE,                      ((0x7fff<<16) | 0x7fff));

    //*************************************************************************
    // Create the memory to memory format object.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),           MY_MEMORY_TO_MEMORY);

    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_NOTIFIES,     DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER );
    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_BUFFER_IN,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_BUFFER_OUT,   DD_TEMP_BUFFER_CONTEXT_DMA);

    ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;

    //**********************************************************************
    // Setup DST surface for device bitmaps
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_PRIMARY_IMAGE_IN_MEMORY);

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_SOURCE,  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_DESTIN,  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_Y8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_PITCH,                 ( ((ppdev->lDelta) << 16) |  (ppdev->lDelta)) ) ;
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_OFFSET_SOURCE,         ppdev->ulPrimarySurfaceOffset);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_OFFSET_DESTIN,         ppdev->ulPrimarySurfaceOffset);

    //**********************************************************************
    // Setup CONTEXT PATTERN
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(24)));
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NVFFF_SET_OBJECT(0),       DD_IMAGE_PATTERN);

    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
            break;
        case BMF_8BPP:
            // Must be set to a legal value but hardware ignores it otherwise
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT,        NV044_SET_MONOCHROME_FORMAT_CGA6_M1);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_SHAPE,         NV044_SET_MONOCHROME_SHAPE_64X_1Y);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_SELECT,           NV044_SET_PATTERN_SELECT_MONOCHROME);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_COLOR0,        color0);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_COLOR1,        color1);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_PATTERN0,      0xffffffff);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_PATTERN1,      0x50505050);

    //**********************************************************************
    // Y8 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(17)));
    NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));
    for (i=0;i<16;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // R5G6B5 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(33)));
    NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
    for (i=0;i<32;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // X1R5G5B5 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(33)));
    NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X1R5G5B5(0));
    for (i=0;i<32;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // X8R8G8B8 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(65)));
    NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));
    for (i=0;i<64;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // Setup CONTEXT COLOR KEY
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),                DD_IMAGE_SOLID);

    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_CONTEXT_DMA_NOTIFIES,  NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0);  // Disabled

    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    //******************************************************************
    // Setup multiple Indexed Image From CPU objects (565 format)
    //
    // Each object has an associated LUT context DMA and a notifier.
    // This is necessary since a LUT can't be updated until the operation
    // is completed. To improve performance, many objects were created so
    // that we didn't have to wait for the previous indexed image operation
    // to be completed.
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //******************************************************************                                                 
    for(i=0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        NV_DMAPUSH_CHECKFREE(((ULONG)(22)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NVFFF_SET_OBJECT(0),                  DD_INDEXED_IMAGE1_FROM_CPU + i);

        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_DMA_LUT,         NV_WIN_INDEXED_IMAGE_CONTEXT);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_DMA_NOTIFIES,
                          NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_CLIP_RECTANGLE,  DD_IMAGE_BLACK_RECTANGLE);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_PATTERN,         DD_IMAGE_PATTERN);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_ROP,             DD_ROP5_SOLID);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_SURFACE,         DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_CONVERSION,        NV060_SET_COLOR_CONVERSION_TRUNCATE);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_OPERATION,               NV060_SET_OPERATION_ROP_AND);

        // Determine the color format
        switch (ppdev->iBitmapFormat) 
        {
            case BMF_32BPP:
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            case BMF_16BPP:
                // In 16bpp, hardware will dither when using R5G6B5, so we must use X8R8G8B8 to get the exact desired results
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            case BMF_8BPP:
                // Does hardware ignore this value???
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            default:
                return(FALSE);
        }
    }

    //**********************************************************************
    // Setup Image From CPU (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NVFFF_SET_OBJECT(0),                  DD_IMAGE_FROM_CPU);

    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_DMA_NOTIFIES,    NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_CLIP_RECTANGLE,  DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_PATTERN,         DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_ROP,             DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_BETA4,           NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_SURFACE,         DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION,               NV061_SET_OPERATION_ROP_AND);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_R5G6B5);
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    //**********************************************************************
    // Setup Image BLIT (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(18)));
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_IMAGE_BLIT);

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_CLIP_RECTANGLE,    DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_PATTERN,           DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_ROP,               DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_BETA4,             NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_SURFACES,          DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION,                 NV05F_SET_OPERATION_ROP_AND);

    //**********************************************************************
    // Setup RECT and TEXT  (565 format)
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(22)));
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NVFFF_SET_OBJECT(0),               DD_RENDER_RECT_AND_TEXT);

    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_DMA_FONTS,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_PATTERN,      DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_ROP,          DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_SURFACE,      DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_OPERATION,            NV04A_SET_OPERATION_ROP_AND);

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_MONOCHROME_FORMAT,    NV04A_SET_MONOCHROME_FORMAT_CGA6_M1);

    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));

    //**********************************************************************
    // Setup SOLID_LINE
    //**********************************************************************
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0),                   DD_IMAGE_ROP_AND_LIN);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_DMA_NOTIFIES,     NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_CLIP_RECTANGLE,   DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_PATTERN,          DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_ROP,              DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_SURFACE,          DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_OPERATION,                NV05C_SET_OPERATION_ROP_AND);
    ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    if (ppdev->cjPelSize>1)
    {
        ASSERT((2==ppdev->cjPelSize) || (4==ppdev->cjPelSize));

        NV_DMAPUSH_CHECKFREE(((ULONG)(10)));

        /* Set color key blit object into subchannel. */
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),            DD_IMAGE_BLIT_COLORKEY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_SURFACES,     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_COLOR_KEY,    DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_OPERATION,            NV05F_SET_OPERATION_SRCCOPY_AND); // SRCCOPY doesn't support color key

        ppdev->dDrawSpareSubchannelObject = DD_IMAGE_BLIT_COLORKEY;
    }    

    //**********************************************************************
    // Setup ALPHA IMAGE FROM MEMORY
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(8*2)));
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),            DD_ALPHA_IMAGE_FROM_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_DMA_IMAGE,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_PATTERN,      DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_ROP,          DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_BETA4,        NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT,         NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_OPERATION,            NV077_SET_OPERATION_BLEND_PREMULT);

    ppdev->dDrawSpareSubchannelObject = DD_ALPHA_IMAGE_FROM_MEMORY;

    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    ((NvNotification *) (ppdev->Notifiers->Primary2d))->status = 0;

    ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status = 0;

    ((NvNotification *) (&(ppdev->Notifiers->DmaToMem[NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY*sizeof(NvNotification)])))->status = NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS;

    ppdev->NvLastIndexedImageNotifier = 0;

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
        ((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[i*sizeof(NvNotification)])))->status = NV060_NOTIFICATION_STATUS_DONE_SUCCESS;

    return(TRUE);
}

BOOL NvSetupHwObjects(PDEV * ppdev)
{

    ULONG i;

    NV_CREATE_OBJECT_SETUP();

    //**************************************************************************
    // Create misc objects that we need
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA1(DD_ROP5_SOLID,                NV03_CONTEXT_ROP);
    NV_CREATE_OBJECT_DMA1(NV_DD_CONTEXT_BETA4,          NV04_CONTEXT_BETA);
    NV_CREATE_OBJECT_DMA1(MY_MEMORY_TO_MEMORY,          NV03_MEMORY_TO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_BLACK_RECTANGLE,     NV01_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_PATTERN,             NV04_CONTEXT_PATTERN);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_SOLID,               NV04_CONTEXT_COLOR_KEY);
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate misc objects"));
        return(FALSE);
    }

    //**************************************************************************
    // Create INDEXED_IMAGE_FROM_CPU objects
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        NV_CREATE_OBJECT_DMA2(DD_INDEXED_IMAGE1_FROM_CPU + i,
                          NV05_INDEXED_IMAGE_FROM_CPU,NV04_INDEXED_IMAGE_FROM_CPU)
    }
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate INDEXED_IMAGE_FROM_CPU"));
        return(FALSE);
    } else {
        ppdev->CurrentClass.IndexedImageFromCPU = NV_CREATE_OBJECT_CLASS();
    }

    //**************************************************************************
    // Create CONTEXT_SURFACES_2D object
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_PRIMARY_IMAGE_IN_MEMORY,
                          NV10_CONTEXT_SURFACES_2D,NV04_CONTEXT_SURFACES_2D);
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate CONTEXT_SURFACES"));
        return(FALSE);
    } else {
        ppdev->CurrentClass.ContextSurfaces2D = NV_CREATE_OBJECT_CLASS();
    }

    //**************************************************************************
    // Create IMAGE objects
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_IMAGE_BLIT,           NV15_IMAGE_BLIT,NV04_IMAGE_BLIT);
    NV_CREATE_OBJECT_DMA1(DD_RENDER_RECT_AND_TEXT, NV04_GDI_RECTANGLE_TEXT);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_ROP_AND_LIN,    NV04_RENDER_SOLID_LIN);
    NV_CREATE_OBJECT_DMA2(DD_IMAGE_FROM_CPU,
                          NV05_IMAGE_FROM_CPU,NV04_IMAGE_FROM_CPU);

    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate IMAGE objects"));
        return(FALSE);
    }

    //**************************************************************************
    // Create SCALED_IMAGE object used by ESC_NV_DESKMGR_ZOOMBLIT
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA1(DD_SCALED_IMAGE_FROM_MEMORY,
                          NV10_SCALED_IMAGE_FROM_MEMORY);

    if (NV_CREATE_OBJECT_FAIL()) {
        ppdev->CurrentClass.ScaledImageFromMemory = 0;
    } else {
        ppdev->CurrentClass.ScaledImageFromMemory = NV_CREATE_OBJECT_CLASS();
    }


    //**************************************************************************
    // Create objects needed to to a color key transparent blit 
    // for the overly merge blit. Only supported in 16 or 32 bpp
    //**************************************************************************
    if (ppdev->cjPelSize>1)
    {
        ASSERT((2==ppdev->cjPelSize) || (4==ppdev->cjPelSize));

        NV_CREATE_OBJECT_INIT();
        NV_CREATE_OBJECT_DMA1(DD_IMAGE_BLIT_COLORKEY, NV04_IMAGE_BLIT);

        if (NV_CREATE_OBJECT_FAIL()) 
        {
            DISPDBG((0, "Cannot allocate DD_IMAGE_BLIT_COLORKEY overlay merge blit objects"));            
            return(FALSE);
        }
    }

    //**************************************************************************
    // Create ALPHA IMAGE FROM MEMORY object used for AlphaBlended CopyBlt
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_ALPHA_IMAGE_FROM_MEMORY,
                          NV10_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY);

    if (NV_CREATE_OBJECT_FAIL()) 
    {
        DISPDBG((0, "Cannot allocate DD_ALPHA_IMAGE_FROM_MEMORY object"));            
        return(FALSE);
    } else {
        ppdev->CurrentClass.AlphaImageFromMemory = NV_CREATE_OBJECT_CLASS();
    }

    return(TRUE);
}


BOOL bClassSupported(PDEV *ppdev, NvU32 classID)
{
    unsigned int i=0;
    while (i < ppdev->nvNumClasses) {
        if (ppdev->nvClassList[i] == classID) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}



//******************************************************************************
//
//  Function:   NvCreateObject
//
//  Routine Description:
//      Creates a DMA or PIO object given an array of classes.  Walks down array and
//      determines which class is supported by the current hardware.  Once it
//      finds a supported class, it allocates the object.
//      We use this to create the highest known class of a particular type. 
//
//      ie.  NV_CONTEXT_SURFACES_2D which try first with NV10_CONTEXT_SURFACES_2D 
//      and then NV04_CONTEXT_SURFACES_2D
//
//  Arguments:
//      A bunch
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NvCreateObject(PDEV *ppdev,
                    BOOL bCreateDMA,
                    PVOID parms, 
                    NvU32 obj, 
                    NvU32 *createObjClass,
                    NvU32 *createObjFail,
                    int numclasses, 
                    NvU32 *classes) {
    
    int i;                                                                    
    ULONG channel;

    if (bCreateDMA) {
        channel = ppdev->hDmaChannel;
    } else {
        channel = ppdev->hPioChannel;
    }
    *createObjFail |= 1;  // Fail by default
    *createObjClass = 0; 
    for (i=0; i<numclasses; i++) {                      
        if (bClassSupported(ppdev,classes[i])) {
            *createObjClass = classes[i];                                          
                if (NvAlloc(ppdev->hDriver,                                  
                            ppdev->hClient,                                  
                            channel,
                            (obj),                                           
                            (*createObjClass),
                            (parms)) == NVOS05_STATUS_SUCCESS){   
                    *createObjFail &= ~(0x1);                                            
                }                                                                     
            break;
        }
    }                                                                         
    *createObjFail <<= 1;                                                      
}





//******************************************************************************
//
//  Function:   vCalibrate_XferSpeeds
//
//
//  Routine Description:
//
//      This routine calibrates the xfer speeds of the CPU transfers,
//      the DMA xfers, the DMA hardware overhead, the CPU overhead to
//      setup a xfer.  The routine then combine these values into a 
//      single factor in pdev (globalXferOverheadFactor) that will be
//      used in the NVScreenToMem routine to decide which size to take
//      for the xfer chunks. ( The details are in the math. model )
//
//           - Stephane
//
//  Arguments:
//
//      Ptr to PDEV describing the physical device.
//
//  Return Value:
//
//      None.
//
//  Note:
//
//      **IMPORTANT**  This routine include (copy pasted) the actual code of
//                     the function call NV4_DmaPushSend.  This means that
//                     ANY changes to NV4_DmaPushSend must be reflected in
//                     here.  (This is not very good, but this function needs
//                     this to be more accurate)
//
//******************************************************************************


VOID vCalibrate_XferSpeeds(PDEV *ppdev)
{ 
    //***[ For calibration routine ]***[CALIBLOCALS]*****
    
    #define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
    #define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100
    
    ULONG               j;
    
    LONGLONG            llCntrFreq;
    LONGLONG            llTimeStamp1;
    LONGLONG            llTimeStamp2;
    
    BYTE*               SysMemBuffer;
    BYTE*               limit;
    BYTE*               pjFinalDstWrite;
    BYTE*               pjDmaRead;
    BYTE*               pjDmaRead_start;
    
    ULONG               bytesPerLine_max;
    ULONG               bytesPerLine;
    ULONG volatile      volatileDummy;
    BYTE * volatile     volatileDummyPtr;
    ULONG               linesPerXfer;
    ULONG               SrcDMAOffset;
    ULONG               DstDMAOffset;
    ULONG               DstDMA2ndPartOffset;
    ULONG               SrcDMAincPerXfer;
    ULONG               linesToGo;
    
    LONG                lSrcPitch;
    LONG                lDstPitch;
    LONG                FinalDstJump2NextLineBeg;
    
    double              dfX;
    double              dfY;
    double              dfOH;
    double              dfK;
    double              dfTime;
    double              dfFactor;
    
    Nv04ControlDma      *nvDmaChannel;
    NvNotification      *pNotifier;
    
    DECLARE_DMA_FIFO;               // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
        
    //***[ End of locals for calibration routine ]*******
    //*********************************[CALIBLOCALSEND]**

       
    
    
    
   
    //**************************************************************************
    //*[ Profiling Stuff BEGIN ]***[CALIBSTART]*********************************
    //**************************************************************************   
    //************************************************************************** 
    //
    //               SPEED CALIBRATION FOR CONCURENT DMA/CPU XFERS
    //                              
    //                                  - Stephane
    //
    //************************************************************************** 
    // Setup calibration data and calculate and store a "special" num
    // in ppdev->globalXferOverheadFactor.  (There is mathematical/algorithmic
    // details that are not explained in this function, ask me for details)
    // 
    //
    // We have to calculate 
    //
    // X     ( DMAXfer speed )
    // Y     ( DMAXfer speed )
    // OH    ( overhead between issuing command, and DMAXfer actually start and
    //         get into high (well, constant plateau speed ))
    // k     ( overhead of setting up a xfer )
    //
    //
    //  To approximate OH we kick a very small Xfer, and to approximate X,
    //  we set a long transfer, time it, substract OH from time, and compute 
    //  bytes/time.  To approximate Xaj, we use data from long xfer without
    //  substracting OH.
    //
    
    
    
    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    
    //**************************************************************************
    //                                                                         *
    // Get push buffer global information (from pdev) into local variables
    //
    //************************************************************************* 
    
    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
    
    //*                                                                        *
    //**************************************************************************
    
    
    if ( ppdev->pfnScreenToMemBlt != NULL ) // if this function can be called!
    {                                       // or else profiling data is useless
                                            // and moreover, if we are on NV3,
                                            // there is no DMA push buffer
        
        // Make sure our Mem2Mem object is in spare subchannel
        
        NV_DMAPUSH_CHECKFREE(((ULONG)(2)));
    
        if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY)
        {
            NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
            ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
            
            UPDATE_PDEV_DMA_COUNT;   //
            NV4_DmaPushSend(ppdev);  // Flush now, to avoid overhead interfering with calibration
        }
    
    
        //**********************************************************************
        //  Good. We are on NV4 or above, and this function is present. 
        //  We are going to setup variables needed to execute a Vram to SysMem 
        //  Xfer via an intermediate buffer (the DMA locked Mem2Mem buffer)
        //  We need to allocate system memory to simulate a destination bitmap
        //  of a destination region. But how big do we create this region? See:
        //**********************************************************************
    
        //  NOTE to get more "accurate" calibration results.
        //  ----------------------------------------------------------
        //
        //        Either prevent optimization of compiler with a special pragma,
        //        OR prevent optimization by setting data type qualifier to VOLATILE
        //        OR make a dummy function accepting all these parameters by adress,
        //        that do not modify them, so that the compiler flag these vars as
        //        being "unoptimizable" due to use (in the call to the dummy()) 
        //        between initialisation and the use of their value here (below)
        //        
        //        The reason why we want to prevent this is to be more precise in the
        //        profiling: if NV_DMA_FIFO == 1, this might be translated as something
        //        like
        //                      -> adress of dma fifo + dmacount (see dmamacro.h)
        //                     |
        //              mov [ebx],1              ; value appended as immediate operhand in
        //                                       ; actual opcode.
        //
        //        instead of
        //
        //              mov eax, [ebp + ??]      ; put local value into reg
        //              mov [ebx],eax            ; put local value into fifo
        //
        //        The following variables are affected by this remark:
        //        (see Nv4ScreenToMemBlt in nv4bltc.c )
        //        
        //        SrcDMAOffset          : Because it is based on the pjSrcBits which
        //                                is based on the src surface we normally 
        //                                receive in Nv4ScreenToMemBlt
        //
        //        lSrcPitch             : (same thing)
        //        bytesPerLine          : (based on the format of the region we get...)
        //        linesPerXfer          : (based on the optimum byte per xfer runtime
        //                                 algo - this calibration is for that algo!)
        //        linesToGo             : (used in the real loop of the xfer per chunk,
        //                                 even tough here it may never be used, and
        //                                 could be pulled out of this code by the 
        //                                 compiler) BUT SEE NOTE BELOW
        //        
        //        SrcDmaincPerXfer      : This don't change in the loops, but still, the
        //                                values must NOT be included in the ADD opcode
        //                                as immediates by the compiler, because in reality,
        //                                (in NV4ScreenToMemBlt), this would really be
        //                                computed runtime.
        //
        // 
        //
        //        FinalDstJump2NextLineBeg :  ( same thing here)
        //
        //        By the way, pjDmaRead is NOT affected, because we use it as in the "real"
        //        case, that is, it gets = to pdev->MemToMemBuffer
        //
        //  NOTE: There might be some unintended side effects by using Volatile, in that
        //        if we use directly the volatile variables in the loop, those might not
        //        be "cached" into registers.  One way to avoid this is to declare dummy
        //        "mirror" volatile variables, assign the static value to them, and then,
        //        init the normal variables with the content of these "mirror" variables.
        //        That way, the compiler has no choice but to take into account that
        //        these variables MUST be used and the compiler cannot assume any value
        //        at one point in the program after their assignation, since the assignation
        //        values were provided by volatiles, which can, by definition, have any 
        //        values any time.
        //        For linesToGo, it is tricky: we don't want to put THIS variable volatile
        //        to prevent unwanted side effects, but we HAVE to use it or else compiler
        //        will remove it.  So one way to prevent this is to assign a volatile to
        //        the value of linesToGo.
        //
        //  The best solution seems to be to use the "mirror-volatile-init-method" because
        //  disabling optimization could impact the calibration because our "real" code in
        //  ScreenToMem blt IS optimized by the compiler.
        //
    
        
        
        EngQueryPerformanceFrequency(&llCntrFreq);  // get the counter frequency
    
        ppdev->pfnWaitEngineBusy( ppdev );          // because we want to time the overhead 
                                                    // of processing the stuff comming next,
                                                    // not including previous commands that
                                                    // might be still pending or running...
    
        UPDATE_LOCAL_DMA_COUNT;                     // !!!RESYNC the local fifo count because
                                                    // wait busy modifies them!!!!
        
        
        // Find an arbitrary bitmap size (height*width) fitting in the
        // mem2mem buffer by taking the squareroot of its size.
        // we will still limit the transfer to 3.5 MB because we don't
        // know how much vram the card has (well we know but where
        // in the driver this info is stored ? ) Anyway, no card has
        // a framebuffer less than 4 MB, (but to be safe, we're going
        // to put about 3.5 meg, just in case (instance memory ? ) )
        //
        // We take the squareroot for bytesperline because we are
        // going to use that same number as our number of lines
        //
    
        if ( ppdev->MemToMemBufferSize > 3655744 )
        {
            bytesPerLine_max = 1912; // clamp to sqrt(3.486 Meg)                                                                
        }
        else // else use mem2mem buffer size since it is < 3.5 meg
             // (we dont want to use 1912, because mem2mem is smaller
             // than 3.5 meg so we would corrupt mem past the buffer)
             // in other words, take Minimum( 1912, sqrt(memtomembuffersize) )
        {
            bytesPerLine_max = (ULONG) sqrt( ppdev->MemToMemBufferSize ) ;
        }
                         
        //
        // From here on, we will use bytesPerLine as the width also, so that
        // the number (max) of lines we can copy is bytesPerLine also. (considering
        // the "surface" being 8bpp)
        //
    
    
        // Allocate the system memory buffer that will simulate the bits of
        // a destination region in unlocked system ram.
    
        
        SysMemBuffer = (BYTE *) EngAllocMem(0, bytesPerLine_max*bytesPerLine_max, ALLOC_TAG);
    
        if( SysMemBuffer == NULL )
        {
            DISPDBG((1, "DrvEnableSurface - Failed EngAllocMem for mem buffer in calibration section"));
            goto CalibXfer_Error;
        }
        
    
        //**********************************************************************
        //
        //                          OH CALIBRATION
        //                **************************************
        //
        // OH is the overhead time of the hardware: the time the hardware takes
        //    to pull from the DMA push buffer and execute the command ( and
        //    finally start the xfer)
        //
        //
        // Setup variables for a very small DMA Xfer (1 byte) from VRAM start
        // to DMA Mem2Mem buffer
        // (remember the variables are all dummies, we do this for 
        // calibration; all we have to make sure is that there is no access
        // violation of course...)
        //
        // Note that for this first transfer we don't calibrate "K" so it doesnt
        // mather if we use the volatiles to init our variables.
        //
        //**********************************************************************
     
        //---[Set the number of bytes per line of the region to Xfer]-----------
    
        volatileDummy    = 1;                   // set the volatile
        bytesPerLine     = volatileDummy;       // assign by volatile to prevent
                                                // optimization
        
        //---[Set the number of lines per Xfer ]--------------------------------
        //
        //                                   (normally based on OptBytesPerXfer)
    
        volatileDummy    = 1;
        linesPerXfer     = volatileDummy;
        
        
        //---[Set Source/FinalDest Pitch and Address of bits (and inc for 
        //                                                    FinalDest Ptr)]---  
    
        // Don't need this for this for calibration
        //
        //pjSrcBits    = ppdev->pjScreen;      // Assume VRAM Base == pjScreen
                                             // (== base of primary surface)
    
        
        volatileDummy = bytesPerLine;
        lSrcPitch     = volatileDummy;       // set source pitch == bytesPerLines 
                                             // (no gap in mem btw ending of lines and beg.
                                             // of next lines)
                
        //   Don't need these for this first calibration xfer
        //
        //volatileDummy = 1;                
        //lDstPitch     = volatileDummy;
    
        
        //FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;
    
    
    
        //---[Mem2Mem DMA Buffer ReadPtr (to FinalDest) (it's inc == 0)]--------  
                
                
        //  Don't need this for this first calibration xfer
        //
        //pjDmaRead = ppdev->pMemToMemBuffer;  // Init the reading ptr for the second
                                             // transfer "pipe" (the CPU-Xfers)
        
    
        //---[Convert the SRC offset in DMA Offset (and calculate inc. 
        //                                                  after each Xfer)]---
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset = 0;           // Xfer the bytes to start of mem2mem buffer
        
        //  Don't need this for this first calibration xfer
        //
        //                                                      // dont need to "volatile
        //SrcDMAincPerXfer   = linesPerXfer * lSrcPitch;        // mirror" these, because
                                                                // linesPerXfer has already
                                                                // been volatile-assigned.
    
        //---[Set the total number of lines to Xfer (Xfer_siz/bytesPerLine)]----
        
        
        //  Don't need this for this first calibration xfer
        //
        //linesToGo = 1;                       // Init the number of lines left to transfer
    
          
        //***[ Push commands in the DMA Fifo for the 1 byte Xfer ]**************
        
    
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                        
        
        // Don't need that, we don't calibrate that yet
        //
        //
        //linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
        //SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region
        //DstDMAOffset  = DstDMA2ndPartOffset;   // Use the other part of dst DMA region (mem2mem buffer)
                        
                
        // Intstead of that:
        //
        //NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        //
        // We will copy paste the function in here so that we can get the time
        // stamp just before the hardware starts processing the FIFO
    
        //  THIS IS COPY PASTED  nv4hw.c BECAUSE WE WANT TO START PROFILING
        //  JUST BEFORE THE LAST STATEMENT OF THIS FUNCTION
    
        nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

        //**********************************************************************
        // Check if the ALI 1541 chipset is present.
        // If so, then we need to workaround a cache issue by doing an out to port
        //**********************************************************************
        
        if (ppdev->AliFixupIoNeeded)
            {
        // Assembly is not feasible for IA64
        #ifndef _WIN64
            outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
        #endif
            }
        
        
        #ifdef NVD3D    // DX6
        //**********************************************************************
        // If there is another DMA push channel active, wait til it's finished.
        //
        // It hurts performance to check this with every kickoff, so we only do
        // this check when:
        // 1) This is a DX6 build. We can only successfully sync with other DMA
        //    Push Channels and not PIO channels (DX3 is PIO only).
        // 2) DirectDraw is enabled and ddraw objects have been created
        //   (determined by checking if surfaces have been created).
        //
        //**********************************************************************
        
        if ((ppdev->DDrawEnabledFlag) &&
            (ppdev->pDriverData->DDrawVideoSurfaceCount))
            {
            if (ppdev->pfnWaitForChannelSwitch)
                ppdev->pfnWaitForChannelSwitch(ppdev);
            }
        #else
        //**********************************************************************
        // It's possible the DX3 PIO channel is still active. We need to wait
        // til it's finished. It hurts performance to check this with every
        // kickoff, so we only do this check when DirectDraw is enabled.
        //**********************************************************************
        if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
            {
            NV4_DdPioSync(ppdev);
            ppdev->bDDChannelActive = FALSE;
            }
        #endif // #ifndef NVD3D
        
        //**************************************************************************
        // Convert the PUT ptr to a byte address
        //**************************************************************************
        
        ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;
        
        //**************************************************************************
        // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
        // Then 'OR' it near the end of the push buffer
        //**************************************************************************
        
        if (ppdev->nvDmaCount >0)
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
        else
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];
        
        *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;
        
        //**************************************************************************
        // Tell the hardware to start processing the push buffer
        //**************************************************************************
        
        //**********************************************************************
        //  Here, just before kicking this, we snoop the Eng counter 
        //**********************************************************************
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        nvDmaChannel->Put = ppdev->nvDmaCachedPut;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
        // The 1 byte Transfer is completed, get the timestamp
    
        EngQueryPerformanceCounter(&llTimeStamp2);
        
        dfOH = (double)(llTimeStamp2 - llTimeStamp1)/(double)(llCntrFreq) ; // get time in seconds;
        
        if ( dfOH == 0 ) 
            goto CalibXfer_Error;
        
        
        
        //**********************************************************************
        //
        //                      K,X, and Y  CALIBRATION
        //                **************************************
        //
        // Setup variables for the largest DMA xfer we can have.
        //
        //**********************************************************************
        
    
    
        //---[Set the number of bytes per line of the region to Xfer]-----------
    
        // bytesPerLine_max must be run time calculated so don't need to use
        // the volatile trick here ? Need to use it so we have a different
        // local variable created, otherwise compiler will never really create
        // "bytesPerLine" and only bytesPerLine_max
        
        volatileDummy    = bytesPerLine_max;        // see init of bytesPerLine_max
        bytesPerLine     = volatileDummy;
                                            
        
        //---[Set the number of lines per Xfer ]--------------------------------
        //
        //                                   (normally based on OptBytesPerXfer)
    
        volatileDummy    = bytesPerLine_max;        // see init of bytesPerLine_max
        linesPerXfer     = volatileDummy;
        
        
        //---[Set Source/FinalDest Pitch and Address of bits (and inc for 
        //                                                    FinalDest Ptr)]---  
    
        
        volatileDummy = bytesPerLine;
        lSrcPitch     = volatileDummy;       // set source pitch == bytesPerLine 
                                             // (no gap in mem btw ending of lines and beg.
                                             // of next lines)
                
        volatileDummy = bytesPerLine;        // Final destination pitch (our sys MEM        
        lDstPitch     = volatileDummy;       // cached surface (unlocked))
    
        
        FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;  // inc to jump a beg of next line
                                                              // when at the end off the preceding
                                                              // one
    
        //---[Mem2Mem DMA Buffer ReadPtr (to FinalDest) (it's inc == 0)]--------  
                
                
        pjDmaRead       = ppdev->pMemToMemBuffer;  // Init the reading ptr for the second
                                                   // transfer "pipe" (the CPU-Xfers)
        
        volatileDummyPtr= (BYTE *)(ppdev->pMemToMemBuffer);
        
        pjDmaRead_start = volatileDummyPtr;

        pjFinalDstWrite = SysMemBuffer;      // Where to write our CPU Xfers
    
    
        //---[Convert the SRC offset in DMA Offset (and calculate inc. 
        //                                                  after each Xfer)]---
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset        = 0;               // Xfer the bytes to start of mem2mem buffer
        
        DstDMA2ndPartOffset = volatileDummy;   // 2nd part of mem2mem buffer (dummy, we don't care)
        
                                                                // dont need to "volatile
        SrcDMAincPerXfer   = linesPerXfer * lSrcPitch;          // mirror" these, because
                                                                // linesPerXfer has already
                                                                // been volatile-assigned.
    
        //---[Set the total number of lines to Xfer (Xfer_siz/bytesPerLine)]----
                
        volatileDummy = bytesPerLine_max;    // see init of bytesPerLine_max
        linesToGo     = volatileDummy;       // Init the number of lines left to transfer
    
          
        //***[ Push commands in the DMA Fifo for the big Xfer ]*****************
        
        EngQueryPerformanceCounter(&llTimeStamp1);  // Get time stamp first (for K)
    
    
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                        
                
        NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        
                
        // We now need the following, we calibrate K
        //
        //
        linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
        SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region
        DstDMAOffset  = DstDMA2ndPartOffset;   
        
        // we also include the following, even if in the actual code, it's not in the same place,
        // but because it still has to be executed for each cpu xfers, we include this in K

        pjDmaRead = pjDmaRead_start;

    
        EngQueryPerformanceCounter(&llTimeStamp2);  // Get time stamp (for K)
                
        
        dfK = (double)( llTimeStamp2 - llTimeStamp1 ) / (double)(llCntrFreq) ; // get K in seconds
        
        if ( dfK == 0 ) 
            goto CalibXfer_Error;
        
        
        // Note that here, the EngQuery have overhead, and if the Xfer is too
        // fast, we might wrongly calibrate X if we do the while(!notified) and 
        // get a third timestamp right here. Instead, we are going to kick the xfer
        // another time
    
        // Make sure the variables are used in our program so compiler don't
        // warn us or remove the above (useless) statements
    
        volatileDummy = linesToGo;        // dummy...
        volatileDummy = SrcDMAOffset;
        volatileDummy = DstDMAOffset;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
    
        //***[ Setup another Xfer to calibrate X ]**********************************
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset = 0;               // Xfer the bytes to start of mem2mem buffer
        
        volatileDummy = bytesPerLine_max;  // see init of bytesPerLine_max
        linesToGo     = volatileDummy;     // Init the number of lines left to transfer
    
    
        //***[ Push commands in the DMA Fifo for the 2nd big Xfer ]*************
        
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count                                        
        // PushSend:
        //
        //  THIS IS COPY PASTED  nv4hw.c BECAUSE WE WANT TO START PROFILING
        //  JUST BEFORE THE LAST STATEMENT OF THIS FUNCTION
    
        nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

        //**********************************************************************
        // Check if the ALI 1541 chipset is present.
        // If so, then we need to workaround a cache issue by doing an out to port
        //**********************************************************************

        if (ppdev->AliFixupIoNeeded)
            {
        // Assembly is not feasible for IA64
        #ifndef _WIN64
                outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
        #endif
            }
    
    
        #ifdef NVD3D    // DX6
        //**********************************************************************
        // If there is another DMA push channel active, wait til it's finished.
        //
        // It hurts performance to check this with every kickoff, so we only do
        // this check when:
        // 1) This is a DX6 build. We can only successfully sync with other DMA
        //    Push Channels and not PIO channels (DX3 is PIO only).
        // 2) DirectDraw is enabled and ddraw objects have been created
        //   (determined by checking if surfaces have been created).
        //
        //**********************************************************************

        if ((ppdev->DDrawEnabledFlag) &&
            (ppdev->pDriverData->DDrawVideoSurfaceCount))
            {
            if (ppdev->pfnWaitForChannelSwitch)
                ppdev->pfnWaitForChannelSwitch(ppdev);
            }
        #else
        //**********************************************************************
        // It's possible the DX3 PIO channel is still active. We need to wait
        // til it's finished. It hurts performance to check this with every
        // kickoff, so we only do this check when DirectDraw is enabled.
        //**********************************************************************
        if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
            {
            NV4_DdPioSync(ppdev);
            ppdev->bDDChannelActive = FALSE;
            }
        #endif // #ifndef NVD3D

        //**************************************************************************
        // Convert the PUT ptr to a byte address
        //**************************************************************************

        ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

        //**************************************************************************
        // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
        // Then 'OR' it near the end of the push buffer
        //**************************************************************************

        if (ppdev->nvDmaCount >0)
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
        else
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

        *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;
        
        //**************************************************************************
        // Tell the hardware to start processing the push buffer
        //**************************************************************************
        
        //**********************************************************************
        //  Here, just before kicking this, we snoop the Eng counter 
        //**********************************************************************
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        nvDmaChannel->Put = ppdev->nvDmaCachedPut;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
        // The big transfer is completed, get the timestamp
    
        EngQueryPerformanceCounter(&llTimeStamp2);
        
        // Problem: We don't know how big dfTime can be: this is dependant of the counter
        //          frequency. If it is too big, we will loose all precision in the totalbytes/dfTime
        //          division.  So, the division must not, at first come lower than the smallest positive,
        //          that can be represented by a double, 4.94065645841247E-324 .  Even then, we must check
        //          the operations AFTER that concern X. We will calculate, at the end, sqrt(X*OH) or
        //          sqrt(Y*K).  K and OH are at least one, so sqrt(X) and sqrt(Y) must not be lower than
        //          4.94065645841247E-324, so X and Y should be >= (4.94065645841247E-324 )^2 (but this is
        //          even lower than 4.94065645841247E-324 so the latter is our boundary. 
        //          
        //          (We could also convert the ticks in seconds, with counter frequency, and then divide 
        //          the size of the transfer by the number of seconds it took.  We know that this can't be 
        //          lower than 1 byte (even 1k, even 1 MB ! )   )
      
        dfTime = ( (double)( llTimeStamp2 - llTimeStamp1) - dfOH ) / (double)(llCntrFreq) ; // get time in seconds
    
        if( dfTime == 0 ) // never supposed to happen but...
        {
            // OH is of the order of the time of the xfer, bailout, disable overlapping
            // of Xfers
            goto CalibXfer_Error;
        }
        
        
        dfX = (double)( bytesPerLine * bytesPerLine ) / dfTime ;
        
        if ( dfX <= 4.94065645841247E-324 ) 
            goto CalibXfer_Error;  // practically, dfX would be >>> 1 ! 
                        
        
        //**********************************************************************
        //
        //                           Y  CALIBRATION
        //                **************************************
        //
        // CPU Xfer the big Xfer we just DMA-Xfered.
        //
        //**********************************************************************
    
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        for(j=0; j < linesPerXfer; j++)
        {            
                    
            // Xfer a whole line
            //
            for(limit = pjDmaRead + bytesPerLine; 
                pjDmaRead < limit; 
                pjDmaRead++, pjFinalDstWrite++ )
            {
                *pjFinalDstWrite = *pjDmaRead ;
            }
            pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                         // next line in the dest surface
    
        } // ...for all bytes in chunk to cpu-xfer
    
        EngQueryPerformanceCounter(&llTimeStamp2);
    
                
        
        dfTime = (double)( llTimeStamp2 - llTimeStamp1 ) / (double)(llCntrFreq) ; // get time in seconds
    
        if( dfTime == 0 ) 
            goto CalibXfer_Error;
                
        dfY = (double)( bytesPerLine * bytesPerLine ) / dfTime ;
        
        if ( dfY <= 4.94065645841247E-324 ) 
            goto CalibXfer_Error;  // practically, dfY would be >>> 1 ! 
    
        // One remark here: we could combine this last if with the if( dfTime == 0)
        // same thing goes for calculation of dfX (see before)...
    
    
        //**********************************************************************
        //
        //               globalXferOverheadFactor CALCULATION
        //             ****************************************
        //
        //  Now that we have X, Y, K, OH, all is left to do is to combine 
        //  (choose which data to use) the calibration data into one value,
        //  the OverheadFactor.  This is were the real model I have designed
        //  and the actual implementation diverge:  this has been done for 
        //  speed purpose of course, and anyway, with experimentation in MatLab,
        //  I have showed that this approximation of the dependant variable
        //  that give the "maxima" of the piecewise optimization function, gives
        //  pretty good results.  Otherwise, if we wanted to have the REAL
        //  optimal block size 100% of the time (I say 100% because the appro-
        //  ximation computation == the optimal anyway), we would be forced to
        //  find the maximum of a piecewise function (made of 2 analytical 
        //  functions and 1 junction).  This implies calculating 2 analytical
        //  maxima, the maxima of the junction (boundarie of the two pieces)
        //  and finally take the max of all those max. (For each Xfer of bitmaps
        //  region) This is unacceptable !
        //  Even now, with this approximation, I end up calculating one maxima
        //  by plugging values in the derivative of an analytical function. This
        //  implies calculating 1 MUL, and 1 SQRT (but the SQRT is optimized, it
        //  is not a CPU-SQRT). Thus...
        //
        //  TODO (would be good to try): instead of calc. the SQRT of Transfer 
        //  size * globalXferOverheadFactor (see nv4bltc.c NV4ScreenToMemBlt),
        //  fill a lookup table with common xfer size VS the opt xfer size, using
        //  the REAL model.  The "common xfer sizes" could be the middle of each
        //  power of 2. (Pretty much like I did the LUT to be able to compute a
        //  SQRT with Newton's method with only 2 iterations).
        //
        //  Of course, before trying this, we would have to see what is the
        //  maximum error we can commit for S (block size of xfer) for each
        //  value in the lookup (each interval) and see if it's worth it. If it's
        //  not, do a linear interpolation ?  (but this bring us back to the sqrt
        //  because Newton's method implies iteration similar to the interpolation)
        //
        //**********************************************************************
    
        //
        // Decide what to use: sqrt(Y*OH) or sqrt(X*K)
        //
                
        if(  ( (dfX/dfY) / (dfOH/dfK) )    >= 1  )
        {
            // Use analytic equation (OgA)' (derivative)
            //  
            // OgA' = sqrt( T*X*K ) = sqrt(T) * sqrt( X*K )
    
            dfFactor = sqrt( dfX*dfK );            
        }
        else
        {
            // Use analytic equation (OgB)' (derivative)
            //  
            // OgB' = sqrt( T*Y*OH ) = sqrt(T) * sqrt( Y*OH )
    
            dfFactor = sqrt( dfY*dfOH );
        }
    
        //
        // Convert the dfFactor in int but check boundaries before
        //
    
        if( dfFactor < 1 )                        // clamp to 1 at least
            ppdev->globalXferOverheadFactor = 1;
        
        else 
        {
            if( dfFactor > 65535 )
                ppdev->globalXferOverheadFactor = 65535;  // 16bit max
            else
                ppdev->globalXferOverheadFactor = (int)(dfFactor);
        }
    
        goto CalibXfer_Done;
    
        
        //---[ An error has most likely occured ]-------------------------------
        
        CalibXfer_Error:
    
            // We diseable implicitly the overlapping
    
            ppdev->globalXferOverheadFactor = 65535;  // 16bit max
    
    
        //---[ All Done... ]----------------------------------------------------
    
        CalibXfer_Done:
    
            EngFreeMem(SysMemBuffer);
    
            
    } // ...if ( ppdev->pfnScreenToMemBlt != NULL ), profile stuff
                                                            
    //**************************************************************************
    //**************************************************************************
    //*[ Profiling Stuff END ]*****[CALIBEND]***********************************
    //**************************************************************************

}

// ...End of:  vCalibrate_XferSpeeds
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvMultiMon.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: nvMultiMon.c                                                  *
//                                                                             *
//  This module contains the support functions for the TwinView multi-mon code *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"
#include "oglDD.h"
#include "nvReg.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"

// public prototypes
void UseOnlyGDIDataForModeDetails(PDEV *ppdev);
void UseOnlyRegistryDataForModeDetails(PDEV *ppdev, NVTWINVIEWDATA *pData);
BOOL InitMultiMon(PDEV *ppdev);
void GetDefaultTVFormat(PPDEV ppdev);
void FreeMemoryMultiMon(PDEV *ppdev);
BOOLEAN TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOLEAN bQuerySupportPhysicalMode(PPDEV ppdev, ULONG head, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode);
VOID vBackOffMode(PPDEV ppdev, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode);
BOOLEAN bQueryBothPanelsAreInSync(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOLEAN bConfirmDeviceType(PPDEV ppdev, ULONG Head, ULONG RequestedDeviceMask, ULONG RequestedDeviceType, ULONG RequestedTVType,
                           ULONG * SuggestedDeviceMask, ULONG * SuggestedDeviceType, ULONG * SuggestedTVType);
void PrintPPDEVTwinViewInfo (char *Msg, PPDEV ppdev);
void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev);
BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes);
void InduceAndUpdateDeviceScanning (PPDEV ppdev);
void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOL BuildModeLists(PPDEV ppdev);
ULONG ValidateRegistryDeviceMasks(PPDEV ppdev, NVTWINVIEWDATA *pData);
VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);
VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);


VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);
ULONG GetNumberDacsActiveFromTwinViewInfo (NVTWINVIEWDATA *pData);
VOID InitDevMaskFromTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);

ULONG MaskToDeviceType( PPDEV ppdev, ULONG ulDeviceMask);
ULONG TVFormatToTVDeviceType(ULONG ulTVFormat);
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask);
ULONG HandleBIOSHeads(PPDEV ppdev);
VOID HandleBandWidth_SingleDacActive(PPDEV ppdev);
VOID HandleBandWidth_DualDacsActive(PPDEV ppdev);

BOOLEAN FindNextLowerRefreshRateMode(PPDEV ppdev, ULONG Head, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerRefreshRate);
BOOLEAN FindNextLowerResolutionMode(PPDEV ppdev, ULONG Head, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerWidth, ULONG *pNextLowerHeight);

BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
          ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning);

/*  Reg utils */

BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData);
VOID SetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG ulData);

// The next two functions are used 
// as wrapper to do an IOCTL reg key read/write (it wraps the NV_REG struct setup)
// ( *W functions uses unicode strings ( L"abcde..." ) )

void GetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);
void SetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);

/* ... Reg Utils */


ULONG GetInitiatedRegValue(PPDEV ppdev);
VOID SetInitiatedRegValue(PPDEV ppdev, ULONG ulVal);
ULONG GetPowerStateRegValue(PPDEV ppdev);
VOID SetPowerStateRegValue(PPDEV ppdev, ULONG ulVal);
ULONG GetPrevDevMaskRegValue(PPDEV ppdev);
VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal);

VOID vReadSaveSettings(PPDEV ppdev);
VOID vWriteSaveSettings(PPDEV ppdev);
NVTWINVIEWDATA *pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS *pQuery, NVTWINVIEWDATA * pTwinViewData);
VOID vPrintSaveSettings(PPDEV ppdev, ULONG ulDebugLevel);


#if DBG
extern ULONG DebugLevel;
VOID GetDebugLevelRegValue(PPDEV ppdev);
#endif DBG


extern VOID NVMovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y);


     


//
// This function makes sure that the physical coords and virtual coords of the two heads are correctly set.
// We use only the GDI mode details and completely ignore the registry data.
// This function is to be used only in the case of when the registry entry 'TwinViewInfo' does not exist or the registry 
// entry info is not sane.
//
void  UseOnlyGDIDataForModeDetails(PDEV *ppdev)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;

    DISPDBG((5,"Enter UseOnlyGDIDataForModeDetails()\n"));


    // Check to see if it is horizontal orientation
    if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        ppdev->TwinView_State = NVTWINVIEW_STATE_SPAN;
        ppdev->TwinView_Orientation = HORIZONTAL_ORIENTATION;
        ppdev->ulNumberDacsActive = 2;
        ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;

        RequestedMode.Width = (USHORT)ppdev->cxScreen / 2;
        RequestedMode.Height = (USHORT)ppdev->cyScreen;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen / 2, ppdev->cyScreen);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }

        //
        // Fill in the info for secondary device
        //
        ulHead = ppdev->ulDeviceDisplay[1];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], ppdev->cxScreen / 2, 0, 
            ppdev->rclDisplayDesktop[ulHead].left + (ppdev->cxScreen / 2), ppdev->cyScreen);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], ppdev->cxScreen / 2, 0, 
                ppdev->rclCurrentDisplay[ulHead].left + RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], ppdev->cxScreen / 2, 0, 
                ppdev->rclCurrentDisplay[ulHead].left + BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // HORIZONTAL_MODE

    // check to see if it is vertical orientation
    if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        ppdev->TwinView_State = NVTWINVIEW_STATE_SPAN;
        ppdev->TwinView_Orientation = VERTICAL_ORIENTATION;
        ppdev->ulNumberDacsActive = 2;
        ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;

        RequestedMode.Width = (USHORT)ppdev->cxScreen;
        RequestedMode.Height =(USHORT) ppdev->cyScreen / 2;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen, ppdev->cyScreen / 2);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }

        //
        // Fill in the info for secondary device
        //
        ulHead = ppdev->ulDeviceDisplay[1];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, ppdev->cyScreen / 2, 
            ppdev->cxScreen, ppdev->rclDisplayDesktop[ulHead].top + (ppdev->cyScreen / 2));

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, ppdev->cyScreen / 2,
                RequestedMode.Width, ppdev->rclCurrentDisplay[ulHead].top + RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, ppdev->cyScreen / 2,
                BestFitMode.Width, ppdev->rclCurrentDisplay[ulHead].top + BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // VERTICAL_MODE

    if (!MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        // We are in Normal mode. There is no concept of clone mode when we use the GDI data.
        if (ppdev->TwinView_State != NVTWINVIEW_STATE_DUALVIEW)
            ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;

        // This is the normal mode where we use only one dac.
        ppdev->ulNumberDacsActive = 1;

        RequestedMode.Width = (USHORT)ppdev->cxScreen;
        RequestedMode.Height = (USHORT)ppdev->cyScreen;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Handle the case where nothing is connected to Head0 but something is connected to head1
        //
        if (ppdev->ulNumberDacsOnBoard == 2)
        {
            if (ppdev->ulNumberDacsConnected == 1)
            {
                if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL)
                {
                    switch (ppdev->ulDeviceDisplay[0])
                    {
                
                    case 0:
                        if (ppdev->ulDeviceType[0] == INVALID_DEVICE_TYPE && ppdev->ulDeviceType[1] != INVALID_DEVICE_TYPE)
                        {
                            // Swap the heads so that we use the other head.
                            ppdev->ulDeviceDisplay[0] = 1;
                            ppdev->ulDeviceDisplay[1] = 0;
                        }
                        break;

                    case 1:
                        if (ppdev->ulDeviceType[1] == INVALID_DEVICE_TYPE && ppdev->ulDeviceType[0] != INVALID_DEVICE_TYPE)
                        {
                            // Swap the heads so that we use the other head.
                            ppdev->ulDeviceDisplay[0] = 0;
                            ppdev->ulDeviceDisplay[1] = 1;
                        }
                        break;

                    default:  
                        DISPDBG((0,"Oops! The primary head is bogus: 0x%x",ppdev->ulDeviceDisplay[0]));
                        break;
                    }
                }
            }
        }


        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen, ppdev->cyScreen);
        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // NORMAL_MODE
}

//
// Returns the number of active dacs from the TwinViewInfo. The returned values are
// 1: standard mode
// 2: clone mode
// 2: spanning mode with a spanning resolution.
// 1: spanning mode with the single screen resolution (6x4, 8x6, 10x7).
// 1: If TwinViewInfo is invalid. This is the safe default value.
//
ULONG GetNumberDacsActiveFromTwinViewInfo (NVTWINVIEWDATA *pData)
{
    ULONG ulNumberDacsActive = 1;

    DISPDBG((5, "Enter GetNumberDacsActiveFromTwinViewInfo()\n"));
    if (pData == NULL)
    {
        DISPDBG((0, "Something Wrong. NULL pointer passed for TwinViewInfo structure"));
        return(ulNumberDacsActive);
    }

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ulNumberDacsActive = 1;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ulNumberDacsActive = 2;
            break;
        case NVTWINVIEW_STATE_SPAN:
            //sanity check
            if (!MULTIMON_MODE((pData->DeskTopRectl.right - pData->DeskTopRectl.left),(pData->DeskTopRectl.bottom - pData->DeskTopRectl.top)))
            {
                ULONG width;
                ULONG height;
                width = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
                height = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
                if ((width == 640 && height == 480) ||
                    (width == 800 && height == 600) ||
                    (width == 1024 && height == 768))
                {
                    //
                    // this is ok as we always export these special modes.
                    // The jury is still out on whether we should set the NumberDacsActive to 1 or 2 for this
                    // case, as the more intuitive option. I vote for 1 as being the more intuitive.
                    //
                    ulNumberDacsActive = 1;
                }
                else
                {
                    DISPDBG((0, "Oops! State: 0x%x, inconsistent with the DeskTopRectl: (%d, %d), (%d, %d)\n",pData->dwState,
                        pData->DeskTopRectl.left, pData->DeskTopRectl.top, pData->DeskTopRectl.right,pData->DeskTopRectl.bottom));
                    ulNumberDacsActive = 1;
                }
            }
            else
            {
                // This is a true multimon resolution
                ulNumberDacsActive = 2;
            }
            break;
        default:
            DISPDBG((0, "Oops! Invalid State from the registry pData: 0x%x\n",pData->dwState));
            ulNumberDacsActive = 1;
            break;
    }
    return(ulNumberDacsActive);
}

//
// This function makes sure that the physical coords and virtual coords of the two heads are correctly set.
// We use only the Registry data set by the nVidia panel and completely ignore the GDI Data (which is a safe thing
// thing to do anyway because at this point, we should have made sure that the GDI data is in complete sync 
// with the registry data.
//
void UseOnlyRegistryDataForModeDetails(PDEV *ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG SuggestedDeviceMask, SuggestedDeviceType, SuggestedTVType;
    ULONG ulPrimaryHead;

    DISPDBG((5, "Enter UseOnlyRegistryDataForModeDetails()\n"));

    ppdev->TwinView_State = pData->dwState;
    ppdev->TwinView_Orientation = pData->dwOrientation;

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ppdev->ulNumberDacsActive = 1;
            ppdev->ulDesktopMode = 0;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ppdev->ulNumberDacsActive = 2;
            ppdev->ulDesktopMode = NV_CLONE_DESKTOP | NV_TWO_DACS;
            break;
        case NVTWINVIEW_STATE_SPAN:
            //sanity check
            if (!MULTIMON_MODE((pData->DeskTopRectl.right - pData->DeskTopRectl.left),(pData->DeskTopRectl.bottom - pData->DeskTopRectl.top)))
            {
                ULONG width;
                ULONG height;
                width = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
                height = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
                if ((width <= 640 && height <= 480) ||
                    (width == 800 && height == 600) ||
                    (width == 1024 && height == 768))
                {
                    //
                    // this is ok as we always export these special modes.
                    // The jury is still out on whether we should set the NumberDacsActive to 1 or 2 for this
                    // case, as the more intuitive option. I vote for 1 as being the more intuitive.
                    //
                    ppdev->ulNumberDacsActive = 1;
                    ppdev->ulDesktopMode = 0;
                }
                else
                {
                    DISPDBG((0, "Oops! State: 0x%x, inconsistent with the DeskTopRectl: (%d, %d), (%d, %d)\n",pData->dwState,
                        pData->DeskTopRectl.left, pData->DeskTopRectl.top, pData->DeskTopRectl.right,pData->DeskTopRectl.bottom));
                    return;
                }
            }
            else
            {
                // This is a true multimon resolution
                ppdev->ulNumberDacsActive = 2;
                ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;
            }
            break;
        default:
            DISPDBG((0, "Oops! Invalid State from the registry pData: 0x%x\n",pData->dwState));
            return;
            break;
    }

    ulPrimaryHead = pData->dwDeviceDisplay[0];
    ppdev->cxScreen = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
    ppdev->cyScreen = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
    ppdev->cBitsPerPel = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp; // same for both devices
    ppdev->cjPelSize = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp / 8; // same for both devices
    ppdev->ulGDIRefreshRate = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwRefresh;

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        // Get the physical head ==> logical head mapping.
        ppdev->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
    }

    //
    // We should iterate through only the numberDacsActive for std/clone/span modes.
    // The only exception is the WindowsXP dualView mode where both heads needs to be initialized
    // even though the NumberDacsActive is 1.
    //
    for (i=0; i < (pData->dwState == NVTWINVIEW_STATE_DUALVIEW ? ppdev->ulNumberDacsOnBoard : ppdev->ulNumberDacsActive); i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];

        // Get the per head flags.
        ppdev->ulEnablePanScan[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnablePanScan;
        ppdev->ulEnableDDC[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnableDDC;
        ppdev->ulEnableDDC[ulHead] = 1; // Hardcoded for now till control panel adds a button for this.
        ppdev->ulFreezePanScan[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezePanScan;
        ppdev->ulFreezeOriginX[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezeOriginX;
        ppdev->ulFreezeOriginY[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezeOriginY;
        ppdev->ulTimingOverRide[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide;


        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.left,
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.top, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.right,
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.bottom);

        //
        // Before we honor the nvPanel's device type selection, lets verify it.
        //
        if (bConfirmDeviceType(ppdev, ulHead, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType, 
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat, &SuggestedDeviceMask, &SuggestedDeviceType, &SuggestedTVType))
        {
            DISPDBG((5,"The requested device type is valid.\n"));
            // use the nvPanel's selected device type
            ppdev->ulDeviceMask[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            ppdev->ulDeviceType[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
            ppdev->ulTVFormat[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
        }
        else
        {
            DISPDBG((0,"Head: %d, The nvPanel requested an invalid device type: 0x%x, TVFormat: 0x%x\n",ulHead,
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType,pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat));
            DISPDBG((0,"so using the suggested default device type: 0x%x, TVFormat: 0x%x\n", 
                SuggestedDeviceType,SuggestedTVType));
            ppdev->ulDeviceMask[ulHead] = SuggestedDeviceMask;
            ppdev->ulDeviceType[ulHead] = SuggestedDeviceType;
            ppdev->ulTVFormat[ulHead] = SuggestedTVType;
        }

        //
        // Before we honor the nvPanel's physical rectangle and refrsh, lets verify it.
        //
        RequestedMode.Width = (USHORT)(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.right - pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.left);
        RequestedMode.Height = (USHORT)(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.bottom - pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.top);
        RequestedMode.RefreshRate = (USHORT)pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh;
        RequestedMode.Depth = (USHORT)pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp;

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            // Registry had valid physical mode info. Use it as is.
            ppdev->rclCurrentDisplay[ulHead].left = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.left;
            ppdev->rclCurrentDisplay[ulHead].top = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.top;
            ppdev->rclCurrentDisplay[ulHead].right = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.right;
            ppdev->rclCurrentDisplay[ulHead].bottom = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.bottom;
            ppdev->ulRefreshRate[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh;
        }
        else
        {
            // Registry did not have have valid physical mode info. So construct it.
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
            //
            // If we are on multimon, adjust the coordinates appropriately for the second head
            //
            if (pData->dwState == NVTWINVIEW_STATE_SPAN && i == 1)
            {
                if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen))
                {
                    ppdev->rclCurrentDisplay[ulHead].left += ppdev->cxScreen / 2;
                    ppdev->rclCurrentDisplay[ulHead].right += ppdev->cxScreen / 2;
                }
                if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen))
                {
                    ppdev->rclCurrentDisplay[ulHead].top += ppdev->cyScreen / 2;
                    ppdev->rclCurrentDisplay[ulHead].bottom += ppdev->cyScreen / 2;
                }
            }
        }
    }
}


//
//  Does a one time initialization of the following info into the pdev.
//
//  TwinView_State: Read from the registry (normal/clone/multimon).
//  ulNumberDacsOnBoard: Number of heads in the system.
//  ulNumberDacsConnected: Number of heads in the system which are connected to a device.
//  ulNumberDacsActive: Number of heads in the system which are active for this mode.
// ulAllDeviceMask: A mask of all output device connectors in the board.
// ulConnectedDeviceMask: A mask of all currently connected output devices in the system.
//  ulMoveDisplayDX, ulMoveDisplayDy: Panning-scanning amaount to move the screen by.
//  ulDeviceMask[NumDacs]: Bitmask for the device connected to each head.defined in nvcm.h
//  ulDeviceType[NumDacs]: defined in nvcm.h, CRT, TV, DFP
//  ulTVFormat[numDacs]: PAL or NTSC
//  ulNumPhysModes[numDacs]
//  ulnumVirtualModes[NumDacs]
//  PhysModeList[numDacs]
//  VirtualModeList[NumDacs]
//  
//
BOOL InitMultiMon(PDEV *ppdev)
{
    ULONG i, j;
    ULONG ReturnedDataLength;
    NVTWINVIEWDATA sData;
    ULONG RegistryDataOK;   // This indicates if the user selections of the nvPanel stored into the registry is OK.
    ULONG UseGDIData;
    ULONG ulDisplayWidth;
    ULONG ulDisplayHeight;
    ULONG ulHead;
    GET_NUMBER_DACS   NumberDacs;
    ULONG ulDeviceType;
    ULONG ulRet;
    ULONG ulDeviceMask;
    ULONG ulTVFormat;
    ULONG UseBIOSHeads;
    ULONG Status;
    ULONG PowerStateRegValue;
    ULONG ulCombinedDeviceMask, ulTmp;
    ULONG ulBIOSDeviceMask;
    


    DISPDBG((6,"InitMultiMon(): Enter"));


    // Get the head info from the miniport such as number of heads on board, number of heads connected and device type of each head.
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_NUMBER_DACS,
                        NULL,
                        0,
                        &NumberDacs,
                        sizeof(NumberDacs),
                        &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! InitMultiMon() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
        // Set safe default values.
        ppdev->ulNumberDacsOnBoard = 1;
        ppdev->ulNumberDacsConnected = 1;
        ppdev->ulAllDeviceMask = BITMASK_CRT0;
        ppdev->ulConnectedDeviceMask = BITMASK_CRT0;
        for (i=0; i < NV_NO_DACS; i++)
        {
            ppdev->ulDeviceMask[i] = BITMASK_CRT0;
            ppdev->ulDeviceType[i] = MONITOR_TYPE_VGA;
        }
    }
    else
    {
        // Fill the info into ppdev.
        ppdev->ulNumberDacsOnBoard = NumberDacs.ulNumberDacsOnBoard;
        ppdev->ulNumberDacsConnected = NumberDacs.ulNumberDacsConnected;
        ppdev->ulAllDeviceMask = NumberDacs.ulAllDeviceMask;
        ppdev->ulConnectedDeviceMask = NumberDacs.ulConnectedDeviceMask;
        ppdev->Mobile = NumberDacs.Mobile;
        ppdev->UseHWSelectedDevice = NumberDacs.UseHWSelectedDevice;
        ppdev->ACPISystem = NumberDacs.ACPISystem;
        ppdev->UseHotKeySameMode = NumberDacs.UseHotKeySameMode;
        ppdev->PanScanSelection = NumberDacs.PanScanSelection;
        ppdev->ulDFPSupports1400x1050 = NumberDacs.ulDFPSupports1400x1050;

        for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
        {
            ppdev->ulDeviceMask[i] = NumberDacs.ulDeviceMask[i];
            ppdev->ulDeviceDisplay[i] = NumberDacs.ulDeviceDisplay[i];
            ppdev->ulDeviceType[i] = NumberDacs.ulDeviceType[i];
            ppdev->ulTVFormat[i] = NumberDacs.ulTVFormat[i];
            ppdev->ulHeadDeviceOptions[i] = NumberDacs.ulHeadDeviceOptions[i];
            if (ppdev->ulHeadDeviceOptions[i] != 0 && ppdev->ulDeviceType[i] != INVALID_DEVICE_TYPE) 
            {
                ppdev->ulDacStatus[i] |= DAC_STATUS_CONNECTED;
            }
        }
    }

    //
    // Initialize the modelist pointers to NULL
    //
    for (i = 0; i < NV_NO_DACS; i++)
    {
        ppdev->PhysModeList[i] = NULL;
        ppdev->VirtualModeList[i] = NULL;
    }

    //
    // Read the default TVFormat from RM
    //
    GetDefaultTVFormat(ppdev);

    //
    // See if we need to turn on the Sony specific STOP_IMAGE method during modesets.
    //
    ppdev->EnableModesetStopImage = 0;
    GetULONGRegValue(ppdev, "EnableModesetStopImage",&ppdev->EnableModesetStopImage);
    
    if (ppdev->ulNumberDacsConnected != ppdev->ulNumberDacsOnBoard) 
    {
        DISPDBG((1,"ulNumberDacsConnected: %d, different than ulNumberDacsOnBoard: %d",
                ppdev->ulNumberDacsConnected, ppdev->ulNumberDacsOnBoard));
        // ppdev->ulNumberDacsOnBoard = ppdev->ulNumberDacsConnected;
    } 

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ppdev->ulDacStatus[i] |= DAC_STATUS_ON_BOARD;
        ppdev->ulEnablePanScan[i] = 1;
        ppdev->ulFreezePanScan[i] = 0;
        ppdev->ulFreezeOriginX[i] = 0;
        ppdev->ulFreezeOriginY[i] = 0;
        ppdev->ulEnableDDC[i] = 1;
        ppdev->ulTimingOverRide[i] = NVTWINVIEW_STATE_AUTO;
    }

    if (ppdev->ulNumberDacsConnected == 0) 
    {
        DISPDBG((0,"Oops! No head is connected, assuming a default CRT monitor with single head config\n"));
        ppdev->ulNumberDacsConnected = 1;
        ppdev->ulAllDeviceMask = BITMASK_CRT0;
        ppdev->ulConnectedDeviceMask = BITMASK_CRT0;
        ppdev->ulDeviceMask[0] = BITMASK_CRT0;
        ppdev->ulDeviceType[0] = MONITOR_TYPE_VGA;
        ppdev->ulDacStatus[0] |= DAC_STATUS_CONNECTED;
        DISPDBG((1,"Deivetype[%d] is MONITOR_TYPE_VGA",i));
    }

    //
    // Read the TwinViewState from the registry
    //
    ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;
    ppdev->ulNumberDacsActive = 1;
    UseGDIData = 1;
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_TWINVIEW_STATE,
                        NULL,
                        0,
                        &sData,
                        sizeof(NVTWINVIEWDATA),
                        &ReturnedDataLength))
    {
        DISPDBG((3, "InitMultiMon() - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
        
        if(!BuildModeLists(ppdev))
            return(FALSE);
    }
    else
    {
        //
        // Print the registry data the way it was read
        //
        PrintTwinViewData("Registry data as read in InitMultiMon()", 1, &sData, ppdev);

        //
        // Do some sanity tests to make sure we didnt get bogus data from the registry
        //
        if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
            ppdev->TwinView_State = sData.dwState;
        if (TwinViewDataOK(ppdev, &sData))
        {
            ULONG ForceUseGDIData = 0;
            DISPDBG((6, "The registry data is sane\n"));
            

            if (!ValidateRegistryDeviceMasks(ppdev, &sData))
            {
                ForceUseGDIData = 1;
            }
            else
            {
                //
                // The requested device masks are valid. Read it into ppdev before building modelists.  
                //
                InitDevMaskFromTwinViewInfo(ppdev, &sData);
            }

            //
            // Build the virtual/physical modelists for the requested devices.
            //
            if(!BuildModeLists(ppdev))
                return(FALSE);

            if (bQueryBothPanelsAreInSync(ppdev, &sData))
            {
                // Now we can trust and use the Registry data as is.
                DISPDBG((6, "Using the registry data\n"));
                UseGDIData = 0;
            }
            else
            {
                DISPDBG((5, "Both panels are not in sync. So using the GDI data\n"));
            }
            if (ForceUseGDIData)
            {
                DISPDBG((1,"ForceUseGDIData is on. So using the GDI data"));
                UseGDIData = 1;
            }
        } 
        else
        {
            DISPDBG((1, "Ooops! The registry data is not sane\n"));
            if(!BuildModeLists(ppdev))
                return(FALSE);
        }
    } // IOCTL


    if (UseGDIData)
    {
        DISPDBG((3,"Using GDI data for mode details\n"));
        UseOnlyGDIDataForModeDetails(ppdev);
    }
    else
    {
        DISPDBG((3,"Using registry data for mode details\n"));
        UseOnlyRegistryDataForModeDetails(ppdev, &sData);
    }

    DISPDBG((1, "HKPending: 0x%x, ulAssertModeTRUE: 0x%x\n", NumberDacs.ulHotKeyPending,ppdev->ulDrvAssertModeTRUE));

    //
    // If this modeset was initiated by the nvPanel, then the TVFormat specified by the user takes precedence
    // over the default TVFormat.
    //
    if (GetInitiatedRegValue(ppdev) == 1)
    {
        // Now go through the active heads and change the TVFormat if we find any active TV device.
        for (i=0; i < ppdev->ulNumberDacsActive; i++)
        {
            ulHead = ppdev->ulDeviceDisplay[i];
            ulDeviceMask = ppdev->ulDeviceMask[ulHead];
            if (ulDeviceMask & BITMASK_ALL_TV)
            {
                DISPDBG((1, "InitMultiMon(): RMDefaultTVFormat: 0x%x, nvPanelTVFormat: 0x%x, PhysHead: 0x%x\n",
                    ppdev->ulDefaultTVFormat, ppdev->ulTVFormat[ulHead], ulHead));
                DISPDBG((1, "So using the user specified TVFormat instead of the RMDefaultTVFormat\n"));
                ppdev->ulDefaultTVFormat = ppdev->ulTVFormat[ulHead];
                ppdev->ulDefaultTVDeviceType = TVFormatToTVDeviceType(ppdev->ulTVFormat[ulHead]);
                break;
            }
        }
    }

    

    // 
    // Assume we have to obey the BIOS heads
    //
    UseBIOSHeads = 1;

    //
    // Miniport handles the BIOS heads at boot time. So need for the display driver to muck with
    // BIOS heads. We do not want to do this if we were called as a result of the hotkey switch.
    //
    if (NumberDacs.ulHotKeyPending == 1)
    {
        UseBIOSHeads = 0;
        //
        // We need to let the control panel thread know that a HK switch has taken place.
        // This is to handle the case when the control panel is open and the user presses HK
        // and the same desktop is maintained by the OS, then the OS does not send any
        // WM_DISPLAYCHANGE message to the control panel app thus causing some device-type-sensitive
        // pages such as TV adjustment to crash.
        //
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT failed"));
        }   

        //
        // Clear the ulInduceModeChangeDeviceMask so that StopImage will be deactivated if it has been turned on.
        // This handles the pathological case, where for some reason, control panel/NVSVC is not able to
        // do the induced modechange successsfully and the screen stays black since StopImage is activated.
        // Then the user will most likely hit HK to get the laptop back to a usable state.
        // Also, let miniport know too.
        //
        if (ppdev->ulInduceModeChangeDeviceMask != 0)
        {
            DISPDBG((1,"Something wrong. ppdev->ulInduceModeChangeDeviceMask: 0x%x, is being cleared due to HK",
            ppdev->ulInduceModeChangeDeviceMask));
        }
        ppdev->ulInduceModeChangeDeviceMask = 0;
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
        }   

    }

    //
    // if we are called directly by the nvPanel, do not use BIOS heads.
    //
    if (GetInitiatedRegValue(ppdev) == 1)
    {
       UseBIOSHeads = 0;
    }

    //
    // The display driver needs to obey BIOS heads only for two cases - returning from FSDOS and resuming from
    // standby/suspend/hibernate. Fortunately for us, Win2K calls DrvAssertMode(TRUE) while returning from 
    // these conditions. So we will use BIOS heads only if this modeset is a result of DrvAssertMode(TRUE) and not
    // DrvEnableSurface().
    //
    if (ppdev->ulDrvAssertModeTRUE == 0)
    {
       UseBIOSHeads = 0;
    }
    else
    {
        //
        // We are here because of a DrvAssertMode(TRUE). Now check if we are enabling
        // the same pdev that was used while going down into VGA mode last. This handles
        // the special case of when we have multiple pdevs active. We compare the 
        // iUnique numbers of the pdevs to distinguish between the cases of
        // resuming from FSDOS/DPMS and toggling between multiple pdevs.
        //
        DISPDBG((1, "Comparing ppdev->iUniqueness: %d, MiniportiUniqueness: %d",
            ppdev->iUniqueness, NumberDacs.ulUniquenessVGA));
        if (NumberDacs.ulUniquenessVGA != ppdev->iUniqueness)
        {
            DISPDBG((1, "Mismatch of iUniqueness so not calling HandleBiosHeads"));
            UseBIOSHeads = 0;
        }
        else
        {
            //
            // We are returning from FSDOS or resuming from DPMS.
            // Clear the PrevDevMask registry entry to ensure that we do the begin/end modeset bracketing.
            //
            SetPrevDevMaskRegValue(ppdev, 0);
        }
    }

    //
    // if we are in spanning mode, we do not obey BIOS heads
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
       //
       // Exception. If one or both of the devices is disconnected, 
       // then we do obey BOOT_DEVICES in spanning mode on laptops.
       //
       if (ppdev->ACPISystem)
       {
            ulCombinedDeviceMask = 0;
            for (i=0; i < ppdev->ulNumberDacsActive; i++)
            {
                ulHead = ppdev->ulDeviceDisplay[i];
                ulCombinedDeviceMask |= ppdev->ulDeviceMask[ulHead];
            }
            ulTmp = ulCombinedDeviceMask;
            if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                               NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulTmp, sizeof(ULONG)))
            {
                DISPDBG((0, "HandleBIOSHeads - Cannot get CHECK_CONNECTED_DEVICES value from RM"));
                UseBIOSHeads = 0;
            }
            else
            {
                if (ulTmp == ulCombinedDeviceMask)
                {
                   //
                   // Both devices are present. So no need to obey BOOT_DEVICES.
                   //
                   UseBIOSHeads = 0;
                }
            }
        }
    }

    //
    // We don't need to obey BOOT_DEVICES on desktops.
    //
    if (ppdev->ACPISystem == 0)
    {
       UseBIOSHeads = 0;
    }

    //
    // use the BIOS heads only if asked to do so in the registry (for laptops).
    //
    if (ppdev->UseHWSelectedDevice == 0)
    {
       UseBIOSHeads = 0;
    }

    

    //
    // Check the registry to see if this is not the extra DrvAssertMode(TRUE) that the OS calls 
    // while resuming from hibernation. Ugh.. I hate state machines but I could not think of any other
    // way to detect this condition. Note that all these calls act on the same pdev.
    // The situation I was running into a problem on the laptop was as follows:
    //
    // - set clone(DFP+CRT).
    // - hibernate
    // - resume
    // - DrvAssertMode(TRUE):   BOOT_DEVICES correctly indicates DFP+CRT: First call
    // - DrvAssertMode(FALSE):  Display and RM think that we are going into FSDOS
    // - DrvAssertMode(TRUE):   BOOT_DEVICES indicates CRT: We need to identify this extra DrvAssertModeTRUE call
    //                          and not obey the BOOT_DEVICES: Second call.
    //
    // All this jugglery because there is no way for the display driver to uniquely identify when we are really going 
    // down into VDM FSDOS via ALT+ENTER or via an App request. Sigh...
    // Note: '5' corresponds to the VideoPowerHibernateState defined in ddk\src\video\inc\ntddvdeo.h
    // Since I can not include ntddvdeo.h in the display driver, I use the numeral value.
    //
    if (ppdev->ulDrvAssertModeTRUE == 1 && NumberDacs.ulUniquenessVGA == ppdev->iUniqueness)
    {
        #define IGNORE_NEXT_ASSERTMODE 0x1234
        //
        // Read the registry value to see what the power down state was when we went down before resuming.
        //
        PowerStateRegValue = GetPowerStateRegValue(ppdev);

        //
        // See if it is the first call.
        //
        if (PowerStateRegValue == 5)
        {
            //
            // we set the registry to indicate that on the next DrvAssertMode(TRUE) we do not obey the BOOT_DEVICES.
            //
            SetPowerStateRegValue(ppdev, IGNORE_NEXT_ASSERTMODE);
        }

        //
        // See if it is the second call.
        //
        if (PowerStateRegValue == IGNORE_NEXT_ASSERTMODE)
        {
            //
            // we do not read the BOOT_DEVICES for this second extra call.
            // Also, set the registry value back to 0.
            //
            if (ppdev->ulDrvAssertModeTRUE == 1)
            {
                UseBIOSHeads = 0;
                SetPowerStateRegValue(ppdev, 0);
            }
        }
    }
    

    //
    // Now call handleBIOSHEads() if we need to.
    //
    if (UseBIOSHeads)
    {
        ulRet = HandleBIOSHeads(ppdev);
        if (ulRet == FALSE)
        {
            //
            // Since the devices were changed in HandleBIOSHeads(), we need to reconstruct the modelists
            // and make sure we are using valid physical modes.
            // Handle only the standard/clone mode case (just a redundant safety check since we should never be
            // here if we were in spanning mode).
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                if(!BuildModeLists(ppdev))
                    return(FALSE);
                UseOnlyGDIDataForModeDetails(ppdev);
            }
        }
    }
    else 
    {
        DISPDBG((1,"Not called HandleBIOSHEads\n"));
        //
        // Print the BOOT_DEVICES just for debugging purposes
        //
        if (Status = NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                  NV_CFG_GET_BOOT_DEVICES, &ulBIOSDeviceMask))
        {
            DISPDBG((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed"));
        }
        DISPDBG((1,"Disp: Informational only: HandleBIOSHeads(): BIOSDeviceMask: 0x%x",ulBIOSDeviceMask));
    }

    //
    // Now turn off the DrvAssertMode flag since we have used it already.
    //
    ppdev->ulDrvAssertModeTRUE = 0;
    
    switch (ppdev->TwinView_State)
    {
        case NVTWINVIEW_STATE_SPAN:
            if (MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen))
            {
                ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;
                ppdev->ulNumberDacsActive = 2;
            }
            else
            {
                ppdev->ulDesktopMode = 0;
                ppdev->ulNumberDacsActive = 1;
            }
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_SPAN"));
            break;
        case NVTWINVIEW_STATE_CLONE:
            ppdev->ulDesktopMode = NV_CLONE_DESKTOP | NV_TWO_DACS;
            ppdev->ulNumberDacsActive = 2;
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_CLONE"));
            break;
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ppdev->ulNumberDacsActive = 1;
            ppdev->ulDesktopMode = 0;
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_NORMAL/NVTWINVIEW_STATE_DUALVIEW"));
            break;
        default:
            ppdev->ulDesktopMode = 0;
            ppdev->ulNumberDacsActive = 1;
            DISPDBG((0,"oops!! Invalid TwinView State: %d\n",ppdev->TwinView_State));
            break;
    }

    // Control panel To Do
    // should set up these value to move screen for panning and scanning
    
    // HW restriction: Set image offset value is a multiple of 4 bytes.  
    // Since move mouse pointer rountine does not deal with 8bpp, 16bpp or 32bpp,
    // set to 4 pixel increment in order to satisfy HW restriction.
    ppdev->ulMoveDisplayDx = 4; 
    ppdev->ulMoveDisplayDy = 4;

    //
    // Convert the device masks to device type
    //
    for (i = 0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        //
        // Convert the device mask to device type. 
        //
        ulHead = ppdev->ulDeviceDisplay[i];
        ulDeviceType = MaskToDeviceType(ppdev, ppdev->ulDeviceMask[ulHead]);
        ppdev->ulDeviceType[ulHead] = ulDeviceType;
        ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat;
    }

    //
    // Make sure the head mapping array is 0,1 or 1,0 for standard mode.
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
    {
        ulHead = ppdev->ulDeviceDisplay[0];
        if (ulHead == 1)
        {
            ppdev->ulDeviceDisplay[1] = 0;
        }
        if (ulHead == 0)
        {
            ppdev->ulDeviceDisplay[1] = 1;
        }
    }

    //
    // Handle the BANDWIDTH limitations of some hardware.
    // For eg. on Toshiba, the NV hardware and the SXGA+ EDID can handle 1400x1050x100HZ.
    // But the system does not allow for scanout bandwidth for this mode while in clone mode.
    // We make this test as a generic test.
    //
    if (ppdev->ulNumberDacsActive == 1)
    {
        HandleBandWidth_SingleDacActive(ppdev);
    }
    if (ppdev->ulNumberDacsActive == 2)
    {
        HandleBandWidth_DualDacsActive(ppdev);
    }
    


    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        ulDisplayHeight = ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        if((ulDisplayWidth < (ULONG)(ppdev->rclDisplayDesktop[ulHead].right - ppdev->rclDisplayDesktop[ulHead].left)) ||
           (ulDisplayHeight < (ULONG)(ppdev->rclDisplayDesktop[ulHead].bottom - ppdev->rclDisplayDesktop[ulHead].top)) )
        {
            ppdev->ulDesktopMode |= (i ? NV_VIRTUAL_DESKTOP_2 : NV_VIRTUAL_DESKTOP_1); 
        }
    }

    ppdev->ulFlipBase = 0;          // Re-initialized back to 0 base after a mode switch


    // Initialize the Cached Cursor data for each mode set
    ppdev->ulCachedCursorWidth = 0;
    ppdev->ulCachedCursorFormat = 0;


    //
    // Now print the info recorded into the ppdev
    //
    PrintPPDEVTwinViewInfo("Printing PPDEV info after finishing InitMultiMon()", ppdev);

    //
    // Now write the current selection from the ppdev back into the twinviewinfo registry structure.
    //
    WriteRegistryTwinViewInfo (ppdev, NULL);

    //
    // Read the current SaveSettings table into ppdev
    //
    vReadSaveSettings(ppdev);

    //
    // Update the registry SaveSettings table with the just concluded modeset.
    //
    vWriteSaveSettings(ppdev);

    //
    // Print the just written SaveSettings table for debugging purposes
    //
    vPrintSaveSettings(ppdev, 2);

    return(TRUE);
}

//
// Returns TRUE if the given head supports the "RequestedMode". "BestFitMode" is not modified.
// Returns FALSE if the given head and does not support the requested mode and returns a best fit mode supported by the device
// which is the nearest match this device actually supports.
// BUGBUG: For now we hardcode a max mode of 1024x768x32ppx60HZ for a DFP and 800x600x32bppx60HZ for TV.
// We assume the CRT can do all modes for now.
//
BOOLEAN bQuerySupportPhysicalMode(PPDEV ppdev, ULONG head, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode)
{
    BOOLEAN bRet = TRUE;
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG ulDeviceType;
    ULONG ulPrimaryHead, ulPrimaryDeviceMask;

    if (ulDeviceMask & BITMASK_ALL_CRT)
    {
        ulDeviceType = MONITOR_TYPE_VGA;
    }
    if (ulDeviceMask & BITMASK_ALL_DFP)
    {
        ulDeviceType = MONITOR_TYPE_FLAT_PANEL;
    }
    if (ulDeviceMask & BITMASK_ALL_TV)
    {
        ulDeviceType = ppdev->ulDefaultTVDeviceType;
    }

    // We will set the BestFitMode to be equal to the Requested mode and then change any fields if need be.
    *BestFitMode = *RequestedMode;

    ulPrimaryHead = ppdev->ulDeviceDisplay[0];
    ulPrimaryDeviceMask = ppdev->ulDeviceMask[ulPrimaryHead];

#if _WIN32_WINNT >= 0x500
    //
    // Since we don't expose TV EDID to GDI, GDI has no idea of existence of TV.  Prune TV anyway.
    //
    if (ulDeviceType != ppdev->ulDefaultTVDeviceType)
    {
        //
        // See whether the display driver or the GDI should do the mode pruning for this head.
        //
        if (bQueryGDIModePruning(ppdev->TwinView_State, ulPrimaryHead, ulPrimaryDeviceMask, 
                head,  ulDeviceMask, ppdev->ACPISystem, ppdev->GDIModePruning))
        {
            //
            // We let GDI do the mode pruning for the EDID
            //
            return(TRUE);
        }
    }
#endif


    switch (ulDeviceType)
    {
        case MONITOR_TYPE_VGA:
        case MONITOR_TYPE_FLAT_PANEL:
            PhysModePtr = ppdev->PhysModeList[head];
            for (i=0; i < ppdev->ulNumPhysModes[head]; i++)
            {
                if (PhysModePtr->ValidMode && 
                    PhysModePtr->Width == RequestedMode->Width &&
                    PhysModePtr->Height == RequestedMode->Height &&
                    PhysModePtr->Depth == RequestedMode->Depth &&
                    PhysModePtr->RefreshRate == RequestedMode->RefreshRate)
                {
                    // Found a match.
                    bRet = TRUE;
                    return(bRet);
                }
                PhysModePtr++;
            }
            // Did not find a match.
            // So backoff to find the next best mode.
            vBackOffMode(ppdev, head, ulDeviceMask, RequestedMode, BestFitMode);
            
            bRet = FALSE;
            break;
        case MONITOR_TYPE_NTSC:
        case MONITOR_TYPE_PAL:
            {
                NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
                ULONG ReturnedDataLength;
                DWORD ulRet=0;
                

                // The IOCTL assumes head0.
                ulRet = EngDeviceIoControl(ppdev->hDriver,
                                    IOCTL_VIDEO_GET_TV_ENCODER_TYPE,
                                    NULL,
                                    0,
                                    &TVInfo,
                                    sizeof(TVInfo),
                                    &ReturnedDataLength);
                DISPDBG((2, "TVEncoderType: 0x%x, ID=0x%x, Connected=0x%x",TVInfo.EncoderType, TVInfo.EncoderID, TVInfo.TVConnected));
                if (ulRet)
                {
                    DISPDBG((0, "InitMultiMon() - IOCTL_VIDEO_GET_TV_ENCODER_TYPE failed, returned %d",ulRet));
                    // Set safe default values.
                    BestFitMode->Width  = 800;
                    BestFitMode->Height = 600;
                    bRet = FALSE;
                }
                // Conexant871 == Brooktree871
                else if ( (TVInfo.EncoderType == NV_ENCODER_BROOKTREE_871) && (RequestedMode->Width >= 1024 || RequestedMode->Height >= 768)) 
                {
                    BestFitMode->Width = 1024;
                    BestFitMode->Height = 768;
                    bRet = FALSE;
                }
                else if (RequestedMode->Width > 800 || RequestedMode->Height > 600)
                {
                    BestFitMode->Width  = 800;
                    BestFitMode->Height = 600;
                    bRet = FALSE;
                }
                if (RequestedMode->RefreshRate != 60)
                {
                    BestFitMode->RefreshRate = 60;
                    bRet = FALSE;
                }
                break;
            }

            
        default:
            DISPDBG((1,"bQuerySupportPhysicalMode(): Invalid devicetype: 0x%x\n",ppdev->ulDeviceType[head]));
            BestFitMode->Width = 1024;
            BestFitMode->Height = 768;
            BestFitMode->RefreshRate = 60;
            bRet = FALSE;
            break;
    } //switch


    return(bRet);
}

//
// Finds the nearest match for the requestedMode by backing off in the order - refresh rate, height, width.
// Note: Can be called for any output device type.
//
VOID vBackOffMode(PPDEV ppdev, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    DAC_TIMING_VALUES sTimingDac;
    HEAD_RESOLUTION_INFO HeadResolution;
    DWORD ReturnedDataLength;

    // Assume a true match. Then we back off the appropriate attribute.
    BestFitMode->Width = RequestedMode->Width;
    BestFitMode->Height = RequestedMode->Height;
    BestFitMode->Depth = RequestedMode->Depth;
    BestFitMode->RefreshRate = RequestedMode->RefreshRate;

    PhysModePtr = ppdev->PhysModeList[ulHead];
    // sanity check. First see if the mode actually find a true match.
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width == RequestedMode->Width &&
            PhysModePtr->Height == RequestedMode->Height &&
            PhysModePtr->Depth == RequestedMode->Depth &&
            PhysModePtr->RefreshRate == RequestedMode->RefreshRate)
        {
            // Found a match.
            return;
        }
        PhysModePtr++;
    }
    
    //
    // Did not find a match. Let the common modeset code FindModeEntry() do the back off for us.
    // Fill up the head resolution info structure used for the common modeset code.
    //
    HeadResolution.ulDisplayWidth = RequestedMode->Width;
    HeadResolution.ulDisplayHeight= RequestedMode->Height;      
    HeadResolution.ulDisplayRefresh = RequestedMode->RefreshRate;   
    
    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ulDeviceMask;        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulDisplayPixelDepth = RequestedMode->Depth;
    HeadResolution.ulOption = 0;
    

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           &HeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "nvMultiMon.c - IOCTL_VIDEO_GET_TIMING_DAC failed"));
        BestFitMode->Width = 800;
        BestFitMode->Height = 600;
        BestFitMode->Depth = RequestedMode->Depth;
        BestFitMode->RefreshRate = 60;
        return;
    }

    

    // Use the returned mode as the supported physical mode.
    // BUGBUG: FindModeEntry() could have tweaked either the refresh rate or width or height.
    // Not sure what tweak the user would prefer. So for now, I take whatever FindModeEntry() gives.
    // Fortunately it does not tweak the depth!
    BestFitMode->Width = (USHORT)sTimingDac.HorizontalVisible;
    BestFitMode->Height = (USHORT)sTimingDac.VerticalVisible;
    BestFitMode->Depth = RequestedMode->Depth;
    BestFitMode->RefreshRate = (USHORT)sTimingDac.Refresh;
    return;
}


//
// Frees up any memory alloced by the driver for multimon purposes.
// Should be called from DrvDisablePdev().
//
void FreeMemoryMultiMon(PDEV *ppdev)
{
    ULONG   i;

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        if (ppdev->PhysModeList[i] != NULL)
        {
            EngFreeMem(ppdev->PhysModeList[i]);
            ppdev->PhysModeList[i] = NULL;
        }
        if (ppdev->VirtualModeList[i] != NULL)
        {
            EngFreeMem(ppdev->VirtualModeList[i]);
            ppdev->VirtualModeList[i] = NULL;
        }
    }
}

//
// Returns true if the twinviewData is safe. Otherwise returns FALSE>
//
BOOLEAN TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    BOOLEAN bRet = TRUE;
    if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 && 
        pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)
    {
        DISPDBG((1,"DeskTopRectl is all zeroed out\n"));
        bRet = FALSE;
    }

    if (pData->dwState != NVTWINVIEW_STATE_SPAN && pData->dwState != NVTWINVIEW_STATE_CLONE &&
        pData->dwState != NVTWINVIEW_STATE_DUALVIEW && pData->dwState != NVTWINVIEW_STATE_NORMAL) 
    {
       DISPDBG((0,"OOps! Invalid State: 0x%x\n", pData->dwState));
       bRet = FALSE;
    }

    if ((pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW)
        && pData->dwDeviceDisplay[0] > 1)
    {
       DISPDBG((0,"Oops! Invalid Head Mapping.  dwDviceDisplay[0]: 0x%x for NORMAL state\n", pData->dwDeviceDisplay[0]));
       bRet = FALSE;
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE)
    {
        if (pData->dwDeviceDisplay[0] > 1 || 
            pData->dwDeviceDisplay[1] > 1 ||
            (pData->dwDeviceDisplay[0] == 0 && pData->dwDeviceDisplay[1] == 0) ||
            (pData->dwDeviceDisplay[0] == 1 && pData->dwDeviceDisplay[1] == 1))
        {
           DISPDBG((0,"OOps! Invalid Head Mapping.  dwDeviceDisplay: 0x%x, 0x%x for MULTIMON state\n", 
            pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1]));
            DISPDBG((0, "Patching the Head Mappings to 0 and 1 respectively\n"));
            // rather than return false, let me try to patch this error.
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE) 
    {
        if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp != pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp)
        {
            DISPDBG((0,"OOps! bit depths differ for head0: %d and head1: %d \n",
                pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp,pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp));
            bRet = FALSE;
        }
    }


    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp == 0)
    {
       DISPDBG((0,"OOps! bit depths are Zero for both head0 and head1: %d, %d\n",
            pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp,pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp));
        bRet = FALSE;
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwRefresh == 0)
    {
        DISPDBG((0,"OOps! ulRefreshRate is all zeroed out for both heads\n"));
        bRet = FALSE;
    }
    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.bottom == 0)
    {
        DISPDBG((0,"OOps! VirtualRectl is all zeroed out for both heads\n"));
        bRet = FALSE;
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.bottom == 0)
    {
        DISPDBG((0,"OOps! PhysicalRectl is all zeroed out for both heads\n"));
        bRet = FALSE;
    }

    // If there is just one head on the board and the registry says any mode other than normal, mark it as invalid.
    if (ppdev)
    {

        if (ppdev->ulNumberDacsOnBoard == 1 &&
            (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE))
        {
            DISPDBG((0,"OOps! Registry state is invalid for the number of heads on the board or for the number of connected heads\n"));
            bRet = FALSE;
        }
    }

    return(bRet);
}



//
// Handle the case when the user makes some selection through nvPanel causing the rgistry entry "TwinViewInfo" 
// to be written and then uses the NT panel (or programmatically through an app) 
// to make mode changes (refresh rate, color depth, resolution, choosing a
// spanning mode resolution). So we need to sync the NT and nvPanel now.
// This function does not modify the 'pdm' or the 'pdev'. It Returns TRUE if the NTPanel selections and the
// nvPanel's selections are identical else returns FALSE.
//
BOOLEAN bQueryBothPanelsAreInSync(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG NumberDacsOnBoard;
    ULONG i;
    ULONG NTWidth, NTHeight, nvWidth, nvHeight; // Width, height of the NT panel selections and nvPanel selections.
    ULONG ulHeadPrimary, ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;

    DISPDBG((5,"Enter bQueryBothPanelsAreInSync()\n"));
    ulHeadPrimary = pData->dwDeviceDisplay[0];

    // Now see if the registry data needs to be synced.
    // If the color depth, primary refresh rate, width and height are the same as in the registry, then the registry data
    // is already in sync and we don't need to do anything.
    if ((ULONG)ppdev->cBitsPerPel == pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwBpp &&
        (ULONG)ppdev->ulGDIRefreshRate == pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh &&
        ppdev->cxScreen == (pData->DeskTopRectl.right - pData->DeskTopRectl.left) &&
        ppdev->cyScreen == (pData->DeskTopRectl.bottom - pData->DeskTopRectl.top))
    {
        DISPDBG((5,"The registry data and the GDI data are in sync.\n"));
        return(TRUE);
    }

    // Pull out theright pieces of info from GDI into the registry structure
    //
    // GDI _solely_ determines the following pieces of info
    // DEsktopRectl, depth for both heads
    // Head0: bpp, Refresh rate, VirtualRect
    // Head1: bpp, VirtualRect
    //
    // GDI _may_ determine the following
    // Head0: physical rect
    // Head1: physical rect
    //
    // Registry _soley_ determines the following pieces of info
    // dwState, dwOrientation
    //
    // Registry _may_ determine the following pieces of info
    // Head0: physical rect
    // head1: physical rect, refresh rate

    // see if the color depth has changed for the primary head.
    if ((ULONG)ppdev->cBitsPerPel != pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwBpp)
    {
        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
        {
            ulHead = pData->dwDeviceDisplay[i];
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwBpp = (ULONG)ppdev->cBitsPerPel;
        }
    }

    // see if the refresh rate has changed for the primary head.
    if ((ULONG)ppdev->ulGDIRefreshRate != pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh)
    {
        pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh = (ULONG)ppdev->ulGDIRefreshRate;
    }

    // See if the resolution has changed. If so, we need to change each head's virtual rectl and also
    // carefully change each head's physical rect.
    if (ppdev->cxScreen != (pData->DeskTopRectl.right - pData->DeskTopRectl.left) ||
        ppdev->cyScreen != (pData->DeskTopRectl.bottom - pData->DeskTopRectl.top))
    {
        //
        // TODO: GK: Do a sanity check of the ulDeviceDisplay in pData. If it is not sane, set the default 0,1 values
        // into the pData
        //
        SET_RECT(&pData->DeskTopRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

        // set up the virtualrect for all the heads corresponding to the state.
        // Check to see if it is horizontal orientation
        if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {
            if (pData->dwState != NVTWINVIEW_STATE_SPAN  || 
                pData->dwOrientation != HORIZONTAL_ORIENTATION)
            {
                DISPDBG((0,"Oops! Invalid state: 0x%x or orientation: 0x%x for requested GDI resolution (%d, %d)\n",
                    pData->dwState,pData->dwState, ppdev->cxScreen, ppdev->cyScreen));
                DISPDBG((0, "Patch it up by setting the correct state and orientation in pdev\n"));
                pData->dwState = NVTWINVIEW_STATE_SPAN;
                pData->dwState = HORIZONTAL_ORIENTATION;
            }

            RequestedMode.Width = (USHORT)ppdev->cxScreen / 2;
            RequestedMode.Height = (USHORT)ppdev->cyScreen;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //

            //
            // TODO: GK: Do a sanity check of the ulDeviceDisplay in pData. If it is not sane, set the default 0,1 values
            // into the pData
            //

            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen / 2, ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            //
            // Fill in the info for secondary device
            //
            ulHead = pData->dwDeviceDisplay[1];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, ppdev->cxScreen / 2, 0, 
                (ppdev->cxScreen / 2) + (ppdev->cxScreen / 2), ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, ppdev->cxScreen / 2, 0,
                    (ppdev->cxScreen / 2) + RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, ppdev->cxScreen / 2, 0,
                    (ppdev->cxScreen / 2) + BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }
        } // HORIZONTAL_MODE

        // check to see if it is vertical orientation
        if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {   
            if (pData->dwState != NVTWINVIEW_STATE_SPAN  || 
                pData->dwOrientation != VERTICAL_ORIENTATION)
            {
                DISPDBG((0,"Oops! Invalid state: 0x%x or orientation: 0x%x for requested GDI resolution (%d, %d)\n",
                    pData->dwState,pData->dwOrientation, ppdev->cxScreen, ppdev->cyScreen));
                DISPDBG((0, "Patch it up by setting the correct state and orientation in pdev\n"));
                pData->dwState = NVTWINVIEW_STATE_SPAN;
                pData->dwOrientation = VERTICAL_ORIENTATION;
            }

            RequestedMode.Width = (USHORT)ppdev->cxScreen;
            RequestedMode.Height =(USHORT) ppdev->cyScreen / 2;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //
            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, 
                ppdev->cxScreen, ppdev->cyScreen / 2);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            //
            // Fill in the info for secondary device
            //
            ulHead = pData->dwDeviceDisplay[1];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, ppdev->cyScreen / 2,
                ppdev->cxScreen, (ppdev->cyScreen / 2) + (ppdev->cyScreen / 2));
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, ppdev->cyScreen / 2,
                    RequestedMode.Width, (ppdev->cyScreen / 2) + RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, ppdev->cyScreen / 2,
                    BestFitMode.Width,(ppdev->cyScreen / 2) + BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }
        } // VERTICAL_MODE

        if (!MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {   
            // Note we could still be in the state of multimon except the user has chosen the 6x4 or 8x6 mode.

            RequestedMode.Width = (USHORT)ppdev->cxScreen;
            RequestedMode.Height = (USHORT)ppdev->cyScreen;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //
            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    BestFitMode.Width,BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            // fill up the second head info also. It will be used in clone mode but ignored in the normal mode.
            if (pData->dwState == NVTWINVIEW_STATE_CLONE && ppdev->ulNumberDacsOnBoard > 1)
            {
                ulHead = pData->dwDeviceDisplay[1];
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
                if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
                {
                    SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                        RequestedMode.Width,RequestedMode.Height);
                    pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
                }
                else
                {
                    SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                        BestFitMode.Width,BestFitMode.Height);
                    pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
                }
            }
        } // single screen resolution
    } // if the GDI resolution is different than registry resolution
    

    return(TRUE);
}


//
// Returns TRUE if the RequestedDeviceType (and the requested TV type in the case of TV) is actually present and
// connected on the 'Head'. If not, returns FALSE and returns a safe valid device type in the *SuggestedDeviceType field.
//
BOOLEAN bConfirmDeviceType(PPDEV ppdev, ULONG Head, ULONG RequestedDeviceMask, ULONG RequestedDeviceType, ULONG RequestedTVType,
                           ULONG * SuggestedDeviceMask, ULONG * SuggestedDeviceType, ULONG * SuggestedTVType)
{
    BOOLEAN bRet = FALSE;
    BOOLEAN bFoundSuggested = FALSE;

    // We ignore the ulDeviceType arguement here.
    if (ppdev->ulConnectedDeviceMask & RequestedDeviceMask)
    {
        return(TRUE);
    }
    else
    {
        *SuggestedDeviceMask = ppdev->ulDeviceMask[Head];
        *SuggestedTVType = ppdev->ulTVFormat[Head];
        return(FALSE);
    }

} // End function bConfirmDeviceType()

//
// This functions returns the physical modelist and virtual modelist for each head.
// Returns TRUE if successful else reurns FALSE.
// if the ModeList pointer is NULL, then only the number of modes is returned, else the actual modelist is returned 
// for the passed in NumModes.
//
BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes)
{
    MODE_ENTRY * SrcPtr;
    ULONG DoSanityCheck = 1;
    ULONG j;
    BOOLEAN bRet = TRUE;
    ULONG ulTmp, ulRet, ulRetSize;
    
    // For the requested devicetype, get the number of virtual modes and fillup the virtual modelist pointer if asked for.
    if (NumVirtModes != NULL)
    {
        *NumVirtModes = ppdev->ulNumVirtualModes[Head];
        //
        // Fill up the virtual modelist.
        // This is device type independent.
        //
        if (VirtModeList != NULL)
        {
            SrcPtr = ppdev->VirtualModeList[Head];
            for (j=0; j < ppdev->ulNumVirtualModes[Head]; j++)
            {
                *VirtModeList = *SrcPtr;
                VirtModeList++;
                SrcPtr++;
            }
        }
    } // NumVirtModes != NULL

    //
    // Fill up the Physical modelist.
    // This is device type dependent.
    // We start off with the virtual modelist and eliminate those modes not supported by this device. Eventually we will do
    // EDID filtering in this chunk of code.
    //
    if (NumPhysModes != NULL)
    {
        HEAD_MODE_LIST_INFO InputInfo;
        

        InputInfo.ulHead = Head;
        InputInfo.ulDeviceMask = DeviceMask;
        InputInfo.ulDeviceType = DeviceType;
        InputInfo.ulTVType = TVFormat;
        InputInfo.ulEnableDDC = ppdev->ulEnableDDC[Head];
        InputInfo.ulEnableDDC = 1; // Hardcoded for now till control panel adds a button for this.

        InputInfo.pVirtualModeList = ppdev->VirtualModeList[Head];
        InputInfo.ulNumVirtualModes = ppdev->ulNumVirtualModes[Head];
        InputInfo.pPhysicalModeList = PhysModeList;

        // Call the IOCTL for the miniport to return the physical modes.
        ulRet = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST,
                                   (HEAD_MODE_LIST_INFO *)&InputInfo,
                                   sizeof(HEAD_MODE_LIST_INFO),
                                   NULL,
                                   0,
                                   &(ulRetSize));
        if (ulRet)
        {
            DISPDBG((0,"Oops! IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST failed!"));
            return(FALSE);
        }
        else
        {
            // Copy the number physical modes into ppdev. The modelist has already been copied into 
            // by the miniport.
            *NumPhysModes = ulRetSize / sizeof(MODE_ENTRY);
            if (*NumPhysModes == 0)
            {
                DISPDBG((0,"Number of physical modes for head: %d is 0",Head));
                return(FALSE);
            }
            return(TRUE);
        }

    } // NumPhysModes != NULL

    return(bRet);
} // end bGetPhysicalVirtualModeList()


//
// Prints the relevant pieces of TwinView related info from the ppdev
//
void PrintPPDEVTwinViewInfo (char *Msg, PPDEV ppdev)
{
    ULONG i;

    DISPDBG((1,".......%s......",Msg));
    DISPDBG((1,"DeskTopMode: 0x%x, NotSupportPanScan: 0x%x, PuntCursor: 0x%x, DacsOnBoard: 0x%x, DacsConnected: 0x%x, DacsActive: 0x%x",
        ppdev->ulDesktopMode, ppdev->ulDriverNotSupportPanScan, ppdev->ulPuntCursorToGDI, ppdev->ulNumberDacsOnBoard,
        ppdev->ulNumberDacsConnected,ppdev->ulNumberDacsActive));
    DISPDBG((1,"TwinViewState: 0x%x, Orientation: 0x%x, DisplayDX: 0x%x, DisplayDy: 0x%x, PrimarySurfOffset: 0x%x",
        ppdev->TwinView_State, ppdev->TwinView_Orientation, ppdev->ulMoveDisplayDx, ppdev->ulMoveDisplayDy,
        ppdev->ulPrimarySurfaceOffset));
    DISPDBG((1,"GDI Requested mode: (%d, %d) at %d bpp, at %d HZ",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cBitsPerPel, ppdev->ulGDIRefreshRate));
    DISPDBG((1,"Head Mapping: %d, %d",ppdev->ulDeviceDisplay[0], ppdev->ulDeviceDisplay[1]));
    DISPDBG((1,"HeadDeviceOptions: 0x%x, 0x%x",ppdev->ulHeadDeviceOptions[0], ppdev->ulHeadDeviceOptions[1]));
    DISPDBG((1,"AllDeviceMask: 0x%x\n",ppdev->ulAllDeviceMask));
    DISPDBG((1,"ConnectedDeviceMask: 0x%x\n",ppdev->ulConnectedDeviceMask));

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        DISPDBG((1,"Head %d: DacStatus: 0x%x, NumPhysModes: 0x%x, NumVirtualModes: 0x%x, DeviceMask: 0x%x, DeviceType: 0x%x, TVFormat: 0x%x",
            i, ppdev->ulDacStatus[i], ppdev->ulNumPhysModes[i], ppdev->ulNumVirtualModes[i], ppdev->ulDeviceMask[i], ppdev->ulDeviceType[i],
            ppdev->ulTVFormat[i]));
        DISPDBG((1, "Virtual: (%d, %d), (%d, %d), Physical: (%d, %d), (%d, %d) at %d HZ",
            ppdev->rclDisplayDesktop[i].left, ppdev->rclDisplayDesktop[i].top,
            ppdev->rclDisplayDesktop[i].right,ppdev->rclDisplayDesktop[i].bottom,    
            ppdev->rclCurrentDisplay[i].left, ppdev->rclCurrentDisplay[i].top,
            ppdev->rclCurrentDisplay[i].right,ppdev->rclCurrentDisplay[i].bottom,    
            ppdev->ulRefreshRate[i]));

    }
    DISPDBG((1,"................................."));
}

//
// Prints the entire twinviewdata structure
//
void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev)
{
    ULONG i;

    DISPDBG((ulDebugLevel,"..........%s...........", Msg));
    DISPDBG((ulDebugLevel,"State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d",
        pData->dwState, pData->dwOrientation, pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right,
        pData->DeskTopRectl.bottom, pData->dwAllDeviceMask, pData->dwConnectedDeviceMask, pData->dwDeviceDisplay[0],pData->dwDeviceDisplay[1]));
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        DISPDBG((ulDebugLevel,"Head %d:    DeviceMask: 0x%x, DeviceType: 0x%x, TVFormat: 0x%x, NumPhysModes: 0x%x, NumVirtualModes: 0x%x",
            i, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceMask, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceType, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwTVFormat, 
            pData->NVTWINVIEWUNION.nvtwdevdata[i].dwNumPhysModes,pData->NVTWINVIEWUNION.nvtwdevdata[i].dwNumVirtualModes));
        DISPDBG((ulDebugLevel,"        Virtual: (%d, %d), (%d, %d), Physical: (%d, %d), (%d, %d)",
            pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.left,pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.top,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.right,pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.bottom,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.left,pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.top,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.right,pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.bottom));
        DISPDBG((ulDebugLevel,"        %d bpp, %d HZ",
            pData->NVTWINVIEWUNION.nvtwdevdata[i].dwBpp, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwRefresh));
    }
    DISPDBG((ulDebugLevel,"........................"));
}

//
// Calls the miniport to do a device scaning.
// Then gets __only__ the updated device options matrix and stuffs it into the panel. 
// BUGBUG: Should I extract all the info? Think about it and talk to Terry. What happens if say the seconda\ry DFP
// is disconnected before inducing the scan? The mode has already been set.
//
void InduceAndUpdateDeviceScanning (PPDEV ppdev)
{
    ULONG  ReturnedDataLength;
    ULONG  i;
    GET_NUMBER_DACS   NumberDacs;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! DrvEnablePDEV - IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING failed"));
        return;
    }

    // Get the head info from the miniport such as number of heads on board, number of heads connected and device type of each head.
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_NUMBER_DACS,
                        NULL,
                        0,
                        &NumberDacs,
                        sizeof(NumberDacs),
                        &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! InitMultiMon() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
        return;
    }
    else
    {
        // Fill the info into ppdev.
        // BUGBUG: Should I extract all the info? Think about it and talk to Terry. What happens if say the seconda\ry DFP
        // is disconnected before inducing the scan? The mode has already been set.
        ppdev->ulNumberDacsConnected = NumberDacs.ulNumberDacsConnected;
        ppdev->ulNumberDacsOnBoard = NumberDacs.ulNumberDacsOnBoard;
        ppdev->ulAllDeviceMask = NumberDacs.ulAllDeviceMask;
        ppdev->ulConnectedDeviceMask = NumberDacs.ulConnectedDeviceMask;
        DISPDBG((1,"NumDacsOnBoard: 0x%x, NumDacsConnected: 0x%x",ppdev->ulNumberDacsOnBoard,
                 ppdev->ulNumberDacsConnected));
        DISPDBG((1,"ulAllDeviceMask: 0x%x, ulConnectedDeviceMask: 0x%x",ppdev->ulAllDeviceMask,
                 ppdev->ulConnectedDeviceMask));
        for (i=0; i < NumberDacs.ulNumberDacsOnBoard; i++)
        {
            ppdev->ulHeadDeviceOptions[i] = NumberDacs.ulHeadDeviceOptions[i];
            DISPDBG((1,"Physical Head: %d, DeviceOptions: 0x%x",i,ppdev->ulHeadDeviceOptions[i]));
        }
    }

}

//
// Some of the flags in the TwinViewInfo structure are synchronous. i.e., they are read into the incore ppdev
// immediately rather than being read in at the modeset time. These synchronous flags are:
// - ulEnablePanScan
// - ulFreezePanScan
// - ulEnableDDC
//
void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    NVTWINVIEW_DEVICE_TYPE_DATA HeadData;
    ULONG PhysWidth, PhysHeight;
    ULONG ReturnedDataLength;

    for (i=0; i< NV_NO_DACS; i++)
    {
        HeadData = pData->NVTWINVIEWUNION.nvtwdevdata[i];
        ppdev->ulEnablePanScan[i] = HeadData.dwEnablePanScan;
        ppdev->ulEnableDDC[i] = HeadData.dwEnableDDC;
        ppdev->ulEnableDDC[i] = 1; // Hardcoded for now till control panel adds a button for this.
        ppdev->ulFreezePanScan[i] = HeadData.dwFreezePanScan;
        ppdev->ulTimingOverRide[i] = HeadData.dwTimingOverRide;

        if (HeadData.dwFreezePanScan == 0)   
        {
            DISPDBG((3, "Enabling PanScan for Head: %d",i));
            if (i == 0)
            {
                ppdev->ulDesktopMode |= NV_VIRTUAL_DESKTOP_1;
            }
            else
            {
                ppdev->ulDesktopMode |= NV_VIRTUAL_DESKTOP_2;
            }
    
        } 
        else if( ppdev->ulDesktopMode & (i ? NV_VIRTUAL_DESKTOP_2 : NV_VIRTUAL_DESKTOP_1))
        {
            DISPDBG((3, "Disabling PanScan for Head: %d",i));

            //
            // Write the desired freeze location into ppdev.
            //
            ppdev->ulFreezeOriginX[i] = HeadData.dwFreezeOriginX;
            ppdev->ulFreezeOriginY[i] = HeadData.dwFreezeOriginY;
            //
            // Update the physical rectangle.
            //
            PhysWidth = ppdev->rclCurrentDisplay[i].right - ppdev->rclCurrentDisplay[i].left;
            PhysHeight = ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top;
            ppdev->rclCurrentDisplay[i].left = HeadData.dwFreezeOriginX;
            ppdev->rclCurrentDisplay[i].top = HeadData.dwFreezeOriginY;
            ppdev->rclCurrentDisplay[i].right = ppdev->rclCurrentDisplay[i].left + PhysWidth;
            ppdev->rclCurrentDisplay[i].bottom = ppdev->rclCurrentDisplay[i].top + PhysHeight;
            //
            // Move the pointer (and the scanout area) to the desired origin if we are not in software cursor mode.
            //
            if (ppdev->ulDriverNotSupportPanScan == FALSE)
            {
                NVMovePointer(ppdev, HeadData.dwFreezeOriginX, HeadData.dwFreezeOriginY);
            }
            //
            // Now turn off the virtual desktop flags to disable pan-scan in the pointer routines.
            //
            if (i == 0)
            {
                ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_1);
            }
            else
            {
                ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_2);
            }
        }
    } // for each dac

    // Get the timing override to take effect immediately.
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! DrvEnablePDEV - IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE failed"));
        return;
    }

}


//
// Does a one time building of mode lists. Should be called only from InitMultiMon().
//
BOOL BuildModeLists(PPDEV ppdev)
{
    PVIDEO_MODE_INFORMATION pVideoModeInformation, SrcPtr;
    DWORD                   cbModeSize;
    ULONG cModes;
    ULONG i, j;
    MODE_ENTRY *ModeListPtr;
    ULONG ReturnedDataLength;
    ULONG ulHead;
    DWORD cNumGDIModes;
    
   
    // Now construc the per-head virtual and physical mode lists.
    // The modes returned by getAvailableModes() will have all of the single,horizontal and vertical modes.
    cModes = getAvailableModes(ppdev->hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize, &cNumGDIModes);

    if (cModes == 0 || cNumGDIModes == 0)
    {
        // Something wrong. There were no valid modes.
        DISPDBG((0, "BuildModeLists(): error. Invalid cModes: %d, cNumGDIModes: %d",cModes, cNumGDIModes));
        // free up any previously alloced memory. This can happen if BuildModeLists() is called twice in a row.
        FreeMemoryMultiMon(ppdev);
        return(FALSE);
    }
    

    // free up any previously alloced memory. This can happen if BuildModeLists() is called twice in a row.
    FreeMemoryMultiMon(ppdev);


    //
    // Create the single screen virtual mode lists for both heads
    // Note that we need to create virtual mode lists for _both_ heads since this list is not
    // EDID-specific. However, we need to compute the physical mode list for the active heads only.
    //
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        // Read the virtual single head modes into the VirtualModeList.
        ppdev->VirtualModeList[ulHead] = EngAllocMem(FL_ZERO_MEMORY,
                                   cModes * sizeof(MODE_ENTRY),
                                   ALLOC_TAG);
        if (ppdev->VirtualModeList[ulHead] == NULL)
        {
            DISPDBG((0, "Oops! InitMultiMon(): EngAllocMEm failed!\n"));
            //
            // free up any memory we might have alloced in the loop before this failure.
            //
            FreeMemoryMultiMon(ppdev);
            return(FALSE);
        }

        ppdev->ulNumVirtualModes[ulHead] = 0;
        ModeListPtr = ppdev->VirtualModeList[ulHead];
        SrcPtr = pVideoModeInformation;
        for (j=0; j < cModes; j++) 
        {
            // We select only the single screen virtual modes because thats what the panel wants.
            if (MULTIMON_MODE(SrcPtr->VisScreenWidth, SrcPtr->VisScreenHeight)) 
            {
                SrcPtr++;
                continue;
            }
            ModeListPtr->ValidMode = 1;
            ModeListPtr->Width = (USHORT)SrcPtr->VisScreenWidth;
            ModeListPtr->Height = (USHORT)SrcPtr->VisScreenHeight;
            ModeListPtr->Depth = (USHORT) (SrcPtr->BitsPerPlane * SrcPtr->NumberOfPlanes);
            ModeListPtr->RefreshRate = (USHORT)SrcPtr->Frequency;
            ppdev->ulNumVirtualModes[ulHead]++;
            ModeListPtr++;
            SrcPtr++;
        }
    } // for

    // Create the Physical mode lists for the active heads.
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ppdev->PhysModeList[i] = EngAllocMem(FL_ZERO_MEMORY,
                                   cModes * sizeof(MODE_ENTRY),
                                   ALLOC_TAG);
        if (ppdev->PhysModeList[i] == NULL)
        {
            DISPDBG((0, "Oops! InitMultiMon(): EngAllocMEm failed!\n"));
            //
            // free up any memory we might have alloced in the loop before this failure.
            //
            FreeMemoryMultiMon(ppdev);
            return(FALSE);
        }
        ppdev->ulNumPhysModes[i] = 0;
    }

    for (i=0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        // Get the physical mode info for this head and the current device.
        if (!bGetPhysicalVirtualModeList(ppdev, ulHead, 
                                    ppdev->ulDeviceMask[ulHead],
                                    ppdev->ulDeviceType[ulHead],
                                    ppdev->ulTVFormat[ulHead],
                                    ppdev->PhysModeList[ulHead],
                                    NULL,
                                    &ppdev->ulNumPhysModes[ulHead],
                                    NULL))
        {
            //  Ganesh
            //  This is not an error if the head is the unused head in a standard mode.
            
            if(ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL && ppdev->ulDeviceDisplay[0] != i)
            {
                //  Benign error since nobody will be using this head info.
                //  Do not print any warning message also.

                continue;
            }

            DISPDBG((0,"InitMultiMon(): oops! bGetPhysicalVirtualModeList() failed for head: %d, devMask: 0x%x, devType: 0x%x, TVFormat: 0x%x",
                i, ppdev->ulDeviceMask[i], ppdev->ulDeviceType[i], ppdev->ulTVFormat[i]));

            return(FALSE);
        }
    } // for

    
   // Free the modelist memory alloced by getAvailableModes()
    EngFreeMem(pVideoModeInformation);

    return(TRUE);
}


//
// Does a sanity check of the device masks specified in the registry data. If they are not sane, returns FALSE.
// else returns TRUE. No state is changed.
//
ULONG ValidateRegistryDeviceMasks(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulDevices, ulHead;
    ULONG ulNumDacsActive;
    ULONG ulWidth, ulHeight;

    if (pData->dwAllDeviceMask != ppdev->ulAllDeviceMask)
    {
        DISPDBG((0,"Oops! Mismatch in AllDeviceMask, ppdev: 0x%x, RegData: 0x%x",
                 ppdev->ulAllDeviceMask,pData->dwAllDeviceMask));
        return(FALSE);
    }

    // Initialize the number of active dacs, to keep the compiler happy.
    ulNumDacsActive = 1;

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ulHead = pData->dwDeviceDisplay[0];
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            ulNumDacsActive = 1;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ulNumDacsActive = 2;
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask |
                        pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            break;
        case NVTWINVIEW_STATE_SPAN:
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask |
                        pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            ulWidth = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
            ulHeight = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
            if (MULTIMON_MODE(ulWidth, ulHeight))
            {
                ulNumDacsActive = 2;
            }
            else
            {
                if( ulWidth != 480 && ulHeight != 360 &&
                    ulWidth <= 640 && ulHeight <= 480)
                {
                     //
                     // These are the special single resolution modes allowed in spanning mode
                     // in order to support DDraw, low resolutions.
                     // 
                     ulNumDacsActive = 1;
                }
                else
                {
                // Also export low resolution for spanning mode for DirectDraw
                    if ((ulWidth == 640 && ulHeight == 480) ||
                        (ulWidth == 800 && ulHeight == 600) ||
                        (ulWidth == 1024 && ulHeight == 768))
                    {
                        //
                        // These are the special single resolution modes allowed in spanning mode.
                        //
                        ulNumDacsActive = 1;
                    }
                    else
                    {
                        DISPDBG((0, "Invalid resolution specified in the registry for spanning mode: %d, %d", ulWidth, ulHeight));
                        return(FALSE);
                    }
                }
            }
            break;
        default:
            DISPDBG((0, "Invalid State in pData\n"));
            return(FALSE);
    }

    if (pData->dwConnectedDeviceMask != ppdev->ulConnectedDeviceMask)
    {
        DISPDBG((0,"Oops! Mismatch in ConnectedDeviceMask, ppdev: 0x%x, RegData: 0x%x",
                 ppdev->ulConnectedDeviceMask,pData->dwConnectedDeviceMask));
        //
        // Before flagging error, see if the currently chosen devices are still valid. If so, some device
        // which was not being used anyway was removed. This is a benign condition so no need to flag an error.
        //
        if ((ulDevices & ppdev->ulConnectedDeviceMask) == ulDevices)
        {
            //
            // All active devices are still connected, so this is a benign condition and hence don't 
            // flag an error
            //
            return(TRUE);
        }
        else
        {
            //
            // An active device has been removed and hence we have to flag an error.
            //
            return(FALSE);
        }
    }

    // Check if the specified per-head devices are correct.
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = pData->dwDeviceDisplay[i];
        if (!(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask & ppdev->ulConnectedDeviceMask))
        {
            DISPDBG((0,"Oops! Head: %d, Invalid Registry Device mask for head: 0x%x, ConnectedMask: 0x%x",
                             ulHead, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask,ppdev->ulConnectedDeviceMask));
        }
    }
    return(TRUE);
}

//
// Copies the device mask, twinview_state and initializes ulNumberDacsActive from the TwinViewInfo into
// the ppdev. These values are needed to build physical mode lists for the new configuration requested
// by the TwinViewInfo structure.
// Note: Before calling this function, the ValidateRegistryDeviceMasks() should have been successfully called
// to make sure the specified device masks are valid.
//
VOID InitDevMaskFromTwinViewInfo(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG SuggestedDeviceMask, SuggestedDeviceType, SuggestedTVType;
    ULONG ulPrimaryHead;

    //
    // Safety check. Should never happen.
    //
    if (pData == NULL)
    {
        DISPDBG((0, "InitDevMaskFromTwinViewInfo(): NULL pointer for TwinViewInfo"));
        return;
    }

    ppdev->TwinView_State = pData->dwState;
    ppdev->TwinView_Orientation = pData->dwOrientation;
    ppdev->ulNumberDacsActive = GetNumberDacsActiveFromTwinViewInfo(pData);

    for (i=0; i < NV_NO_DACS; i++)
    {
        //
        // Get the physical head ==> logical head mapping.
        //
        ppdev->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
    }


    //
    // Copy the device mask
    //
    for (i=0; i<ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ppdev->ulDeviceMask[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
        ppdev->ulDeviceType[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
        ppdev->ulTVFormat[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
    }
}


//
// Input: bitmask for a single device
// Return: device type of this device.
//
ULONG MaskToDeviceType( PPDEV ppdev, ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = MONITOR_TYPE_VGA; 
    else 
    if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = MONITOR_TYPE_FLAT_PANEL;
    else 
    if (ulDeviceMask & BITMASK_ALL_TV)
    {
        ulRet = ppdev->ulDefaultTVDeviceType;
    }
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}


//
// If the system is a desktop, this routine does nothing.
// If the system is a laptop, we should use the output deive posted by the BIOS for the desktop.
// BUGBUG: Currently this function only handles a single output device posted by the BIOS.
// The code does not yet support when the BIOS posts to two devices (sort of BIOS clone mode).
// Returns: TRUE if the config matches with the BIOS heads.
// FALSE if the config differs and the diff has been handled.
//
ULONG HandleBIOSHeads(PPDEV ppdev)
{

    ULONG ulHead;
    ULONG Status, RetSize;
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulCombinedDeviceMask;
    ULONG ulDeviceMask;
    ULONG DeviceMask[NV_NO_DACS];
    ULONG i, status;
    ULONG ReturnedDataLength;
    ULONG ulBIOSDeviceMask;
    
    
    if (Status = NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                  NV_CFG_GET_BOOT_DEVICES, &ulBIOSDeviceMask))
        {
            DISPDBG((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed"));
        }

    DISPDBG((1,"Disp: HandleBIOSHeads(): BIOSDeviceMask: 0x%x",ulBIOSDeviceMask));

    //
    // This case should not happen but just a safety check.
    // When we are in multimon mode, allow BOOT_HEADS only if the NVSVC service has started
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        if (ppdev->ulNVSVCStatus != NVSVC_STATUS_STARTED)
        {
            return(TRUE);
        }
    }

    
    if (ppdev->UseHWSelectedDevice)
    {
        
        //
        // We don't compare BOOT_HEADS if we are explicitly being called by the NVPanel
        //
        if (GetInitiatedRegValue(ppdev) == 1)
        {
            return(TRUE);
        }

        // see if the BIOS had posted on a single device or two devices.
        if (ConvertConnectedMaskToNumDevices(ulBIOSDeviceMask) == 1)
        {
            // BIOS posted on a single device.

            // Check for the cases when we have to do nothing, i.e. windows is in sync with BIOS.
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
            {
                ulHead = ppdev->ulDeviceDisplay[0];
                if (ppdev->ulDeviceMask[ulHead] == ulBIOSDeviceMask)
                {
                    return(TRUE);
                }
            }


            //
            // Invoke NVSVC to do the modeset and return, provided NVSVC service has started.
            //
            if (ppdev->ulNVSVCStatus == NVSVC_STATUS_STARTED)
            {
                ppdev->ulInduceModeChangeDeviceMask = ulBIOSDeviceMask;
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_EVENT failed"));
                }   
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
                }   

                return(TRUE);
            }

            //
            // Since NVSVC has not started, we need to do the device switch ourselves
            // If we are in standard or clone mode, make sure we use this device.
            // We don't handle spanning modes yet.
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                // Ask ResMan for which head to use.
                // Ask ResMan what head to use.
                ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;

                nvConfig.DevicesConfig = ulBIOSDeviceMask;
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;
                if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                   NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
                {

                    DISPDBG((0, "HandleBIOSHeads - Cannot get DEVICES_CONFIG value from RM"));
                }
                else
                {
                    if (nvConfig.DevicesAllocationMap > 1)
                    {
                        DISPDBG((0,"Oops! Invalid DevAllocationMap from RM: 0x%x",nvConfig.DevicesAllocationMap));
                    }
                    if (nvConfig.DevicesAllocationMap == 0)
                    {
                        ppdev->ulDeviceMask[0] = ulBIOSDeviceMask;
                        ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        ppdev->ulDeviceDisplay[0] = 0;
                        ppdev->ulDeviceDisplay[1] = 1;
                    }
                    if (nvConfig.DevicesAllocationMap == 1)
                    {
                        ppdev->ulDeviceMask[1] = ulBIOSDeviceMask;
                        ppdev->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                        ppdev->ulDeviceDisplay[0] = 1;
                        ppdev->ulDeviceDisplay[1] = 0;
                    }
                }

                // Now fill in all the relevant info into the ppdev.
                ulHead = ppdev->ulDeviceDisplay[0];
                ulDeviceMask = ppdev->ulDeviceMask[ulHead];
                ppdev->ulDeviceType[ulHead] = MaskToDeviceType(ppdev, ulDeviceMask);
                ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat; 

                // The resolution (virtual and physical) for the head and desktop will be filled in by the
                // UseOnlyGDIForModeDEtails() which will be called later after HandleBiosHeads().

                // Configuration has changed. So return FALSE.
                return(FALSE);
            } // Normal or Clone
        } // BIOS on single device.

        if (ConvertConnectedMaskToNumDevices(ulBIOSDeviceMask) >= 2)
        {
            // BIOS posted on dual devices.

            // Check for the cases when we have to do nothing, i.e. windows is in sync with BIOS.
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                ulCombinedDeviceMask = ppdev->ulDeviceMask[0] | ppdev->ulDeviceMask[1];
                if (ulCombinedDeviceMask == ulBIOSDeviceMask)
                {
                    return(TRUE);
                }
            }


            //
            // Invoke NVSVC to do the modeset and return, provided NVSVC service has started.
            //
            if (ppdev->ulNVSVCStatus == NVSVC_STATUS_STARTED)
            {
                ppdev->ulInduceModeChangeDeviceMask = ulBIOSDeviceMask;
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_EVENT failed"));
                }
                return(TRUE);
            }

            //
            // Since NVSVC has not started, we need to do the device switch ourselves.
            // If we are in standard or clone mode, make sure we use this device.
            // We don't handle spanning modes yet.
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                // Ask ResMan for which head to use.
                // Ask ResMan what head to use.
                ppdev->TwinView_State = NVTWINVIEW_STATE_CLONE;
                ppdev->ulNumberDacsActive =2;

                ppdev->ulDeviceDisplay[0] = 0;
                ppdev->ulDeviceDisplay[1] = 1;

                // Grab the first output device.
                for (i=0; i < NV_NO_CONNECTORS; i++)
                {
                    if (ulBIOSDeviceMask & (1 << i))
                    {
                        DeviceMask[0] = (1 << i);
                        i++;
                        break;
                    }
                }
                // Continue further and grab the next device.
                for (; i < NV_NO_CONNECTORS; i++)
                {
                    if (ulBIOSDeviceMask & (1 << i))
                    {
                        DeviceMask[1] = (1 << i);
                        break;
                    }
                }

                // Ask ResMan what head to use for the devices.
                nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;
                status = NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
                if (status != 0)
                {

                    DISPDBG((0, "Oops! HandleBIOSHeads - Cannot get DEVICES_CONFIG value from RM"));
                    // Set to a safe single head mode.
                    ppdev->ulNumberDacsConnected = 1;
                    ppdev->ulConnectedDeviceMask = DeviceMask[0];
                    ppdev->ulAllDeviceMask = DeviceMask[0];
                    ppdev->ulDeviceMask[0] = DeviceMask[0];
                    ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                }
                else
                {
                    // We got a successful head assignment for both the devices.
                    switch (nvConfig.DevicesAllocationMap)
                    {
                    case 0x10:
                        // Head assignment 1, 0
                        ppdev->ulDeviceMask[0] = DeviceMask[0];
                        ppdev->ulDeviceMask[1] = DeviceMask[1];
                        break;

                    case 0x01:
                        // Head assignment 0, 1
                        ppdev->ulDeviceMask[0] = DeviceMask[1];
                        ppdev->ulDeviceMask[1] = DeviceMask[0];
                        break;

                    default:
                        DISPDBG((0,"Oops! Unexpected head allocationMap: 0x%x",  nvConfig.DevicesAllocationMap));
                        // Set to a safe single head mode.
                        ppdev->ulNumberDacsConnected = 1;
                        ppdev->ulConnectedDeviceMask = DeviceMask[0];
                        ppdev->ulAllDeviceMask = DeviceMask[0];
                        ppdev->ulDeviceMask[0] = DeviceMask[0];
                        ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        break;
                    }

                    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
                    {
                        //
                        // Convert the device mask to device type. 
                        //
                        ppdev->ulDeviceType[i] = MaskToDeviceType(ppdev, ppdev->ulDeviceMask[i]);
                        ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat;
                    }
                } // status != RM_OK

                // The resolution (virtual and physical) for the head and desktop will be filled in by the
                // UseOnlyGDIForModeDEtails() which will be called later after HandleBiosHeads().

                // Configuration has changed. So return FALSE.
                return(FALSE);
            } // Normal or Clone
        } // BIOS selected two devices.
    } // UseHwSelectedDevice
 
     return (TRUE);
}

//
// Returns the index from the device mask.
// Input: A 32bit bitmask with only one of the 32bits set specifying a unique device
// Return Value: Index of this bitmask
//      For example: 
//      input: 0x4, Return: 2
//      input: 0x20, Return: 5
//      input: 0x1, Return: 0
//      input: 0x0, Return: 0
//
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask)
{
    ULONG i;
    ULONG ulTmp;
    ulTmp = ulDeviceMask;

  
    i=0;
    for (;;)
    {
        if (ulTmp == 0)
        {
            DISPDBG((1,"Oops! ConvertDeviceMaskToIndex(): Invalid ulDeviceMask: 0x%x\n",ulDeviceMask));
            return(0);
        }
        if (ulTmp & 0x1)
        {
            return(i);
        }
        // shift right by one and increment the index
        ulTmp >>= 1;
        i++;
    }
}

//
// Returns the number of bits that are set in the mask.
// 
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask)
{
    ULONG i, NumDevices, ulDeviceMask;
    NumDevices = 0;
    for(i=0; i < NV_NO_CONNECTORS; i++)
    {
        ulDeviceMask = (1 << i);
        if(ulConnectedDeviceMask & ulDeviceMask)
        {
            NumDevices++;
        }
    }
    return(NumDevices);

}

//
// Reads the ToshibaHotKeyMode registry entry.
//
VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode)
{
    char * KeyName = "ForceGDIMode";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStructInput;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStructInput.keyName = (PWSTR)KeyNameUniCode;
    regStructInput.keyVal = pMode;
    regStructInput.keyValSize = sizeof(TOSHIBA_HOTKEY_MODE);

    Status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                (LPVOID)&regStructInput,
                                sizeof(NV_REGISTRY_STRUCT),
                                (LPVOID) (pMode),
                                sizeof(TOSHIBA_HOTKEY_MODE),
                                &(returnedDataLen));

    DISPDBG((1,"KeyValSize returned from miniport: 0x%x",returnedDataLen));
}

//
// Writes the ToshibaHotKeyMode registry entry
//
VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode)
{
    char * KeyName = "ForceGDIMode";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStruct;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = pMode;
    regStruct.keyValSize = sizeof(TOSHIBA_HOTKEY_MODE);

    Status = EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
}

//
// if pData is non-NULL, writes the pData as is to the registry.
// if pData is NULL, then constructs the TwinViewInfo from ppdev information and writes to the registry.
//
VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG returnedDataLength;
    NVTWINVIEWDATA sData;
    ULONG i;
    NVTWINVIEW_DEVICE_TYPE_DATA * pHeadData;

    if (pData)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_TWINVIEW_STATE,
                               pData,
                               sizeof(NVTWINVIEWDATA),
                               NULL,
                               0,
                               &returnedDataLength))
        {
            DISPDBG((0, "WriteRegistryTwinViewInfo pData: - IOCTL_VIDEO_SET_TWINVIEW_STATE failed"));
        }
        return;
    }

    // Zero the memory.
    memset(&sData, 0, sizeof(NVTWINVIEWDATA));

    // We need to costruct the TwinViewData from the ppdev info.
    // Set the desktop resolution.
    sData.DeskTopRectl.left = 0;
    sData.DeskTopRectl.top = 0;
    sData.DeskTopRectl.right = ppdev->cxScreen;
    sData.DeskTopRectl.bottom = ppdev->cyScreen;

    sData.dwState = ppdev->TwinView_State;
    sData.dwOrientation = ppdev->TwinView_Orientation;
    sData.dwAllDeviceMask = ppdev->ulAllDeviceMask;
    sData.dwConnectedDeviceMask = ppdev->ulConnectedDeviceMask;


    for (i=0; i < NV_NO_DACS; i++)
    {
        sData.dwDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];

        pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);

        pHeadData->dwDeviceMask = ppdev->ulDeviceMask[i];
        pHeadData->dwDeviceType = ppdev->ulDeviceType[i];
        pHeadData->dwTVFormat = ppdev->ulTVFormat[i];

        pHeadData->dwBpp = ppdev->cBitsPerPel;
        pHeadData->dwRefresh = ppdev->ulRefreshRate[i];
        pHeadData->VirtualRectl.left = ppdev->rclDisplayDesktop[i].left;
        pHeadData->VirtualRectl.top = ppdev->rclDisplayDesktop[i].top;
        pHeadData->VirtualRectl.right = ppdev->rclDisplayDesktop[i].right;
        pHeadData->VirtualRectl.bottom = ppdev->rclDisplayDesktop[i].bottom;
        pHeadData->PhysicalRectl.left = ppdev->rclCurrentDisplay[i].left;
        pHeadData->PhysicalRectl.top = ppdev->rclCurrentDisplay[i].top;
        pHeadData->PhysicalRectl.right = ppdev->rclCurrentDisplay[i].right;
        pHeadData->PhysicalRectl.bottom = ppdev->rclCurrentDisplay[i].bottom;

        pHeadData->dwNumPhysModes = ppdev->ulNumPhysModes[i];
        pHeadData->dwNumVirtualModes = ppdev->ulNumVirtualModes[i];

        pHeadData->dwEnableDDC = ppdev->ulEnableDDC[i];
        pHeadData->dwEnablePanScan = ppdev->ulEnablePanScan[i];
        pHeadData->dwFreezePanScan = ppdev->ulFreezePanScan[i];
        pHeadData->dwFreezeOriginX = ppdev->ulFreezeOriginX[i];
        pHeadData->dwFreezeOriginY = ppdev->ulFreezeOriginY[i];
        pHeadData->dwTimingOverRide = ppdev->ulTimingOverRide[i];
    }

    //
    // Now write the structure to the registry.
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_TWINVIEW_STATE,
                           &sData,
                           sizeof(NVTWINVIEWDATA),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        DISPDBG((0, "WriteRegistryTwinViewInfo sData: - IOCTL_VIDEO_SET_TWINVIEW_STATE failed"));
    }
    return;
}



// Read a (named) reg key through IOCTL call (through miniport) (DeviceIO Wrapper)
//
// (see dspioctl.h for NV_REG_STRUCT )


void GetRegValueW(
                     HANDLE  hDriver,            // Handle to our phys device
                     PWSTR   keyName,            // Unicode name of the key     : IN
                     PVOID   keyData,            // Ptr to the data of the key  : OUT (IN not used in the IOCTL )
                     ULONG   keyDataSize)        // The sizeof(data) of the key : IN
{
    NV_REGISTRY_STRUCT regStruct;
    ULONG              IOCTLRetDataLen;     // not used
    ULONG              status;

    regStruct.keyName    = keyName;
    regStruct.keyVal     = keyData;
    regStruct.keyValSize = keyDataSize;

    status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                
                                (LPVOID)&regStruct,           // only the keyname and datasize is used
                                                              // 
                                sizeof(NV_REGISTRY_STRUCT),
                                
                                (LPVOID) keyData,             // only *keyData is written
                                keyDataSize,                  //
                                                              // NOTE: For this particular IOCTL (see NV.C),
                                                              // the return buffer is used for the reg key data
                                                              // itself

                                
                                &(IOCTLRetDataLen));

} // ...GetRegValueW()


//
// Writes a (named) reg key through IOCTL call (through miniport) (DeviceIO Wrapper)
//

void SetRegValueW(
                      HANDLE  hDriver,            // Handle to our phys device
                      PWSTR   keyName,            // Unicode name of the key     : IN
                      PVOID   keyData,            // The data of the key         : IN
                      ULONG   keyDataSize)        // The sizeof(data) of the key : IN
{
    NV_REGISTRY_STRUCT regStruct;
    ULONG              IOCTLRetDataLen;     // not used
    ULONG              status;

    regStruct.keyName    = keyName;
    regStruct.keyVal     = keyData;
    regStruct.keyValSize = keyDataSize;

    status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                
                                (LPVOID)&regStruct,    
                                                       
                                sizeof(NV_REGISTRY_STRUCT),
                                
                                NULL,
                                0,
                                
                                &(IOCTLRetDataLen));

} // ...SetRegValueW()



//
// Reads the registry entry "Key Name".
// Returns TRUE if this entry exists and the value is returned in pulData.
// Returns FALSE if this registry entry is absent and pulData is not modified.
//
BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData)
{
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG RetSize = 0;
    
    KeyNameLen = strlen(pcKeyName) + 1;


    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)pcKeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)pulData,
                                sizeof(ULONG),
                                &RetSize);
    if (Status == 0)
    {
        //
        // The call succeeded
        //
        DISPDBG((1,"Disp: GetULONGRegValue(): RegKey: %s, Value: 0x%x",pcKeyName, *pulData));
        return(TRUE);

    }
    else
    {    
        //
        // The call failed.
        //
        DISPDBG((1,"Disp: GetULONGRegValue(): RegKey: %s, Does not exist. Error status: 0x%x",pcKeyName, Status));
        return(FALSE);
    }
}

//
// Sets the registry key "pcKeyName" with the ulong value in pulData.
// Creates the registry entry if it does not exist.
//
VOID SetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG ulData)
{
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen = 0;

    KeyNameLen = strlen(pcKeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)pcKeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulData;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the ModeSetInitiated registry entry.
// Returns 1 if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetInitiatedRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ModeSetInitiated;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "NvCplInduceModeSetInitiated".
    ModeSetInitiated = 0;
    KeyName = "NvCplInduceModeSetInitiated";
    KeyNameLen = strlen(KeyName) + 1;

    ModeSetInitiated = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ModeSetInitiated,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetInitiatedRegValue(): ModeSetInitiated registry value: 0x%x",ModeSetInitiated));
    return(ModeSetInitiated);

}

//
// Sets the ModeSetInitiated registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetInitiatedRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "NvCplInduceModeSetInitiated";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the ResumingFromAdapterPowerDownState registry entry.
// Returns 1 if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetPowerStateRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ResumingFromAdapterPowerDownState;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "ResumingFromAdapterPowerDownState".
    ResumingFromAdapterPowerDownState = 0;
    KeyName = "ResumingFromAdapterPowerDownState";
    KeyNameLen = strlen(KeyName) + 1;

    ResumingFromAdapterPowerDownState = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ResumingFromAdapterPowerDownState,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetPowerStateRegValue(): ResumingFromAdapterPowerDownState registry value: 0x%x",ResumingFromAdapterPowerDownState));
    
    return(ResumingFromAdapterPowerDownState);

}

//
// Sets the ResumingFromAdapterPowerDownState registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetPowerStateRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "ResumingFromAdapterPowerDownState";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the PrevDevMask registry entry.
// Returns the non-zero value if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetPrevDevMaskRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG PrevDevMask;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "PrevDevMask".
    PrevDevMask = 0;
    KeyName = "PrevDevMask";
    KeyNameLen = strlen(KeyName) + 1;

    PrevDevMask = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&PrevDevMask,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetPrevDevMaskRegValue(): PrevDevMask registry value: 0x%x",PrevDevMask));
    
    return(PrevDevMask);

}

//
// Sets the PrevDevMask registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "PrevDevMask";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}




#if DBG
//
// Reads the "nvDispDebugLevel" registry entry.
// If it exists, then sets this value to the global DebugLevel variable.
//
VOID GetDebugLevelRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ulVal;
    ULONG Status;
    ULONG RetSize;

    //
    // We should not override the DebugLevel value that might have been set, say by a developer by hand.
    // If there is no "nvDispDebugLevel" override, we will simply restore the original DebugLevel value.
    //
    ulVal = DebugLevel;

    //
    // Read the registry entry "nvDispDebugLevel".
    //
    KeyName = "nvDispDebugLevel";
    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ulVal,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: nvDispDebugLevel(): nvDispDebugLevel registry value: 0x%x",ulVal));
    
    DebugLevel = ulVal;
}
#endif DBG

//
// Reads in the latest and correct TV format the driver should use for a default value and caches in the ppdev.
// Note: Currently keeps track of a single TV format since all our cards currently have only one TV encoder but
// in the future we may have cards with say two TV encoders. Then we would have to keep track of TV format per
// TV encoder (or per TV device mask).
//
void GetDefaultTVFormat(PPDEV ppdev)
{
    ULONG Status;
    NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS Params;

    ppdev->ulDefaultTVFormat = 0;
    Params.DevicesConfig = TV_ENCODER_0;
    Params.TVStandard = 0;
    
    if (Status = NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_GET_VIDEO_TV_STANDARD, &Params, sizeof(NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS)))
    {
        DISPDBG((0,"Oops!    NV_CFGEX_GET_VIDEO_TV_STANDARD failed"));
    }

    ppdev->ulDefaultTVFormat = Params.TVStandard;

    DISPDBG((1,"Disp: GetDefaultTVFormat(): ulDefaultTVFormat: 0x%x",ppdev->ulDefaultTVFormat));
    ppdev->ulDefaultTVDeviceType = TVFormatToTVDeviceType(ppdev->ulDefaultTVFormat);
    DISPDBG((1,"Disp: GetDefaultTVFormat(): ulDefaultTVDeviceType: 0x%x",ppdev->ulDefaultTVDeviceType));
}

//
// Converts a TV FOrmat to the appropriate tV deviceType.
//
ULONG TVFormatToTVDeviceType(ULONG ulTVFormat)
{
    ULONG ulDeviceType;
    switch (ulTVFormat)
    {
    case NTSC_M:
    case NTSC_J:
        ulDeviceType = MONITOR_TYPE_NTSC;
        break;
    case PAL_M:
    case PAL_A:
    case PAL_N:
    case PAL_NC:
        ulDeviceType = MONITOR_TYPE_PAL;
        break;
    default:
        ulDeviceType = MONITOR_TYPE_NTSC;
        break;
    }
    return(ulDeviceType);
}

BOOLEAN ConvertHeadResToTiming(PPDEV ppdev,
                               ULONG ulHead,
                               HEAD_RESOLUTION_INFO *pHeadResolution,
                               NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS *pParam)
{
    ULONG             ReturnedDataLength;
    DAC_TIMING_VALUES sTimingDac;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           pHeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "HandleBandWidth_SingleDacActive() - IOCTL_VIDEO_GET_TIMING_DAC failed"));
        return FALSE;
    }

    //
    // Sanity check. Make sure we got the requested timings. This should not happen.
    //
    if (sTimingDac.HorizontalVisible != pHeadResolution->ulDisplayWidth || 
        sTimingDac.VerticalVisible != pHeadResolution->ulDisplayHeight ||
        sTimingDac.Refresh != pHeadResolution->ulDisplayRefresh)
    {
        return FALSE;
    }

    if (ulHead == 0)
    {
        pParam->TotalWidth0 = sTimingDac.HorizontalTotal;
        pParam->VisibleWidth0 = sTimingDac.HorizontalVisible;
        pParam->TotalHeight0 = sTimingDac.VerticalTotal;
        pParam->VisibleHeight0 = sTimingDac.VerticalVisible;
        pParam->PixelDepth0 = ppdev->cBitsPerPel;
        pParam->PixelClock0 = sTimingDac.PixelClock;
    }
    else
    {
        pParam->TotalWidth1 = sTimingDac.HorizontalTotal;
        pParam->VisibleWidth1 = sTimingDac.HorizontalVisible;
        pParam->TotalHeight1 = sTimingDac.VerticalTotal;
        pParam->VisibleHeight1 = sTimingDac.VerticalVisible;
        pParam->PixelDepth1 = ppdev->cBitsPerPel;
        pParam->PixelClock1 = sTimingDac.PixelClock;
    }

    return TRUE;
}

//
// Verifies that the physical modes can be supported by the Bandwidth restrictions of the system.
// If not, lowers the physical resolution while keeping the same refresh rate.
// If the same refresh rate can not be kept, then keeps the resolution and lowers the refresh rate.
//
VOID HandleBandWidth_SingleDacActive(PPDEV ppdev)
{
    NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS Params;
    HEAD_RESOLUTION_INFO HeadResolution;
    ULONG ulHead;
    MODE_ENTRY RequestedMode;
    ULONG RefreshLoop, ResolutionLoop;
    ULONG NextLowerWidth, NextLowerHeight, NextLowerRefreshRate;

    RtlZeroMemory(&Params, sizeof(Params));
    Params.VidScalerHead = NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE;

    ulHead = ppdev->ulDeviceDisplay[0];
    if (ulHead == 0)
    {
        Params.HeadActive0 = 1;
    }
    if (ulHead == 1)
    {
        Params.HeadActive1 = 1;
    }
    //
    // Get the timing info for the physical mode.
    //
    HeadResolution.ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
    HeadResolution.ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];   

    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulDisplayPixelDepth = ppdev->cBitsPerPel;
    HeadResolution.ulOption = 0;

    DISPDBG((1,"PhysMode Head%d: %d x %d, %d BPP, %d HZ, devMask: 0x%x, devType: %d",
             ulHead,
             HeadResolution.ulDisplayWidth, HeadResolution.ulDisplayHeight,
             HeadResolution.ulDisplayPixelDepth, HeadResolution.ulDisplayRefresh,
             HeadResolution.ulDeviceMask, HeadResolution.ulDeviceType));

    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
        return;

    RefreshLoop = ResolutionLoop = 1;

    RequestedMode.Width = (USHORT)(ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left);
    RequestedMode.Height= (USHORT)(ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top);
    RequestedMode.RefreshRate = (USHORT)(ppdev->ulRefreshRate[ulHead]);   
    RequestedMode.Depth = (USHORT)(ppdev->cBitsPerPel);
    RequestedMode.ValidMode = 1;

    //
    // We have now built up the NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS structure. 
    // Now the quick success case. See if this mode passes. This is the most common case.
    //
    while (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_VALIDATE_BANDWIDTH, &Params, sizeof(NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS)))
    {
        //
        // We are failing the bandwidth requirements. We need to back off and try a lower physical mode.
        // See if there is a next lower refresh rate physical mode at the same resolution and color depth.
        // If cannot find the next lower refresh rate, try the next lower resolution at the same color depth
        // and refresh rate.
        //
        if (RefreshLoop || ResolutionLoop)
        {
            BOOLEAN bFoundNextLowerMode;

            if (RefreshLoop)
            {
                bFoundNextLowerMode = FindNextLowerRefreshRateMode(ppdev, ulHead, &RequestedMode, &NextLowerRefreshRate);
                if (bFoundNextLowerMode)
                {
                    HeadResolution.ulDisplayRefresh = NextLowerRefreshRate;
                }
            }
            else
            {
                bFoundNextLowerMode = FindNextLowerResolutionMode(ppdev, ulHead, &RequestedMode, &NextLowerWidth, &NextLowerHeight);
                if (bFoundNextLowerMode)
                {
                    HeadResolution.ulDisplayWidth = NextLowerWidth;
                    HeadResolution.ulDisplayHeight= NextLowerHeight;
                    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                }
            }

            if (bFoundNextLowerMode)
            {
                HeadResolution.ulHead = ulHead;              
                HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
                HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
                HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
                HeadResolution.ulDisplayPixelDepth = ppdev->cBitsPerPel;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
                {
                    return;
                }

                //
                // Stick in lowered refresh rate or lowered resolution into the requested mode as we may need to iterate the next time.
                //
                if (RefreshLoop)
                {
                    RequestedMode.RefreshRate = (USHORT)NextLowerRefreshRate;
                }
                else
                {
                    RequestedMode.Width  = (USHORT)NextLowerWidth;
                    RequestedMode.Height = (USHORT)NextLowerHeight;
                }

                if (ResolutionLoop)
                {
                    RefreshLoop = 1;
                }

                //
                // Continue onto validating this combo.
                //
                continue;
            } // if bFoundNextLowerMode
            else
            {
                if (RefreshLoop)
                {
                    RefreshLoop = 0;
                    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                    RequestedMode.RefreshRate = (USHORT)HeadResolution.ulDisplayRefresh;

                    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
                        return;
                }
                else
                {
                    ResolutionLoop = 0;
                }
            }
        }
        else
        {
            DISPDBG((0, "Too bad. Could not find any combo which passes the bandwidth requirements. Returning"));
            return;
        }
    } // while GetExBandwidth()

    //
    // Update the physical mode fields in the ppdev for the head we are varying.
    //
    ppdev->rclCurrentDisplay[ulHead].right = ppdev->rclCurrentDisplay[ulHead].left + RequestedMode.Width;
    ppdev->rclCurrentDisplay[ulHead].bottom = ppdev->rclCurrentDisplay[ulHead].top + RequestedMode.Height;
    ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
    
    DISPDBG((1, "Head: %d, DevMask: 0x%x, Final Phys: (%d, %d), (%d, %d) %d bpp, %d Hz",
             ulHead, ppdev->ulDeviceMask[ulHead], 
             ppdev->rclCurrentDisplay[ulHead].left, ppdev->rclCurrentDisplay[ulHead].top,
             ppdev->rclCurrentDisplay[ulHead].right, ppdev->rclCurrentDisplay[ulHead].bottom,
             ppdev->cBitsPerPel, ppdev->ulRefreshRate[ulHead]));

    return;
}

//
// Verifies that the physical modes can be supported by the Bandwidth restrictions of the system.
// If not, lowers the physical resolution while keeping the same refresh rate.
// If the same refresh rate can not be kept, then keeps the resolution and lowers the refresh rate.
//
VOID HandleBandWidth_DualDacsActive(PPDEV ppdev)
{
    NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS Params;
    HEAD_RESOLUTION_INFO HeadResolution[2];
    ULONG ulHead;
    MODE_ENTRY RequestedMode[2];
    ULONG i;
    ULONG RefreshLoop[2], ResolutionLoop[2];
    ULONG NextLowerWidth, NextLowerHeight, NextLowerRefreshRate;

    RtlZeroMemory(&Params, sizeof(Params));
    Params.VidScalerHead = NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE;
    Params.HeadActive0 = Params.HeadActive1 = 1;

    for (i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        //
        // Get the timing info for the physical mode.
        //
        HeadResolution[i].ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        HeadResolution[i].ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];   

        HeadResolution[i].ulHead = ulHead;              
        HeadResolution[i].ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
        HeadResolution[i].ulDeviceType = ppdev->ulDeviceType[ulHead];        
        HeadResolution[i].ulTVFormat = ppdev->ulTVFormat[ulHead];
        HeadResolution[i].ulDisplayPixelDepth = ppdev->cBitsPerPel;
        HeadResolution[i].ulOption = 0;

        DISPDBG((1,"PhysMode Head%d: %d x %d, %d BPP, %d HZ, devMask: 0x%x, devType: %d",
                 ulHead,
                 HeadResolution[i].ulDisplayWidth, HeadResolution[i].ulDisplayHeight,
                 HeadResolution[i].ulDisplayPixelDepth, HeadResolution[i].ulDisplayRefresh,
                 HeadResolution[i].ulDeviceMask, HeadResolution[i].ulDeviceType));

        if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
            return;
    } // for NumberDacsActive


    for (i = 0; i < 2; i++)
    {
        RefreshLoop[i] = ResolutionLoop[i] = 1;

        RequestedMode[i].Width = (USHORT)(ppdev->rclCurrentDisplay[i].right  - ppdev->rclCurrentDisplay[i].left);
        RequestedMode[i].Height= (USHORT)(ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top);
        RequestedMode[i].RefreshRate = (USHORT)(ppdev->ulRefreshRate[i]);   
        RequestedMode[i].Depth = (USHORT)(ppdev->cBitsPerPel);
        RequestedMode[i].ValidMode = 1;
    }

    //
    // We have now built up the NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS structure. 
    // Now the quick success case. See if this mode passes. This is the most common case.
    //
    i = 0;
    
    while (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_VALIDATE_BANDWIDTH, &Params, sizeof(NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS)))
    {
        //
        // We are failing the bandwidth requirements. We need to back off and try a lower physical mode.
        // See if there is a next lower refresh rate physical mode at the same resolution and color depth.
        // If cannot find the next lower refresh rate, try the next lower resolution at the same color depth
        // and refresh rate.
        //
        if (!RefreshLoop[i] && !ResolutionLoop[i])
        {
            if (i == 1)
            {
                DISPDBG((0, "Too bad. Could not find any combo which passes the bandwidth requirements. Returning"));
                return;
            }
            else
            {
                RefreshLoop[0] = ResolutionLoop[0] = 1;

                ulHead = ppdev->ulDeviceDisplay[0];
                HeadResolution[0].ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
                HeadResolution[0].ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
                HeadResolution[0].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                RequestedMode[0].Width = (USHORT)HeadResolution[0].ulDisplayWidth;
                RequestedMode[0].Height= (USHORT)HeadResolution[0].ulDisplayHeight;
                RequestedMode[0].RefreshRate = (USHORT)HeadResolution[0].ulDisplayRefresh;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[0], &Params))
                    return;

                i = 1;
            }
        }
        else
        {
            BOOLEAN bFoundNextLowerMode;

            ulHead = ppdev->ulDeviceDisplay[i];

            if (RefreshLoop[i])
            {
                bFoundNextLowerMode = FindNextLowerRefreshRateMode(ppdev, ulHead, &RequestedMode[i], &NextLowerRefreshRate);
                if (bFoundNextLowerMode)
                {
                    HeadResolution[i].ulDisplayRefresh = NextLowerRefreshRate;
                }
            }
            else
            {
                bFoundNextLowerMode = FindNextLowerResolutionMode(ppdev, ulHead, &RequestedMode[i], &NextLowerWidth, &NextLowerHeight);
                if (bFoundNextLowerMode)
                {
                    HeadResolution[i].ulDisplayWidth = NextLowerWidth;
                    HeadResolution[i].ulDisplayHeight= NextLowerHeight;
                    HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                }
            }

            if (bFoundNextLowerMode)
            {
                //
                // Found a mode. Now we need to validate against the bandwidth. 
                // So fill the info into the BANDWIDTH_PARAMS structure. First get the TIMING info.
                //
                HeadResolution[i].ulHead = ulHead;              
                HeadResolution[i].ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
                HeadResolution[i].ulDeviceType = ppdev->ulDeviceType[ulHead];        
                HeadResolution[i].ulTVFormat = ppdev->ulTVFormat[ulHead];
                HeadResolution[i].ulDisplayPixelDepth = ppdev->cBitsPerPel;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
                    return;

                //
                // Stick in lowered refresh rate or lowered resolution into the requested mode as we may need to iterate the next time.
                //
                if (RefreshLoop[i])
                {
                    RequestedMode[i].RefreshRate = (USHORT)NextLowerRefreshRate;
                }
                else
                {
                    RequestedMode[i].Width  = (USHORT)NextLowerWidth;
                    RequestedMode[i].Height = (USHORT)NextLowerHeight;
                }

                if (ResolutionLoop[i])
                {
                    RefreshLoop[i] = 1;
                }
                //
                // Continue onto validating this combo.
                // For any Head1 change, reset head0 and restart Head0 validation
                //
                if (i == 1)
                {
                    i = 0;
                }
                continue;
            } // if bFoundNextLowerMode
            else
            {
                if (RefreshLoop[i])
                {
                    RefreshLoop[i] = 0;

                    ulHead = ppdev->ulDeviceDisplay[i];
                    HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                    RequestedMode[i].RefreshRate = (USHORT)HeadResolution[i].ulDisplayRefresh;
                    
                    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
                        return;
                }
                else
                {
                    ResolutionLoop[i] = 0;
                }
            }
        }
    }

    //
    // Update the physical mode fields in the ppdev.
    //
    for (i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ppdev->rclCurrentDisplay[ulHead].right  = ppdev->rclCurrentDisplay[ulHead].left + RequestedMode[ulHead].Width;
        ppdev->rclCurrentDisplay[ulHead].bottom = ppdev->rclCurrentDisplay[ulHead].top  + RequestedMode[ulHead].Height;
        ppdev->ulRefreshRate[ulHead] = RequestedMode[ulHead].RefreshRate;

        DISPDBG((1, "Head: %d, PhysHead: %d DevMask: 0x%x, Final Phys: (%d, %d), (%d, %d) %d bpp, %d Hz",
                 i, ulHead, ppdev->ulDeviceMask[i], 
                 ppdev->rclCurrentDisplay[i].left, ppdev->rclCurrentDisplay[i].top,
                 ppdev->rclCurrentDisplay[i].right, ppdev->rclCurrentDisplay[i].bottom,
                 ppdev->cBitsPerPel, ppdev->ulRefreshRate[i]));
    }

    return;
}


//
// For the physical head, finds the next lower refresh rate for the requested mode while keeping the same depth
// and resolution.
// Returns TRUE if a lower refresh rate was found.
// Returns FALSE if a lower refresh rate was not found.
// Note: The physical mode list contains low res modes so weed out modes less than 640x480 since GDI does not
// accept them.
// The lower refresh rate is returned in pNextLowerRefreshRate.
//
BOOLEAN FindNextLowerRefreshRateMode(PPDEV ppdev, ULONG ulHead, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerRefreshRate)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG LowerRate;

    DISPDBG((1, "FindNextLowerRefreshRateMode() for: %d x %d,  %d bpp, %d HZ",
             pRequestedMode->Width, pRequestedMode->Height, pRequestedMode->Depth, pRequestedMode->RefreshRate));
             

    LowerRate = 0;
    PhysModePtr = ppdev->PhysModeList[ulHead];
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width == pRequestedMode->Width &&
            PhysModePtr->Width >= 640 &&
            PhysModePtr->Height == pRequestedMode->Height &&
            PhysModePtr->Height >= 480 &&
            PhysModePtr->Depth == pRequestedMode->Depth &&
            PhysModePtr->RefreshRate  < pRequestedMode->RefreshRate)
        {
            //
            // Found a match. But we still need to scan the rest of the list as we want the highest 
            // among the lower rates.
            //
            if (PhysModePtr->RefreshRate > LowerRate)
            {
                LowerRate =  PhysModePtr->RefreshRate;
            }
            
        }
        PhysModePtr++;
    }

    if (LowerRate != 0)
    {
        //
        // We found a valid lower rate.
        //
        *pNextLowerRefreshRate = LowerRate;
        DISPDBG((1,"Found Lower Rate: %d HZ",LowerRate));
        return(TRUE);

    }
    else
    {
        //
        // We did not find a valid lower rate.
        //
        DISPDBG((1, "Could not find a lower refresh rate"));
        return(FALSE);
    }
}


//
// For the physical head, finds the next lower resolution for the requested mode while keeping the same depth
// and refreshrate.
// Returns TRUE if a lower resolution was found.
// Returns FALSE if a lower resolution rate was not found.
// Note: The physical mode list contains low res modes so weed out modes less than 640x480 since GDI does not
// accept them.
// The lower width is returned in pNextLowerWidth.
// The lower height is returned in pNextLowerHeight.
//
BOOLEAN FindNextLowerResolutionMode(PPDEV ppdev, ULONG ulHead, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerWidth, ULONG *pNextLowerHeight)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG LowerWidth, LowerHeight;

    DISPDBG((1, "FindNextLowerResolutionMode() for: %d x %d,  %d bpp, %d HZ",
             pRequestedMode->Width, pRequestedMode->Height, pRequestedMode->Depth, pRequestedMode->RefreshRate));

    //
    // Vary the height. Depth and Refresh should be the same. Width should be <= the requested width.
    //
    LowerHeight = 0;
    LowerWidth =  0;
    PhysModePtr = ppdev->PhysModeList[ulHead];
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width <= pRequestedMode->Width &&
            PhysModePtr->Width >= 640 &&
            PhysModePtr->Height < pRequestedMode->Height &&
            PhysModePtr->Height >= 480 &&
            PhysModePtr->Depth == pRequestedMode->Depth &&
            PhysModePtr->RefreshRate  == pRequestedMode->RefreshRate)
        {
            //
            // Found a match. But we still need to scan the rest of the list as we want the highest among
            // the lower resolutions.
            //
            if (PhysModePtr->Height > LowerHeight)
            {
                LowerHeight =  PhysModePtr->Height;
                LowerWidth =  PhysModePtr->Width;
            }
            
        }
        PhysModePtr++;
    }

    if (LowerHeight != 0)
    {
        //
        // We found a valid lower resolution.
        //
        *pNextLowerHeight = LowerHeight;
        *pNextLowerWidth =  LowerWidth;
        DISPDBG((1,"Found Lower resolution: %d x %d",LowerWidth, LowerHeight));
        return(TRUE);
    }
    else
    {
        //
        // We did not find a valid lower resolution.
        //
        DISPDBG((1, "Could not find a lower resolution"));
        return(FALSE);
    }
}

//
// Returns true if the GDI should do the EDID mode pruning.
// Returns FALSE to indicate that the display driver should the EDID mode pruning.
// We need to explicitly pass in all the required pieces of data as arguements since we
// don't have ppdev available at DrvGetModes() time.
//
BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
        ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning)
{
    //
    // If spanning mode, we always let the driver do the pruning
    //
    if (ulTwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        return(FALSE);
    }

    //
    // If DualView mode, we always let the GDI do the pruning
    //
    if (ulTwinView_State == NVTWINVIEW_STATE_DUALVIEW)
    {
        return(TRUE);
    }

    //
    // If we are not dealing with the primary head, then let the driver handle the pruning.
    //
    if (ulHead != ulPrimaryHead || ulDeviceMask != ulPrimaryDeviceMask)
    {
        return(FALSE);
    }

    //
    // Handle  CRT depending on the registry key.
    //
    if ((ulPrimaryDeviceMask & BITMASK_ALL_CRT) &&
        (ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_LAPTOP_CRT || 
         ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_CRT_DFP))
    {
        return(TRUE);
    }

    //
    // Handle  DFP depending on the registry key.
    // Note we always want to let the driver handle mode pruning on laptops for DFPs.
    //
    if ((ulPrimaryDeviceMask & BITMASK_ALL_DFP) && ulACPISystem == 0 && 
          ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_CRT_DFP)
    {
        return(TRUE);
    }
    
    return(FALSE);
}

//
// Reads the SaveSettinngs registry entry into ppdev.
// No need to do extensive sanity checks since miniport would have done the sanity checks at boot time to ensure
// a valid SaveSettings structureexists in the regsistry.
//
VOID vReadSaveSettings(PPDEV ppdev)
{
    char * KeyName = "SaveSettings";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStructInput;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStructInput.keyName = (PWSTR)KeyNameUniCode;
    regStructInput.keyVal = ppdev->SaveSettings;
    regStructInput.keyValSize = sizeof(ppdev->SaveSettings);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                (LPVOID)&regStructInput,
                                sizeof(NV_REGISTRY_STRUCT),
                                (LPVOID) (ppdev->SaveSettings),
                                sizeof(ppdev->SaveSettings),
                                &(returnedDataLen));

    DISPDBG((2,"ReadSaveSettings(): KeyValSize: 0x%x, returnedDataLen: 0x%x",regStructInput.keyValSize,
                returnedDataLen));
}

//
// Finds the slot in the SaveSettings table for the requested device combo using the 'pQuery' or 'pData' structure if
// provided, else uses the device combo specified in the ppdev.
// Should always return a valid pointer to a slot.
// Note: SaveSettings is not implemented for DualView mode for WinXP since the OS handles it fully.
//
NVTWINVIEWDATA *pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS *pQuery, NVTWINVIEWDATA *pTwinViewData)
{
    ULONG i, ulPrimaryHead;
    ULONG ulState, ulOrientation, ulPrimaryDeviceMask, ulDeviceMask0, ulDeviceMask1;
    ULONG ulStateTable, ulOrientationTable, ulPrimaryDeviceMaskTable, ulDeviceMask0Table, ulDeviceMask1Table;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;

    if (pQuery)
    {
        ulState = pQuery->ulState;
        ulOrientation = pQuery->ulOrientation;
        ulPrimaryHead = pQuery->ulDeviceDisplay[0];
        ulPrimaryDeviceMask = pQuery->ulDeviceMask[ulPrimaryHead];
        ulDeviceMask0 = pQuery->ulDeviceMask[0];
        ulDeviceMask1 = pQuery->ulDeviceMask[1];
    }
    else
    if (pTwinViewData)
    {
        ulState = pTwinViewData->dwState;
        ulOrientation = pTwinViewData->dwOrientation;
        ulPrimaryHead = pTwinViewData->dwDeviceDisplay[0];
        ulPrimaryDeviceMask = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwDeviceMask;
        ulDeviceMask0 = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
        ulDeviceMask1 = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
    }
    else
    {
        ulState = ppdev->TwinView_State;
        ulOrientation = ppdev->TwinView_Orientation;
        ulPrimaryHead = ppdev->ulDeviceDisplay[0];
        ulPrimaryDeviceMask = ppdev->ulDeviceMask[ulPrimaryHead];
        ulDeviceMask0 = ppdev->ulDeviceMask[0];
        ulDeviceMask1 = ppdev->ulDeviceMask[1];
    }

    // Only for Rel10 and main.
    if (ulState == NVTWINVIEW_STATE_DUALVIEW)
    {
        DISPDBG((1,"pFindSaveSettings(): SaveSettings is not implemented for DualView for XP. Returnign NULL"));
        return(NULL);
    }
    
    //
    // Search for the slot for the standard mode case.
    //
    if (ulState == NVTWINVIEW_STATE_NORMAL)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulPrimaryHead = pData->dwDeviceDisplay[0];
            ulPrimaryDeviceMaskTable = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwDeviceMask;
            if (ulStateTable == ulState && ulPrimaryDeviceMaskTable == ulPrimaryDeviceMask)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    //
    // Search for the slot for the clone mode case.
    //
    if (ulState == NVTWINVIEW_STATE_CLONE)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulDeviceMask0Table = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
            ulDeviceMask1Table = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            if (ulStateTable == ulState && 
                ulDeviceMask0Table == ulDeviceMask0 && ulDeviceMask1Table == ulDeviceMask1)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    //
    // Search for the slot for the span mode case.
    //
    if (ulState == NVTWINVIEW_STATE_SPAN)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulOrientationTable = pData->dwOrientation;
            ulDeviceMask0Table = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
            ulDeviceMask1Table = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            if (ulStateTable == ulState && ulOrientationTable == ulOrientation &&
                ulDeviceMask0Table == ulDeviceMask0 && ulDeviceMask1Table == ulDeviceMask1)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    DISPDBG((1,"pFindSaveSettings(): Something went wrong. Returning NULL"));
    return(NULL);
}
        


//
// Writes the NVTWINVIEWDATA for the current mode into the SaveSettingsTable in the
// appropriate slot.
// Note: It is assumed that the current mode in the ppdev already reflects the pData.
//
VOID vWriteSaveSettings(PPDEV ppdev)
{
    char * KeyName = "SaveSettings";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStruct;
    ULONG Status;
    ULONG returnedDataLen;
    NVTWINVIEWDATA *pFind;
    NVTWINVIEWDATA sCurrentData;
    ULONG ReturnedDataLength;

    //
    // First readin the TwnViewInfo structure for the just concluded modeset.
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_TWINVIEW_STATE,
                        NULL,
                        0,
                        &sCurrentData,
                        sizeof(NVTWINVIEWDATA),
                        &ReturnedDataLength))
    {
        DISPDBG((1, "vWriteSaveSettings() something wrong: - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
        return;
    }


    pFind = pFindSaveSettings(ppdev, NULL, NULL);
    if (pFind == NULL)
    {   
        DISPDBG((1,"vWriteSaveSettings(): Returning since pFindSaveSettings() returned failure"));
        return;
    }

    //
    // Copy the current mode into the SaveSettings Table of the ppdev in the correct slot.
    //
    *pFind = sCurrentData;
    
    //
    // Now copy the full SaveSettings table into the registry.
    //
    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = ppdev->SaveSettings;
    regStruct.keyValSize = sizeof(ppdev->SaveSettings);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
}

//
// Debug helper routine to print the SaveSettings table.
//
VOID vPrintSaveSettings(PPDEV ppdev, ULONG ulDebugLevel)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;
    CHAR *pcMode;

    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &ppdev->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        switch (pData->dwState)
        {
        case NVTWINVIEW_STATE_NORMAL:
            pcMode = "Standard";
            break;
        case NVTWINVIEW_STATE_CLONE:
            pcMode = "Clone";
            break;
        case NVTWINVIEW_STATE_SPAN:
            pcMode = "Spanning";
            break;
        default:
            pcMode = "Invalid mode";
            break;
        }
        DISPDBG((ulDebugLevel,"%d: %s,%d,  (%d,%d), (0x%x, %d), (0x%x, %d)",i,
            pcMode, pData->dwOrientation, pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1], 
            pDevData0->dwDeviceMask, pDevData0->dwTVFormat, pDevData1->dwDeviceMask, pDevData1->dwTVFormat));

        if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 &&
            pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)   
        {
            // don't print this since this slot is not valid.
        }
        else
        {
            // This slot is valid and occupied. Print the mode info.
            DISPDBG((ulDebugLevel, "   Desktop: (%d, %d), (%d, %d)", 
                pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right, pData->DeskTopRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 virt: (%d, %d), (%d, %d)",
                pDevData0->VirtualRectl.left,pDevData0->VirtualRectl.top,pDevData0->VirtualRectl.right,pDevData0->VirtualRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData0->PhysicalRectl.left,pDevData0->PhysicalRectl.top,pDevData0->PhysicalRectl.right,pDevData0->PhysicalRectl.bottom,
                pDevData0->dwBpp, pDevData0->dwRefresh));
            DISPDBG((ulDebugLevel,"    Head1 virt: (%d, %d), (%d, %d)",
                pDevData1->VirtualRectl.left,pDevData1->VirtualRectl.top,pDevData1->VirtualRectl.right,pDevData1->VirtualRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ",
                pDevData1->PhysicalRectl.left,pDevData1->PhysicalRectl.top,pDevData1->PhysicalRectl.right,pDevData1->PhysicalRectl.bottom,
                pDevData1->dwBpp, pDevData1->dwRefresh));
            DISPDBG((ulDebugLevel,""));
        }
        
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvapi.c ===
/******************************************************************************
*
*   Module:  nvapi.c
*
*   Description:
*       This module contains the functions that provide the NT display driver
*   access to the resource manager.
*
******************************************************************************/

#include "precomp.h"
#include <nv32.h>
#include <nvos.h>
#include <nvntioctl.h>
#include <nvapi.h>

HANDLE __cdecl NvOpen
(
    HANDLE hDriver
)
{
    DWORD status, cbReturned;

    // connect to the RM thru an IOCTL to the miniport
    status = EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_OPEN,
        NULL,
        0,
        NULL,
        0,
        &cbReturned
    );

    return (status == 0) ? hDriver : NVARCH_INVALID_NVDESCRIPTOR;
}

VOID _cdecl NvClose
(
    HANDLE hDriver
)
{
    DWORD cbReturned;

    // disconnect from the RM thru an IOCTL to the miniport
    EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_CLOSE,
        NULL,
        0,
        NULL,
        0,
        &cbReturned
    );
}

ULONG __cdecl NvAllocRoot
(
    HANDLE hDriver,
    ULONG  hClass,
    ULONG *phClient
)
{
    NVOS01_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClass            = hClass;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_ROOT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS01_PARAMETERS),
        &cbReturned
    );

    *phClient               = (ULONG)parms.hObjectNew;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocDevice
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    NVOS06_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDevice;
    parms.hClass            = (NvV32)hClass;
    parms.szName            = (NvP64)szName;



    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_DEVICE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS06_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocContextDma
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    NVOS03_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hObjectParent      = (NvV32)hClient;
    parms.hObjectNew         = (NvV32)hDma;
    parms.hClass             = (NvV32)hClass;
    parms.flags              = (NvV32)flags;
    parms.pBase              = (NvP64)base;
    parms.limit              = (NvU64)limit;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_CONTEXT_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS03_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocChannelPio
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    NVOS04_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.flags             = (NvV32)flags;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_CHANNEL_PIO,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS04_PARAMETERS),
        &cbReturned
    );

    *ppChannel = (PVOID)parms.pChannel;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocChannelDma
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    NVOS07_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.hObjectBuffer     = (NvV32)hDataCtx;
    parms.offset            = (NvU32)offset;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_ALLOC_CHANNEL_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS07_PARAMETERS),
        &cbReturned
    );

    *ppChannel = (PVOID)parms.pControl;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocMemory
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    NVOS02_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot                = (NvV32)hClient;
    parms.hObjectParent        = (NvV32)hParent;
    parms.hObjectNew           = (NvV32)hMemory;
    parms.hClass               = (NvV32)hClass;
    parms.flags                = (NvV32)flags;
    parms.pMemory              = (NvP64)*ppAddress;
    parms.pLimit               = (NvU64)*pLimit;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_MEMORY,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS02_PARAMETERS),
        &cbReturned
    );

    // retrieve output parameters
    *ppAddress = (PVOID)parms.pMemory;
    *pLimit    = (ULONG)parms.pLimit;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocObject
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_OBJECT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS05_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}
ULONG __cdecl NvAllocEvent
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    ULONG index,
#ifdef _WIN64
    PVOID hEvent
#else
    ULONG hEvent
#endif
)
{
    NVOS10_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    parms.index             = (NvV32)index;
    parms.hEvent            = (NvU64)hEvent;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_EVENT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS10_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAlloc
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass,
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot                    = (NvV32)hClient;
    parms.hObjectParent            = (NvV32)hChannel;
    parms.hObjectNew               = (NvV32)hObject;
    parms.hClass                   = (NvV32)hClass;
    parms.pAllocParms              = (NvP64)pAllocParms;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_ALLOC,
        &pParms,
        sizeof(PVOID),
        &parms,
        sizeof(NVOS21_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvFree
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    NVOS00_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectOld        = (NvV32)hObject;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_FREE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS00_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvGetDmaPushInfo
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG retArray,
    ULONG hDmaContext
)
{
    ULONG parms[5];
    PVOID pParms;
    DWORD cbReturned;

    parms[0] = (NvV32)hClient;
    parms[1] = (NvV32)hDevice;
    parms[2] = (NvU32)hChannel;
    parms[3] = (NvU32)retArray;
    parms[4] = (NvU32)hDmaContext;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_DMA_FLOW_CONTROL, // USING THIS TO GET TO RM
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(parms),
        &cbReturned
    );

    return (ULONG)parms[4];

}

ULONG __cdecl NvDmaFlowControl
(
    HANDLE hDriver,
    ULONG hChannel,
    ULONG flags,
    ULONG put,
    ULONG get
)
{
    NVOS08_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hChannel          = (NvV32)hChannel;
    parms.flags             = (NvV32)flags;
    parms.put               = (NvU32)put;
    parms.get               = (NvU32)get;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_DMA_FLOW_CONTROL,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS08_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;
}

ULONG __cdecl NvArchHeap
(
    HANDLE hDriver,
    PVOID  parms
)
{
    PVOID pParms;
    DWORD cbReturned;

    pParms = parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ARCH_HEAP,
        (&pParms),
        sizeof(PVOID),
        parms,
        sizeof(NVOS11_PARAMETERS),
        &cbReturned
    );

    return ((NVOS11_PARAMETERS *)parms)->status;
}

/*
/*
ULONG NvDmaPushMutexState
(
    HANDLE hDriver,
    DWORD  mutexState
)
{
    NV3_DMA_PUSH_MUTEX_STATE_STRUCT parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.mutexState = (U032)mutexState;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_DMA_PUSH_MUTEX_STATE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NV3_DMA_PUSH_MUTEX_STATE_STRUCT),
        &cbReturned
    );

    return (ULONG)parms.nvStatus;

}
*/

ULONG __cdecl NvConfigVersion
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG *pVersion
)
{
    NVOS12_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_VERSION,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS12_PARAMETERS),
        &cbReturned
    );

    *pVersion = (ULONG)parms.version;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigGet
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    NVOS13_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_GET,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS13_PARAMETERS),
        &cbReturned
    );

    *pValue = (ULONG)parms.value;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigSet
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    NVOS14_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.newValue          = (NvV32)newValue;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_SET,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS14_PARAMETERS),
        &cbReturned
    );

    *pOldValue = (ULONG)parms.oldValue;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigGetEx
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    PVOID paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_GET_EX_PARAMS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.paramStructPtr    = (NvP64)paramStructPtr;
    parms.paramSize         = (NvU32)paramSize;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_CONFIG_GET_EX,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS_CONFIG_GET_EX_PARAMS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigSetEx
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    PVOID paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_SET_EX_PARAMS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.paramStructPtr    = (NvP64)paramStructPtr;
    parms.paramSize         = (NvU32)paramSize;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_CONFIG_SET_EX,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS_CONFIG_SET_EX_PARAMS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigUpdate
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    NVOS15_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.flags             = (NvV32)flags;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_UPDATE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS15_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG NvRmDebugControl
(
    HANDLE hDriver,
    ULONG hRoot,
    ULONG command,
    PVOID pArgs
)
{
    NVOS20_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot              = (NvV32)hRoot;
    parms.command            = command;
    parms.pArgs              = (NvP64)((ULONG_PTR)hRoot);

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_DEBUG_CONTROL,
        (&pParms),                      // input buffer
        sizeof(PVOID),                  // input buffer size
        (&parms),                       // output buffer
        sizeof(NVOS20_PARAMETERS),      // output buffer size
        &cbReturned
    );

    return (ULONG)parms.status;
}

ULONG __cdecl NvDirectMethodCall
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG method,
    ULONG data
)
{
    NVOS1D_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectOld        = (NvV32)hObject;
    parms.method            = (NvV32)method;
    parms.data              = (NvV32)data;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_DIRECT_METHOD_CALL,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS1D_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

// end of nvapi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvosnt.h ===
// this file contains the display driver -to- miniport IOCTL codes
// and NvAlloc..() macros for the display driver client


typedef HANDLE NVDESCRIPTOR;
#define NVOPEN_INVALID_DESCRIPTOR 0

#define Nv1GetDeviceOsName(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_GET_DEVICE_OS_NAME,    \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_GET_DEVICE_OS_NAME_STRUCT),  \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv1AllocContextDma(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_ALLOC_CONTEXT_DMA,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_ALLOC_CONTEXT_DMA_STRUCT),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv1FreeContextDma(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_FREE_CONTEXT_DMA,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_FREE_CONTEXT_DMA_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3AllocChannelPio(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_ALLOC_CHANNEL_PIO,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_ALLOC_CHANNEL_PIO_STRUCT),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv3FreeChannelPio(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_FREE_CHANNEL_PIO,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_FREE_CHANNEL_PIO_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3NtAllocChannelDma(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_ALLOC_CHANNEL_DMA,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NVOS07_PARAMETERS),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv3FreeChannelDma(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_FREE_CHANNEL_DMA,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_FREE_CHANNEL_DMA_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3NtDmaFlowControl(fd, ps)               		\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_DMA_FLOW_CONTROL,      		\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NVOS08_PARAMETERS),    		\
        &cbReturned                             \
    );                                          \
}

#define Nv1AllocMemory(fd, ps)               	\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_ALLOC_MEMORY,      	\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_ALLOC_MEMORY_STRUCT),    	\
        &cbReturned                             \
    );                                          \
}

#define Nv1FreeMemory(fd, ps)               	\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_FREE_MEMORY,      		\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_FREE_MEMORY_STRUCT),    		\
        &cbReturned                             \
    );                                          \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvhw.c ===
//******************************************************************************
//
// Module Name:
//
//     NVHW.C
//
// Abstract:
//
//     Implements chip generic hardware routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"

//#include "oldnv332.h"
#include "driver.h"

#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"
#include "nvcm.h"

#undef DEBUG_MSG_CHANNEL_WAIT

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_PUSH0_REG            (0x3200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3220-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_INTR_0                      (0x2100-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHES                      (0x2500-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PULL0                (0x3240-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1                (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS               (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CONFIG_0                    (0x2200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE      (0x3238-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG          (0x3230-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE          (0x3234-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA3                 (0x322C-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_STATUS           (0x3218-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA1                 (0x3224-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA2                 (0x3228-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0                 (0x3220-OFFSET_NV_PFIFO_BASE)

#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************Public*Routine**********************************
//
// Function: NV_GetScanLineData
//
// Routine Description:
//
//             Return current display scanline.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************
ULONG NV_GetScanLineData(PDEV* ppdev) {
#ifdef NV3
    ULONG   Value, Value32;
    UCHAR   lock;

    //******************************************************************************
    // Make sure the extended CRTC registers are enabled
    //******************************************************************************

    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SRX_REG] = NV_PRMVIO_SR_LOCK_INDEX;
    lock = (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG];
    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG] =  NV_SR_UNLOCK_VALUE;

    //******************************************************************************
    // Get the scanline value.
    //******************************************************************************
    (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL1__INDEX;
    Value = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG];
    Value <<= 8;
    (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL0__INDEX;
    Value32 = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG] & 0xFF;
    Value |= Value32;
    Value &= 0x7FF;
    if (Value == 0)
    {
        //******************************************************************************
        // Double check to fix hw bug.
        //******************************************************************************
        (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL1__INDEX;
        Value = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG];
        Value <<= 8;
        (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL0__INDEX;
        Value32 = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG] & 0xFF;
        Value |= Value32;
        Value &= 0x7FF;
    }

    //******************************************************************************
    // Restore the lock
    //******************************************************************************
    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SRX_REG] = NV_PRMVIO_SR_LOCK_INDEX;
    if(lock != 0x01)    // unlock read-back value
    {
        (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG] = NV_SR_LOCK_VALUE;
    }

    return(Value);
#else
    return (((REG_RD32(NV_PCRTC_RASTER+(ppdev->ulDeviceDisplay[0]*0x2000)))>>
            DRF_SHIFT(NV_PCRTC_RASTER_POSITION))&DRF_MASK(NV_PCRTC_RASTER_POSITION));
#endif // NV#
}


//******************************Public*Routine**********************************
//
// Function: NV_WaitForOneVerticalRefresh
//
// Routine Description:
//
//           Palette writes
//           (using video colormap) get queued up and don't
//           actually get written until the next vertical blank.
//           Normally, we would wait on the video colormap buffer notifier
//           to make sure the palette writes are done, before resetting
//           the device (calling int 10h).  However notifiers for the video
//           colormap are currrently *not* functional.  So for now, we'll
//           wait for at least one vertical refresh to occur , to make sure
//           all the palette writes have completed.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************

VOID NV_WaitForOneVerticalRefresh(PDEV* ppdev)

    {
    ULONG   TotalScanLines;
    ULONG   PreviousScanLine, NextScanLine;

    TotalScanLines   = 0;

    //**************************************************************************
    // Get a 'starting' scanline
    //**************************************************************************

    PreviousScanLine = NV_GetScanLineData(ppdev);

    //**************************************************************************
    // The largest resolution (at least for the foreseeable future)
    // will be 2k x 2k.  So wait for 2000 vertical scanlines worth to occur.
    //**************************************************************************

    do
        {
        ULONG   Count=0;

        //**********************************************************************
        // Wait for scanline to advance
        //**********************************************************************

        do
            {
            NextScanLine = NV_GetScanLineData(ppdev);
            Count++;

            //******************************************************************
            // Safety Abort just in case
            //******************************************************************

            if (Count > 10000) goto abort_scan_loop;

            } while (NextScanLine == PreviousScanLine);


        //**********************************************************************
        // If the scan has wrapped, then just add the value of NextScanLine.
        // This is *not* an accurate algorithm but it will get the job done.
        //**********************************************************************

        if (NextScanLine < PreviousScanLine)
            {
            TotalScanLines+=NextScanLine;
            PreviousScanLine = NextScanLine;
            }

        else
            {
            TotalScanLines+=(NextScanLine-PreviousScanLine);
            PreviousScanLine = NextScanLine;
            }


        } while (TotalScanLines < 2000);


abort_scan_loop:

    return;
}





//******************************Public*Routine**********************************
//
// Function: NvHwSpecific
//
// Routine Description:
//
//      This functioin is specific to a Nv chip set to workaround HW problem.
//
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************

VOID NvHwSpecific(PDEV* ppdev)
{
    ULONG ulRetVal;

    // Looking for NV11 Rev. B chip
    NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_CFG_FLAT_PANEL_DITHER_MODE, &ulRetVal );
    if(ulRetVal & NV_CFG_FLAT_PANEL_DITHER_MODE_CAPABLE)
    {
        NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,    
                NV_CFG_FLAT_PANEL_DITHER_MODE, &ulRetVal );             
        if(ulRetVal & NV_CFG_FLAT_PANEL_DITHER_MODE_ENABLED)            
            ppdev->ulWorkAroundHwFlag |=  NV_WORKAROUND_NV11RevB_DIRTHERING;
        else
            ppdev->ulWorkAroundHwFlag &=  ~NV_WORKAROUND_NV11RevB_DIRTHERING;
    }

    // Other chips ...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvptr.c ===
//******************************Module*Header***********************************
//
// Module Name: NVPTR.C
//
// This module contains the hardware pointer support for the display
// driver.  Supports the following classes:
//          NV04_VIDEO_LUT_CURSOR_DAC
//          NV05_VIDEO_LUT_CURSOR_DAC
//          NV10_VIDEO_LUT_CURSOR_DAC
//          NV15_VIDEO_LUT_CURSOR_DAC
//
// Does not support NV3!!
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997-2000 NVidia Corporation. All Rights Reserved.          *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "ddminint.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"
#include "nvcm.h"

#define WORK_AROUND_NV11_DIRTHER                                        \
{                                                                       \
    if(ppdev->ulWorkAroundHwFlag &  NV_WORKAROUND_NV11RevB_DIRTHERING)  \
    {                                                                   \
        return(SPS_DECLINE);                                            \
    }                                                                   \
}

#ifndef NV3

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

#define CURSOR_PIXEL_SIZE 4

#define DESKTOP_MOVING_RATE 20    

#define USE_CURSOR_REGISTER 1
#ifdef USE_CURSOR_REGISTER //[

/*
** 1/10/01 jbaldwin
** This direct register write gains ~2% performance on 2D Winbench 99 BG.  The
** PRAMDAC_CU_START_POS_Reg register is identical from NV3 thru NV20 so this
** direct register write bypassing the class interface isn't quite as bad as
** it would otherwise be.
*/
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                            \
{                                                                           \
    volatile ULONG * PRAMDAC_CU_START_POS_Reg;                              \
                                                                            \
    PRAMDAC_CU_START_POS_Reg = ppdev->PRAMDACRegs + ((ulHead) * 0x2000/4);  \
                                                                            \
    *PRAMDAC_CU_START_POS_Reg = (((x) & 0xffff) | ((y) << 16));             \
}

#else // USE_CURSOR_REGISTER ][

#define USE_DMC_CURSOR 1
// Send the new location directly to HW; new code
#if USE_DMC_CURSOR
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                            \
if (                                                                        \
    NvDirectMethodCall(                                                     \
        ppdev->hDriver,                                                     \
        ppdev->hClient,                                                     \
        ppdev->hDmaChannel,                                                 \
        NV_VIDEO_LUT_CURSOR_DAC+ulHead,                                     \
        NV046_SET_CURSOR_POINT,                                             \
        (x & 0xffff) | (y << 16)                                            \
    ) != NVOS1D_STATUS_SUCCESS                                              \
)                                                                           \
{                                                                           \
    DISPDBG((2, "NVDD: Cannot perform cursor move on %d head", ulHead));    \
}

#else
// Send the new location of cursor into DMA push buffer;  old code
// !!! This code has not been tested yet !!!
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                                                            \
{                                                                                                           \
    DECLARE_DMA_FIFO;                                                                                       \
    INIT_LOCAL_DMA_FIFO;                                                                                    \
    NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));                                                                    \
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulhead);   \
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_POINT, (x & 0xffff) | (y << 16) );        \
    UPDATE_PDEV_DMA_COUNT;                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                 \
}

#endif

#endif // USE_CURSOR_REGISTER ]

//******************************************************************************
//
//  Function:   NvAllocateCursorMem
//
//  Routine Description:
//          Allocating the memory for cursor
//      
//
//  Arguments:
//          ppdev - display driver structure
//          ulBufIndex - double buffer.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL NvAllocateCursorMem(PDEV* ppdev, ULONG ulBufIndex)
{
    if(!ppdev->ulCursorMemOffset[ulBufIndex])
    {
        NvU32 dwStatus;

        // Don't worry offset alignment because RM should take care TYPE_CURSOR
        NVHEAP_ALLOC(dwStatus, ppdev->ulCursorMemOffset[ulBufIndex],  ppdev->ulMaxHwCursorSize * ppdev->ulMaxHwCursorSize * CURSOR_PIXEL_SIZE, TYPE_CURSOR);

        if (dwStatus!=0)
        {
            DISPDBG((2, "NVEnablePointer: Cannot allocate cursor memory"));
            return (FALSE);
        }

        if(NvAllocContextDma(ppdev->hDriver,
                             ppdev->hClient,
                             NV_CONTEXT_DMA_CURSOR+ulBufIndex,
                             NV01_CONTEXT_DMA,
                             NVOS03_FLAGS_ACCESS_READ_WRITE,
                             (PVOID)(ppdev->pjFrameBufbase + ppdev->ulCursorMemOffset[ulBufIndex]),
                             ppdev->ulMaxHwCursorSize * ppdev->ulMaxHwCursorSize * CURSOR_PIXEL_SIZE - 1
                             ))
        {
            DISPDBG((1, "NVEnablePointer: Cannot allocate dma in memory context for cursor"));
            NVHEAP_FREE(ppdev->ulCursorMemOffset[ulBufIndex]);
            ppdev->ulCursorMemOffset[ulBufIndex] = 0;
            return (FALSE);
        }
    }
    return(TRUE);
}

//******************************************************************************
//
//  Function:   NvFreeCursorMem
//
//  Routine Description:
//         Free the cursor memory
//      
//
//  Arguments:
//          ppdev - display driver structure
//          ulBufIndex - double buffer.
//
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void NvFreeCursorMem(PDEV* ppdev, ULONG ulBufIndex)
{

        if(ppdev->ulCursorMemOffset[ulBufIndex])
        {
            if (!(ppdev->flCaps & CAPS_SW_POINTER))
            {
                ppdev->pfnShowPointer(ppdev,FALSE);
                ppdev->pfnWaitEngineBusy(ppdev);
                if (NvFree(  ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_CONTEXT_DMA_CURSOR+ulBufIndex) !=
                    NVOS00_STATUS_SUCCESS )
                {
                    DISPDBG((0, "EnablePointer: Cannot free dma in memory context for cursor"));
                }
                NVHEAP_FREE(ppdev->ulCursorMemOffset[ulBufIndex]);
                ppdev->ulCursorMemOffset[ulBufIndex] = 0;
            }
        }

}




//******************************************************************************
//
//  Function:   NVEnablePointer
//
//  Routine Description:
//
//      Handling Allocate / Free memory for the cursor
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID NVEnablePointer
(
PDEV*               ppdev,
BOOL    bEnable
)
{
    ULONG i, nBuffers;
    ULONG ulHead;
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    if (bEnable)
    {
        for(nBuffers = 0; nBuffers < 2; nBuffers++)
        {
            if(!NvAllocateCursorMem(ppdev, nBuffers))
            {
                ppdev->flCaps |= CAPS_SW_POINTER;
                return;
            }

        	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
        	{
                ulHead = ppdev->ulDeviceDisplay[i];
                NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));  
                NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
                NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_CURSOR(nBuffers), NV_CONTEXT_DMA_CURSOR+nBuffers);
            }
        }
        UPDATE_PDEV_DMA_COUNT;

        //******************************************************************
        // Send data on thru to the DMA push buffer
        //******************************************************************

        if(ppdev->bEnabled)
            NV4_DmaPushSend(ppdev);
        
        // Wait for it to complete.
        ppdev->pfnWaitEngineBusy(ppdev);

    }
    else
    {
        for(i = 0; i < 2; i++)
            NvFreeCursorMem(ppdev, i);
    }
}

//******************************************************************************
//
//  Function:   NvCalNewDisplayWindow
//
//  Routine Description:
//
//      Calculating the display window based on the location of cursor pointer.
//
//  Arguments:
//
//  Return Value:
//
//      True - Moved; FALSE - The location is within Window; Not need to move.
//
//******************************************************************************
BOOLEAN NvCalNewDisplayWindow(
LONG x, LONG y, 
LONG lOutsideLeft, LONG lOutsideTop, LONG lOutsideRight, LONG lOutsideBottom,
ULONG ulMoveDisplayDx, ULONG ulMoveDisplayDy,
RECTL * pWindow)
{

    LONG lNewX1, lNewX2, lNewY1, lNewY2 ;
    BOOLEAN bRet = FALSE;

    lNewX2 = lNewY2 = 0;

    if(x == lOutsideLeft)
    {
        // Reset the X coordinate
        pWindow->right = lOutsideLeft + (pWindow->right - pWindow->left);
        pWindow->left  = lOutsideLeft;
        bRet = TRUE;
    }
    else if(x > pWindow->left)
    {
        if(x < pWindow->right)
        {
            // Inside the view of Display Screen;
            // Do nothing for X;
        }
        else
        {
            if(pWindow->right < lOutsideRight)
            {
                // MOVE display to right
                lNewX2 = pWindow->right + ulMoveDisplayDx;
                while(x > lNewX2)
                    lNewX2 += ulMoveDisplayDx;
                if(lNewX2 > lOutsideRight)
                    lNewX2 = lOutsideRight;
                lNewX1 = lNewX2 - (pWindow->right - pWindow->left);
                pWindow->left = lNewX1;
                pWindow->right = lNewX2;
                bRet = TRUE;
            }
        }
    }
    else
    {
        // MOVE display to left
        if(pWindow->left > lOutsideLeft)
        {
            lNewX1 = pWindow->left - ulMoveDisplayDx;
            while(x < lNewX1)
                lNewX1 -= ulMoveDisplayDx;
            if(lNewX1 < lOutsideLeft)
                lNewX1 = lOutsideLeft;
            lNewX2 = lNewX1 + (pWindow->right - pWindow->left);
            pWindow->left = lNewX1;
            pWindow->right = lNewX2;
            bRet = TRUE;
        }
    }

    // HW restriction Enforcement: Since image offset value is a multiple of 4 bytes.  
    // and this rountine does not deal with 8bpp, 16bpp or 32bpp,
    // set to 4 pixels alignment in order to satisfy HW restriction.
    if(bRet)
        pWindow->left = (pWindow->left + 3) & ~(0x03);

    if(y == lOutsideTop)
    {
        // Reset the Y coordinate
        pWindow->bottom = lOutsideTop + (pWindow->bottom - pWindow->top);
        pWindow->top = lOutsideTop;
        bRet = TRUE;
    }
    else if(y > pWindow->top)
    {
        if(y < (pWindow->bottom) )
        {
            // Inside the view of Display Screen;
            // Do nothing for Y;
        }
        else
        {
            if(pWindow->bottom < lOutsideBottom)
            {
                // Move display down
                lNewY2 = pWindow->bottom + ulMoveDisplayDy;
                while(y > lNewY2)
                    lNewY2 += ulMoveDisplayDy;
                if(lNewY2 > lOutsideBottom)
                    lNewY2 = lOutsideBottom;
                lNewY1 = lNewY2 - (pWindow->bottom - pWindow->top);
                pWindow->top = lNewY1;
                pWindow->bottom = lNewY2;
                bRet = TRUE;
            }
        }
    }
    else
    {
        // MOVE display up
        if(pWindow->top > lOutsideTop)
        {
            lNewY1 = pWindow->top - ulMoveDisplayDy;
            while(y < lNewY1)
                lNewY1 -= ulMoveDisplayDy;
            if(lNewY1 < 0)
                lNewY1 = 0;
            lNewY2 = lNewY1 + (pWindow->bottom - pWindow->top);
            pWindow->top = lNewY1;
            pWindow->bottom = lNewY2;
            bRet = TRUE;
        }
    }

    return(bRet);
}


//******************************************************************************
//
//  Function:   NVMoveDisplayWindow
//
//  Routine Description:
//
//      Move the display window to new location.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void __cdecl NVMoveDisplayWindow(
PDEV*   ppdev,
ULONG   ulHead,
RECTL * prclCurrentDisplay)
{
    ULONG ulPanOffset;
    DECLARE_DMA_FIFO;
    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));  
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulHead);
    ulPanOffset = prclCurrentDisplay->left * ppdev->cjPelSize + prclCurrentDisplay->top * ppdev->lDelta 
                                    + ppdev->ulPrimarySurfaceOffset - ppdev->ulHeadDisplayOffset[ulHead];
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_PAN_OFFSET, ulPanOffset);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), ppdev->lDelta |
        NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
    //******************************************************************
    // Update global push buffer count
    //******************************************************************
    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************
    NV4_DmaPushSend(ppdev);

    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ppdev->pfnWaitEngineBusy(ppdev);

}

//******************************************************************************
//
//  Function:   NVMovePointer
//
//  Routine Description:
//
//      Move the NV hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NVMovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

{
    RECTL * prclCurrentDisplay;
    RECTL * prclDisplayDesktop;
    LONG lOriginalX, lOriginalY;
    ULONG ulHead;
    LONG lOverlayDisabledHead = -1;

    ULONG ulSaveDesktopMode;

    lOriginalX, lOriginalY;

    if(x == -1)
    {
        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
    }

    lOriginalX = x;
    lOriginalY = y;

    ulHead = ppdev->ulDeviceDisplay[0];
    prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
    ulSaveDesktopMode = ppdev->ulDesktopMode;

    if( (ppdev->pDriverData->vpp.dwOverlayFSNumSurfaces != 0))
    {
        // Disable pan & scan because Video is rendering on the head now.
        lOverlayDisabledHead =  ppdev->pDriverData->vpp.dwOverlayFSHead; 
        if( ulHead == (ULONG) lOverlayDisabledHead)
        {
            // Logical head 0
            ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_1);
        }
        else
        {
            // Logical head 1
            ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_2);
        }
    }
#endif
    if(ppdev->ulDesktopMode & NV_VIRTUAL_DESKTOP_1)
    {
        // Primary DAC
        prclDisplayDesktop = &ppdev->rclDisplayDesktop[ulHead];

        if( (x >= prclDisplayDesktop->left) && (x < prclDisplayDesktop->right) && 
            (y >= prclDisplayDesktop->top)  && (y < prclDisplayDesktop->bottom)) 
        {
            if (NvCalNewDisplayWindow(x,y, prclDisplayDesktop->left,  prclDisplayDesktop->top, 
                                         prclDisplayDesktop->right, prclDisplayDesktop->bottom, 
                                         ppdev->ulMoveDisplayDx, 
                                         ppdev->ulMoveDisplayDy, 
                                         prclCurrentDisplay))
            {
                NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
            }
        }
    }

    if(!ppdev->ulPuntCursorToGDI)
    {
        // Don't worry to move the cursor pointer; GDI Software cursor pointer
        x -= ppdev->xPointerHot;
        x -= prclCurrentDisplay->left;
        y -= ppdev->yPointerHot;
        y -= prclCurrentDisplay->top;
        
        if( ulHead != (ULONG) lOverlayDisabledHead)
        {
            SET_CURSOR_LOCATION(ppdev, ulHead, x, y);
        }
    }

    if(ppdev->ulDesktopMode & NV_TWO_DACS)
    {
        x = lOriginalX;
        y = lOriginalY;

        ulHead = ppdev->ulDeviceDisplay[1];
        prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];

        if(ppdev->ulDesktopMode & NV_VIRTUAL_DESKTOP_2)
        {
            // Secondary DAC
            prclDisplayDesktop = &ppdev->rclDisplayDesktop[ulHead];

            if( (x >= prclDisplayDesktop->left) && (x < prclDisplayDesktop->right) && 
                (y >= prclDisplayDesktop->top)  && (y < prclDisplayDesktop->bottom)) 
            {
                if (NvCalNewDisplayWindow(x,y, prclDisplayDesktop->left,  prclDisplayDesktop->top, 
                                         prclDisplayDesktop->right, prclDisplayDesktop->bottom, 
                                         ppdev->ulMoveDisplayDx, 
                                         ppdev->ulMoveDisplayDy, 
                                         prclCurrentDisplay))
                {
                    NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
                }
            }
        }

        if(!ppdev->ulPuntCursorToGDI)
        {
            // Don't worry to move the cursor pointer; GDI Software cursor pointer
            x -= ppdev->xPointerHot;
            x -= prclCurrentDisplay->left;
            y -= ppdev->yPointerHot;
            y -= prclCurrentDisplay->top;

            if( ulHead != (ULONG) lOverlayDisabledHead)
            {
                SET_CURSOR_LOCATION(ppdev, ulHead, x, y);
            }
        }

    }

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
    // restore the Desktop mode
    ppdev->ulDesktopMode = ulSaveDesktopMode;
#endif
}

//******************************************************************************
//
//  Function:   NvSwMonoToHw16BppCursor
//
//  Routine Description:
//  Handle Mono cursor in 16Bpp HW cursor mode (Alpha1?Cur:Cur^Bkgnd).
//
// USING A1R5G5B5 16 bits format
// Translate to black and white format for DAC
// Expand 32 x 32 x 1  (monochrome source ) to 32 x 32 x 16 CursorColorImage
//
// We're going to take the requested pointer AND masks and XOR
// masks and combine them into our work buffer,
//
//              Monochrome Source
//              -----------------
//
//         Byte0   Byte1   Byte2   Byte3
//  0    |       |       |       |       |
//  1    |       |       |       |       |         (monochrome source)
//  2    |       |       |       |       |     Total of 128 bytes per plane
//  3    |       |       |       |       |
//                      etc..
//
//  31   |       |       |       |       |
//
//
//
//              Color Destination
//              -----------------
//
//         Word0   Word1   ....    Word31
//  0    |       |       |       |       |
//  1    |       |       |       |       |         (color destination)
//  2    |       |       |       |       |      Total 32*32*2 bytes
//  3    |       |       |       |       |
//                      etc..
//
//  31   |       |       |       |       |
//
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
void Nv1BppToHw16BppCursor(LONG cx, LONG cy, BYTE* pjSrcScan, ULONG *pulDstScan, 
ULONG ulHwCursorWidth, LONG lSrcDelta, LONG lDstDelta)
{
    int i, j, k;
    BYTE    bMask, bMono;
    ULONG ulDwordCount, ulColor, ulTemp, ulTest;
    LONG    lPixelCountPerLine;

    for(i = 0; i < cy; i++)
    { 
        ulDwordCount = 0;
        lPixelCountPerLine = 0;
        for(j = 0; j < lDstDelta && lPixelCountPerLine < cx; j++)            // in term of bytes
        {
            bMask = pjSrcScan[i * lSrcDelta + j];           // Get a Mask byte (8 pixels)
            bMono = pjSrcScan[ (cy + i) * lSrcDelta + j];   // Get a Mono byte (8 pixels)

            //**************************************************************
            // Now combine the masks according to the AND-XOR Microsoft convention
            //
            //  ('mask' value)      ('mono' value)
            //  AND mask value      XOR mask value      Result on screen
            //  --------------      --------------      ----------------
            //          0               0               Black
            //          0               1               White
            //          1               0               Transparent, pixel unchanged
            //          1               1               Inverts the pixel color
            //
            // We'll parse the pixels from right to left in source
            // (Bit 0 is leftmost in mono image).  This will cause
            // us to bit flip the cursor image and draw it correctly
            //**************************************************************

            ulTest = 0x80;
            for (k = 0; k < 8; k++, ulTest >>= 1)
            {
                if (ulTest & bMono)        // Test this bit
                    ulColor = 0x7fff;     // White
                else
                    ulColor = 0;          // Black

                if (!(ulTest & bMask))
                    ulColor |= 0x8000;    // Not transparent


                //**********************************************************
                // Store 16 bits for NV cursor image data
                //**********************************************************
                if(k & 1)
                {
                    ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                    *pulDstScan++ = ulTemp;
                    ulDwordCount++;
                }
                else
                {
                    ulTemp = ulColor;
                }
                // Before next pixel, 1 byte (mono) is for 8 pixels.  
                // When it is over the width of cursor, quit but check last pixel
                // whether it has been written.
                if( (++lPixelCountPerLine) > cx)
                {
                    if(!(k & 1))
                    {
                        *pulDstScan++ = ulTemp;
                        ulDwordCount++;
                    }
                    break;
                }
            }
        }   // End of j loop

        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }   // End of i loop
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
}

//******************************************************************************
ULONG Nv8BppToHw16BppCursor(PDEV* ppdev, PPALETTEENTRY pPal, XLATEOBJ*   pxlo, LONG cx, LONG cy, 
BYTE* pjSrcColor, BYTE* pjSrcColorMask, ULONG *pulDstScan, ULONG ulHwCursorWidth, 
LONG lSrcDelta, LONG lPitch)
{
    int i, j, k;
    ULONG ulMask;
    ULONG ulDwordCount, ulColor, ulTemp, ulTest;
    WORD    red;
    WORD    green;
    WORD    blue;
    PALETTEENTRY pXlatePal[256];

    //**************************************************************
    // We gotta look up the color from the palette to
    // convert to RGB. Try to get info from the XLATEOBJ
    // first.
    //**************************************************************
//    pPal = ppdev->pPal;     // Default to using pal from PDEV
    if (pxlo != NULL)
    {
        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
        {
            //******************************************************
            // Get the RGB palette.
            //******************************************************
            if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                pPal = pXlatePal;
        }
    }
    for (i = 0; i < cy; i++)
    {
        ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
        ulTest = 0x00000080;
        ulDwordCount = 0;
        for (k = 0; k < cx; k++, ulTest >>=1)
        {
            if (!(k & 7))
                ulTest = 0x00000080 << k;
            ulColor = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
            blue  = pPal[ulColor].peBlue;
            green = pPal[ulColor].peGreen;
            red   = pPal[ulColor].peRed;
            ulColor = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
            if (!(ulTest & ulMask))
            {
                ulColor |= 0x8000;              // Not transparent
            }
            else
            {
                if(ulColor == 0x7FFF)
                {
                    // inverted background color
                    WORK_AROUND_NV11_DIRTHER;
                }
                else
                {
				        // Transparent
                }
            }

            //******************************************************
            // Store 16 bits for NV cursor image data
            //******************************************************
            if(k & 1)
            {
                ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                *pulDstScan++ = ulTemp;
                ulDwordCount++;
            }
            else
            {
                ulTemp = ulColor;
            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
    return(SPS_ACCEPT_NOEXCLUDE);
}

//******************************************************************************
ULONG Nv16BppToHw16BppCursor(PDEV* ppdev, LONG cx, LONG cy, BYTE* pjSrcColor, BYTE* pjSrcColorMask, 
    LONG lSrcDelta, LONG lPitch, ULONG*  pulDstScan, ULONG ulHwCursorWidth, FLONG flGreen)
{
    ULONG ulMask, ulTest;
    WORD    red;
    WORD    green;
    WORD    blue;
    LONG    i,j,k;
    ULONG*  pulTemp;
    ULONG   ulTemp, ulColor, ulDwordCount;

    for (i = 0; i < cy; i++)
    {
        ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
        ulTest = 0x00000080;
        ulDwordCount = 0;
        for (k = 0; k < cx; k++, ulTest >>=1)
        {
           if (!(k & 7))
               ulTest = 0x00000080 << k;

           if (flGreen == 0x03e0)
           {
                //**************************************************
                // For 555: We can use the source color as is
                //          since the color cursor is always 555
                //**************************************************
                ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 15 bits of color
           }
           else
           {
                //**************************************************
                // For 565: Convert from 565 bitmap format to 555
                //          since the color cursor is always 555
                //**************************************************
                ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                red   = (WORD)(ulColor & 0xf800); // 5 bits
                green = (WORD)(ulColor & 0x07c0); // Just take top 5 of 6 bits !
                blue  = (WORD)(ulColor & 0x001f); // 5 bits
                ulColor = (  (red >> 1 ) | (green >> 1 ) | (blue) );
           }

           if (!(ulTest & ulMask))
                 ulColor |= 0x8000;                // Not transparent
           else
           {
                if(ulColor == 0x7FFF)
                {
                    // inverted background color
                    WORK_AROUND_NV11_DIRTHER;
                }
                else
                {
				        // Transparent
                }
           }
          

           //******************************************************
           // Store 16 bits for NV cursor image data
           //******************************************************
            if(k & 1)
            {
                ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                *pulDstScan++ = ulTemp;
                ulDwordCount++;
            }
            else
            {
                ulTemp = ulColor;
            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}


//******************************************************************************
//
//  Function:   NvHw16BppCursor
//
//  Routine Description:
//
//      The cursor has some pixels to be inverted back ground color
//      handle it in 16BPP mode of cursor
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
void NvHw16BppCursor(LONG cx, LONG cy, BYTE* pjSrcColor, BYTE* pjSrcColorMask, 
    LONG lSrcDelta, LONG lPitch, ULONG*  pulDstScan, ULONG ulHwCursorWidth, BOOL AlphaBlendedCursor)
{

    BYTE    bMask, bTest;
    WORD    wRed, wGreen, wBlue;
    LONG    i,j,k;
    ULONG*  pulTemp;
    ULONG   ulTemp, ulColor, ulDwordCount;
    LONG    lPixelCountPerLine;


    for (i = 0; i < cy; i++) 
    {
        ulDwordCount = 0;
        lPixelCountPerLine = 0;
        pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
        for (j = 0; j < cx ; j += 8) 
        {
            bMask = 0;
            if(!AlphaBlendedCursor)
            {
                // Not a alpha cursor; use get the mask
                bMask = *(pjSrcColorMask + i*lSrcDelta + j / 8);  
            }

            bTest = 0x80;
            for(k = 0; k < 8; k++, bTest >>= 1) 
            {
                ulColor = *pulTemp++;

                if(AlphaBlendedCursor)
                {
                    // Check alpha value of each pixel to determinie the transparenet
                    if( (ulColor & 0xFF000000) == 0xFF000000)
                    {
                        // New Cursor Color
                    }
                    else
                    {
                        // Really want to use the backgroup color
                        // clear the mask bit so that it will get the backgroup color.
                        bMask |= bTest;
                    }
                }

                if(!(bTest & bMask))
                {
                    wRed   = (WORD)(((ulColor & 0xFF0000) >> 16) * 32 / 256); // 5 bits
                    wRed   <<= 10;
                    wGreen = (WORD)(((ulColor & 0x00FF00) >> 8 ) * 32 / 256); // 5 bits
                    wGreen <<= 5;
                    wBlue  = (WORD)(((ulColor & 0x0000FF)      ) * 32 / 256); // 5 bits
                
                    ulColor = 0x8000 | wRed | wGreen | wBlue;
                }
                else
                {
				    if (ulColor == 0x00FFFFFF)
					{
                        // inverted background color
                        ulColor = 0x7FFF; 
					}
					else 
					{
				        // Transparent
						ulColor = 0;
					}
                }

                //**********************************************************
                // Store 16 bits for NV cursor image data
                //**********************************************************
                if(k & 1)
                {
                    ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                    *pulDstScan++ = ulTemp;
                    ulDwordCount++;
                }
                else
                {
                    ulTemp = ulColor;
                }

                // Before next pixel, 1 byte (mono) is for 8 pixels.  
                // When it is over the width of cursor, quit but check last pixel
                // whether it has been written.
                if( (++lPixelCountPerLine) > cx)
                {
                    if(!(k & 1))
                    {
                        *pulDstScan++ = ulTemp;
                        ulDwordCount++;
                    }
                    break;
                }

            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }

    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
    
}

//******************************************************************************
//
//  Function:   NVSetPointerShapeToHw
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void NvSetPointerShapeToHw(PDEV * ppdev,  ULONG ulHwCursorWidth, ULONG ulHwCursorHeight, ULONG ulHwCursorFormat)
{
    DECLARE_DMA_FIFO;
    
    ppdev->ulCachedCursorWidth = ulHwCursorWidth;
    ppdev->ulCachedCursorFormat = ulHwCursorFormat;
	INIT_LOCAL_DMA_FIFO;
    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));  

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ppdev->ulDeviceDisplay[0]);

	NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_OFFSET(ppdev->ulCursorCurBufIndex), 0);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_FORMAT(ppdev->ulCursorCurBufIndex), 
    	 (ulHwCursorFormat << 16) |
	     (ulHwCursorHeight << 8) | ulHwCursorWidth);

    if(ppdev->ulDesktopMode & NV_TWO_DACS)
	{
        NV_DMAPUSH_CHECKFREE( ((ULONG)(8)));
	    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(ppdev->ulCursorCurBufIndex) ,   NV_VIDEO_LUT_CURSOR_DAC+ppdev->ulDeviceDisplay[1]);

        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_OFFSET(ppdev->ulCursorCurBufIndex), 0);

    	NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_FORMAT(ppdev->ulCursorCurBufIndex), 
        	 (ulHwCursorFormat << 16) |
	         (ulHwCursorHeight << 8) | ulHwCursorWidth);

        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC);
	}

	//******************************************************************
    // Update global push buffer count
	//******************************************************************
    
    UPDATE_PDEV_DMA_COUNT;

	//******************************************************************
    // Send data on thru to the DMA push buffer
	//******************************************************************

	NV4_DmaPushSend(ppdev);
}



//******************************************************************************
//
//  Function:   NVSetPointerShapeOn16BppHwMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NVSetPointerShapeOn16BppHwMode(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)
{
    PDEV*   ppdev;
    
    BYTE    bMono, bMask;
    BYTE    bTest;

    LONG    lPixelCount;
    LONG    i,j,k;
    LONG    lSrcDelta = 0;
    LONG    lDstDelta = 0;
    
    ULONG   ulDwordCount;    
    ULONG   ulTest; 
    ULONG   ulColor;
    ULONG   ulAlpha;
    ULONG   ulTemp;
    ULONG   ulHwCursorWidth;      // HW : 32 or 64
    ULONG   ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;

    BYTE*    pjSrcScan;           // BYTE * because GDI may give us on byte alignment
    ULONG*   pulDstScan;          // ULONG * for performance

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;

    if ( AlphaBlendedCursor && globalOpenGLData.oglDrawableClientCount )
    {
        //******************************************************************
        // For alpha blended cursors when an OpenGL window is open,
        // we convert it to a hardware mono cursor. 
        // if alpha blended cursors come thru with cx > ppdev->ulMaxHwCursorSize or cy > ppdev->ulMaxHwCursorSize, 
        // they'll get clipped
        //******************************************************************

        if (cx > (LONG)(ppdev->ulMaxHwCursorSize) )
            cx = ppdev->ulMaxHwCursorSize;
            
        if (cy > (LONG)(ppdev->ulMaxHwCursorSize) )
            cy = ppdev->ulMaxHwCursorSize;            
    }
    else 
    {
        if(AlphaBlendedCursor)
        {
            // Not alpha cursor support on 16Bpp mode.
            return(SPS_DECLINE);
        }

        if ( (cx > (LONG)(ppdev->ulMaxHwCursorSize))  ||  (cy > (LONG)(ppdev->ulMaxHwCursorSize)) ) {
            DISPDBG((5, "NVSetPointerShape: Unsupported size"));          
            return(SPS_DECLINE);
        }
    }

    if(cx > 32)
        ulHwCursorWidth = 64;
    else
        ulHwCursorWidth = 32; 
    
    pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);

    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)
    {

        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        lDstDelta = (cx + 7) / 8;
         
        Nv1BppToHw16BppCursor(cx, cy, pjSrcScan, pulDstScan, ulHwCursorWidth, lSrcDelta, lDstDelta);

        DISPDBG((5, "NVSetPointerShape: Mono Cursor"));

    }   // Draw monochrome cursor (psoColor == NULL)
    else
    {
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL) {
            
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN) {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
            } else {
                // (pdsurfSrc->dt == DT_DIB)
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
            }

        } else if (psoColor->pvScan0 != NULL) {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
        } else {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL) {
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
        }
            
        switch (iSrcBitDepth)
        {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:
                Nv8BppToHw16BppCursor(ppdev, ppdev->pPal, pxlo, cx, cy, 
                    pjSrcColor, pjSrcColorMask, pulDstScan, ulHwCursorWidth, 
                    lSrcDelta, lPitch);
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************
            case BMF_16BPP:
                Nv16BppToHw16BppCursor(ppdev, cx, cy, pjSrcColor, pjSrcColorMask, 
                     lSrcDelta, lPitch,  pulDstScan,  ulHwCursorWidth, ppdev->flGreen);

                break;
            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************
            case BMF_32BPP:
                // Converted to 16Bpp for HW.

                NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                    (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                DISPDBG((5, "NVSetPointerShape: Unsupported bit depth"));
                return(SPS_DECLINE);

        }   // Switch
    } // psoColor != NULL

    DISPDBG((5, "NVSetPointerShape: Width or format changed.  Reloading."));
    NvSetPointerShapeToHw(ppdev,  ulHwCursorWidth, cy, ulHwCursorFormat);
    ppdev->ulCursorCurBufIndex ^= 1;
	
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ppdev->pfnMovePointer(ppdev, x, y);

    return(SPS_ACCEPT_NOEXCLUDE);

}

//******************************************************************************
//
//  Function:   NVSetPointerShapeOn32BppHwMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NVSetPointerShapeOn32BppHwMode(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)
{
    PDEV*   ppdev;
    
    BYTE    bMono, bMask;
    BYTE    bTest;

    LONG    lPixelCount;
    LONG    i,j,k;
    LONG    lSrcDelta = 0;
    LONG    lDstDelta = 0;
    
    ULONG   ulDwordCount;    
    ULONG   ulTest; 
    ULONG   ulColor;
    ULONG   ulAlpha;
    ULONG   ulTemp;
    ULONG   ulHwCursorWidth;      // HW : 32 or 64
    // All 32Bpp cursor are done on PM_LE_A8R8G8B8 except the inverted background color cursor.
    ULONG   ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 

    BYTE*    pjSrcScan;           // BYTE * because GDI may give us on byte alignment
    ULONG*   pulDstScan;          // ULONG * for performance

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;

    if ( AlphaBlendedCursor && globalOpenGLData.oglDrawableClientCount )
    {
        //******************************************************************
        // For alpha blended cursors when an OpenGL window is open,
        // we convert it to a hardware mono cursor. 
        // if alpha blended cursors come thru with cx > ppdev->ulMaxHwCursorSize or cy > ppdev->ulMaxHwCursorSize, 
        // they'll get clipped
        //******************************************************************

        if (cx > (LONG)(ppdev->ulMaxHwCursorSize) )
            cx = ppdev->ulMaxHwCursorSize;
            
        if (cy > (LONG)(ppdev->ulMaxHwCursorSize) )
            cy = ppdev->ulMaxHwCursorSize;            
    }
    else 
    {
        if ( (cx > (LONG)(ppdev->ulMaxHwCursorSize))  ||  (cy > (LONG)(ppdev->ulMaxHwCursorSize)) ) {
            DISPDBG((5, "NVSetPointerShape: Unsupported size"));
            return(SPS_DECLINE);
        }
    }

    if(cx > 32)
        ulHwCursorWidth = 64;
    else
        ulHwCursorWidth = 32; 
    
    pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);

    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)
    {
        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        lDstDelta = (cx + 7) / 8;
         
        for(i = 0; i < cy; i++)
        { 
            ulDwordCount = 0;
            for(j = 0; j < lDstDelta; j++)                 // in term of bytes
            {
                bMask = pjSrcScan[i * lSrcDelta + j];           // Get a Mask byte (8 pixels)
                bMono = pjSrcScan[ (cy + i) * lSrcDelta + j];   // Get a Mono byte (8 pixels)

                //**************************************************************
                // Now combine the masks according to the AND-XOR Microsoft convention
                //
                //  ('mask' value)      ('mono' value)
                //  AND mask value      XOR mask value      Result on screen
                //  --------------      --------------      ----------------
                //          0               0               Black
                //          0               1               White
                //          1               0               Transparent, pixel unchanged
                //          1               1               Inverts the pixel color
                //
                // We'll parse the pixels from right to left in source
                // (Bit 0 is leftmost in mono image).  This will cause
                // us to bit flip the cursor image and draw it correctly
                //**************************************************************

                ulTest = 0x80;
                for (k = 0; k < 8; k++, ulTest >>= 1)
                {
                    if ((ulTest & bMask))
                    {
                        if (ulTest & bMono)             // Test this bit
                        {
                            // inverted background color
                            pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);
                            WORK_AROUND_NV11_DIRTHER;
                            Nv1BppToHw16BppCursor(cx, cy, pjSrcScan, 
                                pulDstScan, ulHwCursorWidth, lSrcDelta, lDstDelta);
                            ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                            goto NvCursorDoneImage;
                        }
                        else
                        {
                            ulColor = 0;                // transparent
                        }
                    }
                    else
                    {
                        if (ulTest & bMono)             // Test this bit
                            ulColor = 0xffffffff;         // White
                        else
                            ulColor = 0xff000000;                // Black
                    }

                    *pulDstScan++ = ulColor;
                    ulDwordCount++;
                }
            }   // End of j loop

            // make HW happy, fill remaining DWORD to ulHwCursorWidth
            while(ulDwordCount < ulHwCursorWidth)
            {
                *pulDstScan++ = 0x0;
                ulDwordCount++;
            }
        }   // End of i loop
        DISPDBG((5, "NVSetPointerShape: Mono Cursor"));
    }   // Draw monochrome cursor (psoColor == NULL)
    else
    {
        WORD    red;
        WORD    green;
        WORD    blue;
        WORD    alpha;
        ULONG   ulMask;
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        ULONG*  pulTemp;
        PALETTEENTRY pXlatePal[256];
        PPALETTEENTRY pPal;
    
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL) {
            
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN) {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
            } else {
                // (pdsurfSrc->dt == DT_DIB)
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
            }

        } else if (psoColor->pvScan0 != NULL) {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
        } else {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL) {
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
        }
            
        switch (iSrcBitDepth)
        {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:

            #ifdef HW_SUPPORT_32BPP_XOR
            !!!  Will enable later on for new chip (NV20 and later)
            !!!  set new format for 32Bpp XOR function
            !!!  set the format
            !!!  ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 
            
        
                //**************************************************************
                // We gotta look up the color from the palette to
                // convert to RGB. Try to get info from the XLATEOBJ
                // first.
                //**************************************************************
                pPal = ppdev->pPal;     // Default to using pal from PDEV
                if (pxlo != NULL)
                {
                    if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
                    {
                        //******************************************************
                        // Get the RGB palette.
                        //******************************************************
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                            pPal = pXlatePal;
                    }
                }
                for (i = 0; i < cy; i++)
                {
                    ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    ulTest = 0x00000080;
                    ulDwordCount = 0;
                    for (k = 0; k < cx; k++, ulTest >>=1)
                    {
                        if (!(k & 7))
                            ulTest = 0x00000080 << k;
                        ulColor = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
                        blue  = pPal[ulColor].peBlue;
                        green = pPal[ulColor].peGreen;
                        red   = pPal[ulColor].peRed;
                        ulColor = ( (DWORD)(red & 0xf8) << 13) | ((green & 0xf8) << 5) | ((blue & 0xf8) >> 3);

                        if (!(ulTest & ulMask))
                            ulColor |= 0xff000000;      // Not transparent
                        else
                            ulColor = 0;                // transparent

                        *pulDstScan++ = ulColor;
                        ulDwordCount++;
                    }
                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                    while(ulDwordCount < ulHwCursorWidth)
                    {
                        *pulDstScan++ = 0x0;
                        ulDwordCount++;
                    }
                }
                DISPDBG((5, "NVSetPointerShape: 8bpp Cursor"));
            #else
                if(Nv8BppToHw16BppCursor(ppdev, ppdev->pPal, pxlo, cx, cy, 
                    pjSrcColor, pjSrcColorMask, pulDstScan, ulHwCursorWidth, 
                    lSrcDelta, lPitch)
                     == SPS_DECLINE)
                    return(SPS_DECLINE);
                ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                goto NvCursorDoneImage;
            #endif
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************
            case BMF_16BPP:
            #ifdef HW_SUPPORT_32BPP_XOR
            !!!  Will enable later on for new chip (NV20 and later)
            !!!  set new format for 32Bpp XOR function
            !!!  ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 
                for (i = 0; i < cy; i++)
                {
                    ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    ulTest = 0x00000080;
                    ulDwordCount = 0;
                    for (k = 0; k < cx; k++, ulTest >>=1)
                    {
                       if (!(k & 7))
                           ulTest = 0x00000080 << k;

                       ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                       red   = (WORD)((ulColor & 0xf800) >> 11); // 5 bits
                       green = (WORD)((ulColor & 0x07e0) >> 5); // 6 bits
                       blue  = (WORD)(ulColor & 0x001f); // 5 bits
                       ulColor = (  (DWORD)(red << 16) | (green << 8) | (blue) );

                        if (!(ulTest & ulMask))
                            ulColor |= 0xff000000;      // Not transparent
                        else
                            ulColor = 0;                // transparent

                        *pulDstScan++ = ulColor;
                        ulDwordCount++;

                    }
                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                    while(ulDwordCount < ulHwCursorWidth)
                    {
                        *pulDstScan++ = 0x0;
                        ulDwordCount++;
                    }
                }
                DISPDBG((5, "NVSetPointerShape: 16bpp Cursor"));
            #else
                if(Nv16BppToHw16BppCursor(ppdev, cx, cy, pjSrcColor, pjSrcColorMask, 
                     lSrcDelta, lPitch,  pulDstScan,  ulHwCursorWidth, ppdev->flGreen)
                     == SPS_DECLINE)
                    return(SPS_DECLINE);
                ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                goto NvCursorDoneImage;
            #endif

                break;
            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************
            case BMF_32BPP:
                if (ppdev->ulMaxHwCursorDepth >= 32) {
                    if(AlphaBlendedCursor) {
                        if (ppdev->bSupportAlphaCursor) {
                            // NV11, NV15 and up have full 32bit, alpha cursor support

                            for (i = 0; i < cy; i++) {
                                pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                                for (k = 0; k < cx; k++) {
                                    *pulDstScan++ =  *pulTemp++;
                                }
                                // make HW happy, fill remaining DWORD to ulHwCursorWidth
                                for( ; k < (LONG)ulHwCursorWidth; k++) {
                                    *pulDstScan++ = 0x0;
                                }
                            }
                            DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor"));
                        } else {
                            // If we have no alpha cursor support in hardware AND opengl 
                            // or an overlay is present, support the cursor in hardware
                            // by ignoring the alpha componenet.  This prevents the cursor
                            // from disappearing due to a GDI software cursor getting
                            // overwritten by opengl or the overlay.
                            if (globalOpenGLData.oglDrawableClientCount 
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
                                || ppdev->pDriverData->vpp.dwOverlaySurfaces
#endif          
                                ) {
                                for (i = 0; i < cy; i++) {
                                    pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                                    for (k = 0; k < cx; k++) {
                                        ulAlpha = *pulTemp;
                                        ulAlpha >>= 24;
                                        // Removed Alpha Value
                                        if(ulAlpha == 0xFF) {
                                            ulColor = *pulTemp | 0xFF000000;
                                        } else {
                                            ulColor = 0x00000000;
                                        }
                                        *pulDstScan++ = ulColor;
                                        pulTemp++;
                                    }
                                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                                    for( ; k < (LONG)ulHwCursorWidth; k++) {
                                        *pulDstScan++ = 0x0;
                                    }
                                }                        
                            } else {
                                DISPDBG((5, "NVSetPointerShape: No 32bpp Alpha Support"));
                                return(SPS_DECLINE);
                            }
                            DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor w/ no alpha"));
                        }
                    } else {
                        // Regular 32 bit cursor
                        for (i = 0; i < cy; i++) {
                            lPixelCount = 0;
                            pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                            for (j = 0; j < cx ; j += 8) {
                                bMask = *(pjSrcColorMask + i*lSrcDelta + j / 8);  
                                bTest = 0x80;
                                for(k = 0; k < 8; k++, bTest >>= 1) {
                                    ulColor = *pulTemp++;

                                    if(!(bTest & bMask)) 
                                    {
                                        ulColor |= 0xFF000000;
                                    }
                                    else 
                                    {
                                	    if (ulColor == 0x00FFFFFF)
                    					{
                                            // inverted background color
                                            WORK_AROUND_NV11_DIRTHER;
                                            NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                                                (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                                            ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                                            goto NvCursorDoneImage;
                    					}
					                    else 
                    					{
				                            // Transparent
                    						ulColor = 0;
					                    }
                                    }

                                    *pulDstScan++ = ulColor;

                                    lPixelCount++;
                                }
                            }
                            // make HW happy, fill remaining DWORD to ulHwCursorWidth
                            for( ; lPixelCount < (LONG)ulHwCursorWidth; lPixelCount++)
                            {
                                *pulDstScan++ = 0x0;
                            }
                        }
                        DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor w/ no alpha"));
                    }
                } 
                else 
                {
                    WORK_AROUND_NV11_DIRTHER;
                    NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                        (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                    ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                    goto NvCursorDoneImage;
                }
                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                DISPDBG((5, "NVSetPointerShape: Unsupported bit depth"));
                return(SPS_DECLINE);

        }   // Switch
    } // psoColor != NULL

    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }

NvCursorDoneImage:

    if(ulHwCursorWidth  != ppdev->ulCachedCursorWidth ||
       ulHwCursorFormat != ppdev->ulCachedCursorFormat)
    {
        DISPDBG((5, "NVSetPointerShape: Width or format changed.  Reloading."));
        NvSetPointerShapeToHw(ppdev,  ulHwCursorWidth, cy, ulHwCursorFormat);
    }
    else
    {
        volatile ULONG * pCursorAddress;
        ULONG ulCursorOffset;
        ULONG i, ulHead;
        
      	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
       	{
            ulHead = ppdev->ulDeviceDisplay[i];
            pCursorAddress = ppdev->NvBaseAddr + 0x0060080c / 4 + ((ulHead) * 0x2000/4);
            ulCursorOffset = ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex];
            *pCursorAddress = ulCursorOffset;
        }
        
    }
    ppdev->ulCursorCurBufIndex ^= 1;
	
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ppdev->pfnMovePointer(ppdev, x, y);

    return(SPS_ACCEPT_NOEXCLUDE);

}


void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable)
{
#if !USE_DMC_CURSOR
    DECLARE_DMA_FIFO;
    INIT_LOCAL_DMA_FIFO;
#endif

    if(ulDiable)
    {
#if USE_DMC_CURSOR
        SET_CURSOR_LOCATION(ppdev, ulHead, (ppdev->cxScreen + 64), (ppdev->cyScreen + 64));
#else        
        NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_POINT, ((ppdev->cxScreen + 64) & 0xffff) | ((ppdev->cyScreen + 64) << 16) );

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
#endif        
    }
}

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclient.c ===
/******************************Module*Header*******************************\
* Module Name: oglclients.c
*
* This module contains the functions to support the OpenGL clients.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

//******************************************************************************
//
//  Function: FindClientListFromClientInfo
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientListFromClientInfo(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    if (clientInfo)
        {
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node)
            {
            if (clientInfo == &node->clientInfo)
                {
                return(node);
                break;
                }
            node = node->next;
            }
        // Although this happens in DrvClipChanged after the ICD destroyed
        // the servers client info, it's a bug to work on invalidated data!
        DISPDBG((1, "WARNING in OglFindClientListFromClientInfo: invalid clientInfo: 0x%p", clientInfo));
        }

    return(NULL);
    }

//******************************************************************************
//
//  Function: OglAppendToClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglAppendToClientInfoList(
PDEV    *ppdev, 
DWORD   flags,                               // bits indicating allocated/free resources
HDRVOBJ hDrvObj,                             // driver object handle for this client
NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, // drawable information for this client
NV_OPENGL_CONTEXT_INFO  *clientContextInfo)  // context information for this client
    {
    NV_OPENGL_CLIENT_INFO_LIST *newNode, *node;
 
    if (globalOpenGLData.oglClientCount >= MAX_OGL_CLIENTS)
    {
        DISPDBG((2, "OglAppendToClientInfoList: Too many OpenGL clients"));
        return NULL;
    }

    newNode = EngAllocMem(FL_ZERO_MEMORY, sizeof(NV_OPENGL_CLIENT_INFO_LIST), ALLOC_TAG);
    if (newNode == NULL)
        {
        OglDebugPrint("OglAppendToClientInfoList - Failed EngAllocMem");
        return(FALSE);
        }
    memset(newNode, 0, sizeof(NV_OPENGL_CLIENT_INFO_LIST));

    newNode->refCount++;
    newNode->next                          = NULL;
    newNode->clientInfo.flags              = flags;
    newNode->clientInfo.hDrvObj            = hDrvObj;
    newNode->clientInfo.modeSwitchCount    = ppdev->dwGlobalModeSwitchCount;
    newNode->clientInfo.clientDrawableInfo = clientDrawableInfo;
    newNode->clientInfo.clientContextInfo  = clientContextInfo;
    newNode->clientInfo.dwProcessID        = GetCurrentProcessID();

    if (NULL == globalOpenGLData.oglClientListHead.clientList)
        {
        globalOpenGLData.oglClientListHead.clientList = newNode;
        }
    else
        {
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node->next)
            {
            node = node->next;
            }
        node->next = newNode;
        }

    OglIncClientCount(ppdev);
    return(newNode);
    }

//******************************************************************************
//
//  Function: OglRemoveFromClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void OglRemoveFromClientInfoList(
PDEV *ppdev, 
NV_OPENGL_CLIENT_INFO_LIST *toFree)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node, *parNode;

    if (toFree == NULL ||
        ppdev == NULL ||
        globalOpenGLData.oglClientListHead.clientList == NULL)
        {
        return;
        }

    if (toFree->clientInfo.pwo)
        {
        // Although it's not allowed to call that here, I need to invalidate the pwo because we
        // still get called with this client, but we delete it here.
        // reproduce: run quadroview on nt5 and open a model -> page fault
        // however: will work most of the time, dunno why ?!?! [WNDOBJ_vSetConsumer() is just setting the pvConsumer entry // maybe windows is using the pvConsumer somehow ?!?!]
#if 0
        WNDOBJ_vSetConsumer(toFree->clientInfo.pwo, NULL);
#endif
        }

    if (toFree == globalOpenGLData.oglClientListHead.clientList)
        {
        if (globalOpenGLData.oglClientListHead.clientList)
            {
            globalOpenGLData.oglClientListHead.clientList->refCount--;
            if (globalOpenGLData.oglClientListHead.clientList->refCount == 0)
                {
                //
                // Long explanation:
                //    refCount is used to indicate that multiple PDEVs
                //    are using globalOpenGLData.oglClientListHead.clientList.
                //    If refCount > 0 then we cannot free the memory but
                //    we can set globalOpenGLData.oglClientListHead.clientList to
                //    NULL.  If refCount == 0 then we can free the memory
                //    associated with globalOpenGLData.oglClientListHead.clientList
                //    and set it to NULL.
                //
                //    It is very important to remember that the pointer
                //    and memory associated with globalOpenGLData.oglClientListHead.clientList
                //    maybe be shared between two different PEVs.  Multiple
                //    PDEVs get access to one globalOpenGLData.oglClientListHead.clientList
                //    in ResetPDEV (enable.c).
                //
                globalOpenGLData.oglClientListHead.clientList = 
                    globalOpenGLData.oglClientListHead.clientList->next;
                EngFreeMem(toFree); // free memory
                OglDecClientCount(ppdev);
                }
            }
        }
    else
        {
        parNode = globalOpenGLData.oglClientListHead.clientList;
        node    = globalOpenGLData.oglClientListHead.clientList->next;
        while (node)
            {
            if (node == toFree)
                {
                parNode->next = node->next;
                EngFreeMem(toFree);
                OglDecClientCount(ppdev);
                break;
                }
            parNode = node;
            node    = node->next;
            }
        }

    return;
    }


//******************************************************************************
//
//  Function: OglFindClientInfoRmClient
//
//  Routine Description:
//
//  Arguments:
//
//        Handle to resource manager client
//
//  Return Value:
//        Pointer to client information node
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO *OglFindClientInfoRmClient(
PDEV *ppdev, 
ULONG rmClient)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node       = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.hClient == rmClient)
            {
            clientInfo = &node->clientInfo;
            break;
            }
        node = node->next;
        }

    return(clientInfo);
    }


//******************************************************************************
//
//  Function: OglFindDrawableInClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//        Pointer to client information node
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO *OglFindDrawableInClientInfoList(
PDEV *ppdev, 
NV_OPENGL_DRAWABLE_INFO *inDrawablePtr)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node       = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientDrawableInfo == inDrawablePtr)
            {
            clientInfo = &node->clientInfo;
            break;
            }
        node = node->next;
        }

    return(clientInfo);
    }

//******************************************************************************
//
//  Function: OglFindClientInfoGlobalData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
static NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoGlobalData(
PDEV *ppdev, 
ULONG processHandle, 
PVOID globalData)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.processHandle == processHandle &&
            node->clientInfo.oglGlobalPagePtr == globalData)
            {
            break;
            }
        node = node->next;
        }

    return(node);
    }

//******************************************************************************
//
//  Function:   OglEngDeleteDriverObj
//
//  Routine Description:
//
//        This routine frees the driver object if it is not in use.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
BOOL OglEngDeleteDriverObj(
PDEV *ppdev,
NV_OPENGL_CLIENT_INFO *clientInfo,
ULONG flags
)
    {
        if ((clientInfo->flags & flags) == 0)
        {
            if (clientInfo->hDrvObj)
            {
            DRIVEROBJ *drvObj;

            OglDebugPrint("*********************** OglEngDeleteDriverObj clientInfo = 0x%lx\n", clientInfo);

            drvObj = EngLockDriverObj(clientInfo->hDrvObj);
            if (drvObj)
                {
                OglDebugPrint("*********************** OglEngDeleteDriverObj : GOING to EngDeleteDriverObj clientInfo = 0x%lx\n", clientInfo);
                if (EngDeleteDriverObj(clientInfo->hDrvObj, FALSE, TRUE) == FALSE)
                    {
                    OglDebugPrint("*********************** OglEngDeleteDriverObj EngDeleteDriverObj FAILED! clientInfo = 0x%lx\n", clientInfo);
                    EngUnlockDriverObj(clientInfo->hDrvObj);
                    }
                OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
                }
            else
                {
                OglDebugPrint("*********************** OglEngDeleteDriverObj EngLockDriverObj FAILED! clientInfo = 0x%lx\n", clientInfo);
                return(FALSE);
                }
            return(TRUE);
            }
        }
        return(FALSE);
    }

//******************************************************************************
//
//  Function:   OglDecClientCount
//
//  Routine Description:
//
//        This routine decrements the client count.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglDecClientCount(
PDEV *ppdev
)
{
    //
    // Decrement client count.
    //
    globalOpenGLData.oglClientCount--;

#if DBG
    // Walk the linked list of verify the count.
    OglVerifyClientList(ppdev, "OglDecClientCount");
#endif // DBG
}

//******************************************************************************
//
//  Function:   OglIncClientCount
//
//  Routine Description:
//
//        This routine increments the client count.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglIncClientCount(
PDEV *ppdev
)
{
    //
    // Increment client count.
    //
    globalOpenGLData.oglClientCount++;

#if DBG
    // Walk the linked list of verify the count.
    OglVerifyClientList(ppdev, "OglIncClientCount");
#endif // DBG
}

/* XXX put into separate file called oglGlobal.c
 */
BOOL CALLBACK ClientSharedDrvFreeObj(DRIVEROBJ *pDriverObj);
BOOL CALLBACK RmClientDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   OglRegisterRmClient
//
//  Routine Description:
//
//        Create a node in the OpenGL list and a driver object for the user's RM client.
//
//  Arguments:
//
//        rmClient - RM client handle to track for process abnormal termination
//
//******************************************************************************
void OglRegisterRmClient(PDEV *ppdev, ULONG rmClient)
    {
    int i;
    LONG                   status;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "OglRegisterRmClient - %ld", rmClient));

    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev, 
                                           0, 
                                           0, 
                                           NULL, 
                                           NULL);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("OglRegisterRmClient: OglAppendToClientInfoList FAILED\n");
        return;
        }

    //
    // Save client data in node of list
    //
    clientInfo->hClient = rmClient;

    //
    // Set shared info is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_RM_CLIENT;

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, RmClientDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
        {
        DISPDBG((1, "OglRegisterRmClient: FAILED EngCreateDriverObj"));
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        OglDecClientCount(ppdev);
        return;
        }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj = hDrvObj;

    OglDebugPrint("OglRegisterRmClient = 0x%p 0x%p\n", ppdev, clientInfo);
    }

//******************************************************************************
//
//  Function:   OglUnRegisterRmClient
//
//  Routine Description:
//
//        Free a previously allocated node in the client list.  The node
//        freed is associated with the rmClient.
//
//  Arguments:
//
//        rmClient - RM client handle to track for process abnormal termination
//
//******************************************************************************
void OglUnRegisterRmClient(PDEV *ppdev, ULONG rmClient)
    {
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    long status;

    OglDebugPrint("OglUnRegisterRmClient = 0x%p 0x%p\n", ppdev, rmClient);

    clientInfo = OglFindClientInfoRmClient(ppdev, rmClient);
    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_RM_CLIENT)
        {
        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, rmClient, NV01_NULL_OBJECT, rmClient);

        clientInfo->hClient = 0;    // just for good measure...

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_RM_CLIENT;

        if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_RM_CLIENT) == TRUE)
            {
            OglDebugPrint("OglUnRegisterRmClient: client count = %ld\n", globalOpenGLData.oglClientCount);
            }

        OglDebugPrint("OglUnRegisterRmClient = 0x%p 0x%p\n", ppdev, clientInfo);
        }
    }

//******************************************************************************
//
//  Function:   RmClientDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK RmClientDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
    {
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();
    OglDebugPrint("RmClientDrvFreeObj = 0x%p 0x%p\n", ppdev, clientInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup client info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_RM_CLIENT)
        {
        try
            {
            //
            // Free channel and such.
            //
            NvFree(ppdev->hDriver, clientInfo->hClient, NV01_NULL_OBJECT, clientInfo->hClient);
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "RmClientDrvFreeObj: exception = 0x%lx", status));
            OglReleaseGlobalMutex();
            return(TRUE);
            }
        clientInfo->flags &= ~NV_OGL_CLIENT_RM_CLIENT;
        clientInfo->hClient = 0;    // just for good measure...
        }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("RmClientDrvFreeObj CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   CreateSharedClientInfo
//
//  Routine Description:
//
//        Maps the global page (GDI mutex and mode switch counter) into the
//        client address space.  It adds a node to the linked list and register
//        the node with the GDI subsystem.
//
//        Also maps the fifo registers, and the pci config space registers
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void CreateSharedClientInfo(
PDEV *ppdev, 
ULONG hClient,
ULONG processHandle, 
PVOID *globalData, 
PVOID *pfifoAddress,
PVOID *pbusAddress)
    {
    int i;
    LONG                   status;
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "CreateSharedClientInfo - %ld", processHandle));

    *globalData = *pfifoAddress = NULL;

    if (OglMapGlobalPageAddress(ppdev, globalData) == FALSE)
        {
        OglDebugPrint("CreateSharedClientInfo: OglMapGlobalPageAddress FAILED\n");
        return;
        }

    if (OglMapPFifoAddress(ppdev, pfifoAddress) == FALSE)
        {
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglMapPFifoAddress FAILED\n");
        return;
        }

    if (OglMapPBusAddress(ppdev, pbusAddress) == FALSE)
        {
        OglUnmapPFifoAddress(ppdev, *pfifoAddress);
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglMapPBusAddress FAILED\n");
        return;
        }

    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev, 
                                           0, 
                                           0, 
                                           NULL, 
                                           NULL);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglUnmapPBusAddress(ppdev, *pbusAddress);
        OglUnmapPFifoAddress(ppdev, *pfifoAddress);
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglAppendToClientInfoList FAILED\n");
        return;
        }

    //
    // Save client data in node of list
    //
    clientInfo->hClient          = hClient;       // Per-device client handle
    clientInfo->processHandle    = processHandle; // Process handle from client associated with globalData
    clientInfo->oglGlobalPagePtr = *globalData;   // Pointer to shared memory
    clientInfo->pfifoAddress     = *pfifoAddress; // Address of FIFO in client address space
    clientInfo->pbusAddress      = *pbusAddress;  // Address of BUS registers in client addr space

    //
    // Set shared info is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_SHARED_INFO;

    OglDebugPrint("****************** CreateShared: client count = %ld\n", globalOpenGLData.oglClientCount);

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientSharedDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
        {
        DISPDBG((1, "CreateSharedClientInfo: FAILED EngCreateDriverObj"));
        OglDebugPrint("****************** FAILURE CreateShared: client count = %ld\n", globalOpenGLData.oglClientCount);
        OglUnmapGlobalPageAddress(ppdev, clientInfo->oglGlobalPagePtr);
        OglUnmapPFifoAddress(ppdev, clientInfo->pfifoAddress);
        OglUnmapPBusAddress(ppdev, clientInfo->pbusAddress);
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        return;
        }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj         = hDrvObj;
    clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;

    OglDebugPrint("CreateShared = 0x%p 0x%p\n", ppdev, clientInfo);
    }

//******************************************************************************
//
//  Function:   DestroySharedClientInfo
//
//  Routine Description:
//
//        This routine is used to unmap the memory and destroy the client node.
//        The node is removed from the list and the GDI tracking of the object
//        is deleted.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void DestroySharedClientInfo(
PDEV *ppdev, 
ULONG hClient, 
ULONG processHandle, 
PVOID globalData, 
ULONG deleteFlag)
    {
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    long status;

    OglDebugPrint("DestroySharedClientInfo = 0x%p %ld 0x%p\n", ppdev, processHandle, globalData);

    clientList = OglFindClientInfoGlobalData(ppdev, processHandle, globalData);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_SHARED_INFO)
        {
        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, hClient, NV01_NULL_OBJECT, hClient);

        //
        // Free page mappings from display driver to client.
        //
        OglUnmapGlobalPageAddress(ppdev, clientInfo->oglGlobalPagePtr);
        OglUnmapPFifoAddress(ppdev, clientInfo->pfifoAddress);
        OglUnmapPBusAddress(ppdev, clientInfo->pbusAddress);

        clientInfo->processHandle    = 0;    // just for good measure...
        clientInfo->oglGlobalPagePtr = NULL; // just for good measure...
        clientInfo->pfifoAddress     = NULL; // just for good measure...
        clientInfo->pbusAddress      = NULL; // just for good measure...

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_SHARED_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_SHARED_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyShared: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        OglDebugPrint("DestroyShared = 0x%p 0x%p\n", ppdev, clientInfo);
        }
    }

//******************************************************************************
//
//  Function:   ClientSharedDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientSharedDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
    {
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();
    OglDebugPrint("SHARED ***************** SHARED DrvFreeObj = 0x%p 0x%p\n", ppdev, clientInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup client info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_SHARED_INFO)
        {
        try
            {
            DestroySharedClientInfo(ppdev, clientInfo->hClient, clientInfo->processHandle, clientInfo->oglGlobalPagePtr, FALSE);
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "DestroySharedClientInfo: exception = 0x%lx", status));
            OglReleaseGlobalMutex();
            return(TRUE);
            }
        clientInfo->flags &= ~NV_OGL_CLIENT_SHARED_INFO;
        clientInfo->processHandle    = 0;    // just for good measure...
        clientInfo->hClient          = 0;    // just for good measure...
        clientInfo->oglGlobalPagePtr = NULL; // just for good measure...
        clientInfo->pfifoAddress     = NULL; // just for good measure...
        }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    //
    // Decrement client count.
    //
    OglDebugPrint("****************** Shared CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   OglMapGlogalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the kernel, system
//      address for the shared information into the caller's address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapGlobalPageAddress(
PDEV *ppdev, 
PVOID *globalData
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglMapGlobalPageAddress - Entry"));

    *globalData = NULL;

    sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL     = TRUE;
    sysmemShareMemoryIn.physicalAddress    = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress   = (PVOID)ppdev->oglGlobalPagePtr;
    sysmemShareMemoryIn.byteLength         = ppdev->oglGlobalPageSize;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        *globalData = (PVOID)NULL;
        DISPDBG((2, "OglMapGlobalPageAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    // save user address in shared info structure
    *globalData = (PVOID)sysmemShareMemoryOut.userVirtualAddress;

    DISPDBG((2, "OglMapGlobalPageAddress - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the user virtual address
//      into system address space where the display driver can get to it.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglUnmapGlobalPageAddress(
PDEV *ppdev, 
PVOID globalData
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "OglUnmapGlobalPageAddress - Entry"));

    if (globalData)
        {
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)globalData;
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
            {
            DISPDBG((2, "OglUnmapGlobalPageAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
            }
        }
    else
        {
        DISPDBG((2, "OglUnmapGlobalPageAddress - globalData NULL"));
        }

    DISPDBG((2, "OglUnmapGlobalPageAddress - Exit"));
    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglMapPFifoAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the NV FIFO into the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapPFifoAddress(
PDEV *ppdev, 
PVOID *pfifoAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG  returnedDataLength;

    *pfifoAddress = NULL;

    memset(&sysmemShareMemoryIn, 0, sizeof(NV_SYSMEM_SHARE_MEMORY));
    sysmemShareMemoryIn.pSystemMdl     = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = TRUE;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_NV_PFIFO_USER,
                           &sysmemShareMemoryIn, // not really used in mapping...
                           sizeof(HANDLE),
                           (PULONG)pfifoAddress,
                           sizeof(PULONG),
                           &returnedDataLength))
        {
        DISPDBG((2, "MapPFifoAddress - can't map NV PFIFO"));
        return(FALSE);
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapPFifoAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the NV FIFO from the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
BOOL OglUnmapPFifoAddress(
PDEV *ppdev, 
PVOID pfifoAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG                  returnedDataLength;

    if (pfifoAddress)
        {
        sysmemShareMemoryIn.userVirtualAddress = ((ULONG *)pfifoAddress);
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_NV_PFIFO_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "UnmapPFifoAddress - can't unmap NV PFIFO"));
            return(FALSE);
            }
        }
    else
        {
        DISPDBG((2, "UnmapPFifoAddress - pfifoAddress NULL"));
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglMapPBusAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the NV PCI bus registers
//      into the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapPBusAddress(
PDEV *ppdev, 
PVOID *pbusAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG  returnedDataLength;

    *pbusAddress = NULL;

    memset(&sysmemShareMemoryIn, 0, sizeof(NV_SYSMEM_SHARE_MEMORY));
    sysmemShareMemoryIn.pSystemMdl     = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = TRUE;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_NV_PBUS_USER,
                           &sysmemShareMemoryIn, // not really used in mapping...
                           sizeof(HANDLE),
                           (PULONG)pbusAddress,
                           sizeof(PULONG),
                           &returnedDataLength))
        {
        DISPDBG((2, "MapPBusAddress - can't map NV PBUS"));
        return(FALSE);
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapPBusAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the NV PCI bus registers
//      from the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
BOOL OglUnmapPBusAddress(
PDEV *ppdev, 
PVOID pbusAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG                  returnedDataLength;

    if (pbusAddress)
        {
        sysmemShareMemoryIn.userVirtualAddress = ((ULONG *)pbusAddress);
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_NV_PBUS_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "UnmapPBusAddress - can't unmap NV PBUS"));
            return(FALSE);
            }
        }
    else
        {
        DISPDBG((2, "UnmapPBusAddress - pbusAddress NULL"));
        }

    return(TRUE);
    }

#if DBG
//******************************************************************************
//
//  Function:   OglVerifyClientList
//
//  Routine Description:
//
//      This is a debug routine that walks the client linked list and verifies
//      that the count equals the client count.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the count are equal.
//
//******************************************************************************
BOOL OglVerifyClientList(
PDEV *ppdev,
char *s
)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    ULONG i;

    i = 0;
    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        i++;
        node = node->next;
        }
    OglDebugPrint(">>>>>>>>>> %s clientCount = %ld ? %ld\n", s, globalOpenGLData.oglClientCount, i);
    return((BOOL)(i == globalOpenGLData.oglClientCount));
    }
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclip.c ===
/******************************Module*Header*******************************\
* Module Name: oglclip.c
*
* This module contains the functions to support the OpenGL client side
* window clip list processing.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "oglDD.h"
#include "oglOverlay.h"
#include "oglstereo.h"
#include "oglflip.h"
#include "oglclip.h"
#include "nvdoublebuf.h"

#include "oglutils.h"
#include "ogldebug.h"
#include "cliplist.h"
#include "rectutils.h"
#ifdef NV_MAIN_MULTIMON
#include "linkedlist.h"
#endif

#if (NVARCH >= 0x4)
#include "nvRegionShared.h"
#include "nvcom.h"          // drivers/common/inc
#include "nvtracecom.h"     // drivers/common/inc
#endif // (NVARCH >= 0x4)

#include "Nvcm.h"
//
// export
//

#define DBG_CLIPPED_MESSAGES 1
#undef DBG_CLIPPED_MESSAGES

extern VOID MagicDelay(void);
static void CopyClipListToDrawableInfo(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static void CopyClipListToOtherClients(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);

#if (NVARCH >= 0x4)
// Internal functions that are only called from outside of this file
// These should only be called from __glNv10Flush...()
// Moved to nvRegionShared.h
extern void nvConvertRegionGL2NV(RegionPtr nvRegion, unsigned char useExclusive, 
                          __GLregionRect *inclusiveRects, int numInclusiveRects,
                          __GLregionRect *exclusiveRects, int numExclusiveRects,
                          __GLregionRect *boundingRect);
extern void nvConvertRegionNV2GL(RegionPtr nvRegion, unsigned char useExclusive,
                          __GLregionRect **inclusiveRects, int *numInclusiveRects,
                          __GLregionRect **exclusiveRects, int *numExclusiveRects);

#endif // (NVARCH >= 0x4)

static void OglBltBackDepthBuffer(PDEV *ppdev,
                NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
                RECTL *srcRect,
                RECTL *dstRect);

static RECTL nullRect = { 0,0,0,0 };

//******************************************************************************
//
//  Function:   CheckUbbWindowClip
//
//  Routine Description:
//
//
//  Arguments:
//
//      ppdev - pointer to PDEV
//      clientDrawableInfo - window and clip information
//
//  Return Value:
//
//      aint none!
//
//******************************************************************************
static ULONG
AreRectanglesIntersecting(
    RECT *r1, 
    RECT *r2
)
    {
    // it is easier to check fail cases where they do not intersect...
    if ((int)r1->bottom <= (int)r2->top) return FALSE;
    if ((int)r1->top >= (int)r2->bottom) return FALSE;
    if ((int)r1->left >= (int)r2->right) return FALSE;
    if ((int)r1->right <= (int)r2->left) return FALSE;

    return TRUE;
    }

//******************************************************************************
//
//  Function:   IsNullRect
//
//  Routine Description:
//
//      Verify rectangle is valid by checking for a 0,0,0,0 rectangle.
//
//  Arguments:
//
//  Return Value:
//
//      non-zero means it is a NULL rectangle
//
//******************************************************************************
static INLINE int IsNullRect(RECTL *rect)
{
    return rect->left >= rect->right || rect->top >= rect->bottom;
}

static void
CheckUbbWindowClip(
    PDEV *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
    {
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    ULONG                      fullyExposed;

    clientDrawableInfo->ubbWindowClipFlag = (ULONG)FALSE;
    if ((globalOpenGLData.oglClientListHead.clientList == NULL) ||
        (ppdev->bOglSingleBackDepthCreated == FALSE) || // Must be in UBB mode...
        (ppdev->DoubleBuffer.bEnabled && !ppdev->bOglOverlaySurfacesCreated) || // must disable ubbwinclip if pageflipping is enabled (front+back must look "same"), but when overlays are enabled we still do the ubbwinclip because mainplane+overlayplane live in  buffers, that are not visible (just copied from!)
        (IsNullRect((RECTL *)&clientDrawableInfo->rect) ||
        (clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED)))
        {
        return;
        }

    OglAcquireGlobalMutex();

    fullyExposed = (ULONG)TRUE;
    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        clientInfo = &node->clientInfo;
        if (bOglHasDrawableInfo(clientInfo) &&
            clientInfo->clientDrawableInfo != clientDrawableInfo &&
            clientInfo->clientDrawableInfo->hWnd != clientDrawableInfo->hWnd)
            {
            if (AreRectanglesIntersecting(&clientInfo->clientDrawableInfo->rect, &clientDrawableInfo->rect) == TRUE)
                {
                if (!(clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED))
                    {
                    // another OGL window intersects our window and it has some exposed pixels.
                    fullyExposed = (ULONG)FALSE;
                    }
                }
            }
        node = node->next;
        }

    clientDrawableInfo->ubbWindowClipFlag = fullyExposed;

    OglReleaseGlobalMutex();
    }

void OglTranslateCachedClipRectList(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox)
{
    ULONG ii;
    long windowLeft, windowTop;

    if (IsNullRect(&srcRects[0])) 
        {
        *destNumRects = 1;
        destRects[0] = nullRect;
        }
    else
        {
        windowLeft = boundingBox->left - ppdev->left;
        windowTop  = boundingBox->top - ppdev->top;
        for (ii = 0; ii < srcNumRects; ii++)
        {
            destRects[ii].left   = srcRects[ii].left   - windowLeft;
            destRects[ii].right  = srcRects[ii].right  - windowLeft;
            destRects[ii].top    = srcRects[ii].top    - windowTop;
            destRects[ii].bottom = srcRects[ii].bottom - windowTop;
        }
        *destNumRects = srcNumRects;
    }
}

/*
** OglTranslateClientRelativeRectListToDevice
** 
** Convert the client relative src rect list to 
** a desktop relative destination list.
** 
** FNicklisch 05.10.2000: New
*/ 
void OglTranslateClientRelativeRectListToDevice(
    PDEV *ppdev,
    RECTL *srcRects,     // src rects
    ULONG srcNumRects, 
    RECTL *destRects,    // dst rects
    ULONG *destNumRects,
    RECTL *boundingBox)  // bounding box for offset calculation
{
    ULONG ii;
    long windowLeft, windowTop;

    if (IsNullRect(&srcRects[0])) 
        {
        *destNumRects = 1;
        destRects[0] = nullRect;
        }
    else
        {
        windowLeft = boundingBox->left - ppdev->left;
        windowTop  = boundingBox->top - ppdev->top;
        for (ii = 0; ii < srcNumRects; ii++)
        {
            destRects[ii].left   = srcRects[ii].left   + windowLeft;
            destRects[ii].right  = srcRects[ii].right  + windowLeft;
            destRects[ii].top    = srcRects[ii].top    + windowTop;
            destRects[ii].bottom = srcRects[ii].bottom + windowTop;
        }
        *destNumRects = srcNumRects;
    }
}


//******************************************************************************
//
//  Function:   TranslateRectToScreen
//
//  Routine Description:
//
//      Use desktop left,top to translate rectangle to screen coordinates.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
static void TranslateRectToScreen(
PDEV *ppdev,
RECTL *rect
)
{
    //
    // In multi-monitor system, ppdev->left and ppdev->top are the
    // left and top edge of the display relative to the desktop.
    // For example, if we have 2 monitors, primary on left and secondary
    // on right, then for primary left,top = 0,0 and for secondary
    // left,top = right_edge_of_primary, 0.  In a  single monitor system
    // left,top always equals 0,0.
    //
    rect[0].left -= ppdev->left;
    rect[0].top -= ppdev->top;
    rect[0].right -= ppdev->left;
    rect[0].bottom -= ppdev->top;
}

static void
CopyClipListToOtherClients(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO    *nodeDrawableInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        clientInfo = &node->clientInfo;
        nodeDrawableInfo = clientInfo->clientDrawableInfo; // drawable information for this client
        if (bOglHasDrawableInfo(clientInfo) &&
            (nodeDrawableInfo->hWnd == clientDrawableInfo->hWnd) &&
            (nodeDrawableInfo->hDC != clientDrawableInfo->hDC) &&
            (nodeDrawableInfo != clientDrawableInfo))
            {
            if (clientInfo->ppdev)
                {
                CopyClipListToDrawableInfo(clientInfo->ppdev, pwo, fl, nodeDrawableInfo);
                }
            else
                {
                CopyClipListToDrawableInfo(ppdev, pwo, fl, nodeDrawableInfo);
                }
            }
        node = node->next;
        }
}

//******************************************************************************
//
//  Function:   OglValidateDrawableInfo
//
//  Routine Description:
//
//      Walk the linked list of OpenGL nodes a verify that the drawable info
//      is in the list.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE if in list, FALSE otherwise
//
//******************************************************************************
BOOL OglValidateDrawableInfo(NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    BOOL bRet;

    bRet = FALSE;
    if (clientDrawableInfo)
    {
        NV_OPENGL_CLIENT_INFO *clientInfo;

        OglAcquireGlobalMutex();

        // Start at top of list
        clientInfo = NULL;
        while (bOglGetNextClient(&clientInfo))
            {
            ASSERT(bOglHasDrawableInfo(clientInfo));
            if (clientDrawableInfo == clientInfo->clientDrawableInfo)
                {
                bRet = TRUE;
                break;
                }
            }
        OglReleaseGlobalMutex();
    }
    return(bRet);
}


/*
** bWindowHasMoved
**
** checks window's old and new position rectangles and determines if
** moved only ( without resize )
** 
** Return value: FALSE: if window did not move only ( but resize or did not move )
**               TRUE:  if window moved but did not resize
**
** MSchwarz 09/29/2000: new
*/
BOOL bWindowHasMoved( PRECTL prclSrc, PRECTL prclDest )
{
    BOOL bRet = FALSE;
    ASSERT(prclSrc);
    ASSERT(prclDest);

    if(    ( (prclSrc->right  - prclSrc->left)==(prclDest->right  - prclDest->left) )
        && ( (prclSrc->bottom - prclSrc->top )==(prclDest->bottom - prclDest->top)  )
        && (   (prclSrc->left != prclDest->left ) 
             ||(prclSrc->top  != prclDest->top  ) 
           )
      )            
    {
        DISPDBG((2, "  moved: l%4d t%4d r%4d b%4d (w%4d x h%4d) -> l%4d t%4d r%4d b%4d", 
            prclSrc->left, 
            prclSrc->top, 
            prclSrc->right, 
            prclSrc->bottom,
            prclSrc->right-prclSrc->left, 
            prclSrc->bottom-prclSrc->top,
            prclDest->left,
            prclDest->top,
            prclDest->right, 
            prclDest->bottom));
        bRet = TRUE;
    }
    return bRet;
}


/*
** bWindowHasBeenResized
**
** checks window's old and new position rectangles and determines if
** it has been resized
** 
** Return value: FALSE: if window hasn't been resized
**               TRUE:  if window has been resized
**
** MSchwarz 10/05/2000: new
*/
BOOL bWindowHasBeenResized( PRECTL prclSrc, PRECTL prclDest )
{
    BOOL bRet = FALSE;
    ASSERT(prclSrc);
    ASSERT(prclDest);

    if(    ( (prclSrc->right  - prclSrc->left)!=(prclDest->right  - prclDest->left) )
        || ( (prclSrc->bottom - prclSrc->top )!=(prclDest->bottom - prclDest->top)  )
      )
    {
        DISPDBG((2, "  resized: l%4d t%4d r%4d b%4d (w%4d x h%4d) -> l%4d t%4d r%4d b%4d (w%4d x h%4d)", 
            prclSrc->left, 
            prclSrc->top, 
            prclSrc->right, 
            prclSrc->bottom,
            prclSrc->right-prclSrc->left, 
            prclSrc->bottom-prclSrc->top,
            prclDest->left,
            prclDest->top,
            prclDest->right, 
            prclDest->bottom,
            prclDest->right-prclDest->left, 
            prclDest->bottom-prclDest->top
            ));
        bRet = TRUE;
    }
    return bRet;
}


// MSchwarzer 09/28/2000 need this to copy overlaymainplanefront to primary
static HWND g_hWnd = NULL;
// we need this to be able to handle occluded OGLClients
// in case of WOC_CHANGED
static PPDEV g_ppdev = NULL;
//******************************************************************************
//
//  Function:   DrvClipChanged
//
//  Routine Description:
//
//      Implements the routine which is notified when a clip list changes for
//      our client window.
//
//  Arguments:
//      fl:                     pwo:
//      WOC_CHANGED             NULL
//      WOC_RGN_CLIENT_DELTA    client delta clipping (region we will enter) + includes a pvConsumer
//      WOC_RGN_CLIENT          client clipping (new client area) + includes a pvConsumer
//      WOC_RGN_SURFACE_DELTA   desktop delta clipping (region we left)
//      WOC_RGN_SURFACE         desktop clipping (desktop - clients)
//      WOC_DELETE              includes a pvConsumer of the client that dies 
//                              NOTE: In our implementation pvConsumer already is invalidated!
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID CALLBACK DrvClipChanged(
    WNDOBJ *pwo,
    FLONG  fl
)
{
    PDEV                    *ppdev              = NULL;
    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;
    LONG status;
#ifdef NV_MAIN_MULTIMON
    ULONG_PTR ul;
    PVOID ppData;
    BOOL bRet; 
#endif

#if DBG
    if (NULL == pwo)
    {
        // don't have pwo
        DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s ", fl, szDbg_WOC_flGet(fl)));
    }
    else if (NULL == pwo->pvConsumer)
    {
        // don't have pvConsumer==clientInfo
        DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p", fl, szDbg_WOC_flGet(fl), pwo));
    }
    else
    {
        if (fl & WOC_DELETE)
        {
            // should be the WOC_DELETE, but we will crash on invalid pvConsumer data if we access it
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p (INVALID)", fl, szDbg_WOC_flGet(fl), pwo, pwo->pvConsumer));
        }
        else if (   (NULL == OglFindClientListFromClientInfo(NULL, pwo->pvConsumer))
                 || !bOglHasDrawableInfo(pwo->pvConsumer))
        {
            // don't have clientDrawableInfo -> should not happen
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p", 
                fl, szDbg_WOC_flGet(fl), 
                pwo, pwo->pvConsumer));
        }
        else
        {
        
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p, drawable:0x%p (hWnd:0x%p, clipcount:0x%x)", 
                fl, szDbg_WOC_flGet(fl), 
                pwo, pwo->pvConsumer,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo->hWnd,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo->clipChangedCount
                ));
        }
    }
#endif

    // MSchwarzer 10/06/2000 now we do: we have to check all clientDrawableInfo->ubbWindowClipFlags
    // because after opening a new window underlying window has wrong Flag setting !!
    if (fl & WOC_CHANGED)
    {
        // It is possible for g_ppdev to be NULL here (why?)
        // Since this may cause a leak, print a debug error
        if (g_ppdev == NULL) {
            DBG_ERROR("DrvClipChanged: NULL g_ppdev w/ WOC_CHANGED");
        }
        if (   (NULL != g_ppdev)               // need a ppdev
            && g_ppdev->bEnabled               // running on enabled hardware
            && (NULL != g_ppdev->pOglServer) ) // with initialized oglserver structure
        {
            ppdev = g_ppdev;

            // calculate bounding clip rect around all clients
            bOglClipBoundsUpdate(ppdev->pOglServer);

            // loop over all clients with a NV_OPENGL_DRAWABLE_INFO
            clientInfo = NULL;
            while (bOglGetNextClient(&clientInfo))
            {
                CheckUbbWindowClip(ppdev,clientInfo->clientDrawableInfo); 
            }

            bOglStereoModeUpdate(ppdev);
            bOglOverlayModeUpdate(ppdev);

            // Defers it to next call to bOglPageFlipModeRetryEnable
            ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP; 

            // Clipping has changed, we should retry on next swap, but not here and now.
            // But we have to disable pageflipping if necessary!
            bOglPageFlipModeUpdate(ppdev);
        }

        // All done => reset globals to Zero
        g_hWnd                     = NULL;
        g_ppdev                    = NULL;
        DISPDBG((1, " "));
        return;
    }

    // from here on we need a pwo
    if (!pwo)
    {
        DISPDBG((1, "DrvClipChanged: pwo NULL"));
        return;
    }

    //
    // Try to get a valid ppdev.
    //
    // Win2K after a mode switch will give us outdated ppdev for all clients
    // that were started before the mode switch. So we have different 
    // mechanisms to retrieve a ppdev:
    //
    // 1. out of pso                            (default)
    // 2. out of client in pvConsumer           (fallback for all CLIENT calls)
    // 3. out of any client in global list      (fallback for all SURFACE calls)    
    // NOTE: Still a problem with WOC_DELETE because pvConsumer is already invalid.
    //       but we don't handle that call

    //
    // 1. try to get ppdev out of pso.
    //
    ppdev = (PDEV *)pwo->psoOwner->dhpdev;

    ASSERT(NULL!=ppdev);
    if (NULL==ppdev) // Be shure we don't crash!
    { 
        DISPDBG((0,"DrvClipChanged: ERROR: Invalid ppdev in Window!"));
        return;
    }

    // Win2K will give us outdated ppdevs after a modeswitch, 
    // try to find a valid ppdev instead
    if (!ppdev->bEnabled)
    {
        //
        // 2. Try this client
        //

        // NOTE:  clientInfo can be NULL!
        // NOTE2: clientInfo can be != NULL but invalid!
        clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;

        if (   OglFindClientListFromClientInfo(NULL, clientInfo)
            && bOglHasDrawableInfo(clientInfo) )
        {
            DISPDBG((1, "DrvClipChanged: WARNING: GDI gave us a disabled ppdev, try to get a valid pdev out of given client!"));
            ASSERTDD(NULL!=clientInfo->ppdev, "clientInfo with a drawable should always have a ppdev!");

            ppdev = clientInfo->ppdev;
            ASSERT(NULL!=ppdev);
        }

        //
        // 3. Try any client
        //
        clientInfo = NULL; // start at top of list
        while (   !ppdev->bEnabled                 // still invalid?
               && bOglGetNextClient(&clientInfo) )
        {
            DISPDBG((1, "DrvClipChanged: WARNING: GDI gave us a disabled ppdev, try to get a valid pdev out of any client!"));
            ASSERTDD(NULL!=clientInfo->ppdev, "clientInfo with a drawable should always have a ppdev!");

            ppdev = clientInfo->ppdev;
            ASSERT(NULL!=ppdev);
        }
    }

    //memorize ppdev for WOC_CHANGED
    g_ppdev = ppdev;

#if 0 // still unused
    //
    // WOC_DELETE
    //
    // The WNDOBJ is being deleted as a result of the deletion of the window. 
    // Our problem is, that the pvConsumer (clientInfo) already was deleted 
    // through an escape in ogldrwbl.c in a OglEngDeleteDriverObj call, so 
    // there isn't much data we have left to do anything :-(
    //
    if (fl & WOC_DELETE)
    {
        ASSERT(NULL==pwo->pvConsumer);
        return;
    }
#endif

    // From now on we may access the hardware.
    // For that we need a valid and enabled ppdev!
    // FN moved it into branches...ASSERT(ppdev->bEnabled);

    //
    // WOC_RGN_SURFACE
    //
    // GDI should track changes in the surface region of the window object, and 
    // notify the driver when the surface region changes. The surface region is 
    // the display surface area excluding all visible client regions of the 
    // windows being tracked by the driver. 
    // The WNDOBJ refers to a surface region created by GDI. The pvConsumer 
    // member of the WNDOBJ structure is zero. 
    //
    // In other words: We get the entire desktop minus all ogl clients.
    //
    if (fl & WOC_RGN_SURFACE)
    {
        bOglNegativeClipListUpdate(ppdev, pwo);
    }

    // MSchwarz 09/26/2000 we need to clear all space on overlaybuffers we leave with our
    //                     window to no leave garbage there, which would affect other windows
    if (fl & WOC_RGN_CLIENT_DELTA )
    {
        ASSERT(ppdev->bEnabled);
        // this is the new delta region we will enter

        //  The window object contains the delta client region list. 
        //  The delta region is valid for this call only.

        // clear newly entered region in overlay buffers, if pwo belongs to an overlay client
        // but aware of popup-menues which save and restore frontbuffer contents but NOT 
        // overlaybuffer contents => don't destroy overlay ibn this case
        if( 0 == ppdev->lSavedScreenBits )
        {
            // clear overlay front- and backbuffer because ICD will receive a WM_PAINT message
            bClearOverlayForClient(ppdev, pwo, NULL, TRUE, TRUE);
        }
        else
        {
            // only clear overlay frontbuffer because DrvSaveScreenBits will restore it
            bClearOverlayForClient(ppdev, pwo, NULL, TRUE, FALSE);
        }
    }

    if (fl & WOC_RGN_SURFACE_DELTA)
    {
        ASSERT(ppdev->bEnabled);
        // this is the region we will leave

        //  The window object contains the delta client region list. 
        //  The delta region is valid for this call only.

        // this call belongs to a WOC_RGN_SURFACE_DELTA call into DrvClipChanged
        // since the call says the primary that it will grow, there is NO pwo->pvConsumer

        // clear overlay front of new desktop area
        bClearOverlayArea(ppdev, pwo, ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000, TRUE, FALSE );
    }


    if (fl & WOC_RGN_CLIENT)
    {
        try // just in case...
        {
            clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;

            ASSERT(ppdev);
            if (OglFindClientListFromClientInfo(ppdev, clientInfo) != NULL)
            {

                ASSERT(ppdev->bEnabled);
                clientDrawableInfo = clientInfo->clientDrawableInfo;
                if (OglValidateDrawableInfo(clientDrawableInfo) == TRUE)
                {

                    // MSchwarzer 13/11/2000 we need this hWnd for a WOC_RGN_SURFACE_DELTA-call
                    // if it isn't only a windowmove
                    if( bWindowHasMoved( (PRECTL)&clientDrawableInfo->rect,&pwo->rclClient ) )
                    {
                        bGetOglClientInfoHWnd( clientInfo, &g_hWnd );
                    }

#ifdef NV_MAIN_MULTIMON                                      
                    /* Must synchronize all devices that we intersect */    
                    /* Get the first node in the OGLPDEV Linked list */
                    bRet = bLinkedListGetFirstElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, &ul, &ppData);
        
                    while ( bRet )
                    {
                        ASSERT(NULL != ppData);
    
                        /* Compare the node for intersection with the drawable */
                        if ( OglClientIntersectsDevice(ppData, clientDrawableInfo) )
                        {
                            OglSyncEngineUsingPDEV(ppData);
                        }

                        /* Get the next linked list entry */
                        bRet = bLinkedListGetNextElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, &ul, &ppData);            
                    }
#else
                    // force a sync/engine-stall with GDI channel
                    ppdev->pfnWaitEngineBusy(ppdev);
                    // force a sync/engine-stall with all OGL rendering channels
                    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                    ppdev->NVFreeCount = 0;
                    ppdev->pfnWaitForChannelSwitch(ppdev);
#endif

                    CopyClipListToDrawableInfo(ppdev, pwo, fl, clientDrawableInfo);
                    CopyClipListToOtherClients(ppdev, pwo, fl, clientDrawableInfo);
                }
                else
                {
                    DISPDBG((1, "DrvClipChanged: BOGUS clientDrawableInfo"));
                }
            }
            else
            {
                DISPDBG((0, "DrvClipChanged: BOGUS clientInfo"));
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ASSERT(FALSE);
            status = GetExceptionCode();
            DISPDBG((0, "DrvClipChanged: WOC_RGN_CLIENT: exception = 0x%lx", status));
        }
    } 
}


//*************************************************************************
// bOglNegativeClipListCreate
// 
// allocate and initialize a negative clip list to entire desktop.
//
// NOTE: Negative cliplist only makes sense in a UBB and window flipping
//       environment.
//
// returns TRUE  if succeeded.
//         FALSE if failed
//*************************************************************************
BOOL bOglNegativeClipListCreate(PPDEV ppdev)
{
    BOOL      bRet = FALSE;
    CLIPLIST *pClip = NULL; // pointer to negative cliplist

    ASSERT(NULL != ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        pClip    = &ppdev->OglNegativeClipList;

        RtlZeroMemory(pClip, sizeof(CLIPLIST));

        if (bClipListAlloc(pClip, 1))
        {
            pClip->c = 1;
            prclRclSetXYWH(pClip->prcl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

            lClipListPixelCount(pClip);

            prclRclSetXYWH(&pClip->rclBounds, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            bRet = TRUE;
        }

        ASSERT(bRet);
    }
    return (bRet);
}


//*************************************************************************
// bOglNegativeClipListDestroy
// 
// free a negative cliplist
//
// returns TRUE  if succeeded.
//         FALSE if failed
//*************************************************************************
BOOL bOglNegativeClipListDestroy(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);
    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bClipListFree(&ppdev->OglNegativeClipList);

        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglNegativeClipListUpdate
// 
// gets the rect list out of pwo and interpretes it as the negative client 
// list which is the desktop region minus all client views.
//
// returns TRUE  if succeeded.
//         FALSE if failed, negative clip list not valid!
//*************************************************************************
BOOL bOglNegativeClipListUpdate(PPDEV ppdev, WNDOBJ *pwo)
{
    LONG      c     = 0;
    CLIPENUM  ce;
    CLIPLIST *pClip = NULL; // pointer to negative cliplist
    BOOL      bMore = FALSE;
    BOOL      bRet  = TRUE; // default success exit!

    ASSERT(NULL != ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        RECTL     rclScreen;

        rclScreen.left   = ppdev->left;
        rclScreen.right  = ppdev->left+ppdev->cxScreen;
        rclScreen.top    = ppdev->top;
        rclScreen.bottom = ppdev->top+ppdev->cyScreen;

        ASSERT(NULL != pwo  );
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));

        pClip    = &ppdev->OglNegativeClipList;
        pClip->c = 0; // invalidate all existing rects!

        // pwo and screen must be the same!
        if ( !bRclIsEqual(&rclScreen, &pwo->rclClient) )
        {
            LONG      lNeedRects;
            // Windows 2000 has a bug that after a mode switch 
            // it sends us pwo's with clip information of the mode in which the
            // OpenGL application started. 
            // This is bad if we switch to high res because we wouldn't cover outside areas.
            // Try to fix this by adding two rects to the negative cliplist
            lNeedRects = pClip->c + 4; // 4 is what lRclMinusRcl needs as minimum

            if (!bClipListReAlloc(pClip, lNeedRects))
            {
                DISPDBG((0, "bClipListReAlloc failed to realloc from %d to %d", pClip->cMax, lNeedRects));
                // NOTE: This error will override the success below!
                bRet = FALSE;
            }
            else
            {
                pClip->c = lRclMinusRcl(pClip->prcl, &rclScreen, &pwo->rclClient); 
                DISPDBG((0, "WARNING in bOglNegativeClipListUpdate: W2K modeswitch %dx%d -> %dx%d workaround active with %d rects", 
                    lRclWidth(&pwo->rclClient), lRclHeight(&pwo->rclClient), 
                    lRclWidth(&rclScreen)     , lRclHeight(&rclScreen)     , 
                    pClip->c));
            }
        }

        WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0);
        do 
        {
            bMore = WNDOBJ_bEnum(pwo, sizeof(ce), &ce.c);

            if (!bClipListReAlloc(pClip, pClip->c + ce.c))
            {
                DISPDBG((0, "bClipListReAlloc failed to realloc from %d to %d", pClip->cMax, pClip->c + ce.c));
                bRet = FALSE;
                break;
            }

            for (c = 0; c < ce.c; c++)
            {
                ASSERT(pClip->c < pClip->cMax);

                // in the case of W2K switching to low res, clip against current screen
                if (bRclIntersect(&(pClip->prcl[pClip->c]), &(ce.arcl[c]), &rclScreen))
                {
                    pClip->c++;
                }
                else
                {
                    // Mode switch case??
                    DISPDBG((0, "bOglNegativeClipListUpdate: GDI did give us cliprect outside screen! %d,%d,%d,%d",
                        ce.arcl[c].left,ce.arcl[c].top,ce.arcl[c].right,ce.arcl[c].bottom));
                }
            }
        }
        while (bMore);

        //
        // Error handling
        //
        if (!bRet)
        {
            // This is an error case, where we try to do the best!
            if (pClip->cMax > 0)
            {
                // Add entire desktop
                pClip->c = 1;
                prclRclSetXYWH(pClip->prcl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            }
            else
            {
                // can't use cliplist at all!
                pClip->c = 0;
            }
        }

        //
        // Finalize work on clip list
        //
        lClipListPixelCount(pClip);
        prclRclSetXYWH(&pClip->rclBounds, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

        ASSERT(bClipListCheck(pClip));
    }
    return (bRet);
}

//*************************************************************************
// AllocateWindowRectList
//
// Given the clientDrawableInfo, allocate a memory for the list of rectangles.
//*************************************************************************
static void
ReallocCopyWindowRect(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    ULONG                   numClipRects
)
{
#ifndef NV3
    // Do this for NV4 and higher only...
    // Is it a realloc?
    if ((clientDrawableInfo->sizeCopyWindowRectList > MAX_OGL_CLIP_RECTS) && 
        (clientDrawableInfo->copyWindowRect != NULL) &&
        (clientDrawableInfo->copyWindowRect != (&(clientDrawableInfo->windowRect[0])))) {
        EngFreeMem(clientDrawableInfo->copyWindowRect);
        clientDrawableInfo->sizeCopyWindowRectList = 0;
        clientDrawableInfo->copyWindowRect = NULL;
        if (clientDrawableInfo->origWindowRectList)
            {
            EngFreeMem(clientDrawableInfo->origWindowRectList);
            clientDrawableInfo->origWindowRectList = NULL;
            }
    }
                
    // To avoid thrashing allocate a bigger list.
    clientDrawableInfo->sizeCopyWindowRectList = numClipRects + MAX_OGL_CLIP_RECTS;
    clientDrawableInfo->copyWindowRect = (RECTL *)
        EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * clientDrawableInfo->sizeCopyWindowRectList), 
                    ALLOC_TAG);
#else                
    // FOR NV3.....
    if (numClipRects > MAX_OGL_CLIP_RECTS) {
        numClipRects = MAX_OGL_CLIP_RECTS;
    }
#endif // NV3
    if (clientDrawableInfo->bOrigClipList == TRUE)
    {
        clientDrawableInfo->origWindowRectList = (RECTL *)
            EngAllocMem(FL_ZERO_MEMORY, 
                        (sizeof(RECTL) * clientDrawableInfo->sizeCopyWindowRectList), 
                        ALLOC_TAG);
    }
}

//*************************************************************************
// CharacterizeTheClip
//
// Determine what type of clip list is in the clientDrawableInfo.
//*************************************************************************
static void
CharacterizeTheClip(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, 
    RECTL                   *windowRectList,
    RECTL                   *origRectList
)
{
    // do it here to avoid decision in loop above
    if (clientDrawableInfo->numClipRects == 0)
    {
        clientDrawableInfo->numClipRects = 1;
        windowRectList[0] = nullRect;
        if (clientDrawableInfo->bOrigClipList == TRUE)
            {
            COPY_RECT(origRectList[0], windowRectList[0]);
            }
    }

    // Characterize the clip
    if (clientDrawableInfo->numClipRects == 1)
    {
        if (IsNullRect(windowRectList))
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_OCCLUDED;
        }
        else if (windowRectList->left == 0 &&
                 windowRectList->top == 0 &&
                 (LONG)windowRectList->right == (LONG)clientDrawableInfo->cxScreen &&
                 (LONG)windowRectList->bottom == (LONG)clientDrawableInfo->cyScreen)
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_FULLSCREEN;
        }
        else
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_SINGLERECTANGLE;
        }
    }
    else
    {
        clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_COMPLEX;
    }
}

//*************************************************************************
// CheckFullScreen
//
// Walk the list of OpenGL clients and evaluate whether there is an
// full screen OpenGL application.
//*************************************************************************
static void
CheckFullScreen(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    // Display driver should know whether the OpenGL is rendering in FULL screen mode
    // in order to avoid the channel switch between GDI and OpenGL
    if(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN)
    {
        ppdev->ulOpenGLinFullScreen = TRUE;
    }
    else
    {   
        // Walk down the whole list to check whether any window is in FULL screen mode                                       
        NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

        OglAcquireGlobalMutex();
        ppdev->ulOpenGLinFullScreen = FALSE;
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node)
        {
            if (bOglHasDrawableInfo(&node->clientInfo))
            {
                if (node->clientInfo.clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN)
                {
                    ppdev->ulOpenGLinFullScreen = TRUE;
                    break;
                }
            }
            node = node->next;
        }
        OglReleaseGlobalMutex();
    }
}

static void
ClipRectListToScreen(
    PDEV  *ppdev, 
    RECTL *windowRectList,
    ULONG numClipRects,
    LONG  cxScreen, 
    LONG  cyScreen
)
{
    int i;

    for (i = 0; i < (int)numClipRects; i++)
    {
        TranslateRectToScreen(ppdev, &windowRectList[i]);
        OglClipRectToScreen(&windowRectList[i], cxScreen, cyScreen);
    }
}

//*************************************************************************
// AllocateAndCopyWindowClipList
//
// Allocate memory for a new clip list and copy the rectangles from
// a given list.
//*************************************************************************
void
OglAllocateAndCopyWindowClipList(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    RECTL                   *srcRectList,
    ULONG                   numClipRects
)
{
    ASSERT(NULL!=ppdev);

    if (numClipRects > 0)
    {
        ASSERT(NULL!=clientDrawableInfo);
        ASSERT(NULL!=srcRectList);

        ReallocCopyWindowRect(ppdev, clientDrawableInfo, numClipRects);
        if (clientDrawableInfo->copyWindowRect)
        {
            RtlCopyMemory(clientDrawableInfo->copyWindowRect, // dst
                          srcRectList,                        // src
                          numClipRects * sizeof(RECTL));      // count
            ClipRectListToScreen(ppdev, 
                                 srcRectList, numClipRects,
                                 clientDrawableInfo->cxScreen, clientDrawableInfo->cyScreen);
            CharacterizeTheClip(ppdev, clientDrawableInfo, srcRectList, NULL);
        }
    }
}

//*************************************************************************
// CopyClipListToDrawableInfo
//
// This function receives the cliplist for the ICD client window
// from GDI. These rectangles are desktop related ( as all GDI stuff ).
//
// It is important to keep these rectangles in CD_RIGHTDOWN-order in
// ths cliplist because the routine which calculates an exclusive 
// cliplist needs the rectangle in this order
// 
//*************************************************************************
static void
CopyClipListToDrawableInfo(
    PDEV *ppdev,
    WNDOBJ *pwo,
    FLONG fl,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    int   isValidBounds = 0;
    int   isValidClientRect = 0;
    ULONG newNumClipRects, rectListLimit;
    RECT  clientRect;
    RECTL srcRect;
    POINTL ptlSrcMinusDest;
    ULONG i; // just for enumerations

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    if (clientDrawableInfo)
    {
        RECTL *windowRectList = NULL;
        RECTL *origRectList = NULL;

        clientDrawableInfo->clipChangedCount++;
        clientDrawableInfo->cachedClipListDirty = TRUE;

        COPY_RECT(srcRect, clientDrawableInfo->rect);
        COPY_RECT(clientDrawableInfo->rect, pwo->rclClient);

        // remember distance between src and destination rectangle
        ptlSrcMinusDest.x = srcRect.left - pwo->rclClient.left;
        ptlSrcMinusDest.y = srcRect.top  - pwo->rclClient.top;

        switch (pwo->coClient.iDComplexity)
            {
            case DC_TRIVIAL:
            case DC_RECT:
                newNumClipRects = 1;
            break;
            case DC_COMPLEX:
            default: 
                {
                    BOOL        bMore;
                    ENUMRECTS   enumRect;
                    ULONG       i, tempRet;

                    rectListLimit = clientDrawableInfo->sizeCopyWindowRectList;
                    newNumClipRects = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, rectListLimit);
                    if (newNumClipRects == 0xFFFFFFFF) {
                        i = 0;
                        bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                        while ((i < (ULONG)(ppdev->cxScreen*ppdev->cyScreen)) && bMore)
                        {
                            i++;
                            bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                        }
                        newNumClipRects = i;
                        // restart enumeration again
                        tempRet = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, i);
                    }
                }

            break;
            }

        if (newNumClipRects > clientDrawableInfo->sizeCopyWindowRectList) {
            ReallocCopyWindowRect(ppdev, clientDrawableInfo, newNumClipRects);
        }

        windowRectList = clientDrawableInfo->copyWindowRect;
        clientDrawableInfo->numClipRects = newNumClipRects;
        if (clientDrawableInfo->bOrigClipList == TRUE)
            {
            origRectList = clientDrawableInfo->origWindowRectList;
            }

        isValidBounds = !IsNullRect(&pwo->coClient.rclBounds);
        COPY_RECT(clientRect, clientDrawableInfo->rect);
        OglClipRectToScreen(
            (RECTL *)&clientRect,
            clientDrawableInfo->cxScreen,
            clientDrawableInfo->cyScreen);
        isValidClientRect = !IsNullRect((RECTL *)&clientRect);

        // Move single-back-depth if necessary => moved behind clipenumeration

        switch (pwo->coClient.iDComplexity)
            {
            case DC_TRIVIAL:
                DISPDBG((2, "DrvClipChanged: DC_TRIVIAL"));
                clientDrawableInfo->numClipRects = 1;
            break;

            case DC_RECT:

                if (isValidBounds)
                {
                    DISPDBG((2, "DrvClipChanged: DC_RECT: SINGLERECTANGLE"));
                    clientDrawableInfo->numClipRects = 1;
                    COPY_RECT(windowRectList[0], pwo->coClient.rclBounds);
                    if (clientDrawableInfo->bOrigClipList == TRUE)
                        {
                        COPY_RECT(origRectList[0], windowRectList[0]);
                        }
                }
                else
                {
                    DISPDBG((2, "DrvClipChanged: DC_RECT: OCCLUDED"));
                    clientDrawableInfo->numClipRects = 0;
                }
            break;

            case DC_COMPLEX:
                {
                BOOL        bMore;
                ENUMRECTS   enumRect;
                ULONG       i;

                DISPDBG((2, "DrvClipChanged: DC_COMPLEX"));

                i = 0;
                bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                while (i < clientDrawableInfo->numClipRects && bMore)
                    {
                    COPY_RECT(windowRectList[i], enumRect.arcl[0]);
                    if (clientDrawableInfo->bOrigClipList == TRUE)
                        {
                        COPY_RECT(origRectList[i], windowRectList[i]);
                        }
                    i++;
                    bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                    }
                clientDrawableInfo->numClipRects = i;
                break;
                }
            default:
                break;
        }

        // MSchwarzer 10/06/2000  move CLIPPED client area to not overdraw other ogl-windows !!
        if (ppdev->bOglSingleBackDepthSupported &&
            ppdev->bOglSingleBackDepthCreated &&
            isValidBounds && isValidClientRect
            && bWindowHasMoved(&srcRect,&pwo->rclClient))
        {
            // notify GDI syncs that a window move is in progress and a DrvCopyBits will happen.
            ppdev->pOglServer->bWindowInMovement = TRUE;

            switch (pwo->coClient.iDComplexity)
            {
                case DC_TRIVIAL:
                case DC_RECT:
                {
                    srcRect.right  = pwo->coClient.rclBounds.right   + ptlSrcMinusDest.x;
                    srcRect.left   = pwo->coClient.rclBounds.left    + ptlSrcMinusDest.x;
                    srcRect.top    = pwo->coClient.rclBounds.top     + ptlSrcMinusDest.y;
                    srcRect.bottom = pwo->coClient.rclBounds.bottom  + ptlSrcMinusDest.y;

                    OglBltBackDepthBuffer(ppdev, 
                                          clientDrawableInfo,
                                          &srcRect,
                                          &pwo->coClient.rclBounds);
                    break;
                }
                case DC_COMPLEX:
                default: 
                {
                    ULONG       ulNumClips;
                    ULONG       ulDir; // blit direction
                    ULONG       i;
                    BOOL        bMore;
                    ENUMRECTS   enumRect;

                    // we need to know in which direction we have to blit to enumerate
                    // the clipping in the right order !
                    // but we do this only for copyonwindowmove !
                    if(ptlSrcMinusDest.x < 0)       // moving window to right ?
                    {
                        if(ptlSrcMinusDest.y < 0)   // moving window down ?
                            ulDir = CD_LEFTUP;
                        else
                            ulDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if(ptlSrcMinusDest.y < 0)   // moving window down ?
                            ulDir = CD_RIGHTUP;
                        else
                            ulDir = CD_RIGHTDOWN;
                    }

                    ulNumClips = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, ulDir, newNumClipRects);

                    do
                    {
                        bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);

                        // clipping against screen will be done in OglBltBackDepthBuffer
                        // translation is done in OglBltBackDepthBuffer, too
                        for(i=0;i<enumRect.c;i++)
                        {
                            srcRect.right  = enumRect.arcl[i].right   + ptlSrcMinusDest.x;
                            srcRect.left   = enumRect.arcl[i].left    + ptlSrcMinusDest.x;
                            srcRect.top    = enumRect.arcl[i].top     + ptlSrcMinusDest.y;
                            srcRect.bottom = enumRect.arcl[i].bottom  + ptlSrcMinusDest.y;

                            OglBltBackDepthBuffer(ppdev, 
                                                  clientDrawableInfo,
                                                  &srcRect,
                                                  &enumRect.arcl[i]);
                        }
                    }
                    while( bMore );

                    // reset enumeration with values for ICD exclusive cliplist generationg function
                    ulNumClips = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, newNumClipRects);
                }
            }
        }

        ClipRectListToScreen(ppdev, 
                             windowRectList, clientDrawableInfo->numClipRects,
                             clientDrawableInfo->cxScreen, clientDrawableInfo->cyScreen);
        CharacterizeTheClip(ppdev, clientDrawableInfo, windowRectList, origRectList);
        CheckFullScreen(ppdev, clientDrawableInfo);
    }
}

//******************************************************************************
//
//  Function:   OglClipRectToScreen
//
//  Routine Description:
//
//      Implements a routine that clips a rectangle to the PDEV size.
//
//  Arguments:
//
//  Return Value:
//
//      None
//
//******************************************************************************
void OglClipRectToScreen(
    RECTL *rect,
    LONG cxScreen,
    LONG cyScreen
)
{
    if (rect->left < 0)
        {
        rect->left = 0;
        }
    if (rect->top < 0) 
        {
        rect->top = 0;
        }
    if (rect->right > cxScreen) 
        {
        rect->right = cxScreen;
        }
    if (rect->bottom > cyScreen) 
        {
        rect->bottom = cyScreen;
        }

    if (IsNullRect(rect))
        {
        *rect = nullRect;
        }
}

//******************************************************************************
//
//  Function:   NV4_OglFlushClipped
//
//  Routine Description:
//
//      Implements a routine that flushes a push buffer based on the clip list.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
ULONG NV4_OglFlushClipped(
    PDEV *ppdev, 
    HWND hWnd, 
    HDC hDC, 
    ULONG hClient, 
    __GLNVflushInfo *flushInfo
)
{
#ifndef NV3 // Do this for NV4 and higher only...
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    ULONG                      *pCmdBuf;
    ULONG                      *pClipStart;
    LONG                       dwCmdBufFreeCount;
    ULONG                      rectCount;
    RECTL                      *rectList;
    ULONG                      *pushBufferBase;
    ULONG                      *pushBufferEnd;
    LONG                       x;
    LONG                       y;
    LONG                       w;
    LONG                       h;
    ULONG                      ulClipHorizontal;
    ULONG                      ulClipVertical;
#ifndef USE_CLIENT_RECT_LIST
    LONG                       windowLeft;
    LONG                       windowTop;
#endif
    ULONG                      listSize;
    RECTL                      *windowRectList;
    LONG                       status;
    __GLNVcmdInfo              *cmdInfo;
    RECTL                      ubbRect;

    if (!flushInfo || 
        ppdev->dwGlobalModeSwitchCount != flushInfo->localModeSwitchCount) 
        {
        //
        // In this case, the client side should increment
        // the push buffer pointers but not render the buffer.
        //
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_MODE_SWITCH\n");
        flushInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)TRUE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
    }

        try
        {
        cmdInfo = flushInfo->cmdInfo;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV4_OglFlushClipped: cmdInfo: exception = 0x%lx", status));
                return((ULONG)FALSE);
    }    
    // assert(cmdInfo);
    
#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif

    //
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    //
    if (flushInfo->clipChangedCount != clientDrawableInfo->clipChangedCount)
        {
        flushInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)TRUE); 
        }

    windowRectList = clientDrawableInfo->copyWindowRect;
    if (clientDrawableInfo->cachedClipListDirty ||
        flushInfo->wndClipRectChanged)
    {
        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
            windowRectList,
            clientDrawableInfo->numClipRects,
            (LONG) (clientDrawableInfo->rect.left - ppdev->left),
            (LONG) (clientDrawableInfo->rect.top - ppdev->top),
            NULL, &listSize);
        
        if (listSize >= clientDrawableInfo->cachedClipListSize)
        {
            // Reallocate the cached clip list
            
            //
            // Free memory associated with cached clip list of client drawable info.
            //
            if (clientDrawableInfo->cachedClipRectList)
            {
                EngFreeMem(clientDrawableInfo->cachedClipRectList);
                clientDrawableInfo->cachedNumClipRects = 0;
                clientDrawableInfo->cachedClipListSize = 0;
            }
            
            // To avoid thrashing, add MAX_OGL_CLIP_RECTS
            listSize += MAX_OGL_CLIP_RECTS;

            // Allocate the cached clip list now.
            clientDrawableInfo->cachedClipRectList = 
                EngAllocMem(FL_ZERO_MEMORY, 
                (sizeof(RECTL) * listSize), ALLOC_TAG);
            
            if (clientDrawableInfo->cachedClipRectList == NULL)
            {
                DISPDBG((1, "NV4_OglFlushClipped  - Failed EngAllocMem  of CachedClipRectList"));
                OglDebugPrint("****************** FAILURE NV4_OglFlushClipped: EngAllocMem  of CachedClipRectList");
                flushInfo->retStatus = OGL_ERROR_REALLOC_FAILURE; 
                return((ULONG)FALSE);
            }
            
            clientDrawableInfo->cachedClipListSize = listSize;
        }
        
        
        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
            windowRectList,
            clientDrawableInfo->numClipRects,
            (LONG) (clientDrawableInfo->rect.left - ppdev->left),
            (LONG) (clientDrawableInfo->rect.top - ppdev->top),
            &(clientDrawableInfo->cachedClipRectList[0]), 
            &(clientDrawableInfo->cachedNumClipRects));
        
        clientDrawableInfo->cachedClipListDirty = FALSE;
        
    }


    //**********************************************************************
    //**********************************************************************
    // Call into the shared library to do the kickoff
    //**********************************************************************
    //**********************************************************************
    cmdInfo->ntDrawable = (void *)clientDrawableInfo;
    cmdInfo->ntOther = ppdev;
   
    __glNV4FlushInternal(cmdInfo);

    flushInfo->retStatus = OGL_ERROR_NO_ERROR;
#endif  // #ifndef NV3  // Do this for NV4 and higher only...
    return (TRUE);


}

/*
 * Take two input rectangle regions and merge them into one.
 * If list1 and list2 are in window coordinates, leftList2 = topList2 = 0
 * If list1 and list2 are in screen coordinates, leftList2 = topList2 = 0
 * If list1 is window coordinates, list2 is in screen coordinates,
 *      leftList2 = windowLeft of list2, topList2 = windowTop oflist2.
 * Last case uninteresting as it should have been called by switching list1 and list2. 
 */
void CombineRectLists(RECTL *rectList1, ULONG count1, 
                 RECTL *rectList2, ULONG count2,
         LONG  leftList2, LONG topList2,
                 RECTL *resultList, ULONG *resultCount)
{
    ULONG i, j , k;
    RECTL *inpRect1, *inpRect2, *outRect;
    LONG l1, l2, r1, r2, t1, t2 ,b1, b2;
    RECTL tmpRect;

    // Error
    if (resultCount == NULL)
        return;

    *resultCount = 0;

    // Output list is null and out count is 0
    if ((rectList1 == NULL) || (rectList2 == NULL) || (count1 == 0) || (count2 == 0))
        return;

    // Assumes left <= right and top <= bottom
    k = 0;

    // If result List is NULL, the caller is just asking for size of output list.

    if (resultList == NULL)
    {
        outRect = &tmpRect;
    }
    else
    {
        outRect = &(resultList[0]);
    }

    for (j = 0, inpRect2 = &(rectList2[0]) ; j < count2; j++, inpRect2++) {

        l2 = inpRect2->left - leftList2;
        r2 = inpRect2->right - leftList2;
        b2 = inpRect2->bottom - topList2;
        t2 = inpRect2->top - topList2;

        for (i = 0, inpRect1 = &(rectList1[0]); i < count1; i++, inpRect1++) { 

            l1 = inpRect1->left; r1 = inpRect1->right; 
            t1 = inpRect1->top; b1 = inpRect1->bottom;


            outRect->left = ((l1 < l2) ? l2 : l1); 
            outRect->right = ((r1 > r2) ? r2 : r1); 
            outRect->top = ((t1 < t2) ? t2 : t1); 
            outRect->bottom = ((b1 > b2) ? b2 : b1); 

            if ((outRect->left < outRect->right) &&
                (outRect->top < outRect->bottom)) {
                k++; // intersection
                if (resultList != NULL)
                    outRect++;
            } else {
                outRect->left = 0;
                outRect->top = 0;
                outRect->right = 0;
                outRect->bottom = 0;
            }
        }
    }
    *resultCount = k;
}

#if (NVARCH >= 0x4)

ULONG NV_OglFlushClipped(
    PDEV *ppdev, 
    HWND hWnd, 
    HDC hDC, 
    ULONG hClient, 
    __GLNVflushInfo *flushInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    __GLregionRect             boundingRect;
    RECTL                      *windowRectList;
    RECTL                      ubbRect;
 
    if (!flushInfo || 
        ppdev->dwGlobalModeSwitchCount != flushInfo->localModeSwitchCount) 
        {
        //
        // In this case, the client side should increment
        // the push buffer pointers but not render the buffer.
        //
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_MODE_SWITCH\n");
        flushInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)TRUE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }


    try
    {
        cmdInfo = flushInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV_OglFlushClipped: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    
    // assert(cmdInfo);
    
#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif


    //
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    //
    if (!cmdInfo->flushedBetween2D &&
        ((LONG)cmdInfo->windowChangedCount != (LONG)clientDrawableInfo->clipChangedCount))
        {
            flushInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)TRUE); 
        }

    cmdInfo->ntDrawable = (void *)clientDrawableInfo;
    cmdInfo->ntOther = (PDEV *)ppdev;


    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        flushInfo->retStatus = OGL_ERROR_REALLOC_FAILURE; 
        return((ULONG)FALSE);
    }

    __glNVFlushInternal(cmdInfo, FALSE);

    /***** We might need to send info. to client that there was a switch
    ********from complex to simple case....*****************************/

    flushInfo->retStatus = OGL_ERROR_NO_ERROR;
    return((ULONG)TRUE);

}

void *oglXAlloc(size_t size)
{
    void *ptr;

    if (size == 0) {
        return NULL;
    }
    ptr = (void *) EngAllocMem(FL_ZERO_MEMORY, size, ALLOC_TAG);

    if (ptr == NULL) {
        return NULL;    /* XXX out of memory error */
    }
    return ptr;
}

void oglXFree(void *ptr)
{
    if (ptr) {
        EngFreeMem(ptr);
    }
}


void *oglXRealloc(void *oldPtr, size_t oldSize, size_t newSize)
{
    void *newPtr = NULL;

    if (newSize != 0) {
        newPtr = (void *) EngAllocMem(FL_ZERO_MEMORY, newSize, ALLOC_TAG);
        if (oldPtr && newPtr) {
            memcpy(newPtr, oldPtr, (oldSize <= newSize ? oldSize : newSize));
            EngFreeMem(oldPtr);
        }
    } else if (oldPtr) {
        EngFreeMem(oldPtr);
    }
    if (newPtr == NULL) {
        return NULL;    /* XXX out of memory error */
    }
    return newPtr;
}

RegDataPtr oglXAllocData(int n) 
{
    RegDataPtr retPtr;

    retPtr = (RegDataPtr)oglXAlloc(REGION_SZOF(n));

    return retPtr;
}

void oglXFreeData(RegionPtr reg)
{
    if (reg)
    {
        if (reg->data && reg->data->size) 
            oglXFree((reg)->data);
    }
}

void nvConvertRegionGL2NV(RegionPtr nvRegion, unsigned char useExclusive, 
                          __GLregionRect *inclusiveRects, int numInclusiveRects,
                          __GLregionRect *exclusiveRects, int numExclusiveRects,
                          __GLregionRect *boundingRect){
    
    __GLregionRect *GLrects;
    BoxPtr nvRegionRects;
    int i;

    if (!nvRegion)
        return;

    oglXFreeData(nvRegion);

    if(useExclusive){
        nvRegion->data = oglXAllocData(numExclusiveRects);
        nvRegion->data->numRects = numExclusiveRects;
        GLrects = exclusiveRects;
    } else {
        nvRegion->data = oglXAllocData(numInclusiveRects);
        nvRegion->data->numRects = numInclusiveRects;
        GLrects = inclusiveRects;
    }
    nvRegion->data->size = nvRegion->data->numRects;
    nvRegion->extents.x1 = (short)boundingRect->x0;
    nvRegion->extents.x2 = (short)boundingRect->x1;
    nvRegion->extents.y1 = (short)boundingRect->y0;
    nvRegion->extents.y2 = (short)boundingRect->y1;

    nvRegionRects = REGION_RECTS(nvRegion);
    for (i=0; i<(int)numInclusiveRects; i++) {
        __GLregionRect *rect = &GLrects[i];

        nvRegionRects->x1 = (short)rect->x0;
        nvRegionRects->x2 = (short)rect->x1;
        nvRegionRects->y1 = (short)rect->y0;
        nvRegionRects->y2 = (short)rect->y1;
        nvRegionRects++;
    }
}

void nvConvertRegionNV2GL(RegionPtr nvRegion, unsigned char useExclusive,
                          __GLregionRect **inclusiveRects, int *numInclusiveRects,
                          __GLregionRect **exclusiveRects, int *numExclusiveRects){

    int i;
    BoxRec *nvRegionRects;
    GLint *numrects;
    __GLregionRect **rects;


    if (!nvRegion)
        return;

    nvOptimizeRegion(nvRegion);

    if(useExclusive){
        numrects = numExclusiveRects;
        rects    = exclusiveRects;
    } else {
        numrects = numInclusiveRects;
        rects    = inclusiveRects;
    }

    if(nvRegion->data){

        *numrects = nvRegion->data->numRects;
        if(*rects){
            oglXFree(*rects);
        }
        *rects = oglXAlloc((*numrects) * sizeof(__GLregionRect));

        nvRegionRects = REGION_RECTS(nvRegion);

        for (i=0; i<(int) *numrects; i++) {
            __GLregionRect *rect = &((*rects)[i]);

            // copy region to drawable private
            rect->x0 = nvRegionRects->x1;
            rect->x1 = nvRegionRects->x2;
            rect->y0 = nvRegionRects->y1;
            rect->y1 = nvRegionRects->y2;

            nvRegionRects++;
        }

    } else {
        // If there is no nvRegion->data, then there is just one
        // rect and it is in the 'extents' rect.
        *numrects = 1;
        *rects = oglXAlloc(sizeof(__GLregionRect));
        (*rects)[0].x0 = nvRegion->extents.x1;
        (*rects)[0].x1 = nvRegion->extents.x2;
        (*rects)[0].y0 = nvRegion->extents.y1;
        (*rects)[0].y1 = nvRegion->extents.y2;

    }
}

#endif // (NVARCH >= 0x4)


static void OglBltBackDepthBuffer(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    RECTL *srcRect,
    RECTL *dstRect
)
{
    RECTL drawableRect;
    ULONG ulView;

    COPY_RECT(drawableRect, (*srcRect));
    // convert to screen relative coords
    drawableRect.left   -= ppdev->left;
    drawableRect.right  -= ppdev->left;
    drawableRect.top    -= ppdev->top;
    drawableRect.bottom -= ppdev->top;

    if ((dstRect->bottom - dstRect->top == 
         drawableRect.bottom - drawableRect.top) && // height of src and dest are equal

        (drawableRect.right - drawableRect.left > 0) && // src width > 0
        (drawableRect.bottom - drawableRect.top > 0) && // src height > 0

        (dstRect->right - dstRect->left > 0 && // dst width > 0
         dstRect->bottom - dstRect->top > 0))  // dst height > 0
    {
        LONG dstLeft, dstTop, dstRight, dstBottom;
        LONG srcLeft, srcTop;

        srcLeft   = drawableRect.left;
        srcTop    = drawableRect.top;

        dstLeft   = dstRect->left;
        dstTop    = dstRect->top;
        dstRight  = dstRect->right;
        dstBottom = dstRect->bottom;


        //****************************************************************
        // If double buffering is enabled, then the display driver is
        // already blitting some views when the window moves.
        // Only move buffers that are not double pumped by 2D.
        //****************************************************************

        // stereo loop 
        for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
        {

            if (!bDoublePumped(ppdev, ppdev->singleBack1Offset[ulView])) 
            {
                OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                       ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView],
                                       srcLeft, srcTop,
                                       ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView],
                                       dstLeft, dstTop,
                                       dstRight - dstLeft,
                                       dstBottom - dstTop);
            }

            if (!bDoublePumped(ppdev, ppdev->singleDepthOffset[ulView])) 
            {
                OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                       ppdev->singleDepthOffset[ulView], ppdev->singleDepthPitch[ulView],
                                       srcLeft, srcTop,
                                       ppdev->singleDepthOffset[ulView], ppdev->singleDepthPitch[ulView],
                                       dstLeft, dstTop,
                                       dstRight - dstLeft,
                                       dstBottom - dstTop);
            }
            if (ppdev->bOglOverlaySurfacesCreated) 
            {
                if (!bDoublePumped(ppdev, ppdev->singleFrontMainOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleFrontMainOffset[ulView], ppdev->singleFrontMainPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleFrontMainOffset[ulView], ppdev->singleFrontMainPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                if (!bDoublePumped(ppdev, ppdev->singleBack1MainOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleBack1MainOffset[ulView], ppdev->singleBack1MainPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleBack1MainOffset[ulView], ppdev->singleBack1MainPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                //************************************************************
                // Only blit front and back overlay since the display driver
                // is already multi buffering into front and back main planes
                //************************************************************
                if (!bDoublePumped(ppdev, ppdev->singleFrontOverlayOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                if (!bDoublePumped(ppdev, ppdev->singleBack1OverlayOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }
            }
        }//stereo loop
    }


}

#define bRcIntersect(a,b,c) bRclIntersect((RECTL*)(a),(const RECTL*)(b),(const RECTL*)(c))

//*************************************************************************
// bOglClientIntersectingWithOtherClients
// 
// returns TRUE if the given client intersects with any visible OpenGL client.
//*************************************************************************
BOOL bOglClientIntersectingWithOtherClients(IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfoCheck;
    BOOL                   bClipped = FALSE; // assume it isn't clipped

    ASSERTDD(bOglHasDrawableInfo(clientInfo), "give me a valid clientInfo!");

    clientInfoCheck = NULL; // loop through client list, starting at top
    while (bOglGetNextVisibleClient(&clientInfoCheck))
    {
        if (clientInfoCheck->clientDrawableInfo->hWnd != clientInfo->clientDrawableInfo->hWnd)
        {
            if ( bRcIntersect(NULL, 
                               &clientInfoCheck->clientDrawableInfo->rect, 
                               &clientInfo->clientDrawableInfo->rect) )
            {
                // another OGL window intersects our window and it has some exposed pixels.
                bClipped = TRUE;
                break;
            }
        }
    }

    return (bClipped);
}


//*************************************************************************
// Compute the translated inclusive and exclusive clip lists
// 
// returns TRUE if succeeds, FALSE if we fail (out of memory)
//*************************************************************************
BOOL NV_OglUpdateClipLists(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    if (clientDrawableInfo->cachedClipListDirty)
    {
        // Convert Client Drawable List to window coordinates
        // assert(clientDrawableInfo->numClipRects < clientDrawableInfo->cachedClipListSize);
        if (clientDrawableInfo->numClipRects >= clientDrawableInfo->cachedClipListSize)
        {
            // Reallocate the cached clip list
            
            //
            // Free memory associated with cached clip list of client drawable info.
            //
            if (clientDrawableInfo->cachedClipRectList)
            {
                EngFreeMem(clientDrawableInfo->cachedClipRectList);
            }

            // To avoid thrashing
            clientDrawableInfo->cachedClipListSize = clientDrawableInfo->numClipRects + MAX_OGL_CLIP_RECTS;
            
            // Allocate the cached clip list now.
            clientDrawableInfo->cachedClipRectList = 
                EngAllocMem(FL_ZERO_MEMORY, 
                (sizeof(RECTL) * (clientDrawableInfo->cachedClipListSize)), ALLOC_TAG);
            
            if (clientDrawableInfo->cachedClipRectList == NULL)
            {
                DISPDBG((1, "NV_OglUpdateClipLists  - Failed EngAllocMem  of CachedClipRectList"));
                OglDebugPrint("****************** FAILURE NV_OglUpdateClipLists: EngAllocMem of CachedClipRectList");
                clientDrawableInfo->cachedClipListSize = 0;
                clientDrawableInfo->cachedNumClipRects = 0;
                return FALSE;
            }
        }

        OglTranslateCachedClipRectList(ppdev,
                                       clientDrawableInfo->copyWindowRect,
                                       clientDrawableInfo->numClipRects,
                                       clientDrawableInfo->cachedClipRectList,
                                       &clientDrawableInfo->cachedNumClipRects,
                                       (RECTL *) &clientDrawableInfo->rect);

        /* We only need to update the exclusive clip if we are running on
         * CELSIUS or KELVIN, and if the number of inclusive clip rects
         * exceeds the number of clips supported in the hardware.  In the
         * interest of code simplicity, and because this only happens once
         * per clip change, we always update the exclusive clip.
         */
        if (1 /*clientDrawableInfo->cachedNumClipRects > numHWClipRects*/)
        {
            __GLregionRect boundingRect;

            RegionRec nvInclusiveRegion;
            RegionRec nvExclusiveRegion;

            nvInclusiveRegion.data = 0;
            nvExclusiveRegion.data = 0;

            boundingRect.x0 = 0;
            boundingRect.y0 = 0;
            boundingRect.x1 = clientDrawableInfo->rect.right - clientDrawableInfo->rect.left;
            boundingRect.y1 = clientDrawableInfo->rect.bottom - clientDrawableInfo->rect.top;

            // Convert Inclusive to nvRegion
            nvConvertRegionGL2NV(&nvInclusiveRegion, FALSE, 
                (__GLregionRect *)(clientDrawableInfo->cachedClipRectList), 
                clientDrawableInfo->cachedNumClipRects, 
                (__GLregionRect *)(clientDrawableInfo->cachedExclusiveRectList), 
                clientDrawableInfo->cachedNumExclusiveRects, 
                &boundingRect);

            nvInverse(&nvExclusiveRegion,&nvInclusiveRegion,&(nvInclusiveRegion.extents));

            // Convert nvRegion to Exclusive
            // This will free old exclusive rect list if exists...
            nvConvertRegionNV2GL(&nvExclusiveRegion, TRUE,
                             (__GLregionRect **)(&clientDrawableInfo->cachedClipRectList), 
                             &(clientDrawableInfo->cachedNumClipRects),
                             (__GLregionRect **)(&clientDrawableInfo->cachedExclusiveRectList), 
                             &(clientDrawableInfo->cachedNumExclusiveRects));

            oglXFreeData(&nvExclusiveRegion);
            oglXFreeData(&nvInclusiveRegion);
        }
        else
        {
            // Free associated exclusive rect memory
            // and set it so that it is not used.
            oglXFree(clientDrawableInfo->cachedExclusiveRectList);
            clientDrawableInfo->cachedExclusiveRectList = NULL;
            clientDrawableInfo->cachedNumExclusiveRects = 0;
        }

        clientDrawableInfo->cachedClipListDirty = FALSE;
    }

    return TRUE;
}


//*************************************************************************
// bOglClipRectAgainstClipobj
// 
// Clip the incoming pco against the single prcl. 
//
// return TRUE : there is an intersection between pco and prcl,
//        FALSE: no intersection found
//*************************************************************************
BOOL bOglClipRectAgainstClipobj(
    IN  CLIPOBJ *pco, 
    IN  RECTL   *prcl)
{
    BOOL      bRet = FALSE;

    ASSERT(NULL!=prcl);

    if (NULL == pco)
        goto Exit;

    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
            // special case, we don't have a valid target rect here!
            // fall back to rclBounds, but better do not call it!
            ASSERT(pco->iDComplexity != DC_TRIVIAL);

        case DC_RECT:
            bRet = bRclIntersect(NULL, prcl, &pco->rclBounds);
            break;

        case DC_COMPLEX:
        {
            ENUMRECT4 ce;
            BOOL      bMore;

            // In complex case loop over clip list
        
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, CLIP_LIMIT);

            do
            {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);

                while (!bRet && ce.c--)
                {
                    bRet = bRclIntersect(NULL, prcl, &(ce.arcl[ce.c]));
                }
            }
            while (!bRet && bMore);
            break;
        }
    }

Exit:
    return (bRet);
}


//*************************************************************************
// bOglClipBoundsUpdate
// 
// Calculate bounding rect of all visible OpenGL clients
// returns TRUE if there is at least one visible client with a valid rect
// returns FALSE if no client is visible.
//*************************************************************************
BOOL bOglClipBoundsUpdate(struct _OGLSERVER *pOglServer )
{
    BOOL                     bRet               = FALSE; // no client visible, no bounding rect
    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    RECTL                   *prclBounds;

    ASSERT(NULL!=pOglServer);

    prclBounds = &pOglServer->rclAllClientsBounds;

    if (bOglGetNextVisibleClient(&clientInfo))
    {
        ASSERT(NULL != clientInfo);
        ASSERT(NULL != clientInfo->clientDrawableInfo);

        // start with first clients rect.
        *prclBounds = *((RECTL *)&clientInfo->clientDrawableInfo->rect);

        // find first visible ogl client 
        // and initialize clientInfo with pointer to it
        while (bOglGetNextVisibleClient(&clientInfo))
        {
            ASSERT(NULL != clientInfo);
            ASSERT(NULL != clientInfo->clientDrawableInfo);

            vRclBounds(prclBounds, (RECTL*)&clientInfo->clientDrawableInfo->rect, prclBounds);
        }
        bRet = TRUE;
    }
    else
    {
        // initialize with rectangle completely outside screen
        *prclBounds = rclOutside;
        bRet = FALSE;
    }

    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvsetdac.c ===
/************************** Module Header *************************************
 *                                                                             *
 *  Module Name: nvsetdac.c                                                    *
 *                                                                             *
 *                                                                             *
 *   Copyright (C) 1997-present NVidia Corporation. All Rights Reserved.       *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );
extern ULONG GetPrevDevMaskRegValue(PPDEV ppdev);
extern VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal);
extern BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData);

// Enable Double Scan for height <= this value
#define HEIGHT_ENABLE_DOUBLE_SCAN       384

BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution)
{
	DAC_TIMING_VALUES sTimingDac;
    HEAD_RESOLUTION_INFO HeadResolution;
    DWORD ReturnedDataLength;
    DWORD ulFormat = 0;


    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //
    // Fill up the head resolution info structure used for the common modeset code.
    //
    HeadResolution.ulDisplayWidth = pResolution->ulDisplayWidth;
    HeadResolution.ulDisplayHeight= pResolution->ulDisplayHeight;  	
    HeadResolution.ulDisplayRefresh = pResolution->ulDisplayRefresh;  	
    
    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulOption = HEAD_RESOLUTION_OPTION_DONT_BACKOFF;
    switch (pResolution->ulDisplayPixelDepth)
    {
        case BMF_32BPP:
            HeadResolution.ulDisplayPixelDepth = 32;
            break;
        case BMF_16BPP:
            HeadResolution.ulDisplayPixelDepth = 16;
            break;
        case BMF_8BPP:
            HeadResolution.ulDisplayPixelDepth = 8;
            break;
        default:
            DISPDBG((0,"Oops! Invalid color depth: 0x%x\n",pResolution->ulDisplayPixelDepth));
            return(FALSE);
    }


    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           &HeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
    	DISPDBG((0, "nvsetdac.c - IOCTL_VIDEO_GET_TIMING_DAC failed"));
		return FALSE;
    }

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_PREMODE_SET,
                           &ulHead,  // input buffer
                           sizeof(ULONG),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
    	DISPDBG((0, "nvsetdac.c - IOCTL_VIDEO_PREMODE_SET failed"));
		return FALSE;
    }

    DISPDBG((1,"\nNvSetDac() headResolutionInfo: ........................................."));

    DISPDBG((1,"    ulDisplayWidth: %d",HeadResolution.ulDisplayWidth));
    DISPDBG((1,"    ulDisplayheight: %d",HeadResolution.ulDisplayHeight));
    DISPDBG((1,"    ulDisplayRefresh: %d",HeadResolution.ulDisplayRefresh));
    DISPDBG((1,"    ulDisplayPixelDepth: %d",HeadResolution.ulDisplayPixelDepth));
    DISPDBG((1,"    ulHead: %d",HeadResolution.ulHead));
    DISPDBG((1,"    ulDeviceMask: 0x%x",HeadResolution.ulDeviceMask));
    DISPDBG((1,"    ulDeviceType: %d",HeadResolution.ulDeviceType));
    DISPDBG((1,"    ulTVFormat: %d",HeadResolution.ulTVFormat));
    DISPDBG((1,""));

    DISPDBG((1,"TimingParameters: "));
    DISPDBG((1,"    sTimingDac.HorizontalVisible: 0x%x",sTimingDac.HorizontalVisible));
    DISPDBG((1,"    sTimingDac.VerticalVisible: 0x%x",sTimingDac.VerticalVisible));
    DISPDBG((1,"    sTimingDac.Refresh: 0x%x",sTimingDac.Refresh));
    DISPDBG((1,"    sTimingDac.HorizontalTotal: 0x%x",sTimingDac.HorizontalTotal));
    DISPDBG((1,"    sTimingDac.VerticalTotal: 0x%x",sTimingDac.VerticalTotal));
    DISPDBG((1,"    sTimingDac.HorizontalBlankStart: 0x%x",sTimingDac.HorizontalBlankStart));
    DISPDBG((1,"    sTimingDac.VerticalBlankStart: 0x%x",sTimingDac.VerticalBlankStart));
    DISPDBG((1,"    sTimingDac.HorizontalRetraceStart: 0x%x",sTimingDac.HorizontalRetraceStart));
    DISPDBG((1,"    sTimingDac.VerticalRetraceStart: 0x%x",sTimingDac.VerticalRetraceStart));
    DISPDBG((1,"    sTimingDac.HorizontalRetraceEnd: 0x%x",sTimingDac.HorizontalRetraceEnd));
    DISPDBG((1,"    sTimingDac.VerticalRetraceEnd: 0x%x",sTimingDac.VerticalRetraceEnd));
    DISPDBG((1,"    sTimingDac.HorizontalBlankEnd: 0x%x",sTimingDac.HorizontalBlankEnd));
    DISPDBG((1,"    sTimingDac.VerticalBlankEnd: 0x%x",sTimingDac.VerticalBlankEnd));
    DISPDBG((1,"    sTimingDac.PixelClock: 0x%x",sTimingDac.PixelClock));
    DISPDBG((1,"    sTimingDac.HSyncpolarity: 0x%x",sTimingDac.HSyncpolarity));
    DISPDBG((1,"    sTimingDac.VSyncpolarity: 0x%x",sTimingDac.VSyncpolarity));

    
    DISPDBG((1,"NvSetDac() End........................................................\n"));

#if _WIN32_WINNT >= 0x0500

    // setup mode set using DMA push channel
    
    NV_DMAPUSH_CHECKFREE(( (ULONG) (20) ));  

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_NOTIFIES, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_IMAGE_SIZE(0), (sTimingDac.VerticalVisible << 16) | sTimingDac.HorizontalVisible);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_HORIZONTAL_BLANK(0), sTimingDac.HorizontalBlankStart | 
                                                ((sTimingDac.HorizontalBlankEnd -   sTimingDac.HorizontalBlankStart ) << 16));


    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_HORIZONTAL_SYNC(0),  sTimingDac.HorizontalRetraceStart | 
                                                ((sTimingDac.HorizontalRetraceEnd - sTimingDac.HorizontalRetraceStart ) << 16));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_VERTICAL_BLANK(0), sTimingDac.VerticalBlankStart | 
                                                ((sTimingDac.VerticalBlankEnd -   sTimingDac.VerticalBlankStart ) << 16));
                                                                        
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_VERTICAL_SYNC(0),  sTimingDac.VerticalRetraceStart | 
                                                ((sTimingDac.VerticalRetraceEnd - sTimingDac.VerticalRetraceStart ) << 16));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_TOTAL_SIZE(0),  sTimingDac.VerticalTotal << 16 | sTimingDac.HorizontalTotal);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_PIXEL_CLOCK(0), sTimingDac.PixelClock);

#else

    // setup mode set using Direct Method Call
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_CONTEXT_DMA_NOTIFIES,
            NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set context DMA notifies"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_IMAGE_SIZE(0),
            (sTimingDac.VerticalVisible << 16) | sTimingDac.HorizontalVisible
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC image size"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_HORIZONTAL_BLANK(0),
            sTimingDac.HorizontalBlankStart | ((sTimingDac.HorizontalBlankEnd - sTimingDac.HorizontalBlankStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC horizontal blank"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_HORIZONTAL_SYNC(0),
            sTimingDac.HorizontalRetraceStart | ((sTimingDac.HorizontalRetraceEnd - sTimingDac.HorizontalRetraceStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC horizontal sync"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_VERTICAL_BLANK(0),
            sTimingDac.VerticalBlankStart | ((sTimingDac.VerticalBlankEnd - sTimingDac.VerticalBlankStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC vertical blank"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_VERTICAL_SYNC(0),
            sTimingDac.VerticalRetraceStart | ((sTimingDac.VerticalRetraceEnd - sTimingDac.VerticalRetraceStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC vertical sync"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_TOTAL_SIZE(0),
            sTimingDac.VerticalTotal << 16 | sTimingDac.HorizontalTotal
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC total size"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_PIXEL_CLOCK(0),
            sTimingDac.PixelClock
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC pixel clock"));
    }
        
#endif // _WIN32_WINNT >= 0x0500

    if (sTimingDac.VerticalVisible <= HEIGHT_ENABLE_DOUBLE_SCAN)
    {
        ulFormat |= NV046_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED;
    }

    // map to VIDEO_LUT_CURSOR_DAC class values
    if((sTimingDac.HSyncpolarity == 1) || (sTimingDac.HSyncpolarity == 4))
        sTimingDac.HSyncpolarity = NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE;
    else
        sTimingDac.HSyncpolarity = NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE;

    if((sTimingDac.VSyncpolarity == 1) || (sTimingDac.VSyncpolarity == 8))
        sTimingDac.VSyncpolarity = NV046_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE;
    else
        sTimingDac.VSyncpolarity = NV046_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE;

    ulFormat |= (sTimingDac.HSyncpolarity << 2);
    ulFormat |= (sTimingDac.VSyncpolarity << 3);
    ulFormat |= (ulHead << 26);

    switch (pResolution->ulDisplayPixelDepth)
    {
        case BMF_32BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8 << 16);
            break;
        case BMF_16BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5 << 16);
            break;
        case BMF_8BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8 << 16);
            break;
        default:
            return(FALSE);
    }

    switch(ppdev->ulDeviceType[ulHead])
    {
        case MONITOR_TYPE_VGA:
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT << 20);
            break;
        case MONITOR_TYPE_NTSC:      
        case MONITOR_TYPE_PAL:       
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_TV << 20);
            ulFormat |= ((ppdev->ulTVFormat[ulHead] & 0x07) << 22);
            break;
        case MONITOR_TYPE_FLAT_PANEL:
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_DFP << 20);
            break;
        case INVALID_DEVICE_TYPE:
            DISPDBG((0,"Oops! Invalid device type for Head: %d. Lets assume a CRT",ulHead));
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT << 20);
            break;
    }

    // Specify if this head is the 'primary' head or not.
    if (ulHead == ppdev->ulDeviceDisplay[0] && ppdev->ulDualViewSecondary == 0)
    {
        // This is the primary head.
        ulFormat |= (NV07C_SET_DAC_FORMAT_PRIMARY_DEVICE_TRUE << 28);
    }
    else
    {
        // This is not the primary head so make sure the bit is turned off.
        ulFormat |= (NV07C_SET_DAC_FORMAT_PRIMARY_DEVICE_FALSE << 28);
    }


#if _WIN32_WINNT >= 0x0500

    // perform mode set using DMA push channel
    
    ulFormat |= (NV046_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY << 31);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_FORMAT(0), ulFormat);


    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Initialize patch
    //**************************************************************************
    NV4_DmaPushSend(ppdev);

    // Wait for the mode is set.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    
#else

    // perform mode set using Direct Method Call -- no notification needed
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_FORMAT(0),
            ulFormat
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC format"));
    }
        
#endif // _WIN32_WINNT >= 0x0500

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_POSTMODE_SET,
                           &ulHead,  // input buffer
                           sizeof(ULONG),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
    	DISPDBG((1, "nvsetdac.c - IOCTL_VIDEO_POSTMODE_SET failed"));
		return FALSE;
    }

#if _WIN32_WINNT >= 0x0500

    // Setup the DMA context of LUT using DMA channel
    NV_DMAPUSH_CHECKFREE(( (ULONG) (2) ));  
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_LUT(0), NV_WIN_COLORMAP_CONTEXT+ulHead);
    
#else

    // setup the DMA context of LUT using Direct Method Call
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_CONTEXT_DMA_LUT(0),
            NV_WIN_COLORMAP_CONTEXT + ulHead
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
    }
        
#endif // _WIN32_WINNT >= 0x0500
    
    // Since the VIDEO can call this function directly, the gamma values will be set multiple times.
    if (pResolution->ulDisplayPixelDepth != BMF_8BPP)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_RESTORE_GAMMA_VALUES,
                           NULL,
                           0,
                           ppdev->ajClutData,  
                           sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256,
                           &ReturnedDataLength))
        {
    	    DISPDBG((1, "nvsetdac.c - IOCTL_VIDEO_POSTMODE_SET failed"));
        }
    }
    
    
        // Cannot call un-initialized function ppdev->pfnSetPalette
#if _WIN32_WINNT >= 0x0500

    // setup LUT using DMA push channel
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    
#else

    // setup LUT using Direct Method Call -- no notification needed
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_LUT_OFFSET(0),
            0
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_LUT_FORMAT(0),
            0                                   // don't need notification w/DMC
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT format"));
    }
        
#endif // _WIN32_WINNT >= 0x0500



    return(TRUE);

}

BOOL NvInitialDac(PDEV *ppdev)
{

    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;
    RESOLUTION_INFO Res;
    ULONG i;
    ULONG ulHead;
    PVOID parms;
    ULONG ulDisplayWidth, ulDisplayHeight, ulOldValue;
    ULONG ulCombinedMask;
    ULONG ulPrimaryHead;
    NV_CFGEX_DISPLAY_CHANGE_START_PARAMS BracketParams;
    ULONG ulPanOffset;
    ULONG ulPrevDevMask;
    BOOLEAN bDoBracketing = FALSE;
    ULONG ulStopImage;
    
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    DISPDBG((1, "\nNvInitializeDAC: ppdev = 0x%08x", ppdev));
    DISPDBG((1, "ppdev->pjScreen               = 0x%08x", ppdev->pjScreen));
    DISPDBG((1, "ppdev->ulPrimarySurfaceOffset = 0x%08x", ppdev->ulPrimarySurfaceOffset));
    DISPDBG((1, "ppdev->pjFrameBufbase         = 0x%08x", ppdev->pjFrameBufbase));


    // We need to let resman know a combined mask for the devices that ae going to
    // be used in this mode.
    ulCombinedMask = 0;
    for (i = 0;
         i < ((ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL) ? ppdev->ulNumberDacsActive : ppdev->ulNumberDacsConnected);
         i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ulCombinedMask |= ppdev->ulDeviceMask[ulHead];
    }
    BracketParams.NewDevices = (ulCombinedMask | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET);
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        BracketParams.Properties = 1;
    }
    else
    {
        BracketParams.Properties = 0;
    }

    ulPrevDevMask = GetPrevDevMaskRegValue(ppdev);

    if (ulPrevDevMask == 0)
    {
        //
        // we are booting up, so we need to do the bracketing.
        //
        bDoBracketing = TRUE;
    }
    else
    if (ulPrevDevMask != ulCombinedMask)
    {
        //
        // the previous mode dev mask is different than the new mode device mask, so we need to do the bracketing.
        //
        bDoBracketing = TRUE;
    }


    if (bDoBracketing)
    {
        DISPDBG((1, "Doing the modeset bracketing: PrevDevMask: 0x%x, CurrentMask: 0x%x",ulPrevDevMask, ulCombinedMask));
    }
    else
    {
        DISPDBG((1, "Not Doing the modeset bracketing: PrevDevMask: 0x%x, CurrentMask: 0x%x",ulPrevDevMask, ulCombinedMask));
    }
   
    
    if (bDoBracketing)
    {
        // Let ResMan know we are starting the modeset process for the LUT_CURSOR objects.
        if (NvConfigSetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFGEX_DISPLAY_CHANGE_START, &BracketParams, sizeof(BracketParams))) {
            ASSERTDD(1,"Error in Notifying Start bracket of modeset to ResMan");
        }
    }
    else
    {
        if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
        {
            if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_DISPLAY_CHANGE_CONFIG, 1, &ulOldValue)) 
            {
                    ASSERTDD(1,"Error in Setting NV_CFG_DISPLAY_CHANGE_CONFIG");
            }
        }
        else
        {
            if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_DISPLAY_CHANGE_CONFIG, 0, &ulOldValue)) 
            {
                    ASSERTDD(1,"Error in Setting NV_CFG_DISPLAY_CHANGE_CONFIG");
            }
        }
    }

    // Initialize status of all Notifiers to "nothing pending"
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_CURSOR_IMAGE(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_CURSOR_IMAGE(1)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    
    Res.ulDisplayPixelDepth = ppdev->cBitsPerPel;

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        NV_CREATE_OBJECT_SETUP();

        ulHead = ppdev->ulDeviceDisplay[i];

        if (ulHead > 0) {
            nv07cAllocParms.logicalHeadId = ulHead;
            parms = &nv07cAllocParms;
        } else {
            parms = NULL;
        }
        NV_CREATE_OBJECT_INIT();
        // NV5 will use NV04_VIDEO_LUT_CURSOR_DAC class because the method offset of NV05_VIDEO_LUT_CURSOR_DAC 
        // is different from other NV??_VIDEO_LUT_CURSOR_DAC classes.
        NV_CREATE_DMA3(parms,NV_VIDEO_LUT_CURSOR_DAC+ulHead, 
                       NV15_VIDEO_LUT_CURSOR_DAC,NV10_VIDEO_LUT_CURSOR_DAC,
                       NV04_VIDEO_LUT_CURSOR_DAC);
        if (NV_CREATE_OBJECT_FAIL()) {
            return (FALSE);
        } else {
            ppdev->CurrentClass.VideoLutCursorDac = NV_CREATE_OBJECT_CLASS();
        }

        Res.ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        Res.ulDisplayHeight = ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        Res.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];  
        Res.ulDisplayPixelDepth = ppdev->iBitmapFormat;

        NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_IMAGE(0), DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);

        UPDATE_PDEV_DMA_COUNT;
        NvSetDac(ppdev, ulHead, &Res);
    	UPDATE_LOCAL_DMA_COUNT;

         // Wait for previous image completed
        ppdev->ulHeadDisplayOffset[ulHead] = ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta
                                             + ppdev->ulPrimarySurfaceOffset;
        ulPanOffset = ppdev->rclCurrentDisplay[ulHead].left * ppdev->cjPelSize + ppdev->rclCurrentDisplay[ulHead].top * ppdev->lDelta 
                                             + ppdev->ulPrimarySurfaceOffset - ppdev->ulHeadDisplayOffset[ulHead];

        DISPDBG((1, "ppdev->ulHeadDisplayOffset[%d] = 0x%08x", ulHead, ppdev->ulHeadDisplayOffset[ulHead]));
        DISPDBG((1, "ulPanOffset = 0x%08x", ulPanOffset));

        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), ppdev->ulHeadDisplayOffset[ulHead]);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_PAN_OFFSET, ulPanOffset);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0),
                          ppdev->lDelta | NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
        
        //**************************************************************************
        // Make sure to update the DMA count before we kickoff!
        //**************************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
    }


    if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_SCREEN_WIDTH, ppdev->cxScreen, &ulOldValue)) {
        ASSERTDD(1,"Error in Setting DAC");
    }


    if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_SCREEN_HEIGHT, ppdev->cyScreen, &ulOldValue)) {
        ASSERTDD(1,"Error in Setting DAC");
    }

    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));
    ulPrimaryHead = ppdev->ulDeviceDisplay[0];
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulPrimaryHead);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_NOTIFY, NV046_NOTIFY_WRITE_ONLY);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_IMAGE(0), DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    

    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;

    // Set up the notifier after waitinf for any existing notification to finish.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV4_DmaPushSend(ppdev);

    // Now wait for the DMA to complete.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

    if (bDoBracketing)
    {
        // Let ResMan know we are finished with the modeset process for the LUT_CURSOR objects.
        if (NvConfigSetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFGEX_DISPLAY_CHANGE_END, &BracketParams, sizeof(BracketParams))) {
            ASSERTDD(1,"Error in Notifying End bracket of modeset to ResMan");
        }
    }

    //
    // Now write the current modeset device mask to the registry as PrevDevMask.
    //
    SetPrevDevMaskRegValue(ppdev, ulCombinedMask);



    //
    // We need to in effect, defer this modeset if we have scheduled a modeset via NVSVC.
    // This way, the user does not 'see' two modesets happen. The cursor needs to be disabled too.
    // Currently we do this only for Win2K and later since we are not supporting laptops in NT4.0
    //
    ulStopImage = 0;
    if (ppdev->ulInduceModeChangeDeviceMask)
    {
        ulStopImage = 1;
    }

    //
    // If the ModesetStopImage feature for sony has been enabled and the registry entry tells us to
    // stop the image, we invoke the STOP_IMAGE method.
    //
    if (ppdev->EnableModesetStopImage)
    {
        ULONG ModesetStopImage = 0;
        GetULONGRegValue(ppdev, "ModesetStopImage", &ModesetStopImage);
        if (ModesetStopImage == 1)
        {
            ulStopImage = 1;
        }
    }
     
    //
    // stop the image if needed.    
    //
    if (ulStopImage)
    {   
        for(i = 0; i < ppdev->ulNumberDacsActive; i++)
        {
        
            ulHead = ppdev->ulDeviceDisplay[i];

            DISPDBG((1, "Stopping Image to defer the first modeset since NVSVC is scheduled for a modeset"));
            NV_DMAPUSH_CHECKFREE(( (ULONG) (8) ));  
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_NOTIFIES, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_NOTIFY, NV046_NOTIFY_WRITE_ONLY);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_STOP_IMAGE(0), NV046_STOP_IMAGE_AS_SOON_AS_POSSIBLE);
            //**************************************************************************
            // Make sure to update the DMA count before we kickoff!
            //**************************************************************************
            UPDATE_PDEV_DMA_COUNT;
            // Set up the notifier after waitinf for any existing notification to finish.
            while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
            ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

            NV4_DmaPushSend(ppdev);

            // Now wait for the DMA to complete.
            while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
        }
    }
    
    
    return(TRUE);
}

//**************************************************************************
// Restores DACs that may have been flipped by OpenGL to the primary surface
// PaulP
//**************************************************************************

void NvRestoreDacs(PDEV *ppdev)
{
    void __cdecl NVMoveDisplayWindow(PDEV* ppdev, ULONG ulHead, RECTL * prclCurrentDisplay);

    RECTL *prclCurrentDisplay;
    ULONG ulHead;
    ULONG i;

    if (ppdev->ulFlipBase != ppdev->ulPrimarySurfaceOffset)
    {
        ASSERT(OGL_FLIPPED());

        ppdev->ulFlipBase = ppdev->ulPrimarySurfaceOffset;

        for (i=0; i < ppdev->ulNumberDacsActive; i++)
        {
            ulHead = ppdev->ulDeviceDisplay[i];
            prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];
            NvSetDacImageOffset(ppdev, ulHead,
                ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta);
            #ifdef NV3
                // Pan and Scan feature is not supported in NV3.
            #else
                NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
            #endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglcmd.c ===
//******************************Module*Header***********************************
// Module Name: oglcmd.c
//
// OpenGL command dispatcher
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#include "nvdoublebuf.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglclip.h"
#include "Nvcm.h"

#if (NVARCH >= 0x4)

ULONG
NV_OglOperation(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    __GLNVoperation *op
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;

    /* TODO -
     * perform the windowChangedCount test here
     * cache window-relative clip list so we don't have to compute it here
     */

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList) {
        clientInfo = &clientList->clientInfo;
    }  else {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_CLIENT_NOT_FOUND
        return FALSE;
    }

    if (clientInfo) {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
    } else {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_CLIENT_NOT_FOUND
        return FALSE;
    }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_REALLOC_FAILURE\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    op->clip.numRects = clientDrawableInfo->cachedNumClipRects;
    op->clip.rects = (__GLregionRect *)clientDrawableInfo->cachedClipRectList;
    
    op->cmdInfo->ntOther      = (void *)ppdev;
    op->cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    op->cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(op->cmdInfo->ntClientInfo));

    switch (op->opCode) {
    case NVOP_CLEAR:
        //__glNVSetupClear(op);
        return TRUE;
    case NVOP_SWAP: // not yet
    default:
        op->retStatus = NVOP_STATUS_UNKNOWN_OP;
        return FALSE;
    }
}

#endif  // #if (NVARCH >= 0x4)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglDD.h ===
#ifndef __OGLDD_H
#define __OGLDD_H

// DirectDraw ------------------------------------------------------
#if _WIN32_WINNT >= 0x0500
#include "nvPriv.h"

// ----- Escapes: these are duplicated in escape.h to block out these numbers
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88

// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89

// ----- Prototypes
extern NVS2VERROR __stdcall nvMoComp(LPNVS2VDATATYPE lpS2VData);
extern NVOCERROR __stdcall nvOverlayControl(LPNVOCDATATYPE lpOCData);
#endif  // WINNT >= 0x500

// OGL -------------------------------------------------------------

//*************************************************************************
// OGLSERVER
// 
// This structure is hooked to the display driver ppdev, created at startup
// time of the driver (DrvEnableSurface and deleted in DrvDisableSurface). 
// On creation it is initialized with 0 (zero), you can rely on this!
// It should be used to store all OpenGL server related data. 
// All OpenGL stuff inside ppdev will be moved to this structure (later).
//
// Please add a good comment to all variables!
//*************************************************************************
typedef struct _OGLSERVER
{
    // rclAllClientsBounds is the bounding rectangle around all visible
    // OpenGL clients.
    RECTL rclAllClientsBounds; 

    // bGdiInOglWindowNeedsSync to determine if a GDI command was rendering 
    // to the OGL window and needs to be synced before OGL is allowed to 
    // continue.
    // TRUE:  GDI is rendering to OGL window and needs to be synced before 
    //        OGL is rendering!
    // FALSE: nothing needs to be done
    BOOL  bGdiInOglWindowNeedsSync;   

    // bWindowInMovement is used to notify the oglsync code that a 
    // copy on windowmove of the ogl is in progress.
    // TRUE  : OGL window is moving.
    // TRUE  : OGL window isn't moving.
    BOOL  bWindowInMovement;          

    // ulPageFlipRetryCounter will control how and if bOglPageFlipModeUpdate
    // is allowed to enable pageflipping again, after it was disabled.
    ULONG ulPageFlipRetryCounter;     
} OGLSERVER;


//
// Defines used to work with OGLSERVER->ulPageFlipRetryCounter
// PAGEFLIP_IMMEDIATE_UPDATE
//      An immediate pageflip update is enabled. This is the default 
//      behaviour of the driver. Pageflip updates are not defer and 
//      the retry counter is disabled.
//      
// PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP
//      retry to enable pageflipping in next swap buffers
//
// PAGEFLIP_RETRY_COUNTER_START >= i > PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP
//      countdown area, do not enable pageflipping within this area
//
// PAGEFLIP_RETRY_COUNTER_START
//      Use this to initialize the counter. As long it is within the 
//      countdown area, pageflipping isn't enabled!
#define PAGEFLIP_IMMEDIATE_UPDATE           0
#define PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP  1
#define PAGEFLIP_RETRY_COUNTER_START        (ppdev->ulGDIRefreshRate)


//******************************************************************
// This is the maximum number of ddraw surfaces that we allow to
// exist before we disable window flipping for OpenGL.  This is tested
// against in __glNVDoDACParams() and in NV_OglDDrawSurfaceCreated().
//
// The surface count lives in ppdev->oglDDrawSurfaceCount and is
// incremented by NV_OglDDrawSurfaceCreated() and decremented by
// NV_OglDDrawSurfaceDestroyed().  On NT5, the real ddraw driver calls
// these routines from CreateSurface32/DestroySurface32 in the ddraw
// subtree.  On NT4 they are called from within the display driver in
// DdCreateSurface and Nv4DestroySurface since ddraw is built into the
// display driver.
//
// For NT5 this maximum is 2 since running any opengl app will create 
// 2 ddraw surfaces. On NT4, no ddraw surfaces are created for an opengl
// app so anything above 0 signifies that an actual ddraw app was
// started
//******************************************************************
#if _WIN32_WINNT >= 0x0500
#define OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING 2
#else
#define OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING 0
#endif

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#ifdef _WIN64
#define __GLNV_FENCE()                                                  \
{                                                                       \
    extern void nvFence(void);                                          \
                                                                        \
    nvFence();                                                          \
}
#else
#define __GLNV_FENCE()                                                  \
{                                                                       \
    GLuint dummy = 0xDEADBEEF;                                          \
    GLuint *fencePtr = &dummy;                                          \
    __asm mov  eax, (fencePtr)                                          \
    __asm xchg [eax], ecx                                               \
}
#endif

#define OGL_CLIENT_DLL_NAME_NV4                 L"nvoglnt.dll"
#define OGL_CLIENT_DLL_NAME_NV3                 L"nv3oglnt.dll"



#define NV_OGL_CLIENT_DRAWABLE_INFO 0x0001 // if bit ON then drawable info exists...
#define NV_OGL_CLIENT_CONTEXT_INFO  0x0002 // if bit ON then context info exits...
#define NV_OGL_CLIENT_SHARED_INFO   0x0004 // if bit ON then context info exits...
#define NV_OGL_CLIENT_WOC_DELETE    0x0008 // if bit ON then WOC_DELETE occured on window...
#define NV_OGL_CLIENT_RM_CLIENT     0x0010 // if bit ON then tracking RM client in node

//
// Use client side rectangle list or display driver side...
//
#undef USE_CLIENT_RECT_LIST
#define USE_CLIENT_RECT_LIST 1


/*******************************************************************************
 *
 *    Useful information for OpenGL support.  Not guaranteed to work.
 *
 ******************************************************************************/


#define     OPENGL_CMD              4352
#define     OPENGL_GETINFO          4353
#define     NV_OPENGL_SET_ENABLE    0x6988
#define     OPENGL_GETINFO_DRVNAME  0

#define     OPENGL_ICD_VER          2
#define     OPENGL_DRIVER_VER       0x10000
#define     OPENGL_KEY_NAME_NV3     L"RIVA128"
#define     OPENGL_KEY_NAME_NV4     L"RIVATNT"

typedef struct {
    unsigned long   ulVersion;
    unsigned long   ulDriverVersion;
    unsigned char   awch[ MAX_PATH + 1 ];
} OPENGL_INFO, FAR *LP_OPENGL_INFO;

#define     ESC_ALLOC_CONTEXT_DMA                   0x6989
#define     ESC_FREE_CONTEXT_DMA                    0x698A
#define     ESC_ALLOC_CHANNEL_DMA                   0x698B
#define     ESC_FREE_CHANNEL_DMA                    0x698C
#define     ESC_DMA_FLOW_CONTROL                    0x698D
#define     ESC_SET_GAMMA_RAMP                      0x698E
#define     ESC_GET_GAMMA_RAMP                      0x698F
#define     ESC_GET_PIXEL_FORMAT                    0x7000
#define     ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

// Reserving Escape for Intel Diagnostics - Escape value is ASCII "nv"+1
#define     ESC_INTEL_DIAGNOSTICS                   0x6e77

/*******************************************************************************
 * Macros for PAGE ALIGNMENT and PAGE SIZE.
 *
 * It would be preferable to grab this out of the DDK header files,
 * but the Windows SDK header files conflict with the DDK header files.
 ******************************************************************************/

#ifdef _M_IA64

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x2000
#endif

#ifndef PAGE_SHIFT
#define PAGE_SHIFT 13L
#endif

#else // #ifdef _M_IA64

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#ifndef PAGE_SHIFT
#define PAGE_SHIFT 12L
#endif

#endif // #ifdef _M_IA64

#ifndef BYTES_TO_PAGES
#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PAGE_SHIFT) + \
                            (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))
#endif

#ifndef ROUND_TO_PAGES
#define ROUND_TO_PAGES(Size)  (((ULONG)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
#endif


#define PAGE_ALIGN_UP(Va) ((PVOID)(((ULONG_PTR)(Va) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)))

/************************************WARNING*******************************************/
/********* These are duplicated from OpenGL gl\glcore.h********************************/
/**************************************************************************************/

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

#ifdef _WIN32
typedef struct __GLregionRectRec {
    /* lower left (inside the rectangle)  = (x0, y0)*/
    /* upper right (outside the rectangle)   = (x1, y1)*/
    /* This structure is modified and arranged so that it matches with win32
     * structure RECT and the structure RECTL used by DDK.
     * This avoids us doing extra copies of the rectangle lists
     * when we share the code in Display Driver.
     * RECT structure is
     * typedef struct _RECT 
     * {    
     *  // rc     
     *      LONG left;     
     *      LONG top;     
     *      LONG right; 
     *      LONG bottom; 
     *  } RECT;  
     * the order of the members (x0, y1, x1, y0).
     */ 
    LONG x0;  /* left */
    LONG y0;  /* top   $%$%$ XXX NEED TO REPAIR nv10pushbufclip to have correct meaning of y1 = TOP, y0 = BOTTOM*/
    LONG x1;  /* right */
    LONG y1;  /* bottom */
} __GLregionRect;
#else // _WIN32
typedef struct __GLregionRectRec {
    /* lower left (inside the rectangle)  = (x0, y0)*/
    /* upper right (outside the rectangle)   = (x1, y1)*/
    /* This structure is modified and arranged so that it matches with win32
     * structure RECT and the structure RECTL used by DDK.
     * This avoids us doing extra copies of the rectangle lists
     * when we share the code in Display Driver.
     * RECT structure is
     * typedef struct _RECT 
     * {    
     *  // rc     
     *      LONG left;     
     *      LONG top;     
     *      LONG right; 
     *      LONG bottom; 
     *  } RECT;  
     * the order of the members (x0, y1, x1, y0).
     */ 
    int x0;  /* left */
    int y0;  /* top   $%$%$ XXX NEED TO REPAIR nv10pushbufclip to have correct meaning of y1 = TOP, y0 = BOTTOM*/
    int x1;  /* right */
    int y1;  /* bottom */
} __GLregionRect;
#endif // _WIN32

#include "nvEscDef.h"
#include "nvcom.h"

//////////////////////////////////////////////////////////////////////
// OpenGL exports.
VOID OglRemoveClient(PDEV *ppdev, NV_OPENGL_CLIENT_INFO_LIST *clientList);
NV_OPENGL_DRAWABLE_INFO *CreateDrawableClientInfo(SURFOBJ *pso, HWND hWnd, HDC hDC, struct tagPIXELFORMATDESCRIPTOR *ppfd);
VOID DestroyDrawableClientInfo(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG deleteFlag);
ULONG CreateContextClientInfo(PDEV *ppdev, HWND hWnd, ULONG hClient);
VOID DestroyContextClientInfo(PDEV *ppdev, ULONG hClient, ULONG deleteFlag);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWndHDC(PDEV *ppdev, HWND hWnd, HDC hDc);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(PDEV *ppdev, HWND hWnd);
VOID CALLBACK DrvClipChanged(WNDOBJ *pwo, FLONG fl);
VOID CALLBACK DrvClipChanged1(WNDOBJ *pwo, FLONG fl);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoHClient(PDEV *ppdev, ULONG hClient);
NV_OPENGL_CLIENT_INFO *OglFindDrawableInClientInfoList(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *inDrawablePtr);
VOID OglDebugPrintFunc(PCHAR DebugMessage, ...);
NV_OPENGL_CLIENT_INFO_LIST *OglAppendToClientInfoList(
    PDEV    *ppdev,
    DWORD   flags,                               // bits indicating allocated/free resources
    HDRVOBJ hDrvObj,                             // driver object handle for this client
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, // drawable information for this client
    NV_OPENGL_CONTEXT_INFO  *clientContextInfo); // context information for this client
void OglRemoveFromClientInfoList(PDEV *ppdev, NV_OPENGL_CLIENT_INFO_LIST *toFree);
void OglRemovePdevListFromClientList(NV_OPENGL_CLIENT_INFO_LIST *clientList);

NV_OPENGL_CLIENT_INFO_LIST *OglFindClientListFromClientInfo(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL OglValidateDrawableInfo(NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
void CreateSharedClientInfo(PDEV *ppdev, ULONG hClient, ULONG processHandle, PVOID *globalData, PVOID *pfifoAddress, PVOID *pbusAddress);
void DestroySharedClientInfo(PDEV *ppdev, ULONG hClient, ULONG processHandle, PVOID globalData, ULONG deleteFlag);
BOOL OglEngDeleteDriverObj(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo, ULONG flags);
void OglIncClientCount(PDEV *ppdev);
void OglDecClientCount(PDEV *ppdev);
BOOL OglMapGlobalPageAddress(PDEV *ppdev, PVOID *globalData);
BOOL OglUnmapGlobalPageAddress(PDEV *ppdev, PVOID globalData);
BOOL OglMapPFifoAddress(PDEV *ppdev, PVOID *pfifoAddress);
BOOL OglUnmapPFifoAddress(PDEV *ppdev, PVOID pfifoAddress);
BOOL OglMapPBusAddress(PDEV *ppdev, PVOID *pbusAddress);
BOOL OglUnmapPBusAddress(PDEV *ppdev, PVOID pbusAddress);
BOOL OglAcquireClipMutex(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
VOID OglReleaseClipMutex(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
#if DBG
BOOL OglVerifyClientList(PDEV *ppdev, char *s);
#endif // DBG

void OglChannelWait(PDEV *ppdev, ULONG ourChannelId, ULONG maskOtherChannels);
ULONG NV4_OglSwapBuffers(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVswapInfo *swapInfo);
ULONG NV4_OglFlushClipped(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVflushInfo *flushInfo);
void NV_OglInitState(PDEV *ppdev, void *cmdInfo);
void NV_OglGetAppSupportSettings(PDEV *ppdev);

#if (NVARCH >= 0x4)
ULONG NV_OglSwapBuffers(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVswapInfo *swapInfo);
ULONG NV_OglFlushClipped(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVflushInfo *flushInfo);
ULONG NV_OglOverlayMergeBlit(PDEV *ppdev, HWND hWnd, HDC hDC, __GLNVoverlayMergeBlitInfo *mergeInfo);
ULONG NV_OglOperation(PDEV *ppdev, HWND hWnd, HDC hDC, __GLNVoperation *op);
BOOL NV_OglUpdateClipLists(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);

// This lives in the shared lib and is called into only by the display driver
void STDCALL __glNVKickOffPushBufferNT(__GLNVcmdInfo *cmdInfo);
void STDCALL __glNV4KickOffPushBufferNT(__GLNVcmdInfo *cmdInfo);
#endif  // (NVARCH >= 0x4)

void CombineRectLists(RECTL *, ULONG , RECTL *, ULONG, LONG, LONG, RECTL *, ULONG *);

int OglAllocUnifiedSurfaces(PDEV *ppdev, __GLNVsbdFlags *sbdFlags);
int OglFreeUnifiedSurfaces(PDEV *ppdev);
NvU32 OglGetUnifiedSurfaceInfo(PDEV *ppdev, __GLNVsbdFlags *sbdFlags);
void OglTranslateCachedClipRectList(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox);
void OglTranslateClientRelativeRectListToDevice(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox);
void OglRegisterRmClient(PDEV *ppdev, ULONG rmClient);
void OglUnRegisterRmClient(PDEV *ppdev, ULONG rmClient);
ULONG OglCpuBlit(PDEV *ppdev, __GLNvCpuBltData *oglNVCpuBltData);
void OglReadRegistry(PDEV *ppdev);


void OglUseDisplayDriverBlt(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    LONG srcOffset,
    LONG srcPitch,
    LONG srcLeft, 
    LONG srcTop, 
    LONG dstOffset,
    LONG dstPitch,
    LONG dstLeft, 
    LONG dstTop, 
    LONG width, 
    LONG height);

BOOL bGetOglClientInfoHWnd(struct _NV_OPENGL_CLIENT_INFO *clientInfo, HWND* phWnd);
BOOL bExchangeClientsFrontAndBack(PPDEV,NV_OPENGL_DRAWABLE_INFO*);//resides in oglsurf.c
VOID vOglFlipChangedUpdate(PPDEV ppdev, NV_OPENGL_CLIENT_INFO*);
VOID vFlipToPrimary(PPDEV);//resides in oglsurf.c
void OglAllocateAndCopyWindowClipList(PDEV *, NV_OPENGL_DRAWABLE_INFO *, RECTL *, ULONG);

#endif // __OGD_DD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclip.h ===
#ifndef _OGLCLIP_H
#define _OGLCLIP_H
//******************************Module*Header***********************************
// Module Name: oglclip.h
//
// OpenGL server side clip management
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglNegativeClipListCreate(PPDEV ppdev);
BOOL bOglNegativeClipListDestroy(PPDEV ppdev);
BOOL bOglNegativeClipListUpdate(PPDEV ppdev, struct _WNDOBJ *pwo);
BOOL bOglClientIntersectingWithOtherClients(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
void OglClipRectToScreen(RECTL *rect, LONG cxScreen, LONG cyScreen);
void OglCopyClipListToDrawableInfo(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
BOOL bOglClipRectAgainstClipobj(
    IN  CLIPOBJ *pco, 
    IN  RECTL   *prcl);
BOOL bOglClipBoundsUpdate(struct _OGLSERVER *pOglServer);
void CombineRectLists(RECTL *rectList1, ULONG count1, 
                      RECTL *rectList2, ULONG count2,
                      LONG  leftList2, LONG topList2,
                      RECTL *resultList, ULONG *resultCount);

#define COPY_RECT(_DST, _SRC) \
    _DST.left = _SRC.left; \
    _DST.right = _SRC.right; \
    _DST.top = _SRC.top; \
    _DST.bottom = _SRC.bottom;


#endif // _OGLCLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglctx.c ===
/******************************Module*Header*******************************\
* Module Name: oglctx.c
*
* This module contains the functions to support the OpenGL client side
* context interface.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvReg.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "nvcom.h"          // drivers/common/inc

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#define OGL_DEBUG_PREFIX "NV: "

BOOL CALLBACK ClientContextDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   OglDebugPrintFunc
//
//  Routine Description:
//
//      This routine prints output messages for the OpenGL portion of the driver.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
VOID __cdecl OglDebugPrintFunc(
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);
    EngDebugPrint(OGL_DEBUG_PREFIX, DebugMessage, ap);
    va_end(ap);
}

//******************************************************************************
//
//  Function:   CreateContextClientInfo
//
//  Routine Description:
//
//      This routine associates a handle to the resource manager client and
//      a HWND with an OpenGL client.  This routine is called in response to
//      a client side escape.
//
//  Arguments:
//
//  Return Value:
//
//      FALSE indicates an allocate problem; otherwise TRUE
//
//******************************************************************************
ULONG CreateContextClientInfo(
    PDEV  *ppdev,
    HWND  hWnd, // for debugging
    ULONG hClient // key for searching for context nodes
)
{
    int i;
    LONG                   status;
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;
    NV_OPENGL_CONTEXT_INFO *clientContextInfo;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "CreateContextClientInfo - 0x%p %ld", hWnd, hClient));

    clientContextInfo = EngAllocMem(FL_ZERO_MEMORY,
                                    (sizeof(NV_OPENGL_CONTEXT_INFO) + PAGE_SIZE - 1),
                                    ALLOC_TAG);
    if (clientContextInfo == NULL)
    {
        DISPDBG((2, "CreateContextClientInfo - Failed EngAllocMem"));
        return((ULONG)FALSE);
    }

    OglDebugPrint("ALLOC: clientContextInfo = 0x%p\n", clientContextInfo);


    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev,
                                           0,
                                           0,
                                           NULL,
                                           clientContextInfo);
    if (clientList)
    {
        clientInfo = &clientList->clientInfo;
    }
    else
    {
        EngFreeMem(clientContextInfo);
        return((ULONG)FALSE);
    }

    clientContextInfo->hWnd    = hWnd; // for debugging
    clientContextInfo->hClient = hClient;

    clientInfo->clientContextInfo = clientContextInfo;

    //
    // Set context is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_CONTEXT_INFO;

    OglDebugPrint("****************** CreateContext: client count = %ld\n", globalOpenGLData.oglClientCount);

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientContextDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
    {
        DISPDBG((1, "CreateContextClientInfo: FAILED EngCreateDriverObj"));
        OglDebugPrint("****************** FAILURE CreateContext: client count = %ld\n", globalOpenGLData.oglClientCount);
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        OglDebugPrint("FREE: clientContextInfo = 0x%p\n", clientContextInfo);
        OglDecClientCount(ppdev);
        return((ULONG)FALSE);
    }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj         = hDrvObj;
    clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;

    OglDebugPrint("CreateContext = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientContextInfo);

    return((ULONG)TRUE);
}

//******************************************************************************
//
//  Function:   DestroyContextClientInfo
//
//  Routine Description:
//
//      This routine frees the client drawable info structure and unbinds it
//      to the window.  This is called in reponse to the client side escape
//      or when the client side process dies.
//
//  Arguments:
//
//  Return Value:
//
//      VOID
//
//******************************************************************************
void DestroyContextClientInfo(
    PDEV  *ppdev,
    ULONG hClient,
    ULONG deleteFlag
)
{
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_CONTEXT_INFO     *clientContextInfo = NULL;
    long status;

    DISPDBG((2, "DestroyContextClientInfo - %ld", hClient));

    clientList = OglFindClientInfoHClient(ppdev, hClient);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO && clientInfo->clientContextInfo)
    {
        DISPDBG((1, "DestroyContextClientInfo: hClient = %ld", (ULONG)hClient));

        clientContextInfo = clientInfo->clientContextInfo;

        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, hClient, NV01_NULL_OBJECT, hClient);

        //
        // Free client structure memory.
        //
        EngFreeMem(clientContextInfo);
        clientInfo->clientContextInfo = NULL;

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_CONTEXT_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_CONTEXT_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyContext: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        OglDebugPrint("DestroyContext = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientContextInfo);
    }
}

//******************************************************************************
//
//  Function:   OglFindClientInfoHClient
//
//  Routine Description:
//
//      Find a client information structure given a resource manager hClient.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoHClient(
    PDEV  *ppdev,
    ULONG hClient
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientContextInfo &&
            node->clientInfo.clientContextInfo->hClient == hClient)
            {
            return(node);
            }
        node = node->next;
        }

    return(NULL);
}


//******************************************************************************
//
//  Function:   OglGetClientInfoHWnd
//
//  Routine Description:
//
//      returns the hWnd belonging to the client info.
//
//  Arguments:      pClientInfo: pointer to the client info
//                  phWnd:       pointer to a hWnd this is the desired returnvalue             
//
//  Return Value:   TRUE: found hWnd
//                  FALSE: found no hWnd
//
//  MSchwarzer 09/28/2000: new
//
//******************************************************************************
BOOL bGetOglClientInfoHWnd( NV_OPENGL_CLIENT_INFO *pClientInfo, HWND* phWnd)
{
    BOOL bRet = FALSE;

    ASSERTDD( NULL != phWnd, "" );

    *phWnd = 0;

    if( pClientInfo )
    {
        if ( bOglHasDrawableInfo(pClientInfo) )
        {
            *phWnd = pClientInfo->clientDrawableInfo->hWnd;
            bRet = TRUE;
        }
        else if(  ( pClientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO )
                &&( pClientInfo->clientContextInfo )
               )
        {
            *phWnd = pClientInfo->clientContextInfo->hWnd;
            bRet = TRUE;
        }

    }
    return bRet;
}

//******************************************************************************
//
//  Function:   ClientContextDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientContextDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;


    OglAcquireGlobalMutex();

    OglDebugPrint("CONTEXT ***************** CONTEXT DrvFreeObj = 0x%p 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientInfo->clientDrawableInfo, clientInfo->clientContextInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup context info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO)
    {
        if (clientInfo->clientContextInfo)
        {
            DWORD hClient;

            try
            {
                hClient = clientInfo->clientContextInfo->hClient;
                DestroyContextClientInfo(ppdev, hClient, FALSE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "DestroyContextClientInfo: exception = 0x%lx", status));
                OglReleaseGlobalMutex();
                return(TRUE);
            }
        }
        clientInfo->flags &= ~NV_OGL_CLIENT_CONTEXT_INFO;
        clientInfo->clientContextInfo = NULL; // just for good measure...
    }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("****************** Context CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

#if ( NVARCH >= 0x4)
void NV_OglInitState(PDEV *ppdev, void *cmdInfo)
{
    __glNVInitSharedFnPtrs((__GLNVcmdInfo *)cmdInfo);
    ppdev->oglSyncGdi       = ((__GLNVcmdInfo *)cmdInfo)->syncGdi;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldebug.h ===
#ifndef _OGLDEBUG_H
#define _OGLDEBUG_H
//******************************Module*Header***********************************
// Module Name: ogldebug.h
//
// special debug code for ogl server part of display driver
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#if DBG
//******************************************************************************
#ifndef _DEBUG_H
#error ogldebug.h needs debug.h!
#endif

// DrvClipChanged-WOC-Flags stuff
char *szDbg_WOC_flGet(ULONG fl);
#define DBG_PRINT_WOC_FL(lvl,str,pfn,fl) vDbg_PrintDBG_NAMEINDEXfl(lvl,str,szDbg_WOC_flGet,fl)

//
//******************************************************************************
#else  // DBG
//******************************************************************************
// In a free build remove all debug defines
//

#define DBG_PRINT_WOC_FL(lvl,str,pfn,fl)


//******************************************************************************
#endif // DBG
#endif // _OGLDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldrwbl.c ===
/******************************Module*Header*******************************\
* Module Name: ogldrwbl.c
*
* This module contains the functions to support the OpenGL client side
* drawable interface.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglflip.h"
#include "oglOverlay.h"
#include "Nvcm.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#ifndef WO_RGN_DESKTOP_COORD
#define WO_RGN_DESKTOP_COORD 0x100
#endif

static BOOL MapDrawableClientAddress(PDEV *ppdev, 
                                     NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, 
                                     NV_SYSMEM_SHARE_MEMORY *sysmemShareMemoryOut);
static BOOL UnmapDrawableClientAddress(PDEV *ppdev,
                                       NV_OPENGL_DRAWABLE_INFO  *clientDrawableInfo);
static BOOL MapDrawableGlobalPageAddress(PDEV *ppdev,
                                         NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static BOOL UnmapDrawableGlobalPageAddress(PDEV *ppdev, 
                                           NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static void CopyOrigClipList(PDEV *, NV_OPENGL_DRAWABLE_INFO *);

BOOL CALLBACK ClientDrawableDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   CreateDrawableClientInfo
//
//  Routine Description:
//
//      This routine associates a window with client supplied information.  Window
//      change events are tracked by DrvClipChanged and the client information is
//      updated.  This function is called in response to the client side escape.
//
//  Arguments:
//
//  Return Value:
//
//      NULL indicates an allocate problem; otherwise user virtual address
//
//******************************************************************************
NV_OPENGL_DRAWABLE_INFO *CreateDrawableClientInfo(
    SURFOBJ *pso,
    HWND    hWnd,
    HDC     hDC,
    PIXELFORMATDESCRIPTOR *ppfd
)
{
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    WNDOBJ                  *pwo = (WNDOBJ *)NULL;
    HDRVOBJ                 hDrvObj = (HDRVOBJ)NULL;
    PDEV                    *ppdev = (PDEV *)pso->dhpdev;
    NV_SYSMEM_SHARE_MEMORY  sysmemShareMemoryOut;
    LONG                    status;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
    PVOID				    origClientDrawableInfoPtr;
    FLONG                   flWindowTrackingFlags;

    DISPDBG((2, "CreateDrawableClientInfo: hWnd = 0x%p hDC = 0x%p", hWnd, hDC));

    //
    // Create window object to track changes to this window in DrvClipChanged
    //
    flWindowTrackingFlags = 
#if _WIN32_WINNT >= 0x0500
                            WO_RGN_UPDATE_ALL | WO_RGN_CLIENT | WO_RGN_DESKTOP_COORD;
#else
                            WO_RGN_CLIENT;
#endif


    // In an overlay environment we need the delta client messages to 
    // update the overlay layout to not have garbage in our overlaybuffer
    if(ppdev->bOglOverlayDesired)
    {
        flWindowTrackingFlags |= WO_RGN_CLIENT_DELTA   // to clear newly entered overlay region
                              |  WO_RGN_SURFACE_DELTA; // to clear regions without overlay in default transparent color
    }

    //
    // Workstation features need extra functionality
    //
    if(   HWGFXCAPS_UBB(ppdev) 
       && HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // want to get a negative clip list
        // this is only necessary while window flipping is enabled
        flWindowTrackingFlags |= WO_RGN_SURFACE;
    }

    //
    // NOTE: It is very important that all calls to engcreatewnd use the same flWindowTrackingFlags!
    //       All pathes above cannot change while ogl is running!
    //

    pwo = EngCreateWnd(pso,
                       hWnd,DrvClipChanged,
                       flWindowTrackingFlags,
                       0L);

    DISPDBG((1, "CreateDrawableClientInfo: create WNDOBJ (pwo = 0x%p)", pwo));

    clientDrawableInfo = NULL;
    if (pwo == (WNDOBJ *)0) 
    {
        //this is an error case which results in an assertion in the ICD years later
        // => assert it here !!
        ASSERT(pwo != NULL);
        DISPDBG((0, "CreateDrawableClientInfo - Failed EngCreateWnd"));
        return(NULL);
    }
    else if (pwo == (WNDOBJ *)-1)
    {
        DISPDBG((2, "CreateDrawableClientInfo - Already tracking hWnd"));
        clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
        if (clientList)
        {
            clientInfo = &clientList->clientInfo;
        }
        if (clientInfo)
        {
            clientDrawableInfo = clientInfo->clientDrawableInfo;
            clientDrawableInfo->refCount++;
            DISPDBG((1, "CreateDrawableClientInfo: hWnd = 0x%p, refCount=0x%x", hWnd, clientDrawableInfo->refCount));
            return(clientDrawableInfo->userVirtualAddress);
        }
        else
        {
            //
            // Lets see GDI is tracking the window but we can't find it in our
            // list.  This is very bad.
            //
            if (ppdev->numDevices == 1)
                {
                return(NULL);
                }
            //
            // In multi-device world we track the window on multiple devices
            // but EngCreateWnd fails.  So, just create the drawable node and
            // let DrvClipChanged update multiple nodes.  This works around
            // a limitation in EngCreateWnd.
            //
        }
    }

    /* Since we are not guaranteed page aligned allocation,
     * we need to allocate an extra PAGE_SIZE - 1 memory and use
     * memory starting from next page. */
    origClientDrawableInfoPtr = clientDrawableInfo = 
        EngAllocMem(FL_ZERO_MEMORY, (sizeof(NV_OPENGL_DRAWABLE_INFO) + PAGE_SIZE -1), ALLOC_TAG);

    if (clientDrawableInfo == NULL)
    {
        DISPDBG((2, "CreateDrawableClientInfo - Failed EngAllocMem"));
        return(NULL);
    }

    
    clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)PAGE_ALIGN_UP(clientDrawableInfo);
    clientDrawableInfo->origClientDrawableInfoPtr = origClientDrawableInfoPtr;

    clientDrawableInfo->bOrigClipList = FALSE; // do not copy the original clip list by default
    clientDrawableInfo->origWindowRectList = NULL;

    //
    // Initialize the clientDrawableInfo structure
    //
    clientDrawableInfo->hWnd      = hWnd;
    clientDrawableInfo->hDC       = hDC;
    clientDrawableInfo->cachedClipRectList = NULL; // It is already zero..but to clarify..
    clientDrawableInfo->overlayMember = (ppfd->bReserved != 0);

    //
    // If we created a window object then map a system address to the client
    // address and use it for accessing the structure in the display driver.
    //
    DISPDBG((1, "CreateDrawableClientInfo: SetConsumer (pv = 0x%p)", clientDrawableInfo));
    if (MapDrawableClientAddress(ppdev,
                                 clientDrawableInfo,
                                 &sysmemShareMemoryOut) == TRUE)
    {
        //
        // Get pointer to new client.
        //
        clientList = OglAppendToClientInfoList(ppdev, 
                                               0, 
                                               0, 
                                               clientDrawableInfo, 
                                               NULL);
        if (clientList)
            {
            clientInfo = &clientList->clientInfo;
            }
        else
            {
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglDebugPrint("CreateDrawable: OglAppendToClientInfoList: FAILED\n");
            return(NULL);
            }

        OglDebugPrint("ALLOC: clientDrawableInfo = 0x%p\n", clientDrawableInfo);

        if (MapDrawableGlobalPageAddress(ppdev, clientDrawableInfo) == FALSE)
        {
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }

        OglDebugPrint("****************** CreateDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);

        //
        // Create driver object that tracks this client index with the client process
        //
        hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientDrawableDrvFreeObj, ppdev->hdevEng);
        if (hDrvObj == NULL)
        {
            DISPDBG((1, "CreateDrawableClientInfo: FAILED EngCreateDriverObj"));
            OglDebugPrint("****************** FAILURE CreateDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);
            UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }
        //
        // Save driver object and mode switch count.
        //
        clientInfo->hDrvObj         = hDrvObj;
        clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;
        clientInfo->ppdev           = ppdev;
        clientInfo->pfd             = *ppfd;

        // Allocate the cached clip list now.
        clientDrawableInfo->cachedClipRectList = 
            EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * MAX_OGL_CLIP_RECTS), ALLOC_TAG);

        if (clientDrawableInfo->cachedClipRectList == NULL)
        {
            DISPDBG((1, "CreateDrawableClientInfo  - Failed EngAllocMem  of CachedClipRectList"));
            OglDebugPrint("****************** FAILURE CreateDrawable: EngAllocMem  of CachedClipRectList");
            UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }

        clientDrawableInfo->cachedNumClipRects = 0;
        clientDrawableInfo->cachedClipListSize = MAX_OGL_CLIP_RECTS;
        clientDrawableInfo->cachedClipListDirty = TRUE;
        clientDrawableInfo->cachedExclusiveRectList = NULL; // we will allocate it if needed.
        clientDrawableInfo->cachedNumExclusiveRects = 0; 

        clientDrawableInfo->copyWindowRect = &(clientDrawableInfo->windowRect[0]);
        clientDrawableInfo->sizeCopyWindowRectList = MAX_OGL_CLIP_RECTS;

        //
        // DrvClipChanged is called with the pointer in the second
        // argument to WNDOBJ_vSetConsumer.  We pass in the display driver
        // address mapping to the clientInfo structure.
        //
        if (pwo && pwo != (WNDOBJ *)-1)
        {
            WNDOBJ_vSetConsumer(pwo, (PVOID)clientInfo);
            clientInfo->pwo = pwo;
        }

        //
        // Inititalize width and height of display for this drawable.
        //
        clientDrawableInfo->cxScreen = ppdev->cxScreen;
        clientDrawableInfo->cyScreen = ppdev->cyScreen;

        //
        // Initialize flags for this client.  Drawable is ALWAYS created before context...
        //
        clientInfo->flags = NV_OGL_CLIENT_DRAWABLE_INFO;

        if (ppdev->numDevices > 1)
        {
            if (pwo && pwo != (WNDOBJ *)-1)
            {
                // if we got a valid pwo then this is the first client to start tracking
                // a window.  this client is the one where the original unclipped window
                // rectangle list will be stored.
                clientDrawableInfo->origWindowRectList =  
                    EngAllocMem(FL_ZERO_MEMORY, sizeof(RECTL)*clientDrawableInfo->sizeCopyWindowRectList, ALLOC_TAG);
                if( NULL != clientDrawableInfo->origWindowRectList )
                {
                    clientDrawableInfo->bOrigClipList = TRUE;
                }
                else
                {
                    DISPDBG((0,"CreateDrawableClientInfo could not allocate %d byte for origWindowRectList",
                        (sizeof(RECTL)*clientDrawableInfo->sizeCopyWindowRectList) ));
                }
            }
            else
            {
                // on a multi-monitor system, the first client drawable info copies
                // the window clip list.  this list must be copied into all other 
                // client drawable info structures that are tracking the HWND.
                CopyOrigClipList(ppdev, clientDrawableInfo);
            }
        }

        OglDebugPrint("CreateDrawable = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientDrawableInfo);
    }
    else
    {
        DISPDBG((1, "CreateDrawableClientInfo: FAILED MapDrawableClientAddress"));
        EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
        OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
        return(NULL);
    }
    
    globalOpenGLData.oglDrawableClientCount++ ;
    
    clientDrawableInfo->refCount = 1;

    // If we have more than one opengl window than we can't flip.
    // Need to restore the DAC to point to the primary surface.
    // we are now able to decide if a previously found DDraw app is an ICD app in real
    ASSERT(NULL!=clientInfo);
    bRemovePointerFromList(&ppdev->oglDDrawSurfaceCountList,(PULONG)((ULONG_PTR)clientInfo->dwProcessID));
    ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
    bOglPageFlipModeUpdate(ppdev);

    return(clientDrawableInfo->userVirtualAddress);
}

//******************************************************************************
//
//  Function:   DestroyDrawableClientInfo
//
//  Routine Description:
//
//      This routine frees the client drawable info structure and unbinds it
//      to the window.  This is called in reponse to the client side escape
//      or when the client side process dies.
//
//  Arguments:
//
//  Return Value:
//
//      VOID
//
//******************************************************************************
void DestroyDrawableClientInfo(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG deleteFlag
)
{
    int i;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    PVOID						origClientDrawableInfoPtr;

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

//    if (OGL_FLIPPED()) {
//        vFlipToPrimary(ppdev);
//    }

    if ( bOglHasDrawableInfo(clientInfo) )
    {
        NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;

        DISPDBG((1, "DestroyDrawableClientInfo: hWnd = 0x%p", hWnd));

        // note: on a call by the drvobj callback refCount will be explicitly
        // set to 1 to make sure all resources get freed
        // (see ClientDrawableDrvFreeObj)
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERTDD(clientDrawableInfo->refCount, "DestroyDrawableClientInfo: illegal refCount!!");
        if (--clientDrawableInfo->refCount)
        {
            // still referenced ??
            DISPDBG((1, "DestroyDrawableClientInfo: hWnd = 0x%p, refCount=0x%x", hWnd, clientDrawableInfo->refCount));
            return;
        }

        // MSchwarzer 9/28/2000 remove palette from global structure if there is one
        if (   bOglIsOverlayClient(clientInfo)
            && !OglDestroyLayerPalette(hWnd) )
        {
            // no palette or error ?
            DISPDBG((0, "DestroyDrawableClientInfo: OglDestroyLayerPalette( hWnd = 0x%p) failed", hWnd));
        }

        UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
        UnmapDrawableClientAddress(ppdev, clientDrawableInfo);

        //
        // Free memory associated with cached clip list of client drawable info.
        //
        if (clientDrawableInfo->cachedClipRectList)
        {
            EngFreeMem(clientDrawableInfo->cachedClipRectList);
        }

        //
        // Free memory associated with cached exclusive clip list of client drawable info.
        //
        if (clientDrawableInfo->cachedExclusiveRectList)
        {
            EngFreeMem(clientDrawableInfo->cachedExclusiveRectList);
        }
        //
        // Free memory associated with copy Clip Window rect if allocated
        //
#ifndef NV3
        if ((clientDrawableInfo->sizeCopyWindowRectList > MAX_OGL_CLIP_RECTS) && 
            (clientDrawableInfo->copyWindowRect != NULL) &&
            (clientDrawableInfo->copyWindowRect != (&(clientDrawableInfo->windowRect[0])))) {
            EngFreeMem(clientDrawableInfo->copyWindowRect);
            clientDrawableInfo->sizeCopyWindowRectList = 0;
            clientDrawableInfo->copyWindowRect = NULL;
            if (clientDrawableInfo->origWindowRectList)
                {
                EngFreeMem(clientDrawableInfo->origWindowRectList);
                clientDrawableInfo->origWindowRectList = NULL;
                }
        }
#endif // NV3

        //
        // Free memory associated with client drawable info.
        //
        origClientDrawableInfoPtr = clientDrawableInfo->origClientDrawableInfoPtr;
        EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
        clientDrawableInfo             = NULL;
        clientInfo->clientDrawableInfo = NULL;

        //
        // Clear drawable bit.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_DRAWABLE_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_DRAWABLE_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        globalOpenGLData.oglDrawableClientCount-- ;
        
        if (globalOpenGLData.oglDrawableClientCount == 0)
            {
            OglFreeUnifiedSurfaces(ppdev);
            }

        OglDebugPrint("DestroyDrawable = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, origClientDrawableInfoPtr);
    }    
}

//******************************************************************************
//
//  Function:   OglFindClientInfoFromHWndHDC
//
//  Routine Description:
//
//      Find a client information structure given a HWND and HDC.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWndHDC(
    PDEV *ppdev, 
    HWND hWnd,
    HDC hDC
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    if (ppdev->numDevices > 1)
        {
        // Use hWnd AND hDC to find node...
        while (node)
            {
            if (node->clientInfo.clientDrawableInfo &&
                node->clientInfo.clientDrawableInfo->hWnd == hWnd &&
                node->clientInfo.clientDrawableInfo->hDC == hDC)
                {
                return(node);
                }
            node = node->next;
            }
        }
    else
        {
        // Just use hWnd to find node...
        while (node)
            {
            if (node->clientInfo.clientDrawableInfo &&
                node->clientInfo.clientDrawableInfo->hWnd == hWnd)
                {
                return(node);
                }
            node = node->next;
            }
        }
    return(NULL);
}

//******************************************************************************
//
//  Function:   OglFindClientInfoFromHWnd
//
//  Routine Description:
//
//      Find a client information structure given a HWND and HDC.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(
    PDEV *ppdev, 
    HWND hWnd
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientDrawableInfo &&
            node->clientInfo.clientDrawableInfo->hWnd == hWnd)
            {
            return(node);
            }
        node = node->next;
        }

    return(NULL);
}

//******************************************************************************
//
//  Function:   ClientDrawableDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientDrawableDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();

    OglDebugPrint("DRAWABLE ***************** DRAWABLE DrvFreeObj = 0x%p 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientInfo->clientDrawableInfo, clientInfo->clientContextInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup drawable info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_DRAWABLE_INFO)
    {
        if (clientInfo->clientDrawableInfo)
        {
            ASSERT(bOglHasDrawableInfo(clientInfo));
            //
            // Free channel and such.
            //
            NvFree(ppdev->hDriver, 
                   clientInfo->clientDrawableInfo->hClient, 
                   NV01_NULL_OBJECT, 
                   clientInfo->clientDrawableInfo->hClient);

            // At this point we know that the user mode process is dead.
            // Therefore we can safely free any drawableInfo etc
            // => override refCount protection to free resources
            clientInfo->clientDrawableInfo->refCount = 1;

            DestroyDrawableClientInfo(ppdev, 
                                      clientInfo->clientDrawableInfo->hWnd,
                                      clientInfo->clientDrawableInfo->hDC, 
                                      FALSE);
        }
        clientInfo->flags &= ~NV_OGL_CLIENT_DRAWABLE_INFO;
        clientInfo->clientDrawableInfo = NULL; // just for good measure...
    }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("****************** Drawable CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    if (globalOpenGLData.oglDrawableClientCount == 0)
        {
        OglFreeUnifiedSurfaces(ppdev);
        }

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   MapDrawableClientAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the kernel, system
//      address for the shared information into the caller's address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
MapDrawableClientAddress(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    NV_SYSMEM_SHARE_MEMORY  *sysmemShareMemoryOut
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "MapDrawableClientAddress - Entry"));

    sysmemShareMemoryIn.pSystemMdl     = NULL; // miniport WILL allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = FALSE;
    
    sysmemShareMemoryIn.physicalAddress = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress = (PVOID)clientDrawableInfo; // kernel or system address
    sysmemShareMemoryIn.byteLength = sizeof(NV_OPENGL_DRAWABLE_INFO);

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        clientDrawableInfo->pClientInfoMdl     = (PVOID)NULL;
        clientDrawableInfo->userVirtualAddress = (PVOID)NULL;
        DISPDBG((2, "MapDrawableClientAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    //
    // Mapping succeeded, save client address information in client drawable info structure.
    //
    clientDrawableInfo->pClientInfoMdl     = (PVOID)sysmemShareMemoryOut->pSystemMdl;
    clientDrawableInfo->userVirtualAddress = (PVOID)sysmemShareMemoryOut->userVirtualAddress;

    DISPDBG((2, "MapDrawableClientAddress - Exit"));

    return(TRUE);
}

//******************************************************************************
//
//  Function:   UnmapDrawableClientAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the user virtual address
//      into system address space where the display driver can get to it.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
UnmapDrawableClientAddress(
    PDEV                     *ppdev,
    NV_OPENGL_DRAWABLE_INFO  *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "UnmapDrawableClientAddress - Entry"));
    if (clientDrawableInfo && 
        clientDrawableInfo->pClientInfoMdl &&
        clientDrawableInfo->userVirtualAddress)
    {
        sysmemShareMemoryIn.pSystemMdl = (PVOID)clientDrawableInfo->pClientInfoMdl;
        sysmemShareMemoryIn.bDontModifyMDL = FALSE;
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)clientDrawableInfo->userVirtualAddress;

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
        {
            DISPDBG((2, "UnmapDrawableClientAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
        }
        clientDrawableInfo->userVirtualAddress = (PVOID)NULL;
    }
    else
    {
        DISPDBG((2, "UnmapDrawableClientAddress - clientDrawableInfo NULL"));
    }

    DISPDBG((2, "UnmapDrawableClientAddress - Exit"));
    return(TRUE);
}

//******************************************************************************
//
//  Function:   MapDrawableGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the display driver OGL 
//      shared page into the client address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
MapDrawableGlobalPageAddress(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "MapDrawableGlobalPageAddress - Entry"));

    clientDrawableInfo->oglGlobalPagePtr = NULL;

    sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL     = TRUE;
    sysmemShareMemoryIn.physicalAddress    = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress   = (PVOID)ppdev->oglGlobalPagePtr;
    sysmemShareMemoryIn.byteLength         = ppdev->oglGlobalPageSize;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        clientDrawableInfo->oglGlobalPagePtr = NULL;
        DISPDBG((2, "MapDrawableGlobalPageAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    // save user address in context info structure
    clientDrawableInfo->oglGlobalPagePtr = (PVOID)sysmemShareMemoryOut.userVirtualAddress;

    DISPDBG((2, "MapDrawableGlobalPageAddress - Exit"));

    return(TRUE);
}

//******************************************************************************
//
//  Function:   UnmapDrawableGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the display driver
//      OGL shared page of memory.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
static BOOL
UnmapDrawableGlobalPageAddress(
    PDEV                   *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "UnmapDrawableGlobalPageAddress - Entry"));
    if (clientDrawableInfo && 
        clientDrawableInfo->oglGlobalPagePtr)
    {
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)clientDrawableInfo->oglGlobalPagePtr;
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
        {
            DISPDBG((2, "UnmapDrawableGlobalPageAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
            clientDrawableInfo->oglGlobalPagePtr = NULL;
            return(FALSE);
        }
    
        clientDrawableInfo->oglGlobalPagePtr = NULL;
    }
    else
    {
        DISPDBG((2, "UnmapDrawableGlobalPageAddress - clientDrawableInfo NULL"));
    }

    DISPDBG((2, "UnmapDrawableGlobalPageAddress - Exit"));
    return(TRUE);
}


static void
CopyOrigClipList(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *cdiNode = NULL;

    // Document assumptions by using ASSERT...
    ASSERT(ppdev);
    ASSERT(ppdev->numDevices > 1);
    ASSERT(clientDrawableInfo);
    ASSERT(clientDrawableInfo->bOrigClipList == FALSE);
    ASSERT(clientDrawableInfo->origWindowRectList == NULL);

    OglAcquireGlobalMutex();

    cdiNode = globalOpenGLData.oglClientListHead.clientList;
    while (cdiNode)
    {
        clientInfo = &cdiNode->clientInfo;
        if (bOglHasDrawableInfo(clientInfo) &&
            clientInfo->clientDrawableInfo != clientDrawableInfo &&
            clientInfo->clientDrawableInfo->hWnd == clientDrawableInfo->hWnd && // same HWND
            clientInfo->clientDrawableInfo->bOrigClipList == TRUE && // 1st drawable with orignal unclipped rectlist
            clientInfo->clientDrawableInfo->origWindowRectList != NULL) // origWindowRectList allocated
        {
            // cdiNode contains the original unclipped window rectangle list
            // copy it to clientDrawableInfo
            // copy windowrect, too !
            clientDrawableInfo->numClipRects = clientInfo->clientDrawableInfo->numClipRects;
            clientDrawableInfo->rect = clientInfo->clientDrawableInfo->rect;
            OglAllocateAndCopyWindowClipList(ppdev, 
                                             clientDrawableInfo,
                                             clientInfo->clientDrawableInfo->origWindowRectList,
                                             clientInfo->clientDrawableInfo->numClipRects);
            break;
        }

        cdiNode = cdiNode->next;
    }

    OglReleaseGlobalMutex();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglexpor.c ===
//******************************Module*Header*******************************
// Module Name: oglexpor.c
//
// These variables and routines are exported by the Display Driver for use
// by the OpenGL shared library.  This is only used in NV10 and higher processors
//
// Copyright (c) 1998 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif


#ifndef NV3

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvReg.h"
#include "oglDD.h"
#include "pixelfmt.h"
#include "nvcom.h"       // drivers/common/inc
#include "nvtracecom.h"  // drivers/common/inc
#include "wincommon.h"   // drivers/common/inc
#include "wglcommon.h"   // drivers/common/inc
#include "Nvcm.h"        // Needed for NV_CFG_VBLANK_COUNTER,

#include "oglclip.h"

int nvControlOptions = 0;
int nvDebugOptions = 0;
int nvDebugMask = 0;
int nvDebugLevel = 0;
int nvDebugStatus = 0;
int nvTraceCountDMAWords = 0;
const int __glInKernel = TRUE;    

__GLNVdata *nvTraceLastPushBufCurrent = NULL;

// This local useful to disable assert's. Handy if assert's are keeping
// debugger control in Display driver, and all you want to do now is get
// back to client mode to terminate the application. May avoid a re-boot.
static int doBreakPoint = 1;

void __cdecl __glNVAssert(void *expString, void *filenameString, unsigned linenumber)
{
    if (doBreakPoint) {
        NV_BREAKPOINT();
    }
}

int __cdecl tprintf(const char *format, ...)
{
    va_list ap;
    
    va_start(ap, format);
    EngDebugPrint("", (char *)format, ap);
    va_end(ap);
    return 0;
}

void __cdecl nvTraceFuncEnter(int clas, nvFunRec *funRec)
{
    if ((nvDebugLevel >= 20) && (nvDebugMask & clas)) {
        tprintf("ENTER %s()\n",funRec->name);
    }
}

void __cdecl nvTraceFuncExit(int clas, nvFunRec *funRec)
{
    if ((nvDebugLevel >= 20) && (nvDebugMask & clas)) {
        tprintf("EXIT %s()\n",funRec->name);
    }
}

void __cdecl nvDebugCountDMAWords(void *cmdBufPtr)
{
}

void * __cdecl __glFlusholdNextPut(void *state)
{
    if (doBreakPoint) {
        NV_BREAKPOINT();
    }
    return NULL;
}

int __cdecl
__glFlusholdCheck2DClip(void *state)
{
    return 1;
}

void __cdecl nvComparePushBuf(void *fLastPut, void *fCurrent, void *fFifo, int fFormatted, int makeRoomWords, void *startOfFlushBlock)
{
}

#if defined(_WIN32) && !defined(_WIN64)
void __cdecl __glNVMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
    return;
}
#endif

void __cdecl __glNVFlushInternal(__GLNVcmdInfo *cmdInfo, 
                                   unsigned char forceRealBuf)
{
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

    if (forceRealBuf) {
        // forceRealBuf is TRUE when we are called from the lowest level
        // flush code that just wants us to write the Put.  So we just
        // call NV10_KickoffPushBuffer
        if (ppdev->oglSyncGdi) {
            OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                           cmdInfo->maskOtherChannels);
        }
        __glNVKickOffPushBufferNT(cmdInfo);
    } else {
        if (cmdInfo->usingCopyBuf) {
            __glNVCopyPseudoKickoff(cmdInfo, GL_TRUE);
        }
        if (!cmdInfo->isClipped) {
            // If we are not clipped rendering then we were just called from
            // a swap routine (this may change in the future.  In that case
            // all we have to do is write Put then make some jump space just
            // like __glNV10Flush does without all the drawable validation
            // stuff since we are guaranteed to flush before we enter the
            // shared lib.
            if (ppdev->oglSyncGdi) {
                OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                               cmdInfo->maskOtherChannels);
            }
            __glNVKickOffPushBufferNT(cmdInfo);
            __glNVMakeJumpSpaceInPushBuffer(cmdInfo);
        } else {
            // Otherwise, do a full clipped kickoff cuz we might have been
            // writing into the clipbuffer, SetupAndKickoff takes care of
            // this.  This can be recursively called from below SetupAndKickoff
            // or from a swap.

            // Note: Flushold my be busted here if the clipping changes.
            // We may need to revisit this and change the FALSE to a TRUE
            // so that it punts if were going to do a clip change.  The
            // other option is to move the clip test higher up.  
            //    - ibuck

            NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

            clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;

            // Test for optimized path
            if (clientDrawableInfo->ubbWindowClipFlag == (ULONG)TRUE &&
                !(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) &&
                cmdInfo->backBufferIsEnabled &&
                !__glNVWasFlipped(cmdInfo))
                {
                ULONG numRects;
                RECTL ubbRect;

                // 2D clip is bounds....ignore clip list in this case
                // UBB is ON, window is not occluded, window flipping is OFF, back buffered rendering only
                COPY_RECT(ubbRect, clientDrawableInfo->rect);
                OglClipRectToScreen((RECTL *)&ubbRect,
                                     clientDrawableInfo->cxScreen,
                                     clientDrawableInfo->cyScreen);
                OglTranslateCachedClipRectList(ppdev,
                                               &ubbRect, 1,
                                               &ubbRect, &numRects,
                                               (RECTL *) &(clientDrawableInfo->rect));

                __glNVSetupAndKickoff(cmdInfo,
                          numRects,  (__GLregionRect *)&ubbRect,
                          0, (__GLregionRect *)NULL,  FALSE);
            }
            else
            {
                __glNVSetupAndKickoff(cmdInfo,
                                  clientDrawableInfo->cachedNumClipRects,
                                  (__GLregionRect *)(clientDrawableInfo->cachedClipRectList),
                                  clientDrawableInfo->cachedNumExclusiveRects,
                                  (__GLregionRect *)(clientDrawableInfo->cachedExclusiveRectList),
                                  FALSE);
            }
        }
    }
}

/*
 * FUNCTION: __glNV4FlushInternal
 *
 * DESC: Wait for the DMA Channel and call the SetupAndKickoff routines to update the fifo pointers
 *       and clips.  If we are not clipped, or we have a bad rect list, then we will generate
 *       our own, based on the window position and occlusion.
 *
 * Called from __glNV4SetupSwap, nv4FlipBuffers, and NV4_OglFlushClipped.
 */
void __cdecl __glNV4FlushInternal(__GLNVcmdInfo *cmdInfo)
{
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;
    RECTL ubbRect;
    
    // BugFix for Indexed image blits when OGL running, for NV < NV10 (bug #20000720-213841)
    OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                   cmdInfo->maskOtherChannels);

    clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;

    // Otherwise, do a full clipped kickoff cuz we might have been
    // writing into the clipbuffer, SetupAndKickoff takes care of
    // this.  This can be recursively called from below SetupAndKickoff
    // or from a swap.
    if ( (!cmdInfo->isClipped) ||
         ((clientDrawableInfo->ubbWindowClipFlag == (ULONG)TRUE) &&
          !(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) &&
          (cmdInfo->backBufferIsEnabled)) )
    {
        extern void CombineRectLists(RECTL *rectList1, ULONG count1, 
                                     RECTL *rectList2, ULONG count2,
                                     LONG  leftList2, LONG topList2,
                                     RECTL *resultList, ULONG *resultCount);
        ULONG numRects;
        
        // 2D clip is bounds....ignore clip list in this case
        // UBB is ON, window is not occluded, window flipping is OFF, back buffered rendering only
        COPY_RECT(ubbRect, clientDrawableInfo->rect);
        OglClipRectToScreen((RECTL *)&ubbRect,
                            clientDrawableInfo->cxScreen,
                            clientDrawableInfo->cyScreen);

        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
                         &ubbRect, 1,
                         (LONG) (clientDrawableInfo->rect.left - ppdev->left),
                         (LONG) (clientDrawableInfo->rect.top - ppdev->top),
                         &ubbRect, &numRects);

        __glNV4SetupAndKickoff(cmdInfo, numRects, (__GLregionRect *)&ubbRect);
    }
    else /* We are clipped in one way or another. */
    {
        __glNV4SetupAndKickoff(cmdInfo, 
                               clientDrawableInfo->cachedNumClipRects,
                               (__GLregionRect *)clientDrawableInfo->cachedClipRectList);
    }
}

void __cdecl __glNV4KickOffPushBuffer(__GLNVcmdInfo *cmdInfo) 
{
    // Call back into the shared lib to do the kickoff since only the
    // shared lib has access to state, nv4state, etc...
    __glNV4KickOffPushBufferNT(cmdInfo);
}


unsigned int __cdecl __glNVGetCurrentScanLine(__GLNVcmdInfo *cmdInfo, int *iCurScanLine) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;

    *iCurScanLine = ppdev->pfnGetScanline(ppdev);
    return TRUE;
}

unsigned int __cdecl __glNVGetVBlankCounter(__GLNVcmdInfo *cmdInfo, int head, int *iCurSwap) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;
    NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS param;
    unsigned int ret;

    param.Head = head;
    param.VBlankCounter = 0;

    ret = (unsigned int) NvConfigGetEx (ppdev->hDriver,
                                        ppdev->hClient,
                                        ppdev->hDevice,
                                        NV_CFGEX_VBLANK_COUNTER_MULTI,
                                        &param,
                                        sizeof(param));
    *iCurSwap = param.VBlankCounter;
    return ret;
}

unsigned int __cdecl __glNVGetVBlankEnabled(__GLNVcmdInfo *cmdInfo, int head, int *enabled) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;
    NV_CFGEX_VBLANK_ENABLED_PARAMS param;
    unsigned int ret;

    param.Head = head;
    param.Enabled = *enabled;

    ret = (unsigned int) NvConfigGetEx (ppdev->hDriver,
                                        ppdev->hClient,
                                        ppdev->hDevice,
                                        NV_CFGEX_VBLANK_ENABLED,
                                        &param,
                                        sizeof(param));
    *enabled = (int) param.Enabled;
    return ret;
}

//******************************************************************************
// avoid unresolved globals from shared library.
// only needed in ICD.
//******************************************************************************

int __cdecl __glwqExportThreadIndex()
{
    NV_BREAKPOINT();    // should not be called in kernel
    return 0;
}

/*****************************************************************************/
void __cdecl
__glmt0NVWaitForFreeSpace(void *state, int space)
// should only be called from thread 0 (i.e. the master thread)
{
}

//********************************************************************
// This is called by OpenGL when it is going to do a flip.  This sets
// the flipbase to the base address of the buffer we are going to flip
// to.  In addition it also grabs the panning offset that the display
// driver is currently at if we happen to be doing a pan'n'scan type
// of virtual desktop.  This routine returns TRUE if OpenGL should 
// stop flipping due to another OpenGL surface active or if a ddraw
// video surface is also active since this would cause problems with
// window flipping.
//********************************************************************

int __cdecl __glNVDoDACParams(__GLNVcmdInfo *cmdInfo, NvU32 newDACOffset, NvU32 *panningOffset)
{
    int i;
    int stopFlip;
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

    for (i = 0; i < NV_NO_DACS; i++) 
        {
        panningOffset[i] = (NvU32)ppdev->ulHeadDisplayOffset[i];
        }

    stopFlip =  !((NV_OPENGL_CLIENT_INFO *)cmdInfo->ntClientInfo)->bFlipping;        
                //((globalOpenGLData.oglDrawableClientCount > 1) ||
                //(ppdev->oglDDrawSurfaceCount > OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING));

    if (!stopFlip)
    {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

        // flipping possible, remember new offset
        ppdev->ulFlipBase = (ULONG)newDACOffset;

        // this client is flippping now
        clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;
        clientDrawableInfo->bFlipping = TRUE;
    }
    /*
    else if (OGL_FLIPPED()) 
    {
        // flipping and we're on the wrong page 
        // and we need to flip back to primary
        vFlipToPrimary(ppdev);
    }
    */

    return stopFlip;  
}

//********************************************************************
// If video is active, then posting a stall method to the hardware may
// cause the hardware to hang since the resman may not able to service
// the stall method due to interrupts caused by the video driver
//********************************************************************

int __cdecl __glNVDisableStall(__GLNVcmdInfo *cmdInfo)
{
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
    if (ppdev->pDriverData->vpp.dwOverlaySurfaces) {
        return TRUE;
    }
#endif          
    return FALSE;

}

int __cdecl __wglNVGetPfdFlags(void *osother, __WINNVpixelFormatFlags *winPFFlags)
{
    PDEV *ppdev = (PDEV *) osother;
    int flags = 0;

    bOglPfdCheckFlags(ppdev, (ULONG *) &flags);
//    flags |= __winNVProcessWinFlags(winPFFlags);
    return flags;
}
int __cdecl __wglGDIDescribePixelFormat(int iPixelFormat,
                                        unsigned int uBytes,
                                        PIXELFORMATDESCRIPTOR *ppfd,
                                        void *osother)
{
    ASSERTDD(0,"__wglGDIDescribePixelFormat should not be called in the server");
    return FALSE;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglkick.c ===
/******************************Module*Header*******************************\
* Module Name: oglkick.c
*
* This module contains the functions to support the OpenGL kick off.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"

#define NV_JUMP(addr)  (0x20000000 | (addr))

#define DBG_KICKOFF_MESSAGES 1
#undef DBG_KICKOFF_MESSAGES

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

// ripped off from nv4ddrw.c
#define OFFSET_NV_PFIFO_BASE            (0x2000)
#define OFFSET_NV_PFIFO_DMA_REG         (0x2508-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1    (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_PUSH (0x3220-OFFSET_NV_PFIFO_BASE)
#define CACHE1_PUSH1_MODE_DMA           0x100
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100

extern VOID MagicDelay(void);

//******************************************************************************
//
//  Function: OglChannelWait
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglChannelWait(
    PDEV  *ppdev,
    ULONG ourChannelId,
    ULONG maskOtherChannels
    )
{
    /*
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  *pfifoCache1Push1;
    volatile ULONG  *pfifoCache1DmaPush;
    volatile ULONG  regValue;

    pfifoDmaReg        = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);
    pfifoCache1Push1   = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
    pfifoCache1DmaPush = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_PUSH);

    if (ppdev->oglLastChannel != ourChannelId)
        {
        regValue = READ_REGISTER_ULONG(pfifoDmaReg);
        // wait for all other channels to go to 0 (not active)
        while ((regValue & maskOtherChannels) != 0) 
            {
            (VOID)MagicDelay();
            regValue = READ_REGISTER_ULONG(pfifoDmaReg);
            }

        regValue = READ_REGISTER_ULONG(pfifoCache1Push1);
        if (((regValue & CACHE1_PUSH1_MODE_DMA) != 0) &&
            ((regValue & (0x1F)) != ourChannelId)) 
            {
            regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
            while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0) 
                {
                (VOID)MagicDelay();
                regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
                }
            }
        }
    */
    

    if (ppdev->oglLastChannel != ourChannelId)
    {
        ppdev->oglLastChannel = -1;             // FORCE IT TO SYNC...
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->oglLastChannel = ourChannelId;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglflip.c ===
//******************************Module*Header***********************************
// Module Name: oglflip.c
//
// Maintenance code for OpenGL flipping.
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#include "nvdoublebuf.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglclip.h"
#include "Nvcm.h"

// export
#include "oglflip.h"

//*************************************************************************
// bOglClientIsFlipCandidate
// 
// returns TRUE if clientInfo belongs to a client that is allowed to 
// do pageflipping now. A flip candidate must have a exchange pixelformat
// or run in fullscreen and must be visible 
//*************************************************************************
BOOL bOglClientIsFlipCandidate(
    IN PPDEV                          ppdev,
    IN struct _NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet = FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=clientInfo);

    // *****
    // *KEY* Here we decide if a client can flip or not!
    // *****
    if (   (clientInfo->pfd.dwFlags & PFD_SWAP_EXCHANGE)                // must have the exchange (flip) pixelformat
        && (   bOglIsUnclippedClient(clientInfo)                        // unclipped (easy decision)
            || (   !bOglClientIntersectingWithOtherClients(clientInfo)  // or not clipped against other ogl
                && !bOglIsComplexClippedClient(ppdev, clientInfo) )     // and not complex clipped (complex clipping is slower than blitting)
           )
        && (   bOglIsFullscreenClient(clientInfo)                       // either be a quake fullscreen client
            || (   ppdev->bOglSingleBackDepthSupported                  // or needs GDI double pumping
                && ppdev->bOglSingleBackDepthCreated)
           )
       )
    {
        // these assertions catch internal errors, where we export wrong pixelformats
        ASSERT(0 != (clientInfo->pfd.dwFlags & PFD_DOUBLEBUFFER));  // not allowed on single buffered client
        ASSERT(0 == clientInfo->pfd.bReserved);                     // not allowed on overlay client
        ASSERT(0 == (clientInfo->pfd.dwFlags & PFD_STEREO));        // not allowed on stereo client

        bRet = TRUE;
    }

    DISPDBG((3, "bOglClientIsFlipCandidate - 0x%08p %s", clientInfo, bRet ? "is a flip candidate" : "must blit"));

    return (bRet);
}


//*************************************************************************
// bOglGetNextFlipCandidate
// 
// returns next flip candidate starting with given client.
//*************************************************************************
BOOL bOglGetNextFlipCandidate(
    IN     PPDEV                   ppdev, 
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo) 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    ASSERT(NULL!=ppdev);

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextVisibleClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglClientIsFlipCandidate(ppdev, clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglIsClientFlipping
// 
// returns TRUE if given client is set to flip mode (this doesn't mean it 
// really is flipping if itself doesn't want!)
//*************************************************************************
BOOL bOglIsClientFlipping(
    IN struct _NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglHasDrawableInfo(clientInfo)
            && clientInfo->bFlipping);
}


//*************************************************************************
// bOglGetNextFlippingClient                                                 
//                                                                    
// Start with clientInfoStart (not included to search) and find       
// next flipping OpenGL client and return the result to *ppClientInfo.
// If clientInfoStart==START_SEARCH_AT_BEGIN start with first client. 
//                                                                    
// NOTE: There only should be one flipping client at all!             
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a flip client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextFlippingClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglIsClientFlipping(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeUpdate
// 
// Checks the pageflip status of all open OpenGL apps against system 
// conditions and updates status if neccessary. It will disable 
// pageflipping cleaning up the buffers, flipping back to primary, 
// notifiying affected clients. It will enable pageflipping if one single
// client is visible and it is a FlipCandidate. On Quadro it will manage
// double pumping for window flipping.
//
// Pageflip enable will only be done if PAGEFLIP_IMMEDIATE_UPDATE is set!
// Pageflip enable should not be called from within DrvClipChanged!
// 
// return: TRUE  - succeeded        
//         FALSE - failed, any error
//*************************************************************************
BOOL bOglPageFlipModeUpdate(PPDEV ppdev)
{
    BOOL                   bFlipCandidateFound  = FALSE;
    NV_OPENGL_CLIENT_INFO *clientInfoFlipOld    = NULL;
    NV_OPENGL_CLIENT_INFO *clientInfo           = NULL;
    BOOL                   bRet                 = FALSE;
    ULONG                  cVisibleClients;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    cVisibleClients = cOglVisibleClients(ppdev);

    if (   bOglDirectDrawAppRunning(ppdev) // direct draw has direct access to primary
        || bOglPOWERlibAppRunning(ppdev)   // POWERlib has direct access to primary
        || !OglIsEnabled(ppdev)            // OpenGL now disabled
       )
    {
        // apps using linear addressing to the FB running
        bRet = bOglPageFlipModeDisableAll(ppdev);
    }
    else if (   (0 == cOglWindows(ppdev)) // all ogls closed
             || (cVisibleClients  > 1)    // multiple visible clients
             || (cVisibleClients == 0)    // all clients invisible
            )
    {
        // conditions for flipping not met        
        bRet = bOglPageFlipModeDisableAll(ppdev);
    }
    else
    {
        // only one ogl visible
        ASSERT(1==cVisibleClients);

        clientInfo          = NULL;
        bFlipCandidateFound = bOglGetNextFlipCandidate(ppdev, &clientInfo);

        clientInfoFlipOld = NULL;
        if ( bOglGetNextFlippingClient(&clientInfoFlipOld) )
        {
            if (clientInfo != clientInfoFlipOld)
            {
                bOglPageFlipModeDisable(ppdev, clientInfoFlipOld);

                ASSERT(!bOglGetNextFlippingClient(NULL));
            }
        }

        if ( bFlipCandidateFound )
        {
            // only enable pageflipping now, if enable isn't deferred to the retry!
            if (PAGEFLIP_IMMEDIATE_UPDATE == ppdev->pOglServer->ulPageFlipRetryCounter)
            {
                //
                // KEY: Enable pageflipping for this client.
                //

                bRet = bOglPageFlipModeEnable(ppdev, clientInfo);
            }
            else
            {
                // leave it as it is!
            }
        }
        else
        {
            bRet = bOglPageFlipModeDisableAll(ppdev);
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeEnable
// 
// enables pageflipping for the given OpenGL client.
// The client has to be a FlipCandidate. If it isn't already flipping, 
// flipping will be allowed for that client and double pumping is enabled
// on Quadro boards.
// Pageflip enable should not be called from within DrvClipChanged!
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//*************************************************************************
BOOL bOglPageFlipModeEnable(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));
    ASSERT(bOglClientIsFlipCandidate(ppdev, clientInfo));

    if ( !bOglIsClientFlipping(clientInfo) )
    {
        if (bOglIsFullscreenClient(clientInfo))
        {
            // all fullscreen flip candidates may flip!
        }
        else if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
        {
            // Only workstation parts my flip if not fullscreen, but they need ubb buffers
            if (   !ppdev->bOglSingleBackDepthCreated                                                          // need UBB surface                 
                || (   !bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT])                 // need double pumping              
                    && !NV_AddDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) ) ) //   failed to enable double pumping
            {
                // failed to enable double pumping code!
                goto Exit;
            }
        }

        // *****
        // *KEY* here we enable a client to flip.
        // *****
        clientInfo->bFlipping = TRUE;
        clientInfo->clientDrawableInfo->ubbWindowClipFlag = FALSE; // need to disable ubb clip optimization
        ppdev->pOglServer->ulPageFlipRetryCounter         = PAGEFLIP_IMMEDIATE_UPDATE; // no need to retry anymore
        DISPDBG((3, "bOglPageFlipModeEnable: 0x%08p is flip enabled", clientInfo));
    }
    else 
    {
        // already initialized
    }


    bRet = TRUE;

Exit:
    return (bRet);
}


//******************************************************************************
// bOglPageFlipModeDisable
// 
// disables pageflipping for the given OpenGL client.
// This includes flipping back to primary, exchanging front and back if flipped
// and disabling double pumping.
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//******************************************************************************
BOOL bOglPageFlipModeDisable(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));
    ASSERT(bOglIsClientFlipping(clientInfo));

    DISPDBG((3, "bOglPageFlipModeDisable: 0x%08p must blit again", clientInfo));
    //
    // disable double pumping, fix buffer offsets...

    if (OGL_FLIPPED()) 
    {
        vFlipToPrimary(ppdev);
    }

    // Potentially client needs to fix his surface offsets
    clientInfo->clientDrawableInfo->clipChangedCount++;
    clientInfo->bFlipping = FALSE;

    // NOTE: This is an assumption that we only double pump on this buffer for page flipping
    if ( bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]);
    }

    bRet = TRUE;
        
    return (bRet);
}


//******************************************************************************
// bOglPageFlipModeDisableAll
// 
// disables pageflipping for all OpenGL clients running.
// This includes flipping back to primary, exchanging front and back if flipped
// and disabling double pumping.
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//******************************************************************************
BOOL bOglPageFlipModeDisableAll(PPDEV ppdev)
{
    BOOL                   bRet       = FALSE;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;

    ASSERT(NULL!=ppdev);

    //
    // This is only done in the case a flipping client wasn't found!
    //

    if (OGL_FLIPPED()) 
    {
        vFlipToPrimary(ppdev);
    }

    clientInfo = NULL;
    while (bOglGetNextFlippingClient(&clientInfo))
    {
        ASSERT(bOglIsClientFlipping(clientInfo));

        bOglPageFlipModeDisable(ppdev, clientInfo);
        
        // I don't think I want to have two simultaneous flipping clients!
        ASSERT(!bOglGetNextFlippingClient(NULL));
    }

    // NOTE: This is an assumption that we only double pump on this buffer for page flipping
    if ( bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]);
    }
        
    bRet = TRUE;
        
    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeRetryEnable
// 
// Tries to enalbe pageflipping again depending on retry counter.
// If pageflipping was disabled due to collision with GDI we initialize a
// counter to try again after several swapbuffer calls. 
// If the counter is down to PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP it will 
// try an immediate update of pageflipping.
// DrvClipChanged will set the counter to PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP 
// to invoke a pageflip enable at the next SwapBuffers.
//
// This function must either be called in the context of SwapBuffers or
// in the __glNVDoDACParams (for now it is called in SwapBuffers).
// At lease it MUST be called somewhere!
//*************************************************************************
BOOL bOglPageFlipModeRetryEnable(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    // As it is unsigned this test includes PAGEFLIP_IMMEDIATE_UPDATE
    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    if (PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP == ppdev->pOglServer->ulPageFlipRetryCounter)
    {
        DISPDBG((3, "bOglPageFlipModeRetryEnable: retry enable pageflipping"));

        //
        // Key: try again to enable pageflipping
        //
        ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_IMMEDIATE_UPDATE;
        bRet = bOglPageFlipModeUpdate(ppdev);
    }
    else if (PAGEFLIP_IMMEDIATE_UPDATE != ppdev->pOglServer->ulPageFlipRetryCounter)
    {
        // wait some more time to enable pageflipping
        ppdev->pOglServer->ulPageFlipRetryCounter--;
    }
    else // ppdev->pOglServer->ulPageFlipRetryCounter == PAGEFLIP_IMMEDIATE_UPDATE
    {
        // default, nothing to do!
    }

    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    return bRet;
}


//*************************************************************************
// cOglFlippingClients
// returns the current number of clients in pageflip mode
//*************************************************************************
ULONG cOglFlippingClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cFlipClients=0;

    clientInfo = NULL;
    while (bOglGetNextFlippingClient(&clientInfo))
    {
        cFlipClients++;
    }

    // current hard- and sw only supports one flip client!
    ASSERT(cFlipClients <= 1);
    return (cFlipClients);
}
// End of oglflip.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglflip.h ===
#ifndef _OGLFLIP_H
#define _OGLFLIP_H
//******************************Module*Header***********************************
// Module Name: oglflip.h
//
// Export file for maintenance code for OpenGL flipping.
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglPageFlipModeUpdate(PPDEV ppdev);
BOOL bOglPageFlipModeEnable(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglPageFlipModeDisable(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglPageFlipModeDisableAll(PPDEV ppdev);
BOOL bOglPageFlipModeRetryEnable(PPDEV ppdev);
ULONG cOglFlippingClients(PPDEV ppdev);

#endif // _OGLFLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldebug.c ===
//******************************Module*Header***********************************
// Module Name: ogldebug.c
//
// special debug code for ogl server part of display driver
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"

#if DBG
#include "ogldebug.h"

//*************************************************************************
// DrvClipChanged-WOC-Flags stuff:
//                                                        
// szDbg_WOC_flGet
//   return string exactly matching fl
// aDbg_WOC_fl                                             
//   array defining all flags                             
//*************************************************************************
DBG_NAMEINDEX aDbg_WOC_fl[] =
{
    DBG_MAKE_NAMEINDEX(WOC_RGN_CLIENT_DELTA ),
    DBG_MAKE_NAMEINDEX(WOC_RGN_CLIENT       ),
    DBG_MAKE_NAMEINDEX(WOC_RGN_SURFACE_DELTA),
    DBG_MAKE_NAMEINDEX(WOC_RGN_SURFACE      ),
    DBG_MAKE_NAMEINDEX(WOC_CHANGED          ),
    DBG_MAKE_NAMEINDEX(WOC_DELETE           ),
    #if (_WIN32_WINNT >= 0x0500)
    DBG_MAKE_NAMEINDEX(WOC_DRAWN            ),
    DBG_MAKE_NAMEINDEX(WOC_SPRITE_OVERLAP   ),
    DBG_MAKE_NAMEINDEX(WOC_SPRITE_NO_OVERLAP),
    #endif
};

char *szDbg_WOC_flGet(ULONG fl)
{
    return (DBG_GETDBG_NAMEINDEX(aDbg_WOC_fl, fl));
}

#endif // DBG
// End of ogldebug.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\OglOverlay.h ===
#ifndef __OGLOVERLAY_H
#define __OGLOVERLAY_H
//
// MSchwarzer 09/28/2000: new
//
void OglInitLayerPalette(void);

BOOL bOglFindGlobalLayerPaletteHWND(
    IN  HWND hWnd, 
    OUT NV_LAYER_PALETTE **ppLayerPalette);

BOOL OglSetLayerPalette(__GLNVpaletteData *pSourcePalette);
BOOL OglGetLayerPalette(__GLNVpaletteData *pDestPalette);
BOOL OglDestroyLayerPalette(HWND hWnd);

BOOL bClearOverlayForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd, BOOL bClearFrontBuffer, BOOL bClearBackBuffer);
BOOL bClearOverlayArea(PPDEV ppdev, WNDOBJ *pwo, ULONG ulTransparentColor, BOOL bClearFrontBuffer, BOOL bClearBackBuffer);
BOOL bCopyMainPlaneFrontToPrimaryForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd);
BOOL bCopyIntersectingMainPlaneFrontToPSO(PPDEV  ppdev, SURFOBJ *psoSrc, SURFOBJ *psoDst, RECTL* prclDst, POINTL* pptlSrc);
BOOL bDoMergeBlitOnIntersectingRectangle(PPDEV  ppdev, RECTL* prclDst);
BOOL bOglSwapMergeBlit(PPDEV ppdev, struct __GLMergeBlitDataRec   *pMergeBlitData);

BOOL bAddPointerToList( PPOINTER_LIST, PVOID);
BOOL bIsPointerInList( PPOINTER_LIST, PVOID);
BOOL bRemovePointerFromList( PPOINTER_LIST, PVOID);
BOOL bClearPointerList( PPOINTER_LIST);
BOOL bIsPointerListEmpty( PPOINTER_LIST pList );
BOOL bRemoveFirstElementFromList( PPOINTER_LIST pList );
BOOL ulGetNumberOfPointersInList( PPOINTER_LIST pList );

BOOL bOglGetNextOverlayClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL bOglGetNextVisibleOverlayClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL bOglIsOverlayClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglIsOverlayModeEnabled(PPDEV ppdev);
BOOL bOglOverlayModeUpdate(PPDEV ppdev);
BOOL bOglOverlayModeEnable(PPDEV ppdev);
BOOL bOglOverlayModeDisable(PPDEV ppdev);

ULONG cOglOverlayClients(PPDEV ppdev);
BOOL  bOglOverlaySurfacesAllowed(PPDEV ppdev);
#endif // __OGLOVERLAY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglstereo.h ===
#ifndef __OGLSTEREO_H
#define __OGLSTEREO_H

/*
**
** MODULE: oglstereo.h
**
** OS dependent functions releated to oglstereo reside here
**
** Copyright (C) 2000 NVidia Corporation. All Rights Reserved.
**
*/

BOOL  bOglStereoGlassesSwitchOff(PDEV* ppdev);
BOOL  bOglStereoGlassesSwitchOn(PDEV* ppdev);
BOOL  bOglIsStereoClient(struct _NV_OPENGL_CLIENT_INFO *pClientInfo);
ULONG cOglStereoClients(PPDEV ppdev);
BOOL  bOglIsStereoModeEnabled(PPDEV ppdev);
BOOL  bOglStereoModeUpdate(PPDEV ppdev);
BOOL  bOglStereoModeEnable(PPDEV ppdev);
BOOL  bOglStereoModeDisable(PPDEV ppdev);
BOOL  bOglGetNextActiveStereoClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL  bOglGetNextStereoClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);


#endif //#ifndef __OGLSTEREO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglswap.c ===
/******************************Module*Header*******************************\
* Module Name: oglswap.c
*
* This module contains the functions to support the OpenGL swap buffers.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglOverlay.h"
#include "oglsync.h"
#include "oglflip.h"
#include "Nvcm.h"   // Needed for NV_CFG_VBLANK_COUNTER,

#if (NVARCH >= 0x4)
#include "nvcom.h"          // drivers/common/inc
#include "nvtracecom.h"     // drivers/common/inc
#endif // (NVARCH >= 0x4)


#define DBG_SWAP_MESSAGES 1
#undef DBG_SWAP_MESSAGES


#define __glNV4SetupSwap(a, b, c, d, e, f)

//******************************************************************************
//
//  Function: OglUseDisplayDriverBlt
//
//  Routine Description:
//
//        Utility routine to use display driver channel for a BLIT.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void
OglUseDisplayDriverBlt(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    LONG srcOffset,
    LONG srcPitch,
    LONG srcLeft, 
    LONG srcTop, 
    LONG dstOffset,
    LONG dstPitch,
    LONG dstLeft, 
    LONG dstTop, 
    LONG width, 
    LONG height
)
    {
    if (srcLeft != dstLeft || srcTop != dstTop)
        {
        LONG dstRight, dstBottom;
        RECTL  rclDst;
        POINTL ptlSrc;

        ppdev->NVFreeCount = 0;

        //**************************************************************
        // Clip to display... (pixels outside of display size are undefined)
        //**************************************************************
        if ((long)dstLeft < (long)0)
            {
            srcLeft -= dstLeft;
            width += dstLeft;
            dstLeft = 0;
            }
        if ((long)dstTop < (long)0)
            {
            srcTop -= dstTop;
            height += dstTop;
            dstTop = 0;
            }

        if ((long)width > 0 && (long)height > 0)
            {
            LONG lDeltaX, lDeltaY;

            dstRight = dstLeft + width;
            dstBottom = dstTop + height;

            if ((long)srcLeft < (long)0)
                {
                ptlSrc.x = 0;
                rclDst.left = -srcLeft + dstLeft;
                }
            else
                {
                ptlSrc.x = srcLeft;
                rclDst.left = dstLeft;
                }
            if ((long)srcTop < (long)0)
                {
                ptlSrc.y = 0;
                rclDst.top = -srcTop + dstTop;
                }
            else
                {
                ptlSrc.y = srcTop;
                rclDst.top = dstTop;
                }

            // right and bottom of source must be inside screen too,
            // because we cannot blit from outside of screen!
            lDeltaX = srcLeft + width - clientDrawableInfo->cxScreen;
            if (lDeltaX > 0)
                {
                width    -= lDeltaX;
                dstRight -= lDeltaX;
                }

            lDeltaY = srcTop + height - clientDrawableInfo->cyScreen;
            if (lDeltaY > 0)
                {
                height    -= lDeltaY;
                dstBottom -= lDeltaY;
                }

            if ((long)dstRight > (long)clientDrawableInfo->cxScreen)
                {
                rclDst.right = clientDrawableInfo->cxScreen;
                }
            else
                {
                rclDst.right = dstRight;
                }

            if ((long)dstBottom > (long)clientDrawableInfo->cyScreen)
                {
                rclDst.bottom = clientDrawableInfo->cyScreen;
                }
            else
                {
                rclDst.bottom = dstBottom;
                }

            if ((long)rclDst.right >= (long)rclDst.left &&
                (long)rclDst.bottom >= (long)rclDst.top)
                {

                ppdev->pfnAcquireOglMutex(ppdev);

                // do complete sync on all ICD channels
                OglSyncEngineUsingPDEV(ppdev);

                (ppdev->pfnSetSourceBase)(ppdev, srcOffset, srcPitch);
                (ppdev->pfnSetDestBase)(ppdev, dstOffset, dstPitch);
                (ppdev->pfnCopyBlt)(ppdev, 1, &rclDst, 0xcccc, &ptlSrc, &rclDst, NULL);

                ppdev->pfnWaitEngineBusy(ppdev);

                ppdev->pfnReleaseOglMutex(ppdev);
                }
            }

        }
    }

// This function builds the intersection of a cliplist with a SwapHintRect list.
// INPUT:   pSwapHintRects points to the list that was passed in by the escape
//          numSwapHintRects is the number of rects in pSwapHintRects
//          windowRectList is the translated cliplist from the clientDrawableInfo
//          numWindowRects is the number of cliprects in windowRectList
//          pSwapRects points to the resulting list of swap rectangles
// OUTPUT:  pSwapRects contains NULL if there are no SwapHintRects in the escape data,
//              otherwise it contains a pointer to the newly allocated list of swap rectangles
//          the return value is the number of resulting swap rectangles

ULONG OglApplySwapHintRects(
    __GLregionRect *pSwapHintRects, 
    ULONG numSwapHintRects, 
    __GLregionRect *windowRectList, 
    ULONG numWindowRects, 
    __GLregionRect *pSwapRects
)
    {
    ULONG ulNumResultRects = 0;

    if ((numSwapHintRects > 0) && (NULL != pSwapHintRects)) 
        {
        __GLregionRect *pSwapRect;
        __GLregionRect *pClipRect;
        __GLregionRect *pResultRect;
        int numSwapRects, numClipRects;

        numSwapRects = numSwapHintRects;

        if (NULL != pSwapRects) 
            {
            // clip each clip rect against each swaphint rect to get the resulting list of swap rectangles 
            pSwapRect = pSwapHintRects;
            ASSERT(NULL != pSwapRect); // if the counter is > 0, there must be a rectangle
            while (numSwapRects > 0) 
                {
                pClipRect       = windowRectList;
                numClipRects    = numWindowRects;
                while (numClipRects > 0) {
                    // Test on intersection                    
                    if (   (pSwapRect->x0 < pClipRect->x1) 
                        && (pSwapRect->x1 > pClipRect->x0)  
                        && (pSwapRect->y0 < pClipRect->y1) 
                        && (pSwapRect->y1 > pClipRect->y0) )
                        {
                        // copy intersection rectangle into resulting swaprect list
                        pResultRect = &pSwapRects[ulNumResultRects];
                        pResultRect->x0 = max(pSwapRect->x0, pClipRect->x0);
                        pResultRect->x1 = min(pSwapRect->x1, pClipRect->x1);
                        pResultRect->y0 = max(pSwapRect->y0, pClipRect->y0);
                        pResultRect->y1 = min(pSwapRect->y1, pClipRect->y1);
                        ulNumResultRects++;
                        }
                    pClipRect++;
                    numClipRects--;
                    }
                pSwapRect++;
                numSwapRects--;
                }    
            }
        }

    return ulNumResultRects;
    }


//******************************************************************************
//
//  Function: NV4_OglSwapBuffers
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
ULONG
NV4_OglSwapBuffers(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG hClient,
    __GLNVswapInfo *swapInfo
)
{
#if (NVARCH >= 0x4)
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;
    ULONG                      swapHintUsed;

    if (!swapInfo ||
        ppdev->dwGlobalModeSwitchCount != swapInfo->localModeSwitchCount)
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_MODE_SWITCH\n");
        swapInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)FALSE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    try
    {
        cmdInfo = swapInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV4_OglSwapBuffers: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    
    
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    if ((LONG)swapInfo->clipChangedCount != (LONG)clientDrawableInfo->clipChangedCount)
        {
        swapInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)FALSE); 
        }

#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif
    
    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
        {
        swapInfo->retStatus = OGL_ERROR_NO_ERROR;
        return TRUE;
        }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        swapInfo->retStatus = OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    //
    // If retry counter is set, try to enable pageflipping again
    //
    bOglPageFlipModeRetryEnable(ppdev);

    windowRectList = clientDrawableInfo->cachedClipRectList;
    numWindowRects = clientDrawableInfo->cachedNumClipRects;

    cmdInfo->ntOther      = (void *)ppdev;
    cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list in the __GLNVswapInfo
    swapHintUsed = FALSE;
    if (swapInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG          numSwapRects = 0;      // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      swapInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (pSwapRectList != NULL)
            {
            swapHintUsed = TRUE;

            numSwapRects = OglApplySwapHintRects(   swapInfo->pSwapHintRects,
                                                    swapInfo->numSwapHintRects, 
                                                    (__GLregionRect *)windowRectList, 
                                                    numWindowRects, 
                                                    pSwapRectList);
            if (numSwapRects > 0)
                {
                // Call into the shared library to do the swap.
                __glNV4SetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                                 numSwapRects,
                                 pSwapRectList,
                                 (int) clientDrawableInfo->cxScreen,
                                 (int) clientDrawableInfo->cyScreen);

                }

            EngFreeMem(pSwapRectList);
            }
        }


    if (FALSE == swapHintUsed)
        {
        // Call into the shared library to do the swap.
        __glNV4SetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                         numWindowRects,
                         (__GLregionRect *)windowRectList,
                         (int) clientDrawableInfo->cxScreen,
                         (int) clientDrawableInfo->cyScreen);
        }

    swapInfo->retStatus = OGL_ERROR_NO_ERROR;
#endif // (NVARCH >= 0x4)
    return((ULONG)TRUE);
}

#if (NVARCH >= 0x4)
//******************************************************************************
//
//  Function: NV_OglSwapBuffers
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
ULONG
NV_OglSwapBuffers(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG hClient,
    __GLNVswapInfo *swapInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;
    ULONG                      swapHintUsed;

    if (!swapInfo ||
        ppdev->dwGlobalModeSwitchCount != swapInfo->localModeSwitchCount)
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_MODE_SWITCH\n");
        swapInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)FALSE);
        }
    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    try
    {
        cmdInfo = swapInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV_OglSwapBuffers: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    

    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    if ((LONG)swapInfo->clipChangedCount != (LONG)clientDrawableInfo->clipChangedCount)
        {
        swapInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)FALSE); 
        }

#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif
    
    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
        {
        swapInfo->retStatus = OGL_ERROR_NO_ERROR;
        return TRUE;
        }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        swapInfo->retStatus = OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    //
    // If retry counter is set, try to enable pageflipping again
    //
    bOglPageFlipModeRetryEnable(ppdev);

    windowRectList = clientDrawableInfo->cachedClipRectList;
    numWindowRects = clientDrawableInfo->cachedNumClipRects;

    cmdInfo->ntOther      = (void *)ppdev;
    cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

    // In a stereo environment enable broadcasting to
    // right buffer if stereo is active. 
    // NOTE: this is also done for monoscopic apps, but we need the right 
    //       buffers to be initialized
    if (ppdev->bOglStereoDesired)
    {
        __glNVPrepareStereoSwap((void *)swapInfo->drawable, ppdev->bOglStereoActive);
    }

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list in the __GLNVswapInfo
    swapHintUsed = FALSE;
    if (swapInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG          numSwapRects = 0;      // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      swapInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (pSwapRectList != NULL)
            {
            swapHintUsed = TRUE;

            numSwapRects = OglApplySwapHintRects(   swapInfo->pSwapHintRects,
                                                    swapInfo->numSwapHintRects, 
                                                    (__GLregionRect *)windowRectList, 
                                                    numWindowRects, 
                                                    pSwapRectList);
            if (numSwapRects > 0)
                {
                // Call into the shared library to do the swap.
                __glNVSetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                                numSwapRects,
                                pSwapRectList,
                                (int) clientDrawableInfo->cxScreen,
                                (int) clientDrawableInfo->cyScreen);

                }

            EngFreeMem(pSwapRectList);
            }
        }


    if (FALSE == swapHintUsed)
        {
        // Call into the shared library to do the swap.
        __glNVSetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                        numWindowRects,
                        (__GLregionRect *)windowRectList,
                        (int) clientDrawableInfo->cxScreen,
                        (int) clientDrawableInfo->cyScreen);
        }

    swapInfo->retStatus = OGL_ERROR_NO_ERROR;
    return (TRUE);
}


/*
** NV_OglOverlayMergeBlit
** 
** Derived from NV_OglSwapBuffers.
**
** Display driver version of overlay merge blit implementation. 
** Needs to feed the surface offsets to the blit.
** Needs to feed correct clip information.
** 
** return:
**    TRUE  - succeeded
**    FALSE - failed to do the merge blit
** 
** FNicklisch 26.09.2000: New
*/ 
ULONG NV_OglOverlayMergeBlit(
    PDEV                       *ppdev,
    HWND                        hWnd,
    HDC                         hDC,
    __GLNVoverlayMergeBlitInfo *pMergeInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo         = NULL;  // Client data...
    NV_OPENGL_CLIENT_INFO_LIST *clientList         = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;                    // Common commandinfo passed to merge blit
    RECTL                      *prclWindowClipList;         // local clip list
    ULONG                       numWindowRects;             // number of valid rects inside prclWindowClipList
    __GLMergeBlitData           MergeBlitData;              // Data structure passed to merge blit
    NV_LAYER_PALETTE           *pLayerPalette;              // overlay palette used for this window
    ULONG                       ulRet              = FALSE; // default error Exit
    unsigned int                dwAction           = 0;     // Local mergeblit configuration bits
    ULONG                       ulTemp;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=pMergeInfo);

    //
    // check if overlay is possible
    //
    if (!ppdev->bOglOverlaySurfacesCreated)
    {
        // This happens during startup of an overlayed ogl app!
        pMergeInfo->retStatus = OGL_ERROR_SURFACE_INVALID;
        goto Exit;
    }

    try
    {
        cmdInfo = pMergeInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ASSERTDD(0,"cannot access pMergeInfo, please fix that!");
        DISPDBG((1, "NV_OglOverlayMergeBlit: pMergeInfo: exception = 0x%lx", GetExceptionCode()));
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }    
    
    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    ASSERT(NULL!=clientList);
    if (clientList)
    {
        clientInfo = &clientList->clientInfo;
        ASSERT(NULL!=clientInfo);
    }
    else
    {
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }

    if (clientInfo)
    {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERT(NULL!=clientDrawableInfo);
    }
    else
    {
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }

    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
    {
        pMergeInfo->retStatus = OGL_ERROR_NO_ERROR;
        ulRet = TRUE;
        goto Exit;
    }

    prclWindowClipList =
        EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * clientDrawableInfo->numClipRects), ALLOC_TAG);

    if (NULL==prclWindowClipList)
    {
        OglDebugPrint("NV_OglOverlayMergeBlit: EngAllocMem failed for prclWindowClipList, bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        pMergeInfo->retStatus = OGL_ERROR_CLIP_LIST_BAD;
        goto Exit;
    }


    //
    // FNicklisch: ToDo later...
    // Can spend some time on rewritting the clip list code below.
    // It isn't neccessary to convert to client relative and then back to 
    // desktop relative.
    // 
    
    //
    // Client relative part
    //

    OglTranslateCachedClipRectList(ppdev,
                                   clientDrawableInfo->copyWindowRect,
                                   clientDrawableInfo->numClipRects,
                                   prclWindowClipList,
                                   &numWindowRects,
                                   (RECTL *) &(clientDrawableInfo->rect));
    ASSERT(numWindowRects==clientDrawableInfo->numClipRects);

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list
    if (pMergeInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG           numSwapRects  = 0;    // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      pMergeInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (NULL != pSwapRectList)
            {
            ASSERT(NULL != prclWindowClipList);
            ASSERT(numWindowRects>0);

            numSwapRects = OglApplySwapHintRects(pMergeInfo->pSwapHintRects,
                                                 pMergeInfo->numSwapHintRects, 
                                                 (__GLregionRect *)prclWindowClipList, 
                                                 numWindowRects, 
                                                 pSwapRectList);

            // use the swaphint list as current clip list and release the old one
            EngFreeMem(prclWindowClipList);

            prclWindowClipList = (RECTL *) pSwapRectList;
            numWindowRects     = numSwapRects;
            }
        }


    //
    // Use desktop relative coordinates here. In place translation!
    //
    OglTranslateClientRelativeRectListToDevice(ppdev,
                                               prclWindowClipList, numWindowRects,
                                               prclWindowClipList, &ulTemp,
                                               (RECTL *) &(clientDrawableInfo->rect));
    ASSERT(numWindowRects==ulTemp);

    MergeBlitData.prclClip           = (__GLregionRect *)prclWindowClipList;
    MergeBlitData.cClip              = numWindowRects;

    //
    // Setup offset data 
    //
    MergeBlitData.PrimaryFrontOffset = ppdev->ulPrimarySurfaceOffset;
    MergeBlitData.PrimaryFrontPitch  = ppdev->lDelta;
    MergeBlitData.ScratchOffset      = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.ScratchPitch       = ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT];

    MergeBlitData.MainFrontOffset    = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainFrontPitch     = ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainBackOffset     = ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainBackPitch      = ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_LEFT];

    MergeBlitData.OverlayFrontOffset = ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.OverlayFrontPitch  = ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.OverlayBackOffset  = ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT]; 
    MergeBlitData.OverlayBackPitch   = ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT]; 


    if (!bOglFindGlobalLayerPaletteHWND(hWnd, &pLayerPalette))
    {
        // 
        // No palette does mean no layer plane!
        // FNicklisch: This is kind of a hack! Should find a better way to check if a window is an overlay window.
        //
        //isn't so critical...OglDebugPrint("NV_OglOverlayMergeBlit: couldn't find layer palette!\n");

        dwAction               = NV_OVERLAY_NO_OVERLAY_PLANE;
        MergeBlitData.colorref = ICD_PALETTE_TRANSPARENT_COLOR;
    }
    else
    {
        ASSERT(NULL!=pLayerPalette);
        MergeBlitData.colorref = pLayerPalette->entries[pLayerPalette->crTransparent];
    }

    ASSERT(2==ppdev->cjPelSize || 4==ppdev->cjPelSize);

    MergeBlitData.colordepth         = ppdev->cjPelSize * 8; // 16 or 32!
    MergeBlitData.dwAction           = pMergeInfo->dwAction | dwAction;

    // Only know these bits
    ASSERT(0==(MergeBlitData.dwAction & ~(  NV_OVERLAY_MERGE_BLIT
                                          | NV_OVERLAY_UPDATE_OVERLAY
                                          | NV_OVERLAY_UPDATE_MAIN
                                          | NV_OVERLAY_USE_CLIPRECT
                                          | NV_OVERLAY_DEFERRED
                                          | NV_OVERLAY_NO_OVERLAY_PLANE
                                          | NV_OVERLAY_RUN_IN_DD
                                          )));

    //
    // If we use the user clipping, transfer it to desktop relative space
    //
    if (MergeBlitData.dwAction & NV_OVERLAY_USE_CLIPRECT)
    {
        // NOTE: User cliping in pMergeInfo is client relative!
        MergeBlitData.rclUser.x0 = pMergeInfo->x;
        MergeBlitData.rclUser.y0 = pMergeInfo->y;
        MergeBlitData.rclUser.x1 = pMergeInfo->x + pMergeInfo->width;
        MergeBlitData.rclUser.y1 = pMergeInfo->y + pMergeInfo->height;

        OglTranslateClientRelativeRectListToDevice(ppdev,
                                                   (RECTL *)&MergeBlitData.rclUser, 1,
                                                   (RECTL *)&MergeBlitData.rclUser, &ulTemp,
                                                   (RECTL *)&(clientDrawableInfo->rect));
        ASSERT(1==ulTemp);
    }

    if (   (NULL==cmdInfo)                                   // this happens if're called from inside display driver
        || (MergeBlitData.dwAction & NV_OVERLAY_RUN_IN_DD) ) // this happens if we want to run in the display driver channel
    {
        // this is a merge blit which has to happen in the display driver!
        // DD channel

        bOglSwapMergeBlit(ppdev,
                          &MergeBlitData);
    }
    else
    {
        // Call into the shared library to do the merge blit.
        // ICD channel
        cmdInfo->ntClientInfo = clientInfo;
        ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

        __glNVSetupMergeBlit(cmdInfo,
                             &MergeBlitData);
    }

    //
    // This sync here fixes most of the Softimage problems (preview, texture selectio box...)
    //
    ppdev->pfnAcquireOglMutex(ppdev);
    ppdev->pfnWaitForChannelSwitch(ppdev);
    ppdev->pfnWaitEngineBusy(ppdev);
    ppdev->pfnReleaseOglMutex(ppdev);

    EngFreeMem(prclWindowClipList);
    pMergeInfo->retStatus = OGL_ERROR_NO_ERROR;

    ulRet = TRUE;
Exit:
    return (ulRet);
}

#endif // (NVARCH >= 0x4)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsync.h ===
#ifndef _OGLSYNC_H
#define _OGLSYNC_H
//******************************Module*Header***********************************
// Module Name: oglsync.h
//
// interface file for syncing routines GDI against ogl, and ogl against ogl
//
// Copyright (c) 2001, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

void OglSyncEngineUsingPDEV(PDEV *ppdev);
#ifdef DISABLE_OGLSYNC
    #pragma message("  FNicklisch: WARNING: OglSync against GDI is disabled, shouldn't be default!")
    #define bOglSyncOglIfGdiRenderedToWindow(ppdev)                                     TRUE
    #define bOglSyncIfGdiInOglWindowRect(ppdev,pso,prclTrg,pco)                         TRUE
    #define bOglSyncIfGdiInOglWindowPath(ppdev,pso,ppo,pco)                             TRUE
    #define bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc)        TRUE
    #define bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc)    TRUE
#else

BOOL bOglSyncOglIfGdiRenderedToWindow(
    IN PPDEV ppdev);

BOOL bOglSyncIfGdiInOglWindowRect(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to prclBounds
    IN RECTL   *prclTrg,    // destination rectangle of drawing surface
    IN CLIPOBJ *pco);       // clip obj for destination

BOOL bOglSyncIfGdiInOglWindowPath(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to object
    IN PATHOBJ *ppo,        // pathobject to be rendered on pso
    IN CLIPOBJ *pco);       // clip obj for destination

BOOL bOglSyncIfGdiInOglWindowBlt(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN POINTL  *pptlSrc);   // source point

BOOL bOglSyncIfGdiInOglWindowStretch(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN RECTL   *prclSrc);   // source point
#endif //DISABLE_OGLSYNC

#endif // _OGLSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsurf.c ===
/******************************Module*Header*******************************\
* Module Name: oglsurf.c
*
* Single-back-depth surface API.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "rectUtils.h"
#include "oglstereo.h"
#include "ogloverlay.h"
#include "oglflip.h"
#include "oglsync.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

//******************************************************************************
//
//  Function: OglAllocOverlaySurfaces
//
//  Routine Description:
//            Allocate 4 auxiliary overlay surfaces for opengl pseudo
//            hardware implementation of overlay planes
//
//  Arguments:
//
//  Return Value:
//            TRUE if succeeds
//
//
//******************************************************************************
static int
OglAllocOverlaySurfaces(
    PDEV  *ppdev,
    ULONG  ulView
)
{
    RBRUSH_COLOR  rbc  = {0};    // solid colour brush
    RECTL         rclScreen;
    int   iRet   = FALSE;
    DWORD   dwStatus;

    //__asm int 3;
    // Alloc front main surface

    rbc.iSolidColor = ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000;


    // at this time we don't support real stereo-overlay
    ASSERT( OGL_STEREO_BUFFER_LEFT == ulView );
    ASSERT( NULL != ppdev );

    // desktop extend to clear overlaybuffers after creation
    rclScreen.left   = 0;
    rclScreen.top    = 0;
    rclScreen.right  = ppdev->cxScreen;
    rclScreen.bottom = ppdev->cyScreen;

    ppdev->singleFrontMainOffset[ulView] = 0;
    ppdev->singleFrontMainPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontMainOffset[ulView], (DWORD)ppdev->singleFrontMainPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleFrontMainPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc back main surface
    ppdev->singleBack1MainOffset[ulView] = 0;
    ppdev->singleBack1MainPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1MainOffset[ulView], (DWORD)ppdev->singleBack1MainPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleBack1MainPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc front overlay surface
    ppdev->singleFrontOverlayOffset[ulView] = 0;
    ppdev->singleFrontOverlayPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontOverlayOffset[ulView], (DWORD)ppdev->singleFrontOverlayPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleFrontOverlayPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc back overlay surface
    ppdev->singleBack1OverlayOffset[ulView] = 0;
    ppdev->singleBack1OverlayPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1OverlayOffset[ulView], (DWORD)ppdev->singleBack1OverlayPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleBack1OverlayPitch[ulView] = 0;
        goto Exit; // failure
    }


    ppdev->pfnAcquireOglMutex(ppdev);
    ppdev->NVFreeCount = 0;
    //**********************************************************************
    // We need to make absolutely sure that the Channel switch
    // from the DMA pusher to the PIO channel has been completed
    //**********************************************************************
    ppdev->pfnWaitForChannelSwitch(ppdev);

    // clear overlay front and back with default transparent color
    ppdev->pfnSetDestBase(ppdev, ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView] );
    NV4DmaPushFillSolid( ppdev, 1, &rclScreen, 0xF0F0, rbc, NULL);
    ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView] );
    NV4DmaPushFillSolid( ppdev, 1, &rclScreen, 0xF0F0, rbc, NULL);

    ppdev->pfnReleaseOglMutex(ppdev);

    iRet = TRUE;

Exit:

    return iRet;
}

//******************************************************************************
//
//  Function: OglAllocUnifiedSurfaces
//
//  Routine Description:
//            Allocate the single-back-depth buffer that is the size of the
//            display for OpenGL to use.
//            Also allocates the overlay front/back (main/overlay) surfaces
//             for OpenGL pseudo hardware overlay support.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
int
OglAllocUnifiedSurfaces(
    PDEV *ppdev,
    __GLNVsbdFlags *sbdFlags
)
{
    int iRet = FALSE;
    DWORD dwStatus;


    if (!ppdev->bOglSingleBackDepthSupported)
    {
        goto Exit;
    }

    // our intension is to allocate all buffers which may be allocated according to the exported
    // pixelformats at the FIRST time an allocation is done, to not run out of offscreen memory e.g.
    // if 1st ICD consumes a lot of it for textures and 2nd ICD wants more UBB buffers than 1st one.
    if (ppdev->bOglSingleBackDepthCreated == FALSE)
    {
        ULONG ulDesiredViews = 0;
        ULONG ulView ;

        ASSERT(FALSE==ppdev->bOglOverlaySurfacesCreated);

        bMoveAllDfbsFromOffscreenToDibs(ppdev);

        // if we export stereo pixelformat, allocate the buffer for it
        if( ppdev->bOglStereoDesired )
            ulDesiredViews = 2;
        else
            ulDesiredViews = 1;


        for( ulView = 0; ulView<ulDesiredViews; ulView++ )
        {
            DWORD depthType;

            // primary is allocated by DD, only handle other front buffers.
            if( ulView > 0 )
            {
                // allocate right front buffer
                ppdev->singleFrontOffset[ulView] = 0;
                ppdev->singleFrontPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontOffset[ulView], (DWORD)ppdev->singleFrontPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);
                if (dwStatus!=0)
                    goto Exit;  // failure
            }

            // allocate back buffer
            ppdev->singleBack1Offset[ulView] = 0;
            ppdev->singleBack1Pitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1Offset[ulView], (DWORD)ppdev->singleBack1Pitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);
            if (dwStatus!=0)
                goto Exit;  // failure

            // TODO: allocate back buffer 2 for triple buffering.

            // allocate depth buffer
            ppdev->singleDepthOffset[ulView] = 0;
            ppdev->singleDepthPitch[ulView] = ppdev->singleBack1Pitch[ulView];
            if (sbdFlags->depthCompressed) {
                switch (ppdev->cjPelSize) {
                case 2:
                    depthType = TYPE_DEPTH_COMPR16;
                    break;
                case 4:
                    depthType = TYPE_DEPTH_COMPR32;
                    break;
                default:
                    depthType = TYPE_DEPTH;
                    break;
                }
            } else {
                depthType = TYPE_DEPTH;
            }
            NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleDepthOffset[ulView], (DWORD)ppdev->singleDepthPitch[ulView], (DWORD)ppdev->cyScreen, depthType);
            if (dwStatus!=0)
                goto Exit;

            ppdev->bOglSingleBackDepthCreated = TRUE;
    
            // allocate Overlay surfaces
            if (ppdev->bOglOverlayDesired)
            {
                if(FALSE == OglAllocOverlaySurfaces(ppdev,ulView)) 
                {
                    goto Exit;
                } 
                else 
                {
                    ppdev->bOglOverlaySurfacesCreated = TRUE;
                }
            }

        }//for( ulView = 0; ulView<ulDesiredViews; ulView++ )

        ppdev->ulOglActiveViews = ulDesiredViews;

        // Try to enable pageflipping for that client
        bOglStereoModeUpdate(ppdev);
        bOglOverlayModeUpdate(ppdev);
        bOglPageFlipModeUpdate(ppdev);
    }

    iRet = TRUE;// success

Exit:

    if( FALSE == iRet )
    {
        OglFreeUnifiedSurfaces(ppdev);
    }

    return iRet; 
}

//******************************************************************************
//
//  Function: OglFreeUnifiedSurfaces
//
//  Routine Description:
//            Free a previously allocated single-back-depth buffer that is the size of the
//            display for OpenGL to use.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//  MSchwarzer  10/09/2000: now we're freeing all surfaces whose offset is not 0
//
//******************************************************************************
int
OglFreeUnifiedSurfaces(
    PDEV *ppdev
)
{
    ULONG ulView;

    // Try to enable pageflipping for that client
    bOglPageFlipModeDisableAll(ppdev);
    bOglOverlayModeDisable(ppdev);
    bOglStereoModeDisable(ppdev);

    NV_DisableDoubleBufferMode(ppdev);
    
    for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
    {
        // primary is allocated by DD, only handle other front buffers.
        if( ulView > OGL_STEREO_BUFFER_LEFT )
        {   
            if(ppdev->singleFrontOffset[ulView]) 
            {
                NVHEAP_FREE(ppdev->singleFrontOffset[ulView]);
            }
            ppdev->singleFrontOffset[ulView] = 0;
            ppdev->singleFrontPitch[ulView]  = 0;
        }

        if(ppdev->singleBack1Offset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1Offset[ulView]);
        ppdev->singleBack1Offset[ulView] = 0;
        ppdev->singleBack1Pitch[ulView]  = 0;

        if(ppdev->singleDepthOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleDepthOffset[ulView]);
        ppdev->singleDepthOffset[ulView] = 0;
        ppdev->singleDepthPitch[ulView]  = 0;

        // overlay buffers
        if(ppdev->singleFrontMainOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleFrontMainOffset[ulView]);
        ppdev->singleFrontMainOffset[ulView] = 0;
        ppdev->singleFrontMainPitch[ulView]  = 0;

        if(ppdev->singleFrontOverlayOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleFrontOverlayOffset[ulView]);
        ppdev->singleFrontOverlayOffset[ulView] = 0;
        ppdev->singleFrontOverlayPitch[ulView]  = 0;

        if(ppdev->singleBack1MainOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1MainOffset[ulView]);
        ppdev->singleBack1MainOffset[ulView] = 0;
        ppdev->singleBack1MainPitch[ulView]  = 0;

        if(ppdev->singleBack1OverlayOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1OverlayOffset[ulView]);
        ppdev->singleBack1OverlayOffset[ulView] = 0;
        ppdev->singleBack1OverlayPitch[ulView]  = 0;

    }

    ppdev->bOglSingleBackDepthCreated = FALSE;
    ppdev->bOglOverlaySurfacesCreated = FALSE;
    ppdev->ulOglActiveViews           = 0;

    return 1;
}

NvU32 
OglGetUnifiedSurfaceInfo(
    PDEV *ppdev, 
    __GLNVsbdFlags *sbdFlags
)
{
    if (ppdev->bOglSingleBackDepthSupported &&
        ppdev->bOglSingleBackDepthCreated) {
            switch (sbdFlags->surfaceInfoType) {
                case SBD_BACK_1_OFFSET:
                    return ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_PITCH:
                    return ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_DEPTH_OFFSET:
                    return ppdev->singleDepthOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_DEPTH_PITCH:
                    return ppdev->singleDepthPitch[OGL_STEREO_BUFFER_LEFT];
                
                // Overlays
                case SBD_FRONT_MAIN_OFFSET:
                    return ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_MAIN_PITCH:
                    return ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_MAIN_OFFSET:
                    return ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_MAIN_PITCH:
                    return ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_OVERLAY_OFFSET:
                    return ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_OVERLAY_PITCH:
                    return ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_OVERLAY_OFFSET:
                    return ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_OVERLAY_PITCH:
                    return ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT];

                // ogl api stereo buffers
                case SBD_FRONT_RIGHT_OFFSET:
                    return ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_RIGHT_PITCH:
                    return ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_RIGHT_OFFSET:
                    return ppdev->singleBack1Offset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_RIGHT_PITCH:
                    return ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_DEPTH_RIGHT_OFFSET:
                    return ppdev->singleDepthOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_DEPTH_RIGHT_PITCH:
                    return ppdev->singleDepthPitch[OGL_STEREO_BUFFER_RIGHT];
                
                // Overlays
                case SBD_FRONT_MAIN_RIGHT_OFFSET:
                    return ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_MAIN_RIGHT_PITCH:
                    return ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_MAIN_RIGHT_OFFSET:
                    return ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_MAIN_RIGHT_PITCH:
                    return ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_OVERLAY_RIGHT_OFFSET:
                    return ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_OVERLAY_RIGHT_PITCH:
                    return ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_OVERLAY_RIGHT_OFFSET:
                    return ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_OVERLAY_RIGHT_PITCH:
                    return ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_RIGHT];

                default:
                    ASSERTDD(0,"Invalid surface info type");
                    return FALSE;
            }
    }
    return FALSE;
}

/*
**  bExchangeClientsFrontAndBack
**
**  Swaps the contents of fullscreen front and backbuffer of
**  complete opengl client area (clipped against screen).
**  It uses a temporary buffer to do its work. 
**
**  return: TRUE  - buffers copied + flipped to primary
**          FALSE - if no buffers copied ( e.g. no UBB-mode ), not flipped to primary
**
**  10/16/2000 MSchwarzer: new
*/
BOOL bExchangeClientsFrontAndBack( PPDEV ppdev, NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo)
{
    BOOL bBufferExchanged = FALSE;

    ASSERT(ppdev);
    ASSERT(pClientDrawableInfo);


    if(  (ppdev->bOglSingleBackDepthSupported)
       &&( ppdev->bOglSingleBackDepthCreated)
      )
    {
        RECTL rclSrc;
        RECTL rclScreen;

        vRclCopy(&rclSrc,(RECTL*)(&pClientDrawableInfo->rect));

        // convert to screen relative coords
        vRclSubOffset(&rclSrc,&rclSrc,ppdev->left,ppdev->top);

        // set up primary ccordinates
        rclScreen.left   = 0;
        rclScreen.right  = ppdev->cxScreen;
        rclScreen.top    = 0;
        rclScreen.bottom = ppdev->cyScreen;

        // clip clientrect against screen and check if its a empty rect
        if(   (bRclIntersect(&rclSrc,&rclScreen,&rclSrc))
            &&(!bRclIsEmpty(&rclSrc))
           )
        {
            ULONG  ulTempBufferOffset         = 0;
            ULONG  ulTempBufferSize           = 0;
            LONG   lTempBufferStride          = 0;
            BOOL   bAllocatedTempBufferOnHeap = FALSE;
            BOOL   bCopyAtOnce                = FALSE;
            RECTL  rclClipScreen;
            RECTL  rclClipTmpBuffer;
            POINTL ptlSrcScreen;
            POINTL ptlSrcTmpBuffer;
            LONG   lRow;
            LONG   cy;
            DWORD  dwStatus;

            // 32 BYTE- align !
            lTempBufferStride = (( ppdev->cjPelSize * lRclWidth(&rclSrc) ) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

            ulTempBufferSize = lTempBufferStride * lRclHeight(&rclSrc);

            if( ulTempBufferSize > ppdev->ulTempOffscreenBufferSize )
            {
                NVHEAP_ALLOC(dwStatus, ulTempBufferOffset,  ulTempBufferSize, TYPE_IMAGE)
                if( dwStatus == 0 )
                {
                    bAllocatedTempBufferOnHeap = TRUE;
                    bCopyAtOnce                = TRUE;
                }
            }

            if(!bAllocatedTempBufferOnHeap)
            {
                ASSERT(0 != ppdev->ulTempOffscreenBufferSize);

                if( ulTempBufferSize <= ppdev->ulTempOffscreenBufferSize )
                    bCopyAtOnce = TRUE;

                ulTempBufferSize   = ppdev->ulTempOffscreenBufferSize;
                ulTempBufferOffset = ppdev->ulTempOffscreenBufferOffset;
            }

            // constant values
            ptlSrcTmpBuffer.x = 0;
            ptlSrcTmpBuffer.y = 0;

            // we may have to copy the clientrect via several blockcopies
            cy    = ulTempBufferSize / lTempBufferStride;

            ptlSrcScreen.x = rclSrc.left;
            ptlSrcScreen.y = rclSrc.top;

            rclClipScreen.left   = rclSrc.left;
            rclClipScreen.right  = rclSrc.right;
            rclClipScreen.top    = rclSrc.top;
            rclClipScreen.bottom = rclSrc.top+cy;
           
            rclClipTmpBuffer.left   = 0;
            rclClipTmpBuffer.right  = lRclWidth(&rclSrc);
            rclClipTmpBuffer.top    = 0;
            rclClipTmpBuffer.bottom = cy;

            // loop once for each block ( height/(cy+1) ) but last block
            // may not occupy full tempbuffer 
            for ( lRow=(lRclHeight(&rclSrc)+cy-1)/cy; lRow>0; lRow-- )
            {
                // copy backbuffercontents to tempbuffer
                ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
                ppdev->pfnSetDestBase(ppdev, ulTempBufferOffset, lTempBufferStride);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipTmpBuffer, 0xcccc, &ptlSrcScreen, &rclClipTmpBuffer, NULL);

                // copy frontbuffercontents to primary
                ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
                ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcScreen, &rclClipScreen, NULL);

                //flip to primary if offscreen bitmap was big enough for complete clientarea
                if( bCopyAtOnce )
                    NvRestoreDacs(ppdev);

                // copy tempbuffercontents to backbuffer
                ppdev->pfnSetSourceBase(ppdev, ulTempBufferOffset, lTempBufferStride);
                ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcTmpBuffer, &rclClipScreen, NULL);

                ptlSrcScreen.y       += cy;
                rclClipScreen.top    += cy;
                rclClipScreen.bottom += cy;                

                // next row is last row which may be smaller than others
                if(  (2==lRow)
                   &&(rclClipScreen.bottom > rclSrc.bottom)
                  )
                {
                    rclClipTmpBuffer.bottom = cy - (rclClipScreen.bottom - rclSrc.bottom);
                    rclClipScreen.bottom    = rclSrc.bottom;
                }
            }

            ppdev->pfnWaitEngineBusy(ppdev);

            if(bAllocatedTempBufferOnHeap)
                NVHEAP_FREE(ulTempBufferOffset);

            bBufferExchanged = TRUE;

            // flip to primary here if we could not copy the clientarea at once
            if (!bCopyAtOnce)
                NvRestoreDacs(ppdev);
        }

    }

    return bBufferExchanged;
}


//*************************************************************************
// vOglFlipChangedUpdate
// 
// Run through client list and set notification that primary flipped. 
// This is done for all clients except the given one.
// The exclusion can be used to update all clients that this one has 
// flipped.
//*************************************************************************
VOID vOglFlipChangedUpdate(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo) // exclude this client from update, can be NULL
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
    {
        if (   (NULL != node->clientInfo.clientDrawableInfo)
            && (&node->clientInfo != clientInfo) )
        {
            ASSERT(node->clientInfo.flags & NV_OGL_CLIENT_DRAWABLE_INFO);
            // flipping address has changed, notify ICD
            node->clientInfo.clientDrawableInfo->flipChangedCount++;
            // the client stopped with flipping now
            node->clientInfo.clientDrawableInfo->bFlipping = FALSE;
            break;
        }
        node = node->next;
    }
}


/*
**  vFlipToPrimary
**
**  Swaps the contents of fullscreen front and backbuffer
**  if there are any visible opengl windows and sets the 
**  dac to the primary
**
**  10/17/2000 MSchwarzer: new
**  01/16/2001           : function does a fullscreen swap now
*/
VOID vFlipToPrimary(PPDEV ppdev)
{
    BOOL bFlippedToPrimary = FALSE;

    ASSERT(ppdev);
    ASSERT(OGL_FLIPPED());

    DISPDBG((3, "vFlipToPrimary"));
    
    OglSyncEngineUsingPDEV(ppdev);

    if(  ( ppdev->bOglSingleBackDepthSupported )
       &&( ppdev->bOglSingleBackDepthCreated )
      )
    {
        ULONG  ulTempBufferOffset         = 0;
        ULONG  ulTempBufferSize           = 0;
        BOOL   bCopyAtOnce                = FALSE;
        BOOL   bAllocatedTempBufferOnHeap = FALSE;
        RECTL  rclClipScreen;
        RECTL  rclClipTmpBuffer;
        POINTL ptlSrcScreen;
        POINTL ptlSrcTmpBuffer;
        LONG   lRow;
        LONG   cy;
        DWORD  dwStatus;

        DISPDBG((3, "vFlipToPrimary: exchange buffers"));

        // try to get a full screensize temporary buffer
        ulTempBufferSize  = ppdev->lDelta * ppdev->cyScreen;

        if( ulTempBufferSize > ppdev->ulTempOffscreenBufferSize )
        {
            NVHEAP_ALLOC(dwStatus, ulTempBufferOffset,  ulTempBufferSize, TYPE_IMAGE)
            if( 0 == dwStatus ) // success
            {
                bAllocatedTempBufferOnHeap = TRUE;
                bCopyAtOnce                = TRUE;
            }
        }

        if(!bAllocatedTempBufferOnHeap)
        {
            // not enough room in offscreen to copy at once => copy line by line
            ASSERT(0 != ppdev->ulTempOffscreenBufferSize);
            if( 0 == ppdev->ulTempOffscreenBufferSize )
                goto Exit;

            if( ulTempBufferSize <= ppdev->ulTempOffscreenBufferSize )
                bCopyAtOnce = TRUE;

            ulTempBufferSize   = ppdev->ulTempOffscreenBufferSize;
            ulTempBufferOffset = ppdev->ulTempOffscreenBufferOffset;
        }

        // constant values
        ptlSrcTmpBuffer.x = 0;
        ptlSrcTmpBuffer.y = 0;

        // we may have to copy the clientrect via several blockcopies
        cy    = ulTempBufferSize / ppdev->lDelta;

        ptlSrcScreen.x = 0;
        ptlSrcScreen.y = 0;

        rclClipScreen.left   = 0;
        rclClipScreen.right  = ppdev->cxScreen;
        rclClipScreen.top    = 0;
        rclClipScreen.bottom = cy;
       
        rclClipTmpBuffer     = rclClipScreen;

        // loop once for each block ( height/(cy+1) ) but last block
        // may not occupy full tempbuffer 
        for ( lRow=(ppdev->cyScreen+cy-1)/cy; lRow>0; lRow-- )
        {
            // copy backbuffercontents to tempbuffer
            ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ulTempBufferOffset, ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipTmpBuffer, 0xcccc, &ptlSrcScreen, &rclClipTmpBuffer, NULL);

            // copy frontbuffercontents to primary
            ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcScreen, &rclClipScreen, NULL);

            //flip to primary if offscreen bitmap was big enough for complete clientarea
            if( bCopyAtOnce )
            {
                NvRestoreDacs(ppdev);
                bFlippedToPrimary = TRUE;
            }

            // copy tempbuffercontents to backbuffer
            ppdev->pfnSetSourceBase(ppdev, ulTempBufferOffset, ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcTmpBuffer, &rclClipScreen, NULL);

            ptlSrcScreen.y       += cy;
            rclClipScreen.top    += cy;
            rclClipScreen.bottom += cy;                

            // next row is last row which may be smaller than others
            if(  (2==lRow)
               &&(rclClipScreen.bottom > ppdev->cyScreen)
              )
            {
                rclClipTmpBuffer.bottom = cy - (rclClipScreen.bottom - ppdev->cyScreen);
                rclClipScreen.bottom    = ppdev->cyScreen;
            }
        }

        ppdev->pfnWaitEngineBusy(ppdev);

        if(bAllocatedTempBufferOnHeap)
            NVHEAP_FREE(ulTempBufferOffset);
    }

Exit:

    if( !bFlippedToPrimary )
    {
        // Restore if necessary!
        NvRestoreDacs(ppdev);
    }

    vOglFlipChangedUpdate(ppdev, NULL);

    ASSERT(!OGL_FLIPPED());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsync.c ===
//******************************Module*Header***********************************
// Module Name: oglsync.c
//
// syncing routines GDI against ogl, and ogl against ogl
//
// Copyright (c) 2001, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "nvReg.h"
#include "nvcm.h"
#include "oglDD.h"
#include "oglclip.h"
#include "oglflip.h"
#include "oglutils.h"

#include "oglsync.h"

/*
** Problem GDI sync:
** Only want to sync if two channels, here GDI and OpenGL render to the same 
** window (rectangle). As we have cliplists for all OpenGL clients, we are able 
** to track if GDI is going to render to an OpenGL client window. If so we sync
** on the GDI entry and set a flag to sync again on the next OpenGL entry.
**
** Affected functions (all GDI driver entries that render) and code used to 
** quickly determine rclBounds:
**
** + DrvBitBlit (1)
**      uses bOglSyncIfGdiInOglWindowBlt
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvCopyBits (1)
**      uses bOglSyncIfGdiInOglWindowBlt
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvStretchBlt (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      // can do inversions of x and y when the destination rectangle is not well ordered.
**      prclRectOrder(&rclDstOrdered, prcl);    // creates an ordered rect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclDstOrdered : pco->rclBounds;
**
** + DrvTextOut            
**      uses bOglSyncIfGdiInOglWindowRect
**      if (prclOpaque) 
**        rclBounds = (DC_TRIVIAL==iDComplexity) ? *prclOpaque : pco->rclBounds;
**      else
**        rclBounds = (DC_TRIVIAL==iDComplexity) ? pstro->rclBkGround : pco->rclBounds;
**
** + DrvLineTo             
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prclBounds : pco->rclBounds;
**
** + DrvStrokePath         
**      uses bOglSyncIfGdiInOglWindowPath
**      PATHOBJ_vGetBounds(ppo, &rcfxBounds);
**      rclTrg.left   = rcfxBounds.xLeft>>4;        // round down
**      rclTrg.top    = rcfxBounds.yTop>>4;
**      rclTrg.right  = (rcfxBounds.xRight+15)>>4;  // round up
**      rclTrg.bottom = (rcfxBounds.yBottom+15)>>4;
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclTrg : pco->rclBounds;
** 
** + DrvFillPath           
**      uses bOglSyncIfGdiInOglWindowPath
**      PATHOBJ_vGetBounds(ppo, &rcfxBounds);
**      rclTrg.left   = rcfxBounds.xLeft>>4;        // round down
**      rclTrg.top    = rcfxBounds.yTop>>4;
**      rclTrg.right  = (rcfxBounds.xRight+15)>>4;  // round up
**      rclTrg.bottom = (rcfxBounds.yBottom+15)>>4;
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclTrg : pco->rclBounds;
** 
** + DrvPaint              
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclDstOrdered : pco->rclBounds;
** 
** + DrvAlphaBlend (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvTransparentBlt (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvSaveScreenBits
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = *prcl;
**
** - DrvMovePointer        
** - DrvSetPointerShape    
**      left it out for now, if through DAC then I don't care, 
**      otherwise it should come in through copybits again
**
** + DrvEscape
**      calls bOglSyncOglIfGdiRenderedToWindow
**      no render rect (OPENGL_CMD escape needs to track old GDI rendering and sync)
**             
** + DrvSwapBuffers        
**      calls bOglSyncOglIfGdiRenderedToWindow
**      needs to track old GDI rendering and sync
**
** (1) prcl is prclSrc or prclTrg, depending on src/dst pso
**
*/


#if DBG
// global variable to disable smart syncing
BOOL bOglSyncGdiVsOglDisabled = FALSE;
BOOL bOglFillSyncedGdi        = FALSE;
BOOL bOglFillSyncedOgl        = FALSE;

#define OGLSYNC_FILL_GDI(ppdev,prcl)                                                     \
    if (bOglFillSyncedGdi && bRet)                                                       \
    {                                                                                    \
        RBRUSH_COLOR rbc = {0};                                                          \
        rbc.iSolidColor = 0xff;                                                          \
        ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);      \
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, prcl, 0xF0F0, rbc, NULL);  \
        ppdev->pfnWaitEngineBusy(ppdev);                                                 \
    }
#define OGLSYNC_FILL_OGL(ppdev,prcl)                                                     \
    if (bOglFillSyncedOgl && bRet)                                                       \
    {                                                                                    \
        RBRUSH_COLOR rbc = {0};                                                          \
        rbc.iSolidColor = 0xff00;                                                        \
        ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);      \
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, prcl, 0xF0F0, rbc, NULL);  \
        ppdev->pfnWaitEngineBusy(ppdev);                                                 \
    }
#else
    #define OGLSYNC_FILL_GDI(ppdev,prcl)
    #define OGLSYNC_FILL_OGL(ppdev,prcl)
#endif


/*
 * FUNCTION: OglSyncEngineUsingPDEV
 *
 * DESC: Using the given PDEV, sync/engine-stall GDI and OGL Rendering Channels.
 */
void OglSyncEngineUsingPDEV(PDEV *ppdev)
{
    ASSERT(ppdev->bEnabled);

    ppdev->pfnAcquireOglMutex(ppdev);

    DISPDBG((4, "OglSyncEngineUsingPDEV"));

    // wait for GDI to finish
//    ppdev->pfnWaitEngineBusy(ppdev);

    // force a sync/engine-stall with GDI channel
    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
    ppdev->pfnWaitEngineBusy(ppdev);

    // force a sync/engine-stall with all OGL rendering channels
    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
    ppdev->NVFreeCount = 0;
    ppdev->pfnWaitForChannelSwitch(ppdev);

    ppdev->pfnReleaseOglMutex(ppdev);
}

#ifdef DISABLE_OGLSYNC
#pragma message("  FNicklisch 21.05.2001: WARNING: OglSync against GDI is disabled!")
#else

//*************************************************************************
// bOglSyncOglIfGdiRenderedToWindow
// 
// Syncs all channels if we recognized a gdi command that rendered into the
// OpenGL window. Now we need to sync again, as we need to be sure GDI is 
// finished before we continue with OpenGL.
//*************************************************************************
BOOL bOglSyncOglIfGdiRenderedToWindow(
    IN PPDEV ppdev)
{
    BOOL bRet; 

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    bRet = ppdev->pOglServer->bGdiInOglWindowNeedsSync;

    if (bRet && ppdev->bEnabled)
    {
        OglSyncEngineUsingPDEV(ppdev);

        ppdev->pOglServer->bGdiInOglWindowNeedsSync = FALSE;
    }

    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowRect
// 
// Syncs all channels if rcl and pco describe a drawing region that is 
// within any visible OpenGL client. Either prclTrg or pco can be NULL but
// not both at the same time! pso can be NULL!
// 
// Return: TRUE  - sync happend, intersection with OpenGL
//         FALSE - nothing donde, no intersection with OpenGL
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowRect(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to prclBounds
    IN RECTL   *prclTrg,    // destination rectangle of drawing surface
    IN CLIPOBJ *pco)        // clip obj for destination
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients

    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;

    ASSERT(NULL != ppdev);

#if DBG
    // debug code can disable fix
    if (bOglSyncGdiVsOglDisabled)
        goto Exit;
#endif

    //
    // Need a enabled hardware and only work on Quadro!
    //
    if (!ppdev->bEnabled)
    {
        // need valid ppdev
        goto Exit;
    }

    //
    // KEY: disable fix code for GeForce!
    //      Only QUADRO will handle sync OGL vs GDI!
    //
    if (!HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // need supported board
        goto Exit;
    }

    //
    // Need a valid surface
    //
    if (   (NULL == pso)
        || !IS_SCREEN(pso) )
    {
        // not rendering to front, no need to sync
        // NOTE: GDI can only render to front (whereever it is)!
        goto Exit;
    }

    //
    // Calculate final rclBounds for rendering on primary surface
    //    
    if (NULL != pco)
    {
        if (   (DC_TRIVIAL != pco->iDComplexity)
            || (NULL == prclTrg) )
        {
            prclTrg = &pco->rclBounds;
        }
    }

    ASSERTDD(NULL != prclTrg, "bOglSyncIfGdiInOglWindowRect either needs pco or prclTrg, use it correctly!");

    // fast out if no intersection with all clients bounding rect
    if (!bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, prclTrg))
    {
        goto Exit;
    }


    // find first visible ogl client 
    // and initialize clientInfo with pointer to it
    if (!bOglGetNextVisibleClient(&clientInfo))
    {
        // no visible OpenGL client, no need to sync
        goto Exit;
    }

    //
    // Enumerate clients and clip against rclBounds
    //
    do
    {
        ASSERT(NULL != clientInfo); // we enter this loop with a valid client!

        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERT(NULL != clientDrawableInfo);

        //
        // check if bounding rects of client and gdi are intersecting
        //
        if (bRclIntersect(NULL, (RECTL *)&clientDrawableInfo->rect, prclTrg))
        {
            ULONG ulRect;

            //
            // This potentially is a critical GDI call. Verify that it is inside 
            // one of the ogl clipping rects.
            //

            // Loop over clients clip list 
            for (ulRect=0; !bRet && (ulRect < clientDrawableInfo->numClipRects); ulRect++)
            {
                // if we have a proper pco 
                // clip each client rect against all clipobj rects

                if (   (NULL != pco)
                    && (DC_TRIVIAL != pco->iDComplexity) )
                {
                    bRet = bOglClipRectAgainstClipobj(pco, (RECTL *)&clientDrawableInfo->copyWindowRect[ulRect]);
                }
                else
                {
                    bRet = bRclIntersect(NULL, (RECTL *)&clientDrawableInfo->copyWindowRect[ulRect], prclTrg);
                }
                OGLSYNC_FILL_OGL(ppdev,(RECTL *)&clientDrawableInfo->copyWindowRect[ulRect]);
                OGLSYNC_FILL_GDI(ppdev,prclTrg);
            }
        }
    } 
    while (!bRet && bOglGetNextVisibleClient(&clientInfo));

    //
    // Handle the sync if needed
    //
    if (bRet)
    {
        ASSERT(NULL != ppdev->pOglServer);
        DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: need sync"));
        // we now know that GDI is rendering from/to an OpenGL window
        // Sync everything, to get a stable base for GDI
        OglSyncEngineUsingPDEV(ppdev);

        //
        // As double pumping to within a Ogl's backbuffer potentially 
        // destroyes its content, we cannot allow this. Unfortunately
        // our double pumping cannot handle this. Therefore we need to
        // disable pageflipping (and with that double pumping) now.
        //

        if (   ppdev->pOglServer->bWindowInMovement
            || (   !bRclIsEqual(prclTrg, (RECTL *)&clientDrawableInfo->rect) // not client size
                && bRclIsIn (prclTrg, (RECTL *)&clientDrawableInfo->rect) )) // bounds is bigger than client
        {
            // this is a GDI that starts outside the window, although we sync
            // we don't disable page flipping as it possibly is a copy of the entire window!
            DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: GDI bounding ogl: copy on window move?"));
        }
        else
        {
            DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: GDI inside ogl: disable pf"));
            // Because of our double pumping code, we cannot pageflip GDI to OpenGL back!
            if (0 != cOglFlippingClients(ppdev))
            {
                bOglPageFlipModeDisableAll(ppdev);

                // try again later: Take any random number, I use refresh rate for now, but
                // could calculate a number depending on window size vs desktop size
                ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_RETRY_COUNTER_START;
            }
        }

        ppdev->pOglServer->bGdiInOglWindowNeedsSync = TRUE;
    }

Exit:
    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowPath
// 
// Syncs all channels if rcl and pco describe a drawing region that is 
// within any visible OpenGL client. pco can be NULL.
// 
// Return: TRUE  - sync happend, intersection with OpenGL
//         FALSE - nothing donde, no intersection with OpenGL
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowPath(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to object
    IN PATHOBJ *ppo,        // pathobject to be rendered on pso
    IN CLIPOBJ *pco)        // clip obj for destination
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients
    RECTFX   rcfxBounds;
    RECTL    rclTrg;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppo);
    ASSERT(NULL != ppdev->pOglServer);

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);
    rclTrg.left   = rcfxBounds.xLeft >> 4;        // round down
    rclTrg.top    = rcfxBounds.yTop  >> 4;
    rclTrg.right  = (rcfxBounds.xRight+15)  >> 4;  // round up
    rclTrg.bottom = (rcfxBounds.yBottom+15) >> 4;

    // fast out if no intersection with all clients bounding rect
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclTrg))
    {
        bRet = bOglSyncIfGdiInOglWindowRect(
            ppdev,
            pso,        // surface belonging to prclBounds
            &rclTrg,    // destination rectangle of drawing surface
            pco);       // clip obj for destination
    }

    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowBlt
// 
// Simple wrawpper for bOglSyncIfGdiInOglWindowRect to be called from a 
// blt function that uses source point and target rect as blt functions.
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowBlt(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN POINTL  *pptlSrc)    // source point
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    // fast out if no intersection with all clients bounding rect
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, prclDst))
    {
        // try destination first
        bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoDst, prclDst, pco);
    }

    if (   !bRet
        && (NULL != psoSrc)
        && (NULL != pptlSrc) )
    {
        RECTL rclSrc;

        rclSrc.left   = pptlSrc->x;
        rclSrc.right  = pptlSrc->x + lRclWidth(prclDst);
        rclSrc.top    = pptlSrc->y;
        rclSrc.bottom = pptlSrc->y + lRclHeight(prclDst);

        if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclSrc))
        {
            // Now source, but cannot use destination pco
            bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoSrc, &rclSrc, NULL);
        }
    }
    ppdev->pOglServer->bWindowInMovement = FALSE;

    return (bRet);
}



//*************************************************************************
// bOglSyncIfGdiInOglWindowStretch
// 
// Simple wrawpper for bOglSyncIfGdiInOglWindowRect to be called from a 
// blt function that uses source and target rects as stretch functions.
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowStretch(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN RECTL   *prclSrc)    // source point
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients
    RECTL    rclOrdered;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    // try destination first
    prclRclOrder(&rclOrdered, prclDst);
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclOrdered))
    {
        bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoDst, &rclOrdered, pco);
    }

    if (   !bRet
        && (NULL != psoSrc)
        && (NULL != prclSrc) )
    {
        // Now source, but cannot use destination pco
        prclRclOrder(&rclOrdered, prclSrc);
        if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclOrdered))
        {
            bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoSrc, &rclOrdered, NULL);
        }
    }

    return (bRet);
}
#endif // DISABLE_OGLSYNC
// End of oglsync.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogloverlay.c ===
/******************************Module*Header*******************************\
* Module Name: ogloverlay.c
*
* OpenGL Overlay plane implementation
*
* Copyright (c) 2000 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvReg.h"
#include "nvcm.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "nvdoublebuf.h"
#include "nvcom.h"

extern VOID NV4_DmaPushSend(PDEV *);

//
// Export 
//
#include "ogloverlay.h"


void OglInitLayerPalette(void)
{
    globalOpenGLData.oglLayerPaletteListHead.paletteList = NULL;
    globalOpenGLData.oglLayerPaletteClientCount = 0;
}

/*
** bOglFindGlobalLayerPaletteHWND
** 
** Find LayerPalette entry to given HWND in global linked list.
**
** return: TRUE  - entry found: *ppLayerPalette contains pointer to palette entry
**         FALSE - not found: *ppLayerPalette not valid!
** 
** FNicklisch 28.09.2000: New
*/ 
BOOL bOglFindGlobalLayerPaletteHWND(
    IN  HWND hWnd, 
    OUT NV_LAYER_PALETTE **ppLayerPalette)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;

    while (pLayerPalette && pLayerPalette->windowHandle != hWnd)
    {
        pLayerPalette = pLayerPalette->next;
    }

    *ppLayerPalette = pLayerPalette;

    return (pLayerPalette != NULL);
}


//*************************************************************************
// OglSetLayerPalette
// 
// Create a display driver managed overlay palette for the given window and
// store the user palette to it. If the palette already exists, reuse it.
// Called by ICD through escape to set an overlay palette.
//*************************************************************************
BOOL OglSetLayerPalette(__GLNVpaletteData *pSourcePalette)
{
    NV_LAYER_PALETTE *pLayerPalette;
    ULONG ulIndex;

    ASSERTDD(NULL!=pSourcePalette, "pSourcePalette missing!");

    if (!bOglFindGlobalLayerPaletteHWND(pSourcePalette->windowHandle, &pLayerPalette))
    {
        // Need to create new entry
        pLayerPalette = EngAllocMem(FL_ZERO_MEMORY, sizeof(NV_LAYER_PALETTE), ALLOC_TAG);

        if (NULL != pLayerPalette)
        {
            pLayerPalette->next = globalOpenGLData.oglLayerPaletteListHead.paletteList;
            globalOpenGLData.oglLayerPaletteListHead.paletteList = pLayerPalette;
            globalOpenGLData.oglLayerPaletteClientCount++;
        }
        else
        {
            ASSERTDD(NULL!=pLayerPalette, "failed to allocate palette entry!");
            return FALSE;
        }
    }

    pLayerPalette->windowHandle  = pSourcePalette->windowHandle;
    pLayerPalette->crTransparent = pSourcePalette->crTransparent;
    for (ulIndex = 0; ulIndex < ICD_PALETTE_ENTRIES; ulIndex++)
    {
        pLayerPalette->entries[ulIndex] = pSourcePalette->entries[ulIndex];
    }

    return TRUE;
}   


//*************************************************************************
// OglGetLayerPalette
// 
// return the display driver managed overlay palette to a given window. 
// If the palette doesn't exist, create a default palette.
// Called by ICD through escape to retrieve an overlay palette.
//*************************************************************************
BOOL OglGetLayerPalette(__GLNVpaletteData *pDestPalette)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;
    ULONG ulIndex;
    BOOL bRet=FALSE;

    ASSERTDD(NULL!=pDestPalette, "OglGetLayerPalette: pDestPalette missing!");

    if (!bOglFindGlobalLayerPaletteHWND(pDestPalette->windowHandle, &pLayerPalette))
    {
        // Palette data not found!
        // Initialize input data and call OglSetLayerPalette to create a new global entry.

        // set all to white aka ff
        pDestPalette->crTransparent = ICD_PALETTE_TRANSPARENT_INDEX;
        pDestPalette->entries[0]    = ICD_PALETTE_TRANSPARENT_COLOR;
        //pDestPalette->entries[pDestPalette->crTransparent] = RGB(0, 0, 0); // black
        for (ulIndex = 1; ulIndex<256; ulIndex++)
        {                     //  red   green blue
          pDestPalette->entries[ulIndex] = RGB(0xff, 0xff, 0xff);            // white
        }

        bRet = OglSetLayerPalette(pDestPalette);
    }
    else
    {
        // found existing entry, return that
        pDestPalette->windowHandle    = pLayerPalette->windowHandle;
        pDestPalette->crTransparent   = pLayerPalette->crTransparent;
        for (ulIndex = 0; ulIndex < ICD_PALETTE_ENTRIES; ulIndex++)
        {
            pDestPalette->entries[ulIndex] = pLayerPalette->entries[ulIndex];
        }
        bRet = TRUE;
    }

    ASSERTDD(bRet, "Don't assume OglGetLayerPalette to fail!");
    return bRet;
}


//*************************************************************************
// OglDestroyLayerPalette
// 
// Free the display driver managed overlay palette of the given window.
//*************************************************************************
BOOL OglDestroyLayerPalette(HWND hWnd)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;

    if (bOglFindGlobalLayerPaletteHWND(hWnd, &pLayerPalette))
    {
        if (pLayerPalette == globalOpenGLData.oglLayerPaletteListHead.paletteList)
        {
            globalOpenGLData.oglLayerPaletteListHead.paletteList = pLayerPalette->next;
        }
        else
        {
            NV_LAYER_PALETTE *pPredecessor = globalOpenGLData.oglLayerPaletteListHead.paletteList;

            while (pPredecessor->next != pLayerPalette)
            {
                pPredecessor = pPredecessor->next;
            }
            ASSERTDD(NULL != pPredecessor,"OglDestroyLayerPalette: paletteList invalid !");

            pPredecessor->next = pLayerPalette->next;
        }

        EngFreeMem(pLayerPalette);

        return TRUE;
    }

    return FALSE;
}


/*
** bClearOverlayForClient
**
** Clears the delta area of clipped clientrect on overlay buffers ( newly entered areas )
** ( front for singlebuffered, front + back otherwise )
**
** Return value: FALSE: nothing done
**               TRUE:  if a clear happend
**
** MSchwarz  09/26/2000: derived from ELSA's old code
**           11/14/2000: redesigned interface: now an additional hWnd is possible for identifying client
*/
BOOL bClearOverlayForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd, BOOL bClearFrontBuffer, BOOL bClearBackBuffer)
{
    BOOL                     bRet               = FALSE;
    HWND                     hWndTemp           = NULL;
    NV_LAYER_PALETTE        *pLayerPalette      = NULL;
    NV_OPENGL_CLIENT_INFO   *pClientInfo        = NULL;
    RBRUSH_COLOR             rbc                = {0};    // solid colour brush

    ASSERT(NULL != pwo);
    ASSERT(NULL != ppdev);

    //
    // Whatever we do here it is only neccessary if 
    // overlays are enabled
    //
    if (ppdev->bOglOverlaySurfacesCreated)
    {
        BOOL bMore;

        if(pwo->pvConsumer)
        {
            pClientInfo = (NV_OPENGL_CLIENT_INFO*)pwo->pvConsumer;
            ASSERT(OglFindClientListFromClientInfo(ppdev, pClientInfo));
            bGetOglClientInfoHWnd( pClientInfo, &hWndTemp );
        }
        else
        {
            hWndTemp = hWnd;
        }

        if(hWndTemp)
        {
            //
            // For overlay apps take transparent color from palette 
            // for non overlay apps take default transparent color:
            //
            ULONG ulTransparentColor = ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000;

            if(bOglFindGlobalLayerPaletteHWND( hWndTemp, &pLayerPalette))
            {
                ASSERT( NULL!=pLayerPalette );
                ASSERT( pLayerPalette->crTransparent < ICD_PALETTE_ENTRIES);
                // if hWnd owns a Palette, it belongs to an overlay client.
                // get the transparent value as solid clearcolor
                ulTransparentColor = pLayerPalette->entries[pLayerPalette->crTransparent];
            }

            bRet = bClearOverlayArea(ppdev, pwo,ulTransparentColor, bClearFrontBuffer, bClearBackBuffer);
        }
    }

    return bRet;
}



/*
** bClearOverlayArea
**
** Clears the area described by a WNDOBJ in overlayfront
** and overlayback ubb-buffers with default transparent 
** color.
**
** Return value: FALSE: nothing done
**               TRUE:  if a clear happend
**
** MSchwarz  11/28/2000: new
*/
BOOL bClearOverlayArea(PPDEV ppdev, WNDOBJ *pwo, ULONG ulTransparentColor, BOOL bClearFrontBuffer, BOOL bClearBackBuffer)
{
    BOOL          bRet = FALSE;
    RBRUSH_COLOR  rbc  = {0};    // solid colour brush

    ASSERT(NULL != pwo);
    ASSERT(NULL != ppdev);

    //
    // Whatever we do here it is only neccessary if 
    // overlays are enabled
    //
    if(   (ppdev->bOglOverlaySurfacesCreated)
        &&(  (bClearFrontBuffer) 
           ||(bClearBackBuffer)
          )
      )
    {
        BOOL bMore;

        rbc.iSolidColor = ulTransparentColor;

        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->NVFreeCount = 0;
        //**********************************************************************
        // We need to make absolutely sure that the Channel switch
        // from the DMA pusher to the PIO channel has been completed
        //**********************************************************************
        ppdev->pfnWaitForChannelSwitch(ppdev);

        if(bClearBackBuffer)
        {
            // clear delta region on overlay front and back
            ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                if (ce.c) // can be 0
                { //Clear the Buffer

                    NV4DmaPushFillSolid( ppdev,
                                          ce.c,
                                          ce.arcl,          // List of rectangles to be filled
                                          0xF0F0,           // PATCOPY
                                          rbc,              // rbc.prb points to brush realization structure
                                          NULL);            // Pattern alignment
                }
            }
            while (bMore) ;
        }

        if(bClearFrontBuffer)
        {
            ppdev->pfnSetDestBase(ppdev, ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                if (ce.c) // can be 0
                { //Clear the Buffer

                    NV4DmaPushFillSolid( ppdev,
                                          ce.c,
                                          ce.arcl,          // List of rectangles to be filled
                                          0xF0F0,           // PATCOPY
                                          rbc,              // rbc.prb points to brush realization structure
                                          NULL);            // Pattern alignment
                }
            }
            while (bMore) ;
        }

        // set back offset and pitch of 1st frontbuffer
        ppdev->pfnSetDestBase(ppdev, 0 , ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT] );

        ppdev->pfnReleaseOglMutex(ppdev);

        bRet = TRUE;
    }

    return bRet;
}

/*
** bCopyMainPlaneFrontToPrimaryForClient
**
** Copies the MainPlaneFront to Primary of delta area of clipped clientrect 
** on overlay buffers ( areas we leave next )
** We need this to get rid of the overlay contents in Primary before primary
** area is saved away by 2D commands
** 
** Return value: FALSE: if no OverlayClient
**               TRUE:  otherwise
**
** MSchwarz 09/27/2000: new
*/
BOOL bCopyMainPlaneFrontToPrimaryForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd)
{
    BOOL                     bRet               = FALSE;
    NV_LAYER_PALETTE         LayerPalette;
    NV_LAYER_PALETTE        *pLayerPalette;
    NV_OPENGL_CLIENT_INFO   *pClientInfo         = NULL;

    ASSERTDD(NULL != pwo,"");
    ASSERTDD(NULL != ppdev,"");

    pLayerPalette       = &LayerPalette;

    if( 0 != hWnd )
    {

        // if hWnd owns a Palette, it belongs to an overlay client.
        if(bOglFindGlobalLayerPaletteHWND( hWnd, &pLayerPalette) )
        {
            BOOL bMore;

            ppdev->pfnAcquireOglMutex(ppdev);
            ppdev->NVFreeCount = 0;
            //**********************************************************************
            // We need to make absolutely sure that the Channel switch
            // from the DMA pusher to the PIO channel has been completed
            //**********************************************************************
            ppdev->pfnWaitForChannelSwitch(ppdev);

            ppdev->pfnSetSourceBase(ppdev, ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT] );
            ppdev->pfnSetDestBase(ppdev, 0 , ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                POINTL      ptl;
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                ptl.x = pwo->rclClient.left;
                ptl.y = pwo->rclClient.top;

                if (ce.c) // can be 0
                { //copy mainplane front to primary

                    NV4DmaPushCopyBlt( ppdev,
                                       ce.c,
                                       ce.arcl,          // List of rectangles to be filled
                                       0xCCCC,           // SrcCopy !!
                                       &ptl,             // Src Ptl 
                                       &pwo->rclClient,   // Dst Ptl
                                       NULL);            // no BlendObj 

                }
            }
            while (bMore) ;

            ppdev->pfnReleaseOglMutex(ppdev);

            bRet = TRUE;

        }// if(bOglFindGlobalLayerPaletteHWND( pClientContextInfo->hWnd, &pLayerPalette)
        else
        {
            DISPDBG((2,"bCopyMainPlaneFrontToPrimaryForClient: Client is no OverlayClient"));
        }

    }//if( 0 != hWnd )

    return bRet;
}



BOOL bIsOverlayClient( PPDEV ppdev, NV_OPENGL_CLIENT_INFO *pClientInfo )
{
    BOOL bIsOverlayClient = FALSE;

    ASSERT(ppdev);

#if DEBUG
    if( OglFindClientListFromClientInfo(ppdev,pClientInfo) )
#else
    if(pClientInfo)
#endif //#if DEBUG
    {
        HWND hWnd;

        if( bGetOglClientInfoHWnd( pClientInfo, &hWnd ) )
        {
            if( 0 != hWnd )
            {
                NV_LAYER_PALETTE *pLayerPalette;
                // if hWnd owns a Palette, it belongs to an overlay client.
                if(bOglFindGlobalLayerPaletteHWND( hWnd, &pLayerPalette) )
                {
                    bIsOverlayClient = TRUE;
                }
            }
        }
    }

    return bIsOverlayClient; 
}


/*
** bCopyIntersectingMainPlaneFrontToPSO
**
** Copies the MainPlaneFront of any intersecting parts of any overlaywindow 
** to destination Surface
** psoDst should point to a surface where the area of a upcoming popup window
** have been saved for later restauration purposes. For Overlay windows we saved
** the Primary including overlays, but we have to extract the overlay part.
** So copy areas of Mainplanbefront over the psoDst.
** 
** Return value: FALSE: if no intersection found
**               TRUE:  if 1 or more intersections found
**
** MSchwarz 10/04/2000: new
*/
BOOL bCopyIntersectingMainPlaneFrontToPSO(PPDEV  ppdev, SURFOBJ *psoSrc, SURFOBJ *psoDst, RECTL* prclDst, POINTL* pptlSrc)
{
    BOOL                        bInterSectionFound  = FALSE;
    BOOL                        bScreenToScreenBlt  = FALSE;
    RECTL                       rclSrc;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    NV_OPENGL_CLIENT_INFO      *pClientInfo         = NULL;

    ASSERT(ppdev);
    ASSERT(psoDst);
    ASSERT(STYPE_DEVICE != psoDst->iType);
    ASSERT(prclDst);
    ASSERT(pptlSrc);

    // calculate src rectangle
    rclSrc.left   = pptlSrc->x;
    rclSrc.right  = rclSrc.left + prclDst->right  - prclDst->left;
    rclSrc.top    = pptlSrc->y;
    rclSrc.bottom = rclSrc.top  + prclDst->bottom - prclDst->top;

    // do we do a Screen to Mem Blt or a Screen to Screen Blt ?
    if(   (psoDst->dhsurf)
        &&(DT_SCREEN == ((DSURF*)psoDst->dhsurf)->dt )
      )
    {
        bScreenToScreenBlt = TRUE;
    }

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    while( pClientInfoList )
    {
        pClientInfo = &pClientInfoList->clientInfo;

        if ( bIsOverlayClient(ppdev, pClientInfo) )
        {
            RECTL   rclIntersectSrc;
            RECTL   rclIntersectDst;
            RECTL  *prcl             = NULL;
            POINTL  ptlIntersectSrc;
            ULONG   cRect            = 0;
            NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo = pClientInfo->clientDrawableInfo;
            // find intersection with prclDst and copy contents of intersected mainplanefront
            // to prclDst
            if( pClientDrawableInfo->ubbWindowClipFlag )
            {
                cRect = 1;
                prcl = (RECTL*)(&pClientDrawableInfo->rect);
            }
            else
            {
                cRect = pClientDrawableInfo->numClipRects;
                prcl = pClientDrawableInfo->windowRect;
            }

            while( cRect )
            {
                if( bIntersect( &rclSrc, prcl, &rclIntersectSrc) )
                {
                    // calculate intersected pptlSrc / prclDst
                    rclIntersectDst.left   = prclDst->left + ( rclIntersectSrc.left   - pptlSrc->x );
                    rclIntersectDst.right  = prclDst->left + ( rclIntersectSrc.right  - pptlSrc->x );
                    rclIntersectDst.top    = prclDst->top  + ( rclIntersectSrc.top    - pptlSrc->y );
                    rclIntersectDst.bottom = prclDst->top  + ( rclIntersectSrc.bottom - pptlSrc->y );

                    ptlIntersectSrc.x = pptlSrc->x + ( rclIntersectDst.left - prclDst->left );
                    ptlIntersectSrc.y = pptlSrc->y + ( rclIntersectDst.top  - prclDst->top  );

                    // here we have to decide if we use a Screen to Mem or Screen to Screen Blt
                    if( bScreenToScreenBlt )
                    {
                        if( !bInterSectionFound )
                        {
                            (ppdev->pfnSetSourceBase)(ppdev,ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT],ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT]);
                            (ppdev->pfnSetDestBase)(ppdev,
                                                    (ULONG)((BYTE *)(((DSURF*)psoDst->dhsurf)->LinearPtr) - ppdev->pjScreen),
                                                    ((DSURF*)psoDst->dhsurf)->LinearStride);
                        }
                        //copy intersection with mainplanefront to prclDst;
                        NV4DmaPushCopyBlt(ppdev, 1,&rclIntersectDst, 0xCCCC,
                                          &ptlIntersectSrc, &rclIntersectDst, NULL);
                    }
                    else// Screen to Mem Blt
                    {
                        DSURF   *pdhsurfSave;
                        VOID    *LinearPtr;
                        ULONG    LinearStride;

                        // save away psoSrc->dhasurf -> linearpointer/stride , replace it with singleFrontMainOffset
                        //, call NV4ScreenToMemBlt and restore values
                        pdhsurfSave = (DSURF *)psoSrc->dhsurf;

                        LinearPtr       = pdhsurfSave->LinearPtr;
                        LinearStride    = pdhsurfSave->LinearStride;
                        pdhsurfSave->LinearPtr      = (PVOID)(ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT] + ppdev->pjScreen );
                        pdhsurfSave->LinearStride   = ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];


                        NV4ScreenToMemBlt(  ppdev,1,&rclIntersectDst,psoSrc,psoDst,
                                            &ptlIntersectSrc,&rclIntersectDst,NULL);

                        pdhsurfSave->LinearPtr      = LinearPtr;
                        pdhsurfSave->LinearStride   = LinearStride;
                    }

                    bInterSectionFound = TRUE;
                }
                prcl++;
                cRect--;
            }
        }

        pClientInfoList = pClientInfoList->next;
    }
    return bInterSectionFound;
}
#if (NVARCH >= 0x4)
/*
** bDoMergeBlitOnIntersectingRectangle
**
** Does a Mergeblit on intersecting parts of any overlaywindow .
** This function has to be called after a saved popup-menue background
** behind an overlaywindow has benn restored with the mainplanefront
** contents => overlay has to be merged with rectangle
** 
** Return value: FALSE: if no intersection found
**               TRUE:  if 1 or more intersections found
**
** MSchwarz 10/05/2000: new
*/
BOOL bDoMergeBlitOnIntersectingRectangle(PPDEV  ppdev, RECTL* prclDst)
{
    BOOL                        bInterSectionFound  = FALSE;
    RECTL                       rclSrc;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    NV_OPENGL_CLIENT_INFO      *pClientInfo         = NULL;

    ASSERT(ppdev);
    ASSERT(prclDst);

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    while( pClientInfoList )
    {
        pClientInfo = &pClientInfoList->clientInfo;

        if ( bIsOverlayClient(ppdev, pClientInfo) )
        {
            RECTL   rclIntersect;
            RECTL  *prcl             = NULL;
            ULONG   cRect            = 0;
            NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo = pClientInfo->clientDrawableInfo;
            // find intersection with prclDst and copy contents of intersected mainplanefront
            // to prclDst
            if( pClientDrawableInfo->ubbWindowClipFlag )
            {
                cRect = 1;
                prcl = (RECTL*)(&pClientDrawableInfo->rect);
            }
            else
            {
                cRect = pClientDrawableInfo->numClipRects;
                prcl = pClientDrawableInfo->windowRect;
            }

            while( cRect )
            {
                if( bIntersect( prclDst, prcl, &rclIntersect) )
                {
                    __GLNVoverlayMergeBlitInfo MergeInfo;
                    ULONG ulTemp;

                    RtlZeroMemory(&MergeInfo, sizeof(MergeInfo));


                    MergeInfo.dwAction = NV_OVERLAY_MERGE_BLIT    // do merge blit
                                       | NV_OVERLAY_RUN_IN_DD     // use display driver code
                                       | NV_OVERLAY_USE_CLIPRECT; // use user clipping given in x,y,w,h

                    // 
                    // NOTE: User cliping in MergeInfo is client relative!
                    //
                    OglTranslateCachedClipRectList(ppdev,
                                                   &rclIntersect,
                                                   1,
                                                   &rclIntersect,
                                                   &ulTemp,
                                                   (RECTL *) &(pClientDrawableInfo->rect));
                    ASSERT(1==ulTemp);

                    MergeInfo.x        = rclIntersect.left;                    
                    MergeInfo.y        = rclIntersect.top;                    
                    MergeInfo.width    = rclIntersect.right - rclIntersect.left;
                    MergeInfo.height   = rclIntersect.bottom - rclIntersect.top;

                    // Now call mergeblit disptatcher
                    // As this will add the clipping it isn't possible to
                    // directly call bOglSwapMergeBlit.
                    NV_OglOverlayMergeBlit(ppdev,
                        pClientDrawableInfo->hWnd,
                        pClientDrawableInfo->hDC,
                        &MergeInfo);

                    ASSERT(MergeInfo.retStatus==OGL_ERROR_NO_ERROR);
                    bInterSectionFound = TRUE;
                }
                prcl++;
                cRect--;
            }
        }

        pClientInfoList = pClientInfoList->next;
    }
    return bInterSectionFound;
}



//*********************************************************************
// bOglSwapMergeBlit
// 
// Main worker routine managing the overlay merge blit. 
// Depending on the mergeblit data it can do some 
// additional work to clean up overlays.
//
// 1. common setup
// 2. a. Loop over clip rects. 
//    b. If necessary clip against user rect
// For all rects do:
// 3. If needed update overlay front with overlay back
// 4. If needed update main front with main back
// 5. Is overlay update necessary?
//    a. No: Main plane to visible directly
//    b. Yes: Merge blit
//
// NOTE: The rects list (prclClip) must already be adjusted to match the 
//       offsets to the buffers.
//       If a offsetPixelsX adjustment is needed, do it outside! 
//       If a desktop clipping is neccessary, do it outside!
// 
// FNicklisch 11.10.2000: New, derived from __glNVSwapMergeBlit
//*********************************************************************
BOOL bOglSwapMergeBlit(
    PPDEV                ppdev,          // hw state to use for rendering
    __GLMergeBlitData   *pMergeBlitData) // structure with all merge blit information
{
    int             colordepth; // 16 or 32 as bpp colordepth
    unsigned int    ulRects   ; // count of clip rects
    __GLregionRect *pRects    ; // pointer to list of clip rects (read notes!)
    RECTL           rclDst    ;
    BOOL            b1=FALSE, b2=FALSE, b3=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=pMergeBlitData);
    ASSERT(0==pMergeBlitData->cClip || NULL!=pMergeBlitData->prclClip);

    //
    // 1. setup
    //
    ulRects            = pMergeBlitData->cClip     ;
    pRects             = pMergeBlitData->prclClip  ;
    colordepth         = pMergeBlitData->colordepth;

    ppdev->pfnWaitEngineBusy( ppdev );

    //
    // 2 a. Work done per clip rect
    //
    for (/*ulRects*/ ; ulRects > 0; ulRects--, pRects++) 
    {
        //
        // 2 b. calculate final clip rect against user clipping if necessary
        //
        if (pMergeBlitData->dwAction & NV_OVERLAY_USE_CLIPRECT)
        {
            if (!bIntersect((RECTL*)&pMergeBlitData->rclUser, (RECTL*)pRects, &rclDst))
            {
                continue;
            }
        }
        else
        {
            rclDst = *(RECTL*)pRects;
        }

        //
        // Additional pre surface updates
        //

        // 3. overlay back -> overlay front
        if (pMergeBlitData->dwAction & NV_OVERLAY_UPDATE_OVERLAY)
        {
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->OverlayBackOffset , pMergeBlitData->OverlayBackPitch);
            ppdev->pfnSetDestBase(ppdev, pMergeBlitData->OverlayFrontOffset, pMergeBlitData->OverlayFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }

        // 4. main back -> main front
        if (pMergeBlitData->dwAction & NV_OVERLAY_UPDATE_MAIN)
        {
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainBackOffset , pMergeBlitData->MainBackPitch );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->MainFrontOffset, pMergeBlitData->MainFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }

        //
        // Make the surface visible to the user
        //
        if (pMergeBlitData->dwAction & NV_OVERLAY_NO_OVERLAY_PLANE)
        {
            // 5 a. This windows doesn't use the overlay plane, so there
            // is no need to do the transparent blit and use the 
            // scratch buffer.

            // main plane to scratch
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainFrontOffset   , pMergeBlitData->MainFrontPitch   );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->PrimaryFrontOffset, pMergeBlitData->PrimaryFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }
        else if (pMergeBlitData->dwAction & NV_OVERLAY_MERGE_BLIT)
        {
            //
            // 5 b. Merge blit
            //

            // main plane to scratch
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainFrontOffset, pMergeBlitData->MainFrontPitch);
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->ScratchOffset  , pMergeBlitData->ScratchPitch  );
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);

            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->OverlayFrontOffset, pMergeBlitData->OverlayFrontPitch);
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->ScratchOffset     , pMergeBlitData->ScratchPitch     );

            // overlay plane to scratch onto main plane
            NV4DmaPushColorKeyBlt(ppdev, 1, &rclDst, (POINTL*)&rclDst, &rclDst, (ULONG)pMergeBlitData->colorref);

            // scratch to primary
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->ScratchOffset     , pMergeBlitData->ScratchPitch     );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->PrimaryFrontOffset, pMergeBlitData->PrimaryFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }
    }

    NV4_DmaPushSend(ppdev);
    //ppdev->pfnWaitEngineBusy( ppdev );

    return TRUE;
}
#endif


//
// Next 4 functions provide a simple listfunction to store pointer
// values in, delete them, clear the entire list and check if they 
// are in the list . It is implemented as simple array with  
// MAX_POINTER_LIST_ELEMENTS ( defined in driver .h ) number of elements.
// There is no function to retrieve a pointer back from list.
//
// Implemented Functions so far: 
// -bAddPointerToList
// -bIsPointerInList
// -bRemovePointerFromList
// -bClearPointerList
// -bIsPointerListEmpty
// -ulGetNumberOfPointersInList
//

// At this time ( 10/13/2000 ) these functions are only used for overlay
// applications to detect a popup-window Primary to MEM copy to be able to
// remove and restore the overlay context to look more like a hardware
// overlay

/*
** bAddPointerToList
**
** Stores given pointer in list( implemented as
** simple array ) even if it is already inside.
**
** Return value: FALSE: if no place left for storing
**               TRUE:  if pointer was stored in list
**
** MSchwarz 10/13/2000: new
*/
BOOL bAddPointerToList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bAdded = FALSE;
    
    ASSERT(pList);
    
    if(pList->cElements < MAX_POINTER_LIST_ELEMENTS)
    {
        ASSERT(NULL==pList->apulElements[pList->cElements]);
        pList->apulElements[pList->cElements] = pulPointer;
        pList->cElements++;
        bAdded = TRUE;
        DISPDBG((20, "  AP:Pointer: 0x%x, cElements: %d",pulPointer,pList->cElements));                
    }
    return bAdded;
}

/*
** bIsPointerInList
**
** Checks if a given pointer is stored in list ( implemented as
** simple array )
**
** Return value: FALSE: if pointer not found
**               TRUE:  if pointer was found inside list
**
** MSchwarz 10/13/2000: new
*/
BOOL bIsPointerInList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bFound = FALSE;
    ULONG ul;
    
    ASSERT(pList);
    
    for(ul=0;ul<pList->cElements;ul++)
    {
        if( pulPointer == pList->apulElements[ul] )
        {
            DISPDBG((20, "  FP:Pointer: 0x%x, at Index: %d found",pulPointer,ul));                
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}

/*
** bRemovePointerFromList
**
** removes a given pointer from list ( implemented as
** simple array ) and shifting empty place to end of list
**
** Return value: FALSE: if pointer not found
**               TRUE:  if pointer was removed from list
**
** MSchwarz 10/13/2000: new
*/
#pragma warning(disable: 4296)

BOOL bRemovePointerFromList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bRemoved = FALSE;
    ULONG ul;
    
    ASSERT(pList);

    for(ul=0;ul<pList->cElements;ul++)
    {
        if( pulPointer == pList->apulElements[ul] )
        {
            bRemoved = TRUE;
            // shift emtpy place to end of filled up queue
            for(;ul<pList->cElements-1;ul++)
                pList->apulElements[ul] = pList->apulElements[ul+1];
            //erase shifted element
            pList->apulElements[ul] = NULL;
            pList->cElements--;
            ASSERT(pList->cElements>=0);

            DISPDBG((20, "  RP:Pointer: 0x%x, cElements: %d",pulPointer,pList->cElements));                
        }
    }

    return bRemoved;
}

#pragma warning(default: 4296)

/*
** bClearPointerList
**
** completely clears a given list ( implemented as
** simple array )
**
** Return value: FALSE: no clear possible
**               TRUE:  list cleared
**
** MSchwarz 10/13/2000: new
*/
BOOL bClearPointerList( PPOINTER_LIST pList )
{
    BOOL  bCleared = FALSE;
    ULONG ul;
    
    ASSERT(pList);

    for(ul=0;ul<pList->cElements;ul++)
    {
        pList->apulElements[ul] = NULL;
    }
    pList->cElements = 0;
    bCleared = TRUE;

    DISPDBG((20, "  CP:Pointer: 0x%x, cElements: %d",0,pList->cElements));                

    return bCleared;
}


/*
** bIsPointerListEmpty
**
** returns if given pointerlist contains any
** element or not
**
** Return value: FALSE: no clear possible
**               TRUE:  list cleared
**
** MSchwarz 11/14/2000: new
*/
BOOL bIsPointerListEmpty( PPOINTER_LIST pList )
{
    BOOL bIstEmtpy = FALSE;
    ASSERT(pList);

    if( 0 == pList->cElements )
    {
        bIstEmtpy = TRUE;
    }

    return bIstEmtpy;
}


/*
** bRemoveFirstElementFromList
**
** removes the 1st element ( last recently used )
** from list to make space 
**
** Return value: FALSE: no element removed
**               TRUE:  1st element removed
**
** MSchwarz 11/21/2000: new
*/
BOOL bRemoveFirstElementFromList( PPOINTER_LIST pList )
{
    BOOL bElementRemoved = FALSE;
    ASSERT(pList);

    if( 0 != pList->cElements )
    {
        if( bRemovePointerFromList( pList, (ULONG*)(pList->apulElements[0]) ) )
            bElementRemoved = TRUE;
    }

    return bElementRemoved;
}


/*
** ulGetNumberOfPointersInList
**
** returns number af stored pointers in list
*/
BOOL ulGetNumberOfPointersInList( PPOINTER_LIST pList )
{
    ASSERT(pList);

    return pList->cElements;
}


//*************************************************************************
// bOglIsOverlayClient
// returns TRUE if the given clientInfo describes a client running a 
// overlay pixelformat.
//*************************************************************************
BOOL bOglIsOverlayClient(NV_OPENGL_CLIENT_INFO *pClientInfo)
{
    BOOL bIsOverlayClient;

    bIsOverlayClient =  bOglHasDrawableInfo(pClientInfo)
                    && (pClientInfo->pfd.bReserved != 0);

    return (bIsOverlayClient);
}


//*************************************************************************
// bOglGetNextOverlayClient
//
// finds next OpenGL client running on a overlay pixelformat starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a overlay client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextOverlayClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo) // 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        if (bOglIsOverlayClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglGetNextVisibleOverlayClient
//
// finds next visible OpenGL client running on a overlay pixelformat 
// starting with next client after *ppClientInfo or at top of list 
// if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a overlay client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextVisibleOverlayClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextOverlayClient(&clientInfo))
    {
        if (bOglIsVisibleClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}



//*************************************************************************
// bOglIsOverlayModeEnabled
// 
// returns TRUE if driver is in overlay mode and handles overlay and main 
// plane buffers (e.g. double pumping).
//*************************************************************************
BOOL bOglIsOverlayModeEnabled(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);

    return(bDoublePumped(ppdev, ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT]));
}


//*************************************************************************
// bOglOverlayModeEnable
// 
// enables overlay mode. For now this is only double pumping to the 
// overlay front main surface. 
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeEnable(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired
        && !bOglIsOverlayModeEnabled(ppdev))
    {
        ULONG ulSurfaceOffest;

        ASSERT(ppdev->bOglSingleBackDepthCreated);
        ASSERT(bOglGetNextVisibleOverlayClient(NULL));

        ulSurfaceOffest = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];

        if (!bDoublePumped(ppdev, ulSurfaceOffest) )
        {
            NV_AddDoubleBufferSurface(ppdev, ulSurfaceOffest);
        }
        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglOverlayModeDisable
// 
// disable overlay mode. For now this is only double pumping to the 
// overlay front main surface. 
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeDisable(PPDEV ppdev)
{
    BOOL bRet = FALSE;
    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired
        && bOglIsOverlayModeEnabled(ppdev))
    {
        ULONG ulSurfaceOffest;

        ASSERT(ppdev->bOglSingleBackDepthCreated);

        ulSurfaceOffest = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];

        if (bDoublePumped(ppdev, ulSurfaceOffest) )
        {
            NV_RemoveDoubleBufferSurface(ppdev, ulSurfaceOffest);
        }
        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglOverlayModeUpdate
// 
// Update overlay mode. Need to activate double pumping on visible windows.
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeUpdate(PPDEV ppdev)
{
    BOOL                   bRet = FALSE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired)
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        // Find next visible overlay client to enable overlay mode
        if (bOglGetNextVisibleOverlayClient(NULL))
        {
            bRet = bOglOverlayModeEnable(ppdev);
        }
        else 
        {
            bRet = bOglOverlayModeDisable(ppdev);
        }
    }

    return bRet;
}


//*************************************************************************
// cOglOverlayClients
// returns the current number of clients running a stereo pixelformat
//*************************************************************************
ULONG cOglOverlayClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cOverlayClients=0;

    clientInfo = NULL;
    while (bOglGetNextOverlayClient(&clientInfo))
    {
        ASSERT(ppdev->bOglOverlayDesired);
        cOverlayClients++;
    }

    return (cOverlayClients);
}


//******************************************************************************
//
//  Function:   bOglOverlaySurfacesAllowed
//
//  Checks 3 things: 1. is board workstation board 
//                   2. do we have enough framebuffer to allocate all overlay buffers
//                   3. are overlay pixelformats allowed by registry   
//
//  Return Value: TRUE:  overlay pixelformats are allowed and there are enough ressources for them
//                FALSE: overlay pixelformats are not allowed
//
//******************************************************************************
BOOL bOglOverlaySurfacesAllowed( PPDEV ppdev )
{
    ASSERT( ppdev );

    ppdev->bOglOverlayDesired = FALSE;

    if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
    {
        OglReadRegistry(ppdev);

        // do we have enough frambuffer memory to enable overlay ?
        ASSERT(ppdev->cyScreen > 0);
        ASSERT(ppdev->cyScreen < ppdev->cyMemory);
        //     room for 7 fullscreen buffer:    front+back0+z+mainf+mainb + ovf+ovb
        if(ppdev->cyMemory >= (LONG)(ppdev->cyScreen*7) )
        {
             if (ppdev->oglRegOverlaySupport == NV_REG_OGL_OVERLAY_SUPPORT_ON)
             {
                 ppdev->bOglOverlayDesired = TRUE;
             }
        }
    }
    return (ppdev->bOglOverlayDesired);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglstereo.c ===
//******************************Module*Header***********************************
// Module Name: oglstereo.c
//
// OS dependent functions releated to oglstereo reside here
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "ddmini.h"
#endif  
#include "nvRmStereo.h"
#include "nvdoublebuf.h"
#include "nvReg.h"
#include "oglutils.h"

// export
#include "oglstereo.h"


// Documentation of the stereo implementation
//
// The OpenGL stereo implementation uses the OpenGL API on a window with 
// pixelformat that has PFD_STEREO selected. In stereo mode we run in a
// quad buffered environment. The color buffers are GL_FRONT_LEFT, GL_FRONT_RIGHT, 
// GL_BACK_LEFT and GL_BACK_RIGHT. Also depth and stencil buffers are duplicated
// for the right eye. pic 1.
// Monoscopic apps will default to the left buffers and the broadcast to the
// right buffers has to be handled. We allow a mix of monoscopic and stereo 
// apps in a windowed environment.
//
// If the system in in stereo mode (OGL_EnableStereoSupport) all ICDs, even
// monoscopic ICDs will cause the display driver to allocate and reserve 
// all stereo buffers to guarantee that later stereo apps will succeed to run
// in hardware.
//
// If a stereo ICD is enabled the display driver will enable the shutter glasses
// and double pump GDI to the right front buffer.
//
// If all stereo windows are occluded or disabled through an escape/OGL extension
// we disable the shutter glasses and double pumping. This speeds up the system.
//
// Notes/Limitations:
//
// * We don't want to flip in stereo mode, because we would need to wait 
//   on the vblank. Toggle between hsync and vsync flips causes the screen 
//   to flicker.
// * Monoscopic double buffered will run as in non stereo environment but
//   the ICDs need to allocate and initialize at least the stereo buffers 
//   in the drawable private to allow the swap to be broadcasted. The 
//   broadcast is completely solved in the shared library through the
//   dp->stereoEyeLoop used by the stereo swap, too. It uses different 
//   initialized buffers. pic 4.
// * Monoscopic single buffered ICDs are internally set to stereo.
//   This will cause GL_FRONT to render to both frontbuffers.
//   No need to broadcast outside, but we run through differnt pathes
//   than in a non stereo environment! 
// 
// 
// pic 1) Default mode stereo apps
// 
//  LEFT eye               RIGHT eye
//
// +---------+            +---------+                            
// |  Front  |<- toggle ->|  Front  |                            
// |  left   |    DAC     |  right  |                  
// |         |<-+         |         |<-+                      
// +---------+  |         +---------+  |                      
//              |                      |    
//          swap-left              swap-right
//              |                      |     
// +---------+  |         +---------+  |                      
// |  Back   | -+         |  Back   | -+                      
// |  left   |            |  right  |                  
// |         |            |         |                  
// +---------+            +---------+                            
//                                            
// +---------+            +---------+                             
// |    Z    |            |    Z    |                             
// |  left   |            |  right  |                             
// |         |            |         |                             
// +---------+            +---------+         
//                                           
// A swap buffers needs to swap both back buffers to both front buffers.
// This is done by a loop in the swap blit itself.
//
//
// pic 2) Stereo apps, stereo disabled through extension
// 
//  LEFT eye               RIGHT eye
//
// +---------+            +---------+                            
// |  Front  |            |  Front  |                            
// |  left   |            |  right  |                  
// |         |<-+         |         |                 
// +---------+  |         +---------+                 
//              |          ^         
//          swap-left swap-right (duplicate)
//              |       /              
// +---------+  |     /   +---------+                 
// |  Back   | -+----     |  Back   |                 
// |  left   |            |  right  |          
// |         |            |         |                  
// +---------+            +---------+                            
//                                            
// +---------+            +---------+                             
// |    Z    |            |    Z    |                             
// |  left   |            |  right  |                             
// |         |            |         |                             
// +---------+            +---------+         
//
//
// pic 3) Default mode monoscopic double buffered apps
// 
//  LEFT eye         
//
// +---------+       
// |  Front  |       
// |  left   |       
// |         |<-+    
// +---------+  |    
//              |    
//          swap-left
//              |    
// +---------+  |    
// |  Back   | -+       
// |  left   |         
// |         |         
// +---------+                   
//                
// +---------+                    
// |    Z    |                    
// |  left   |                    
// |         |                    
// +---------+    
//
// doesn't need to take care about right buffers
// 
//
// pic 4) Monoscopic double buffered apps running in 
//        stereo environment
// 
//  LEFT eye               RIGHT eye         
//                                           
//   ICD to 
//  LEFT only
//      V
// +---------+            +---------+        
// |  Front  |            |  Front  |        
// |  left   |            |  right  |        
// |         |<-+         |         |<-+     
// +---------+  |         +---------+  |     
//              |                      |     
//          swap-left              swap-right(duplicate)
//              |                      |     
// +---------+  |                     / 
// |  Back   | -+                   /     
// | left +  |                    /      
// | right   | ---------------- /        
// +---------+                 
//                                           
// +---------+     
// |    Z    |     
// |  left   |     
// |         |     
// +---------+
//
// App renders as before, but swap buffers copies back left
// to front left and to front back.
// ICD needs to allocate and associate right buffers. The 
// back right is maped to back left.
//
//
// pic 5) Monoscopic single buffered apps running in 
//        stereo environment
// 
//  LEFT eye               RIGHT eye
//
//          ICD to GL_FRONT
//           /            \
//         /                \
//        V                  V
// +---------+            +---------+
// |  Front  |<- toggle ->|  Front  |
// |  left   |    DAC     |  right  |
// |         |            |         |
// +---------+            +---------+
//
// More information:
// .\drivers\OpenGL\include\GL\glcore.h
// .\drivers\display\winnt4\displays\nv_disp\oglstereo.c


//
// bOglStereoGlassesSwitchOn
//
// calls the miniport to switch on stereo
// glasses toggling
//
// Return value: FALSE: did not switch glasses toggling on
//               TRUE:  switched on  glasses toggling
//
// MSchwarz 11/16/2000: new
//
BOOL bOglStereoGlassesSwitchOn(PDEV* ppdev)
{
    ULONG                 ul;
    NV_CFG_STEREO_PARAMS  StereoParams;
    ULONG                 ulReturnedDataLength;
    BOOL                  bGlassesSwitchOn = FALSE;

    ASSERT(ppdev);

    if (!ppdev->bOglStereoActive)
    {
        RtlFillMemory(&StereoParams,sizeof(StereoParams),0xFF);

        StereoParams.Flags               =   STEREOCFG_WS_OGL_API_STEREO   // mark structure as used by ogl api stereo
                                           | STEREOCFG_STEREO_INITIALIZE   // switch glasses on
                                           | STEREOCFG_ELSADDC;            // use ELSA DDC switching method
        StereoParams.EyeDisplayed        = 0;
        StereoParams.FlipOffsets[1][0]   = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_LEFT];
        StereoParams.FlipOffsets[1][1]   = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
        // for flipping purposes:
        StereoParams.FlipOffsets[2][0]   = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
        StereoParams.FlipOffsets[2][1]   = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_RIGHT];

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_STEREO_GLASSES_SWITCH,
                               &StereoParams,                       // input buffer
                               sizeof(StereoParams),
                               NULL,                                // no output buffer
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((1, "bOglStereoGlassesSwitchOn - Error switching stereo glasses on"));
            goto Exit;
        }
        ppdev->bOglStereoActive = TRUE;
    }

    bGlassesSwitchOn = TRUE;

Exit:

    return bGlassesSwitchOn;
}



//
// bOglStereoGlassesSwitchOff
//
// calls the miniport to switch off stereo
// glasses toggling
//
// Return value: FALSE: did not switch glasses toggling off
//               TRUE:  switched off glasses toggling
//
// MSchwarz 11/16/2000: new
//
BOOL bOglStereoGlassesSwitchOff(PDEV* ppdev)
{
    NV_CFG_STEREO_PARAMS  StereoParams;
    ULONG                 ulReturnedDataLength;
    BOOL                  bOglStereoGlassesSwitchOff = FALSE;

    ASSERT(ppdev);

    if (ppdev->bOglStereoActive)
    {
        RtlFillMemory(&StereoParams,sizeof(StereoParams),0xFF);

        StereoParams.Flags               =   STEREOCFG_WS_OGL_API_STEREO   // mark structure as used by ogl api stereo
                                           | STEREOCFG_STEREO_DISABLE;     // switch glasses off
        StereoParams.EyeDisplayed        = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_STEREO_GLASSES_SWITCH,
                               &StereoParams,                       // input buffer
                               sizeof(StereoParams),
                               NULL,                                // no output buffer
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((1, "bOglStereoGlassesSwitchOff - Error switching stereo glasses off"));
            goto Exit;
        }

        ppdev->bOglStereoActive    = FALSE;
    }
    bOglStereoGlassesSwitchOff = TRUE;

Exit:

    return bOglStereoGlassesSwitchOff;
}


//*************************************************************************
// bOglIsStereoClient
// returns TRUE if the given clientInfo describes a client running a 
// stereo pixelformat.
//*************************************************************************
BOOL bOglIsStereoClient(NV_OPENGL_CLIENT_INFO *pClientInfo)
{
    BOOL bIsStereoClient;

    bIsStereoClient =  bOglHasDrawableInfo(pClientInfo)
                    && (pClientInfo->pfd.dwFlags & PFD_STEREO);

    return (bIsStereoClient);
}


//*************************************************************************
// bOglGetNextStereoClient
//
// finds next OpenGL client running on a stereo pixelformat starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a stereo client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextStereoClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo) // 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        if (bOglIsStereoClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}



//*************************************************************************
// cOglStereoClients
// returns the current number of clients running a stereo pixelformat
//*************************************************************************
ULONG cOglStereoClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cStereoClients=0;

    clientInfo = NULL;
    while (bOglGetNextStereoClient(&clientInfo))
    {
        ASSERT(ppdev->bOglStereoDesired);
        cStereoClients++;
    }

    return (cStereoClients);
}



//*************************************************************************
// bOglIsStereoModeEnabled
// 
// returns TRUE if driver is in stereo mode (e.g. double pumping 
// and glasses).
//*************************************************************************
BOOL bOglIsStereoModeEnabled(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);
    return(ppdev->bOglStereoActive);
}


//*************************************************************************
// bOglGetNextActiveStereoClient
//
// Same (including interface) as bOglGetNextStereoClient but only finds 
// active clients. An active client is visible and not disabled by escape.
//
// Returns TRUE if a visible stereo client was found and returns a pointer 
//   to the clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextActiveStereoClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextStereoClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextStereoClient(&clientInfo))
    {
        // found stereo client, but is it currently visible
        if (   bOglIsVisibleClient(clientInfo)
            && !clientInfo->bStereoDisabled)
        {
            // if wanted return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}
    
    
    
//*************************************************************************
// bOglStereoModeEnable
// 
// enables GDI double pumping to stereo buffer 
// * Shutter glasses will be enabled
// * Tvinview mode will set the second dacs
// * Vertical interlaced stereo will do nothing
//
// Returns TRUE if succeeded, FALSE if failed.
//*************************************************************************
BOOL bOglStereoModeEnable(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ULONG ulSurfaceOffset = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];

        ASSERT(NV_REG_OGL_STEREO_SUPPORT_OFF != ppdev->oglRegApiStereoSupport);
        ASSERT(ppdev->bOglSingleBackDepthCreated);
        ASSERT((bOglGetNextActiveStereoClient(NULL)));

        // at least one visible stereo client
        // need to toggle glasses and double pump
        if (ppdev->bOglStereoActive)
        {
            // already active, nothing to do.
        }
        else
        {
            // Only workstation parts have ubb buffers
            if (   !bDoublePumped(ppdev, ulSurfaceOffset)
                && !NV_AddDoubleBufferSurface(ppdev, ulSurfaceOffset) )
            {
                // failed to enable double pumping code!
                goto Exit;
            }

            switch (ppdev->oglRegApiStereoMode)
            {

                case NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES:
                {
                    // enable it now
                    if (bOglStereoGlassesSwitchOn(ppdev))
                    {
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        // failed to enable glasses
                        NV_RemoveDoubleBufferSurface(ppdev, ulSurfaceOffset);
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0 :
                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0:
                {
                    //stereo (perhaps doesn't need double pumping)
                    ppdev->bOglStereoActive = TRUE;
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0         :
                {
                    // dac0 and dac1 are defaulting to left buffer, need to set dac1 to right 
                    // needs double pumping
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        NvSetDacImageOffset(ppdev, ppdev->ulDeviceDisplay[1], ppdev->singleFrontMainOffset[1] - ppdev->ulPrimarySurfaceOffset);
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        DBG_ERROR("ERROR in bOglStereoModeEnable: need twinview clone mode to enable NV_REG_OGL_API_STEREO_MODE_TVINVIEW");
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0        :
                {
                    // dac0 and dac1 are defaulting to left buffer, need to set dac0 to right 
                    // needs double pumping
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        NvSetDacImageOffset(ppdev, ppdev->ulDeviceDisplay[0], ppdev->singleFrontMainOffset[1] - ppdev->ulPrimarySurfaceOffset);
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        DBG_ERROR("ERROR in bOglStereoModeEnable: need twinview clone mode to enable NV_REG_OGL_API_STEREO_MODE_TVINVIEW");
                    }
                    break;
                }

                default:
                    DISPDBG((0, "unsupported NV_REG_OGL_API_STEREO_MODE: 0x%x",ppdev->oglRegApiStereoMode));
                    break;
            }

        }

        ASSERT(ppdev->bOglStereoActive);
        ASSERT(ppdev->DoubleBuffer.bEnabled);
        ASSERT(ppdev->DoubleBuffer.NumBuffers > 0);
        ASSERT(ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT] != ppdev->singleFrontOffset[OGL_STEREO_BUFFER_LEFT]);
    }
    ASSERT(bOglIsStereoModeEnabled(ppdev));

Exit:
    return (ppdev->bOglStereoActive);
}


//*************************************************************************
// bOglStereoModeDisable
// 
// disables stereo mode: 
// * Shutter glasses will stop to toggle
// * Tvinview mode will reset the dacs
// * Vertical interlaced stereo will do nothing
// GDI broadcasting to stereo buffers is stopped.
//
// Returns TRUE if succeeded, FALSE if failed.
//*************************************************************************
BOOL bOglStereoModeDisable(PPDEV ppdev)
{
    BOOL bRet = TRUE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        // Although running in a stereo environment it isn't necessary 
        // to enable the shutter glasses and double pumping.
        if (ppdev->bOglStereoActive)
        {
            switch (ppdev->oglRegApiStereoMode)
            {
                case NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES:
                {
                    bOglStereoGlassesSwitchOff(ppdev);
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0         :
                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0        :
                {
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        ULONG ulHead = ppdev->ulDeviceDisplay[1];
                        NvSetDacImageOffset(ppdev, ulHead,
                            ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta);
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0 :
                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0:
                default:
                {
                    break;
                }
            }

            if ( bDoublePumped(ppdev, ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT]) )
            {
                NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT]);
            }

            ppdev->bOglStereoActive = FALSE;
            // active, need to disable it now
        }

        ASSERT(!ppdev->bOglStereoActive);

        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglStereoModeUpdate
//
// run through client list and compare against system settings to consider 
// if stereo mode (glasses+double pumping) has to be enabled or not.
// This is used to dynamically toggle between glasses on with GDI double 
// pumping and OpenGL broadcasting to right front and glasses off an a 
// monoscopic usage of the left buffers only. Doing this will increase 
// performance for all non stereo apps in a stereo environment or when 
// all stereo apps are occluded.
//
// returns TRUE if stereomode is enabled
//*************************************************************************
BOOL bOglStereoModeUpdate(PPDEV ppdev)
{
    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        if (bOglGetNextActiveStereoClient(NULL))
        {
            bOglStereoModeEnable(ppdev);
        }
        else
        {
            bOglStereoModeDisable(ppdev);
        }
    }

    // return if stero mode is on or off
    return (ppdev->bOglStereoActive);
}

// End of oglstereo.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pixelfmt.h ===
#ifndef _PIXELFMT_H
#define _PIXELFMT_H
//******************************Module*Header***********************************
// Module Name: pixelfmt.h
//
// export header for pixelfmt.c
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglStereoSurfacesAllowed(PPDEV ppdev);
BOOL bOglPfdCheckFlags(PPDEV ppdev, ULONG *pulPfdCheckFlags);
int cGetWindowFlippingControl(PPDEV ppdev);

#endif // _PIXELFMT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\paint.c ===
//*****************************Module*Header********************************
// 
// Module Name: paint.c
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//*************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;


    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

#if 0 // NOTE: needs to be enabled if it doesn't longer call DrvBitBlt!
    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,NULL,pco);        
    }
#endif

        
    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglutils.c ===
//*****************************Module*Header*******************************
// Module Name: oglutils.c
//
// all little opengl helperfunctions should reside here
// Copyright (c) 2000 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "oglDD.h"
#include "oglflip.h"
#include "nvdoublebuf.h"
#include "oglstereo.h"
#include "ogloverlay.h"
#include "cliplist.h"
#include "pixelfmt.h"
#include "oglclip.h"
#include "Nvcm.h"
#include "nvReg.h"
#ifdef NV_MAIN_MULTIMON
#include "oglutils.h"
#include "linkedlist.h"
#endif

#ifdef NVD3D
    #include "dx95type.h"
    #include "ddmini.h"
#endif  


//
// export
//
#include "oglutils.h"

GLOBAL_OPENGL_DATA globalOpenGLData = { NULL, 0, 0, 0 };
ULONG globalOpenGLMutex = 0;
ULONG globalOpenGLMutexCount = 0;

//*************************************************************************
// For details regarding NV_OglDDrawSurfaceCreated/Destroyed, please see
// the comment in oglDD.h regarding OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING
//*************************************************************************
#if !i386 || _WIN32_WINNT >= 0x0500
typedef HANDLE (*P_PS_GET_CURRENT_PROCESS_ID)(void);
#endif

#pragma warning(disable: 4035)  // no return value
DWORD GetCurrentProcessID(VOID)
{
#if i386 && _WIN32_WINNT >= 0x0400
    __asm
    {
        mov eax, fs:[0x18]
        mov eax, [eax + 0x20] // return value in eax
    }
#else
    HANDLE hPID = NULL;
    HANDLE hDLL;

    hDLL = EngLoadImage(L"NTOSKRNL.EXE");
    if (hDLL)
    {
        P_PS_GET_CURRENT_PROCESS_ID pfPsGetCurrentProcessId;

        pfPsGetCurrentProcessId = (P_PS_GET_CURRENT_PROCESS_ID)EngFindImageProcAddress(hDLL, "PsGetCurrentProcessId");
        if (pfPsGetCurrentProcessId)
        {
            // does NOT work in FREE mode
            hPID = pfPsGetCurrentProcessId();
        }
        EngUnloadImage(hDLL);
    }
    return (DWORD)((DWORD_PTR)hPID);
#endif
}
#pragma warning(default: 4035)  // no return value



//*************************************************************************
// bAddProcessIDToDDrawCounterList
//
// Function removes all stored ProcessId's belonging to an 
// ICD app from list. Then Adds a given ProcessID to 
// DDrawCounterList in ppdev if it does not belong to an ICD.
//
// returns TRUE  if ProcessID was successfully added to list( came from DDraw app )
//         FALSE if ProcessID belongs to ICD app or if there was no space left in list
//
//*************************************************************************
BOOL bAddProcessIDToDDrawCounterList( PPDEV ppdev, ULONG ulProcessID )
{
    NV_OPENGL_CLIENT_INFO *pClientInfo     = NULL;
    BOOL                   bRet            = FALSE;
    BOOL                   bIsICDProcessID = FALSE;

    ASSERT(ppdev);

    while( bOglGetNextClient(&pClientInfo) )
    {
        if( pClientInfo->dwProcessID == ulProcessID )
        {
            bIsICDProcessID = TRUE;
        }

        // remove processid from list if it belongs to an ICD
        while(bRemovePointerFromList( &ppdev->oglDDrawSurfaceCountList, (PULONG)((ULONG_PTR)pClientInfo->dwProcessID)) )
        {
            // remove each stored link to this ICD client
            ;
        }
    }
    // now all ProcessID's belonging to an ICD-app should have been removed from list

    // add given ProcesId to DDrawSurfaceCountList if it does not belong to an ICD
    if( !bIsICDProcessID )
    {
        if(!bAddPointerToList( &ppdev->oglDDrawSurfaceCountList, (PULONG)((ULONG_PTR)ulProcessID)))
        {
            DISPDBG((0,"bAddProcessIDToDDrawCounterList: no space left for ProcessIDCount"));
            goto Exit;
        }

        // added ProcessID to list => ID call came from DDraw app
        bRet = TRUE;
    }
    // now number of saved ProcessID's is number of DDrawappps

Exit:

    return bRet;
}

//*************************************************************************
// bRemoveProcessIDFromDDrawCounterList
//
// Function removes all given ProcessId from list. 
// If ProcessID is not in list and does not belong
// to an ICD Client, then complete list is erased
// because this case indicates us that winlogon.exe
// or csrss.exe or rundll32.exe called DisableAllDirectDrawObject
// to perform  a CTRL-ALT-DEL / Fullscreen DOS-Box 
// or a modeswitch.
//
// returns TRUE  if ProcessID was removed from list( came from DDraw app )
//         FALSE never at this point of implementation
//
//*************************************************************************
BOOL bRemoveProcessIDFromDDrawCounterList( PPDEV ppdev, ULONG ulProcessID )
{
    NV_OPENGL_CLIENT_INFO *pClientInfo     = NULL;
    BOOL                   bRet            = FALSE;
    BOOL                   bIsICDProcessID = FALSE;

    ASSERT(ppdev);

    // did ulProcessID reside in List ?
    if( !bRemovePointerFromList(&ppdev->oglDDrawSurfaceCountList,(PULONG)((ULONG_PTR)ulProcessID)) )
    {
        // check if ulProcessID belongs to an ICD app
        while( bOglGetNextClient(&pClientInfo) )
        {
            if( pClientInfo->dwProcessID == ulProcessID )
            {
                bIsICDProcessID = TRUE;
            }
        }

        if( bIsICDProcessID )
        {
            // an ICD apps is destroying its ddraw context => everything OK
            bRet = TRUE;
        }
        else
        {
            // if we reach this point, either winlogon.exe
            // or csrss.exe or rundll32.exe called DisableAllDirectDrawObject
            // => empty list
            bClearPointerList(&ppdev->oglDDrawSurfaceCountList);

            bRet = TRUE;
        }
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}




//*************************************************************************
//  NV_OglDDrawSurfaceCreated
//
//  This function is called when a new DDraw/D3D surface may have been
//  created which may force us to switch off windowflipping.
//*************************************************************************

void __cdecl NV_OglDDrawSurfaceCreated(PDEV *ppdev)
{
    ASSERT(ppdev);

    if( (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC) )
    {
        // look ahead! function automatically removes all ICD processes from list
        // => update counter and PageFlipMode allways
        bAddProcessIDToDDrawCounterList(ppdev,GetCurrentProcessID());

        ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
        bOglPageFlipModeUpdate(ppdev);
    }
}

//*************************************************************************
//  NV_OglDDrawSurfaceDestroyed
//
//  This function is called when a DDraw/D3D surface may have been destroyed
//  which may allow us to switch on windowflipping.
//*************************************************************************
void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *ppdev)
{
    ASSERT(ppdev);

    if( (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC) )
    {
        bRemoveProcessIDFromDDrawCounterList(ppdev,GetCurrentProcessID());
    
        ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
        bOglPageFlipModeUpdate(ppdev);
    }
}


//*************************************************************************
// bOglDirectDrawAppRunning
// 
// Returns TRUE if from the OGLs perspective a concurring 
// directdraw or direct3d app is running.
//
// NOTE: After a modeswitch the complete counting is destroyed:
//       ppdev->pDriverData->DDrawVideoSurfaceCount goes to negative values
//       ppdev->oglDDrawSurfaceCount only has one count per ogl
//       ppdev->DDrawVideoSurfaceCount isn't used at all
//
//*************************************************************************
BOOL bOglDirectDrawAppRunning(PPDEV ppdev)
{
    return(ppdev->oglDDrawSurfaceCount > 0);

#pragma message("  MSchwarzer 12/12/2000:  look at this. Optimize for NT4!")
// W2K should work fine now
// On NT4 CTRL-ALT-DEL kill us because it releases all DDraw surfaces but does
// not realloc them :-((
// Fullscreen DOS-Box and Modeswitch works fine now
}


//*************************************************************************
// bOglPOWERlibAppRunning
// 
// Returns TRUE if from the OGLs perspective a concurring 
// POWERlib/POWERdraft is running.
//*************************************************************************
BOOL bOglPOWERlibAppRunning(PPDEV ppdev)
{
    return (FALSE);
}


//*************************************************************************
// bOglHasDrawableInfo
// returns TRUE if the given client has a clientDrawableInfo linked to it.
//*************************************************************************
BOOL bOglHasDrawableInfo(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    if (clientInfo)
    {
        // Need a valid pointer to make my tests!
        ASSERT(OglFindClientListFromClientInfo(NULL, clientInfo));
        return (   (clientInfo->clientDrawableInfo)
                && (clientInfo->flags & NV_OGL_CLIENT_DRAWABLE_INFO) );
    }
    return (FALSE);
}


//*************************************************************************
// bOglIsVisibleClient
// returns TRUE if the client is visible.
//*************************************************************************
BOOL bOglIsVisibleClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglHasDrawableInfo(clientInfo)
            && !bRclIsEmpty((RECTL *)&clientInfo->clientDrawableInfo->rect)
            && !(clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) );
}


//*************************************************************************
// bOglIsUnclippedClient
// returns TRUE if the client is visible and not clipped
//*************************************************************************
BOOL bOglIsUnclippedClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglIsVisibleClient(clientInfo)
            && (   (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_SINGLERECTANGLE)
                || (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLYVISIBLE)
                || (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN) ) );
}


//*************************************************************************
// bOglIsFullscreenClient
// returns TRUE if the client is running in fullscreen mode
//*************************************************************************
BOOL bOglIsFullscreenClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglIsVisibleClient(clientInfo)
            && (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN) );
}


//*************************************************************************
// bOglIsComplexClippedClient
// 
// returns TRUE if the client is complex clipped. Complex clipped does mean
// it has more clip rect than the hardware can process.
//*************************************************************************
BOOL bOglIsComplexClippedClient(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet = FALSE; // no it isn't

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));

    if (    bOglIsVisibleClient(clientInfo)      // unvisible -> simple, occluded
         && !bOglIsUnclippedClient(clientInfo)   // unclipped -> simple
         && clientInfo->clientDrawableInfo->numClipRects > HWGFXCAPS_MAXCLIPS(ppdev))
    {
        // could do some checks if exclusive rects would help us,
        // but for now assume we are complex clipped.
        bRet = TRUE;
    }

    return (bRet);
}


//*************************************************************************
// bOglGetNextClient
//
// finds next OpenGL clientinfo that contains a drawable starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    BOOL                        bRet            = FALSE;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    BOOL                        bSearchStart   ;

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    bSearchStart = (   (NULL != ppClientInfo)     // valid pointer
                    && (NULL != *ppClientInfo) ); // initialized for search?

    while (pClientInfoList)
    {
        if (bSearchStart)            
        {
            // need to find start of serach first.
            if (&pClientInfoList->clientInfo == *ppClientInfo)
            {
                // Stop search for head of list and start 
                // search for client with next element
                bSearchStart = FALSE;
            }

        }
        else if (bOglHasDrawableInfo(&pClientInfoList->clientInfo))
        {
            // if wanted return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = &pClientInfoList->clientInfo;
            }
                
            bRet = TRUE;
            break;
        }

        pClientInfoList = pClientInfoList->next;
    }

    return bRet;
}


//*************************************************************************
// bOglGetNextVisibleClient
//
// finds next visible OpenGL client starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a visible client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextVisibleClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglIsVisibleClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// cOglVisibleClients
// 
// Returns number of visible opengl clients. 0==no client or all clients 
// occluded.
//*************************************************************************
ULONG cOglVisibleClients(PPDEV ppdev)
{
    BOOL                   bFound     = TRUE;
    ULONG                  ulRet      = 0;
    NV_OPENGL_CLIENT_INFO *clientInfo;

    ASSERT(NULL!=ppdev);

    clientInfo = NULL; // Start search at top of chained list

    while (bOglGetNextVisibleClient(&clientInfo))
    {
        ulRet++;
    }

    return (ulRet);
}


//*************************************************************************
// cOglWindows
// 
// Returns count of/number of OpenGL windows, drawables.
//*************************************************************************
ULONG cOglWindows(PPDEV ppdev)
{
    ULONG                 ulRet=0;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;

    ASSERT(NULL!=ppdev);

    clientInfo = NULL;

    while (bOglGetNextClient(&clientInfo))
    {
        ulRet++;
    }

    ASSERT(0==ulRet || OglIsEnabled(ppdev));
    ASSERT(ulRet <= globalOpenGLData.oglClientCount);
    ASSERT(ulRet == globalOpenGLData.oglDrawableClientCount);

    return (ulRet);
}



//******************************************************************************
//
//  Function: CreateOglGlobalMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************

void CreateOglGlobalMemory(
PDEV *ppdev)

    {
    NV_OPENGL_GLOBAL_DATA *nvGlobalData;

    ppdev->oglGlobalPageSize = PAGE_SIZE * BYTES_TO_PAGES(sizeof(ULONG));
    /* Since we are not guaranteed page aligned allocation,
     * we need to allocate an extra PAGE_SIZE - 1 memory and use
     * memory starting from next page. */
    ppdev->origOglGlobalPagePtr = ppdev->oglGlobalPagePtr =
        EngAllocMem(FL_ZERO_MEMORY, (ppdev->oglGlobalPageSize + PAGE_SIZE - 1), ALLOC_TAG);

    if (ppdev->oglGlobalPagePtr != NULL)
        {
        ppdev->oglGlobalPagePtr = PAGE_ALIGN_UP(ppdev->oglGlobalPagePtr);

        DISPDBG((8, "CreateOglGlobalMemory OGLGPPTR = 0x%p, OrigPtr = 0x%p",ppdev->oglGlobalPagePtr, ppdev->origOglGlobalPagePtr));

        if (OglLockDownMemory(ppdev, ppdev->oglGlobalPageSize) == FALSE)
            {
            // NO OpenGL acceleration...
            EngFreeMem(ppdev->origOglGlobalPagePtr);
            ppdev->oglGlobalPagePtr = NULL;
            ppdev->origOglGlobalPagePtr = NULL;
            ppdev->oglMutexPtr      = NULL;
            ppdev->oglModeSwitchPtr = NULL;
            ppdev->bReleaseOglMutex = 0;
            return;
            }
        }
    else
        {
        DISPDBG((2, "CreateOglGlobalMemory - Failed EngAllocMem"));
        }

    nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdev->oglGlobalPagePtr;
    if (nvGlobalData)
        {
        ppdev->oglMutexPtr      = &nvGlobalData->oglMutex;
        ppdev->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
        }

    ppdev->bReleaseOglMutex = 0;

    ppdev->oglLastChannel = 0;
}

//******************************************************************************
//
//  Function: DestroyOglGlobalMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void DestroyOglGlobalMemory(
PDEV *ppdev)

    {
    if (ppdev->oglGlobalPageMdl)
        {
        OglUnlockMemory(ppdev);
        }
    ppdev->oglGlobalPageMdl = NULL;
    if ((ppdev->oglGlobalPagePtr) && (ppdev->origOglGlobalPagePtr))
        {
        EngFreeMem(ppdev->origOglGlobalPagePtr);
        }

    ppdev->oglGlobalPagePtr = NULL;
    ppdev->origOglGlobalPagePtr = NULL;
    ppdev->oglMutexPtr      = NULL;
    ppdev->oglModeSwitchPtr = NULL;
    ppdev->bReleaseOglMutex = 0;
}

//******************************************************************************
//
//  Function: OglDisableModeSwitchUpdate
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************

void OglDisableModeSwitchUpdate(
PDEV *ppdev)

    {
    int i;
    ppdev->dwGlobalModeSwitchCount = ppdev->dwGlobalModeSwitchCount + 2;
    ppdev->dwGlobalModeSwitchCount |= 0x1;
    if (ppdev->oglModeSwitchPtr) *ppdev->oglModeSwitchPtr = ppdev->dwGlobalModeSwitchCount;

    if (ppdev->bOglSingleBackDepthCreated ||
        ppdev->bOglOverlaySurfacesCreated)  
        {
        // Free single-back-depth - client side must recover this...
        OglFreeUnifiedSurfaces(ppdev);
        }
    } // end of OglDisableModeSwitchUpdate

//******************************************************************************
//
//  Function: OglEnableModeSwitchUpdate
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************

void OglEnableModeSwitchUpdate(
PDEV *ppdev)

    {
    ppdev->dwGlobalModeSwitchCount = ppdev->dwGlobalModeSwitchCount + 2;
    ppdev->dwGlobalModeSwitchCount &= 0xFFFFFFFE;
    if (ppdev->oglModeSwitchPtr) *ppdev->oglModeSwitchPtr = ppdev->dwGlobalModeSwitchCount;

    //******************************************************************************
    // Wait for other DMA channels to drain at this point.
    //******************************************************************************
    // Check pfnWaitForChannelSwitch for NULL pointer because in bAssertModeHardware
    // the driver call OglEnableModeSwitchUpdate and the ppdev function pointers are
    // not setup yet.  The function pointers should be setup first before calling
    // bAssertModeHardware...
    //******************************************************************************

    if (OglIsEnabled(ppdev) && ppdev->pfnWaitForChannelSwitch)
        {
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        }
    } // end of OglEnableModeSwitchUpdate

//******************************************************************************
//
//  Function: OglLockDownMutexMemory
//
//  Routine Description:
//
//     Lock down memory shared between display driver and client side.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
BOOL OglLockDownMemory(
    PDEV *ppdev,
    ULONG numBytes)

    {
    NV_LOCK_DOWN_MEMORY lockDownMemoryIn;
    NV_LOCK_DOWN_MEMORY lockDownMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglLockDownMemory - Entry"));

    lockDownMemoryIn.virtualAddress = (PVOID)ppdev->oglGlobalPagePtr;
    lockDownMemoryIn.byteLength     = ROUND_TO_PAGES(numBytes);
    lockDownMemoryIn.pMdl           = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_LOCK_DOWN_MEMORY,
        &lockDownMemoryIn,
        sizeof(NV_LOCK_DOWN_MEMORY),
        &lockDownMemoryOut,
        sizeof(NV_LOCK_DOWN_MEMORY),
        &dwReturnedDataLength))
    {
        DISPDBG((2, "OglLockDownMemory - IOCTL_VIDEO_LOCK_DOWN_MEMORY failed"));
        ppdev->oglGlobalPageMdl = NULL;
        return(FALSE);
    }

    ppdev->oglGlobalPageMdl = lockDownMemoryOut.pMdl;

    DISPDBG((2, "OglLockDownMemory - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
//  Function: OglUnlockMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
BOOL OglUnlockMemory(
PDEV *ppdev)

    {
    NV_UNLOCK_MEMORY unlockMemoryIn;
    NV_UNLOCK_MEMORY unlockMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglUnlockMemory - Entry"));

    unlockMemoryIn.pMdl = (PVOID)ppdev->oglGlobalPageMdl;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_UNLOCK_MEMORY,
        &unlockMemoryIn,
        sizeof(NV_UNLOCK_MEMORY),
        &unlockMemoryOut,
        sizeof(NV_UNLOCK_MEMORY),
        &dwReturnedDataLength))
    {
        DISPDBG((2, "OglUnlockMemory - IOCTL_VIDEO_SYSMEM_SHARE_MEMORY failed"));
        return(FALSE);
    }

    DISPDBG((2, "OglUnlockMemory - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
// Function: OglAcquireGlobalMutex
//
// Routine Description:
//
//     Acquire the mutex that protects the OpenGL global variables.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID OglAcquireGlobalMutex(void)
{
    LONGLONG stime, ctime, dtime;
    ULONG    *oglMutexPtr;
    ULONG     key;
    ULONG     firstTime;

    oglMutexPtr = &globalOpenGLMutex;

    firstTime = 0;
    key = 1;
    do
        {
        NV_EXCHANGE(oglMutexPtr, key);
        if (key == 1)
            {

            if (firstTime == 0)
                {
                firstTime = 1;
                EngQueryPerformanceCounter((LONGLONG *)&stime);
                }
            else
                {

                EngQueryPerformanceCounter((LONGLONG *)&ctime);
                dtime = (ctime - stime);
                if (dtime >= 3) // 3 seconds
                    {
                    // TIMEOUT force reset of mutex
                    *oglMutexPtr = 1;                // report mutex acquired
                    key = 0;                         // force out of loop
                    }
                }
            }
        }
    while (key == 1);

    globalOpenGLMutexCount = 1;
}

//******************************************************************************
//
// Function: OglReleaseGlobalMutex
//
// Routine Description:
//
//     Release the mutex that protects OpenGL global variables
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID OglReleaseGlobalMutex(void)
{
    globalOpenGLMutex = 0;
    globalOpenGLMutexCount = 0;
}


//*************************************************************************
// bOglServicesDisable
// 
// free everything that was allocated to run opengl especially stuff
// allocated in bOglServicesInit
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglServicesDisable(PPDEV ppdev)
{
    ASSERT (NULL!=ppdev);


    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bOglNegativeClipListDestroy(ppdev);
    }

    OglDisableModeSwitchUpdate(ppdev);

    if (NULL != ppdev->pOglServer)
    {
        EngFreeMem(ppdev->pOglServer);
        ppdev->pOglServer = NULL;
    }

    // for now cannot fail
    return (TRUE);
}


//*************************************************************************
// bOglServicesInit
// 
// Initialize everything needed to run the OpenGL server side.
// This has to be called after a ppdev has been created before the first
// OpenGL app is started.
//
// Call bOglServicesDisable to free this stuff again.
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglServicesInit(PPDEV ppdev)
{
    BOOL bRet = FALSE; // default error exit

    ASSERT (NULL!=ppdev);

    ppdev->pOglServer = EngAllocMem(FL_ZERO_MEMORY, sizeof(OGLSERVER), ALLOC_TAG);
    if (NULL == ppdev->pOglServer)
    {
        DBG_ERROR("bOglServicesInit: failed to initialize ppdev->pOglServer");
        goto Exit;
    }

    OglEnableModeSwitchUpdate(ppdev);

    NV_InitDoubleBufferSavedProcs(ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bOglStereoSurfacesAllowed(ppdev);
        bOglOverlaySurfacesAllowed(ppdev);

        bOglNegativeClipListCreate(ppdev);
    }

    bRet = TRUE;
Exit:
    return (bRet);
}

#if (NVARCH >= 0x4)
//*************************************************************************
// OglReadRegDword
//
// Utility function for OglReadRegistry to read one opengl registry
// entry.  If this fails or if the registry does not exist then
// outVal is not modified
//*************************************************************************

static void OglReadRegDword(
    PDEV *ppdev,
    CHAR *rawName,
    DWORD *outVal)
{
    CHAR fullName[NV_MAX_REG_KEYNAME_LEN + 4];
    WCHAR keyName[NV_MAX_REG_KEYNAME_LEN];
    DWORD fullNameLen, keyNameLen;
    DWORD retStatus;
    DWORD keyVal, keyValSize;

    /* Build a wide name */
    fullName[0] = 0;
    strcat(fullName, "OGL_");
    strcat(fullName, rawName);
    fullNameLen = strlen(fullName)+1;
    ASSERTDD(fullNameLen <= NV_MAX_REG_KEYNAME_LEN, "Key name too long");

    EngMultiByteToUnicodeN(keyName,
                           NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR),
                           &keyNameLen,
                           (PCHAR)fullName,
                           fullNameLen*sizeof(CHAR));

    retStatus = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                   (LPVOID)keyName,
                                   keyNameLen,
                                   (LPVOID)&keyVal,
                                   sizeof(DWORD),
                                   &keyValSize);

    if (retStatus == NO_ERROR) {
        *outVal = keyVal;
    } 
}

//*************************************************************************
// OglReadRegistry
//
// Reads in opengl related regisry settings into ppdev->oglRegXXXX
// entries into the pdev.  This calls into the shared library
// to initialize default registry values consistent with the ICD and
// also calls into the shared library to hack the registry values on
// a per chip/chip type/OS basis.
//*************************************************************************

void OglReadRegistry(
    PDEV *ppdev)
{
    DWORD doUnifiedBuffers;
    DWORD doWindowFlipping;
    DWORD flippingControl;
    DWORD applicationKey;
    DWORD appSupportBits;
    DWORD overlaySupport;
    DWORD apiStereoSupport;
    DWORD apiStereoMode;
#if 0    
    // Grab the defaults from the opengl shared library to be consistent with
    // the ICD.
    __glNVLoadRegistryDefaults(ppdev->hwGfxCaps,
                               &doUnifiedBuffers,
                               &doWindowFlipping,
                               &flippingControl,
                               &applicationKey,
                               &appSupportBits,
                               &overlaySupport,
                               &apiStereoSupport,
                               &apiStereoMode);
#endif
    OglReadRegDword(ppdev, NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER, &doUnifiedBuffers);
    OglReadRegDword(ppdev, NV_REG_OGL_WINDOW_FLIPPING, &doWindowFlipping);
    OglReadRegDword(ppdev, NV_REG_OGL_OVERLAY_SUPPORT, &overlaySupport);
    OglReadRegDword(ppdev, NV4_REG_OGL_BUFFER_FLIPPING_CONTROL, &flippingControl);
    OglReadRegDword(ppdev, NV_REG_OGL_STEREO_SUPPORT, &apiStereoSupport);
    OglReadRegDword(ppdev, NV_REG_OGL_API_STEREO_MODE, &apiStereoMode);
#if 0
    // Apply per OS per chip hacks to the registry through the shared library to
    // be consistent with the ICD.
    __glNVDoRegistryHacks(ppdev->hwGfxCaps,
                          &flippingControl,
                          &doUnifiedBuffers,
                          &doWindowFlipping,
                          &applicationKey,
                          &appSupportBits,
                          &overlaySupport,
                          &apiStereoSupport,
                          &apiStereoMode);
#endif                          
    ppdev->oglRegUBB              = doUnifiedBuffers;
    ppdev->oglRegWindowFlipping   = doWindowFlipping;
    ppdev->oglRegFlippingControl  = flippingControl;
    ppdev->oglRegOverlaySupport   = overlaySupport;
    ppdev->oglRegApiStereoSupport = apiStereoSupport;
    ppdev->oglRegApiStereoMode    = apiStereoMode;
}
#endif // NVARCH >= 0x4


//*************************************************************************
// bOglAssertMode
// 
// has to be called within DrvAssertMode at a point where the hardware 
// is accessible.
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglAssertMode(PPDEV ppdev, BOOL bEnable)
{
    ASSERT (NULL!=ppdev);

    if (bEnable)
    {
        //
        // Enable paused mode again
        //

        if (OglIsEnabled(ppdev))
        {
            // try to enable necessary ogl features.
            bOglPageFlipModeUpdate(ppdev);
            bOglOverlayModeUpdate(ppdev);
            bOglStereoModeUpdate(ppdev);
        }
    }
    else
    {
        //
        // Pause mode (temporariliy disabled)
        //

        if (OglIsEnabled(ppdev))
        {
            // Disable GDI broadcasting
            // pageflipping, stereo shuttering, merge blits, ...
            bOglPageFlipModeDisableAll(ppdev);
            bOglOverlayModeDisable(ppdev);
            bOglStereoModeDisable(ppdev);
        }

        // need to free allocated UBB buffers
        if (ppdev->bOglSingleBackDepthCreated)  
        {
            // Free UBB surfaces, clients must recover
            OglFreeUnifiedSurfaces(ppdev);
        }
    }

    // for now cannot fail
    return TRUE;
}


//*************************************************************************
// bOglResetPDEV
// 
// has to be called in DrvResetPDEV to check if a mode switch is allowed 
// depending on OpenGL settings and active applications.
//
// returns TRUE  if modeswitch is allowed
//         FALSE if modeswitch is not allowed
//*************************************************************************
BOOL bOglResetPDEV(
    PPDEV ppdevOld, // ppdev of mode we're leaving (old mode)
    PPDEV ppdevNew) // ppdev of mode we're switching to (new mode)
{
    BOOL bRet = FALSE; // default error, cannot allow to switch resolution
    BOOL bOld;         // remember old value

    ASSERT(NULL!=ppdevNew);
    ASSERT(NULL!=ppdevOld);

    // Overlays are not supported in all resolutions
    if (   (   (bOld = ppdevOld->bOglOverlayDesired)                   //    overlay was enabled
            || bOglOverlaySurfacesAllowed(ppdevOld) )                  //    or overlays is still enabled
        && (cOglWindows(ppdevOld)>0)                                   // and opengl running
        && !bOglOverlaySurfacesAllowed(ppdevNew)                       // new mode doesn't support overlay
       )
    {
        DISPDBG((0, "ERROR: cannot switch to new mode because OpenGL overlays won't work!"));
        // if registry has changed in the meantime, we lost this value. Reset it!
        ppdevOld->bOglOverlayDesired = bOld; 
        goto Exit;
    }

    // Stereo isn't supported in all resolutions
    if (   (   (bOld = ppdevOld->bOglStereoDesired)                    //    stereo was enabled
            || bOglStereoSurfacesAllowed(ppdevOld) )                   //    or stereo is still enabled
        && (cOglWindows(ppdevOld)>0)                                   // and opengl running
        && !bOglStereoSurfacesAllowed(ppdevNew)                        // new mode doesn't support stereo
       )
    {
        DISPDBG((0, "ERROR: cannot switch to new mode because OpenGL stereo won't work!"));
        // if registry was changed in the meantime, we lost this value. Reset it!
        ppdevOld->bOglStereoDesired = bOld; 
        goto Exit;
    }

    // everything is okay!
    bRet=TRUE;
Exit:
    return (bRet);
}

#ifdef NV_MAIN_MULTIMON
/***************** OGL Multi-Monitor Support functions ******************/
/* See MAIN - oglmultimon.c for similar code.                           */
/************************************************************************/

/*
 * FUNCTION: OglClientIntersectsDevice
 *
 * DESC: Intersects the clientDrawableInfo rect with that of the PDEV
 */ 
BOOL OglClientIntersectsDevice(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    if (!ppdev->bEnabled) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.bottom <= (int)ppdev->top) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.top >= (int)(ppdev->top + ppdev->cyScreen)) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.left >= (int)(ppdev->left + ppdev->cxScreen)) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.right <= (int)ppdev->left) return GL_FALSE;
  
    return TRUE;
}

/************************ Global PDEV management ************************/

/*
 * FUNCTION: OglInitPDEVList
 * 
 * DESC: Initialize the globalOpenGLData PDEV list to NULL 
 * 
 * Called by DrvEnableDriver
 */
void OglInitPDEVList(void)
{
    if (!bLinkedListCreate(&(globalOpenGLData.oglpdevList), LL_CLASS_OGLPDEV))
    {
        /* For some reason our initialization failed */
        DISPDBG((1, "OglInitPDEVList: Error! Can't create the PDEV linked list!"));
        ASSERT(FALSE);
    }
}

/*
 * FUNCTION: OglDestroyPDEVList
 *
 * DESC: Destroys the PDEV List
 *
 * Called by DrvDisableDriver
 */
void OglDestroyPDEVList(void)
{
    /* If we failed here, we are either calling DrvDisableDriver too many times, or 
     * something went terribly wrong.  Either way, we need to print Debug
     * information about this.
     */
    if (!bLinkedListDestroy(&(globalOpenGLData.oglpdevList)))
    { 
        DISPDBG((1, "OglInitPDEVList: Error! Can't destroy the PDEV linked list!"));
        ASSERT(FALSE);
    }
}

/*
 * FUNCTION: OglAddPDEVToList
 *
 * DESC: Adds a PDEV reference node to the globalOpenGLData structure.
 *
 * Called by DrvEnablePDEV
 */
void OglAddPDEVToList(PDEV *ppdev)
{
    bLinkedListAddElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR)ppdev, (PVOID)ppdev, 0);
}

/*
 * FUNCTION: OglRemovePDEVFromList
 *
 * DESC: Removes a matching PDEV from the globalOpenGLData PDEV list.
 *
 * Called by DrvDisablePDEV
 */
void OglRemovePDEVFromList(PDEV *ppdev)
{
    bLinkedListRemoveElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR)ppdev);
}

//
//  bOglGetNextPdev
//
//  Function is an interface for struct LINKEDLIST with. 
//  class LL_CLASS_OGLPDEV. It returns next element in inked. 
//  If *pul is 0, function returns head of list.
//  Function returns TRUE while a new element is found.
//
//  Function should be used as follows:
//
//  PDEV       *ppdevLoop   = NULL;
//
//  while(bOglGetNextPdev(&ppdevLoop))  // loop thru entire oglpdevlist until we find desired listentry
//  {
//      // do something here
//   }
//
BOOL bOglGetNextPdev( IN OUT PPDEV* pppdev )
{
    BOOL   bRet       = FALSE;
    PVOID  pvData     = NULL;

    // we need a valid ppdevlist here
    ASSERT(globalOpenGLData.oglpdevList);
    ASSERT(pppdev);

    if( NULL==*pppdev )
    {
        bRet = bLinkedListGetFirstElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR*)pvData, &pvData);
        if( bRet )
        {
            *pppdev = (PPDEV)pvData;
        }
    }
    else
    {
        bRet = bLinkedListGetNextElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR*)pvData, &pvData);
        if( bRet )
        {
            *pppdev = (PPDEV)pvData;
        }
    }

    return bRet;
}


//
//  bOglRetrieveValidPDEVForDevice
//
//  Function loops thru global ddevList and returns ppdev 
//  which is enabled and belongs to given ulDeviceNumber.
//
BOOL bOglRetrieveValidPDEVForDevice( IN OUT PPDEV* pppdev, IN ULONG ulDeviceNumber )
{
    BOOL bRet = FALSE;
    ASSERT(pppdev);

    *pppdev = NULL;                 // start enumeration at root

    while(bOglGetNextPdev(pppdev))  // loop thru entire ppdevlist until we find desired listentry
    {
        if(  ((*pppdev)->bEnabled)                             // is the ppdev initialized and enabled ?
           &&((*pppdev)->ulDeviceReference == ulDeviceNumber)  // is this the number of coresponding device
          )
        {
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


//
//  bOglRetrieveValidPDEVForOrigin
//
//  Function loops thru global ddevList and returns ppdev 
//  which is enabled and has origin described by lLeft and lTop.
//
BOOL bOglRetrieveValidPDEVForOrigin( IN OUT PPDEV* pppdev, IN LONG lLeft, IN LONG lTop )
{
    BOOL bRet = FALSE;

    ASSERT(pppdev);

    *pppdev = NULL;                             // start enumeration at root

    while(bOglGetNextPdev(pppdev))              // loop thru entire ppdevlist until we find desired listentry
    {
        if(  ((*pppdev)->bEnabled)              // is the ppdev initialized and enabled ?
           &&((*pppdev)->left == (ULONG)lLeft)  // does origin fit devices origin ?
           &&((*pppdev)->top  == (ULONG)lTop )  // does origin fit devices origin ?
          )
        {
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglutils.h ===
#ifndef __OGLUTILS_H
#define __OGLUTILS_H

/*
**
** MODULE: oglutils.h
**
** little opengl helper functions should reside here
**
** Copyright (C) 2000 NVidia Corporation. All Rights Reserved.
**
*/

void __cdecl NV_OglDDrawSurfaceCreated(PDEV *);
void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *);
BOOL  bOglDirectDrawAppRunning(PPDEV);
BOOL  bOglPOWERlibAppRunning(PPDEV);
BOOL  bOglIsVisibleClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsUnclippedClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsFullscreenClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsComplexClippedClient(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglHasDrawableInfo(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglGetNextClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL  bOglGetNextVisibleClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
ULONG cOglVisibleClients(PPDEV ppdev);
ULONG cOglWindows(PPDEV ppdev);

void CreateOglGlobalMemory(PDEV *);
void DestroyOglGlobalMemory(PDEV *);
void OglDisableModeSwitchUpdate(PDEV *);
void OglEnableModeSwitchUpdate(PDEV *);
BOOL OglLockDownMemory(PDEV *, ULONG);
BOOL OglUnlockMemory(PDEV *ppdev);

BOOL bOglServicesInit(PPDEV ppdev);
BOOL bOglServicesDisable(PPDEV ppdev);
BOOL bOglAssertMode(PPDEV ppdev, BOOL bEnable);
BOOL bOglResetPDEV(PPDEV ppdevOld, PPDEV ppdevNew);

#ifdef NV_MAIN_MULTIMON
void OglInitPDEVList(void);
void OglDestroyPDEVList(void);
BOOL OglClientIntersectsDevice(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
void OglSyncEngineUsingPDEV(PDEV *ppdev);
void OglAddPDEVToList(PDEV *ppdev);
void OglRemovePDEVFromList(PDEV *ppdev);

BOOL bOglGetNextPdev( IN OUT PPDEV* pppdev );
BOOL bOglRetrieveValidPDEVForDevice( IN OUT PPDEV* pppdev, IN ULONG ulDeviceNumber );
BOOL bOglRetrieveValidPDEVForOrigin( IN OUT PPDEV* pppdev, IN LONG lLeft, IN LONG lTop );
#endif

DWORD GetCurrentProcessID(VOID);
#endif //#ifndef __OGLUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\precomp.h ===
/******************************Module*Header***********************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\******************************************************************************/

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#ifndef _WIN32_WINNT     // NT 3.5
#include <stdio.h>
#endif                  // NT 3.5
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>

#if _WIN32_WINNT < 0x0500
typedef  ULONG ULONG_PTR;
__inline ULONG PtrToUlong(PVOID p) { return((ULONG) p); }
#endif

#if _WIN32_WINNT >= 0x0500
#define  __NTDDKCOMP__
#if DX8
#include <d3d8.h>
#include <ddrawint.h>
#else
#include <d3d.h>
#endif
#endif

#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#ifndef _WIN32_WINNT    // If this is NT 3.5x
#include <windows.h>    // NT 3.5, need Win32 API Fct Protos
#endif                  // If this is >= NT 4.0
#include <gl\gl.h>

#include "lines.h"
#ifdef NVD3D
#include "nvProcMan.h"
    #include "dmemmgr.h"
#endif
#include "memstruc.h"
#include "nvos.h"
#include "nvntioctl.h"
#include "nvEscDef.h"
#if defined(_WIN64)
#include "nvEscDef32.h"
#endif

// This file used to include driver.h but that included (indirectly) nv32.h
// Some of the files in the winnt4/displays/nv_disp directory needed to use specialized (older)
// versions of nv32.h (eg: nv1_32.h, oldnv332.h).  To resolve this issue (for now)
// I've moved the inclusion of driver.h into each of the files that needed it.  This allows
// each to include any specialized version of the nv32 header as needed.  -mlavoie

#include "debug.h"
#include "machdep.h"
#include "nvMultiMon.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\palette.c ===
//******************************Module*Header***********************************
//
// Module Name: palette.c
//
// Palette support.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.
PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

//******************************************************************************
//
//  Function:   bInitializePalette
//
//  Routine Description:
//
//      Initializes default palette for PDEV.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)

    {
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    //**********************************************************************
    // Allocate our palette. We create a default 256 color palette for
    // all the video modes. The reason for this is that we need to store
    // an 8BPP palette in the PDEV since DrvSetCursorShape can be called
    // with an 8BPP bitmap and an XLATEOBJ with no RGB values. In this case
    // we use the default palette RGB values to convert it to 16BPP, which
    // is what our color cursor hw requires.
    //**********************************************************************

    ppal = (PALETTEENTRY *) EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, ALLOC_TAG);
    if (ppal == NULL)
        goto ReturnFalse;

    ppdev->pPal = ppal;

    //**********************************************************************
    // Generate 256 (8*4*4) RGB combinations to fill the palette
    //**********************************************************************

    jRed = 0;
    jGre = 0;
    jBlu = 0;

    ppalTmp = ppal;

    for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
        ppalTmp->peRed   = jRed;
        ppalTmp->peGreen = jGre;
        ppalTmp->peBlue  = jBlu;
        ppalTmp->peFlags = 0;

        ppalTmp++;

        if (!(jRed += 32))
            if (!(jGre += 32))
                jBlu += 64;
        }

    //**********************************************************************
    // Fill in Windows reserved colours from the WIN 3.0 DDK
    // The Window Manager reserved the first and last 10 colours for
    // painting windows borders and for non-palette managed applications.
    //**********************************************************************

    for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
        //******************************************************************
        // First 10
        //******************************************************************

        ppal[ulLoop]       = gapalBase[ulLoop];

        //******************************************************************
        // Last 10
        //******************************************************************

        ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

    //**********************************************************************
    // Get handle for palette from GRE.
    //**********************************************************************

    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
        }
    else

        {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_24BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
        }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((2, "Failed bInitializePalette"));
    return(FALSE);
    }

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

//******************************************************************************
//
//  Function:   bEnablePalette
//
//      Initialize the hardware's 8bpp palette registers.
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnablePalette(PDEV* ppdev)

    {
    ULONG i, j;
    ULONG ulHead, ulOffset;



    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        //**********************************************************************
        // Set palette using hardware specific routine
        // (Specify start and length)
        //**********************************************************************

		for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    	{
        	ulHead = ppdev->ulDeviceDisplay[i];
	        ulOffset = ulHead*256;
   
    	    for(j = 0 ; j < 256; j++)
        	{
	            ppdev->ajClutData[j + ulOffset].Red =    ppdev->pPal[j].peRed >>
                                          ppdev->cPaletteShift;
    	        ppdev->ajClutData[j + ulOffset].Green =  ppdev->pPal[j].peGreen >>
                                          ppdev->cPaletteShift;
        	    ppdev->ajClutData[j + ulOffset].Blue =   ppdev->pPal[j].peBlue >>
                                          ppdev->cPaletteShift;
	            ppdev->ajClutData[j + ulOffset].Unused = 0;
    	    }
	    }
        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));
    }


    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
    }

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PDEV*           ppdev = (PDEV *) dhpdev;
    UCHAR   cTemp;
    ULONG i;
    ULONG ulHead, ulCount;
    ULONG ulOffset;

    UNREFERENCED_PARAMETER(fl);

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);
    
    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.
   	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulCount = cColors;
        ulOffset = ppdev->ulDeviceDisplay[i] * 256;

        if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                         (ULONG*) (ppdev->ajClutData+ulOffset)))
        {
            DISPDBG((2, "DrvSetPalette failed PALOBJ_cGetColors"));
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return (FALSE);
        }

        if (ppdev->cPaletteShift)
        {
            while(ulCount--)
            {
                cTemp = ppdev->ajClutData[ulCount+ulOffset].Red >> ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Red = ppdev->ajClutData[ulCount+ulOffset].Blue >> ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Blue = cTemp;
                ppdev->ajClutData[ulCount+ulOffset].Green >>= ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Unused = 0;
            }
        }
        else
        {
            while(ulCount--)
            {
                cTemp = ppdev->ajClutData[ulCount+ulOffset].Red;
                ppdev->ajClutData[ulCount+ulOffset].Red = ppdev->ajClutData[ulCount+ulOffset].Blue;
                ppdev->ajClutData[ulCount+ulOffset].Blue = cTemp;
                ppdev->ajClutData[ulCount+ulOffset].Unused = 0;
            }
        }
    }

    //**************************************************************************
    // Setup the palette using hardware specific routine
    // (Specify start and length)
    //**************************************************************************

    if(ppdev->bEnabled) // Incomplete fix for the av in V4DmaPushSetPalette if acceleration is disabled.
        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));
    else
    {
        PVIDEO_CLUTDATA pScreenClutData;

        ulCount = cColors;
        pScreenClutData = (PVIDEO_CLUTDATA)(&(pScreenClut->LookupTable[0]));

        if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                         (ULONG*)pScreenClutData))
        {
            DISPDBG((2, "DrvSetPalette failed PALOBJ_cGetColors"));
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return (FALSE);
        }

        if(ppdev->cPaletteShift)
        {
            while(ulCount--)
            {
                pScreenClutData[ulCount].Red >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Green >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Blue >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Unused = 0;
            }
        }
        else
        {
            while(ulCount--)
            {
                pScreenClutData[ulCount].Unused = 0;
            }
        }

        if(EngDeviceIoControl(ppdev->hDriver,
                              IOCTL_VIDEO_SET_COLOR_REGISTERS,
                              pScreenClut,
                              MAX_CLUT_SIZE,
                              NULL,
                              0,
                              &ulCount))
        {
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return(FALSE);
        }
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    return(TRUE);

}

/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
*
* DDI entry point for setting gamma ramp.
*
\**************************************************************************/
ULONG
nvSetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals)
{
    ULONG nNumEntries = 256;
    ULONG nStartIndex = 0;
    ULONG i, ulHead, ulDevice, ulOffset;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        for(ulDevice = 0; ulDevice < ppdev->ulNumberDacsActive; ulDevice++)
        {
            ulHead = ppdev->ulDeviceDisplay[ulDevice];
            ulOffset = ulHead * 256;

            for (i = 0; i < nNumEntries; i++) 
            {
                ppdev->ajClutData[i + ulOffset].Blue  = (UCHAR) (fpRampVals[512 + i] >> 8); /* blue value */
                ppdev->ajClutData[i + ulOffset].Green = (UCHAR) (fpRampVals[256 + i] >> 8); /* green value */
                ppdev->ajClutData[i + ulOffset].Red   = (UCHAR) (fpRampVals[i] >> 8); /* red value */
            }
        }

        ppdev->pfnSetPalette(ppdev, (nStartIndex << 2) , (nNumEntries << 2) );
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* ULONG nvGetGammaRamp
*
* DDI entry point for getting gamma ramp.
*
\**************************************************************************/
ULONG
nvGetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals)
{

    unsigned short i;
    unsigned long nNumEntries = 256;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        for (i = 0; i < nNumEntries; i++) 
        {
            fpRampVals[512 + i] = ((USHORT)ppdev->ajClutData[i].Blue << 8); // blue value
            fpRampVals[256 + i] = ((USHORT)ppdev->ajClutData[i].Green << 8);// green value
            fpRampVals[i]       = ((USHORT)ppdev->ajClutData[i].Red << 8);  // red value
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


#if _WIN32_WINNT >= 0x0500
/*****************************************************************************\
*   BOOL    DrvIcmSetDeviceGammaRamp
*
*   DDI entry point for setting gamma ramp.
*
*   iFormat == IGRF_RGB_256WORDS (always)
*   lpRamp == pointer to GAMMARAMP structure.
*   where       typedef struct _GAMMARAMP {
*                   WORD Red[256];
*                   WORD Green[256];
*                   WORD Blue[256];
*               } GAMMARAMP, *PGAMMARAMP;
*
\*****************************************************************************/

BOOL
DrvIcmSetDeviceGammaRamp(
    DHPDEV  dhpdev,
    ULONG   iFormat,
    LPVOID  lpRamp
)
{
    PPDEV           ppdev = (PPDEV)dhpdev;
    WORD *          pwGamma;
    ULONG i, ulHead, ulDevice, ulOffset;

    //
    //  Sanity check
    //

    if(iFormat == IGRF_RGB_256WORDS)
    {
        pwGamma = lpRamp;

        //
        //  Enable PIXMIX
        //
//        dwRet = EngDeviceIoControl(
//            ppdev->hDriver,
//            IOCTL_VIDEO_ENABLE_PIXMIX_INDEX,
//            NULL, 0,
//            NULL, 0,
//            &dwReturnedDataLength
//            );

        //
        //  Copy gamma ramp
        //
        for(ulDevice = 0; ulDevice < ppdev->ulNumberDacsActive; ulDevice++)
        {
            ulHead = ppdev->ulDeviceDisplay[ulDevice];
            ulOffset = ulHead * 256;

            for(i = 0; i < 256; i++)
            {
                ppdev->ajClutData[i + ulOffset].Red = (UCHAR)(pwGamma[i] >> 8);
                ppdev->ajClutData[i + ulOffset].Green = (UCHAR)(pwGamma[256 + i] >> 8);
                ppdev->ajClutData[i + ulOffset].Blue = (UCHAR)(pwGamma[(2*256) + i] >> 8);
                ppdev->ajClutData[i + ulOffset].Unused = 0;
            }
        }

        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));

        return(TRUE);
    }
    
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pointer.c ===
//******************************Module*Header***********************************
//
// Module Name: pointer.c
//
// This module contains the hardware pointer support for the display
// driver.  This supports both the built-in S3 hardware pointer and
// some common DAC hardware pointers.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 - 2000 NVidia Corporation. All Rights Reserved.        *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nv32.h"

//******************************************************************************
// External declarations
//******************************************************************************

VOID ShowPointer(PDEV*   ppdev, BOOL bShow);

#ifdef NV3
extern VOID NV3MovePointer(PDEV *,LONG,LONG);
extern VOID NV3EnablePointer(PDEV *,BOOL);
extern ULONG NV3SetPointerShape(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
#else
extern VOID NVMovePointer(PDEV *,LONG,LONG);
extern VOID NVEnablePointer(PDEV *,BOOL);
extern ULONG NVSetPointerShapeOn16BppHwMode(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
extern ULONG NVSetPointerShapeOn32BppHwMode(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
#endif
//******************************************************************************
//
//  Function:   DrvMovePointer
//
//  Routine Description:
//
//  NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
//        time, even while we're executing another drawing call!
//
//        Consequently, we have to explicitly synchronize any shared
//        resources.  In our case, since we touch the CRTC register here
//        and in the banking code, we synchronize access using a critical
//        section.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*   ppdev;
    BOOL    bRet;

    ppdev = (PDEV*) pso->dhpdev;
    if (x == -1)
    {
    //**************************************************************************
    // This is a request to hide the cursor.
    //**************************************************************************
    ppdev->pfnShowPointer(ppdev, FALSE);
    }
    else
    {
        //**************************************************************************
        // Move cursor to appropriate location
        //**************************************************************************
        ppdev->pfnMovePointer(ppdev, x, y);

#if _WIN32_WINNT >= 0x0500
        if(ppdev->ulPuntCursorToGDI)
            {
            ppdev->pfnWaitEngineBusy(ppdev);
            EngMovePointer(pso, x, y, prcl);
            }
#endif

    }

}

//******************************************************************************
//
//  Function:   DrvSetPointerShape
//
//  Routine Description:
//
//      Sets the new pointer shape.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)

    {
    PDEV*   ppdev;
    DWORD*  pul;
    ULONG   cx;
    ULONG   cy;
    BOOL    AlphaBlendedCursor;
    ULONG   ulReturnValue;
        
    ppdev = (PDEV*) pso->dhpdev;

    ulReturnValue = SPS_DECLINE;

    if (ppdev->flCaps & CAPS_SW_POINTER || !ppdev->bEnabled)
        goto DoneDrvSetPointerShape;

#if _WIN32_WINNT >= 0x0500

    if ( (fl & SPS_ALPHA) && (psoMsk == NULL) && (psoColor != NULL) )
        {
        //**********************************************************************
        // Handle Win2k Alpha blended cursors (ONLY if OpenGL is enabled)
        // Normally, we wouldn't attempt to handle alpha blended cursors because
        // our hardware doesn't support alpha blended cursors.
        // Unfortunately, when OpenGL is enabled, the alpha blended software cursor
        // is not visible on top of an OpenGL app.  So we're forced to 'handle' 
        // this case with our opaque hardware cursor, so that we can see the cursor.
        //
        // 2 side effects:
        //      1) Hardware only supports 32x32 cursors (up to NV5)
        //         So Alpha Blended cursors which width > 32 and height > 32
        //         may get clipped abruptly.
        //
        //      2) We ignore the alpha blended component of the bitmap
        //          and just make it transparent.
        //**********************************************************************

        cx = psoColor->sizlBitmap.cx;           
        cy = psoColor->sizlBitmap.cy;           
        AlphaBlendedCursor = TRUE;

        }    


    else

#endif
    
        {

        //**********************************************************************
        // Our old documentation says that 'psoMsk' may be NULL, which means
        // that the pointer is transparent.  Well, trust me, that's wrong.
        // I've checked GDI's code, and it will never pass us a NULL psoMsk:
        //**********************************************************************

        AlphaBlendedCursor = FALSE;

        // psoMsk is for monochrome cursors
        //
        cx = psoMsk->sizlBitmap.cx;             // Note that 'sizlBitmap.cy' accounts
        cy = psoMsk->sizlBitmap.cy >> 1;        //   for the double height due to the
                                                //   inclusion of both the AND masks
                                                //   and the XOR masks.  For now, we're
                                                //   only interested in the true
                                                //   pointer dimensions, so we divide
                                                //   by 2.
        }
        
    ulReturnValue = (ULONG)(ppdev->pfnSetPointerShape(pso, psoMsk, psoColor, pxlo, x,y, xHot, yHot, cx, cy, AlphaBlendedCursor));

    if(ulReturnValue == SPS_DECLINE)
    {
        //**************************************************************************
        // Hide HW cursor going to SW cursor
        //**************************************************************************

        ppdev->pfnShowPointer(ppdev, FALSE);
    }

DoneDrvSetPointerShape:

    if( ulReturnValue == SPS_DECLINE)
    {
        ppdev->ulDriverNotSupportPanScan = TRUE;
        ppdev->bIsSWPointer              = TRUE;

#if _WIN32_WINNT >= 0x0500
        // punt back to GDI and keep track of mouse movement in DrvMovePointer
        if(EngSetPointerShape(pso, psoMsk, psoColor, pxlo, xHot, yHot, x, y, prcl, fl) != SPS_ACCEPT_EXCLUDE)
        {
            ppdev->ulPuntCursorToGDI = FALSE;
        }
        else
        {
            ulReturnValue = SPS_ACCEPT_NOEXCLUDE;
            ppdev->ulDriverNotSupportPanScan = FALSE;
            ppdev->ulPuntCursorToGDI = TRUE;
        }
#endif

    }
    else
    {
        ppdev->ulDriverNotSupportPanScan = FALSE;
        ppdev->bIsSWPointer              = FALSE;
    }

    return(ulReturnValue);

    }

//******************************************************************************
//
//  Function:   vDisablePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vDisablePointer(
PDEV*   ppdev)
    {
        if (ppdev->flCaps & CAPS_SW_POINTER)
            return;

        if(ppdev->pfnEnablePointer)
        {
            ppdev->pfnEnablePointer(ppdev, FALSE);
        }
    }

//******************************************************************************
//
//  Function:   vAssertModePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)

    {
    ULONG*  pulDst;
    LONG    i;
    LONG    lPointerShape;

    //**************************************************************************
    // With a software pointer, we don't have to do anything.
    //**************************************************************************

    if (ppdev->flCaps & CAPS_SW_POINTER)
        return;

    //**************************************************************************
    // Turn off the hardware cursor
    //**************************************************************************

    if(ppdev->pfnEnablePointer)
        ppdev->pfnEnablePointer(ppdev, bEnable);

    }

//******************************************************************************
//
//  Function:   bEnablePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnablePointer(
PDEV*   ppdev)

    {
    RECTL       rclDraw;
    RECTL       rclBank;
    LONG        iBank;
    LONG        cjOffset;
    LONG        cjOffsetInBank;

    //**************************************************************************
    // With a software pointer, we don't have to do anything.
    //**************************************************************************

    if (ppdev->flCaps & CAPS_SW_POINTER)
        return(TRUE);

    //**************************************************************************
    // Check what type of hardware cursor to enable (NV1/NV3)
    //**************************************************************************

    ppdev->pfnShowPointer     = ShowPointer;
#ifdef NV3
    ppdev->pfnMovePointer     = NV3MovePointer;
    ppdev->pfnSetPointerShape = NV3SetPointerShape;
    ppdev->pfnEnablePointer   = NV3EnablePointer;
#else
    if (ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV10_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV05_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV04_VIDEO_LUT_CURSOR_DAC) {
        ppdev->pfnMovePointer     = NVMovePointer;
        ppdev->pfnEnablePointer   = NVEnablePointer;
    } else {
        // Error
        ASSERTDD(0,"No supported VIDEO_LUT_CURSOR_DAC object created");
    }

    switch(ppdev->CurrentClass.VideoLutCursorDac)
    {
        case NV10_VIDEO_LUT_CURSOR_DAC:
        case NV05_VIDEO_LUT_CURSOR_DAC:
        case NV04_VIDEO_LUT_CURSOR_DAC:
            ppdev->pfnSetPointerShape = NVSetPointerShapeOn16BppHwMode;
            break;
        default:
            // all NV newer chips should be able to handle 32Bpp cursor.
            ppdev->pfnSetPointerShape = NVSetPointerShapeOn32BppHwMode;
            break;
    }
#endif // NV3
    
    //**************************************************************************
    // Actually turn on the pointer:
    //**************************************************************************

    vAssertModePointer(ppdev, TRUE);

    DISPDBG((5, "Passed bEnablePointer"));

    return(TRUE);
    }



//******************************************************************************
//
//  Function:   ShowPointer
//
//  Routine Description:
//
//      Show or hide the hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ShowPointer(
PDEV*   ppdev,
BOOL    bShow)      // If TRUE, show the pointer.  If FALSE, hide the pointer.

    {
    LONG    x;
    LONG    y;

    if (bShow)
        {
        //**********************************************************************
        // Make the hardware pointer visible:
        //**********************************************************************

        x  = ppdev->xPointer;
        y  = ppdev->yPointer;
        }

    else

        {
        //**********************************************************************
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:
        //**********************************************************************

        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
        }

    //*************************************************************************
    // Enable/Disable cursor by moving to new position
    //*************************************************************************

    ppdev->pfnMovePointer(ppdev, x, y);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* This module contains the functions that set and describe pixel formats.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop

#if (NVARCH >= 0x4)
#include "wincommon.h"
#include "wglcommon.h"
#include "nvapi.h"
#include "Nvcm.h"
#endif // (NVARCH >= 0x4)
#include "oglDD.h"
#include "OglOverlay.h"

#include "nvReg.h"

//
// export
//


#ifdef NV3
#define NUM_NV_PIXELFORMATS_16BPP  4

static PIXELFORMATDESCRIPTOR
NVPixelFormats16Bpp555[NUM_NV_PIXELFORMATS_16BPP] =
{
    /*
    ** 16 bit
    */
    // Single Buffer, No Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                                          // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_SUPPORT_GDI,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        0,                                          // NO stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Single Buffer, With Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                                          // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_SUPPORT_GDI,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        8,                                          // stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Double Buffer, No Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                      // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_DOUBLEBUFFER |
        PFD_SWAP_COPY,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        0,                                          // NO stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Double Buffer, With Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                      // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_DOUBLEBUFFER |
        PFD_SWAP_COPY,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        8,                                          // stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    }
};

LONG APIENTRY NV3DescribePixelFormat(
    LONG                  iPixelFormat,
    ULONG                 cjpfd,
    PIXELFORMATDESCRIPTOR *ppfd)
{
    DWORD size;

    if (ppfd &&
        (iPixelFormat > 0) &&
        (iPixelFormat <= NUM_NV_PIXELFORMATS_16BPP)) {
        size = (cjpfd < sizeof(PIXELFORMATDESCRIPTOR)) ?
            cjpfd : sizeof(PIXELFORMATDESCRIPTOR);
        memcpy(ppfd, &NVPixelFormats16Bpp555[iPixelFormat-1], size);
    }

    return NUM_NV_PIXELFORMATS_16BPP;
}
#endif

//******************************************************************************
//
//  Function:   DrvSetPixelFormat
//
//  Routine Description:
//
//      Implements the set pixel format ICD routine.  This routine is called
//      by OpenGL32.DLL to set the pixel format to the value in iPixelFormat.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE is the pixel format is set, FALSE otherwise.
//
//******************************************************************************
BOOL APIENTRY DrvSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd
)
{
    int i;
    PDEV                  *ppdev = (PDEV *)pso->dhpdev;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    if (ppdev)
        {

        if (OglSupportEnabled(ppdev) == (ULONG)FALSE)
                    {
            DISPDBG((2, "SetPixelFormat: OglSupportEnable FAILED!", 0, ppdev->cBitsPerPel));
            return FALSE;
                    }

        clientList = OglFindClientInfoFromHWnd(ppdev, hWnd);
        if (clientList)
            {
            clientInfo = &clientList->clientInfo;
            }

        if (clientInfo && clientInfo->clientDrawableInfo)
        {
            clientInfo->clientDrawableInfo->iPixelFormat = iPixelFormat;
        }
    
        return TRUE;
        }
        
    else
    
        {
        return(FALSE);
        }

}

//*************************************************************************
// bOglStereoSurfacesAllowed
// 
// returns TRUE if the current environment, depending on quadro, 
// resolution and registry allows stereo
//*************************************************************************
BOOL bOglStereoSurfacesAllowed(PPDEV ppdev)
{
    ASSERT( ppdev );

    ppdev->bOglStereoDesired = FALSE;

#if (NVARCH >= 0x4)
    if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
    {
        // do we have enough frambuffer memory to enable overlay ?
        ASSERT(ppdev->cyScreen > 0);
        ASSERT(ppdev->cyScreen < ppdev->cyMemory);
        OglReadRegistry(ppdev);

        //     room for 6 fullscreen buffer:    front*2+back*2+Z*2
        if(ppdev->cyMemory >= (LONG)(ppdev->cyScreen*6) )
        {
            if (ppdev->oglRegApiStereoSupport != NV_REG_OGL_STEREO_SUPPORT_OFF)
            {
                ppdev->bOglStereoDesired = TRUE;
            }
        }
    }
#endif //(NVARCH >= 0x4)
    return (ppdev->bOglStereoDesired);
}


/*
** bOglPfdCheckFlags
** 
** depending on registry, frambuffer size and other restricting 
** things return a mask with pixelformats types we allow.
** 
** FNicklisch 13.11.2000: New
*/ 
BOOL bOglPfdCheckFlags(PPDEV ppdev, ULONG *pulPfdCheckFlags)
{
#if (NVARCH >= 0x4)
    ASSERTDD(!bOglOverlaySurfacesAllowed(ppdev) || !bOglStereoSurfacesAllowed(ppdev), "stereo AND overlays not supported!");

    if( bOglOverlaySurfacesAllowed(ppdev) )
    {
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_OVERLAYS;
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_SWAP_LAYER_BUFFERS;
    }
         //
    else // KEY: workaround for never overlays and stereo at same time!
         //
    if( bOglStereoSurfacesAllowed(ppdev) )
    {
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_STEREO;
    }
#else
    ppdev;            // unused parameter
    pulPfdCheckFlags;
#endif
    return (TRUE);
}

//******************************************************************************
//
//  Function:   DrvDescribePixelFormat
//
//  Routine Description:
//
//      Implements the routine which informs OpenGL32.DLL of our supported
//      pixel formats.
//
//  Known Problems:
//     
//     Make sure tbis method is consistent with icdcmd.c/DrvDescribePixelFormat [only NT4/NT5 goes through disp]
//
//  Arguments:
//
//  Return Value:
//
//      Number of pixel formats supported
//
//******************************************************************************
LONG APIENTRY DrvDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd
)
{
    LONG result;
    DWORD size;
    PDEV  *ppdev;
    __WINNVpixelFormatFlags winPFFlags;

    DISPDBG((1, "DrvDescribePixelFormat: Entry iPixelFormat %ld",
             iPixelFormat));

    ppdev = (PDEV *)dhpdev;

#ifdef _WIN64
    // For some reason we die with an unspeakable backtrace when we
    // call __wglNVDescribePixelFormat after returning FALSE for
    // the OPENGL_INFO escape.  Return to it someday, but for now ...

    if (!(ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)) {
        DISPDBG((2, "DrvDescribePixelFormat: !ppdev->oglWorkStationPart!"));
        result = 0;
    } else
#endif
    if (OglSupportEnabled(ppdev) == (ULONG)FALSE) {
        DISPDBG((2, "DrvDescribePixelFormat: OglSupportEnabled FAILED!"));
        result = 0;
    } else {
#ifdef NV3
        if (ppdev->cBitsPerPel == 16) {
            result = NV3DescribePixelFormat(iPixelFormat, cjpfd, ppfd);
        } else {
            result = 0;
        }
#else        
        OglReadRegistry(ppdev);
                                     
        winPFFlags.color16depth32  = ppdev->oglColor16Depth32;
        winPFFlags.color32depth16  = ppdev->oglColor32Depth16; 
        winPFFlags.multisample     = ppdev->oglMultisample;
        winPFFlags.flippingControl = ppdev->oglRegFlippingControl;
        winPFFlags.unifiedBuffers  = ppdev->oglRegUBB; 

        result = 0;
#if 0
         __wglNVDescribePixelFormat(
            (int)ppdev->cBitsPerPel,
            0,
            (int)iPixelFormat,
            (UINT)cjpfd,
            ppfd,
            NULL,
            NULL,
            &winPFFlags,
            FALSE,
            (void *) ppdev);
#endif
#endif // NV3
    }
    
    DISPDBG((2, "DrvDescribePixelFormat: Exit %ld %ld",
             0, ppdev->cBitsPerPel));

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\rectutils.c ===
/*
** $Header$
**
** MODULE:   rectutils.c
**
** AUTHOR:   FNicklisch, (c) nVidia GmbH
**
** DESCR:    Basic rectangle functions for Top Down coordinates
**           Bottom Up coordinates have BU at end of name
**
** History:
**   FNicklis 28.03.1996: created      
**   db       23.09.1996: RectDrawSingle added
**   KLux     05.11.1997: New enumeration functions for complex lists
**   FNicklis 11.12.1997: moved prototypes from enum.h
**   FNicklis 13.05.1998: remaming of inlines completed
**   FNicklis 19.06.1999: used in nVidia single and multiboard driver branches
**   FNicklis 10.08.1999: ported to OpenGL project
**   FNicklis 25.08.1999: new functions for Bottom Up coordinate space
**   FNicklisch 05.07.2001: ported to nvidia
*/

#include "precomp.h"
#include "driver.h"

// export
#include "rectutils.h"

/*
** ************************************************************************ 
** * main routines, chip independent                                      *
** ************************************************************************
*/

/*
** lRclMinusRcl
**
** calculates rclBounds - rclMinus, which may have 0 to 4 
** resulting rectangles stored in the prclResult array.
**
** return:
**   1-4 number of resulting rects stored in prclResult
**   0   nothing left from rclBounds, no rectangle stored.
**
** FNicklis 11.07.97: New
** FNicklis 21.10.98: simplified interface
*/
LONG lRclMinusRcl(OUT RECTL prclResult[],
                    IN  const RECTL *prclBounds, 
                    IN  const RECTL *prclMinus)
{
    RECTL rclWork;          // Copy of rclBounds we work on.
    RECTL rclHelp = {0};    // Intersecting rect between bounds and minus (part of minus within bounds)
    LONG  lRects  = 0;      // default exit
    
    ASSERTDD(NULL!=prclResult, "lRclMinusRcl: NULL==prclResult");
    ASSERTDD(NULL!=prclBounds, "lRclMinusRcl: NULL==prclBounds");
    //ASSERTDD(NULL!=prclMinus,   "lRclMinusRcl: NULL==prclMinus");
    
    // Minus is a non recangle (point) inside Bounds?
    if (   (NULL==prclMinus)
        || ( bRclIsEmpty(prclMinus) && bRclIsIn(prclBounds, prclMinus) ) ) 
    { 
        // e.g. where pwo->coClient.rclBounds is a nul-rect on OGL-startup
        // Nothing to substract
        DISPDBG((DBG_LVL_RECT, "minus is 0 and inside prclBounds"));
        *prclResult = *prclBounds;
        lRects        = 1;
        goto Exit;
    }
    
    // if bounds is completely inside minus -> trivial case
    if (bRclIsIn (prclMinus, prclBounds)) 
    { // Bounds inside Minus?
        DISPDBG((DBG_LVL_RECT, "bounds is inside minus, nothing left"));
        *prclResult = *prclBounds;
        lRects        = 0;
        goto Exit;
    }
    
    // if bounds isn't intersecting minus -> trivial case
    if (   !bRclIntersect(&rclHelp, prclBounds, prclMinus)
        || bRclIsEmpty(&rclHelp) )
    {
        DISPDBG((DBG_LVL_RECT, "not intersection (trivial case)"));
        *prclResult = *prclBounds;
        lRects        = 1;
        goto Exit;
    }
    
    // No we have the rect that has to be cut form bounds inside 
    // rclHelp. We make a copy of bounds (work) and run around help cutting
    // of overlapping parts from work. These parts are stored to the array.
    // The last remaing rect in work has to be equal help!
    
    //              H=minus rect
    //   111111111               11 111 111 11
    //   111111111               2H hhh 2H3 H2
    //   222HHH333               
    //   222HHH333               11      1  11
    //   222444333               2H 1H2  H  H2
    //   222444333               23      2  32
    //                           
    //
    rclWork = *prclBounds;
    
    // take rect above rclHelp
    prclResult[lRects].top    = rclWork.top;    
    prclResult[lRects].left   = rclWork.left;   
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclHelp.top;  // ***
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.top = rclHelp.top;
        lRects++;
    }
    
    // take rect on the left side of rclHelp
    prclResult[lRects].top    = rclWork.top;
    prclResult[lRects].left   = rclWork.left;
    prclResult[lRects].right  = rclHelp.left; // ***
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.left = rclHelp.left;
        lRects++;
    }
    
    // take rect on the right side of rclHelp
    prclResult[lRects].top    = rclWork.top;
    prclResult[lRects].left   = rclHelp.right; // ***
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.right = rclHelp.right;
        lRects++;
    }
    
    // take remaing rect below rclHelp
    prclResult[lRects].top    = rclHelp.bottom; // ***
    prclResult[lRects].left   = rclWork.left;
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.bottom = rclHelp.bottom;
        lRects++;
    }
    
Exit:
    return(lRects);
} // lRclMinusRcl


/*
** lRclIntersectExclude
**
** stores a In rect to a Out rect cliped against bounds minus Exclude.
** This can result in up to four rectangles!
**
** out = (In - Exclude) & Bounds
**
** bounds, 
**
** Returns number of resulting rects.
**
** FNicklis 08.10.98: New
*/
LONG lRclIntersectExclude(
  OUT RECTL *prclOut,        // array of up to four resulting rectangles
  IN const RECTL  *prclIn,         // rect stored to Out
  IN const RECTL  *prclBounds,     // Has to be clipped against In
  IN const RECTL  *prclExclude)    // exclude must not be part of Out
{
  LONG lRet = 0;

  if (prclBounds)
  {
    // calculate intersection
    if (bRclIntersect(prclOut, prclIn, prclBounds))
    {
      lRet++;
    }
  }
  else
  {
    *prclOut = *prclIn;
    lRet++;
  }

  if ( (0 != lRet) && (NULL!=prclExclude) )
  {
    RECTL rclTemp = *prclOut; // Make a copy!

    // exclude prclExclude this rectangle from prclOut
    // this gives up to four new rectangles!

    // substract exclude from out
    lRet = lRclMinusRcl(prclOut, &rclTemp, prclExclude);
  }

#ifdef DEBUG
  // preset the unused rectangles to show a failure in screen!
  if ( 0 == lRet )
  {
    LONG l;
    for (l=0;l<4;l++)
      prclRclSetXYWH(prclOut+l, 0,0, 1024,768); // don't have ppdev, hardcoded rectangle
  }
#endif

  return (lRet);
}


// functions tests if prclSubject is left or above the prclReference
BOOL bIsLeftOrAbove(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsLeftOrAbove);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->right <= prclReference->left)
    bRet = TRUE;
  else
    if (prclSubject->bottom <= prclReference->top)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is right or above the prclReference
BOOL bIsRightOrAbove(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsRightOrAbove);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->left >= prclReference->right)
    bRet = TRUE;
  else
    if (prclSubject->bottom <= prclReference->top)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is left or below the prclReference
BOOL bIsLeftOrBelow(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsLeftOrBelow);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->right <= prclReference->left)
    bRet = TRUE;
  else
    if (prclSubject->top >= prclReference->bottom)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is right or below the prclReference
BOOL bIsRightOrBelow(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsRightOrBelow);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->left >= prclReference->right)
    bRet = TRUE;
  else
    if (prclSubject->top >= prclReference->bottom)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}


#if 0 //disabled

/*
** bRclDrawSingle_SW
**
** handles all rop2 with P and D, but only Solid brushes
**
** 290797 FNicklis new
*/
BOOL bRclDrawSingle_SW (SURFOBJ  *pso, 
                         RECTL    *prcl, 
                         BRUSHOBJ *pbo, 
                         POINTL   *pptlBrushOrg, 
                         ROP4     rop4) 
{
  PPDEV ppdev;
  UNALIGNED BYTE *pjData;
  BOOL  bRet=FALSE;
  BOOL  bReadAndModify=FALSE;
  ULONG ulSolidColor;
  ULONG ulColor;
  BYTE  *pjColor= (BYTE *)&ulColor;
  WORD  *pwColor= (WORD *)&ulColor;
  LONG  x,y;
  ULONG rop3;
  BOOL  bValidGDI;

  DISPDBG((DBG_LVL_SUBENTRY, "  bRclDrawSingle_SW {"));
  ASSERTDD(NULL != pso,          "bRclDrawSingle_SW: pso == NULL");
  ASSERTDD(NULL != pso->dhpdev,  "bRclDrawSingle_SW: pso->dhpdev == NULL");
  ASSERTDD(NULL != prcl,         "bRclDrawSingle_SW: prcl == NULL");
  ASSERTDD(!bRectIsEmpty(prcl), "bRclDrawSingle_SW: prcl is empty rect");

  ppdev = (PPDEV)pso->dhpdev;

  ulSolidColor = pbo->iSolidColor;
  if ((ULONG)-1 == ulSolidColor) {
    DISPDBG((DBG_LVL_PUNT, "    ERROR in bRclDrawSingle_SW: Not a solid brush -> leaving"));
    goto Exit;
  }

  rop3 = (rop4>>8) & 0xff;

  if ((rop4 & 0xff) != rop3) {
    DISPDBG((DBG_LVL_PUNT, "    ERROR in bRclDrawSingle_SW: FG!=BG ROP:0x%x",rop4));
    goto Exit;
  }

  // Check basic 16 rops, 5 do not need to read destination -> set ulColor
  if (rop3==ROP3_P) {
    // Copy
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:P"));
    ulColor=ulSolidColor;

  } else if (rop3==ROP3_0) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:0"));
    ulColor=0;

  } else if (rop3==ROP3_1) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:1"));
    ulColor=1;

  } else if (rop3==ROP3_D) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:D(nop)"));
    bRet = TRUE; // NOP
    goto Exit;

  } else if (rop3==ROP3_Pn) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:Pn"));
    ulColor=~ulSolidColor;

  } else {
    // Have to read destination
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:0x%x", rop3));
    if (rop3==ROP3_DPna ||
        rop3==ROP3_DPno){
      DISPDBG((DBG_LVL_FLOW1,    " ?Pn?"));
      ulSolidColor=~ulSolidColor; // remember inverted solid color
    }
    bReadAndModify=TRUE;
  }

  pjData = ((BYTE *)pso->pvScan0) + prcl->top*pso->lDelta + prcl->left*ppdev->cjPelSize;

  DISPDBG((DBG_LVL_FLOW1,    " ulSolidColor:0x%x",ulSolidColor));
  vDbg_PrintRECTL(DBG_LVL_FLOW1, "    prcl:",prcl);
  DISPDBG((DBG_LVL_FLOW1,    "    iBytePerPixel:%d, ulBitCount:%d",iBytePerPixel,ppdev->ulBitCount));
  DISPDBG((DBG_LVL_FLOW1,    "    pvScan0:0x%x, lDelta:0x%x", pso->pvScan0,pso->lDelta));

  for (y=0; y<lRectHeight(prcl); y++) {
    UNALIGNED BYTE *pujWork  = (BYTE *)pjData;
    UNALIGNED WORD *puwWork =  (WORD *)pjData;
    ULONG *pulWork = (ULONG *)pjData;

    //DISPDBG((DBG_LVL_FLOW1, "    %d: pjData:0x%x", y, pjData));
    for (x=0; x<lRectWidth(prcl); x++) {

      // handle rops that need to read the destination?
      if (bReadAndModify) {
        // Read Destination
        UCDISPDBG(("WARNING bRclDrawSingle_SW called with rop, but not testet! - remove this line when OK"));
        switch (iBytePerPixel) {
          case 1:
            pjColor[0] = *pujWork;
            break;
          case 2:
            pwColor[0] = *puwWork;
            break;
          case 3:
            pjColor[0] = pujWork[0];
            pjColor[1] = pujWork[1];
            pjColor[2] = pujWork[2];
            break;
          case 4:
            ulColor = *pulWork;
            break;
          default:
            DISPDBG((DBG_LVL_ERROR, "    ERROR in bRclDrawSingle_SW: unknown iBytePerPixel=%d",iBytePerPixel));
            break;
        }
        // Destination Data from framebuffer now in ulColor

        if (ROP3_PDna==rop3 ||  
            ROP3_PDno==rop3 ||
            ROP3_Dn  ==rop3) {
          // Invert Destination
          ulColor = ~ulColor; 
        }

        // Now combine D and P
        if (ROP3_DPna==rop3 ||
            ROP3_PDna==rop3 ||
            ROP3_DPan==rop3 ||
            ROP3_DPa==rop3) {
          // D and P
          ulColor = ulColor & ulSolidColor; 
        } else if (ROP3_DPno==rop3 ||
                   ROP3_PDno==rop3 ||
                   ROP3_DPo ==rop3 ||
                   ROP3_DPon==rop3) {
          // D or P
          ulColor = ulColor | ulSolidColor; 
        } else if (ROP3_DPx ==rop3 ||
                   ROP3_PDxn==rop3) {
          // D xor P
          ulColor = ulColor ^ ulSolidColor;
        } 

        // Now if necesssary invert the result
        if (ROP3_DPan ==rop3 ||
            ROP3_PDxn==rop3 ||
            ROP3_DPon==rop3) {
          ulColor = ~ulColor; 
        }
      } // if ..bReadAndModify (ROPS)

      // Come here and copy the resulting color to the destination
      switch (iBytePerPixel) {
        case 1:
          *pujWork++ = pjColor[0];
          break;
        case 2:
          *puwWork++ = pwColor[0];
          break;
        case 3:
          *pujWork++ = pjColor[0];
          *pujWork++ = pjColor[1];
          *pujWork++ = pjColor[2];
          break;
        case 4:
          *pulWork++ = ulColor;
          break;
        default:
          DISPDBG((DBG_LVL_ERROR, "    ERROR in bRclDrawSingle_SW: unknown iBytePerPixel=%d",iBytePerPixel));
          break;
      }
    }
    pjData += pso->lDelta;
  }
  if (bValidGDI) ppdev->ReenableHwAccelAccess(ppdev); 

  bRet = TRUE;

Exit:
  DISPDBG((DBG_LVL_SUBENTRY, "  } RDS_SW: %s", bRet?"TRUE":"FALSE"));
  return bRet;
} // end of bRclDrawSingle_SW

#endif

/*
** same as vRclAddOffset but working on array
*/
VOID vRclListAddOffset(
       OUT RECTL *pTrg,     // output array long enough to store c rects
  const IN RECTL *pSrc,     // input array with c rects
        IN ULONG  c,        // number of rects to transform
        IN LONG   lXOffset, // x offset to add 
        IN LONG   lYOffset) // x offste to add
{
  ULONG cRect;
  ASSERT(NULL!=pTrg);
  ASSERT(NULL!=pSrc);

  for (cRect=0; cRect<c; cRect++)
  {
    vRclAddOffset(pTrg+cRect, pSrc+cRect, lXOffset, lYOffset);
  }
}

/*
** same as vRclSubOffset but working on array
*/
VOID vRclListSubOffset(
       OUT RECTL *pTrg,     // output array long enough to store c rects
  const IN RECTL *pSrc,     // input array with c rects
        IN ULONG  c,        // number of rects to transform
        IN LONG   lXOffset, // x offset to add 
        IN LONG   lYOffset) // x offste to add
{
  ULONG cRect;
  ASSERT(NULL!=pTrg);
  ASSERT(NULL!=pSrc);

  for (cRect=0; cRect<c; cRect++)
  {
    vRclSubOffset(pTrg+cRect, pSrc+cRect, lXOffset, lYOffset);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\savescreenbits.h ===
#ifndef _SAVESCREENBITS_H
#define _SAVESCREENBITS_H
//******************************Module*Header***********************************
// Module Name: savescreenbits.h
//
//  This module contains the DrvSaveScreenBits realization
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

ULONG_PTR APIENTRY DrvSaveScreenBits(
    SURFOBJ  *pso,
    ULONG    iMode,
    ULONG_PTR ident,
    RECTL    *prcl);

BOOL bSaveScreenBitsGarbageCollection(
    PPDEV ppdev,
    ULONG ulKeep);



#endif // _SAVESCREENBITS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\RectUtils.h ===
#ifndef _RECT_UTILS_H
#define _RECT_UTILS_H

/*
** $Header$
**
** MODULE:   Rect_Utils.h
**
** AUTHOR:   FNicklis, (c) nVidia GmbH
**
** DESCR:    Basic rectangle functions for Top Down coordinates
**           Bottom Up coordinates have BU at end of name
**
** History:
**   MSchwarzer 10/17/2000: integrated from other codebase
*/

/* *** Basic Rectangle Functions *** */

static RECTL rclEmpty   = { 0,0,0,0 };
static RECTL rclOutside = {-1,-1,-1,-1};

// returns TRUE if Src1 intersects Src2 and intersection rect is stored to Trg
BOOL _inline bRclIntersect (
        OUT RECTL *Trg,  // can be NULL
  const IN  RECTL *Src1, // NULL not allowed
  const IN  RECTL *Src2) // NULL not allowed
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);

  if (   (Src1->left   >= Src2->right ) 
      || (Src1->right  <= Src2->left  ) 
      || (Src1->top    >= Src2->bottom) 
      || (Src1->bottom <= Src2->top   ) ) 
  {
    //Skuklik : If NO intersection, the resulting rectangle should be empty (0,0,0,0)
    if (Trg)
    {
      *Trg = rclEmpty;
    }
    goto Exit;
  }

  bRet = TRUE;

  if (NULL == Trg) 
  {
    goto Exit;
  }

  Trg->left     = max(Src1->left,   Src2->left);
  Trg->right    = min(Src1->right,  Src2->right);
  Trg->top      = max(Src1->top,    Src2->top);
  Trg->bottom   = min(Src1->bottom, Src2->bottom);

Exit:
  return(bRet);
}

// NULL params not allowed
BOOL _inline bRclIntersectBU (RECTL *Trg, const RECTL *Src1, const RECTL *Src2)
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);

  if (   (Src1->left   >= Src2->right ) 
      || (Src1->right  <= Src2->left  ) 
      || (Src1->bottom >= Src2->top   ) 
      || (Src1->top    <= Src2->bottom) ) 
  {
    goto Exit;
  }

  bRet = TRUE;

  if (NULL == Trg) 
  {
    goto Exit;
  }

  Trg->left     = max(Src1->left,   Src2->left);
  Trg->right    = min(Src1->right,  Src2->right);
  Trg->top      = min(Src1->top,    Src2->top);
  Trg->bottom   = max(Src1->bottom, Src2->bottom);

Exit:
  return(bRet);
}

// NULL params not allowed
BOOL _inline bRclIsEmpty(const RECTL *Src)
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src);
  if ( ((Src->right  - Src->left) <= 0) || 
       ((Src->bottom - Src->top) <= 0) ) 
  {
    bRet = TRUE;
  }

  return(bRet);
}

// NULL params not allowed
LONG _inline lRclWidth(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->right - pSrc->left); 
}

// NULL params not allowed
LONG _inline lRclHeight(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->bottom - pSrc->top); 
}

// NULL params not allowed
LONG _inline lRclHeightBU(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->top - pSrc->bottom); 
}

// NULL params not allowed
void _inline vRclSubOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN LONG lXOffset, IN LONG lYOffset)
{

  ASSERT(NULL!=pSrc);
  ASSERT(NULL!=pTrg);

  pTrg->left     = pSrc->left   - lXOffset;
  pTrg->right    = pSrc->right  - lXOffset;
  pTrg->top      = pSrc->top    - lYOffset;
  pTrg->bottom   = pSrc->bottom - lYOffset;

  return;
}

//
// add the origin of the src rect to the dest rect
//
void __inline vRclAddOrigin(IN OUT PRECTL prclDest, const IN PRECTL prclSrc)
{
  LONG xOrigin, yOrigin;

  ASSERT(NULL != prclDest);
  ASSERT(NULL != prclSrc);
  
  xOrigin = prclSrc->left;
  yOrigin = prclSrc->top;

  prclDest->left   += xOrigin;
  prclDest->top    += yOrigin;
  prclDest->right  += xOrigin;
  prclDest->bottom += yOrigin;
}

// NULL params not allowed
void _inline vRclAddOffset (OUT RECTL *pTrg, const IN RECTL *pSrc, IN LONG lXOffset, IN LONG lYOffset)
{

  ASSERT(NULL!=pSrc);
  ASSERT(NULL!=pTrg);

  pTrg->left     = pSrc->left   + lXOffset;
  pTrg->right    = pSrc->right  + lXOffset;
  pTrg->top      = pSrc->top    + lYOffset;
  pTrg->bottom   = pSrc->bottom + lYOffset;

  return;
}


// NULL params not allowed
void _inline vRclBounds (OUT RECTL *Trg, IN const RECTL *Src1, IN const RECTL *Src2) 
{

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);
  ASSERT(NULL!=Trg );

  Trg->left     = min(Src1->left,   Src2->left);
  Trg->right    = max(Src1->right,  Src2->right);
  Trg->top      = min(Src1->top,    Src2->top);
  Trg->bottom   = max(Src1->bottom, Src2->bottom);

  return;
}

// NULL params not allowed
BOOL _inline bRclCombine(IN OUT RECTL *prclInOut, IN const RECTL *prclNew)  
{
  BOOL bRet=TRUE;


  ASSERT(NULL != prclInOut);
  ASSERT(NULL != prclNew);

  if (prclNew->top == prclInOut->bottom)
  {
    if (prclNew->left == prclInOut->left && prclNew->right == prclInOut->right)
    {
      prclInOut->bottom = prclNew->bottom;
      goto Exit;
    }
  }
  if (prclNew->bottom == prclInOut->top)
  {
    if (prclNew->left == prclInOut->left && prclNew->right == prclInOut->right)
    {
      prclInOut->top = prclNew->top;
      goto Exit;
    }
  }
  if (prclNew->left == prclInOut->right)
  { 
    if (prclNew->top == prclInOut->top && prclNew->bottom == prclInOut->bottom)
    {
      prclInOut->right = prclNew->right;
      goto Exit;
    }
  }
  if (prclNew->right == prclInOut->left)
  {
    if (prclNew->top == prclInOut->top && prclNew->bottom == prclInOut->bottom)
    {
      prclInOut->left = prclNew->left;
      goto Exit;
    }
  }
  bRet=FALSE;

Exit:
  return(bRet);
}

/*
** Checks if inner rectangle is completly inside or equal 
** the outer rectangle.
** TRUE:  inner is completly surrounded by outer.
** FALSE: inner intersects outer or is outside
**
** 20.06.96 fi
*/ 
//FN it was time enough to use the new name: #define E_RclIsIn bRclIsIn 
// NULL params not allowed
_inline BOOL bRclIsIn (IN const RECTL *outer, IN const RECTL *inner) 
{
  BOOL bRet;

  ASSERT(NULL != outer);
  ASSERT(NULL != inner);
  bRet = ((outer->left <= inner->left) && (outer->right  >= inner->right) &&  // x-check
          (outer->top  <= inner->top)  && (outer->bottom >= inner->bottom));   // y-check

  return bRet;
} // end of bRclIsIn


/*
** Checks if inner rectangle is completly inside or equal 
** the outer rectangle.
** TRUE:  inner is completly surrounded by outer.
** FALSE: inner intersects outer or is outside
**
** 20.06.96 fi
*/ 
//FN it was time enough to use the new name: #define E_RclIsIn bRclIsIn 
// NULL params not allowed
_inline BOOL bRclIsInBU (IN const RECTL *outer, IN const RECTL *inner) 
{
  BOOL bRet;

  ASSERT(NULL != outer);
  ASSERT(NULL != inner);
  bRet = ((outer->left <= inner->left) && (outer->right  >= inner->right) &&  // x-check
          (outer->top  >= inner->top)  && (outer->bottom <= inner->bottom));   // y-check

  return bRet;
} // end of bRclIsInBU


// Checks whether a point is inside the rect
// NULL params not allowed
BOOL _inline bRclPtlInside (IN const RECTL *prcl, IN const POINTL *pptl)
{
  BOOL bRet;

  ASSERT(NULL!=prcl);
  ASSERT(NULL!=pptl);

  if ((pptl->x      < prcl->left)    || 
	    (pptl->x      >= prcl->right)  ||  // right border is outside the rect
      (pptl->y      < prcl->top)     || 
	    (pptl->y      >= prcl->bottom) )   // bottom border is outside
  { 
    // bottom border is outside the rect
    bRet = FALSE;
  }
  else
  {
    // Point is inside
    bRet = TRUE;
  }

  return(bRet);
}

// Checks whether a point is inside the rect
// NULL params not allowed
BOOL _inline bRclPtlInsideBU(IN const RECTL *prcl, IN const POINTL *pptl)
{
  BOOL bRet;

  ASSERT(NULL!=prcl);
  ASSERT(NULL!=pptl);

  if ((pptl->x      < prcl->left)    || 
	    (pptl->x      >= prcl->right)  ||  // right border is outside the rect
      (pptl->y      >= prcl->top)    ||  // top border is outside
	    (pptl->y      < prcl->bottom) ) 
  { 
    // bottom border is outside the rect
    bRet = FALSE;
  }
  else
  {
    // Point is inside
    bRet = TRUE;
  }

  return(bRet);
}

// Sets all members to 0
// NULL param allowed
VOID _inline vRclClear (OUT RECTL *prcl)
{
  if (prcl) {
    prcl->left   =
    prcl->right  =
    prcl->top    =
    prcl->bottom = 0;
  }
}

// **FN** 100697 Compares two rects either by pointer or members
// NULL params allowed
_inline BOOL bRclIsEqual (IN const RECTL *prcl1, IN const RECTL *prcl2)
{
  BOOL bRet;
 
  if (prcl1==prcl2) 
  {
    // both are equal pointers or NULL
    bRet = TRUE;

  } 
  else if (prcl1 && prcl2) 
  {
    // both point to a rect, compare members
    bRet =  (prcl1->left   == prcl2->left   &&
            prcl1->right  == prcl2->right  &&
            prcl1->top    == prcl2->top    &&
            prcl1->bottom == prcl2->bottom);
  } 
  else 
  {
    // One is NULL
    bRet = FALSE;
  }
  return (bRet);
} // end of bRclIsEqual 

__inline RECTL *prclRclOrder(OUT RECTL *prclOrdered, IN RECTL *prclIn)
{
  *prclOrdered = *prclIn; // Make a copy of the src rect

  ASSERT(prclOrdered!=prclIn);
  ASSERT(prclOrdered!=NULL);
  ASSERT(prclIn!=NULL);

  // Then check for ordering
  if (prclIn->left>prclIn->right)  {
    prclOrdered->left  = prclIn->right;
    prclOrdered->right = prclIn->left;
  }
  if (prclIn->top>prclIn->bottom)  {
    prclOrdered->top = prclIn->bottom;
    prclOrdered->bottom = prclIn->top;
  }

  return (prclOrdered);
}


// FN 031197
// Exchanges data of both input structs and returns a pointer to the first param if successful or NULL
__inline RECTL *prclRclSwap(IN OUT RECTL *prcl1, IN OUT RECTL *prcl2)
{
  RECTL rclTemp;

  if (NULL==prcl1 || NULL==prcl2) 
  {
    DISPDBG((0, "  ERROR in prclRclSwap: NULL rect - prcl1:0x%x, prcl2:0x%x",prcl1, prcl2));
    prcl1 = NULL;
  } 
  else 
  {
    rclTemp = *prcl1;
    *prcl1  = *prcl2;
    *prcl2  = rclTemp;
  }
  return (prcl1);
} // end of prclRclSwap


// FN 031197
// Exchanges data of both input structs and returns a pointer to the first param if successful or NULL
__inline SIZEL *psizSizeSwap(IN OUT SIZEL *psiz1, IN OUT SIZEL *psiz2)
{
  SIZEL sizTemp;

  if (NULL==psiz1 || NULL==psiz2) {
    DISPDBG((0, "  ERROR in psizSizeSwap: NULL size - psiz1:0x%x, psiz2:0x%x",psiz1, psiz2));
    psiz1 = NULL;
  } else {
    sizTemp = *psiz1;
    *psiz1  = *psiz2;
    *psiz2  = sizTemp;
  }
  return (psiz1);
} // end of psizSizeSwap

__inline RECTL *prclRclSetXYWH(OUT RECTL *prcl, IN LONG left, LONG top, 
                                   LONG width, LONG height)
{
  if (NULL!=prcl) {
    prcl->left   = left;
    prcl->right  = left + width;
    prcl->top    = top;
    prcl->bottom = top + height;
  }
  return prcl;
}

// FNicklis 01.11.98: counts the pixels in a rect (w*h)
__inline LONG lRclPixelCount(IN const RECTL *prcl)
{
  return (lRclWidth(prcl) * lRclHeight(prcl));
}

/*
** vRclTopDownToBottomUp
** transformation from TopDown to BottomUp coordinate space
*/
__inline VOID vRclTopDownToBottomUp(
  OUT RECTL *prclBottomUp,
  IN  RECTL *prclTopDown,
  IN  RECTL *prclReference) // taken as reference to perform transformation (need height)
{
  LONG lReferenceHeight;

  ASSERT(NULL!=prclBottomUp);
  ASSERT(NULL!=prclTopDown);

  lReferenceHeight = lRclHeight(prclReference);

  prclBottomUp->left   = prclTopDown->left;
  prclBottomUp->right  = prclTopDown->right;

  prclBottomUp->bottom = lReferenceHeight - prclTopDown->bottom;
  prclBottomUp->top    = lReferenceHeight - prclTopDown->top;
}

// vRclBottomUpToTopDown is simply the same as vRclTopDownToBottomUp
#define vRclBottomUpToTopDown vRclTopDownToBottomUp


// prclSrc copies contents of prclSrc to prclDst
__inline VOID vRclCopy(OUT RECTL *prclDst, IN RECTL *prclSrc)
{
    ASSERT(prclDst);
    ASSERT(prclSrc);
    *prclDst = *prclSrc; // Make a copy of the src rect
}


LONG lRclMinusRcl(OUT RECTL prclDest[], IN const RECTL *prclSrc, IN const RECTL *prclMinus);

LONG lRclIntersectExclude(
  OUT RECTL *prclOut,              // array of up to four resulting rectangles
  IN const RECTL  *prclIn,         // rect stored to Out
  IN const RECTL  *prclBounds,     // Has to be clipped against In
  IN const RECTL  *prclExclude);   // exclude must not be part of Out

BOOL bIsLeftOrAbove(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsRightOrAbove(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsLeftOrBelow(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsRightOrBelow(RECTL *prclSubject, RECTL *prclReference);
VOID vRclListAddOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN ULONG c, IN LONG lXOffset, IN LONG lYOffset);
VOID vRclListSubOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN ULONG c, IN LONG lXOffset, IN LONG lYOffset);

#endif //#define _RECT_SUP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\swap.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.53 $
** $Date: 1993/06/03 17:06:13 $
*/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "oglDD.h"
#include "oglsync.h"

BOOL APIENTRY DrvSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo)
{
    PDEV  *ppdev = NULL;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;
    POINTL  ptlSrc;
    RECTL   prclDst;
    RECTL   rcl;
    LONG                       status;

    ppdev = (PDEV *)pwo->psoOwner->dhpdev;

    if (!ppdev->bEnabled)
    {
        DBG_ERROR("DrvSwapBuffers called in VGA mode -> ignoring");
        return TRUE;
    }

    //**************************************************************
    // Actually do the swap
    //**************************************************************
    try // just in case...
    {
        clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;
        if (OglFindClientListFromClientInfo(ppdev, clientInfo) != NULL)
        {
            clientDrawableInfo = clientInfo->clientDrawableInfo;

            // if the swap was already done by the client, don't do it again
            if (clientDrawableInfo->ulSwapDoneByClient)
            {
                // nothing to do, swap taken care of by ICD
                clientDrawableInfo->ulSwapDoneByClient = 0;
                return TRUE;
            }

            if (OglValidateDrawableInfo(clientDrawableInfo) == TRUE)
            {
                ULONG ulView; // stereo loop enumerator

                // If the window is not visible, stop
                if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
                    clientDrawableInfo->numClipRects == 0)
                {
                    return TRUE;
                }

                // Currently only handle display driver channel swaps with UBB
                // enabled.
                if (!ppdev->bOglSingleBackDepthCreated) 
                {
                    return TRUE;
                }

                //************************************************************************** 
                // Need to do smart sync between OpenGL and GDI depending on 
                // clip intersection.
                //**************************************************************************
                bOglSyncOglIfGdiRenderedToWindow(ppdev);

                //**************************************************
                // We now have screen relative clips for the swap
                //**************************************************
                rcl.left   = 0;
                rcl.top    = 0;
                rcl.right  = ppdev->cxScreen;
                rcl.bottom = ppdev->cyScreen;
                ptlSrc.x   = 0;
                ptlSrc.y   = 0;

                // need to wait until ICD has finished rendering
                ASSERT(NULL!=ppdev->pfnWaitEngineBusy);
                ppdev->pfnWaitEngineBusy(ppdev);

                for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
                {
                    ULONG ulPrimarySurfaceOffset;
                    LONG  lPrimarySurfacePitch;

                    if (OGL_STEREO_BUFFER_LEFT == ulView)
                    {
                        ulPrimarySurfaceOffset = ppdev->ulPrimarySurfaceOffset;
                        lPrimarySurfacePitch   = ppdev->lDelta;
                    }
                    else
                    {
                        ulPrimarySurfaceOffset = ppdev->singleFrontOffset[ulView];
                        lPrimarySurfacePitch   = ppdev->singleFrontPitch[ulView];
                    }

                    // perhaps previous swaps succeeded in the ICD but we're displaying back,
                    // then we need to blit from primary to back
                    if (OGL_FLIPPED())
                    {
                        ppdev->pfnSetSourceBase(ppdev, ulPrimarySurfaceOffset, lPrimarySurfacePitch);
                        ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView]);
                    }
                    else
                    {
                        ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView]);
                        ppdev->pfnSetDestBase(ppdev, ulPrimarySurfaceOffset, lPrimarySurfacePitch);
                    }
                    ppdev->pfnCopyBlt(ppdev, 
                                      clientDrawableInfo->numClipRects,
                                      clientDrawableInfo->copyWindowRect, 
                                      0xCCCC, &ptlSrc, &rcl, NULL);
                }
                ppdev->pfnWaitEngineBusy(ppdev);
            }
            else
            {
                DISPDBG((1, "DrvSwapBuffers: BOGUS clientDrawableInfo"));
            }
        }
        else
        {
            DISPDBG((1, "DrvSwapBuffers: BOGUS clientInfo"));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        DISPDBG((1, "DrvSwapBuffers: WOC_RGN_CLIENT: exception = 0x%lx", status));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\textout.c ===
//******************************Module*Header***********************************
//
// Module Name: textout.c
//
// On every TextOut, GDI provides an array of 'GLYPHPOS' structures
// for every glyph to be drawn.  Each GLYPHPOS structure contains a
// glyph handle and a pointer to a monochrome bitmap that describes
// the glyph.  (Note that unlike Windows 3.1, which provides a column-
// major glyph bitmap, Windows NT always provides a row-major glyph
// bitmap.)  As such, there are three basic methods for drawing text
// with hardware acceleration:
//
// 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
//       (probably in off-screen memory), and text is drawn by
//       referring the hardware to the cached glyph locations.
//
// 2) Glyph expansion -- Each individual glyph is colour-expanded
//       directly to the screen from the monochrome glyph bitmap
//       supplied by GDI.
//
// 3) Buffer expansion -- The CPU is used to draw all the glyphs into
//       a 1bpp monochrome bitmap, and the hardware is then used
//       to colour-expand the result.
//
// The fastest method depends on a number of variables, such as the
// colour expansion speed, bus speed, CPU speed, average glyph size,
// and average string length.
//
// For the S3 with normal sized glyphs, I've found that caching the
// glyphs in off-screen memory is typically the slowest method.
// Buffer expansion is typically fastest on the slow ISA bus (or when
// memory-mapped I/O isn't available on the x86), and glyph expansion
// is best on fast buses such as VL and PCI.
//
// Glyph expansion is typically faster than buffer expansion for very
// large glyphs, even on the ISA bus, because less copying by the CPU
// needs to be done.  Unfortunately, large glyphs are pretty rare.
//
// An advantange of the buffer expansion method is that opaque text will
// never flash -- the other two methods typically need to draw the
// opaquing rectangle before laying down the glyphs, which may cause
// a flash if the raster is caught at the wrong time.
//
// This driver implements glyph expansion and buffer expansion --
// methods 2) and 3).  Depending on the hardware capabilities at
// run-time, we'll use whichever one will be faster.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"


RECTL grclMax = { 0, 0, 0x7fff, 0x7fff };



//******************************************************************************
//
//  Function:   vClipSolid
//
//  Routine Description:
//
//      Fills the specified rectangles with the specified colour, honouring
//      the requested clipping.  No more than four rectangles should be passed in.
//      Intended for drawing the areas of the opaquing rectangle that extend
//      beyond the text box.  The rectangles must be in left to right, top to
//      bottom order.  Assumes there is at least one rectangle in the list.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)

    {
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;

    //**********************************************************************
    // Bottom of last rectangle to fill
    //**********************************************************************

    iLastBottom = prcl[crcl - 1].bottom;

    //**********************************************************************
    // Initialize the clip rectangle enumeration to right-down so we can
    // take advantage of the rectangle list being right-down:
    //**********************************************************************

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

    //**********************************************************************
    // Scan through all the clip rectangles, looking for intersects
    // of fill areas with region rectangles:
    //**********************************************************************

    do {
        //******************************************************************
        // Get a batch of region rectangles:
        //******************************************************************

        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

        //******************************************************************
        // Clip the rect list to each region rect:
        //******************************************************************

        for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
            //**************************************************************
            // Since the rectangles and the region enumeration are both
            // right-down, we can zip through the region until we reach
            // the first fill rect, and are done when we've passed the
            // last fill rect.
            //**************************************************************

            if (prclClip->top >= iLastBottom)
                {
                //**********************************************************
                // Past last fill rectangle; nothing left to do:
                //**********************************************************

                return;
                }

            //**************************************************************
            // Do intersection tests only if we've reached the top of
            // the first rectangle to fill:
            //**************************************************************

            if (prclClip->bottom > prcl->top)
                {
                //**********************************************************
                // We've reached the top Y scan of the first rect, so
                // it's worth bothering checking for intersection.
                //**********************************************************

                //**********************************************************
                // Generate a list of the rects clipped to this region
                // rect:
                //**********************************************************

                prclTmp     = prcl;
                prclClipTmp = arclTmp;

                for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                    //******************************************************
                    // Intersect fill and clip rectangles
                    //******************************************************

                    if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                        //**************************************************
                        // Add to list if anything's left to draw:
                        //**************************************************

                        crclTmp++;
                        prclClipTmp++;
                        }
                    }

                //**********************************************************
                // Draw the clipped rects
                //**********************************************************

                if (crclTmp != 0)
                    {
                    (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                          0xf0f0, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }


//******************************************************************************
//
//  Function:   DrvTextOut
//
//  Routine Description:
//
//      Calls the appropriate text drawing routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix -- 0x0d0d

    {
    PDEV*       ppdev;
    DSURF*      pdsurfDst;
    SURFOBJ*    TempDstSurfObjPtr;
    ULONG*      DstBits;
    ULONG*      ScreenBitmap;
    BOOL        result;
    ULONG       DstOffset;
    ULONG       DstStride;

    //**************************************************************************
    // Get variables to determine if we're drawing to system memory or VRAM
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    ASSERTDD(ppdev != NULL, "Null ppdev in DrvTextOut");

    // NV HW is not enabled.
    if(!ppdev->bEnabled)
        goto Do_EngTextOut;


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso, (NULL != prclOpaque) ? prclOpaque : &pstro->rclBkGround, pco);        
    }

        
    //**************************************************************************
    // There will always be a destination so we don't have to check
    // for psoDst == NULL.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Set linear offset and stride for source and destination buffers
    //**************************************************************************

    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_SCREEN))     // offscreen bitmap
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }
    else if ((pdsurfDst == NULL) && (DstBits == ScreenBitmap))  // screen bitmap
        {
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }
        
    //**************************************************************************
    // Only handle cases where destination is VRAM.  This must be a DFB that is
    // stored in system memory. We need to send this case to GDI.
    // GDI is allowed to call us to update DFBs that are stored in system
    // memory when in Full Screen DOS (typically during a STRESS test). Note that
    // the ppdev value might not be valid, and might contain bad data.
    //**************************************************************************

    else
        goto Do_EngTextOut;

//**************************************************************************
    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:
    //**************************************************************************

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);

    result = (ppdev->pfnTextOut(pso, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque));

    return(result);


Do_EngTextOut:

    //**************************************************************************
    // Default to using original SURFOBJ. This will work for GDI managed surfaces
    // which is the case for all bitmaps stored in on-screen VRAM. 
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // Check whether surface is a DFB or the primary screen surface. DFB's stored
    // in off screen VRAM need to use a "wrapper" object so GDI will understand it.
    //**************************************************************************

    if (pdsurfDst != NULL)
        {
        if (pdsurfDst->dt == DT_SCREEN)
        
            {
        //**********************************************************************
        // If this is a DFB, and we want to use GDI to draw, use the 'wrapper'
        // surface object.  (The surface object must be locked)
        //**********************************************************************

        //**********************************************************************
        // SurfOBJ that will be used if we are drawing to a DFB
        //**********************************************************************

            TempDstSurfObjPtr = ppdev->psoPunt;

            TempDstSurfObjPtr->dhsurf       = 0;                    // Behave like a standard DIB
            TempDstSurfObjPtr->sizlBitmap   = pdsurfDst->sizl;
            TempDstSurfObjPtr->cjBits       = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            TempDstSurfObjPtr->pvBits       = pdsurfDst->LinearPtr;
            TempDstSurfObjPtr->pvScan0      = pdsurfDst->LinearPtr;
            TempDstSurfObjPtr->lDelta       = pdsurfDst->LinearStride;

            TempDstSurfObjPtr->iBitmapFormat = ppdev->iBitmapFormat;

            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in system memory as a DIB. If we are called
            // when in Full Screen DOS, ppdev might not be valid, so just return here
            // without waiting for the engine to be busy.
            //**********************************************************************
            TempDstSurfObjPtr = pdsurfDst->pso;
            ppdev->pfnWaitEngineBusy(ppdev);
            return (ppdev->pfnEngTextOut(TempDstSurfObjPtr, pstro, pfo, pco, prclExtra, prclOpaque,
                                         pboFore, pboOpaque, pptlBrush, mix));
            }
        }

    //**************************************************************************
    // Let the DIBEngine draw it
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    return (ppdev->pfnEngTextOut(TempDstSurfObjPtr, pstro, pfo, pco, prclExtra, prclOpaque,
                                 pboFore, pboOpaque, pptlBrush, mix));
    }

//******************************************************************************
//
//  Function:   bEnableText
//
//  Routine Description:
//
//      Performs the necessary setup for the text drawing subcomponent.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnableText(
PDEV*   ppdev)
    {
    SIZEL   sizl;
    HBITMAP hbm;

    //**************************************************************************
    // We don't do glyph caching for NV
    //**************************************************************************

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   vDisableText
//
//  Routine Description:
//
//      Performs the necessary clean-up for the text drawing subcomponent.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vDisableText(PDEV* ppdev)

    {
    HSURF       hsurf;
    SURFOBJ*    psoText;

    //**************************************************************************
    // Here we free any stuff allocated in 'bEnableText'.
    // We don't do glyph caching for NV
    //**************************************************************************


    }

//******************************************************************************
//
//  Function:   vAssertModeText
//
//  Routine Description:
//
//      Disables or re-enables the text drawing subcomponent in preparation for
//      full-screen entry/exit.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
    {
    //**************************************************************************
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
    //**************************************************************************
    }

//******************************************************************************
//
//  Function:   DrvDestroyFont
//
//  Routine Description:
//
//      Note: Don't forget to export this call in 'enable.c', otherwise you'll
//              get some pretty big memory leaks!
//
//      We're being notified that the given font is being deallocated; clean up
//      anything we've stashed in the 'pvConsumer' field of the 'pfo'.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDestroyFont(
FONTOBJ*    pfo)

    {
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
        {
//        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\savescreenbits.c ===
//************************* Module Header **************************************
//                                                                             *
//  Module Name: SaveScreenBits.c                                              *
//                                                                             *
//  This module contains the DrvSaveScreenBits realization                     *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//                                                                             *
//  DrvSaveScreenBits it needed for use of opengl overlay to be able to exract *
//  and to restore the correct overlay contents                                *
//                                                                             *
//  This function is NV4 or better only !                                      * 
//                                                                             *
//******************************************************************************
#include "precomp.h"
#include "driver.h"
#include "oglDD.h"
#include "OglOverlay.h"
#include "oglstereo.h"
#include "oglsync.h"
#include "linkedlist.h"
#include "rectutils.h"
#include "nv32.h"
#include "nvcm.h"


#include "savescreenbits.h"

// Number of maximum stored screenbits before garbage collection is called.
#define MAX_SAVESCREENBITS 20

static BOOL bSaveScreenBitsFree(
    IN PPDEV        ppdev, 
    IN ULONG_PTR    ident, 
    IN SURFOBJ     *psoFree);

//
//  DrvSaveScreenBits
//
//  Saves away contents of the desktop before a popup-menue 
//  will apear and restores it after the popup has gone.
//  Function is mainly needed for opengl overlay apps for whom
//  we have to handle the overlay merging in this call.
//
//  NOTE: GDI has a bug. Starting an application from the start menu
//        will create (SS_SAVE) a couple of ScreenBits but not free 
//        them (SS_RESTORE/SS_FREE). Because of this bug we would 
//        leak memory and therefore we need a garbage collection which
//        is called from time to time. 
//        BTW: If any OpenGL is started, GDI behaves correctly. 
//
//  Return value: FALSE:   no action succeeded
//                TRUE:    if SS_RESTORE or SS_FREE succeeded
//                psoSave: if SS_SAVE succeeded   
//
ULONG_PTR APIENTRY DrvSaveScreenBits(
    SURFOBJ  *pso,
    ULONG    iMode,
    ULONG_PTR ident,
    RECTL    *prcl
    )
{
    ULONG_PTR  ulRet              = FALSE;
    PPDEV      ppdev              = NULL;
    POINTL     ptlSrc             = {0, 0};
    SURFOBJ   *psoSave            = NULL;  
    DSURF*     pdsurf             = NULL;
    HBITMAP    hbmpSave           = NULL;

    ASSERT(pso);

    ppdev = (PPDEV)pso->dhpdev;
    ASSERT(ppdev);

    DISPDBG((3,"DrvSaveScreenBits { pso:0x%p, iMode:%8s, ident:0x%08x, prcl:0x%p",pso,iMode==SS_SAVE?"SAVE":(iMode==SS_RESTORE?"RESTORE":(iMode==SS_FREE?"FREE":"unknown")),ident,prcl));

    // Disable DrvSaveScreenBits for NV4/NV5 for now since this causes
    // a crash in the kernel.  Not sure why but this is an urgent 
    // showstopper so we'll just disable it until we can talk to Yoko
    // about it.  Crash does not occur on NV10 and higher chips so
    // this should not affect overlays since they only run on NV10 and
    // higher.
    
    if (!(   HWGFXCAPS_QUADRO_GENERIC(ppdev)
          && (   bOglIsOverlayModeEnabled(ppdev)
              || bOglIsStereoModeEnabled(ppdev)
             ) 
       ) )
    {
        switch(iMode) 
        {
            case SS_SAVE:
                // Cleanup all collected screenbits as they're not longer used.
                if (   HWGFXCAPS_QUADRO_GENERIC(ppdev)
                    && (ppdev->lSavedScreenBits > 0) )
                {
                    bSaveScreenBitsGarbageCollection(ppdev,0);
                }
                break;
            case SS_RESTORE:
                break;
            case SS_FREE:
                ulRet = TRUE;
                break;
            default:
                ASSERT(SS_SAVE==iMode);
                break;
        }
        goto Exit;
    }

#if (NVARCH >= 0x4)
    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,prcl,NULL);        
    }

    ASSERT(NULL!=ppdev->pLinkedListSaveScreenBits)
    ASSERT(NULL!=ppdev->pfnCopyBlt);
    ASSERT(NULL!=ppdev->pfnScreenToMemBlt);
    ASSERT(NULL!=ppdev->pfnMemToScreenBlt);

    switch(iMode)
    {

        // The driver should save the data from the rectangle defined by prcl. 
        // The driver is responsible for managing this data in its off-screen 
        // memory. The ident parameter is ignored. 
        // Upon success, DrvSaveScreenBits should return an identifier for the 
        // saved data. The driver can return a handle or even a pointer to its 
        // off-screen memory. This function returns zero if it fails. 
        case SS_SAVE:
        {
            RECTL     rclTrg;
            SIZEL     sizlRect;
            ULONG     ulIdent;

            ASSERT(NULL!=prcl);
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_SAVE"));

            ppdev->ulSaveScreenBitsRefCounter++;
            if (0==ppdev->ulSaveScreenBitsRefCounter) // case of wrap around, avoid 0!
                ppdev->ulSaveScreenBitsRefCounter++;

            ulIdent = ppdev->ulSaveScreenBitsRefCounter;

            sizlRect.cx = lRclWidth(prcl);
            sizlRect.cy = lRclHeight(prcl);

            if( bOglIsOverlayModeEnabled(ppdev) )
                sizlRect.cy += lRclHeight(prcl);
            if( bOglIsStereoModeEnabled(ppdev) )
                sizlRect.cy += lRclHeight(prcl);

            // try to use offscreen memory
            hbmpSave = DrvCreateDeviceBitmap((DHPDEV)ppdev, sizlRect, pso->iBitmapFormat);

            if (!hbmpSave)
            {   
                //Not enough room in OFFSCREEN
                DISPDBG((2,"DrvSaveScreenBits: Not enough room in OffScreen for Bitmap")); 

                hbmpSave = EngCreateBitmap(sizlRect, 0, pso->iBitmapFormat, BMF_TOPDOWN, NULL);
                if(hbmpSave)
                {
                    EngAssociateSurface((HSURF)hbmpSave, ppdev->hdevEng, 0);
                }
                else
                {
                    DISPDBG((0, "DrvSaveScreenBits failed to get offscreen and host memory!"));
                    break;
                }
            }

            ASSERT(hbmpSave);
            ptlSrc.x = prcl->left;
            ptlSrc.y = prcl->top;

            psoSave = EngLockSurface((HSURF)hbmpSave);
            pdsurf  = (DSURF*)psoSave->dhsurf;

            rclTrg.left   = 0;
            rclTrg.right  = lRclWidth(prcl);
            rclTrg.top    = 0;
            rclTrg.bottom = lRclHeight(prcl);

            // stereo:  save frontleft + frontrigth
            // overlay: save frontleft (with mainplanefront for overlay clients) + overlayfront 

            // 1st screen to offscreen copy 
            if(IS_DEV_DEVICEBITMAP(psoSave))
            {
                ULONG      ulDstOffset;
                LONG       lDstStride;

                // source is our primary
                ppdev->pfnSetSourceBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                // destination is device bitmap
                ulDstOffset = (ULONG)((BYTE *)(pdsurf->LinearPtr) - ppdev->pjFrameBufbase);
                lDstStride  = pdsurf->LinearStride;
                ppdev->pfnSetDestBase(ppdev, ulDstOffset , lDstStride);

                ppdev->pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);

                // special case handling for saving away overlay frontbuffer
                if( bOglIsOverlayModeEnabled(ppdev) )
                {
                    // if rclTrg intersects with opengl overlay application,copy frontbuffer
                    // contents without overlay of this client
                    bCopyIntersectingMainPlaneFrontToPSO( ppdev, pso, psoSave, &rclTrg, &ptlSrc);

                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                            ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);

                    ASSERT(NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt);
                    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);
                }
                    
                // special case handling for saving away stereo frontbufferleft
                if( bOglIsStereoModeEnabled(ppdev) )
                {
                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                            ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);
                }

            }
            // screen to mem copy
            else
            {
                ASSERT(!IS_DEVICEBITMAP(psoSave));
                // source is our primary
                ppdev->pfnSetSourceBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                // destination is mainmemory => no call to ppdev->pfnSetDestBase needed

                ppdev->pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                if( bOglIsOverlayModeEnabled(ppdev) )
                {
                    PVOID pvLastDstOffset;

                    // if rclTrg intersects with opengl overlay application,copy frontbuffer
                    // contents without overlay of this client
                    bCopyIntersectingMainPlaneFrontToPSO( ppdev, pso, psoSave, &rclTrg, &ptlSrc);

                    // we need this structure for NV4ScreenToMemBlt
                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                            ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);

                    // pfnScreenToMemBlt needs pso->dhsurf to determine src offset
                    pvLastDstOffset = ((DSURF*)pso->dhsurf)->LinearPtr;
                    ((DSURF*)pso->dhsurf)->LinearPtr = ppdev->pjFrameBufbase + ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
        
                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                    // repair primary's LinearPtr
                    ((DSURF*)pso->dhsurf)->LinearPtr = pvLastDstOffset;
                }

                // special case handling for saving away stereo frontbufferleft
                if( bOglIsStereoModeEnabled(ppdev) )
                {
                    PVOID pvLastDstOffset;

                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                            ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                    // pfnScreenToMemBlt needs pso->dhsurf to determine src offset
                    pvLastDstOffset = ((DSURF*)pso->dhsurf)->LinearPtr;
                    ((DSURF*)pso->dhsurf)->LinearPtr = ppdev->pjFrameBufbase + ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
        
                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                    // repair primary's LinearPtr
                    ((DSURF*)pso->dhsurf)->LinearPtr = pvLastDstOffset;
                }

            }

            // remember number of actually stored popups to keep opengl overlay happy
            ppdev->lSavedScreenBits++;
            bLinkedListAddElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ulIdent, psoSave, 0);

            bSaveScreenBitsGarbageCollection(ppdev, MAX_SAVESCREENBITS);

            ulRet = (ULONG_PTR)ulIdent;
            break;
        }

        // The driver should restore the data identified by ident to the 
        // rectangle prcl on the display; that is, the driver should restore 
        // the bitmap to its original position. The driver can assume that 
        // the rectangle at prcl is exactly the same size as the rectangle 
        // that was saved. The data should be discarded after this call. 
        // DrvSaveScreenBits should return TRUE if the data has been restored 
        // to the display, or FALSE if the data cannot be restored. 
        case SS_RESTORE:
        {
            HSURF hsurf;
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_RESTORE"));

            //
            // special case handling for restoring overlay frontbuffer and stereo
            // frontbuffer left. Overlay/stereo mode may have been switched on 
            // between saving and restoring => check if overlay/stereo has been saved 
            // !!  we ( may get problems with stereo + overlay at the same time )
            //
            ASSERT(NULL!=prcl);
            if (bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoSave))
            {
                ASSERT(NULL!= psoSave);
                pdsurf     = (DSURF*)psoSave->dhsurf;

                ptlSrc.x = 0;
                ptlSrc.y = 0;

                // offscreen to primary
                if(IS_DEV_DEVICEBITMAP(psoSave))
                {
                    ULONG      ulSrcOffset;
                    LONG       lSrcStride;

                    // source is device bitmap
                    ulSrcOffset = (ULONG)((BYTE *)(pdsurf->LinearPtr) - ppdev->pjFrameBufbase);
                    lSrcStride  = pdsurf->LinearStride;

                    ppdev->pfnSetSourceBase(ppdev, ulSrcOffset, lSrcStride);
                    // destination is our primary
                    ppdev->pfnSetDestBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);

                    // for stereo case we don't allow bufferflipping and have to handle
                    // access to stereo frontbuffer in a NOT doublepumped case

                    // doublepump normal/overlay or flipped case
                    ppdev->pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);

                    if(   (bOglIsOverlayModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                              ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);



                        ASSERT(NULL!=ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt)
                        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                    if(   (bOglIsStereoModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away stereo content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                              ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                        ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt );
                        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);
                    }

                }
                else
                // mainmemory to primary
                {
                    // destination is our primary
                    ppdev->pfnSetDestBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                    // straight (maybe double pumped )mem to screen BLT.
                    ppdev->pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                    if(   (bOglIsOverlayModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                              ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);
                    
                        ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt );
                        ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                    if(   (bOglIsStereoModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                              ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                        ASSERT(NULL!=ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt)
                        ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                }

                // free it now
                ulRet = (ULONG_PTR)bSaveScreenBitsFree(ppdev, ident, psoSave);
            }
            else
            {
                DISPDBG((0, "DrvSaveScreenBits: tried to restore ident 0x%08x which is unknown", ident));
                ulRet = FALSE;
            }

            break;
        }

        
        // The data identified by ident is no longer needed and can be freed. 
        // The value of prcl is undefined and should not be used. The driver 
        // should not restore the saved rectangle to the display. 
        // DrvSaveScreenBits should return TRUE. 
        case SS_FREE:
        {
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_FREE"));
            
            // find ident and free it
            if (bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoSave))
            {
                bSaveScreenBitsFree(ppdev, ident, psoSave);
            }
            else
            {
                DISPDBG((0, "DrvSaveScreenBits: tried to free ident 0x%08x which is unknown", ident));
            }
            ulRet = TRUE;
            break;
        }

        default:
        {
            ASSERT(SS_SAVE==iMode);
            ulRet = FALSE;
            break;
        }
    }

#endif //#if (NVARCH >= 0x4)
Exit:
    DISPDBG((3,"} DrvSaveScreenBits: 0x%08x, lSavedScreenBits:%d", ulRet,ppdev->lSavedScreenBits));
    return ulRet;
}


//*************************************************************************
// bSaveScreenBitsGarbageCollection
// 
// free and remove all saved ScreenBits data and only keep the given number
// of elements.
//*************************************************************************
BOOL bSaveScreenBitsGarbageCollection(
    IN PPDEV ppdev,
    IN ULONG ulKeep) // number of screenbits to keep.
{
    BOOL bRet = TRUE;

    while (ulKeep < ulLinkedListGetCountOfElements(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS))
    {
        ULONG_PTR ulIdent;
        SURFOBJ   *psoFree;

        
        ulIdent = 0;
        psoFree = NULL;
        if (bLinkedListGetOldestElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, &ulIdent, &psoFree))
        {
            ASSERT(NULL != psoFree);
            ASSERT(0    != ulIdent);

            DISPDBG((0, "bSaveScreenBitsGarbageCollection removing 0x%08x", ulIdent));

            bSaveScreenBitsFree(ppdev, ulIdent, psoFree);
        }
        else
        {
            bRet = FALSE;
            break;
        }
    }
    return (bRet);
}


//*************************************************************************
// bSaveScreenBitsFree
// 
// called to free a ScreenBits element and remove it from the linked list. 
// Is called in SS_FREE and the garbage collection routine.
//*************************************************************************
static BOOL bSaveScreenBitsFree(
    IN PPDEV        ppdev,
    IN ULONG_PTR    ident,   // Linked list identifier of node to free
    IN SURFOBJ     *psoFree) // surface to delete
{
    BOOL  bRet = FALSE;
    HSURF hsurf;

    ASSERT(NULL != ppdev);
    ASSERT(0    != ident);
    ASSERT(NULL != psoFree);

    ASSERT(bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoFree));

    hsurf = psoFree->hsurf;

#if 0 // This code is necessary if DrvDeleteDeviceBitmap isn't exported!
// It is tested with 1.09 million popups over three days without
// any leakage.
    if(IS_DEVICEBITMAP(psoFree))
    {
        DrvDeleteDeviceBitmap(psoFree->dhsurf);
    }
#endif
    // NOTE: if hsurf is a device bitmap (created through EngCreateDeviceBitmap)
    //   EngDeleteSurface will call DrvDeleteDeviceBitmap if exported, to destroy 
    //   the pdsurf and poh.
    EngUnlockSurface(psoFree);

    EngDeleteSurface((HSURF)hsurf);

    // remove from linked list
    bLinkedListRemoveElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident);

    // remember number of actually stored popups to keep opengl overlay happy
    ppdev->lSavedScreenBits--;

    ASSERT(ppdev->lSavedScreenBits >= 0);
    ASSERT(ppdev->lSavedScreenBits==(LONG)ulLinkedListGetCountOfElements(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS));

    bRet = TRUE;
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\thunk.c ===
//*****************************Module*Header************************************
//
// Module Name: thunk.c
//
// This module exists solely for testing, to make it is easy to instrument
// all the driver's Drv calls.
//
// Note that most of this stuff will only be compiled in a checked (debug)
// build.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG


// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

////////////////////////////////////////////////////////////////////////////
// By default, GDI does not synchronize drawing to device-bitmaps.  Since
// our hardware dictates that only one thread can access the accelerator
// at a time, we have to synchronize bitmap access.
//
// If we're running on Windows NT 3.5, we can ask GDI to do it by setting
// HOOK_SYNCHRONIZEACCESS when we associate a device-bitmap surface.

// These macros are merely for testing that GDI's HOOK_SYNCHRONIZEACCESS
// actually works:

#define SYNCH_ENTER()
#define SYNCH_LEAVE()

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
#ifdef _WIN32_WINNT         // If >= NT 4.x
HDEV        hdev,
#else
PWSTR       pwszDataFile,
#endif                      // If >= NT 4.x
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV ppdev;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvEnablePDEV(%d x %d %d bpp %d Hz)",
        pDevmode->dmPelsWidth,
        pDevmode->dmPelsHeight,
        pDevmode->dmBitsPerPel,
        pDevmode->dmDisplayFrequency));

    ppdev = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
#ifdef _WIN32_WINNT         // If >= NT 4.x
                hdev,
#else
                pwszDataFile,
#endif                      // If >= NT 4.x
                pwszDeviceName,
                hDriver);

    DISPDBG((1, "<< DrvEnablePDEV: 0x%p",ppdev));
    SYNCH_LEAVE();

    return(ppdev);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvCompletePDEV(ppdev:0x%p, hdev:0x%p)", dhpdev, hdev));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((1, "<< DrvCompletePDEV"));
    SYNCH_LEAVE();
}

VOID DbgSynchronize(
DHPDEV dhpdev,
RECTL  *prcl)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSynchronize"));

    DrvSynchronize(
                dhpdev,
                prcl);

    DISPDBG((6, "<< DrvSynchronize"));
    SYNCH_LEAVE();
}



VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvDisablePDEV(ppdev:0x%p)",dhpdev));

    DrvDisablePDEV(dhpdev);

    DISPDBG((1, "<< DrvDisablePDEV"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvEnableSurface(ppdev:0x%p)",dhpdev));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((1, "<< DrvEnableSurface"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvDisableSurface(ppdev:0x%p)",dhpdev));

    DrvDisableSurface(dhpdev);

    DISPDBG((1, "<< DrvDisableSurface"));
    SYNCH_LEAVE();
}

#ifdef _WIN32_WINNT         // If >= NT 4.x
BOOL  DbgAssertMode(
#else
void  DbgAssertMode(
#endif                      // If >= NT 4.x
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvAssertMode: ppdev: 0x%x, bEnable: %d", dhpdev, bEnable));

#ifdef _WIN32_WINNT     // If >= NT 4.x
    b = DrvAssertMode(dhpdev,bEnable);
#else
    DrvAssertMode(dhpdev,bEnable);
#endif                  // If >= NT 4.x

    DISPDBG((1, "<< DrvAssertMode: ppdev: 0x%x, bEnable: %d", dhpdev, bEnable));
    SYNCH_LEAVE();

#ifdef _WIN32_WINNT     // If >= NT 4.x
    return (b);
#else
    return;
#endif                  // If >= NT 4.x
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((1, ">> DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((1, "<< DrvGetModes"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, ">> DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "<< DrvMovePointer"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "<< DrvSetPointerShape"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, ">> DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "<< DrvDitherColor"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "<< DrvSetPalette"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCopyBits"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDst,NULL,NULL,pco,NULL,prclDst,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "<< DrvCopyBits"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvBitBlt"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDst,NULL,NULL,pco,NULL,prclDst,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "<< DrvBitBlt"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "<< DrvTextOut"));
    SYNCH_LEAVE();

    return(u);
}

#ifdef _WIN32_WINNT         // If >= NT 4.x
BOOL DbgLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((6, "<< DrvLineTo"));
    SYNCH_LEAVE();

    return(u);
}
#endif _WIN32_WINNT         // If >= NT 4.x

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "<< DrvStrokePath"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "<< DrvFillPath"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "<< DrvPaint"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, ">> DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "<< DrvRealizeBrush"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "<< DrvCreateDeviceBitmap"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "<< DrvDeleteDeviceBitmap"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvStretchBlt"));

    // Our DrvStretchBlt routine calls back to EngStretchBlt, which
    // calls back to our DrvCopyBits routine -- so we have to be
    // re-entrant for synchronization...

    SYNCH_LEAVE();

    DISPDBG((0, "DSB: %s %s src:%s %s (%d,%d %d*%d), dst:%s %s (%d,%d %d*%d), msk:%s %s (%d,%d)",
        pco?szDbg_CLIPOBJiDComplexity(pco->iDComplexity):"DC_trivial",
        pxlo?szDbg_XLATEOBJflXlate(pxlo->flXlate):"XO_trivial",
        psoSrc?szDbg_SURFOBJiBitmapFormat(psoSrc->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoSrc), prclSrc->left, prclSrc->top, prclSrc->right-prclSrc->left, prclSrc->bottom-prclSrc->top, 
        psoDst?szDbg_SURFOBJiBitmapFormat(psoDst->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoDst), prclDst->left, prclDst->top, prclDst->right-prclDst->left, prclDst->bottom-prclDst->top, 
        psoMask?szDbg_SURFOBJiBitmapFormat(psoMask->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoMask), psoMask?pptlMask->x:0, psoMask?pptlMask->y:0));

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    SYNCH_ENTER();
    DISPDBG((6, "<< DrvStretchBlt"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgEscape(
SURFOBJ*    pso,
ULONG       iEsc,
ULONG       cjIn,
VOID*       pvIn,
ULONG       cjOut,
VOID*       pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvEscape: 0x%x %s %s", iEsc, szDbg_iEscGet(iEsc), ESC_NV_OPENGL_ESCAPE==iEsc?szDbg_NV_OPENGL_ESCAPE(((NV_OPENGL_COMMAND *)pvIn)->command):(QUERYESCSUPPORT==iEsc?szDbg_iEscGet(*(ULONG *)pvIn):"") ));

    u = DrvEscape(pso,
                  iEsc,
                  cjIn,
                  pvIn,
                  cjOut,
                  pvOut);

    DISPDBG((6, "DrvEscape done"));

    return(u);
}

ULONG DbgDrawEscape(
SURFOBJ *pso,
ULONG    iEsc,
CLIPOBJ *pco,
RECTL   *prcl,
ULONG    cjIn,
PVOID    pvIn)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvDrawEscape"));

    u = DrvDrawEscape(pso,
                      iEsc,
                      pco,
                      prcl,
                      cjIn,
                      pvIn);

    DISPDBG((6, "DrvDrawEscape done"));

    return(u);
}

BOOL DbgResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvResetPDEV(ppdevOld:0x%p -> ppdevNew:0x%p)", dhpdevOld, dhpdevNew));

    bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);

    DISPDBG((1, "<< DrvResetPDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgDestroyFont(FONTOBJ *pfo)
{
    DISPDBG((5, ">> DbgDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "<< DbgDestroyFont"));
}

#ifdef _WIN32_WINNT     // If >= NT 4.x
BOOL DbgGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          lpdwNumHeaps,
VIDEOMEMORY*    pvmList,
DWORD*          lpdwNumFourCC,
DWORD*          lpdwFourCC)
{
    BOOL b;

    DISPDBG((5, ">> DbgQueryDirectDrawInfo"));

    b = DrvGetDirectDrawInfo(dhpdev,
                             pHalInfo,
                             lpdwNumHeaps,
                             pvmList,
                             lpdwNumFourCC,
                             lpdwFourCC);

    DISPDBG((6, "<< DbgQueryDirectDrawInfo"));

    return(b);
}

BOOL DbgEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    b = DrvEnableDirectDraw(dhpdev,
                            pCallBacks,
                            pSurfaceCallBacks,
                            pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(b);
}

VOID DbgDisableDirectDraw(
DHPDEV      dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}

#if _WIN32_WINNT >= 0x0500

BOOL	DbgIcmSetDeviceGammaRamp(
	DHPDEV	dhpdev,
	ULONG	iFormat,
	LPVOID	lpRamp
)
{
	BOOL	b;

	DISPDBG((5, ">> DbgIcmSetDeviceGammaRamp"));

	b = DrvIcmSetDeviceGammaRamp(dhpdev, iFormat, lpRamp);

	DISPDBG((6, "<< DbgIcmSetDeviceGammaRamp"));

	return(b);
}


HBITMAP	DbgDeriveSurface(
	DD_DIRECTDRAW_GLOBAL	*pDirectDraw,
	DD_SURFACE_LOCAL		*pSurface
)
{
	HBITMAP	hbm;

	DISPDBG((1, ">> DbgDeriveSurface"));

	hbm	= DrvDeriveSurface(pDirectDraw, pSurface);

	DISPDBG((1, "<< DbgDeriveSurface"));

	return(hbm);
}

void DbgDrvNotify(
    SURFOBJ *hsurf,
    ULONG iType,
    PVOID pvData
)
{
	DISPDBG((1, ">> DbgDrvNotify"));

	DrvNotify(hsurf, iType, pvData);

	DISPDBG((1, "<< DbgDrvNotify"));
}

BOOL DbgAlphaBlend(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ  *pxlo,
    RECTL  *prclDest,
    RECTL  *prclSrc,
    BLENDOBJ  *pBlendObj) 
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvAlphaBlend"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDest,NULL,NULL,pco,NULL,prclDest,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvAlphaBlend(
        psoDest,
        psoSrc,
        pco,
        pxlo,
        prclDest,
        prclSrc,
        pBlendObj); 

    DISPDBG((6, "<< DrvAlphaBlend"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTransparentBlt(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    RECTL    *prclSrc,
    ULONG     iTransColor,
    ULONG     Reserved) 
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvTransparentBlt"));

    u = DrvTransparentBlt(
        psoDest,
        psoSrc,
        pco,
        pxlo,
        prclDest,
        prclSrc,
        iTransColor,
        Reserved); 

    DISPDBG((6, "<< DrvTransparentBlt"));
    SYNCH_LEAVE();

    return(u);
}

#endif //_WIN32_WINNT >= 0x0500

#endif      // If >= NT 4.x

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\stretch.c ===
//******************************Module*Header***********************************
//
// Module Name: stretch.c
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)

    {
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;

    RECTL       rclClip;
    RECTL*      prclClip;
    ULONG       DstWidth;
    ULONG       DstHeight;
    ULONG       SrcWidth;
    ULONG       SrcHeight;
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;
    LONG        i;
    FNXFER*         pfnXfer;
    POINTL      ptlSrc;

    //**************************************************************************
    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:
    //**************************************************************************

    //**************************************************************************
    // For NV: Our primary surface is NOT a device surface.
    // It is a GDI managed, standard DIB surface...
    //**************************************************************************

    pdsurfSrc = NULL;
    pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;


    ppdev = (PDEV*) psoDst->dhpdev;


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**************************************************************************
    // NV: This function is NOT currently implemented/hooked
    // TODO:  Add punt/wrapper functionality same as BitBlt!
    //**************************************************************************

    return(TRUE);




    //**************************************************************************
    // It's quicker for GDI to do a StretchBlt when the source surface
    // is NOT a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.
    //
    // NV:  This works much better with our driver since we use GDI-MANAGED
    //      surfaces.  No need to call DrvCopyBits so performance is better.
    //      (We can directly read the source bits, no problem)
    //**************************************************************************

    //**************************************************************************
    // Currently, we only support the following type of stretch DIB
    //      - No mask
    //      - Source is a DIB (STYPE_BITMAP), 1 bpp with pxlo->flXlate = XO_TABLE
    //          which means we get 1 colors, one for foreground and one for background
    //      - Destination is screen
    //      - 1 to 1 stretching (no stretching)
    //      - Clipping is DC_TRIVIAL
    //**************************************************************************

    if (    (psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            (pxlo != NULL) &&
            (pxlo->flXlate & XO_TABLE) &&
            (pxlo->cEntries == 2) &&
            (psoSrc->iBitmapFormat == BMF_1BPP) &&
            (pco !=NULL) &&
            (pco->iDComplexity == DC_TRIVIAL)
        )

        {
        DstWidth  = prclDst->right - prclDst->left;
        DstHeight = prclDst->bottom - prclDst->top;

        SrcWidth  = prclSrc->right - prclSrc->left;
        SrcHeight = prclSrc->bottom - prclSrc->top;

        //**********************************************************************
        // Right now, we don't really do stretching.
        // We only support 1 to 1 copies with a monochrome source bitmap.
        // DeviceBitmapBit calls come thru here.
        //**********************************************************************

        if ( (DstWidth == SrcWidth) &&
             (DstHeight == SrcHeight))
            {

            pfnXfer = ppdev->pfnXfer1bpp;

            //******************************************************************
            // Specify 1 'clip' rectangle (same as original destination rectangle)
            // Manually specify 0xCCCC for Source Copy ROP
            // PatternColor doesn't matter in this case since this is a SRCCOPY rop
            //   (no pattern involved) so we'll just send 0x00000000
            // Send the origin of the source rectangle in ptlSrc..for now
            // we just care about the origin since we're not doing stretching
            //******************************************************************

            ptlSrc.x = prclSrc->left;
            ptlSrc.y = prclSrc->top;

            pfnXfer(ppdev, 1, prclDst, 0xCCCC, psoSrc, &ptlSrc, prclDst, pxlo,0x00000000,NULL);
            return(TRUE);
            }

        else
            {
            //******************************************************************
            // Eventually, we'll add the stretch functionality
            // For now, just fall through to GDI.
            //******************************************************************
            }

        }

    //**************************************************************************
    // Send call back to GDI, we didn't handle it.
    //**************************************************************************

    //**************************************************************************
    // TODO:  Add punt/wrapper functionality same as BitBlt!
    //**************************************************************************

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wksappsupport.h ===
#ifndef _WKSAPPSUPPORT_H
#define _WKSAPPSUPPORT_H
/**************************************************************************
** wksappsupport.h
**
** This module handles the ESC_NV_WKS_APP_SUPPORT escape to 
** support the workstation tools interface.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 09.11.2000: New
**************************************************************************/

LONG lWksAppSupport(SURFOBJ *pso, 
                    ULONG cjIn, VOID *pvIn,
                    ULONG cjOut, VOID *pvOut);

#define WKS_ESC_SUCCEED      1
#define WKS_ESC_UNSUPPORTED  0
#define WKS_ESC_FAILED      -1

#endif // _WKSAPPSUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wksappsupport.c ===
/**************************************************************************
** wksappsupport.c
**
** This module handles the ESC_NV_WKS_APP_SUPPORT escape to 
** support the workstation tools interface.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 09.11.2000: New
** FNicklisch 21.11.2000: Implemented SUBESC_WKS_WINDOW_STEREOMODE
**************************************************************************/

// import
#include "precomp.h"
#include "driver.h"
#include "Nvcm.h"
#include "nvapi.h"
#include "nv32.h"
#include "oglDD.h"
#include "oglstereo.h"
#include "wincommon.h"
#include "pixelfmt.h"

// export
#include "wksappsupport.h"


static BOOL bWksWindowStereoSupport(
    IN     PPDEV ppdev,
    IN     NV_WKS_WINDOW_STEREOMODE_IN  *pWindowStereoModeIn ,
       OUT NV_WKS_WINDOW_STEREOMODE_OUT *pWindowStereoModeOut);


#define CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cj, cjNeeded, lRet, pHeadOut, lErrorCode); \
    if (cj != cjNeeded)                     \
    {                                       \
        if (NULL != pHeadOut)               \
        {                                   \
            pHeadOut->ulSize  = cjNeeded;   \
            pHeadOut->lResult = lErrorCode; \
        }                                   \
        lRet = WKS_ESC_SUCCEED;             \
        goto Exit;                          \
    }

#define CHECK_CJINOUT_AND_GOTO_EXIT_IF_FAIL(cjIn, cjInNeeded, cjOut, cjOutNeeded, lRet, pHeadOut);   \
    CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , cjInNeeded , lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE ); \
    CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, cjOutNeeded, lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);


//*************************************************************************
// lWksAppSupport
//
// handles all ESC_NV_WKS_APP_SUPPORT subescapes.
// return WKS_ESC_SUCCEED     - escape was handled, detailed status
//                              in NV_WKS_HEAD_OUT.
//        WKS_ESC_UNSUPPORTED - unsupported escape
//        WKS_ESC_FAILED      - escape failed
//*************************************************************************
LONG lWksAppSupport(
    SURFOBJ *pso, 
    ULONG   cjIn, 
    VOID    *pvIn,
    ULONG   cjOut, 
    VOID    *pvOut)
{
    LONG             lRet        = WKS_ESC_FAILED; // default to error
    NV_WKS_HEAD_IN  *pHeadIn     = (NV_WKS_HEAD_IN *)pvIn;
    NV_WKS_HEAD_OUT *pHeadOut    = NULL;
    PPDEV            ppdev       = NULL;

    ASSERT(NULL != pso);
    ASSERT(NULL != pvIn);
    ASSERT(cjIn > 0);

    if (   (NULL == pvIn)
        || (cjIn < sizeof(NV_WKS_HEAD_IN))
        || ( (cjOut != 0) && (NULL == pvOut) ) 
        || ( (cjOut != 0) && (cjOut < sizeof(NV_WKS_HEAD_OUT) ) )
       )
    {
        // interface error, escape used in a wrong manner
        goto Exit;
    }

    //
    // Check and initialize out structure
    //
    if (cjOut != 0)        
    {
        ASSERT(NULL != pvOut);
        ASSERT(cjOut>= sizeof(NV_WKS_HEAD_OUT));

        RtlZeroMemory(pvOut, cjOut);

        pHeadOut            = (NV_WKS_HEAD_OUT *)pvOut;
        pHeadOut->ulVersion = NV_WKS_VERSION;

        CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , pHeadIn->ulInSize , lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
        CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, pHeadIn->ulOutSize, lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

        pHeadOut->ulSize    = pHeadIn->ulOutSize;
        pHeadOut->lResult   = NV_WKS_RESULT_ERROR; // until now we assume we fail
    }

    ppdev = (PDEV *)pso->dhpdev;

    //
    // handle known escapes
    //
    switch (pHeadIn->ulSubEsc)
    {
        case SUBESC_WKS_GET_CAPS:
        {
            ULONG               status;
            NV_WKS_GET_CAPS_IN  *pGetCapsIn  = pvIn;
            NV_WKS_GET_CAPS_OUT *pGetCapsOut = pvOut;

            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , sizeof(NV_WKS_GET_CAPS_IN ), lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, sizeof(NV_WKS_GET_CAPS_OUT), lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

            //
            // Get data
            //

            // translate the config bits that possibly change in future to a stable interface
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AA_LINES       ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AA_LINES       ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AA_POLYS       ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AA_POLYS       ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AKILL_USERCLIP ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_LOGIC_OPS      ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_LOGIC_OPS      ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_NV15_ALINES    ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_NV15_ALINES    ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_2SIDED_LIGHTING;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_UBB ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_UBB ;

            pGetCapsOut->ulMaxClipRects = HWGFXCAPS_MAXCLIPS(ppdev);

            if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
            {
                ULONG ulPFDCaps=0;
                ASSERT(pGetCapsOut->flGraphicsCaps & NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC);

                pGetCapsOut->flWksCaps |= NV_WKS_CAPS_WORKSTATION_BOARD;

                bOglPfdCheckFlags(ppdev, &ulPFDCaps);

                if (ulPFDCaps & WIN_PFD_SUPPORTS_OVERLAYS)
                    pGetCapsOut->flWksCaps |= NV_WKS_CAPS_OVERLAY_CAPABLE;

                if (ulPFDCaps & WIN_PFD_SUPPORTS_STEREO)
                    pGetCapsOut->flWksCaps |= NV_WKS_CAPS_STERO_CAPABLE;
            }

            pHeadOut->lResult = NV_WKS_RESULT_SUCCESS;
            break;
        }

        case SUBESC_WKS_WINDOW_STEREOMODE:
        {
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , sizeof(NV_WKS_WINDOW_STEREOMODE_IN ), lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, sizeof(NV_WKS_WINDOW_STEREOMODE_OUT), lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

            if (!bWksWindowStereoSupport(ppdev, pvIn, pvOut))
            {
                // severe error!
                goto Exit;
            }

            break;
        }

        default:
        {
            // unsupported escape
            if (cjOut >= sizeof(NV_WKS_HEAD_OUT))
            {
                pHeadOut->ulSize  = sizeof(NV_WKS_HEAD_OUT); // can only feed header
                pHeadOut->lResult = NV_WKS_RESULT_ERROR_SUBESC_NOT_SUPPORTED;
            }
            break;
        }
    }

    lRet = WKS_ESC_SUCCEED; // escape handled

Exit:
    return (lRet);
}


//*************************************************************************
// bWksWindowStereoSupport
//
// handles SUBESC_WKS_WINDOW_STEREOMODE escape. In and out structures 
// must be valid.
//
// NOTE: example escape code below
//
// return: FALSE - failed, pWindowStereoModeOut not valid
//         TRUE  - succeeded, pWindowStereoModeOut valid
//*************************************************************************
static BOOL bWksWindowStereoSupport(
    IN     PPDEV ppdev,
    IN     NV_WKS_WINDOW_STEREOMODE_IN  *pWindowStereoModeIn ,
       OUT NV_WKS_WINDOW_STEREOMODE_OUT *pWindowStereoModeOut)
{
    BOOL                        bRet            = FALSE;
    NV_OPENGL_CLIENT_INFO_LIST *clientList      = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo      = NULL;
    BOOL                        bStereoClient   = FALSE;

    ASSERT(NULL != ppdev               );
    ASSERT(NULL != pWindowStereoModeIn );
    ASSERT(NULL != pWindowStereoModeOut);

    pWindowStereoModeOut->hwnd = pWindowStereoModeIn->hwnd;


    // work on specified window?
    if (NULL != pWindowStereoModeIn->hwnd)
    {
        // Set or query for specified window
        clientList = OglFindClientInfoFromHWnd(ppdev, pWindowStereoModeIn->hwnd);

        if (NULL != clientList)
        {
            clientInfo = &clientList->clientInfo;

            bStereoClient = bOglIsStereoClient(clientInfo);

            switch (pWindowStereoModeIn->ulMode)
            {
                case NV_WKS_WINDOW_STEREOMODE_ENABLE :
                case NV_WKS_WINDOW_STEREOMODE_DISABLE:
                {
                    if (bStereoClient)
                    {
                        // set stereo clients stereo mode
                        clientInfo->bStereoDisabled = (NV_WKS_WINDOW_STEREOMODE_DISABLE == pWindowStereoModeIn->ulMode) ? TRUE : FALSE;

                        //
                        // KEY: Update stereo mode now!
                        //
                        bOglStereoModeUpdate(ppdev);

                        pWindowStereoModeOut->ulMode      = clientInfo->bStereoDisabled ? NV_WKS_WINDOW_STEREOMODE_DISABLED 
                                                                                        : NV_WKS_WINDOW_STEREOMODE_ENABLED;
                        pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_SUCCESS;
                    }
                    else
                    {
                        // error, cannot set stereo mode on monoscopic window
                        pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND;
                        pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
                    }
                    break;
                }
                case NV_WKS_WINDOW_STEREOMODE_QUERY:
                {
                    if (bStereoClient)
                    {
                        pWindowStereoModeOut->ulMode  = clientInfo->bStereoDisabled ? NV_WKS_WINDOW_STEREOMODE_DISABLED 
                                                                                    : NV_WKS_WINDOW_STEREOMODE_ENABLED;
                    }
                    else
                    {
                        pWindowStereoModeOut->ulMode  = NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND;
                    }
                    // succeed because it's a query
                    pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_SUCCESS;
                    break;
                }
            }
        }
        else
        {
            // error, given window not found
            pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_INVALID_HWND;
            pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
        }
    } 
    else
    {
        // No window given, query only!

        switch (pWindowStereoModeIn->ulMode)
        {
            case NV_WKS_WINDOW_STEREOMODE_QUERY:
            {
                if (0==cOglStereoClients(ppdev))
                {
                    pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_NO_STEREO;
                }
                else
                {
                    if (ppdev->bOglStereoActive)
                        pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_ENABLED;
                    else
                        pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_DISABLED;
                }

                pWindowStereoModeOut->hdr.lResult    = NV_WKS_RESULT_SUCCESS;
                break;
            }
            case NV_WKS_WINDOW_STEREOMODE_ENABLE :
            case NV_WKS_WINDOW_STEREOMODE_DISABLE:
            {
                // error, not allowed without window
                pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_INVALID_HWND;
                pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
                break;
            }
            default:
            {
                // error, unkown parameter
                pWindowStereoModeOut->hdr.lResult            = NV_WKS_RESULT_ERROR_PARAMETER;
                break;
            }
        }
    }

    bRet = TRUE;

    return (bRet);
}



#if 0 

// 
// Example code, please do not delete!
//

/* 
// SUBESC_WKS_GET_CAPS
{
    HDC                 hDC;
    NV_WKS_GET_CAPS_IN  wksGetCapsIn;
    NV_WKS_GET_CAPS_OUT wksGetCapsOut;
    int                 iResult;

    hDC = GetDC(hWnd); // NOTE: a NULL hWnd will fail on Windows 2000 multiscreen

    if (NULL != hDC)
    {

        ZeroMemory(&wksGetCapsIn,  sizeof(NV_WKS_GET_CAPS_IN));
        ZeroMemory(&wksGetCapsOut, sizeof(NV_WKS_GET_CAPS_OUT));

        NV_WKS_INIT_HEAD_IN(&wksGetCapsIn, SUBESC_WKS_GET_CAPS, sizeof(NV_WKS_GET_CAPS_IN), sizeof(NV_WKS_GET_CAPS_OUT), 0);

        iResult = ExtEscape(hDC,                         // handle to DC
                            ESC_NV_WKS_APP_SUPPORT,      // escape function
                            sizeof(NV_WKS_GET_CAPS_IN),  // size of input structure
                            (LPCSTR)&wksGetCapsIn,       // input structure
                            sizeof(NV_WKS_GET_CAPS_OUT), // size of output structure
                            (LPSTR)&wksGetCapsOut);      // output structure
        if (iResult > 0)
        {
            // Escape succeeded, wksGetCapsOut valid
            if (   (sizeof(NV_WKS_GET_CAPS_OUT) == wksGetCapsOut.hdr.ulSize) // expected size must match
                && (wksGetCapsOut.hdr.ulVersion >= NV_WKS_VERSION)           // driver must at least have this version of interface
                && (wksGetCapsOut.hdr.lResult   >  0) )                      // no error
            {
                // Succeeded!
                //
                // TODO: add code to work with 
                //  wksGetCapsOut.flGraphicsCaps;
                //  wksGetCapsOut.ulMaxClipRects;
                //  wksGetCapsOut.flWksCaps;
            }
            else
            {
                // ERROR: Any internal error in usage of escape (sizes, state of driver, ...)
            }
        }
        else if (0 == iResult)
        {
            // ERROR: Escape not implemented
        }
        else // iResult < 0
        {
            // ERROR: Escape failed
        }

        ReleaseDC(hWnd, hDC);
    }
    else
    {
        // ERROR: couldn't retrieve a HDC
    }
}


//SUBESC_WKS_WINDOW_STEREOMODE

//*************************************************************************
// bNvWksWindowStereomodeSelect
//
// enables or disables stereo mode on given window. The function will only 
// succeed if the window is an OpenGL window that has a stereo pixelformat 
// selected.
//
// return: TRUE  - succeeded, returns current status to pbNewStereoStatus
//         FALSE - failed, pbNewStereoStatus not touched
//
// FNicklisch 21.11.2000: new
//*************************************************************************
BOOL bNvWksWindowStereomodeSelect(
    IN     HWND hWnd,               // hwnd of stereo window
       OUT BOOL bStereoModeEnable,  // TRUE: enable stereo mode, FALSE: disable stereo mode
       OUT BOOL *pbNewStereoStatus)   // pointer to return status or NULL
{
    BOOL                         bRet          = FALSE;
    NV_WKS_WINDOW_STEREOMODE_IN  wksWindowStereomodeIn ;
    NV_WKS_WINDOW_STEREOMODE_OUT wksWindowStereomodeOut;
    size_t                       inSize ;
    size_t                       outSize;
    int                          iResult;
    HDC                          hDC;

    hDC = GetDC(hWnd);

    if (NULL != hDC)
    {
        inSize  = sizeof(NV_WKS_WINDOW_STEREOMODE_IN );
        outSize = sizeof(NV_WKS_WINDOW_STEREOMODE_OUT);

        ZeroMemory(&wksWindowStereomodeIn , inSize );
        ZeroMemory(&wksWindowStereomodeOut, outSize);

        NV_WKS_INIT_HEAD_IN(&wksWindowStereomodeIn, SUBESC_WKS_WINDOW_STEREOMODE, inSize, outSize, 0);

        wksWindowStereomodeIn.hwnd   = hWnd;
        wksWindowStereomodeIn.ulMode = bStereoModeEnable ? NV_WKS_WINDOW_STEREOMODE_ENABLE : NV_WKS_WINDOW_STEREOMODE_DISABLE;

        iResult = ExtEscape(hDC,                             // handle to DC
                            ESC_NV_WKS_APP_SUPPORT,          // escape function
                            inSize,                          // size of input structure
                            (LPCSTR)&wksWindowStereomodeIn, // input structure
                            outSize,                         // size of output structure
                            (LPSTR)&wksWindowStereomodeOut); // output structure

        if (iResult > 0)
        {
            if (   (outSize == wksWindowStereomodeOut.hdr.ulSize)           // expected size must match
                && (wksWindowStereomodeOut.hdr.ulVersion >= NV_WKS_VERSION) // driver must at least have this version of interface
                && (wksWindowStereomodeOut.hdr.lResult   == NV_WKS_RESULT_SUCCESS) )            // no error
            {
                if (wksWindowStereomodeOut.hwnd != hWnd)
                {
                    // ERROR, wrong out hwnd
                }
                else
                {
                    switch (wksWindowStereomodeOut.ulMode)
                    {
                        case NV_WKS_WINDOW_STEREOMODE_DISABLED:
                        {
                            if (pbNewStereoStatus)
                                *pbNewStereoStatus = FALSE;
                            bRet = TRUE;
                            break;
                        }

                        case NV_WKS_WINDOW_STEREOMODE_ENABLED:
                        {
                            if (pbNewStereoStatus)
                                *pbNewStereoStatus = TRUE;
                            bRet = TRUE;
                            break;
                        }

                        default:
                        {
                            // any error, wrong usage of escape
                            break;
                        }
                    }
                }
            }
            else
            {
                // ERROR: Any internal error in usage of escape (sizes, state of driver, ...)
            }
        }
        else if (0 == iResult)
        {
            // ERROR: Escape not implemented
        }
        else // iResult < 0
        {
            // ERROR: Escape failed
        }
        ReleaseDC(hWnd,hDC);
    }

    return (bRet);
}
  
    

  
    
*/
#endif

// End of wksappsupport.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\vpe_nt.h ===
// this will bring over alot of types which are useful

#include <dx95type.h>

#ifndef DEBUG
	#ifndef DPF
	    #define DPF         1 ? (void)0 : (void)
	#endif
#else
/*
 * Msg
 * Defined in ddsamp.c
 */
extern void __cdecl DPF( LPSTR szFormat, ... );
#endif

/* Debug stuff */
#ifdef DEBUG
	#define ASSERT(ParamAssert) 	(ParamAssert)? \
			(void)0:DPF("Assertion failed in %s at line %i\n", __FILE__, __LINE__)

	#define strASSERT( Condition, string )	(Condition)?\
			(void)0:DPF("Assertion failed in %s at line %i, %s", __FILE__, __LINE__, strAssert)		

#else
	#define Assert( ParamAssert )
	#define ASSERT( ParamAssert )
	#define strASSERT( Condition, string )
#endif
	
/* Prototypes for VPE_NT.c */
                                   
DWORD PASCAL CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput);
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput);
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput);
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput);
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput);
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput);
DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput);
DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput);
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput);
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput);
DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput);
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput);
DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput);
DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput);	


// This structure will be used to store all of the OS specific stuff which might 
// otherwise be part of the vpSurfaces  structure

typedef struct _OSSpecificGlobals {
	long	dwVideoPortsAvailable;		// the number of video ports available.. inited as one usually
												// and decremented per useage
												
												
} OSSpecificGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsdebug.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsdebug.c
//
// Debug code 
//
// FNicklisch 09/14/2000: New, derived from debug.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "ELSAESC.h"
#include "wkselsatoolsescape.h"
#include "wkselsatoolstoolbox.h"
#include "wkselsatoolsregistry.h"

#if DBG
// export header file
#include <wkselsatoolsdebug.h>


// FNicklis 21.10.98: New sub escapes defined
DBG_NAMEINDEX aDbgETSubEscName[]=
{
  // Sub escapes, common for Windows 95 and Windows NT:
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VERSION_INFO     ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_STRING     ), 
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_DWORD      ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_BINARY     ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_STRING       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_DWORD        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_BINARY       ),

  // 0x30-0x4F reserved for WINman
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DATA_GET        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DATA_SET        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DDC_EDID_GET    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DATA_GET       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DATA_SET       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DDC_EDID_GET   ),

  // 0x50-0x6F reserved for elsa directdraw caps
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCAPS            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETFEATURES        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETFEATURES        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETVIDMEMINFO      ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCOLORADJUSTMENT ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETCOLORADJUSTMENT ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETGAMMARAMP       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETGAMMARAMP       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCOLORCAPSLIMITS ),

  // 0x100-0x11F reserved for Video-In / -Out Escapes
  //
  DBG_MAKE_NAMEINDEX(SUBESC_ET_VIDEO_DMACOPYSM        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_VIDEO_OUTCONTROL       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_RMAPI_CONFIGSETGET     ),

  // 0x200-0x21F reserved for all tools to decide if they are
  //             allowed to pop up, only to be used in combination
  //             with a resctricted call RES_ESC_ELSA_TOOL
  //
  DBG_MAKE_NAMEINDEX(SUBESC_STEREO_TOOL               ),

  // 0x300-0x3FF reserved for hardware status and control
  //
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_TEMPERATURE      ),
  
  
  // ********************************************************
  // Windows 95 sub escapes:

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_MONITORKEY_REGPATH    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_D3DSETTINGS_REGPATH   ),

  // ********************************************************
  // Windows NT sub escapes:

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_OPENGLICD_REGPATH),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DUO_ESC_GETPANELINFO   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DUO_ESC_SETPANELINFO   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_POWERLIB_START         ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_POWERLIB_EXIT          ),

  // 0x10-0x2F reserved for driver internal escapes
  DBG_MAKE_NAMEINDEX(SUBESC_ET_GETREGISTER            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SETREGISTER            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_MODIFYREGISTER         ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SCROLL                 ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_GFXOPTIONQUERY         ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_NOTIFYDRIVER           ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SAA                    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DDSURFOVERRIDE         ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_MULTIBOARDSETUP        ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_DPMS                   ),

  // 0x30- ... Common driver Escapes
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SETWINDOW_STEREOMODE   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_ICDCLIENTINFO    ),
};

char *szDbg_GetETSubEscName(LONG SubEscNr)
{
  return (DBG_GETDBG_NAMEINDEX(aDbgETSubEscName, SubEscNr));
}

// 17.09.1998 FNicklis: New
char *pszDbg_GetFLOH(FLOH floh)
{
  static char pszRet[80];

  pszRet[0]='\0'; // delete string 

  if (0!=floh)
  {
    strcpy( pszRet, "(");

    if (floh & FLOH_ONLY_IF_ROOM) 
    {  // Don't kick stuff out of offscreen memory to make room
      strcat( pszRet, "FLOH_ONLY_IF_ROOM");
      floh &= ~FLOH_ONLY_IF_ROOM;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh & FLOH_MAKE_PERMANENT) 
    { // Allocate a permanent entry
      strcat( pszRet, "FLOH_MAKE_PERMANENT");
      floh &= ~FLOH_MAKE_PERMANENT;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh & FLOH_RESERVE) // Allocate an off-screen entry,
    {
      strcat( pszRet, "FLOH_RESERVE");
      floh &= ~FLOH_RESERVE;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh)
    {
      strcat( pszRet, "unknown");
    }

    strcat( pszRet, ")");
  }
  return (pszRet);
}

// FN new, taken from old glint sources

VOID vDbg_PrintPOINTL(FLONG flFlags, PCHAR pcString, const POINTL *pptl)
{
  if (pptl)
  {
    DISPDBG((flFlags, "%s: x:%-5d y:%-5d",pcString, pptl->x, pptl->y));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

VOID vDbg_PrintRECTL(FLONG flFlags, PCHAR pcString, const RECTL *prcl)
{
  if (prcl)
  {
    DISPDBG((flFlags, "%s: l:%-5d t:%-5d r:%-5d b:%-5d (w:%-5d h:%-5d)", pcString,
      prcl->left, prcl->top, prcl->right, prcl->bottom, prcl->right-prcl->left,prcl->bottom-prcl->top));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}


VOID vDbg_PrintSIZEL(FLONG flFlags, PCHAR pcString, const SIZEL *psiz)
{
  if (psiz)
  {
    DISPDBG((flFlags, "%s: cx:%08x cy:%08x",
      pcString, psiz->cx, psiz->cy));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

VOID vDbg_PrintCLIPOBJiDComplexity(FLONG flFlags, BYTE iDComplexity)
{
  switch(iDComplexity)
  {
    case DC_TRIVIAL:
      DISPDBG((flFlags, " DC_TRIVIAL"));
      break;
    case DC_RECT:   
      DISPDBG((flFlags, " DC_RECT"));
      break;
    case DC_COMPLEX:
      DISPDBG((flFlags, " DC_COMPLEX"));
      break;
    default: 
      DISPDBG((flFlags, " DC_??:0x%x",iDComplexity));
      break;
  }
}

VOID vDbg_PrintCLIPOBJiFComplexity(FLONG flFlags, BYTE iFComplexity)
{
  switch(iFComplexity)
  {
    case FC_RECT:    
      DISPDBG((flFlags, "FC_RECT"));
      break;
    case FC_RECT4:   
      DISPDBG((flFlags, "FC_RECT4"));
      break;
    case FC_COMPLEX: 
      DISPDBG((flFlags, "FC_COMPLEX"));
      break;
    default: 
      DISPDBG((flFlags, "FC_??:0x%x",iFComplexity));
      break;
  }
}

VOID vDbg_PrintCLIPOBJ(FLONG flFlags, PCHAR pcString, const CLIPOBJ *pco)
{
  if (pco)
  {
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: 0x%p, iUniq:%08x ", pcString, pco, pco->iUniq));

    vDbg_PrintCLIPOBJiDComplexity(flFlags|DBG_LVL_NOLINEFEED|DBG_LVL_NOPREFIX, pco->iDComplexity);
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED|DBG_LVL_NOPREFIX, " "));
    vDbg_PrintCLIPOBJiFComplexity(flFlags|DBG_LVL_NOPREFIX, pco->iFComplexity);

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: ", pcString));
    vDbg_PrintRECTL(flFlags|DBG_LVL_NOPREFIX, "rclBounds", &pco->rclBounds);
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

#ifndef PAL_DC
// NT 3.51
#define PAL_DC		      0x00000010
#define PAL_FIXED	      0x00000020
#define PAL_FREE	      0x00000040
#define PAL_MANAGED	    0x00000080
#define PAL_NOSTATIC	  0x00000100
#define PAL_MONOCHROME	0x00000200
#define PAL_DITHER	    0x00000400
#endif

DBG_NAMEINDEX aDbgXLATEOBJiTypeNames[] =
{
  DBG_MAKE_NAMEINDEX(PAL_DC        ),
  DBG_MAKE_NAMEINDEX(PAL_FIXED     ),
  DBG_MAKE_NAMEINDEX(PAL_FREE      ),
  DBG_MAKE_NAMEINDEX(PAL_MANAGED   ),
  DBG_MAKE_NAMEINDEX(PAL_NOSTATIC  ),
  DBG_MAKE_NAMEINDEX(PAL_MONOCHROME),
  DBG_MAKE_NAMEINDEX(PAL_DITHER	   ),
  DBG_MAKE_NAMEINDEX(PAL_INDEXED   ),
  DBG_MAKE_NAMEINDEX(PAL_BITFIELDS ),
  DBG_MAKE_NAMEINDEX(PAL_RGB       ),
  DBG_MAKE_NAMEINDEX(PAL_BGR       ),
};

/*
** Find string matching ulIndex out of DBG_NAMEINDEX array pNameIndex
*/
char *szDbg_GetDBG_NAMEINDEX(IN const DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex)
{
  char *szRet=NULL;

  while (lEntries)
  {
    if (pNameIndex->ulIndex == ulIndex)
    { 
      szRet=pNameIndex->szName;
      break;
    }
    pNameIndex++;
    lEntries--;
  }
  
  if (szRet==NULL)
    szRet="unknown\0??????????????????????"; // Added space to allow strange things on the pointer returned!

  return (szRet);
}

char *szDbg_GetXLATEOBJiTypeName(ULONG fl)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgXLATEOBJiTypeNames, sizeof(aDbgXLATEOBJiTypeNames)/sizeof(aDbgXLATEOBJiTypeNames[0]), fl));
}

VOID vDbg_PrintXLATEOBJiType(FLONG flFlags, USHORT iType)
{
  vDbg_PrintflCapabilities(
    flFlags, 
    "", 
    szDbg_GetXLATEOBJiTypeName,
    (ULONG)iType);
}

VOID vDbg_PrintXLATEOBJflXlate(FLONG flFlags, FLONG flXlate)
{
  if (flXlate & XO_TRIVIAL) 
    DISPDBG( (flFlags, " XO_TRIVIAL"));
  if (flXlate & XO_TABLE) 
    DISPDBG( (flFlags, " XO_TABLE  "));
  if (flXlate & XO_TO_MONO) 
    DISPDBG( (flFlags, " XO_TO_MONO")); 
  if (flXlate & 0x00000008) 
    DISPDBG( (flFlags, " XO_FROM_CMYK")); 
  if (flXlate & 0x00000010) 
    DISPDBG( (flFlags, " XO_DEVICE_ICM")); 
  if (flXlate & 0x00000020) 
    DISPDBG( (flFlags, " XO_HOST_ICM")); 

#if (_WIN32_WINNT >= 0x500)
  #if ((XO_FROM_CMYK != 0x00000008) || (XO_DEVICE_ICM != 0x00000010) || (XO_HOST_ICM != 0x00000020))
    #error Check DDK defintions for XLATES flags!
  #endif
#endif

  if (!(flXlate & (XO_TO_MONO | XO_TABLE | XO_TRIVIAL | 0x00000008 | 0x00000010 | 0x00000020))) 
    DISPDBG( (flFlags, " XO_??? (0x%x)", flXlate));
}

VOID vDbg_PrintXLATEOBJ(FLONG flFlags, PCHAR pcString, const XLATEOBJ *pxlo)
{
  if (pxlo)
  {
    DISPDBG((flFlags, "%s: 0x%p", pcString, pxlo));
    DISPDBG((flFlags, "%s: iUniq:0x%x, cEntries:%d, pulXlate:0x%p", pcString, pxlo->iUniq, pxlo->cEntries, pxlo->pulXlate));

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: flXlate:0x%x ", pcString, pxlo->flXlate));
    vDbg_PrintXLATEOBJflXlate(flFlags|DBG_LVL_NOPREFIX, pxlo->flXlate);
    
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: iSrcType:0x%x ", pcString, pxlo->iSrcType));
    vDbg_PrintXLATEOBJiType(flFlags|DBG_LVL_NOPREFIX, pxlo->iSrcType);

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: iDstType:0x%x ", pcString, pxlo->iDstType));
    vDbg_PrintXLATEOBJiType(flFlags|DBG_LVL_NOPREFIX, pxlo->iDstType);
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));   
  }
  DISPDBG((flFlags, "."));   
}

VOID vDbg_PrintSURFOBJiType(FLONG flFlags, USHORT  iType)
{
  switch(iType)
  {
    case STYPE_BITMAP:    DISPDBG( (flFlags," STYPE_BITMAP")); 
                          break;
    case STYPE_DEVBITMAP: DISPDBG( (flFlags, " STYPE_DEVBITMAP")); 
                          break;
    case STYPE_DEVICE:    DISPDBG( (flFlags," STYPE_DEVICE")); 
                          break;
    default:              DISPDBG( (flFlags," STYPE_? 0x%x",iType)); 
                          break;
  }
}

VOID vDbg_PrintSURFOBJiBitmapFormat(FLONG flFlags, ULONG iBitmapFormat)
{
  switch (iBitmapFormat)
  {
    case BMF_8RLE:    DISPDBG((flFlags, " BMF_8RLE" )); break;
    case BMF_4RLE:    DISPDBG((flFlags, " BMF_4RLE" )); break;
    case BMF_32BPP:   DISPDBG((flFlags, " BMF_32BPP")); break;
    case BMF_24BPP:   DISPDBG((flFlags, " BMF_24BPP")); break;
    case BMF_16BPP:   DISPDBG((flFlags, " BMF_16BPP")); break;
    case BMF_8BPP:    DISPDBG((flFlags, " BMF_8BPP" )); break;
    case BMF_4BPP:    DISPDBG((flFlags, " BMF_4BPP" )); break;
    case BMF_1BPP:    DISPDBG((flFlags, " BMF_1BPP" )); break;
    default:          DISPDBG((flFlags, " BMF_?:0x%x",iBitmapFormat));break;
  }
}

VOID vDbg_PrintSURFOBJ(FLONG flFlags, PCHAR pcString, const SURFOBJ *pso)
{
  //char pjPlatz[100];

  if (pso)
  {
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED,"%s: 0x%p ", pcString, pso));   
    vDbg_PrintSURFOBJiType(flFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED, pso->iType);
    DISPDBG((flFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED," "));
    vDbg_PrintSURFOBJiBitmapFormat(flFlags|DBG_LVL_NOPREFIX, pso->iBitmapFormat);

    DISPDBG((flFlags,"%s: dhsurf:0x%p, hsurf:0x%p, phpdev:0x%p, hdev:0x%p", pcString,
             pso->dhsurf, pso->hsurf, pso->dhpdev, pso->hdev)); 

    DISPDBG((flFlags,"%s: sizlBitmap: cx:%d, cy:%d, cjBits:0x%x, pvBits:0x%p", pcString,
          pso->sizlBitmap.cx,pso->sizlBitmap.cy, pso->cjBits,pso->pvBits));

    DISPDBG((flFlags,"%s: pvScan0:0x%p, lDelta:0x%x, iUniq:0x%x, fjBmp:%08x", pcString,
          pso->pvScan0,pso->lDelta, pso->iUniq, pso->fjBitmap));    
  }
  else
  {
    DISPDBG((flFlags,"%s: NULL", pcString));   
  }
}

/*
** DBG_TRACE_DUMP
** 
** prints the trace dump of all known functions on the stack
** 
** FNicklis 02.10.1998: New
*/

VOID vDbg_PrintTRACE_DUMP(FLONG flDbgLvl)
{
#if 0 // FNicklisch 14.09.00: unused
  DISPDBG((flDbgLvl,"DBG_TRACE_DUMP printing call stack"));
  if (lDbgUnhandledFnStack>0)
  {
    DISPDBG((flDbgLvl,"  %3d-%d (%d) calls not catched",lDbgUnhandledFnStack+lDbgFnStack,lDbgFnStack,lDbgUnhandledFnStack));
  }
  else
  {
    LONG l;
    for (l=lDbgFnStack-1; l>=0; l--)
      DISPDBG((flDbgLvl,"  %3d: %s at 0x%p",l,aDbgFnStack[l].szName,aDbgFnStack[l].pfn));
  }
#endif // FNicklisch 14.09.00: unused
}

char *szDbg_TRACE_GetCurrentFn(VOID)
{
#if 0 // FNicklisch 14.09.00: unused
  static LONG lCount=0;
  if ( (lDbgFnStack<1) || (lDbgUnhandledFnStack>0) )
    return ("unknown");

  if (   (lCount<20)
      && (NULL==aDbgFnStack[lDbgFnStack-1].szName) )
  {
    DISPDBG((DBG_LVL_ERROR, "ERROR in szDbg_TRACE_GetCurrentFn: corrupt function stack..."));
    vDbg_PrintTRACE_DUMP(DBG_LVL_ERROR);
    lCount++;
  }

  return (aDbgFnStack[lDbgFnStack-1].szName);
#else
  return ("unknown");
#endif // FNicklisch 14.09.00: unused
}


/*
** define an array with all RegEscapeIDs
*/
DBG_NAMEINDEX aDbgExceptionCode[] =
{
  DBG_MAKE_NAMEINDEX(STATUS_WAIT_0                  ),
  DBG_MAKE_NAMEINDEX(STATUS_ABANDONED_WAIT_0        ),
  DBG_MAKE_NAMEINDEX(STATUS_USER_APC                ),
  DBG_MAKE_NAMEINDEX(STATUS_TIMEOUT                 ),
  DBG_MAKE_NAMEINDEX(STATUS_PENDING                 ),
  DBG_MAKE_NAMEINDEX(STATUS_SEGMENT_NOTIFICATION    ),
  DBG_MAKE_NAMEINDEX(STATUS_GUARD_PAGE_VIOLATION    ),
  DBG_MAKE_NAMEINDEX(STATUS_DATATYPE_MISALIGNMENT   ),
  DBG_MAKE_NAMEINDEX(STATUS_BREAKPOINT              ),
  DBG_MAKE_NAMEINDEX(STATUS_SINGLE_STEP             ),
  DBG_MAKE_NAMEINDEX(STATUS_ACCESS_VIOLATION        ),
  DBG_MAKE_NAMEINDEX(STATUS_IN_PAGE_ERROR           ),
  DBG_MAKE_NAMEINDEX(STATUS_INVALID_HANDLE          ),
  DBG_MAKE_NAMEINDEX(STATUS_NO_MEMORY               ),
  DBG_MAKE_NAMEINDEX(STATUS_ILLEGAL_INSTRUCTION     ),
  DBG_MAKE_NAMEINDEX(STATUS_NONCONTINUABLE_EXCEPTION),
  DBG_MAKE_NAMEINDEX(STATUS_INVALID_DISPOSITION     ),
  DBG_MAKE_NAMEINDEX(STATUS_ARRAY_BOUNDS_EXCEEDED   ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_DENORMAL_OPERAND  ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_DIVIDE_BY_ZERO    ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_INEXACT_RESULT    ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_INVALID_OPERATION ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_OVERFLOW          ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_STACK_CHECK       ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_UNDERFLOW         ),
  DBG_MAKE_NAMEINDEX(STATUS_INTEGER_DIVIDE_BY_ZERO  ),
  DBG_MAKE_NAMEINDEX(STATUS_INTEGER_OVERFLOW        ),
  DBG_MAKE_NAMEINDEX(STATUS_PRIVILEGED_INSTRUCTION  ),
  DBG_MAKE_NAMEINDEX(STATUS_STACK_OVERFLOW          ),
  DBG_MAKE_NAMEINDEX(STATUS_CONTROL_C_EXIT          ),
};

char *szDbg_GetExceptionCode(DWORD dwID)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgExceptionCode, sizeof(aDbgExceptionCode)/sizeof(aDbgExceptionCode[0]), (LONG)dwID));
}

DBG_NAMEINDEX aDbgET_SET_VALUE_RETdwFlags[] =
{
  DBG_MAKE_NAMEINDEX(ET_VALUE_OK     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_REBOOT ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DEFAULT),
  DBG_MAKE_NAMEINDEX(ET_VALUE_BLOCKED),
  DBG_MAKE_NAMEINDEX(ET_VALUE_ERROR	),
  DBG_MAKE_NAMEINDEX(ET_VALUE_UNKNOWN),
};

// get single string out of aDbgET_SET_VALUE_RETdwFlags matching dwFlags
char *szDbg_GetET_SET_VALUE_RETdwFlags(DWORD dwFlags)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgET_SET_VALUE_RETdwFlags, sizeof(aDbgET_SET_VALUE_RETdwFlags)/sizeof(aDbgET_SET_VALUE_RETdwFlags[0]), dwFlags));
}

// get complete description to dwFlags 
VOID vDbg_PrintET_VALUE_RETdwFlags(
  FLONG flDbgLvl, 
  PCHAR pcString, 
  DWORD dwFlags)
{
  vDbg_PrintflCapabilities(
    flDbgLvl, 
    pcString, 
    szDbg_GetET_SET_VALUE_RETdwFlags,
    dwFlags);
}

DBG_NAMEINDEX aDbgESC_RETURN[] =
{
  DBG_MAKE_NAMEINDEX(ESC_SUCCESS     ),
  DBG_MAKE_NAMEINDEX(ESC_NOTSUPPORTED),
  DBG_MAKE_NAMEINDEX(ESC_ERROR       ),
};

// get single string out of aDbgESC_RETURN matching dwFlags
char *szDbg_GetESC_RETURN(LONG lRet)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgESC_RETURN, sizeof(aDbgESC_RETURN)/sizeof(aDbgESC_RETURN[0]), (ULONG)lRet));
}

DBG_NAMEINDEX aDbgREG_RETURN[] =
{
  DBG_MAKE_NAMEINDEX(REG_ERROR  ),
  DBG_MAKE_NAMEINDEX(REG_OK     ),
  DBG_MAKE_NAMEINDEX(REG_DEFAULT),
};

// get single string out of aDbgREG_RETURN matching dwFlags
char *szDbg_GetREG_RETURN(LONG lRet)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgREG_RETURN, sizeof(aDbgREG_RETURN)/sizeof(aDbgREG_RETURN[0]), (ULONG)lRet));
}


/*
** define an array with all RegEscapeIDs
*/
DBG_NAMEINDEX aDbgET_VALUE_IDs[] =
{
  // Windows 9x
  //
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_MCLK                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_NVCLK                            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ),

  // Windows NT
  //
  // Basic/system 0x20000000-0x200000ff
  //#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
  //#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_P6ENABLEUSWC                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_REVERSESCREENORDER                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_USEGETACCESSRANGES                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_USELCDPANEL                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VERTICALSCREENORDER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_WAITFORFIFOS                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICEORIGINX                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICEORIGINY                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICESIZEX                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICESIZEY                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALORIGINX                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALORIGINY                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALSIZEX                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALSIZEY                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DELLXXL                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_HWLINES                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOEXTRA_P2            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOEXTRA               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOUSAGE               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DMABUFFERSIZE                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DMAPADDING                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_BOARD_PATTERN                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_AGP_DMA                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_FRAMEBUFFER                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_GLINTMMIO                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_DELTAMMIO                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_LOCALBUFFER                         ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_PPRO_ENABLEWCB                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ALPHA_MIATA                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_BIN_GDI_GAMMARAMP                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_BIN_OEM_MODELIST                           ),

  // ICDInterface.* 0x20000100-0x200001ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DISABLE                    ),
  //DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               ),
  //DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBSIZE                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_USESINGLETX                ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          ),

  // GLintDMA.* 0x20000200-0x2000024f
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_ENABLE                              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 ),
  
  //above...DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_ENABLE                              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_RATE                                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_REQUEST_DEPTH                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_FAST_WRITES                         ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DMAWAITFORPOLL                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_CACHING                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_MSWORKAROUND                        ),
  

  // GLintIRQ.* 0x20000250-0x200002ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTIRQ_ENABLE                         ),

  // OpenGL.* 0x20000300-0x200003ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_UNIXCONFORM                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DOUBLEWRITE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DRAWLINEENDS                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDELTA                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEGXCULL                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DELTANODRAW                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DUALTXPRO                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_STATISTICS                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_BENCHING                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEKATMAI                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PIXELTUBE                        ),

  // OpenGL AGP settings
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AGP_DMA                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AGP_TEXTURES                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ERRORLOG                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DUMPLOG                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MCAD_MODE                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MULTIBOARD                       ),

  
    
  // Heidi/Kinetix.* 0x20000400-0x200004ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFERREGIONS                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_SWAPHINTS                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  ),

  // HardwareInformation.* 0x20000500-0x200005ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_BOARDNAME                               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_DESCRIPTION                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_SERNUM                                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          ),

  // DDraw ids    0x20000600-0x200006ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWENABLEVIDEOIO                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                ),

  // LCD Panel    0x20000700-0x200007ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELPANSTARTXRES                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTRETCHXRES                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSINGLEMODE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLECRT                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLELCD                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLETV                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED9),
  
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED9),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ERAZOR_II ),

  
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_CORE_CLOCK        ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MEMORY_CLOCK      ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MEMORY_TIMING     ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_STANDARDTIMINGS),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SCRAMBLEMODE   ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SCRAMBLESETTINGS),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO    ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY),
                                                                
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HELPERFLAGS           ),

// Keys used by the multiboard wrapper to store WINman2 modes (Binary)
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET9),

// Keys used by the single board driver to store WINman2 modes (Binary)
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET9),

// tetris tiling configuration
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_TILING),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_MODE  ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_SHIFT ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM       ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_FORCESOFTWARE           ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGFLAGSOVERRIDE        ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGMAXLOCALERRORCOUNT   ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGTRACETOFILE          ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_USE_DISPLAYDRIVER_BUFFER),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_FORCE_TIMING                ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_ACQUIREMUTEXFORKICKOFF  ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS         ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_CLIENTRELATIVECLIPRECTS ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_USE_ELSA_INITCODE           ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SHUTDOWN                    ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK         ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP              ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_SZ_OEM_VERSION                    ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS                  ),
                                                                         
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_ONDMACRASH                  ),
};


char *szDbg_GetET_VALUE_IDName(DWORD dwID)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgET_VALUE_IDs, sizeof(aDbgET_VALUE_IDs)/sizeof(aDbgET_VALUE_IDs[0]), (LONG)dwID));
}


#define FL_CAPS_TOGGLE_STEP 3 // needed by vDbg_Printfl2DCapabilities and vDbg_Printfl3DCapabilities
                              // print as much cap strings in one line

/*
** vDbg_PrintflCapabilities
**
** prints line with all set capabilities
**
*/
VOID vDbg_PrintflCapabilities(
  FLONG flDbgFlags, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function (szDbg_GetFL_2DCAPSName)
  FLONG flPrint)
{
  if (0==flPrint)
    DISPDBG((flDbgFlags, "%s: 0 (nothing set)", pcString));
  else
  {
    ULONG ul;
    LONG lToggle = 0;

    DISPDBG((flDbgFlags, "%s: 0x%x", pcString,flPrint));
    for (ul=0; ul<32; ul++)
    {
      if ( bBitsTest(flPrint,1<<ul) )
      {
        if (0==(lToggle % FL_CAPS_TOGGLE_STEP)) // only two in one line
        {
          if (lToggle)
            DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX, " ")); // linefeed
          DISPDBG((flDbgFlags|DBG_LVL_NOLINEFEED, "%s: %s ", pcString, szFlCaps(1<<ul)));
        }
        else
        {
          DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED, "%s", szFlCaps(1<<ul)));
        }
        lToggle++;
      }
    }

    DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX, " ")); // linefeed
  }
}


VOID vDbg_PrintET_VERSION(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const ET_VERSION *pVersion)
{
  if (NULL==pVersion)
    DISPDBG((flDbgFlags, "%s: NULL (ET_VERSION *)", pcString));
  else
  {
    DISPDBG((flDbgFlags, "%s: 0x%p (ET_VERSION *)", pcString, pVersion));
    DISPDBG((flDbgFlags, "%s dwFlags         : 0x%x", pcString, pVersion->dwFlags ));
    DISPDBG((flDbgFlags, "%s dwAlign1        : 0x%x", pcString, pVersion->dwAlign1));
    DISPDBG((flDbgFlags, "%s dwNTMajor       : %d",   pcString, pVersion->dwNTMajor       ));
    DISPDBG((flDbgFlags, "%s dwNTMinor       : %d",   pcString, pVersion->dwNTMinor       ));
    DISPDBG((flDbgFlags, "%s dwNTBuildMajor  : %d",   pcString, pVersion->dwNTBuildMajor  ));
    DISPDBG((flDbgFlags, "%s dwNTBuildMinor  : %d",   pcString, pVersion->dwNTBuildMinor  ));
    DISPDBG((flDbgFlags, "%s dwNTReserved0   : 0x%x", pcString, pVersion->dwNTReserved0   ));
    DISPDBG((flDbgFlags, "%s dwNTReserved1   : 0x%x", pcString, pVersion->dwNTReserved1   ));
    DISPDBG((flDbgFlags, "%s dwNTCapabilities: 0x%x", pcString, pVersion->dwNTCapabilities));
    DISPDBG((flDbgFlags, "%s dwNTVersionStamp: 0x%x", pcString, pVersion->dwNTVersionStamp));
    DISPDBG((flDbgFlags, "%s szVersion       : %s", pcString, pVersion->szVersion));
  }
}


VOID vDbg_PrintET_VERSION_INFO(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const ET_VERSION_INFO *pVersionInfo)
{
  if (NULL==pVersionInfo)
    DISPDBG((flDbgFlags, "%s: NULL (ET_VERSION_INFO *)", pcString));
  else
  {
    char szTemp[100] = {0};
    char *szPtr;
    if (strlen(pcString)<100)
      strcpy(szTemp,pcString);
    szPtr = szTemp+strlen(szTemp);
    DISPDBG((flDbgFlags, "%s: 0x%p (ET_VERSION_INFO *)", pcString, pVersionInfo));
    DISPDBG((flDbgFlags, "%s dwSize: 0x%x", pcString, pVersionInfo->dwSize));
    if (strlen(pcString)+strlen("Version") < 100)
      strcpy(szPtr,"Version");
    else
      strcpy(szTemp,"Version");
    vDbg_PrintET_VERSION(flDbgFlags, szTemp, &pVersionInfo->Version);
    DISPDBG((flDbgFlags, "%s szRegDriverKey:%s", pcString, pVersionInfo->szRegDriverKey));
  }
}

DBG_NAMEINDEX aDbgDrvINDEX[] =
{
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnablePDEV           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCompletePDEV         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisablePDEV          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnableSurface        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisableSurface       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvAssertMode           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvResetPDEV            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCreateDeviceBitmap   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDeleteDeviceBitmap   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvRealizeBrush         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDitherColor          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStrokePath           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFillPath             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStrokeAndFillPath    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvPaint                ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvBitBlt               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCopyBits             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStretchBlt           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPalette           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvTextOut              ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEscape               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDrawEscape           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFont            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontTree        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontData        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPointerShape      ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvMovePointer          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvLineTo               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSendPage             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartPage            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEndDoc               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartDoc             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetGlyphMode         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSynchronize          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSaveScreenBits       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetModes             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFree                 ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDestroyFont          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontCaps        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvLoadFontFile         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvUnloadFontFile       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFontManagement       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryTrueTypeTable   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryTrueTypeOutline ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetTrueTypeFile      ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontFile        ),
  #if (_WIN32_WINNT <= 0x400) // not supported under NT5
  DBG_MAKE_NAMEINDEX(INDEX_UNUSED5                 ),
  #endif
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryAdvanceWidths   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPixelFormat       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDescribePixelFormat  ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSwapBuffers          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartBanding         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvNextBand             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetDirectDrawInfo    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnableDirectDraw     ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisableDirectDraw    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQuerySpoolType       ),
};

char *szDbg_GetDrvINDEX(ULONG ulIndex)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgDrvINDEX, sizeof(aDbgDrvINDEX)/sizeof(aDbgDrvINDEX[0]), ulIndex));
}

/*
** vDbg_PrintET_VALUE_DWORD
** vDbg_PrintET_VALUE_STRING
**
** Print ELSAESC structures.
**
** FNicklis 11.05.1999: New
*/
VOID vDbg_PrintET_VALUE_DWORD(
  FLONG           flDebugFlags, 
  PCHAR           pcString,   
  ET_VALUE_DWORD *petDWord)
{
  ASSERT(NULL!=pcString);
  if (NULL==petDWord)
  {
    DISPDBG((flDebugFlags, "%s = NULL", pcString));
  }
  else
  {
    DISPDBG((flDebugFlags, "%s.dwSize:0x%08x, .dwID:0x%08x, .dwValue:0x%08x (%d), .dwFlags:0x%08x (%s)", pcString, 
      petDWord->dwSize, petDWord->dwID, petDWord->dwValue, petDWord->dwValue, petDWord->dwFlags, szDbg_GetET_SET_VALUE_RETdwFlags(petDWord->dwFlags)));
  }
}
  
VOID vDbg_PrintET_VALUE_STRING(
  FLONG            flDebugFlags, 
  PCHAR            pcString,   
  ET_VALUE_STRING *petString)
{
  ASSERT(NULL!=pcString);
  if (NULL==petString)
  {
    DISPDBG((flDebugFlags, "%s = NULL", pcString));
  }
  else
  {
    DISPDBG((flDebugFlags, "%s.dwSize:0x%08x, .dwID:0x%08x, .szValue:%s, .dwFlags:0x%08x (%s)", pcString, 
      petString->dwSize, petString->dwID, petString->szValue, petString->dwFlags, szDbg_GetET_SET_VALUE_RETdwFlags(petString->dwFlags)));
  }
}

#endif //DBG
#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsdebug.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsdebug.h ===
#ifndef _WKSELSATOOLSDEBUG_H
#define _WKSELSATOOLSDEBUG_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsdebug.h
//
// compatibility code only 
//
// FNicklisch 09/14/2000: New, derived from ELSA debug.h
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS
#if DBG

#define DISPDBGCOND(cond,arg)                 if(cond)DebugPrint arg; else NULL
#define DBG_CURRENTPOSITION DISPDBG((0, "file:%s, line:%d",__FILE__,__LINE__))

#ifdef i386
#define DBG_HW_INDEP_BREAK { __asm {int 3} }
#else
#define DBG_HW_INDEP_BREAK EngDebugBreak()
#endif

#undef RIP
// FN more comfortable RIP
#define RIP(text)                                     \
  {                                                   \
    ENG_TIME_FIELDS localTime;                        \
    EngQueryLocalTime(&localTime);                    \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                        \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#ifdef _WIN64 
  // FNicklis IA-64: Rip that only works on IA64
  #define RIP_IA64(text)                                                           \
    DebugPrint(0, "RIP %s: FNicklis IA-64: Code possibly crashes on IA64",text?text:""); \
    RIP(text)
#else 
  #define RIP_IA64(text)
#endif

#define DBGBREAK()                                    \
  {                                                   \
    ENG_TIME_FIELDS localTime;                        \
    EngQueryLocalTime(&localTime);                    \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                        \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#undef ASSERTDD
// FN more comfortable ASSERTDD
#define ASSERTDD(condition, text)                                  \
  if (FALSE==(condition))                                          \
  {                                                                \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
    DBG_TRACE_DUMP(0);                                             \
    DBGBREAK(); /* No more output (text) needed! */                 \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
  }

#undef ASSERT // remove if defined!
#define ASSERT(condition) ASSERTDD(condition,"")
#define DBG_LVL_SWITCHFLAG      0 // ( BIT(31) ) // DON'T USE THIS, BECAUSE THIS IS THE FLAG TO SWITCH
                                            // BETWEEN FLAGED ANS UNFLAGED DEBUGLEVEL

#define DBG_LVL_0               0 // ( DBG_LVL_SWITCHFLAG | BIT(0)|BIT(1)|BIT(2)|BIT(3)) // bit 0-3 but not break!
#define DBG_LVL_ENTRY           5 // ( DBG_LVL_SWITCHFLAG | BIT(0) ) // for Entry to driver function
#define DBG_LVL_PARAM           7 // ( DBG_LVL_SWITCHFLAG | BIT(1) ) // info for functions parameter
#define DBG_LVL_OPENPARAM       8 // ( DBG_LVL_SWITCHFLAG | BIT(2) ) // db want's it for extended info for functions parameter
#define DBG_LVL_PUNT            4 // ( DBG_LVL_SWITCHFLAG | BIT(3) ) // when punting function to engine

#define DBG_LVL_1               0 // ( DBG_LVL_SWITCHFLAG | BIT(4)|BIT(5)|BIT(6)|BIT(7)) // bit 4-7
#define DBG_LVL_SUBENTRY        6 // ( DBG_LVL_SWITCHFLAG | BIT(4) ) // Output for sub entry/function
#define DBG_LVL_FLOW0           8 // ( DBG_LVL_SWITCHFLAG | BIT(5) ) // 
#define DBG_LVL_FLOW1           9 // ( DBG_LVL_SWITCHFLAG | BIT(6) )
#define DBG_LVL_FLOW2           10// ( DBG_LVL_SWITCHFLAG | BIT(7) )

#define DBG_LVL_2               0 // ( DBG_LVL_SWITCHFLAG | BIT(8)|BIT(9)|BIT(10)|BIT(11)) // bit 8-11
#define DBG_LVL_IA64            7 // ( DBG_LVL_SWITCHFLAG | BIT(8) )  // for output that is not for others interest
#define DBG_LVL_DB              1 // ( DBG_LVL_SWITCHFLAG | BIT(9) )
#define DBG_LVL_FN              1 // ( DBG_LVL_SWITCHFLAG | BIT(10) )
#define DBG_LVL_UNUSED11        10// ( DBG_LVL_SWITCHFLAG | BIT(11) )

#define DBG_LVL_3               0 // ( DBG_LVL_SWITCHFLAG | BIT(12)|BIT(13)|BIT(14)|BIT(15))
#define DBG_LVL_MS              1 // ( DBG_LVL_SWITCHFLAG | BIT(12) )
#define DBG_LVL_UNUSED13        10// ( DBG_LVL_SWITCHFLAG | BIT(13) ) // ***unused
#define DBG_LVL_UNUSED14        10// ( DBG_LVL_SWITCHFLAG | BIT(14) ) // ***unused
#define DBG_LVL_UNUSED15        10// ( DBG_LVL_SWITCHFLAG | BIT(15) ) // ***unused

#define DBG_LVL_4               0 // ( DBG_LVL_SWITCHFLAG | BIT(16)|BIT(17)|BIT(18)|BIT(19))
#define DBG_LVL_WARNING         2 // ( DBG_LVL_SWITCHFLAG | BIT(16) ) // for Warnings that aren't as severe as errors
#define DBG_LVL_ERROR           1 // ( DBG_LVL_SWITCHFLAG | BIT(17) ) // for output that isn't as severe as an failed assertion
#define DBG_LVL_UNUSED18        10// ( DBG_LVL_SWITCHFLAG | BIT(18) ) // ***unused
#define DBG_LVL_UNUSED19        10// ( DBG_LVL_SWITCHFLAG | BIT(19) ) // ***unused

#define DBG_LVL_5               0 // ( DBG_LVL_SWITCHFLAG | BIT(20)|BIT(21)|BIT(22)|BIT(23))
#define DBG_LVL_OUTS            10// ( DBG_LVL_SWITCHFLAG | BIT(20) ) // for data passed to HW
#define DBG_LVL_TEST            1 // ( DBG_LVL_SWITCHFLAG | BIT(21) ) // for temporay output, don't check in code to source safe with TEST set!
#define DBG_LVL_CONTEXT         10 // ( DBG_LVL_SWITCHFLAG | BIT(22) ) // for all output relating to contexts
#define DBG_LVL_UNUSED23        10 // ( DBG_LVL_SWITCHFLAG | BIT(23) ) // ***unused

#define DBG_LVL_6               0 // ( DBG_LVL_SWITCHFLAG | BIT(24)|BIT(25)|BIT(26)|BIT(27))
#define DBG_LVL_SWBC            8 // ( DBG_LVL_SWITCHFLAG | BIT(24) ) // for all output relating to sowftware broadcasting
#define DBG_LVL_RECT            10// ( DBG_LVL_SWITCHFLAG | BIT(25) ) // for all output relating to rectangles
#define DBG_LVL_HEAP            10// ( DBG_LVL_SWITCHFLAG | BIT(26) ) // for all output relating to heap
#define DBG_LVL_SYNC            10// ( DBG_LVL_SWITCHFLAG | BIT(27) ) // for all output relating to chip synchronization

// Signaling flags 
#define DBG_LVL_7               0 // ( BIT(28)|BIT(29)|BIT(30)|BIT(31) )
#define DBG_LVL_ENUMERATE       0 // ( BIT(28) ) // to enumerate lists, arrays etc instead of printing only pointer or one element
#define DBG_LVL_NOPREFIX        0 // ( BIT(29) ) // DebugPrint without prefix
#define DBG_LVL_NOLINEFEED      0 // ( BIT(30) ) // DebugPrint without linefeed
#define DBG_LVL_BIT31           0 // ( BIT(31) ) // DON'T USE THIS, BECAUSE THIS IS THE FLAG TO SWITCH
//                                          // BETWEEN FLAGGED AND UNFLAGGED DEBUGLEVEL

// Shorcuts to enable continuous lines (used by FN only?)
// Example:   DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, functionX);           // continue line
//            DISPDBG((DBG_LVL_SUBENTRY_NPLF, "ppdev: 0x%x", ppdev));  // continued line to be continued again
//            DISPDBG((DBG_LVL_SUBENTRY_NP,   ", index: %d", index));  // continued line finished now
//            DBG_PRINTD(DBG_LVL_FLOW0, index);                        // new line (only to show result)
//          will print 
//            NV0:  functionX { ppdev:0x12345678, index: 4
//            NV0:    index: 4                            
#define DBG_LVL_ENTRY_NLF         ( DBG_LVL_ENTRY    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_ENTRY_NPLF        ( DBG_LVL_ENTRY    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_ENTRY_NP          ( DBG_LVL_ENTRY    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_SUBENTRY_NLF      ( DBG_LVL_SUBENTRY | DBG_LVL_NOLINEFEED )
#define DBG_LVL_SUBENTRY_NPLF     ( DBG_LVL_SUBENTRY | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_SUBENTRY_NP       ( DBG_LVL_SUBENTRY | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW0_NLF         ( DBG_LVL_FLOW0    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW0_NPLF        ( DBG_LVL_FLOW0    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW0_NP          ( DBG_LVL_FLOW0    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW1_NLF         ( DBG_LVL_FLOW1    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW1_NPLF        ( DBG_LVL_FLOW1    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW1_NP          ( DBG_LVL_FLOW1    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW2_NLF         ( DBG_LVL_FLOW2    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW2_NPLF        ( DBG_LVL_FLOW2    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW2_NP          ( DBG_LVL_FLOW2    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_TEST_NLF          ( DBG_LVL_TEST     | DBG_LVL_NOLINEFEED )
#define DBG_LVL_TEST_NPLF         ( DBG_LVL_TEST     | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_TEST_NP           ( DBG_LVL_TEST     | DBG_LVL_NOPREFIX   )

// Shortcuts (lower levels include higher - more important - levels)
#define DBG_LVL_2ERROR         (DBG_LVL_ERROR)
#define DBG_LVL_2WARNING       (DBG_LVL_2ERROR|DBG_LVL_WARNING)
#define DBG_LVL_2TEST          (DBG_LVL_2ERROR|DBG_LVL_TEST)
#define DBG_LVL_2ENTRY         (DBG_LVL_2WARNING|DBG_LVL_ENTRY)
#define DBG_LVL_2SUBENTRY      (DBG_LVL_2ENTRY|DBG_LVL_SUBENTRY)
#define DBG_LVL_2FLOW          (DBG_LVL_2SUBENTRY|DBG_LVL_FLOW0|DBG_LVL_FLOW1)
#define DBG_LVL_2DB            (DBG_LVL_2FLOW|DBG_LVL_DB|DBG_LVL_TEST)
#define DBG_LVL_2FN            (DBG_LVL_2FLOW|DBG_LVL_FN|DBG_LVL_TEST)
#define DBG_LVL_2SK            (DBG_LVL_2FLOW|DBG_LVL_SK|DBG_LVL_TEST)
#define DBG_LVL_2MS            (DBG_LVL_2FLOW|DBG_LVL_MS|DBG_LVL_TEST)
#define DBG_LVL_FULLOUTPUT     (DBG_LVL_0|DBG_LVL_1|DBG_LVL_4|DBG_LVL_5|DBG_LVL_6) // All but break, user depending and anoying output

#define DBG_LVL_FULLFN (DBG_LVL_FULLOUTPUT & ~(DBG_LVL_FLOW2|DBG_LVL_OUTS|DBG_LVL_HEAP))
#define DBG_LVL_FULLDB (DBG_LVL_FULLOUTPUT & ~DBG_LVL_OUTS)

#define DBG_LVL_CHECK(flDbgFlags,flFlag) ((flDbgFlags & ~DBG_LVL_7) & flFlag) // mask out signalling flags




extern VOID DebugGetFlagsAddress(void);
// In this array the global Debugflags are stored
#if 0 // FNicklisch 14.09.00: unused
extern FLONG flDbgFlags[DBG_MAX_GROUPS];
extern FLONG flDbgFlagsReset;
extern LONG  DebugLevel;
extern char szDbgStandardDebugPrefix[70];

// This variable conatines the stored flags local (!) to every module
static ULONG SavedFlags = 0; // **FN** 191196
#endif // FNicklisch 14.09.00: unused

#define DBGFLAGSSET(drventry,dbgflags) //                 { flDbgFlags[(drventry)]=(dbgflags); }
#define DBGFLAGSNEW(dbgflags)          //                 { SavedFlags=flDbgFlags[flDbgFlags[DBG_ACTUAL_FUNCTION]]; DBGFLAGSSET(flDbgFlags[DBG_ACTUAL_FUNCTION],dbgflags); }
#define DBGFLAGSOLD()                  //                 { flDbgFlags[flDbgFlags[DBG_ACTUAL_FUNCTION]]=SavedFlags; }

VOID vDbg_PrintPOINTL(FLONG flFlags, PCHAR pcString, const POINTL *pptl);
VOID vDbg_PrintRECTL(FLONG flFlags, PCHAR pcString, const RECTL *prcl);
VOID vDbg_PrintRECTLArray(FLONG flFlags, PCHAR pcString, const RECTL *prcl, LONG c);
VOID vDbg_PrintSIZEL(FLONG flFlags, PCHAR pcString, const SIZEL *psiz);

VOID vDbg_PrintCLIPOBJ(FLONG flFlags, PCHAR pcString, const CLIPOBJ *pco);
VOID vDbg_PrintCLIPOBJiDComplexity(FLONG flFlags, BYTE iDComplexity);
VOID vDbg_PrintCLIPOBJiFComplexity(FLONG flFlags, BYTE iFComplexity);

VOID vDbg_PrintXLATEOBJ(FLONG flFlags, PCHAR pcString, const XLATEOBJ *pxlo);
VOID vDbg_PrintXLATEOBJiType(FLONG flFlags, USHORT iType);
VOID vDbg_PrintXLATEOBJflXlate(FLONG flFlags, FLONG flXlate);

VOID vDbg_PrintSURFOBJ(FLONG flFlags, PCHAR pcString, const SURFOBJ *pso);
VOID vDbg_PrintSURFOBJiType(FLONG flFlags, USHORT  iType);
VOID vDbg_PrintSURFOBJiBitmapFormat(FLONG flFlags, ULONG iBitmapFormat);
char *szDbg_GetEscapeName(ULONG ulEsc);
char *szDbg_GetETSubEscName(LONG SubEscNr);

char *szDbg_TRACE_GetCurrentFn(VOID);
VOID vDbg_TRACE_IN(FLONG flDbgFlags, char *szFunction, PFN pfn);
VOID vDbg_TRACE_OUT(FLONG flDbgFlags, char *szRetVal, ULONG ulRetVal);
VOID vDbg_PrintTRACE_DUMP(FLONG flDbgLvl);

#define DBG_TRACE_IN(flDbgFlags,function) //vDbg_TRACE_IN((FLONG)flDbgFlags,#function,(PFN)function)
// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_TRACE_OUT(flDbgFlags,retVal)  //vDbg_TRACE_OUT((FLONG)flDbgFlags,#retVal,(ULONG)((ULONG_PTR)(retVal)))
#define DBG_TRACE_DUMP(flDbgLvl) //vDbg_PrintTRACE_DUMP(flDbgLvl)
#define DBG_ERROR(szText)   {static ULONG ulOutCount=0; if(ulOutCount++ <20) DISPDBG((DBG_LVL_ERROR, "ERROR in %s called by %s: %s",szDbg_TRACE_GetCurrentFn(),szGetApplicationName(), szText));}
#define DBG_WARNING(szText) {static ULONG ulOutCount=0; if(ulOutCount++ <20) DISPDBG((DBG_LVL_WARNING, "WARNING in %s called by %s: %s",szDbg_TRACE_GetCurrentFn(),szGetApplicationName(), szText));}
#define DBG_TEST(szText)    DISPDBG((DBG_LVL_TEST, "Testline in %s: %s (remove this output now:%s, line:%d!)",szDbg_TRACE_GetCurrentFn(),szText,__FILE__,__LINE__))
// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_PRINTX(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:0x%x",#variable,(ULONG)((ULONG_PTR)(variable))))
#define DBG_PRINTD(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%d",#variable,variable))
#define DBG_PRINTS(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%s",#variable,variable))
#define DBG_PRINTB(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%s",#variable,variable?"TRUE":"FALSE"))

// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_TESTX(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:0x%x",szDbg_TRACE_GetCurrentFn(),#variable,(ULONG)((ULONG_PTR)(variable))))
#define DBG_TESTD(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%d",szDbg_TRACE_GetCurrentFn(),#variable,variable))
#define DBG_TESTS(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%s",szDbg_TRACE_GetCurrentFn(),#variable,variable))
#define DBG_TESTB(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%s",szDbg_TRACE_GetCurrentFn(),#variable,variable?"TRUE":"FALSE"))

#define FL_DBG_CHECK_PTRONLY      0x00
#define FL_DBG_CHECK_NEXT         0x01
#define FL_DBG_CHECK_PREV         0x02
#define FL_DBG_CHECK_NEXTEMPTY    0x04
#define FL_DBG_CHECK_LIST         0x08
#define FL_DBG_CHECK_MEMORY       0x10

#define FL_DBG_CHECK_LINK         (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV)
#define FL_DBG_CHECK_LINKMEM      (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKS        (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_NEXTEMPTY)
#define FL_DBG_CHECK_LINKSMEM     (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_NEXTEMPTY|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKLIST     (FL_DBG_CHECK_LINK |FL_DBG_CHECK_LIST)
#define FL_DBG_CHECK_LINKLISTMEM  (FL_DBG_CHECK_LINK |FL_DBG_CHECK_LIST|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKSLIST    (FL_DBG_CHECK_LINKS|FL_DBG_CHECK_LIST)
#define FL_DBG_CHECK_LINKSLISTMEM (FL_DBG_CHECK_LINKS|FL_DBG_CHECK_LIST|FL_DBG_CHECK_MEMORY)

#define FL_DBG_CHECK_ALL          (0xFF)

BOOL bDbg_CheckHeapNode(const struct _memory_t *pHeap,const struct _memory_t *pNode, FLONG flCheck);
VOID vDbg_CheckHeapIntegrity(FLONG flDbgLvl, char *szText, const struct _memory_t *pHeap);
VOID vDbg_Print_memory_t(FLONG flDbgLvl, char *szText, const struct _memory_t *pHeap);
char *szDbg_GetET_VALUE_IDName(DWORD dwID);


extern LONG Void;
#define DBGVOID Void

extern BOOL bDbg_CheckHeap;

VOID vDbg_Printfl2DCapabilities(
  FLONG flDbgFlags, 
  PCHAR pcString, 
  const PPDEV ppdev);

VOID vDbg_PrintET_VERSION(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const struct tagET_VERSION *pVersion);

VOID vDbg_PrintET_VERSION_INFO(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const struct tagET_VERSION_INFO *pVersionInfo);

char *szDbg_GetExceptionCode(DWORD dwID);

void vDbg_PrintBitBltParams(ULONG ulFlags,SURFOBJ  *psoTrg,    
                                          SURFOBJ  *psoSrc,
                                          SURFOBJ  *psoMask,
                                          CLIPOBJ  *pco,
                                          XLATEOBJ *pxlo,
                                          RECTL    *prclTrg,
                                          POINTL   *pptlSrc,
                                          POINTL   *pptlMask,
                                          BRUSHOBJ *pbo,
                                          POINTL   *pptlBrush,
                                          ROP4     rop4);
void vDbg_PrintCopyBitsParams(ULONG ulFlags,  
                              SURFOBJ*  psoTrg,
                              SURFOBJ*  psoSrc,
                              CLIPOBJ*  pco,
                              XLATEOBJ* pxlo,
                              RECTL*    prclTrg,
                              POINTL*   pptlSrc);

#define PBB_DBG(arg)      vDbg_PrintBitBltParams    arg
#define PCB_DBG(arg)      vDbg_PrintCopyBitsParams  arg

char *szDbg_GetET_SET_VALUE_RETdwFlags(DWORD dwFlags);
char *szDbg_GetESC_RETURN(LONG lRet);
VOID vDbg_PrintET_VALUE_RETdwFlags(
  FLONG flDbgLvl, 
  PCHAR pcString, 
  DWORD dwFlags);

VOID vDbg_PrintflCaps(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const PPDEV ppdev);

VOID vDbg_PrintBRUSHOBJ(FLONG flDbgFlags,PCHAR pcString,const BRUSHOBJ* pbo);
VOID vDbg_PrintExportedFunctions(FLONG flDbgLvl,PCHAR pcString, const DRVENABLEDATA *pded);
#if MULTI_BOARD
VOID vDbg_PrintFunctionTable(FLONG flDbgLvl, PCHAR pcString, const APFN* papfn);
VOID vDbg_PrintBlitDirectionTable( FLONG flDbgLvl, IN const PPDEV ppdev );
#endif
VOID vDbg_PrintPATHOBJ(
  FLONG    flDebugFlags, 
  PCHAR    pcString,   
  PATHOBJ *ppo);

VOID vDbg_PrintET_QUERY(
  IN       FLONG     flDebugFlags, 
  IN const PCHAR     pcString,   
  IN const struct tagET_QUERY *petQuery);
VOID vDbg_PrintET_WINMAN2_DATA_GET(
  IN       FLONG                flDebugFlags, 
  IN const PCHAR                pcString,   
  IN const struct tagET_WINMAN2_DATA_GET *pWINmanDataGet);
VOID vDbg_PrintET_WINMAN2_DATA_SET(
  IN       FLONG                flDebugFlags, 
  IN const PCHAR                pcString,   
  IN const struct tagET_WINMAN2_DATA_SET *pWINmanDataSet);
VOID vDbg_PrintET_WINMAN2_DATA_BRD_R(
  IN       FLONG                  flDebugFlags, 
  IN const PCHAR                  pcString,   
  IN const struct tagET_WINMAN2_DATA_BRD_R *pWINmanDataBrd);
VOID vDbg_PrintET_WINMAN2_DATA_BRD_RW(
  IN       FLONG                   flDebugFlags, 
  IN const PCHAR                   pcString,   
  IN const struct tagET_WINMAN2_DATA_BRD_RW *pWINmanDataBrdRW);
char *szDbg_GetWINMAN_SETName(ULONG fl);
char *szDbg_GetWINMAN_RESULTName(ULONG fl);
VOID vDbg_PrintflWINMAN_MOD(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  DWORD dwDrvModFlags);
VOID vDbg_PrintVIDEO_MODE_INFORMATION(
  FLONG flDebugFlags, 
  PCHAR pcString,   
  struct _VIDEO_MODE_INFORMATION *pVideoModeInformation);
char *szDbg_GetREG_RETURN(LONG lRet);
VOID vDbg_PrintDEVMODEW(
  FLONG     flDebugFlags, 
  PCHAR     pcString,   
  struct _devicemodeW *pDevMode);
char *szDbg_GetDrvINDEX(ULONG ulIndex);

VOID vDbg_PrintET_VALUE_DWORD(
  FLONG           flDebugFlags, 
  PCHAR           pcString,   
  struct tagET_VALUE_DWORD *petDWord);

VOID vDbg_PrintET_VALUE_STRING(
  FLONG            flDebugFlags, 
  PCHAR            pcString,   
  struct tagET_VALUE_STRING *petString);

VOID vDbg_PrintSURFACE_flType(
  IN       FLONG flDbgLvl, 
  IN const PSTR  pjString, 
  IN       FLONG fl);

VOID vDbg_PrintSURFACE(
  IN       FLONG flDbgLvl, 
  IN const PSTR  pjString, 
  IN const struct _SURFACE *pSurface);

#if 0 // ELSA-FNicklis 25.04.00: unused
VOID vDbgFIFO(PPDEV ppdev, ULONG ulDbgLevel);
#define DBG_FIFO vDbgFIFO
#endif // ELSA-FNicklis 25.04.00: unused

// Not supported yet, disabled for debug and free!
#define vDbg_PrintGDIINFO(flDbgLvl, pgdiinfo)
#define vDbg_PrintDD_HALINFO(flDbgLvl,pcString,phalinfo)
#define vDbg_PrintSPS_FLAGS(flDbgLvl,ulSPS_FLAGS)
#define vDbg_PrintSPS_RETURNS(flDbgLvl,ulSPS_FLAGS)


typedef struct _DBG_NAMEINDEX
{
  ULONG ulIndex;
  char *szName;
} DBG_NAMEINDEX;

#define DBG_MAKE_NAMEINDEX(id) {(ULONG)id, #id}
char *szDbg_GetDBG_NAMEINDEX(IN const struct _DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex);
#define DBG_GETDBG_NAMEINDEX(array, ulIndex) szDbg_GetDBG_NAMEINDEX((array), sizeof(array)/sizeof((array)[0]), ulIndex)
VOID vDbg_PrintflCapabilities(
  FLONG flDbgFlags, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function (szDbg_GetFL_2DCAPSName)
  FLONG flPrint);

#define szBOOL(expression) ( (expression) ? "TRUE" : "FALSE" )

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */

#else
/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */

#define DBGBREAK()
#define EngDebugBreak()
#define DISPDBG(arg)
#define DISPDBGCOND(cond,arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define RIP_IA64(x)
#define ASSERTDD(condition,text)
#define ASSERT(condition)
#define DBG_CURRENTPOSITION 

#define DBGFLAGSSET(drventry,dbgflags)
#define DBGFLAGSNEW(dbgflags)
#define DBGFLAGSOLD()                 

#define pszDbg_GetFLOH(floh)

#define vDbg_PrintPOINTL(flFlags,pcString,pptl)
#define vDbg_PrintRECTL(flFlags,pcString,prcl)
#define vDbg_PrintRECTLArray(flFlags,pcString,prcl,c)
#define vDbg_PrintSIZEL(flFlags,pcString,psiz)

#define vDbg_PrintCLIPOBJ(flFlags,pcString,pco)
#define vDbg_PrintCLIPOBJiDComplexity(flFlags,iDComplexity)
#define vDbg_PrintCLIPOBJiFComplexity(flFlags,iFComplexity)

#define vDbg_PrintXLATEOBJ(flFlags,pcString,pxlo)
#define vDbg_PrintXLATEOBJiType(flFlags,iType)
#define vDbg_PrintXLATEOBJflXlate(flFlags,flXlate)

#define vDbg_PrintSURFOBJ(flFlags,pcString,pso)
#define vDbg_PrintSURFOBJiType(flFlags,iType)
#define vDbg_PrintSURFOBJiBitmapFormat(flFlags,iBitmapFormat)
#define szDbg_GetEscapeName(ulEsc)
#define szDbg_GetETSubEscName(SubEscNr)

#define DBG_TRACE_IN(flDbgFlags,function)
#define DBG_TRACE_OUT(flDbgFlags,retVal)
#define DBG_TRACE_DUMP(ulDbgLvl)
#define DBG_ERROR(szText)
#define DBG_WARNING(szText)
#define DBG_TEST(szText)
#define DBG_PRINTX(flDbgFlags,variable)
#define DBG_PRINTD(flDbgFlags,variable)
#define DBG_PRINTS(flDbgFlags,variable)
#define DBG_PRINTB(flDbgFlags,variable)

#define DBG_TESTX(variable)
#define DBG_TESTD(variable)
#define DBG_TESTS(variable)
#define DBG_TESTB(variable)

#define bDbg_CheckHeapNode(pHeap,pNode,flCheck)
#define vDbg_CheckHeapIntegrity(flDbgLvl, szText, pHeap)
#define vDbg_Print_memory_t(flDbgLvl, szText, pHeap)
#define szDbg_GetET_VALUE_IDName(dwID)

#define vDbg_Printfl2DCapabilities(flDbgLvl,szText,ppdev)
#define vDbg_PrintET_VERSION(flDbgLvl,szText,pVersion)
#define vDbg_PrintET_VERSION_INFO(flDbgLvl,szText,pVersionInfo)
#define szDbg_GetExceptionCode(dwID)
#define PBB_DBG(arg)
#define PCB_DBG(arg)
#define szDbg_GetET_SET_VALUE_RETdwFlags(dwFlags)
#define szDbg_GetESC_RETURN(lRet)
#define vDbg_PrintET_VALUE_RETdwFlags(flDbgLvl,pcString,dwFlags)
#define vDbg_PrintflCaps(flDbgFlags,pcString,ppdev)
#define vDbg_PrintBRUSHOBJ(flDbgFlags,pcString,pbo)
#define vDbg_PrintExportedFunctions(flDbgLvl,pcString,ded)
#define vDbg_PrintFunctionTable(flDbgLvl, pcString, papfn)
#define vDbg_PrintBlitDirectionTable(flDbgLvl, ppdev)
#define vDbg_PrintPATHOBJ(flDebugFlags,pcString,ppo)

#define vDbg_PrintET_QUERY(flDebugFlags,pcString,petQuery)
#define vDbg_PrintET_WINMAN2_DATA_GET(flDebugFlags,pcString,pWINmanDataGet)
#define vDbg_PrintET_WINMAN2_DATA_SET(flDebugFlags,pcString,pWINmanDataSet)
#define vDbg_PrintET_WINMAN2_DATA_BRD_R(flDebugFlags,pcString,pWINmanDataBrd)
#define vDbg_PrintET_WINMAN2_DATA_BRD_RW(flDebugFlags,pcString,pWINmanDataBrdRW)
#define szDbg_GetWINMAN_SETName(fl)
#define szDbg_GetWINMAN_RESULTName(fl)
#define vDbg_PrintflWINMAN_MOD(flDbgFlags,pcString,dwDrvModFlags)
#define vDbg_PrintVIDEO_MODE_INFORMATION(flDebugFlags,pcString,pVideoModeInformation)
#define szDbg_GetREG_RETURN(lRet)
#define vDbg_PrintDEVMODEW(flDebugFlags,pcString,pDevMode)
#define szDbg_GetDrvINDEX(ulIndex)
#define vDbg_PrintET_VALUE_DWORD(flDebugFlags,pcString,petDWord)
#define vDbg_PrintET_VALUE_STRING(flDebugFlags,pcString,petString)

#define vDbg_PrintSURFACE_flType(flDbgLvl, pjString, fl)
#define vDbg_PrintSURFACE(flDbgLvl, pjString, pSurface)


// Not supported yet, disabled for debug and free!
#define vDbg_PrintGDIINFO(flDbgLvl, pgdiinfo)
#define vDbg_PrintDD_HALINFO(flDbgLvl,pcString,phalinfo)
#define vDbg_PrintSPS_FLAGS(flDbgLvl,ulSPS_FLAGS)
#define vDbg_PrintSPS_RETURNS(flDbgLvl,ulSPS_FLAGS)
#define DBG_FIFO(ppdev, ulDbgLevel) 

#define vDbg_PrintFL_PUNT_Flags(flDbgLvl, pjString, flFlags)
#define bDbg_VerifySURFOBJ(pso)

#endif // DBG

#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\vpe_nt.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vpe_nt.c                                                          *
* Copyright Microsoft, 1996. All rights reserved.
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           6/29/98                                          *
*                                                                           *
\***************************************************************************/


/* #includes ---------------------------------------------*/



#include "precomp.h"
#include "nvos.h"
#include "nvapi.h"
#include "nvsubch.h"
#include "vpe_nt.h"
#include "surfaces.h"

//#if DX5

DWORD WINAPI GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpInput);
DWORD WINAPI SyncSurfaceData32(LPDDHAL_SYNCSURFACEDATA lpInput);
DWORD WINAPI SyncVideoPortData32(LPDDHAL_SYNCVIDEOPORTDATA lpInput);
DWORD WINAPI ColorControl32(LPDDHAL_COLORCONTROLDATA lpInput);



/*
** Callback tables exported through the GetDriverInfo32 interface
*/
const DDHAL_DDKERNELCALLBACKS KernelCallbacks =
{
    sizeof(DDHAL_DDKERNELCALLBACKS),
    0,
    NULL,
    NULL
};

const GUID *guids[] =
{
    &DDVPTYPE_CCIR656,
};

#define MAX_VP_TYPES    (sizeof(guids)/sizeof(void*))
#define CCIR656     0

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif // mmioFOURCC

const DDPIXELFORMAT InputFormats[] =
{
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1}
};




#define MAX_INPUT_FORMATS (sizeof(InputFormats)/sizeof(DDPIXELFORMAT))
#define INPUTFORMAT_UYVY    0

const DDVIDEOPORTCAPS ddLPBVideoPortCaps =
{
    sizeof(DDVIDEOPORTCAPS),    // size of the DDVIDEOPORTCAPS structure
    DDVPD_WIDTH             |
    DDVPD_HEIGHT            |
    DDVPD_ID                |
    DDVPD_CAPS              |
    DDVPD_FX                |
    DDVPD_AUTOFLIP          |
    DDVPD_ALIGN             |
    0,
    1024,                       // VP max width (limited by FF24)
    1024,                       // max VBI data width (limited by FF24)
    512,                        // VP max height (limited by FF24)
    0,                          // VP ID (0 - (dwMaxVideoPorts-1))
    DDVPCAPS_AUTOFLIP       |   // LPB supports 2 autoflip buffers
    DDVPCAPS_INTERLACED     |
    DDVPCAPS_NONINTERLACED  |
    DDVPCAPS_READBACKFIELD  |
//  DDVPCAPS_READBACKLINE   |   // LPB doesn't support this
//  DDVPCAPS_SHAREABLE      |   // LPB doesn't support this
    DDVPCAPS_SKIPEVENFIELDS |   // when does FF00_5 start dropping ?BJT
    DDVPCAPS_SKIPODDFIELDS  |   // when does FF00_5 start dropping ?BJT
//  DDVPCAPS_SYNCMASTER     |   // LPB doesn't support this
    DDVPCAPS_VBISURFACE     |   // GX2 places VBI data in same surface
//  DDVPCAPS_COLORCONTROL   |   // LPB doesn't support this. SP does.
    0,
//  DDVPFX_CROPTOPDATA      |   // We don't know VBI size without being told
//  DDVPFX_CROPX            |
//  DDVPFX_CROPY            |
    DDVPFX_INTERLEAVE       |
//  DDVPFX_MIRRORLEFTRIGHT  |   // LPB doesn't support this
//  DDVPFX_MIRRORUPDOWN     |   // LPB doesn't support this
//  DDVPFX_PRESHRINKX       |   // LPB can't arbitrarily shrink
//  DDVPFX_PRESHRINKY       |   // LPB can't arbitrarily shrink
//  DDVPFX_PRESHRINKXS      |   // LPB shrinks by byte/pixel dropping
//  DDVPFX_PRESHRINKYS      |   // LPB shrinks by byte/pixel dropping
    DDVPFX_PRESHRINKXB      |   // down to 1/2, 1/4, 1/8 or 1/16
    DDVPFX_PRESHRINKYB      |   // as above
//  DDVPFX_PRESTRETCHX      |   // LPB never stretches
//  DDVPFX_PRESTRETCHY      |   // LPB never stretches
//  DDVPFX_PRESTRETCHXN     |   // LPB never stretches
//  DDVPFX_PRESTRETCHYN     |   // LPB never stretches
//  DDVPFX_VBICONVERT       |   // LPB doesn't have special VBI conversion
//  DDVPFX_VBINOSCALE       |   // TBD: GX2 has some VBI support
    0,
    5,                          // Number of autoflippable surfaces
    8,                          // Byte restriction of placement within surface
    1,                          // Byte restriction of width after prescaling
    1,                          // Byte restriction of left cropping
    1,                          // Byte restriction of cropping width
    16,                         // shrink in steps of original width
    32,                         // shrink in steps of original height
};

const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks =
{
    sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
    DDHAL_VPORT32_CANCREATEVIDEOPORT |
    DDHAL_VPORT32_CREATEVIDEOPORT |
    DDHAL_VPORT32_FLIP |
    DDHAL_VPORT32_GETBANDWIDTH |
    DDHAL_VPORT32_GETINPUTFORMATS |
    DDHAL_VPORT32_GETOUTPUTFORMATS |
    DDHAL_VPORT32_GETFIELD |
    DDHAL_VPORT32_GETLINE |
    DDHAL_VPORT32_GETCONNECT |
    DDHAL_VPORT32_DESTROY |
    DDHAL_VPORT32_GETFLIPSTATUS |
    DDHAL_VPORT32_UPDATE |
    DDHAL_VPORT32_WAITFORSYNC |
    DDHAL_VPORT32_GETSIGNALSTATUS |
    //DDHAL_VPORT32_COLORCONTROL |
    0,
    &CanCreateVideoPort32,
    &CreateVideoPort32,
    &FlipVideoPort32,
    &GetVideoPortBandwidth32,
    &GetVideoPortInputFormat32,
    &GetVideoPortOutputFormat32,
    (LPVOID)0,
    &GetVideoPortField32,
    &GetVideoPortLine32,
    &GetVideoPortConnectInfo,
    &DestroyVideoPort32,
    &GetVideoPortFlipStatus32,
    &UpdateVideoPort32,
    &WaitForVideoPortSync32,
    &GetVideoSignalStatus32,
    (LPVOID)0
};

const DWORD dwConnectionCaps=	//DDVPCONNECT_DOUBLECLOCK			|
											//DDVPCONNECT_VACT					|
											//DDVPCONNECT_INVERTPOLARITY		|
											/* we discard at least until the V bit goes low, and potentially more depending
											  on the setting of YCROP  as well as the current VBI situation  */
											DDVPCONNECT_DISCARDSVREFDATA	|
											//DDVPCONNECT_HALFLINE				|
											/*  these next are "client" only 
											//DDVPCONNECT_INTERLACED			|
											//DDVPCONNECT_SHAREEVEN			|
											//DDVPCONNECT_SHAREODD				|
											*/
											0;

#if 0

const DWORD dwConnectionCaps=
                          //      DDVPCONNECT_INVERTPOLARITY      |
                                DDVPCONNECT_DISCARDSVREFDATA    |
                                DDVPCONNECT_HALFLINE            |
                                DDVPCONNECT_INTERLACED          |
                                DDVPCONNECT_SHAREEVEN           |
                                DDVPCONNECT_VACT                |
                                DDVPCONNECT_DOUBLECLOCK         |
                                DDVPCONNECT_SHAREODD            |
                                0
                                ;

#endif
#if 0

#ifdef WINNT
    /* fpVidMem is already an offset on NT */
    #define SCREENOFFSET(sData, offset) (offset)
    #define UPDATEOVERLAYFLIPOFFSET(sData) (sData->dwOverlayFlipOffset)

    #define LPS3THKINFO PPDEV
    /* our private instance data */
    #define VP_GETSDATA(x) ((LPS3THKINFO)(x->lpDD->lpGbl->dhpdev))
    #define pLPB (&(sData->LPBData))

//    #define SWORD SHORT

    #define TRACE
    #define INT3
    #define assert(x)
#else
    /* fpVidMem is an actual address on Win95 */
    #define SCREENOFFSET(sData, offset) ((offset) - sData->dwScreenFlatAddr)
    #define UPDATEOVERLAYFLIPOFFSET(sData) (dwUpdateOverlayFlipOffset)

    /* our private instance data */
    #define VP_GETSDATA(x) VERIFYSDATA((LPS3THKINFO)(x->lpDD->lpGbl->dwReserved3))
    #define pLPB (&(sData->LPBData))

    /* debugging support */
    #ifdef DEBUG
    #define TRACE   Msg
    #define DPF		Msg
    #define INT3 _asm int 3
    extern void __cdecl Msg( LPSTR szFormat, ... );
    #define assert(test) ((test) ? (void) 0 : DPF("* FAILURE * assertion %s: %s line %d",#test,__FILE__,__LINE__))
    #else
    #define INT3    (void)0
    #define DPF		1 ? (void)0 : (void)
    #define TRACE   1 ? (void)0 : (void)
    #define assert  1 ? (void)0 : (void)
    #endif
#endif

#endif


extern const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks;
extern vpSurfaces MySurfaces;
vpSurfaces*			pMySurfaces = &MySurfaces;
NvNotification*	nvMyVPNotifiers;
OSSpecificGlobals   OSSpecGlobal;


DWORD VPE_DriverInit(PDEV*  ppdev)
{
    ppdev->hVPEChannel = NULL;
	 ppdev->pMySurfaces = (void*)pMySurfaces;
	 MySurfaces.pDrvDat = (void*) ppdev;
	 MySurfaces.dwVideoPortsAvailable = 1;
    return 0;
}


#ifdef VPE_NT
void	getCurrentNanoTimer(U032* pBigTime, U032* pSmallTime)
{
    // XXX do this for real
    *pBigTime = 0;
	*pSmallTime = 0;
}
#endif

U032	getMilliTime(void) {
	U032	bigTime = 0;
	U032	smallTime = 0;
	
	getCurrentNanoTimer(&bigTime, &smallTime);
	return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);
			
}
	
	

/*
 * CanCreateVideoPort32
 *
 * This function is required
 */

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */		
	/* 	this is only a query to see if VideoPort can handle a certain requirement, 
		no structures are defined here, or even chip query */
	DPF("***CanCreateVideoPort32");

	ASSERT(lpInput!=NULL);
	ASSERT(lpInput->lpDDVideoPortDesc !=NULL);	
	
	// Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!
	
	// Check structure size
	if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
		DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check input connection GUID
	if ( !IsEqualGUID(&(lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), &DDVPTYPE_CCIR656) )	 {
		DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check to see if there are ports available... by looking at IDs
   if (lpInput->lpDDVideoPortDesc->dwVideoPortID >= NV_MAX_VIDEOPORTS) {
		DPF("   ***VideoPort not creatable  --> not enough video ports");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// check to see if there are ports available... by looking at local allocation
	if (MySurfaces.dwVideoPortsAvailable <=0 ) {
		DPF("   ***VideoPort not creatable  --> not enough video ports according to our globals");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_BUFFERLENGTH) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// we don't have any restrictions on Microseconds per field that I know of....
	//    lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField;	// Microseconds per video field
    
	if ( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8 ) {
		DPF("   ***VideoPort not creatable  --> incoming connection width is not 8");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
#ifdef NOCHECKHERE
			// the ones I'm not capable of   ANDed   with the ones Dx is asking for
	if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
		// if we get here this should indicate that Dx is asking for a capability we're incapable of
		DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	
	}
#endif
		
	//  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
	// we can work!		

	lpInput->ddRVal = DD_OK;
	DPF("   ***VideoPort creatable! ***");
	return DDHAL_DRIVER_HANDLED;
}


/*
 * CreateVideoPort32
 *
 * This function is optional
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

	/* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
	   as well, signifying that the createvideoport fn could not be completed
	   
	   DirectDraw MS layer will prevent creating more videoports that is
	   available.

	   */
		     
	DWORD		returnVal;
	// we should only have to get this once on creation
	{
		long i;
		
		nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
		pMySurfaces->numberOfSurfaces =0;
		
		
		for(i=0;i<MAXVPSURFACES;i++) {
			pMySurfaces->Surfaces[i] = NULL;
		}
		pMySurfaces->CurrentBufferSurface[4];				// to associate the HW buffer with an arrary index
		
		if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
			pMySurfaces->bInputInterLaced = TRUE;		
		} else {
			pMySurfaces->bInputInterLaced = FALSE;		
		}
		
		 
		if(pMySurfaces->bInputInterLaced)
			pMySurfaces->CurrentCaptureMode =EVENODD;		// indicates which fields will be capture Even	
		else 
			pMySurfaces->CurrentCaptureMode =PROGRESSIVE;	// we're assuming progressive is ALWAYS even even even
			
		pMySurfaces->CurrentScanMode =SEPERATEBUF;		// seperate or interleaved buffersx
		pMySurfaces->lastField= ODD;							// Always start on odd field   //CODE problem if even only capture.. or 
		pMySurfaces->VBIstart = 0;;
		// general information
		pMySurfaces->bSkipNextField = FALSE;
		pMySurfaces->dwOutHeight = 0;
		pMySurfaces->dwOutWidth = 0;
		pMySurfaces->dwImageStartLine =10;				// ditch a minimum of 10 lines
		pMySurfaces->dwVBIStartLine = 0;
		pMySurfaces->dwVBIHeight = 0;
		pMySurfaces->dwPreHeight = 0;					// height and width before prescaling
		pMySurfaces->dwPreWidth = 0;
		pMySurfaces->dwOriginX = 0;						// orgins to move data within the surface
		pMySurfaces->dwOriginY = 0;
		pMySurfaces->bThreadDead = TRUE;
		pMySurfaces->bThreadRunning = FALSE;
		pMySurfaces->hVPInterruptEvent = NULL;
		pMySurfaces->VpInterruptId = 0;	// the thread ID
		pMySurfaces->hThreadHandle = NULL;
		pMySurfaces->bStopVP = FALSE;							// indicates to the thread that it should NOT reprogram
		pMySurfaces->loopCount = 0;
		pMySurfaces->pBuffer0Mem = (U032) NULL;
		pMySurfaces->pBuffer1Mem = (U032) NULL;
		pMySurfaces->curOverlay = 0;			// this way we should start into 0
		
		// initialize all the callback stuff	
		pMySurfaces->ImageCallbackRoutine = NULL;			
		pMySurfaces->VBICallbackRoutine = NULL;			
		pMySurfaces->myIMGCallbackInfo.intCount = 0;			
		pMySurfaces->myVBICallbackInfo.intCount = 0;	
		pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
		pMySurfaces->myVBICallbackInfo.dwFlags = 0;
		pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
		pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;		
		pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;			
		pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;			
		pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;			
		pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;			
		pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);			
		pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);	
		
	}


	DPF("***CreateVideoPort32");


	DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
	DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
	DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
	DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
	DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
	DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
	DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
	DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
	
	DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
	DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
	DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
	DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);

	
	// We'll assume for now that since CanCreate passed that our parameters are valid at this point
	// we need to setup the entire NV object system at this point

	// theorectically we should not have a channel open... let's check that?


	
	((PDEV*)MySurfaces.pDrvDat)->hVPEChannel = DD_PIO_VPE_CHANNEL_OBJECT_HANDLE;
	if (NvAllocChannelPio(  ((PDEV*)MySurfaces.pDrvDat)->hDriver,
			((PDEV*)MySurfaces.pDrvDat)->hClient,
			((PDEV*)MySurfaces.pDrvDat)->hDevice,
			((PDEV*)MySurfaces.pDrvDat)->hVPEChannel,
			NV03_CHANNEL_PIO,
			0,
			(PVOID)&pMySurfaces->pVPChanPtr,
			0
			) != NVOS04_STATUS_SUCCESS)
	{
	   DISPDBG((1, "NVDD: Cannot get NV PIO channel"));
	   NvFree(((PDEV*)MySurfaces.pDrvDat)->hDriver, ((PDEV*)MySurfaces.pDrvDat)->hClient, 
				NV01_NULL_OBJECT, ((PDEV*)MySurfaces.pDrvDat)->hClient);
	   NvClose(((PDEV*)MySurfaces.pDrvDat)->hDriver);
	   return FALSE;
	}
	
	returnVal = SetupVP ( lpInput);
	

	// For the overlay flip, store away a channel pointer
#ifndef VPE_NT
#ifdef NV4
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	
	pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
	pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
	pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
#else

  //CODE
  
#endif //VPE_NT		
	// don't forget to decrement the number of video ports avail number which is 
	lpInput->ddRVal = DD_OK;
	
	return returnVal;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 */
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


	// Check that both surfaces are in our list
	U032	newSurfaceIndex;
	U032	oldSurfaceIndex;
	
	DPF("***FlipVideoPort32");
	

	oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
	if(oldSurfaceIndex  != SURFACENOTFOUND ) {
		newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
		if(newSurfaceIndex != SURFACENOTFOUND ) {
			//  Now do some stuff... uh.. what?
			
			// Find out which of the buffers what programmed for the old surface
			U032	dwBufferIndex = NOSURFACEPROGRAMED;
			{
				U032 i;
				for(i=0;i<4;i++) {
					if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
						dwBufferIndex = i;
						break;
					}
				}
				if (i == 4 ) {
					DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
					return DDHAL_DRIVER_NOTHANDLED;
				}	
			}
			
			
			//  We could wait here until we know the hardware is done...
			//  instead we'll just check it real quick and print a whiner if it's not done
			//  and then fail
			{
				NvNotification* 	pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
				if(pNotify != NULL) {
					if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
						DPF("   Attempting to flip out a surface which is still in progress");
						return DDHAL_DRIVER_NOTHANDLED;
					}
					// check to see if we've had an error 
					//    there are LOTS of these....
					if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
						DPF("   Attempting to flip out a surface which had an error during capture");
						return DDHAL_DRIVER_NOTHANDLED;
					}
				} else {
					DPF("   Attempting to flip out a surface where the notifier was NULL");
					return DDHAL_DRIVER_NOTHANDLED;
				}
			}
			
			// Ok, program up the switch
			ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);
			
		
		} else {
			DPF("   Unable to find Target Surface during FlipVideoPort32");
			DPF("   There was a note that we could be receiving new surfaces ");
			DPF("                      ( Tobin or MS ?)..... need to add code for this");
			
			return DDHAL_DRIVER_NOTHANDLED;
		}
	
	} else {
		DPF("   Unable to find Current Surface during FlipVideoPort32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
  	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

	DPF("***GetVideoPortBandwidth32");
	/*
	 * Determine how much bandwidth is available for the specified
	 * output format and fill in the information.
	 */
	 
	 // we are lucky in that we basically only support ONE format  YEAH!
	 
	 
	if (lpInput->dwFlags & DDVPB_TYPE) {
		lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay 			
	}
	 
	if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
		// The following four should indicate the MINIMUM stretch values represented as percentages times 10
		//  so if we could not stretch below 75% of the orginal size, the we should put in 750
		// for now I'll leave these "as is" because I need to collect the correct values -CJS
		lpInput->lpBandwidth->dwOverlay 				= 1000;
		lpInput->lpBandwidth->dwColorkey 				= 1000;  // Overlay/video port/colorkey works at 1X
		lpInput->lpBandwidth->dwYInterpolate			= 1000;	 // Overlay/video port works at 1X
		lpInput->lpBandwidth->dwYInterpAndColorkey		= 1000;  // Overlay/video port/interpolation works at 2X
	}
	
	
	if (lpInput->dwFlags & DDVPB_OVERLAY) {
		DPF("   We are NOT an overlay limited device but a destination ");
		DPF("      limited device we should not have been called");
	}
	
	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED; 
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
	DPF("   ***GetVideoPortInputFormat32");
	/*
	* The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
	* is large enough to hold the information
	*/

	DPF("   ***GetVideoPortInputFormat32");

	if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &InputFormats[0],  sizeof (DDPIXELFORMAT));
		}
	}

	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &InputFormats[0],  sizeof (DDPIXELFORMAT));
		}
	}

	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
  	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	DPF("***GetVideoPortOutputFormat32");


	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	// default
	lpInput->dwNumFormats = 1;
	if (lpInput->lpddpfOutputFormats != NULL) {
		memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
	}

	// for the video data
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, InputFormats, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	// for the VBI data
	if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, InputFormats, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnect32
 *
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

	// eventually we should check dwPortId if there are more than one port in operation.
	// however since all the port will likely have the same capabilities maybe it's not an
	// issue
	
	DPF("***GetVideoPortConnectInfo");

	lpInput->dwNumEntries = 1;
	if(lpInput->lpConnect == NULL) {
		// this means that Dx is looking for the number of ways you can connect so that it can
		// allocate a structure for the next time around
		lpInput->ddRVal = DD_OK;
	} else {
		// fill in the one structure that we asked for..	
		memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
		lpInput->lpConnect->dwPortWidth = 8;
		lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;	
	}

	return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{
	
	DPF("***DestroyVideoPort32");
	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
		
	tearDownVP();
	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}




/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
	
	U032	dwIndex;
	
	//DPF("***GetVideoPortFlipStatus32");
	if( MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING ) {
   	lpInput->ddRVal = DD_OK;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// search through all of our known surfaces looking for the one it's curious about
	for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
		if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
			// this means we've found the surface that DX is curious about												
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
				ASSERT(1==0);
				DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
   			lpInput->ddRVal = DD_OK;
				return DDHAL_DRIVER_HANDLED;
			}
			
			if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) {
				lpInput->ddRVal = DDERR_WASSTILLDRAWING;
			} else {
				lpInput->ddRVal = DD_OK;
			}
			// return here... we found the surface
			return DDHAL_DRIVER_HANDLED;
		}
	}
	
	DPF("   ***FlipStatus having trouble  --> Surface does");
	DPF("          not exist in my list of surfaces");
	lpInput->ddRVal = DD_OK;

	return DDHAL_DRIVER_HANDLED;
}



U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus ) {
	U032	rValue = DD_OK;
	VPSTATE	myState = *pVideoPortStatus;
	// figure out which buffers to program up and launch them...
	if(bInterleave) {
		 DPF("   Now Launching surfaces.... INTERLEAVED");
	} else {
		 DPF("   Now Launching surfaces.... NOT INTERLEAVED");
	}
	// zero out the last overlay scaler size so we're sure it gets reprogrammed
	pMySurfaces->lastsrcDeltaY = 0;
	pMySurfaces->bStopVP = FALSE;	
	if( bInterleave ) {
		// both buffers will point to the same surface
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			
			// since this is interleave always start the second buffer with the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
	} else {
	
		// buffers will point to consecutive surfaces
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
		// check for another surface
		if( pMySurfaces->VBIstart > 1 ) {
			if( ProgramBufferWithSurface(1,1,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		} else {
			// fire up the second buffer at the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		}
	}
			
	// Now do VBI
	// start first vbi on first surface
	if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
		if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
				rValue = DDERR_INVALIDPARAMS;
		myState |= VP_VBI_CAPTURING;
	
		// now check to see if we have another surface
		if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		} else {
			// set second buffer to first surface
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		}
	}	
	*pVideoPortStatus = myState;
	
	return rValue;
}


/*
** UpdateVideoPort32
**
** This required function sets up the video port
*/
 
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

	VPERRORS myErrors;
	U032		bAutoflip;
#ifndef NV4
	U032		bDelayNV3;
#endif
	
	DPF("***UpdateVideoPort32");


	
	lpInput->ddRVal = DD_OK;
		
	{		
		/*
		 * Turn off the video port
		 */
//CODE
		DPF("   now Stopping the Video Port");

		StopVP();
	
		MySurfaces.dwVideoPortStatus = VP_NOT_RUNNING;
    
	} 
	
	if (lpInput->dwFlags != DDRAWI_VPORTSTOP) { 
#ifndef NV4
		bDelayNV3 = FALSE;
#endif //NV4
		if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
			DPF("   now Starting Video Port for the first time");

		// This is the first round....
#ifndef NV4
			bDelayNV3 = TRUE;
#endif	//NV4

		} 
		
		DPF("   now updating the video port");

		{
			// print some stuff out about the flags we're lookin at:
			
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP	) {
				DPF("      FLAG DVP_AUTOFLIP            on");	
			} else {
				DPF("      FLAG DVP_AUTOFLIP            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT		) {
				DPF("      FLAG DDVP_CONVERT            on");	
			} else {
				DPF("      FLAG DDVP_CONVERT            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP					) {
				DPF("      FLAG DDVP_CROP               on");	
			} else {
				DPF("      FLAG DDVP_CROP               off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE			) {
				DPF("      FLAG DDVP_INTERLEAVE         on");	
			} else {
				DPF("      FLAG DDVP_INTERLEAVE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT		) {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");	
			} else {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN			) {
				DPF("      FLAG DDVP_MIRRORUPDOWN       on");	
			} else {
				DPF("      FLAG DDVP_MIRRORUPDOWN       off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE				) {
				DPF("      FLAG DDVP_PRESCALE           on");	
			} else {
				DPF("      FLAG DDVP_PRESCALE           off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS		) {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     on");	
			} else {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS			) {
				DPF("      FLAG DDVP_SKIPODDFIELDS      on");	
			} else {
				DPF("      FLAG DDVP_SKIPODDFIELDS      off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER				) {
				DPF("      FLAG DDVP_SYNCMASTER         on");	
			} else {
				DPF("      FLAG DDVP_SYNCMASTER         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT				) {
				DPF("      FLAG DDVP_VBICONVERT         on");	
			} else {
				DPF("      FLAG DDVP_VBICONVERT         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE				) {
				DPF("      FLAG DDVP_VBINOSCALE         on");	
			} else {
				DPF("      FLAG DDVP_VBINOSCALE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE		) {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");	
			} else {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP		) {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     on");	
			} else {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     off");	
			}
			
		
		}
		
		// Decide which capture mode to be in given if we're trying to skip some types of fields
		
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
			pMySurfaces->CurrentCaptureMode = ODDODD;
		} else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
			pMySurfaces->CurrentCaptureMode = EVENEVEN;
		} else {
			if(pMySurfaces->bInputInterLaced)
				pMySurfaces->CurrentCaptureMode = EVENODD;
			else
				pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
			bAutoflip = TRUE;
		} else {
			bAutoflip = FALSE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
			pMySurfaces->CurrentScanMode = INTERLEAVBUF;
		} else {
			pMySurfaces->CurrentScanMode = SEPERATEBUF;
		}
		
		{	
			// Here's where we're going to try to figure out where to put things in the vertical and horz
			// dimensions
			
			// At key thing here are the two different modes which people are using to capture VBI
			// one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
			// the other mode is with a seperate surface
			
			// we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode
		
			// When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
			// video surface, since we know this is where it will be expected.
			
			// additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means 
			// "/*
			//	 * Indicates that any data written to the video port during the VREF
			//	 * period will not be written into the frame buffer. This flag is read only.
			//	 */"
		   //  MS of course not really defining what the VREF period means in their land.
			
				
#define VBIVALIDDATALINE  (0x4)	

			pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE;	// at least we're not starting with zero this first four are always
																			// empty as best as I know
			
			pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;
			
			
			pMySurfaces->dwImageStartLine = pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
			
			// if  	dwImageStartLine < 1  then things don't work to well
			if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;
			
			// this is the only way I know how to do the check for vertical cropping
			if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
				pMySurfaces->dwOutHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;				
				pMySurfaces->dwOutWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;		
				DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);				
				if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
					pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
				}		
			} else {
				pMySurfaces->dwOutHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
				pMySurfaces->dwOutWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
			}
			
			// this is something of a hack I suppose
			pMySurfaces->dwOutHeight = pMySurfaces->dwOutHeight;			
						
			// if we're prescaling then do something
			if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
				pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;				
				pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
			} else {
				pMySurfaces->dwPreHeight = pMySurfaces->dwOutHeight;
				pMySurfaces->dwPreWidth = pMySurfaces->dwOutWidth;
			}
			
			
			pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
			pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
		}
		
		switch (pMySurfaces->CurrentCaptureMode) {
				case EVENODD:
					DPF("   UPDATE:     capture mode EVENODD");	
					break;
				case EVENEVEN:
					DPF("   UPDATE:     capture mode EVENEVEN");							
					break;
				case ODDODD:
					DPF("   UPDATE:     capture mode ODDODD");	
					break;
		}
		switch (pMySurfaces->CurrentScanMode) {
				case SEPERATEBUF:
					DPF("   UPDATE:        scan mode SEPERATEBUF");	
					break;
				case INTERLEAVBUF:
					DPF("   UPDATE:        scan mode INTERLEAVBUF");	
					break;
		}
		
		DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
		DPF("   UPDATE: image out dimens %d,%d",pMySurfaces->dwOutWidth,pMySurfaces->dwOutHeight);
		DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
		DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

		myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
										lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);
		if( myErrors == NOVPERROR ) {
#ifndef NV4
			lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus));
#else
			{
				lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus));
			}
#endif //NV4
#ifndef NV4
						
		} else {
			DPF("   Problem updating the Video Port = %d",myErrors);

			switch (myErrors) {
					case CANTCREATESURFACE:
						lpInput->ddRVal = DDERR_OUTOFMEMORY;
						break;
					case TOOMANYSURFACESERROR:
					case  SURFACENOTFOUND:
					default:
						lpInput->ddRVal = DDERR_INVALIDPARAMS;
						break;
			}
				
			return DDHAL_DRIVER_HANDLED;
	
		
			
#endif //NV4
		}	// NOVPERROR
	}  // DDRAWI_VPORTSTOP

	return DDHAL_DRIVER_HANDLED;
}



/*
 * WaitForVideoPortSync32
 *
 * Wait for the LPB Video VSYNC (note: this is entirely
 * different from the screen refresh VGA VSYNC).
 *
 * TBD: No hard polling loops.  Must use lpInput->dwTimeOut
 */
DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
	DPF("***WaitForVideoPortSync32");
	
	lpInput->ddRVal = DDVPSQ_NOSIGNAL;
	
	// if the port is running then
	if (MySurfaces.dwVideoPortStatus != VP_NOT_RUNNING) {
		if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
			// wait for a vsync start.   timeout in lpInput->dwTimeOut
			U032	bigTime;
			U032	smallTime;
			U032	milliTime;
			U032	recentTime[MAXVPSURFACES];
			U032 	dwIndex;
			U032	searchMAX;
	
		// find out what time it is now
			getCurrentNanoTimer(&bigTime, &smallTime);
			milliTime = getMilliTime();
			
			if( pMySurfaces->VBIstart == 0 ) {
				// we're only running VBI so check ALL the surfaces
				searchMAX = pMySurfaces->numberOfSurfaces;
			} else {
				// there is at least one image surface, so check for that
				searchMAX = pMySurfaces->VBIstart;
			}
			//find the current notifiers for the IMAGE surfaces
			for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
				} else {
					recentTime[dwIndex] = 0;
				}
			}
			while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
				for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
					if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
						if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
							// ok, ONE Of the notifiers moved foward
							lpInput->ddRVal = DD_OK; 	//  We found a sync
						}
					}
				}
			}
			// start a while		
		} else if (lpInput->dwFlags & DDVPWAIT_END ) {
			//  timeout in lpInput->dwTimeOut
			// we could wait for ysync that then see which buffer we're on then wait for the line counter
			// to change  .. YUCK
			DPF("   Sorry, don't handle waiting for the end");
	
			return DDHAL_DRIVER_NOTHANDLED;
		} else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
			//timeout in lpInput->dwTimeOut
				// lpInput ->dwLine
			DPF("   Sorry, can't wait for a particular line");
			return DDHAL_DRIVER_NOTHANDLED;
		};
		
	}// videoport status
	
	return DDHAL_DRIVER_HANDLED;
}


DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {	
	
	U032	dwIndex;
	ASSERT(lpInput != NULL);

	DPF("***GetVideoSignalStatus32");
	if( lpInput == NULL)
	{
		DPF("   Input NULL in GetVideoSignalStatus32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
	// If the video port is not running, then we just don't know...
	if( MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING ) {
		DPF("   could not get the signal status, the video port is not running");
		// we'll return no signal in this case....
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

		return DDHAL_DRIVER_HANDLED;
	}
	
	lpInput->ddRVal = DD_OK;
	// default for now is that the signal is good
	lpInput->dwStatus = DDVPSQ_SIGNALOK;
	// first check the notifiers to see if there has been ANY sync
	//     do this by seeing if the notify times are none zero
	{
		U032	probablyRunning = FALSE;
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					probablyRunning = TRUE;
					break;
				}
			}
		}
		
		// if the timer are zero then wait at least 1/24 of a second and check again.
		if(!probablyRunning) {
			// find current time
			U032	 tempTime;
			tempTime = getMilliTime();
			//now wait for 1/24 of a second
			while(tempTime + (1000/24) > getMilliTime()); 
			// and then check one more time for a possible completion
			for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
						probablyRunning = TRUE;
						break;
					}
				}
			}
			
			// if it's still non zero report no signal
			if(!probablyRunning) {
				lpInput->dwStatus = DDVPSQ_NOSIGNAL;
			}

		}	
	}
	
	// have we already decided that the signal is bad...?
	if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {
		
		// Now the default is that the signal is bad
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		
		// check to see that at least one of of the notifiers is LESS than 1/24 of a second
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					U032 diff;
					// ok, we've got a non-zero surface, let's check to see how recent it is
					U032	BigCurrentTime;
					U032	SmallCurrentTime;
					
					getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
					if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
						// we've got a wrap around situation.  this means that we need to work in weirder math
						diff = (
									((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
									+  (SmallCurrentTime >> 1)
								 ) << 1;
					} else {
						// do a simple subtraction
						diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
					}
					//diff now has the delta between the notify and "now"  
					// if the notifier is LESS than a frame period then we've got a signal
					if(diff < MAXFRAMEPERIOD ) {
						lpInput->dwStatus = DDVPSQ_SIGNALOK;
					}
					
				}
			}
		}

	}
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */

DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
	//DPF("***GetVideoPortField32");
	
	if (MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->bField = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->bField = GetField();
		
		lpInput->ddRVal = DD_OK;

		lpInput->bField = 0;
	}	
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

	DPF("***GetVideoPortLine32");
 
 
	if (MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->dwLine = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->dwLine = getCurLine();
		lpInput->ddRVal = DD_OK;
		
	}	
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 ** SyncVideoPortData32
 *
 *  FILENAME: C:\win9x\display\mini\s3\S3_DD32.C
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#if 0
DWORD WINAPI SyncVideoPortData32(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    LPS3THKINFO sData = VP_GETSDATA(lpInput);

    DPF("SyncVideoPortData");

    lpInput->dwOriginOffset = pLPB->dwBaseOffset;

    /*
    ** !! KMVT Field dropping functionality requires a
    ** place to cache the "real" decimation pattern.  So
    ** we (S3) will reserve dwDriverReserved1 for this
    ** purpose.
    */
    lpInput->dwDriverReserved1 = pLPB->dwVDecimationPattern;

    return DDHAL_DRIVER_HANDLED;
}

#endif

/*
 ** SyncSurfaceData32
 *
 *  FILENAME: C:\win9x\display\mini\s3\S3_DD32.C
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#if 0
DWORD WINAPI SyncSurfaceData32(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    LPS3THKINFO sData = VP_GETSDATA(lpInput);

    lpInput->dwSurfaceOffset
        = SCREENOFFSET(sData, lpInput->lpDDSurface->lpGbl->fpVidMem);
    lpInput->dwOverlayOffset
        = lpInput->dwSurfaceOffset + UPDATEOVERLAYFLIPOFFSET(sData);

    DPF("SyncSurfaceData dwOverlayOffset=%lx", lpInput->dwOverlayOffset);

    return DDHAL_DRIVER_HANDLED;
}

#endif


/*
** IndexFromGUID
**
** Get the index into our supported connection table,
** given a GUID.  returns 0 if it isn't a supported
** connection type
*/
int IndexFromGUID(GUID *pGUID)
{
    int i, index;

    index = -1;                          // assume not found

    for (i=0; i<MAX_VP_TYPES; i++)
    {
        if (memcmp(guids[i], pGUID, sizeof(GUID)) == 0)
        {
            index = i;                  // found a match
            break;
        }
    }

    //TRACE("IndexFromGUID found GUID %d",i);

    return index;
}

//#endif // DX5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsescape.h ===
#ifndef _WKSELSATOOLSESCAPE_H
#define _WKSELSATOOLSESCAPE_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsescape.h
//
// FNicklisch 09/14/2000: New, derived from EscapeTools.h
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS

#define ESC_SUCCESS         1     // function succeded without error
#define ESC_NOTSUPPORTED    0     // function not supported
#define ESC_ERROR         (-1)    // function supported but error while working

LONG lEscapeTools( 
  SURFOBJ *pso,
  ULONG    cjIn,
  VOID    *pvIn,
  ULONG    cjOut,
  VOID    *pvOut);

#endif //USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSESCAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsescape.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsescape.c
//
// Handles ESC_ELSA_TOOLS calls to driver
//
// FNicklisch 09/14/2000: New, derived from EscapeTools.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "nvVer.h"
#include "excpt.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "ELSAESC.h"
#include "wkselsatoolsdebug.h"
#include "wkselsatoolsregistry.h"
#include "wkselsatoolstoolbox.h"

// export header file
#include "wkselsatoolsescape.h"


#define szStrCpy strcpy
#define szStrCat strcat

static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo);

static LONG lQueryOpenGlIcdRegPath(
      PPDEV                 ppdev,
  OUT ET_OPENGLICD_REGPATH *pIcdRegPath);

static LONG lEscET_EDD_GETGAMMARAMP(IN const  PPDEV                 ppdev, 
                                    IN const  ET_QUERY*             pET_Query, 
                                    OUT       PET_EDD_GETGAMMARAMP  pETGetGammaRamp);

static LONG lEscET_EDD_SETGAMMARAMP(IN        PPDEV ppdev, 
                                    IN const  PET_EDD_SETGAMMARAMP  pETSetGammaRamp, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet);

static LONG lEscET_SET_VALUE_BINARY(IN        PPDEV ppdev, 
                                    IN const  PET_SET_VALUE_BINARY  pETSetValueBinary, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet);

static LONG lEscET_DPMS(
  IN     PPDEV             ppdev, 
  IN     ET_DPMS_IN  *pIn, 
     OUT ET_DPMS_OUT *pOut);

static LONG lEscET_QUERY_TEMPERATURE(
  IN    PPDEV                 ppdev, 
  IN    ET_QUERY             *petQuery, 
    OUT ET_QUERY_TEMPERATURE *petTemperature);

/*
** lEscapeTools
**
** handles all escape function calls regarding the ELSA escape interface.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_NOTSUPPORTED: failed, esc not supported, input data ignored, output data invalid
**         ESC_ERROR:        failed, returned data invalid
*/
LONG lEscapeTools( 
  SURFOBJ *pso  ,
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut)
{
  LONG  lRet = ESC_NOTSUPPORTED; // Default error 

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscapeTools);
  
  ASSERTDD(NULL!=pso, "lEscapeTools:");

#ifndef RUN_WITH_NVIDIA_MINIPORT 
  // We need a minimum of ET_QUERY to understand the subescape!
  if ( (NULL == pvIn) || 
       (cjIn < sizeof(ET_QUERY)) )
  {
    DBG_ERROR("cjIn<sizeof(ET_QUERY)");
    lRet = ESC_ERROR;
    goto Exit;
  } 
  else 
  {
    ET_QUERY *pEtQuery;
    PPDEV     ppdev;
    DWORD     dwSubEsc;

    ppdev = (struct _PDEV *)pso->dhpdev;

    ASSERT(NULL!=ppdev);

    pEtQuery = (ET_QUERY *)pvIn;
    dwSubEsc = pEtQuery->dwSubEsc;

    DISPDBG((DBG_LVL_SUBENTRY, "dwSubEsc:0x%x (%s), ulBoard:%d", 
      dwSubEsc, szDbg_GetETSubEscName(dwSubEsc), pEtQuery->dwBoard));

    if ( (NULL!=pvOut) && (cjOut>0) )
    {
      if (cjOut!=pEtQuery->dwOutSize)
      {
        DISPDBG((DBG_LVL_ERROR, "ERROR in %s: %d==cjOut != pEtQuery->dwOutSize==%d",
          szDbg_TRACE_GetCurrentFn(),cjOut,pEtQuery->dwOutSize));
        DISPDBG((DBG_LVL_ERROR, "ERROR in %s: dwSubEsc:0x%x (%s), ulBoard:%d", 
          szDbg_TRACE_GetCurrentFn(),dwSubEsc, szDbg_GetETSubEscName(dwSubEsc), pEtQuery->dwBoard));
        lRet = ESC_ERROR;
        goto Exit;
      }

      // clear output buffer before anyone touches it!
      RtlZeroMemory(pvOut, cjOut);
    }

    switch (dwSubEsc)
    {  
      // VERSION_INFO
      // return version nummbers, registry path and 
      case SUBESC_ET_QUERY_VERSION_INFO:
      {
        if ( (NULL==pvOut) || 
             (sizeof(ET_VERSION_INFO) != cjOut) )
        {
          DISPDBG((DBG_LVL_ERROR, "ERROR in DrvEscape: SUBESC_ET_QUERY_VERSION_INFO cjOut:%d != pEtQuery->dwOutSize:%d != sizeof(ET_VERSION_INFO):%d",cjOut, pEtQuery->dwOutSize, sizeof(ET_VERSION_INFO)));
          break;
        }

        lRet = lQueryEtVersionInfo(ppdev, (ET_VERSION_INFO *)pvOut);
        break; 
      }

      case SUBESC_ET_WINMAN2_DATA_SET:
      case SUBESC_ET_WINMAN2_DATA_GET:
      case SUBESC_ET_WINMAN2_DDC_EDID_GET:
      {
        //lRet = lEscWINman2(ppdev, dwSubEsc, cjIn, pvIn, cjOut, pvOut);
        break;
      }

      // APPSET
      // queries ICDs registry path and information about ICD name
      case SUBESC_ET_QUERY_OPENGLICD_REGPATH:
      {
        if ( (NULL==pvOut) || 
             (sizeof(ET_OPENGLICD_REGPATH) > cjOut) ) 
        {
          DBG_ERROR("SUBESC_ET_QUERY_OPENGLICD_REGPATH cjOut to small");
          break;
        }

        // FNicklisch 14.09.00: lRet = lQueryOpenGlIcdRegPath(ppdev, (ET_OPENGLICD_REGPATH *)pvOut);
        break;
      }

      case SUBESC_ET_QUERY_VALUE_BINARY:  
      case SUBESC_ET_QUERY_VALUE_STRING:  
      case SUBESC_ET_QUERY_VALUE_DWORD:   
      case SUBESC_ET_SET_VALUE_STRING:  
      case SUBESC_ET_SET_VALUE_DWORD:  
      //case SUBESC_ET_SET_VALUE_DEFAULT:
      {
        // FNicklisch 14.09.00: lRet = lEscRegistryValue(ppdev, dwSubEsc, cjIn, pvIn, cjOut, pvOut);
        break;
      }

#if 0 // FNicklisch 14.09.00: unused
      // POWERLIB
      case SUBESC_ET_POWERLIB_START:  
      {
        if( !ppdev )
          break;
        // increase number of started powerlibs
        ppdev->pElsaPDEV->nPowerLibsStarted++;
        // switch on hardwarelines, witch won't pass the WHQL
        lRet = ESC_SUCCESS;
        break;
      }

      case SUBESC_ET_POWERLIB_EXIT:  
      {
        ppdev = pPDEVGetFromPso( pso );
        if( !ppdev )
          break;
        // are there any powerlibs left ?
        if( ppdev->pElsaPDEV->nPowerLibsStarted )
          ppdev->pElsaPDEV->nPowerLibsStarted--;
        // if tere are no powerlibs left, clear flag
        lRet = ESC_SUCCESS;
        break;
      }
#endif // FNicklisch 14.09.00: unused

      case SUBESC_ET_QUERY_ICDCLIENTINFO:
      {
        lRet = ESC_ERROR;
        break;
      }

      case SUBESC_ET_EDD_SETGAMMARAMP:

          if((cjIn  == sizeof(ET_EDD_SETGAMMARAMP)) && 
             (cjIn  == pEtQuery->dwSize)            &&
             (pvOut != NULL)                        &&
             (cjOut == sizeof(ET_SET_VALUE_RET))    &&
             (cjOut == pEtQuery->dwOutSize))
          {
            // FNicklisch 14.09.00: lRet = lEscET_EDD_SETGAMMARAMP(ppdev, (ET_EDD_SETGAMMARAMP*)pvIn, (ET_SET_VALUE_RET*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;
      
      case SUBESC_ET_EDD_GETGAMMARAMP:

          if((cjIn  == sizeof(ET_QUERY))            &&
             (cjIn  == pEtQuery->dwSize)            &&
             (pvOut != NULL)                        &&
             (cjOut == sizeof(ET_EDD_GETGAMMARAMP)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_EDD_GETGAMMARAMP(ppdev, (ET_QUERY*)pvIn, (ET_EDD_GETGAMMARAMP*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;
      
      case SUBESC_ET_SET_VALUE_BINARY:
          if((cjIn  >= sizeof(ET_SET_VALUE_BINARY_HDR_SIZE))  &&
             (cjIn  == pEtQuery->dwSize)                      &&
             (pvOut != NULL)                                  &&
             (cjOut == sizeof(ET_SET_VALUE_RET))              &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            lRet = lEscET_SET_VALUE_BINARY(ppdev, (ET_SET_VALUE_BINARY*)pvIn, (ET_SET_VALUE_RET*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      case SUBESC_ET_DPMS:
          if((cjIn  == sizeof(ET_DPMS_IN))  &&
             (cjIn  == pEtQuery->dwSize)         &&
             (pvOut != NULL)                     &&
             (cjOut == sizeof(ET_DPMS_OUT)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_DPMS(ppdev, (ET_DPMS_IN*)pvIn, (ET_DPMS_OUT*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      case SUBESC_ET_QUERY_TEMPERATURE:
          if((cjIn  == sizeof(ET_QUERY))  &&
             (cjIn  == pEtQuery->dwSize)         &&
             (pvOut != NULL)                     &&
             (cjOut == sizeof(ET_QUERY_TEMPERATURE)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_QUERY_TEMPERATURE(ppdev, (ET_QUERY*)pvIn, (ET_QUERY_TEMPERATURE*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      default:
      {
        DISPDBG((DBG_LVL_WARNING, "WARNING in ulEscapeTools: Unsuported sub escape: %s, 0x%x",szDbg_GetETSubEscName(dwSubEsc),dwSubEsc));
        lRet=ESC_NOTSUPPORTED; // Not supported
        break;
      }
    } // .. switch
  } // .. if cjIn else ..
Exit:
#endif
  if (ESC_ERROR==lRet) 
  {
    EngSetLastError(ERROR_INVALID_PARAMETER); 
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}

#ifndef RUN_WITH_NVIDIA_MINIPORT 

//*******************************************************************************************
/*
** lQueryEtVersionInfo
**
** is a tools escape function, that returns the drivers
** registry path, version number and capability flags.
**
** return: ESC_ERROR:   failed, returned data invalid
**         ESC_SUCCESS: ok, returned data valid
*/
#if 1
// local information
#pragma message ("  FNicklis: use the other lQueryEtVersionInfo if finally tested!")
static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo)
{
  LONG              lRet  = ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY,lQueryEtVersionInfo);

  ASSERTDD(NULL!=ppdev,        "");
  ASSERTDD(NULL!=pVersionInfo, "");

  pVersionInfo->dwSize = sizeof(ET_VERSION_INFO);

  szStrCpy( pVersionInfo->szRegDriverKey,    "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\nv4" );
  szStrCpy( pVersionInfo->Version.szVersion, NV_VERSION_MS_STRING_NT4);

  pVersionInfo->Version.dwFlags           = 0;
  #if defined (BETA_VERSION)
  pVersionInfo->Version.dwFlags          |= ET_VER_BETA_DRIVER; 
  #endif
  pVersionInfo->Version.dwNTMajor         = 4;
  pVersionInfo->Version.dwNTMinor         = 0;
  pVersionInfo->Version.dwNTBuildMajor    = 1381;
  pVersionInfo->Version.dwNTBuildMinor    = NV_DRIVER_VERSION_NUMBER;

  // validate capabilities
  pVersionInfo->Version.dwNTVersionStamp  = ET_VERSION_STAMP10;
  // FNicklisch 14.09.00: if ( b2DCapsTest(FL_2DCAPS_CV_BOARD) )
  {
    pVersionInfo->Version.dwNTCapabilities |= ET_VERSION_CAPS_CV_PRODUCT;
  }

  // We always have 3D boards in CV!
  // pVersionInfo->Version.dwNTCapabilities |= ET_VERSION_CAPS_2D_BOARD_ONLY;

  // FNicklisch 14.09.00: vDbg_PrintET_VERSION_INFO(DBG_LVL_FLOW1, "pVersionInfo", pVersionInfo);

  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}

#else
// FNicklis informationvia IOCTL
static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo)
{
  LONG  lRet    = ESC_ERROR;
  LONG  lResult = 0;
  DWORD dwReturnedDataLength;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY,lQueryEtVersionInfo);

  ASSERTDD(NULL!=ppdev,        "");
  ASSERTDD(NULL!=pVersionInfo, "");

  lResult = (LONG)EngDeviceIoControl( ppdev->hDriver,
                                      IOCTL_VIDEO_GET_ET_VERSION_INFO,
                                      NULL,0,
                                      (VOID*)pVersionInfo,sizeof(ET_VERSION_INFO),
                                      &dwReturnedDataLength);

  if (NO_ERROR==lResult)
  {  
    ASSERT(pVersionInfo->dwSize==sizeof(ET_VERSION_INFO));
    ASSERT(pVersionInfo->dwSize==dwReturnedDataLength);

    lRet = ESC_SUCCESS;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}
#endif

//*******************************************************************************************
static LONG lQueryOpenGlIcdRegPath(
      PPDEV                 ppdev,
  OUT ET_OPENGLICD_REGPATH *pIcdRegPath)
{
  LONG                   lRet   = ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lQueryOpenGlIcdRegPath);

  ASSERTDD(NULL!=ppdev,       "");
  ASSERTDD(NULL!=pIcdRegPath, "");

  pIcdRegPath->dwSize = sizeof(ET_OPENGLICD_REGPATH);

  szStrCpy(pIcdRegPath->szRegICDKey,  "\\REGISTRY\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers\\\0");
  szStrCat(pIcdRegPath->szRegICDKey, "RIVATNT");

  // Default String build by environment
  szStrCpy(pIcdRegPath->szRegICDName, "nvoglnt");

  DBG_PRINTS(DBG_LVL_FLOW1, pIcdRegPath->szRegICDKey);
  DBG_PRINTS(DBG_LVL_FLOW1, pIcdRegPath->szRegICDName);

  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}



#define GAMMA_TABLE_ENTRIES (256 * 3)

// CSchalle 8/25/99 2:21:09 PM: new
static LONG lEscET_EDD_GETGAMMARAMP(IN const  PPDEV                 ppdev, 
                                    IN const  ET_QUERY*             pET_Query, 
                                    OUT       PET_EDD_GETGAMMARAMP  pETGetGammaRamp)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_EDD_GETGAMMARAMP);

  ASSERT(ppdev            != NULL);
  ASSERT(pET_Query        != NULL);
  ASSERT(pETGetGammaRamp  != NULL);

  if(nvGetGammaRamp(ppdev, &pETGetGammaRamp->red[0]) == 256)
  {
    pETGetGammaRamp->dwResult = ET_VALUE_OK;
    pETGetGammaRamp->dwSize   = sizeof(ET_EDD_GETGAMMARAMP);
    lRet                      = ESC_SUCCESS;
  }
  else
  {
    pETGetGammaRamp->dwResult = ET_VALUE_BLOCKED;
    pETGetGammaRamp->dwSize   = 0;
    lRet                      = ESC_ERROR;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return lRet;
}


// CSchalle 8/25/99 2:08:44 PM: new
static LONG lEscET_EDD_SETGAMMARAMP(IN        PPDEV ppdev, 
                                    IN const  PET_EDD_SETGAMMARAMP  pETSetGammaRamp, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_EDD_SETGAMMARAMP);

  ASSERT(ppdev           != NULL);
  ASSERT(pETSetGammaRamp != NULL);
  ASSERT(pETSetValueRet  != NULL);

  // prepare output structure
  RtlZeroMemory(pETSetValueRet, sizeof(ET_SET_VALUE_RET));
  pETSetValueRet->dwSize  = sizeof(ET_SET_VALUE_RET);

  if(nvSetGammaRamp(ppdev, &pETSetGammaRamp->red[0]) == 256)
  {
    pETSetValueRet->dwFlags = ET_VALUE_OK;
    lRet                    = ESC_SUCCESS;
  }
  else
  {
    pETSetValueRet->dwFlags = ET_VALUE_BLOCKED;
    lRet                    = ESC_ERROR;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return lRet;
}

// CSchalle 8/26/99 3:17:22 PM:new
// FNicklis 05.10.1999: Allow all IDs and not only ET_VALUE_BIN_GDI_GAMMARAMP
static LONG lEscET_SET_VALUE_BINARY(IN        PPDEV ppdev, 
                                    IN const  PET_SET_VALUE_BINARY  pETSetValueBinary, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet)
{
  LONG  lRet = ESC_ERROR;
  LONG  lSize;

  ASSERT(ppdev              != NULL);
  ASSERT(pETSetValueBinary  != NULL);
  ASSERT(pETSetValueRet     != NULL);

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_SET_VALUE_BINARY);

  // prepare output structure
  pETSetValueRet->dwID    = pETSetValueBinary->dwID;
  pETSetValueRet->dwSize  = sizeof(ET_SET_VALUE_RET);
  pETSetValueRet->dwFlags = ET_VALUE_UNKNOWN;

  // calculate amount of data behind dwData
  lSize = pETSetValueBinary->hdr.dwSize - ET_SET_VALUE_BINARY_HDR_SIZE;

  switch(pETSetValueBinary->dwID)
  {
    case ET_VALUE_BIN_GDI_GAMMARAMP:
    {

      __try // never trust...
      {
        ASSERT(lSize == GAMMA_TABLE_ENTRIES * sizeof(USHORT));

        // refuse to store partial table, or in palettized modes!
        if(lSize                == GAMMA_TABLE_ENTRIES * sizeof(USHORT) && 
           ppdev->iBitmapFormat >  BMF_8BPP)
        {
          if(REG_OK == lRegSetIdBinary(ppdev->hDriver, 
                                       ET_VALUE_BIN_GDI_GAMMARAMP, 
                                       (const BYTE *)pETSetValueBinary->ajData, 
                                       lSize))
          {
            DISPDBG((DBG_LVL_ERROR, "storing gamma table to registry..."));

            pETSetValueRet->dwFlags = ET_VALUE_OK;
      
            lRet                    = ESC_SUCCESS;
          }
        }
        else
        {
          DISPDBG((DBG_LVL_ERROR, "refusing to store gamma table of size %d at BMF %d", lSize, ppdev->iBitmapFormat));
        }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
        DISPDBG((DBG_LVL_ERROR, "ERROR in lEscET_SET_VALUE_BINARY: Exception failed with: %s",szDbg_GetExceptionCode(GetExceptionCode())));
      }
      break;
    }

    default: 
    {
      // write lSize Bytes to registry key with dwID
      if(REG_OK == lRegSetIdBinary(ppdev->hDriver, 
                                   pETSetValueBinary->dwID, 
                                   (const BYTE *)pETSetValueBinary->ajData, 
                                   lSize))
      {
        // succeeded 
        pETSetValueRet->dwFlags = ET_VALUE_OK;      
        lRet                    = ESC_SUCCESS;
      }
      break;
    }
  }
  
  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}


/*
** lEscET_DPMS
**
** handles ET_DPMS ELSA escape.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_ERROR:        failed, returned data invalid
**
** FNicklis 28.09.1999: New
** FNicklis 06.10.1999: Use IOCTL to Miniport
*/
static LONG lEscET_DPMS(
  IN     PPDEV        ppdev, 
  IN     ET_DPMS_IN  *pIn, 
     OUT ET_DPMS_OUT *pOut)
{
  LONG  lRet    = ESC_ERROR;
  LONG  lResult = 0;
  DWORD dwReturnedDataLength;


  DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, lEscET_DPMS);
  DISPDBG((DBG_LVL_SUBENTRY_NPLF, " pIn:0x%x, pOut:0x%x",pIn,pOut));

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=pIn);

#if 0 // FNicklisch 14.09.00: not supported yet
    lResult = (LONG)EngDeviceIoControl( ppdev->hDriver,
                                      IOCTL_VIDEO_ET_DPMS,
                                      (VOID*)pIn, sizeof(ET_DPMS_IN),
                                      (VOID*)pOut,sizeof(ET_DPMS_OUT),
                                      &dwReturnedDataLength);

  if (NO_ERROR==lResult)
  {  
    ASSERT(pOut->dwSize==sizeof(ET_DPMS_OUT));
    ASSERT(pOut->dwSize==dwReturnedDataLength);

    // remember set mode!
    ppdev->pElsaPDEV->lDPMSMode = pOut->lMode;

    lRet = ESC_SUCCESS;
  }

#endif // FNicklisch 14.09.00: not supported yet

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}

/*
** lEscET_QUERY_TEMPERATURE
**
** handles ET_QUERY_TEMPERATUR ELSA escape.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_ERROR:        failed, returned data invalid
**
** FNicklis 30.09.1999: New
*/
static LONG lEscET_QUERY_TEMPERATURE(
  IN    PPDEV                 ppdev, 
  IN    ET_QUERY             *petQuery, 
    OUT ET_QUERY_TEMPERATURE *petTemperature)
{
  LONG lRet=ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, lEscET_QUERY_TEMPERATURE);
#if 0 // ELSA-FNicklis 04.07.00: unused
    DISPDBG((DBG_LVL_SUBENTRY_NPLF, " petQuery:0x%x, petTemperature:0x%x",petQuery,petTemperature));

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=petQuery);
  ASSERT(NULL!=petTemperature);

  petTemperature->dwSize              = sizeof(ET_QUERY_TEMPERATURE);

  // set capabilities of driver e.g. ET_TEMPERATURE_FANSLOW | ET_TEMPERATURE_OVERTEMP
  petTemperature->dwTemperatureCaps   = 0;                          

  // set error status: e.g. ET_TEMPERATURE_FANSLOW if fan irq occured
  // get this from miniport, where irq handler receives fan irqs
  petTemperature->dwTemperatureStatus = (DWORD) flGetTemperatureStatus(ppdev->pElsaPDEV->pHDE); 

  // unused for now
  petTemperature->dwTemperatureValue  = 0;                          

  lRet=ESC_SUCCESS;
#endif // ELSA-FNicklis 04.07.00: unused

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return (lRet);
}
        
#endif //RUN_WITH_NVIDIA_MINIPORT 
#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsescape.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsregistry.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsregistry.c
//
// FNicklisch 09/14/2000: New, derived from registry.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files

#include "precomp.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "wkselsatoolsdebug.h"
#include "wkselsatoolsescape.h"
#include "wkselsatoolstoolbox.h"
#include "ELSAESC.h"

// export header file
#include <wkselsatoolsregistry.h>



/*
** Registry.c
**
** Copyright (c) 1999, ELSA AG, Aachen (Germany)
**
** Internal Registry interface 
**
*/


// Code from ELSAESC.h that is in the driver but isn't used and reported yet
#define SUBESC_ET_SET_VALUE_DEFAULT         0x2111111A // set default (any type)
// In structure (Tool -> driver):
// Input Structure to set a registry default for either DWORD or a STRING
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DEFAULT
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DEFAULT

  DWORD    dwID;    // ID of value to set (ET_VALUE_...)
  DWORD    dwType;  // must be ET_VALUE_TYPE_DWORD, ET_VALUE_TYPE_STRING, ...

} ET_SET_VALUE_DEFAULT, *PET_SET_VALUE_DEFAULT;

static BOOL bRegQueryAgainstInternalStatus(
      PPDEV           ppdev, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut,
  OUT LONG           *plRet);

/*
** lEscRegistryValue
**
** escape wrapper for all registry interface calls.
** It checks in/out interface structure sizes,
** and dispatches the sub escapes.
**
** return: ESC_SUCCESS        function succeded without error            
**         ESC_NOTSUPPORTED   function not supported                     
**         ESC_ERROR          function supported but error while working 
**
** FNicklis 08.12.98: New
*/

LONG lEscRegistryValue(
  PPDEV    ppdev,                                               
  ULONG    dwSubEsc, 
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut)
{
  LONG   lRet   = ESC_ERROR; // Default error 
  HANDLE hDriver;

  DBG_TRACE_IN(DBG_LVL_FLOW0, lEscRegistryValue);

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=pvIn);
  ASSERT(cjIn >= sizeof(ET_QUERY));

#ifdef MULTI_BOARD
  hDriver = hGetBoardhDriver(ppdev, ET_QUERY_GET_BOARD(pvIn));
#else
  hDriver = ppdev->hDriver;
#endif

  switch (dwSubEsc)
  {
    case SUBESC_ET_QUERY_VALUE_STRING:  
    case SUBESC_ET_QUERY_VALUE_DWORD :   
    case SUBESC_ET_QUERY_VALUE_BINARY:
    {
      if (cjIn < sizeof(ET_QUERY_VALUE))
      {
        DBG_ERROR("cjIn < sizeof(ET_QUERY_VALUE)");
        break;
      }

      if (!bRegQueryAgainstInternalStatus(ppdev, dwSubEsc, (ET_QUERY_VALUE *)pvIn, cjOut, pvOut, &lRet))
      {
        // call not handled internaly, go through registry
        lRet = lRegEtQueryValue(hDriver, dwSubEsc, (ET_QUERY_VALUE *)pvIn, cjOut, pvOut);
      }

      break;
    }

    case SUBESC_ET_SET_VALUE_STRING:
    case SUBESC_ET_SET_VALUE_DWORD :
    case SUBESC_ET_SET_VALUE_BINARY:
    {
      if ( (NULL==pvOut) ||
           (sizeof(ET_SET_VALUE_RET) > cjOut) )
      {
        DBG_ERROR("SUBESC_ET_SET_VALUE_STRING/DWORD cjOut to small");
        break;
      }

      lRet = lRegEtSetValue(hDriver, dwSubEsc, pvIn, cjIn, (ET_SET_VALUE_RET *)pvOut);
      break;
    }

    default:
    {
      ASSERTDD(dwSubEsc==SUBESC_ET_QUERY_VALUE_STRING,"unhandled and not supported sub escape");
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));
  return (lRet);
}


// *******************************************************************************************
// * Begin of functions manipulationg registry via ID code
// *******************************************************************************************

/*
** lRegEtQueryValue 
**
** Esc interface to retrieve any driver handled registry key
**
** return : ESC_SUCCESS      ( 1) : function finished successfully
**          ESC_NOTSUPPORTED ( 0) : ERROR: iEsc or SubEsc not supported
**          ESC_ERROR        (-1) : ERROR: any other error (wrong feeding)
**
** 141098 MSchwarz: New
** FNicklis 21.10.98: fixed interface mischmasch
*/
LONG lRegEtQueryValue(
  IN  HANDLE          hDriver, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut)
{
  LONG  lRet      = ESC_ERROR;
  LONG  lResult   = REG_ERROR;
  DWORD dwID;     // recalulated and modified Key ID
  DWORD dwType;   // recalulated and modified type identifier

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtQueryValue);
  ASSERTDD(NULL!=petQueryValue,"");
  DBG_PRINTX(DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, petQueryValue->dwID);

  ASSERT(NULL!=hDriver);

  // Save exit on user error!
  if ( NULL==pvOut )
  {
    ASSERTDD(NULL!=pvOut, "lRegEtQueryValue:");
    goto Exit;
  }

  // check if we get the default only
  dwType = petQueryValue->dwType;
  dwID   = petQueryValue->dwID;
  if (bBitsTest(dwType,ET_VALUE_DEFAULT_FLAG))
  {
    // mask out the default type flag 
    vBitsClear(&dwType,ET_VALUE_DEFAULT_FLAG);
    // use our internal ID bit for defaults retrieval
    dwID   = INTERNAL_ET_VALUE_DEFAULT | petQueryValue->dwID;
  }

  // now decide if to get a DWORD or a String
  switch( dwSubEsc )
  {
    case SUBESC_ET_QUERY_VALUE_DWORD:
    {
      ET_VALUE_DWORD *petValueDWord = (ET_VALUE_DWORD*)pvOut;

      if (ET_VALUE_TYPE_DWORD != dwType) // must be DWord now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_DWORD)!= cjOut )
          ||( sizeof(ET_VALUE_DWORD)!= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
      petValueDWord->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdDWord( hDriver, dwID, &petValueDWord->dwValue );

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueDWord->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueDWord->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueDWord->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueDWord->dwFlags",petValueDWord->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      vDbg_PrintET_VALUE_DWORD(DBG_LVL_FLOW1, "petValueDWord", petValueDWord);
      break;
    }

    case SUBESC_ET_QUERY_VALUE_STRING:
    {
      ET_VALUE_STRING *petValueString = (ET_VALUE_STRING*)pvOut;

      if (ET_VALUE_TYPE_STRING != dwType) // must be String now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_STRING)!= cjOut )
          ||( sizeof(ET_VALUE_STRING)!= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueString->dwSize   = sizeof(ET_VALUE_STRING);
      petValueString->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdSz( hDriver, dwID, petValueString->szValue, ET_MAX_STRING );

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueString->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueString->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueString->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueString->dwFlags",petValueString->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      vDbg_PrintET_VALUE_STRING(DBG_LVL_FLOW1, "petValueString", petValueString);
      break;
    }

    case SUBESC_ET_QUERY_VALUE_BINARY:
    {
      ET_VALUE_BINARY *petValueBinary = (ET_VALUE_BINARY*)pvOut;

      if (ET_VALUE_TYPE_BINARY != dwType) // must be binary now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_BINARY) >= cjOut )
          ||( sizeof(ET_VALUE_BINARY) >= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueBinary->dwSize   = cjOut;
      petValueBinary->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdBinary( hDriver, dwID, petValueBinary->ajData, cjOut-sizeof(ET_VALUE_BINARY));

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueBinary->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueBinary->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueBinary->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueBinary->dwFlags",petValueBinary->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      break;
    }

    default:
    {
      DISPDBG((DBG_LVL_ERROR, "lRegEtQueryValue: invalid dwSubEsc:0x%x",dwSubEsc));
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

Exit:
#ifdef DBG
  if (petQueryValue->dwType & ET_VALUE_DEFAULT_FLAG)
  {
    ASSERTDD((ESC_SUCCESS==lRet), "default was queried, why did we fail?");
    DISPDBGCOND( ((((ET_VALUE_DWORD *)pvOut)->dwFlags)!=ET_VALUE_UNKNOWN) && (ET_VALUE_DEFAULT!=((ET_VALUE_DWORD *)pvOut)->dwFlags), (DBG_LVL_ERROR, "default was queried, why don't we report this? dwFlags:0x%x", ((ET_VALUE_DWORD *)pvOut)->dwFlags));
  }
#endif
  ASSERTDD((ESC_SUCCESS==lRet)||(ESC_NOTSUPPORTED==lRet)||(ESC_ERROR==lRet), "assumed interface has changed!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

//*******************************************************************************************
// 081098 MSchwarz 
// FNicklis 21.10.98: fixed return values
LONG lRegEtSetValue(
  IN  HANDLE            hDriver, 
  IN  DWORD             dwSubEsc, 
  IN  VOID             *pvIn, 
  IN  ULONG             cjIn, 
  OUT ET_SET_VALUE_RET *pSetValueRet)
{
  LONG     lRet      = ESC_ERROR; // Default error 
  LONG     lResult   = REG_ERROR; // Default error

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtSetValue);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX,"dwID:0x%x",(pvIn) ? ((ET_SET_VALUE_DWORD*)pvIn)->dwID : -1));

  ASSERT(NULL!=hDriver);
  ASSERT(NULL!=pvIn);

  // now decide if to set a DWORD or a String
  switch( dwSubEsc )
  {
    case SUBESC_ET_SET_VALUE_DWORD:
    {
      ET_SET_VALUE_DWORD *petSetDWord = pvIn;

      if ( sizeof(ET_SET_VALUE_DWORD) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_DWORD) > cjIn");
        break;
      }

      pSetValueRet->dwID = petSetDWord->dwID; // return structure nees ID
      lResult = lRegSetIdDWord( hDriver, petSetDWord->dwID, 
                                petSetDWord->dwValue );

      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;

    }
    case SUBESC_ET_SET_VALUE_STRING:
    {
      ET_SET_VALUE_STRING *petSetString = pvIn;

      if ( sizeof(ET_SET_VALUE_STRING) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_DWORD) > cjIn");
        break;
      }

      pSetValueRet->dwID = petSetString->dwID; // return structure nees ID
      lResult = lRegSetIdSz( hDriver, petSetString->dwID, 
                             petSetString->szValue);
  
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;
    }

    case SUBESC_ET_SET_VALUE_BINARY:
    {
      ET_SET_VALUE_BINARY *petSetBinary = pvIn;

      if ( sizeof(ET_SET_VALUE_BINARY) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_BINARY) > cjIn");
        break;
      }

      ASSERT(petSetBinary->hdr.dwSize==cjIn);
      pSetValueRet->dwID = petSetBinary->dwID; // return structure nees ID
      
      lResult = lRegSetIdBinary(hDriver, 
                                petSetBinary->dwID, 
                                (const BYTE *)petSetBinary->ajData,
                                cjIn-ET_SET_VALUE_BINARY_HDR_SIZE);
  
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;
    }

    default:
    {
      ASSERTDD(dwSubEsc==SUBESC_ET_SET_VALUE_DWORD, " invalid dwSubEsc");
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

  // Handle return values and output buffer 
  // set bitfield in return structure
  // ERROR and SUCCESS should feed the output buffer error flags!
  if (ESC_NOTSUPPORTED!=lRet)
  {
    pSetValueRet->dwSize = sizeof(ET_SET_VALUE_RET);

    // We handled the escape, filled the out structure. 
    // Now we test and set for possible conditions and errors
    switch (lResult)
    {
      case REG_OK:      pSetValueRet->dwFlags  = ET_VALUE_OK;
                        break;

      case REG_DEFAULT: pSetValueRet->dwFlags  = ET_VALUE_DEFAULT;
                        break;

      case REG_ERROR:   pSetValueRet->dwFlags  = ET_VALUE_UNKNOWN;
                        break;

      default :         RIP("lRegEtSetValue: unknown lResult recieved from lRegSetIdDxx");
                        break;
    }

    vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "pSetValueRet->dwFlags",pSetValueRet->dwFlags);
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdBinary
** lRegGetIdDWord
** lRegGetIdSz
** lRegGetIdMultiSz
**
** Read nByte or a DWORD out of the registry form the key matching dwID.
** The result is stored to pjData, pulData or pstrData.
**
** NOTE: String functions work on ascii/ansi strings. WCHAR conversion is done once
** in the miniport layer.
**
** For easier code handling all functions use lRegGetIdBinary. So we have
** one path to the registry only!
**
** returns: REG_OK:      operation successful, output data valid
**          REG_DEFAULT: operation successful but default value returned, output data valid
**          REG_ERROR:   operation failed, output data not valid
**
** MSchwarz 09.10.98: New
** FNicklis 23.10.98: Fixed error handling and functionality
*/
LONG lRegGetIdBinary(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT BYTE  *pjData, 
  IN  DWORD  nByte )
{
  LONG                lRet                  = REG_ERROR;  // ERROR
  IOCTL_ID_TRANSFER*  piit;
  ULONG               ulLength;
  ULONG               ulReturnedDataLength  = 0;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdBinary);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));

  ASSERTDD(hDriver != NULL, "check environment");
  ASSERTDD(pjData  != NULL, "check caller's interface");
  ASSERTDD(nByte   != 0,    "check caller's interface");

  ulLength  =  sizeof(IOCTL_ID_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetIdBinary
  //
  if( piit )
  {
    DWORD dwWIN32Error=(DWORD)-1;  // IOCTL returns Win32 error code

    piit->dwId        = dwID;
    piit->dwDataSize  = nByte;

#if 0 // FNicklisch 14.09.00: unused
        dwWIN32Error = EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_ID_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_ID_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);
#else
        RIP("later");
#endif // FNicklisch 14.09.00: unused

    if (NO_ERROR == dwWIN32Error)
    {
      // only copy data on success or default

      ASSERTDD(ulReturnedDataLength==ulLength, "check params");

      lRet = piit->lReturnCode;                     // set error code
      RtlCopyMemory( pjData, piit->ajData, nByte ); // copy data to output buffer
    }

    EngFreeMem( piit );
  }
  else
  {
    DBG_ERROR("EngAllocMem failed");
  }

  ASSERTDD((lRet==REG_OK) || (lRet==REG_DEFAULT) || (lRet==REG_ERROR), "unknown return value!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdDWord see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdDWord(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT DWORD *pulData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info

  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pulData, sizeof(DWORD));

  DBGFLAGSOLD();
  DISPDBGCOND((REG_ERROR==lRet),(DBG_LVL_WARNING, "WARNING: REG_ERROR in lRegGetIdDWord on dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DISPDBG((DBG_LVL_FLOW0,"ulData:0x%x %s",( (NULL!=pulData)? (*pulData) : (-1) ), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));

  return lRet;
}

/*
** lRegGetIdSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdSz(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT PSTR   pstrData, 
  IN  DWORD  nByte)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID&INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK),(dwID&INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK)));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info

  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pstrData, nByte);

  DBGFLAGSOLD();
  DISPDBG((DBG_LVL_FLOW0,"pstrData:%s %s",((REG_ERROR!=lRet)?pstrData:"--- invalid data ---"), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdMultiSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdMultiSz(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT PSTR   pstrData, 
  IN  DWORD  nByte)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdMultiSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info
  
  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pstrData, nByte);

  DBGFLAGSOLD();
  DISPDBG((DBG_LVL_FLOW0,"pstrData:%s %s",((REG_ERROR!=lRet)?pstrData:"--- invalid data ---"), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

// *******************************************************************************************

/*
** lRegSetIdBinary
** lRegSetIdDWord 
** lRegSetIdSz 
** lRegSetIdMultiSz 
**
** writes nByte byte or a DWORD to the registry key matching dwID. 
** pjData and pstrData are pointers to a nByte sized buffer, 
** ulData is the value to write.
**
** NOTE: String functions work on ascii/ansi strings. WCHAR conversion is done once
** in the miniport layer.
**
** returns: REG_OK:      operation successful, data written
**          REG_ERROR:   operation failed, data not written
**         (REG_DEFAULT): a future extension could return this, if this was the default data
**
** MSchwarz 09.10.98: New
** FNicklis 23.10.98: Fixed error handling and functionality
*/
LONG lRegSetIdBinary(
  IN       HANDLE hDriver, 
  IN       DWORD  dwID, 
  IN const BYTE  *pjData, 
  IN       DWORD  nByte)
{
  LONG                lRet                 = REG_ERROR;

  IOCTL_ID_TRANSFER*  piit;
  ULONG               ulLength;
  ULONG               ulReturnedDataLength = 0;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdBinary);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x (%s), pjData:0x%x, nByte:%d",dwID,szDbg_GetET_VALUE_IDName(dwID),pjData,nByte));

  ASSERTDD(hDriver != NULL, "check environment");

  ASSERTDD(pjData  != NULL, "check caller's interface");
  ASSERTDD(nByte   != 0,    "check caller's interface");

  ulLength = sizeof(IOCTL_ID_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);

  if( piit )
  {
    DWORD dwWIN32Error=(DWORD)-1;  // IOCTL returns Win32 error code

    piit->dwId        = dwID;
    piit->dwDataSize  = nByte;
    //piit->dwDataType  = REG_BINARY;
    RtlCopyMemory( piit->ajData, pjData, nByte );

#if 0 // FNicklisch 14.09.00: unused
        //  call IOCTL vstatIoctlRegSetIdBinary
    dwWIN32Error = EngDeviceIoControl( hDriver,
                                       IOCTL_VIDEO_REG_ID_TRANSFER_SET,
                                       (VOID*)(piit),ulLength,
                                       (VOID*)(piit),0,
                                       &ulReturnedDataLength);
#else
        RIP("later");
#endif // FNicklisch 14.09.00: unused
    if (NO_ERROR == dwWIN32Error)
    {
      ASSERTDD(ulReturnedDataLength==ulLength, "check params");

      lRet = piit->lReturnCode; // set error code

      if ( REG_DEFAULT==lRet )
      {
        // only default set returns default return code!
        if (!bBitsTest(dwID,INTERNAL_ET_VALUE_DEFAULT))
        {
          lRet = REG_OK;
        }
      }
    }

    EngFreeMem( piit );
  }
  else
  {
    DBG_ERROR("EngAllocMem failed");
  }

  ASSERTDD((lRet==REG_OK) || (lRet==REG_ERROR), "unknown return value!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegSetIdDWord see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdDWord(
  IN HANDLE hDriver, 
  IN DWORD  dwID, 
  IN DWORD  ulData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x, ulData:0x%x",dwID,ulData));

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)&ulData, sizeof(DWORD));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));
  return lRet;
}

/*
** lRegSetIdSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdSz(
 IN       HANDLE hDriver, 
 IN       DWORD  dwID, 
 IN const PSTR   pstrData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x, pstrData:%s",dwID,pstrData));

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)pstrData, strlen(pstrData)+1/*ulStrTrueLen(pstrData)*/);

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegSetIdMultiSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdMultiSz(
 IN       HANDLE hDriver, 
 IN       DWORD  dwID, 
 IN const PSTR   pstrData, 
 IN       DWORD  nByte )
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetIdMultiSz);

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)pstrData, nByte);

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));

  return lRet;
}

//*******************************************************************************************
// 081098 MSchwarz 
// FNicklis 21.10.98: fixed return values
LONG lRegEtDefaultValue(
  IN  HANDLE                hDriver, 
  IN  ET_SET_VALUE_DEFAULT *pDefaultValue, 
  OUT ET_SET_VALUE_RET     *pSetValueRet)
{
  LONG     lRet      = ESC_ERROR; // Default error 
  LONG     lResult   = REG_ERROR; // Default error

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtDefaultValue);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX,"dwID:0x%x",(pDefaultValue) ? pDefaultValue->dwID : -1));

  ASSERT(NULL!=hDriver);
  ASSERT(NULL!=pDefaultValue);
  ASSERT(NULL!=pSetValueRet);

  RtlZeroMemory(pSetValueRet, sizeof(ET_SET_VALUE_RET));

  // preset return structure to error
  pSetValueRet->dwSize = sizeof(ET_SET_VALUE_RET);
  pSetValueRet->dwID   = pDefaultValue->dwID;
  pSetValueRet->dwFlags= ET_VALUE_UNKNOWN; // default error

  // To make code writing and debugging easier I implement this in
  // a two step way. First I read the default from the Miniport,
  // then I write this value again.

  // This helps me to keep the code easy, as I only need to modify
  // the miniports query function.

  // Mask out the default flag as it is useless in this call

  switch (pDefaultValue->dwType & ~ET_VALUE_DEFAULT_FLAG)
  {
    case ET_VALUE_TYPE_DWORD:
    {
      DWORD dwDefault;

      lResult = lRegGetIdDWord(
        hDriver, 
        INTERNAL_ET_VALUE_DEFAULT | pDefaultValue->dwID, 
        &dwDefault);

      if (lResult==REG_ERROR)
      {
        DBG_ERROR("lRegGetIdDWord failed");
        pSetValueRet->dwFlags= ET_VALUE_UNKNOWN;
      }
      else
      {      
        lResult = lRegSetIdDWord(
          hDriver, 
          pDefaultValue->dwID,
          dwDefault);
      }
      break;
    }

    case ET_VALUE_TYPE_STRING:
    {
      PSTR pszDefault;

      // allocate temporary buffer
      if (bAllocMem((PVOID *)&pszDefault, sizeof(ET_MAX_STRING), ALLOC_TAG))
      {
        // add default flag to read the default.
        lResult = lRegGetIdSz(
          hDriver, 
          INTERNAL_ET_VALUE_DEFAULT | pDefaultValue->dwID, 
          pszDefault,
          ET_MAX_STRING);

        if (lResult==REG_ERROR)
        {
          DBG_ERROR("lRegGetIdSz failed");
          pSetValueRet->dwFlags= ET_VALUE_UNKNOWN;
        }
        else 
        {      
          // write the default read above again!
          lResult = lRegSetIdSz(
            hDriver, 
            pDefaultValue->dwID,
            pszDefault);
        }

        // free temporary buffer again
        bFreeMem((PVOID *)&pszDefault, sizeof(ET_MAX_STRING));
      }
      break;
    }

    default:
      ASSERTDD(pDefaultValue->dwType==ET_VALUE_TYPE_STRING, "unkown ET_VALUE_TYPE_xx");
      break;
  }

  if (REG_ERROR != lResult)
  {
    pSetValueRet->dwFlags= ET_VALUE_DEFAULT;
  }
  else
  {
    DBG_ERROR("failed to set the default value");
  }

  // The escape doesn't fail! 
  // But error codes are stored in the return structure
  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

// *******************************************************************************************
// * End of functions manipulationg registry via ID code
// *******************************************************************************************

#if 0 // FNicklis seems to be unused code...

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegGetValueBinary( HANDLE hDriver, PSTR pstrValue, BYTE* pjData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueBinary);

  ASSERTDD(hDriver != NULL, "lRegGetValueBinary");
  ASSERTDD(pjData  != NULL, "lRegGetValueBinary");
  ASSERTDD(nByte   != 0,    "lRegGetValueBinary");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueBinary
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_BINARY;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pjData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegSetValueBinary( HANDLE hDriver, PSTR pstrValue, BYTE* pjData, DWORD nByte )
{

  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueBinary);

  //  call IOCTL 
  ASSERTDD(hDriver != NULL, "lRegSetValueBinary");
  ASSERTDD(pjData  != NULL, "lRegSetValueBinary");
  ASSERTDD(nByte   != 0,    "lRegSetValueBinary");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueBinary
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_BINARY;
    RtlCopyMemory( piit->ajData, pjData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegGetValueDWord( HANDLE hDriver, PSTR pstrValue, DWORD* pulData )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetValueDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," pstrValue:%s",pstrValue));

  ASSERTDD(hDriver != NULL, "lRegGetValueDWord");
  ASSERTDD(pulData != NULL, "lRegGetValueDWord");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + sizeof(DWORD);

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueDWord
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = sizeof(DWORD);
    piit->dwDataType  = REG_DWORD;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pulData, piit->ajData, sizeof(DWORD) );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 121098 MSchwarz 
LONG lRegSetValueDWord( HANDLE hDriver, PSTR pstrValue, DWORD* pulData )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueDWord);

  ASSERTDD(hDriver != NULL, "lRegSetValueDWord");
  ASSERTDD(pulData != NULL, "lRegSetValueDWord");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + sizeof(DWORD);

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueDWord
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = sizeof(DWORD);
    piit->dwDataType  = REG_DWORD;
    RtlCopyMemory( piit->ajData, pulData, sizeof(DWORD) );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegGetValueSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueSz);

  ASSERTDD(hDriver  != NULL, "lRegGetValueSz");
  ASSERTDD(pstrData != NULL, "lRegGetValueSz");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueSz
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_SZ;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pstrData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegSetValueSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueSz);

  ASSERTDD(hDriver  != NULL, "lRegSetValueSz");
  ASSERTDD(pstrData != NULL, "lRegSetValueSz");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueSz
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_SZ;
    RtlCopyMemory( piit->ajData, pstrData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegGetValueMultiSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueMultiSz);

  ASSERTDD(hDriver  != NULL, "lRegGetValueMultiSz");
  ASSERTDD(pstrData != NULL, "lRegGetValueMultiSz");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctRegGetValueMultiSz
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_MULTI_SZ;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pstrData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegSetValueMultiSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueMultiSz);

  ASSERTDD(hDriver  != NULL, "lRegSetValueMultiSz");
  ASSERTDD(pstrData != NULL, "lRegSetValueMultiSz");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctRegSetValueMultiSz
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_MULTI_SZ;
    RtlCopyMemory( piit->ajData, pstrData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}
#endif
//*******************************************************************************************

/*
** bRegRead (single board)
**
** Initialize driver with information taken out of registry...
**
** returns TRUE if successful
**
** FNicklis 22.10.98: derived from bPageflipModeUpdate
*/
BOOL bRegRead(PPDEV ppdev)
{
  BOOL  bRet     = FALSE;
  ULONG ulSwitch = FALSE;// used as boolean to read registry

  DBG_TRACE_IN(DBG_LVL_FLOW0, bRegRead);

#if 0 // ELSA-FNicklis 04.07.00: unused
    if ( (1==ppdev->cjPelSize) ||                  // 8 bpp
       (ppdev->cyMemory < (ppdev->cyScreen*2)) ) // front, Z
  {
    // 3D not possible

    DBG_ERROR("No room for SB-OpenGL, disable OpenGL");    
    v3DCapsClear((ULONG)0xFFFFFFFF); // clear all bits!

    v3DCapsClear(FL_3DCAPS_3D_POSSIBLE) ;
    v3DCapsClear(FL_3DCAPS_HARDWARE_ACCELERATION);
  }
  else
  {
    // 3D possible!
    ULONG ulBuffers = 0;     // number of decided buffers
    BOOL  bDouble   = TRUE;  // try double buffering
    BOOL  bPageflip = FALSE; // allow pageflipping
    BOOL  bOverlay  = FALSE; // overlay not default
    BOOL  bStereo   = FALSE; // overlay not default

    // We have an accelerated board but...
    v3DCapsSet(FL_3DCAPS_3D_POSSIBLE);

    // ...perhaps it is disabled by the user 
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_DISABLE, &ulSwitch ) )
    {
      ulSwitch = TRUE; // default is 3D on
    }

    // disable != 0 (TRUE) -> not enabled
    if (0 != ulSwitch)
    {
      // 3D acceleration disabled
      v3DCapsClear(FL_3DCAPS_HARDWARE_ACCELERATION);
    }
    else
    {
      // 3D acceleration enabled
      v3DCapsSet(FL_3DCAPS_HARDWARE_ACCELERATION);
    }

    // Check memory capabilities
    bDouble  = bOpenGLDoubleBufferPossible(ppdev);
    bStereo  = bOpenGLStereoBufferPossible(ppdev);
    bOverlay = bOpenGLOverlayBufferPossible(ppdev);


    // write double buffer state
    if (REG_ERROR == lRegSetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS, (bDouble ? 2 : 1)) )
    {
      DBG_ERROR("lRegSetIdDWord failed: ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS");
    }

    // Set Pixelformats PFD_SUPPORT_GDI flag?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI, &ulSwitch) )
      ulSwitch = TRUE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_SUPPORT_GDI);
    else
      v3DCapsClear(FL_3DCAPS_PFD_SUPPORT_GDI);

    // configure SWBC layer
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS, &ulSwitch) )
      ulSwitch = FALSE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_FORCEGDIBROADCAST);
    else
      v3DCapsClear(FL_3DCAPS_FORCEGDIBROADCAST);

    // check double buffer user settings
    if (bDouble)
    {
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS, &ulBuffers ) )
        ulBuffers = 2;
    }
    else
      ulBuffers = 1;

    // check double buffer capabilities
    if (ulBuffers > 1)
    {
      v3DCapsSet(FL_3DCAPS_PFD_DOUBLEBUFFER);

      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_ALIGNED_SURFACES, &ulSwitch ) )
        ulSwitch = 0;
      if (0 != ulSwitch)
        v3DCapsSet(FL_3DCAPS_ALIGNED_SURFACES);
      else
        v3DCapsClear(FL_3DCAPS_ALIGNED_SURFACES);
        
      // check ForceSingleBuffered
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED, &ulSwitch ) )
        ulSwitch = 0;
      if (0 != ulSwitch)
        v3DCapsSet(FL_3DCAPS_FORCE_SINGLEBUFFERD);
      else
        v3DCapsClear(FL_3DCAPS_FORCE_SINGLEBUFFERD);

      //
      // We always support blitted swap buffers, but do we need PFDs that
      // only can blit?
      //
      // Check if we export PFD_SWAP_COPY DrvDescribePixelformat
      //
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY, &ulSwitch) )
        ulSwitch=1;
      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_COPY);
      else
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_COPY);

#ifdef RUN_WITH_NVIDIA_MINIPORT 
      bPageflip = FALSE;
#else //RUN_WITH_NVIDIA_MINIPORT 
      //
      // Check if we allow pageflipping, else we would force buffer blits
      //
      // ulSwitch = 0 on Riva TNT! // cannot do HBlank-flip on NV4, so disable pageflipping
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING, &ulSwitch ) )
        ulSwitch = 1; // allow pageflip

      if (0!=ulSwitch)
        bPageflip = TRUE;
#endif//RUN_WITH_NVIDIA_MINIPORT 
    }
    else
    {
      // double buffering disabled
      bDouble  = FALSE; // no double
      v3DCapsClear( FL_3DCAPS_PFD_DOUBLEBUFFER
                   |FL_3DCAPS_PFD_SWAP_COPY);
    }

    //
    // Check vblank user settings
    //
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT, &ulSwitch ) )
      ulSwitch = FALSE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_VBLANKWAIT);           // wait for vblank
    else
      v3DCapsClear(FL_3DCAPS_VBLANKWAIT);

    //
    // Set page flip capabilities
    //
    if (bPageflip)
    {
      // Pageflipping allowed and possible - clear the force buffer blit bit
      v3DCapsSet(FL_3DCAPS_PAGEFLIP);          // try a pageflip in swap buffers

      // export PFD_SWAP_EXCHANGE in DrvDescribePixelformat?
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE, &ulSwitch) )
        ulSwitch = 1;
      if (ulSwitch)
      { // export Swap_exchange in pixelformat
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_EXCHANGE);
      }
      else
      {
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_EXCHANGE);
      }
    }
    else
    {
      // not possible to do pagefliping or tripple buffering
      v3DCapsClear( FL_3DCAPS_PAGEFLIP
                   |FL_3DCAPS_PFD_SWAP_EXCHANGE);
    }

    // Check OpenGL DMA Flush -> don't flip or blit
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES, &ulSwitch ) )
      ulSwitch = 0;

    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch&0x2) 
      v3DCapsSet(FL_3DCAPS_NODMAFLUSH);
    else
      v3DCapsClear(FL_3DCAPS_NODMAFLUSH);

    // Export Buffer Region extension?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_KTX_BUFFERREGIONS, &ulSwitch ) )
      ulSwitch = 1;

    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch) 
      v3DCapsSet(FL_3DCAPS_KTXBUFFERREGIONS);
    else
      v3DCapsClear(FL_3DCAPS_KTXBUFFERREGIONS);


    // Export Buffer Region extension?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_KTX_SWAPHINTS, &ulSwitch ) )
      ulSwitch = 1;
    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch) 
      v3DCapsSet(FL_3DCAPS_KTXSWAPHINTS);
    else
      v3DCapsClear(FL_3DCAPS_KTXSWAPHINTS);


    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLE_STENCIL, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_DISABLE_STENCIL);
    else
      v3DCapsClear(FL_3DCAPS_PFD_DISABLE_STENCIL);


    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLE_ALPHA, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_DISABLE_ALPHA);
    else
      v3DCapsClear(FL_3DCAPS_PFD_DISABLE_ALPHA);

    //
    // Set stereo capabilities
    //
    if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT, &ulSwitch) )
      ulSwitch = 0; // don't use stereo by default

    if(    (bStereo)
        && (0!=ulSwitch) 
      )
    {
      v3DCapsSet(FL_3DCAPS_PFD_STEREO);

      if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS, &ulSwitch) )
        ulSwitch = 0; // don't force stereo buffers by default
      if( 0!=ulSwitch )
        v3DCapsSet(FL_3DCAPS_FORCE_STEREO);
      else
        v3DCapsClear(FL_3DCAPS_FORCE_STEREO);
    }
    else
    {
      v3DCapsClear(FL_3DCAPS_PFD_STEREO);
      v3DCapsClear(FL_3DCAPS_FORCE_STEREO);
    }

    //
    // Set overlay capabilities
    //
    if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES, &ulSwitch) )
      ulSwitch = 0; // don't use overlay by default

    if (   bOverlay
        && (0!=ulSwitch) )
    {
      v3DCapsSet(FL_3DCAPS_PFD_OVERLAYS);
      v3DCapsSet(FL_3DCAPS_OVERLAYS_VIA_FRONT); // MSchwarz 2.11.99:  refer to o_overlay.c: 4. 1st comment
      v3DCapsSet(FL_3DCAPS_OVERLAY_SWBC);
      // Set swap layer caps
      if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS, &ulSwitch) )
        ulSwitch = 1; // allow swap layerbuffers by default
      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
      else
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
    }
    else
    {
      if (0!=ulSwitch)
      {
        DBG_ERROR("Want overlay but not enough offscreen");
      }
      v3DCapsClear(FL_3DCAPS_PFD_OVERLAYS);
      v3DCapsClear(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
    }

    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_FORCE_STENCIL);
    else
      v3DCapsClear(FL_3DCAPS_PFD_FORCE_STENCIL);

    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_FORCE_MORETHAN16BITZ);
    else
      v3DCapsClear(FL_3DCAPS_PFD_FORCE_MORETHAN16BITZ);

    //
    // Determine if ICD awaits client or board relative clip rects within shared info
    // Documentaion in o_Clipping.c
    //
    // NOTE: This key has no default, so set it here in all cases!
    v3DCapsClear(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
    v3DCapsClear(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
    if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS, &ulSwitch) )
    {
      if (bIsSingleScreen(ppdev))
        ulSwitch = DEFAULT_OPENGL_CLIENTCLIPRECTS_1BOARD; // use single board default
      else
        ulSwitch = DEFAULT_OPENGL_CLIENTCLIPRECTS_NBOARD; // use multi boarddefault
    }
    else
    {
      DBG_WARNING("INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS overwritten by registry!");
    }
    
    switch (ulSwitch)
    {
      case CCT_DESKTOPRELATIVE: 
        // desktop relative clip rects
        break;
      case CCT_BOARDRELATIVE:   
        // board relative
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        break;
      case CCT_CLIENTRELATIVE: 
        // client relative
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        break;
      case CCT_CLIENTANDBOARDRELATIVE: 
        // board and client relative
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        break;
      default:
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        ASSERTDD(DEFAULT_OPENGL_CLIENTCLIPRECTS_1BOARD==ulSwitch, "set to client and board relative");
        break;
    }

    #if BETA_VERSION
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK, &ulSwitch ) )
      ulSwitch = 0;
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_NO_ICD_CALLBACK);  
    else
      v3DCapsClear(FL_3DCAPS_NO_ICD_CALLBACK);
    #endif    

    #ifdef DBG
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO, &ulSwitch ) )
        ulSwitch = FALSE;

      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);  
      else
        v3DCapsClear(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);
    #endif
    vDbg_Printfl3DCapabilities(DBG_LVL_FLOW0, "ppdev->fl3DCapabilities", ppdev);
  }

#ifdef DBG
#ifdef _WIN64
  v3DCapsSet(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);
#endif

  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY, (DWORD *)&bDbg_CheckHeap) )
    bDbg_CheckHeap = TRUE;

  DBG_PRINTB(DBG_LVL_FLOW0, bDbg_CheckHeap);
#endif

#if BETA_VERSION
  if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM, &ulSwitch) )
    ulSwitch = 0;

  if (0!=ulSwitch)
  {
    DBG_WARNING("We override the Heaps HEAP_ALLOC_TYPE_POS_BOTTOM flag now!");
    v2DCapsSet(FL_2DCAPS_SURFACENEVERATBOTTOM);
  }
  else
    v2DCapsClear(FL_2DCAPS_SURFACENEVERATBOTTOM);
  
  if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_HELPERFLAGS, &ppdev->flRegHelperFlags) )
    ppdev->flRegHelperFlags = 0;

  // Read reserved keys for internal and temporary usage.
  // Never check in code that uses ulRegReserved0-9!
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED0, &ppdev->ulRegReserved0) )
    ppdev->ulRegReserved0 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED1, &ppdev->ulRegReserved1) )
    ppdev->ulRegReserved1 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED2, &ppdev->ulRegReserved2) )
    ppdev->ulRegReserved2 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED3, &ppdev->ulRegReserved3) )
    ppdev->ulRegReserved3 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED4, &ppdev->ulRegReserved4) )
    ppdev->ulRegReserved4 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED5, &ppdev->ulRegReserved5) )
    ppdev->ulRegReserved5 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED6, &ppdev->ulRegReserved6) )
    ppdev->ulRegReserved6 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED7, &ppdev->ulRegReserved7) )
    ppdev->ulRegReserved7 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED8, &ppdev->ulRegReserved8) )
    ppdev->ulRegReserved8 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED9, &ppdev->ulRegReserved9) )
    ppdev->ulRegReserved9 = 0;
#endif

  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK, &ulSwitch ) )
    ulSwitch = 0;
  
  //  Skuklik: 09.02.2000
  //  0002.0115.5432.CBUE
  //  to fix misbehavior with mediamatics DVD Express
  //  Enabling support for OverlayShrink in DDraw causes fails in HCT (TDDraw) 
  //  CASE 12: Consume all Vid Mem Test (TC 6.1.1) fails
  //  So just turn on this feature if needed by an application, and disable it by default

  if (0!=ulSwitch)
    v2DCapsSet(FL_2DCAPS_SUPPORT_OVERLAYSHRINK);  
  else
    v2DCapsClear(FL_2DCAPS_SUPPORT_OVERLAYSHRINK);

  vDbg_Printfl2DCapabilities(DBG_LVL_FLOW0, "ppdev->fl2DCapabilities", ppdev);

  bRet = TRUE;
#endif // ELSA-FNicklis 04.07.00: unused

  DBG_TRACE_OUT(DBG_LVL_FLOW0, bRet);
  return (bRet);
}

#if DBG
// ELSA-FNicklis 14.04.00: global to help masking of punt flags below.
FLONG flDbgPunt=0xFFFFFFFF;
#endif

/*
** bRegInit
**
** Initialize registry stuff and read driver init values.
**
** FNicklis 27.05.1999: Moved DrvEnableSurface stuff to this function.
*/
BOOL bRegInit(PPDEV ppdev)
{
  ULONG ulSwitch;
  BOOL  bRet = FALSE;

#if 0 // ELSA-FNicklis 04.07.00: unused
    ASSERT(NULL!=ppdev);
  ASSERT(NULL!=ppdev->hDriver);

  // MSchwarz 161098 moved it from RegRead because EnableHardware needs the value
  if(REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_GDI_DMABUFFERSIZE, &ppdev->DmaPushBufTotalSize))
  {
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ppdev->DmaPushBufTotalSize: 0x%x",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_DMABUFFERSIZE), 
      ppdev->DmaPushBufTotalSize));
  }

  // Need at least 8kb buffer to run properly
  if (ppdev->DmaPushBufTotalSize < ((8 KB) + sizeof(DWORD)))
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;

  if(REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_GDI_DMAPADDING, &ppdev->ulDmaPadding))
  {
    ppdev->ulDmaPadding = DMAPUSH_PADDING;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ppdev->DmaPushBufTotalSize: 0x%x",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_DMAPADDING), 
      ppdev->ulDmaPadding));
  }

  // at least one DWORD at the end
  if (ppdev->ulDmaPadding < sizeof(DWORD))
    ppdev->ulDmaPadding = sizeof(DWORD);

  // Need at least 8kb buffer to run properly
  if (ppdev->DmaPushBufTotalSize-ppdev->ulDmaPadding < (8 KB))
  {
    DBG_ERROR("Fallback to default DmaPushBufTotalSize and ulDmaPadding");
    ppdev->ulDmaPadding    = DMAPUSH_PADDING;
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;
  }


  //
  // Support HW lines
  //
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_HWLINES, &ulSwitch) )
    ulSwitch = FALSE;
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_HWLINES);  
  else
    v2DCapsClear(FL_2DCAPS_HWLINES);


  //
  // Enable device bitmaps
  //
#ifdef _WIN64
  // FNicklis IA-64: ToDo - portation not complete!
  #pragma message ("  FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS "__FILE__)
  DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS %s %d",__FILE__,__LINE__));
  v2DCapsClear(FL_2DCAPS_ENABLEDEVICEBITMAPS);
#else
#ifndef RUN_WITH_NVIDIA_MINIPORT 
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS, &ulSwitch) )
    ulSwitch = TRUE;
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_ENABLEDEVICEBITMAPS);
  else
#endif //RUN_WITH_NVIDIA_MINIPORT 
  {
    DBG_WARNING("FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS");
    v2DCapsClear(FL_2DCAPS_ENABLEDEVICEBITMAPS);
  }
#endif


  //
  // Read GDI DMA-buffer allocation type
  //
#if (_WIN32_WINNT >= 0x0500)
  DISPDBG((DBG_LVL_FLOW0, "AGP needed for W2K initialization of miniport"));
  v2DCapsSet(FL_2DCAPS_AGP_DMA);

#else
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_AGP_DMA, &ulSwitch) )
  {
    ulSwitch = FALSE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ulSwitch: %s",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_AGP_DMA), 
      szBOOL(ulSwitch)));
  }
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_AGP_DMA);
  else
    v2DCapsClear(FL_2DCAPS_AGP_DMA);
#endif // ELSA-FNicklis 09.05.00: unused


  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_FRAMEBUFFER_DMA, &ulSwitch) )
  {
    ulSwitch = FALSE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ulSwitch: %s",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_FRAMEBUFFER_DMA), 
      szBOOL(ulSwitch)));
  }
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_FRAMEBUFFER_DMA);
  else
    v2DCapsClear(FL_2DCAPS_FRAMEBUFFER_DMA);

  vDbg_Printfl2DCapabilities(DBG_LVL_FLOW0, "ppdev->fl2DCapabilities", ppdev);

#if BETA_VERSION
#ifdef RUN_WITH_NVIDIA_MINIPORT 
      DISPDBG((DBG_LVL_WARNING, "ELSA-FNicklis 14.04.00: ppdev->flPunt %s %d",__FILE__,__LINE__));
      ppdev->flPunt = (
                      FL_PUNT_DRVFILLPATH          
                    | FL_PUNT_DRVCOPYBITS          
                    | FL_PUNT_DRVBITBLT                                 
                    | FL_PUNT_DRVLINETO            
                    | FL_PUNT_DRVPAINT             
                    | FL_PUNT_DRVSTRETCHBLT        
                    | FL_PUNT_DRVSTROKEPATH        
                    | FL_PUNT_DRVTEXTOUT           
                    | FL_PUNT_DRVMOVEPOINTER       
                    | FL_PUNT_DRVSETPOINTERSHAPE   
                    | FL_PUNT_DRVCREATEDEVICEBITMAP
                    | FL_PUNT_DRVSETPALETTE                
                    | FL_PUNT_CHANNELSWITCH
                    | FL_PUNT_SYNCH
                    ) 
#if DBG
                    & flDbgPunt
#endif
                    ;
#else
  // FNicklis IA-64: Added dynamic punt possiblity
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS, &ppdev->flPunt) )
  {
    #ifdef _WIN64
      // FNicklis IA-64: ToDo - portation not complete!
      #pragma message ("  FNicklis IA-64: ToDo: ppdev->flPunt "__FILE__)
      DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: ppdev->flPunt %s %d",__FILE__,__LINE__));
      ppdev->flPunt = FL_PUNT_DRVFILLPATH          
                    | FL_PUNT_DRVCOPYBITS          
                    | FL_PUNT_DRVBITBLT                                 
                    | FL_PUNT_DRVLINETO            
                    | FL_PUNT_DRVPAINT             
                    | FL_PUNT_DRVSTRETCHBLT        
                    | FL_PUNT_DRVSTROKEPATH        
                    | FL_PUNT_DRVTEXTOUT           
                    | FL_PUNT_DRVMOVEPOINTER       
                    | FL_PUNT_DRVSETPOINTERSHAPE   
                    | FL_PUNT_DRVCREATEDEVICEBITMAP
                    | FL_PUNT_DRVSETPALETTE                
                    | FL_PUNT_CHANNELSWITCH
                    | FL_PUNT_SYNCH
                    ;
    #else
      ppdev->flPunt = 0; // don't punt anything
    #endif
  }
#endif
  if (0!=ppdev->flPunt)
  {
    vDbg_PrintFL_PUNT_Flags(DBG_LVL_WARNING, "ppdev->flPunt", ppdev->flPunt);
  }
#endif


  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP, &ppdev->ulOverlayBPP) )
  {
    ASSERT(0!=ppdev->cjPelSize);
    ppdev->ulOverlayBPP = ppdev->cjPelSize * 8; // bits per pixel => TC overlay in TC, 16bpp overlay in 16bpp
  }
  else
  {
    DISPDBG((DBG_LVL_WARNING, "Overwrite for INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP:%d", ppdev->ulOverlayBPP));
  }

  bRet = TRUE;
#endif // ELSA-FNicklis 04.07.00: unused
  return(bRet);
}


/*
** bRegQueryAgainstInternalStatus (single board)
**
** Esc interface to retrieve any driver handled registry key
**
** NOTE: Don't disable keys using the flags set by the keys! Else 
**       yout wont be able to enable again!
**
** plRet : ESC_SUCCESS      ( 1) : function finished successfully
**         ESC_NOTSUPPORTED ( 0) : ERROR: iEsc or SubEsc not supported
**         ESC_ERROR        (-1) : ERROR: any other error (wrong feeding)
** return: TRUE                  : Escape handled, plRet and pvOut valid
**         FALSE                 : Escape not handled, do it through registry
**
** FNicklis 05.03.1999: New
** FNicklis 25.10.1999: Added first valid return values
*/
static BOOL bRegQueryAgainstInternalStatus(
      PPDEV           ppdev, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut,
  OUT LONG           *plRet)
{
  ET_VALUE_DWORD *petValueDWord = (ET_VALUE_DWORD*)pvOut;
  LONG            bRet          = FALSE; // not handled (default)
  DWORD           dwType;                // recalulated and modified type identifier
  BOOL            bDisableKey   = FALSE; // Key disabled 
  BOOL            bValueSet     = FALSE; // We have a value to return, stored to petValueDWord->dwValue

  DBG_TRACE_IN(DBG_LVL_FLOW0_NLF,bRegQueryAgainstInternalStatus);
  ASSERT(NULL!=petQueryValue);
  DBG_PRINTX(DBG_LVL_FLOW0_NP, petQueryValue->dwID);

  ASSERT(NULL!=ppdev);

  if (dwSubEsc==SUBESC_ET_QUERY_VALUE_DWORD)
  {
    // Don't touch output before we have checked it!
    if (   ( NULL==pvOut )
        || ( sizeof(ET_VALUE_DWORD)!= cjOut )
        || ( sizeof(ET_VALUE_DWORD)!= petQueryValue->hdr.dwOutSize )  )
    {
      DBG_ERROR("Outbuffer to small or invalid data:");
      DISPDBG((DBG_LVL_ERROR, "sizeof(ET_VALUE_DWORD)=%d, cjOut=%d, petQueryValue->hdr.dwOutSize:%d", sizeof(ET_VALUE_DWORD), cjOut,petQueryValue->hdr.dwOutSize));
      bRet   = TRUE;      // handled, but cannot work correctly
      *plRet = ESC_ERROR; // return error to escape
      goto Exit;
    }
    // Ok
  }
  else
  {
    //
    // Only handle dwords by now!
    //
    goto Exit;
  }

  // check if we get the default only
  dwType = petQueryValue->dwType;

  // first check the Keys we don't want to support!
  switch (petQueryValue->dwID)
  {
    case ET_VALUE_DW_ICDINTERFACE_DISABLE:
    {
#if 0 // ELSA-FNicklis 04.07.00: unused
      if (!b3DCapsTest(FL_3DCAPS_3D_POSSIBLE))
      {
        bDisableKey=TRUE;
      }
#endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    // Keys that are not available in single buffered resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING:
    case ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE:
    case ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS:
    case ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS:
    {
      #if 0 // ELSA-FNicklis 04.07.00: unused
      if (!bOpenGLDoubleBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      #endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    // Keys that are not available in non overlay capable resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS:
    case ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES  :
    {
      #if 0 // ELSA-FNicklis 04.07.00: unused
      if (!bOpenGLOverlayBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      #endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    #if 0 // ELSA-FNicklis 04.07.00: unused
    case INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP         :
    {
      if (!bOpenGLOverlayBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      else
      {
        petValueDWord->dwValue = ppdev->ulOverlayBPP;
        bValueSet = TRUE;
      }
      break;
    }
    #endif // ELSA-FNicklis 04.07.00: unused

#if 0 // ELSA-FNicklis 04.07.00: unused
    // Keys that are not available in non stereo capable resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PFD_STEREO:
    case ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS:
    case ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT:
    {
      if (!bOpenGLStereoBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      break;
    }
#endif // ELSA-FNicklis 04.07.00: unused
  }

  if (bValueSet)
  {
    //
    // Did find an internal value, no need to go to registry!
    //
    petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
    petValueDWord->dwID     = petQueryValue->dwID;
    petValueDWord->dwFlags  = ET_VALUE_OK;

    *plRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
    bRet = TRUE;
  }
  else if (bDisableKey)
  {
    // did we find a key want to disable

    // NOTE: Don't disable keys using the flags set by the keys! Else 
    //       yout wont be able to enable again!
    petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
    petValueDWord->dwID     = petQueryValue->dwID;
    petValueDWord->dwFlags  = ET_VALUE_UNKNOWN;

    vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueDWord->dwFlags",petValueDWord->dwFlags);
    *plRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
    bRet = TRUE;
  }
  else 
  {
    goto Exit;
  }

  // defaults that have to be handled must go through miniport!
  if (bBitsTest(dwType,ET_VALUE_DEFAULT_FLAG))
  {
    vBitsClear(&dwType,ET_VALUE_DEFAULT_FLAG);
    goto Exit;
  }

  if (ET_VALUE_TYPE_DWORD != dwType) // must be DWord now, as Default flag is removed
  {
    DBG_ERROR("internal error: returning wrong type");
    bRet   = TRUE; // handled, but cannot work correctly
    *plRet = ESC_ERROR;
    goto Exit;
  }
  
Exit:
  DBG_TRACE_OUT(DBG_LVL_FLOW0, bRet);

  return bRet;
}

#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsregistry.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolstoolbox.h ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolstoolbox.h
//
// FNicklisch 09/14/2000: New, derived from toolbox.h and others
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _WKSELSATOOLSTOOLBOX_H
#define _WKSELSATOOLSTOOLBOX_H

#ifdef USE_WKS_ELSA_TOOLS
/*
** common code used in miniport and display driver
*/

ULONG ulStrLen(IN PSTR pString);
ULONG ulStrTrueLen(IN PSTR pString);
ULONG ulWStrLen(IN PWSTR pString);
ULONG ulWStrTrueLen(IN PWSTR pString);

PSTR  szStrCpy     (OUT PSTR  pTrg, IN const PSTR  pSrc);
PSTR  szStrCat     (OUT PSTR  pTrg, IN const PSTR  pSrc);
PSTR  szStrCpyWStr (OUT PSTR  pTrg, IN const PWSTR pSrc);
PSTR  szStrCatWStr (OUT PSTR  pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCpy    (OUT PWSTR pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCat    (OUT PWSTR pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCpyStr (OUT PWSTR pTrg, IN const PSTR  pSrc);
PWSTR wszWStrCatStr (OUT PWSTR pTrg, IN const PSTR  pSrc);

#ifdef DBG
VOID vDbg_Check_c_ToolBox(VOID);
#else
#define vDbg_Check_c_ToolBox()
#endif

// FNicklis IA-64: Need a pointer size here
// calculate offset in 32 bit ULONG between two pointers
ULONG __inline ulPtrOffsetInByte(IN PVOID pv1, IN PVOID pv2)
{
  // FNicklis IA-64: Usage of 32 bit is save here
  return( (ULONG)((ULONG_PTR)((BYTE*)pv1 - (BYTE*)pv2)) );
}

// FNicklis 21.10.98 20:40:19: New
__inline VOID vBitsSet(IN OUT FLONG *pflValue, IN FLONG flSetBits)
{
  *pflValue |= flSetBits;
}

// FNicklis 21.10.98 20:40:19: New
__inline VOID vBitsClear(IN OUT FLONG *pflValue, IN FLONG flClearBits)
{
  *pflValue &= (~flClearBits);
}

__inline int bBitsTest(IN FLONG flValue, IN FLONG flTestBits)
{
  return ( (flValue & flTestBits) == flTestBits ); // exact match on each bit!
}

/*
** Memory allocation
*/
BOOL bAllocMem(PVOID *ppBuffer, ULONG nByte, ULONG ulTag);

BOOL bAllocMemPageAligned(IN OUT PVOID     *ppvAlign,
                      IN     ULONG      ulSize, // size to allocate
                      IN     ULONG      ulTag); // memory tag
BOOL bFreeMemPageAligned(IN OUT PVOID     *ppvAlign);

#ifdef DBG
BOOL bFreeMem(PVOID *ppBuffer, ULONG nDebugOnlyByteToClear);
#else
BOOL _bFreeMem(PVOID *ppBuffer); // one parameter only
#define bFreeMem(ppBuffer,nDebugOnlyByteToClear) _bFreeMem(ppBuffer)
#endif

__inline BOOL bRectAlloc(RECTL **pprcl, LONG c, ULONG ulTag)
{
  return (bAllocMem((PVOID *)pprcl, c*sizeof(RECTL), ulTag));
}

__inline BOOL bRectFree(RECTL **pprcl)
{
  return (bFreeMem((PVOID *)pprcl,0)); // don't know how much to free!
}

DWORD GetCurrentProcessID(VOID);
CHAR *szGetApplicationName(VOID);


#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSTOOLBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv3cur.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV3CUR.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the hardware cursor
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;**********************************************************************
; Tables are used to convert MONO mask. Ones convert to 7fffh and zeros to 0
; The AND mask is used to add transparency bit. Zero in AND mask converts
; to 8000h, 1 to zero.
;**********************************************************************


MonoTable   dd  0                       ; MONO 00 
            dd  7fff0000h               ; MONO 01 (bits need to be transposed)
            dd  00007fffh               ; MONO 10 (bits need to be transposed)
            dd  7fff7fffh               ; MONO 11
            
AndTable    dd  80008000h               ; MONO 00
            dd  00008000h               ; MONO 01 (bits need to be transposed)
            dd  80000000h               ; MONO 10 (bits need to be transposed)
            dd  0                       ; MONO 11

;
;  stack based params and local variables
;

NV3_LOAD_CURSOR_DATA_STRUC          struc

; Feel free to add any local variables here:

NV3LCD_Row_Count            dd      ?
NV3LCD_Byte_Count           dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3LCD_ebp                  dd      ?
NV3LCD_esi                  dd      ?
NV3LCD_edi                  dd      ?
NV3LCD_ebx                  dd      ?
NV3LCD_RetAddr              dd      ?
NV3LCD_SrcPtr               dd      ?
NV3LCD_DestPtr              dd      ?

NV3_LOAD_CURSOR_DATA_STRUC          ends

NV3_LOAD_CURSOR_DATA_PARM_SIZE     equ     7 * 4

; --------

NV3_CURSOR_CHECKSUM_STRUC          struc

; Feel free to add any local variables here:

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3CHK_ebx                  dd      ?
NV3CHK_ebp                  dd      ?
NV3CHK_esi                  dd      ?
NV3CHK_RetAddr              dd      ?
NV3CHK_SrcPtr               dd      ?

NV3_CURSOR_CHECKSUM_STRUC          ends

NV3_CURSOR_CHECKSUM_PARM_SIZE     equ     5 * 4



;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7      
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )


IMAGE_MONO_FROM_CPU_MONODATA_0      equ    ( (2*8192) + 400h )
IMAGE_MONO_FROM_CPU_MONODATA_1      equ    ( (2*8192) + 404h )
IMAGE_MONO_FROM_CPU_MONODATA_2      equ    ( (2*8192) + 408h )
IMAGE_MONO_FROM_CPU_MONODATA_3      equ    ( (2*8192) + 40ch )
IMAGE_MONO_FROM_CPU_MONODATA_4      equ    ( (2*8192) + 410h )
IMAGE_MONO_FROM_CPU_MONODATA_5      equ    ( (2*8192) + 414h )
IMAGE_MONO_FROM_CPU_MONODATA_6      equ    ( (2*8192) + 418h )
IMAGE_MONO_FROM_CPU_MONODATA_7      equ    ( (2*8192) + 41ch )
IMAGE_MONO_FROM_CPU_MONODATA_8      equ    ( (2*8192) + 420h )
IMAGE_MONO_FROM_CPU_MONODATA_9      equ    ( (2*8192) + 424h )
IMAGE_MONO_FROM_CPU_MONODATA_10     equ    ( (2*8192) + 428h )
IMAGE_MONO_FROM_CPU_MONODATA_11     equ    ( (2*8192) + 42ch )
IMAGE_MONO_FROM_CPU_MONODATA_12     equ    ( (2*8192) + 430h )
IMAGE_MONO_FROM_CPU_MONODATA_13     equ    ( (2*8192) + 434h )
IMAGE_MONO_FROM_CPU_MONODATA_14     equ    ( (2*8192) + 438h )
IMAGE_MONO_FROM_CPU_MONODATA_15     equ    ( (2*8192) + 43ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3LoadCursorData@8
        
NV3LoadCursorData@8 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   eax = Current 16bpp pel
        ;   edx = BitMask
        ;   ebx = Current dword from AND mask
        ;   ecx = Current dword from MONO mask
        ;   esi = Ptr to Source Image data
        ;   ebp = Ptr to Mono Image data        
        ;   edi = Ptr to Destination Data
        ;**********************************************************************
    
        mov     esi,[esp].NV3LCD_SrcPtr             ; Ptr to AND mask
        mov     ebp,esi                             ; Get ptr to MONO mask
        add     ebp,128                             ;  (128 bytes from beginning)
        mov     edi,[esp].NV3LCD_DestPtr            ; Ptr to current destination

        ;**********************************************************************
        ; 
        ; For Each row
        ;   For Each Dword
        ;      For Each Bit   
        ;        Store 16bpp pel corresponding to the bits in
        ;        the AND mask and MONO mask
        ;
        ;**********************************************************************

NV3LCD_Init_Variables:

        mov     [esp].NV3LCD_Row_Count,32           ; We'll be parsing 32 rows
        xor     edx,edx

NV3LCD_Get_Next_Dword:
        mov     [esp].NV3LCD_Byte_Count,4           ; 8 pels (4 inner loops) per byte
        mov     ebx,[esi]                           ; Get 1st dword of AND mask data
        mov     ecx,[ebp]                           ; Get 1st dword of MONO mask data
        
        ;**********************************************************************
        ; Load 16bpp pels - uses tables to convert ones to 7fffh and zeros to 0
        ; Also uses table to add transparency bit from AND mask. Zero in AND mask
        ; converts to 8000h, 1 to zero.
        ;**********************************************************************
                
NV3LCD_Get_Next_Byte:

        rol     cl,2                                ; first 2 pels
        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]
        
        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        
        shr     ebx,8                               ; next byte of AND mask
        shr     ecx,8                               ; next byte of MONO mask
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        dec     [esp].NV3LCD_Byte_Count             ; Continue with next 2 pels
        jnz     NV3LCD_Get_Next_Byte                ; Continue parsing this byte

        ;**********************************************************************
        ; We need to get the next dwords for the masks
        ;**********************************************************************

NV3LCD_Check_Next_Dword:

        add     esi,4                               ; Next AND mask dword
        add     ebp,4                               ; Next MONO mask dword

        ;**********************************************************************
        ; We've read 1 row (1 dword's worth of source data)   
        ;**********************************************************************

NV3LCD_Check_Row_Count:

        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3LCD_Get_Next_Dword               ; Continue parsing the bits

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3LCD_Done:

        add     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     8

NV3LoadCursorData@8 endp


;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3Load16x16CursorData@8
        
NV3Load16x16CursorData@8 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   eax = Current 16bpp pel
        ;   edx = BitMask
        ;   ebx = Current dword from AND mask
        ;   ecx = Current dword from MONO mask
        ;   esi = Ptr to Source Image data
        ;   ebp = Ptr to Mono Image data        
        ;   edi = Ptr to Destination Data
        ;**********************************************************************
    
        mov     esi,[esp].NV3LCD_SrcPtr             ; Ptr to AND mask
        mov     ebp,esi                             ; Get ptr to MONO mask
        add     ebp,64                              ;  (64 bytes from beginning)
        mov     edi,[esp].NV3LCD_DestPtr            ; Ptr to current destination

        ;**********************************************************************
        ; 
        ; For Each row
        ;   For Each Dword
        ;      For Each Bit   
        ;        Store 16bpp pel corresponding to the bits in
        ;        the AND mask and MONO mask
        ;
        ;**********************************************************************

NV3_16x16_LCD_Init_Variables:

        mov     [esp].NV3LCD_Row_Count,16           ; We'll be parsing 16 rows
        xor     edx,edx

NV3_16x16_LCD_Get_Next_Dword:
        mov     [esp].NV3LCD_Byte_Count,2           ; 4 pels (4 inner loops) per byte
        mov     ebx,[esi]                           ; Get 1st word of AND mask data
        mov     ecx,[ebp]                           ; Get 1st word of MONO mask data
        
        ;**********************************************************************
        ; Load 16bpp pels - uses tables to convert ones to 7fffh and zeros to 0
        ; Also uses table to add transparency bit from AND mask. Zero in AND mask
        ; converts to 8000h, 1 to zero.
        ;**********************************************************************
                
NV3_16x16_LCD_Get_Next_Byte:

        rol     cl,2                                ; first 2 pels
        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]
        
        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        
        shr     ebx,8                               ; next byte of AND mask
        shr     ecx,8                               ; next byte of MONO mask
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        dec     [esp].NV3LCD_Byte_Count             ; Continue with next 2 pels
        jnz     NV3_16x16_LCD_Get_Next_Byte         ; Continue parsing this byte

        ;**********************************************************************
        ; Blank out remaining 'width' portion of 32x32 cursor  (clear 16 pels)
        ;**********************************************************************

        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        
        ;**********************************************************************
        ; We need to get the next words for the masks
        ;**********************************************************************

NV3_16x16_LCD_Check_Next_Dword:

        add     esi,4                               ; Next AND mask word
        add     ebp,4                               ; Next MONO mask word

        ;**********************************************************************
        ; We've read 1 row (1 dword's worth of source data)   
        ;**********************************************************************

NV3_16x16_LCD_Check_Row_Count:

        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3_16x16_LCD_Get_Next_Dword        ; Continue parsing the bits

        ;**********************************************************************
        ; Blank out remaining 'height' portion of 32x32 cursor (clear out 16 lines * 32 pels = 512 pels = 256 dwords)
        ;**********************************************************************

        mov     [esp].NV3LCD_Row_Count,256           
NV3_16x16_Continue_Clearing:
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3_16x16_Continue_Clearing         ; Continue clearing out cursor


        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3_16x16_LCD_Done:

        add     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     8

NV3Load16x16CursorData@8 endp



;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3CursorChecksum@4
        
NV3CursorChecksum@4 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    esi
        push    ebp
        push    ebx
        
        sub     esp,(size NV3_CURSOR_CHECKSUM_STRUC) - NV3_CURSOR_CHECKSUM_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   esi = Ptr to Source Image data
        ;   ecx = number of dwords
        ;   eax = top checksum
        ;   ebx = bottom checksum
        ;
        ; NOTE: Calculating a simplified checksum for the entire image
        ;       is NOT sufficient, because we get the same checksum value
        ;       if 2 images are horizontal mirror images of each other.
        ;       To avoid this case, we calculate a checksum for the top
        ;       and bottom half. If they are the same, then we need to
        ;       return a flag value that we can't distinguish this particular
        ;       image (i.e. we'll reload the cursor image completely)
        ;**********************************************************************
    
        mov     esi,[esp].NV3CHK_SrcPtr             ; Ptr to cursor masks
        xor     eax,eax                             ; Clear top checksum value
        xor     ebx,ebx                             ; Clear bottom checksum value

        ;**********************************************************************
        ; Calculate checksum for 1st half of AND mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Top half of mask 
NV3CHK_CheckSumLoop1:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop1          ; Parse dwords at a time

        ;**********************************************************************
        ; Calculate checksum for 2nd half of AND mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Bottom half of mask 
NV3CHK_CheckSumLoop2:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop2          ; Parse dwords at a time
        

        ;**********************************************************************
        ; Calculate checksum for 1st half of MONO mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Top half of mask 
NV3CHK_CheckSumLoop3:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop3          ; Parse dwords at a time
        

        ;**********************************************************************
        ; Calculate checksum for 2nd half of MONO mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Bottom half of mask 
NV3CHK_CheckSumLoop4:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop4          ; Parse dwords at a time
        
        ;**********************************************************************
        ; Check if we've got a mirror image.
        ; If so, then we return a flag value telling the calle to 
        ; reload the cursor image
        ;**********************************************************************

        cmp     eax,ebx                             ; Mirror image?
        jne     short NV3CHK_Done                   ; N: Just return
        mov     eax, 12345678h                      ; Return a flag value
                
        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3CHK_Done:

        add     esp,(size NV3_CURSOR_CHECKSUM_STRUC) - NV3_CURSOR_CHECKSUM_PARM_SIZE

        pop     ebx
        pop     ebp
        pop     esi

        ret     4

NV3CursorChecksum@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolstoolbox.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolstoolbox.c
//
// Toolbox with helper functions
//
// FNicklisch 09/14/2000: New, derived from toolbox.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "excpt.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "wkselsatoolsdebug.h"

// export header file
#include "wkselsatoolstoolbox.h"

// for shared memory issues we need some page aligned memory tiles
// to describe these, use the ALIGN_DESC struct AND the corresponding
// bAllocMemPageAligned and bFreeMemPageAligned routines in toolbox.c

// struct to describe an aligned pointer

typedef struct _ALIGN_DESC
{
  ULONG ulMagic;
  ULONG ulSizeTotal;          // size of the total allocated size
  ULONG ulSizeAligned;        // size of the aligned potrion of the mem chunk
  PVOID pvAligned;            // has to be the 2nd last element
  PVOID pvAnchor;             // has to be the last element
}
ALIGN_DESC;

//******************************Public*Data*********************************\
// MIX translation table
//
// Translates a mix 1-16, into an old style Rop 0-255.
//
//**************************************************************************/
// 220998 MSchwarz moved it here
BYTE ajMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = ajMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = ajMix[mix & 0xFF]
};

#if 0 // FNicklisch 14.09.00: unused
#ifdef _C_TOOLBOX_H

// enable  c_Toolbox.c
#define THIS_IS_A_VALID_TOOLBOX_C_FILE

//
// FNicklis 29.10.98:
//
// It seems to be a little bit strange, but I want to reuse the
// same code shared with the miniport.
//
#include "c_ToolBox.c"

// disable c_Toolbox.c
#undef THIS_IS_A_VALID_TOOLBOX_C_FILE
#endif //_C_TOOLBOX_H
#endif // FNicklisch 14.09.00: unused

#ifdef DBG
LONG lDbgAllocCount=0;
#endif

/*
** bAllocMem
** bFreeMem
**
** Wrapper functions to allocate and free memory where NTDDK.h 
** cannot be included
**
** Needs a pointer to a pointer to the buffer to be allocated, in both cases
**
** return: TRUE  success
**         FALSE error, bjBuffer isn't touched! Don't check for NULL then!
**
** Usage:
**   ...
**   BYTE *pjBuffer;
**
**   if ( !bAllocMem(&pjBuffer, ulSize) )
**   {
**     //  error: malloc failed!
**   }
**   else
**   {
**     // alloc succeded, do the work
**     ...
**     // free buffer again
**     bFreeMem(&pjBuffer);
**   }
**
** FNicklis 23.10.98: New
*/
// Own version!

BOOL bAllocMem(PVOID *ppBuffer, ULONG nByte, ULONG ulTag)
{
  BOOL  bRet = TRUE;
  PVOID pTemp;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bAllocMem);

  ASSERTDD(NULL!=ppBuffer,  "you should not call this function with invalid pointer!");
  ASSERTDD(0!=nByte,        "you should not call this function if you don't need memory!");
  ASSERTDD(0!=ulTag,        "please give me a valid ulTag, or ALLOC_TAG as default!");

  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppBuffer:0x%x, nByte:%d, ulTag:0x%x",*ppBuffer,nByte,ulTag));

  pTemp = EngAllocMem(FL_ZERO_MEMORY, nByte, ulTag);

  // on error don't touch input value
  if (NULL==pTemp)
  {
    DBG_ERROR("EngAllocMem failed");
    DISPDBG((DBG_LVL_ERROR, "  didn't get %d byte, ulTag:0x%x",nByte, ulTag));
    bRet = FALSE;
    goto Exit;
  }

  #ifdef DBG
  ASSERTDD(0==((ULONG_PTR)pTemp & 3), "We need a DWORD aligned pointer!");
  lDbgAllocCount++;
  #endif

  // here is your buffer
  *ppBuffer = pTemp;

Exit:
  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " (*ppBuffer:0x%x)",*ppBuffer));
  return TRUE;
}

#ifdef DBG
BOOL bFreeMem(PVOID *ppBuffer, ULONG nDebugOnlyByteToClear)
#else
BOOL _bFreeMem(PVOID *ppBuffer)
#endif
{
  BOOL bRet=TRUE;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bFreeMem);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppBuffer:0x%x, nDebugOnlyByteToClear:%d",*ppBuffer, nDebugOnlyByteToClear));

  ASSERTDD(NULL!=ppBuffer,  "you should not call this function with invalid pointer!");
  ASSERTDD(NULL!=*ppBuffer, "you should not call this function without alloctated memory!");

#ifdef DBG
  if (nDebugOnlyByteToClear)
  {
    memset(*ppBuffer, 0xCD, nDebugOnlyByteToClear);
    //RtlZeroMemory(*ppBuffer, nByteToClear);
    lDbgAllocCount--;
  }
  ASSERTDD(lDbgAllocCount>=0, "freed mored memory than allocated");
#endif

  // free and invalidate buffer
  EngFreeMem(*ppBuffer);
  *ppBuffer = NULL;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " (*ppBuffer:0x%x)",*ppBuffer));
  return (bRet);
}


/*
**  bAllocMemPageAligned allocates memory that begins at the start of a page 
**
**  ALIGN_DESC is the describer sturct
**  What it does:
**  - places a memory ALIGN_DESC in the gap between the aligned pointer and
**    the start of allocated memory
**  - to ensure that there is enough space to hold ALIGN_DESC it adds the size of 
**    ALIGN_DESC to the size of memory to allocate
**  - it adds one more mem page to the size to allocate cause at least W2K
**    never gives us page aligned memory and we have to use the succeeding page
**  - it allocates the chunk of memory (to get the anchor pointer)
**  - it increments this (anchor) by the size of ALIGN_DESC
**    and rounds the resulting pointer up to the begin of the next page (so we ensure that
**    there will be enough space for ALIGN_DESC) and get the aligned pointer (the result)
**  - it places the ALIGN_DESC directly before the alinged pointer so that we can
**    access it just by subtracting sizeof(ALIGN_DESC) from the align pointer
**  - it fills the ALIGN_DESC with a magic, the anchor and aligned pointer
**    and the total and aligned size
**  - it returns only the align pointer !!!
**
**  Author: Dietmar Bouge' @ ELSA AG 
**  Date  : 12.08.1999
*/

#if 0 // ELSA-FNicklis 04.07.00: unused
BOOL bAllocMemPageAligned(IN OUT PVOID     *ppvAlign, 
                          IN     ULONG      ulSize,   // size to allocate
                          IN     ULONG      ulTag)    // memory tag
{
  BOOL  bRet = TRUE;
  ALIGN_DESC *pAlignDesc;
  ULONG ulSizeTotal;
  BYTE  *pjAnchor;      // prefere BYTE type for arithmetic
  BYTE  *pjAligned;     // prefere BYTE type for arithmetic

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bAllocMemPageAligned);
  ASSERTDD(ppvAlign != NULL, "");
  ASSERTDD(ulSize > 0, "");

  // space for the memory and our admin struct
  ulSizeTotal   = ROUND_TO_PAGES(ulSize + sizeof(ALIGN_DESC));

  // NOTE: on W2K after Beta 3 EngAllocMem returns pointers starting
  //       with an offset of 0x10, so we don't get page aligned memory
  //       just by allocating more than a page!!!
  // 
  ulSizeTotal   += PAGE_SIZE;

  pjAnchor    = (BYTE *)EngAllocMem(FL_ZERO_MEMORY, ulSizeTotal, ulTag);

  // calculate the closest possible pjAligned
  pjAligned   = pjAnchor + sizeof(ALIGN_DESC);

  // advance to next page aligned spot
  pjAligned   = (BYTE *)ROUND_TO_PAGES(pjAligned);

  // calc pAlignPtr so that pAlignPtr->pvAnchor is to be found directly before pjAligned 
  // -> &pAlignPtr->pvAnchor == (pjAligned - sizeof(PVOID))
  pAlignDesc  = (ALIGN_DESC *)(pjAligned - sizeof(ALIGN_DESC));
  ASSERTDD( (VOID *)(pjAligned - sizeof(PVOID)) == &pAlignDesc->pvAnchor, "");
  ASSERTDD((BYTE *)pAlignDesc >= pjAnchor, "");

  // FNicklis IA-64: Use macro for page size
  ASSERT(0 == (PtrToUlong(pjAligned) & PAGE_MASK));

  // on error don't touch input value
  if (NULL == pjAnchor)
  {
    DBG_ERROR("bAllocMemPageAligned failed");
    DISPDBG((DBG_LVL_ERROR, "  didn't get %d bytes, ulTag:0x%x",ulSize, ulTag));
    bRet = FALSE;
  }
  else
  {
#ifdef DBG
    lDbgAllocCount++;
#endif
    pAlignDesc->ulMagic        = 'ELSA';
    pAlignDesc->pvAnchor       = pjAnchor;
    pAlignDesc->pvAligned      = pjAligned;
    pAlignDesc->ulSizeTotal    = ulSizeTotal;
    pAlignDesc->ulSizeAligned  = ulSize;
  }
  *ppvAlign = pjAligned;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppvAlign:0x%x",*ppvAlign));
  return bRet;
}


/*
** bFreeMemPageAligned frees page aligned memory chunks
**
**  ALIGN_DESC is the describer sturct
**  What it does:
**  - in debug builds it checks whether this pointer is valid by checking the alignment
**  - it decrements the incoming pointer by size of  ALIGN_DEST to get a pointer to the
**    ALIGN_DEST
**  - in debug builds it zeros the whole chunk of mem to avoid later use of invalid data
**  - it frees the memory using the anchor
**  - it zeros the incoming pointer
**
**  Author: Dietmar Bouge' @ ELSA AG 
**  Date  : 12.08.1999
*/ 
BOOL bFreeMemPageAligned(IN OUT PVOID     *ppvAlign) 
{
  BOOL  bRet = TRUE;
  ALIGN_DESC *pAlignDesc;
  BYTE *pjAnchor;
  ULONG ulSizeTotal;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bFreeMemPageAligned);
  ASSERTDD(ppvAlign != NULL, "");

  // incoming pointers have to be page aligned here
  // FNicklis IA-64: Use macro for page size
  ASSERT(0 == (PtrToUlong((BYTE *)(*ppvAlign)) & PAGE_MASK));

  pAlignDesc = (ALIGN_DESC *)(((BYTE *)(*ppvAlign)) - sizeof(ALIGN_DESC));
  ASSERTDD(pAlignDesc->ulMagic == 'ELSA', "");
  ASSERTDD(pAlignDesc->pvAligned == (*ppvAlign), "");

  pjAnchor = (BYTE *)(pAlignDesc->pvAnchor);
  ulSizeTotal = pAlignDesc->ulSizeTotal;


#ifdef DBG
  // zero out struct to avoid use of invalid data
  RtlZeroMemory(pjAnchor, ulSizeTotal);
#endif

  EngFreeMem(pjAnchor);

  // zero out struct to avoid use of invalid data
  *ppvAlign = NULL;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppvAlign:0x%x",*ppvAlign));
  return bRet;
}
#endif // ELSA-FNicklis 04.07.00: unused



//
// CSchalle 30.10.98: helper routine - (disassembled NT 4.0 user mode function)
//
#if !i386 || _WIN32_WINNT >= 0x0500
typedef HANDLE (*P_PS_GET_CURRENT_PROCESS_ID)(void);
#endif

#pragma warning(disable: 4035)  // no return value
DWORD GetCurrentProcessID(VOID)
{
  #if i386 && _WIN32_WINNT >= 0x0400
  __asm
  {
    mov eax, fs:[0x18]
    mov eax, [eax + 0x20] // return value in eax
  }
  #else
  HANDLE hPID = NULL;
  HANDLE hDLL;

  hDLL = EngLoadImage(L"NTOSKRNL.EXE");
  if (hDLL)
  {
    P_PS_GET_CURRENT_PROCESS_ID pfPsGetCurrentProcessId;

    pfPsGetCurrentProcessId = (P_PS_GET_CURRENT_PROCESS_ID)EngFindImageProcAddress(hDLL, "PsGetCurrentProcessId");
    if (pfPsGetCurrentProcessId)
    {
      // does NOT work in FREE mode
      hPID = pfPsGetCurrentProcessId();
    }
    EngUnloadImage(hDLL);
  }
  return (DWORD)hPID;
  #endif

}
#pragma warning(default: 4035)  // no return value


/*
** szGetApplicationName
**
** Returns the name of the current process calling the driver
** or NULL, if not available.
** For now only in Debug mode, only on NT 4.0, only on I386
**
** 160797 KGysbers, FNicklis
*/
CHAR *szGetApplicationName(VOID)
{
  CHAR *szRet="unknown"; // default error exit

#if defined (i386)

  // Ask KGysbers for more information about the following asm code
  __asm 
  {
    mov eax,fs:[124h]
    mov eax,[eax+44h]
    add eax,1dch
    mov szRet,eax
  }

  __try 
  { // to read each byte of the string
    CHAR cDummy;
    CHAR *szHlp = szRet; // Don't destroy the original pointer

    while (*szHlp) 
    {
      cDummy = *szHlp++; // Access all bytes until we find a EOS
    }
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    // We failed, be sure there is a save exit
    DISPDBG((DBG_LVL_ERROR, "ERROR in szGetApplicationName: Exception failed with: %s",szDbg_GetExceptionCode(GetExceptionCode()) ));
    
    szRet="unknown"; // default error exit
  } 
#else
  // FNicklis IA-64: Cannot use IA-32 assembler on IA-64
  // FNicklis IA-64: ToDo - portation not complete!
  #pragma message ("  FNicklis IA-64: ToDo: szGetApplicationName "__FILE__)
  DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: szGetApplicationName %s %d",__FILE__,__LINE__));
#endif // (i386)

  // make sure, that we return a vailid pointer here!
  ASSERT(NULL!=szRet);
  ASSERT(strlen(szRet)<MAX_PATH);

  return szRet;
} // szGetApplicationName


#if 0 // FNicklisch 14.09.00: unused
ULONG ulLog2(ULONG ulValue)
{
  #if defined (i386)
    __asm 
    {
      mov ecx, [ulValue]
      bsf eax, ecx
    }
  #else
    int d = 1, iter = -1;
    do 
    {
      d *= 2;
      iter++;
    } 
    while (d <= ulValue);
    return iter;
  #endif
  // return value in eax
}
#endif // FNicklisch 14.09.00: unused

/*
** STRING FUNCTIONS
**
** The following routines are an extension or an alternate 
** inteface to the runtime library functions (Rtl*) to handle
** string, here at first of type UNICODE_STRING.
** 
** The name of each function is build using the scheme (without the blanks):
**
** E_ DestType Function [SrcType]
**
** with
** 
** DestTypes/SrcTypes:
**  UStr - UNICODE_STRING, each character of size WCHAR
**  WStr - WSTR, zero terminated string, each character of size WCHAR
**  AStr - ANSI_STRING same as STRING, each character of size CHAR
**  Str  - STR, zero terminated string, each character of size CHAR
**
** Function:
**  Len      - Returns Length in bytes 
**  TrueLen  - Returns Length in bytes including trailing 0
**  Init     - Initializes the string which includes memory allocation
**  InitMulti- Initializes the string which includes memory allocation and presetting
**  Free     - Frees the allocated mem and initializes all members to 0
**  Cat      - Concatenates a string and someting else (String, value...)
**
** All with strings handled here are delimited wihtin here with the 
** trailing zero.
**
** FN 21.01.97 New
*/

// Len returnes lenght in bytes (not including trailing zero)

ULONG ulStrLen(IN PSTR pString)
{
  PCHAR pTemp=pString;
  
  if (pTemp)
    while (*pTemp) 
      pTemp++;

  // FNicklis IA-64: Usage of 32 bit is save here
  return ((ULONG)(pTemp-pString));
}

ULONG ulWStrLen(IN PWSTR pString)
{
  PWCHAR pTemp=pString;
  
  if (pTemp)
    while (*pTemp) 
      pTemp++;

  // FNicklis IA-64: Usage of 32 bit is save here
  return ((ULONG)(pTemp-pString));
}

// TrueLen returnes lenght in bytes used by characters and trailing zero

ULONG ulStrTrueLen(IN PSTR pString)
{
  ULONG ulRet=ulStrLen(pString);

  if(ulRet)
    return (ulRet+1);
  else
    return (0);
}

ULONG ulWStrTrueLen(IN PWSTR pString)
{
  ULONG ulRet=ulWStrLen(pString);

  if(ulRet)
    return (ulRet+1);
  else
    return (0);
}


PSTR szStrCpy(OUT PSTR szTrg, IN const PSTR szSrc)
{
  RtlMoveMemory(szTrg, szSrc, ulStrTrueLen(szSrc)*sizeof(CHAR));
  return (szTrg);
}

PSTR szStrCat(OUT PSTR szTrg, IN const PSTR szSrc)
{
  return (szStrCpy(szTrg+ulStrLen(szTrg), szSrc));
}

PSTR szStrCpyWStr (OUT PSTR szTrg, IN const PWSTR wszSrc)
{
  PSTR  szRet  = szTrg;

  ASSERTDD(NULL != szTrg, "szStrCpyWStr");
  ASSERTDD(NULL != wszSrc,"szStrCpyWStr");

  if (szTrg && wszSrc) 
  {
    PWSTR wszRun = (PWSTR)wszSrc;
    while (*wszRun) 
    {
      *szTrg++ = (CHAR)(*wszRun++ & 0xff);
      ASSERTDD((szTrg-szRet)<2000, "running out of assumed limit of 2000 chars");
    }
    *szTrg = 0;
  }
  
  return szRet;
}

PSTR szStrCatWStr (OUT PSTR szTrg, IN const PWSTR wszSrc)
{
  return (szStrCpyWStr(szTrg+ulStrLen(szTrg), wszSrc));
}


PWSTR wszWStrCpy    (OUT PWSTR wszTrg, IN const PWSTR wszSrc)
{
  RtlMoveMemory(wszTrg, wszSrc, ulWStrTrueLen(wszSrc)*sizeof(WCHAR));
  return (wszTrg);
}

PWSTR wszWStrCat    (OUT PWSTR wszTrg, IN const PWSTR wszSrc)
{
  return (wszWStrCpy(wszTrg+ulWStrLen(wszTrg), wszSrc));
}

PWSTR wszWStrCpyStr (OUT PWSTR wszTrg, IN const PSTR  szSrc)
{
  PWSTR wszRet = wszTrg;

  ASSERTDD(NULL != wszTrg,"wszWStrCpyStr");
  ASSERTDD(NULL != szSrc,"wszWStrCpyStr");

  if (wszTrg && szSrc) 
  {
    PSTR szRun = (PSTR)szSrc;
    while (*szRun) 
    {
      *wszTrg++ = (WCHAR)(*szRun++ & 0xff);
      ASSERTDD((wszTrg-wszRet)<2000, "running out of assumed limit of 2000 chars");
    }
    *wszTrg = 0;
  }
  
  return wszRet;
}

PWSTR wszWStrCatStr(OUT PWSTR wszTrg, IN const PSTR  szSrc)
{
  return (wszWStrCpyStr(wszTrg+ulWStrLen(wszTrg), szSrc));
}

#if DBG
#ifndef BOOL
#define BOOL int
#endif

VOID vDbg_Check_c_ToolBox(VOID)
{
  static BOOL bFirstRun=TRUE;

  if (bFirstRun)
  {
    CHAR   sz[30];
    USHORT wsz[30];
    USHORT wsz2[30];
    
    bFirstRun=FALSE;

    // CHAR

    // staring with "012" == 3 chars
    szStrCpy(sz, "012");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='\0', "szStrCpy not working");
    ASSERTDD(ulStrLen(sz)==3,     "ulStrLen not working");
    ASSERTDD(ulStrTrueLen(sz)==4, "ulStrTrueLen not working");

    // adding "345" -> "012345" == 6 chars
    szStrCat(sz, "345");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='3' && sz[4]=='4' && sz[5]=='5' && sz[6]=='\0', "szStrCat not working");
    ASSERTDD(ulStrLen(sz)==6,     "ulStrLen after szStrCat not working");

    // WCHAR
    // staring with "ABC" == 3 chars
    wszWStrCpy(wsz, (const PWSTR)L"ABC");
    ASSERTDD(wsz[0]=='A' && wsz[1]=='B' && wsz[2]=='C' && wsz[3]=='\0', "wszWStrCpy not working");
    ASSERTDD(ulWStrLen(wsz)==3,     "ulWStrLen not working");
    ASSERTDD(ulWStrTrueLen(wsz)==4, "ulWStrTrueLen not working");

    // adding "DEF" -> "ABCDEF" == 6 chars
    wszWStrCat(wsz, (const PWSTR)L"DEF");
    ASSERTDD(wsz[0]=='A' && wsz[1]=='B' && wsz[2]=='C' && wsz[3]=='D' && wsz[4]=='E' && wsz[5]=='F' && wsz[6]=='\0', "wszWStrCat not working");
    ASSERTDD(ulWStrLen(wsz)==6,     "ulWStrLen after wszWStrCat not working");

    wszWStrCpy(wsz2, wsz);

    // WCHAR -> CHAR

    // staring with L"012" == 3 chars
    szStrCpyWStr(sz, (const PWSTR)L"012");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='\0', "szStrCpyWStr not working");
    ASSERTDD(ulStrLen(sz)==3,     "ulStrLen after szStrCpyWStr not working");
    ASSERTDD(ulStrTrueLen(sz)==4, "ulStrTrueLen after szStrCpyWStr not working");

    // adding L"345" -> "012345" == 6 chars
    szStrCatWStr(sz, (const PWSTR)L"345");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='3' && sz[4]=='4' && sz[5]=='5' && sz[6]=='\0', "szStrCatWStr not working");
    ASSERTDD(ulStrLen(sz)==6,     "ulStrLen after szStrCatWStr not working");

    // CHAR -> WCHAR
    // staring with "ABC" == 3 chars
    wszWStrCpyStr(wsz, "abc");
    ASSERTDD(wsz[0]=='a' && wsz[1]=='b' && wsz[2]=='c' && wsz[3]=='\0', "wszWStrCpyStr not working");
    ASSERTDD(ulWStrLen(wsz)==3,     "ulWStrLen after wszWStrCpyStr not working");
    ASSERTDD(ulWStrTrueLen(wsz)==4, "ulWStrTrueLen after wszWStrCpyStr not working");

    // adding "def" -> "abcdef" == 6 chars
    wszWStrCatStr(wsz, "def");
    ASSERTDD(wsz[0]=='a' && wsz[1]=='b' && wsz[2]=='c' && wsz[3]=='d' && wsz[4]=='e' && wsz[5]=='f' && wsz[6]=='\0', "wszWStrCatStr not working");
    ASSERTDD(ulWStrLen(wsz)==6,     "ulWStrLen after wszWStrCatStr not working");

    // WCHAR -> CHAR
    // adding L"abcdef" to "012345" -> "012345abcdef"
    szStrCatWStr(sz, wsz);
    ASSERTDD(ulStrLen(sz)==12,      "ulStrLen not working, final test");

    // WCHAR -> CHAR
    // adding "012345abcdef" to l"abcdef" -> l"abcdef012345abcdef"
    wszWStrCatStr(wsz, sz);
    ASSERTDD(ulWStrLen(wsz)==18,         "ulWStrLen not working, final test");
    ASSERTDD(ulWStrTrueLen(wsz)==19,     "ulWStrTrueLen not working, final test");

    ASSERTDD(wsz[ 0]=='a' && wsz[ 1]=='b' && wsz[ 2]=='c' && wsz[ 3]=='d' && wsz[ 4]=='e' && wsz[ 5]=='f', "wszWStrCatStr not working");
    ASSERTDD(wsz[ 6]=='0' && wsz[ 7]=='1' && wsz[ 8]=='2' && wsz[ 9]=='3' && wsz[10]=='4' && wsz[11]=='5', "wszWStrCatStr not working");
    ASSERTDD(wsz[12]=='a' && wsz[13]=='b' && wsz[14]=='c' && wsz[15]=='d' && wsz[16]=='e' && wsz[17]=='f', "wszWStrCatStr not working");

  }
}
#endif


#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolstoolbox.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv1blit.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV1BLIT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated Blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;
;  stack based params and local variables
;

NV1_TRANSFER_BLITDATA_STRUC          struc

; Feel free to add any local variables here:

NV1TBDS_RightCase            dd      ?
NV1TBDS_pjSrcScan            dd      ?
NV1TBDS_SrcIntStep           dd      ?
NV1TBDS_DstStride            dd      ?
NV1TBDS_XCount               dd      ?
NV1TBDS_yDst                 dd      ?
NV1TBDS_pdev                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV1TBDS_ebp                  dd      ?
NV1TBDS_esi                  dd      ?
NV1TBDS_edi                  dd      ?
NV1TBDS_ebx                  dd      ?
NV1TBDS_RetAddr              dd      ?
NV1TBDS_BytesPerDstScan      dd      ?
NV1TBDS_FreeCountPtr         dd      ?
NV1TBDS_Height               dd      ?
NV1TBDS_NextScanPtr          dd      ?
NV1TBDS_ScanInc              dd      ?
NV1TBDS_NvChannelPtr         dd      ?

NV1_TRANSFER_BLITDATA_STRUC          ends

NV1_TRANSFER_BLITDATA_PARM_SIZE     equ     11 * 4

;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )


IMAGE_FROM_CPU_DATA_0      equ    ( (0*8192) + 400h )
IMAGE_FROM_CPU_DATA_1      equ    ( (0*8192) + 404h )
IMAGE_FROM_CPU_DATA_2      equ    ( (0*8192) + 408h )
IMAGE_FROM_CPU_DATA_3      equ    ( (0*8192) + 40ch )
IMAGE_FROM_CPU_DATA_4      equ    ( (0*8192) + 410h )
IMAGE_FROM_CPU_DATA_5      equ    ( (0*8192) + 414h )
IMAGE_FROM_CPU_DATA_6      equ    ( (0*8192) + 418h )
IMAGE_FROM_CPU_DATA_7      equ    ( (0*8192) + 41ch )
IMAGE_FROM_CPU_DATA_8      equ    ( (0*8192) + 420h )
IMAGE_FROM_CPU_DATA_9      equ    ( (0*8192) + 424h )
IMAGE_FROM_CPU_DATA_10     equ    ( (0*8192) + 428h )
IMAGE_FROM_CPU_DATA_11     equ    ( (0*8192) + 42ch )
IMAGE_FROM_CPU_DATA_12     equ    ( (0*8192) + 430h )
IMAGE_FROM_CPU_DATA_13     equ    ( (0*8192) + 434h )
IMAGE_FROM_CPU_DATA_14     equ    ( (0*8192) + 438h )
IMAGE_FROM_CPU_DATA_15     equ    ( (0*8192) + 43ch )
IMAGE_FROM_CPU_DATA_16     equ    ( (0*8192) + 440h )
IMAGE_FROM_CPU_DATA_17     equ    ( (0*8192) + 444h )
IMAGE_FROM_CPU_DATA_18     equ    ( (0*8192) + 448h )
IMAGE_FROM_CPU_DATA_19     equ    ( (0*8192) + 44ch )
IMAGE_FROM_CPU_DATA_20     equ    ( (0*8192) + 450h )
IMAGE_FROM_CPU_DATA_21     equ    ( (0*8192) + 454h )
IMAGE_FROM_CPU_DATA_22     equ    ( (0*8192) + 458h )
IMAGE_FROM_CPU_DATA_23     equ    ( (0*8192) + 45ch )
IMAGE_FROM_CPU_DATA_24     equ    ( (0*8192) + 460h )
IMAGE_FROM_CPU_DATA_25     equ    ( (0*8192) + 464h )
IMAGE_FROM_CPU_DATA_26     equ    ( (0*8192) + 468h )
IMAGE_FROM_CPU_DATA_27     equ    ( (0*8192) + 46ch )
IMAGE_FROM_CPU_DATA_28     equ    ( (0*8192) + 470h )
IMAGE_FROM_CPU_DATA_29     equ    ( (0*8192) + 474h )
IMAGE_FROM_CPU_DATA_30     equ    ( (0*8192) + 478h )
IMAGE_FROM_CPU_DATA_31     equ    ( (0*8192) + 47ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV1_Transfer_MemToScreen_Data@24


NV1_Transfer_MemToScreen_Data@24 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV1_TRANSFER_BLITDATA_STRUC) - NV1_TRANSFER_BLITDATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   ebp = Ptr to NV User Channel
        ;   eax = Dwords remaining in current scanline
        ;   ebx = Current scanline (reverse index)
        ;   ecx = Used by Rep Mov string copy
        ;   edx = Current Free Count
        ;   esi = Ptr to Image data
        ;   edi = Ptr to data array in user channel
        ;**********************************************************************

        mov     ebp,[esp].NV1TBDS_NvChannelPtr      ; Get pointer to NV channel
        add     ebp,IMAGE_FROM_CPU_DATA_0           ; EDI ptr to data array in user channel
        mov     ebx,[esp].NV1TBDS_Height            ; Number of scanlines to output
        mov     edx,[esp].NV1TBDS_FreeCountPtr      ; Ptr to current cached free count
        movzx   edx,word ptr [edx]                  ; Get current free count
        cld                                         ; Default to going forward

        ;**********************************************************************
        ; Make sure there are scanlines to output
        ;**********************************************************************

        cmp     ebx,0                               ; Make sure we have data to output
        jle     NV1TBD_Done                         ; Otherwise just quit

        ;**********************************************************************
        ; Main loop
        ;**********************************************************************


NV1TBD_Scanline_Loop:

        mov     esi,[esp].NV1TBDS_NextScanPtr       ; Ptr to image data
        mov     eax,[esp].NV1TBDS_BytesPerDstScan   ; Number of DWORDS per scanline

        ;**********************************************************************
        ;
        ; Output 31 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_31Dwords:

        cmp     eax,31*4                            ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_16Dwords     ;  N: Less than 31 dwords remaining

NV1TBD_31Dwords_Chk_FreeCount:

        cmp     edx,31*4                            ; Q: Enough room to output 31 dwords?
        jae     short NV1TBD_31Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_31Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_31Dwords_Chk_FreeCount ; Check if FIFO is ready yet

NV1TBD_31Dwords_UpdateFreeCount:

        sub     edx,31*4                            ; Update cached freecount

NV1TBD_31Dwords_SendData:

        mov     ecx,31                              ; 16 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 16 dwords
        sub     eax,31*4                            ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_For_31Dwords     ; Loop thru remaining data



        ;**********************************************************************
        ;
        ; Output 16 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_16Dwords:

        cmp     eax,16*4                            ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_8Dwords      ;  N: Less than 16 dwords remaining

NV1TBD_16Dwords_Chk_FreeCount:

        cmp     edx,16*4                            ; Q: Enough room to output 16 dwords?
        jae     short NV1TBD_16Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_16Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_16Dwords_Chk_FreeCount ; Check if FIFO is ready yet

NV1TBD_16Dwords_UpdateFreeCount:

        sub     edx,16*4                            ; Update cached freecount

NV1TBD_16Dwords_SendData:

        mov     ecx,16                              ; 16 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 16 dwords
        sub     eax,16*4                            ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_For_16Dwords     ; Loop thru remaining data


        ;**********************************************************************
        ;
        ; Output 8 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_8Dwords:

        cmp     eax,8*4                             ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_4Dwords      ;  N: Less than 8 dwords remaining

NV1TBD_8Dwords_Chk_FreeCount:

        cmp     edx,8*4                             ; Q: Enough room to output 8 dwords?
        jae     short NV1TBD_8Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_8Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_8Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_8Dwords_UpdateFreeCount:

        sub     edx,8*4                             ; Update cached freecount

NV1TBD_8Dwords_SendData:

        mov     ecx,8                               ; 8 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 8 dwords
        sub     eax,8*4                             ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_for_8Dwords      ; Loop thr remaining data


        ;**********************************************************************
        ;
        ; Output 4 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_4Dwords:

        cmp     eax,4*4                             ; Q: Any more Dwords to output?
        jae     short NV1TBD_4Dwords_Chk_FreeCount  ;  Y: Output remaining dwords
        jmp     short NV1TBD_Check_For_1Dwords      ;  N: Less than 4 dwords remaining

NV1TBD_4Dwords_Chk_FreeCount:

        cmp     edx,4*4                             ; Q: Enough room to output 4 dwords?
        jae     short NV1TBD_4Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_4Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_4Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_4Dwords_UpdateFreeCount:

        sub     edx,4*4                             ; Update cached freecount

NV1TBD_4Dwords_SendData:

        mov     ecx,4                               ; 4 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 4 dwords
        sub     eax,4*4                             ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_for_4Dwords      ; Loop thr remaining data

        ;**********************************************************************
        ;
        ; Output 1 Dword at a time
        ;
        ;**********************************************************************


NV1TBD_Check_For_1Dwords:

        cmp     eax,4                               ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_Pad          ;  N: Check for pad bytes

NV1TBD_1Dwords_Chk_FreeCount:

        cmp     edx,4*3                             ; Q: Assume worst case 3 dwords
        jae     short NV1TBD_1Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_1Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_1Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_1Dwords_UpdateFreeCount:
        mov     ecx,eax                             ; Get number of bytes
        shr     ecx,2                               ; div 4 = # dwords
        shl     ecx,2                               ; Convert to div4 num bytes
        sub     edx,ecx                             ; Update cached freecount, ASSUME
        sub     eax,ecx
        shr     ecx,2                               ; Back to num dwords

NV1TBD_1Dwords_SendData:

        mov     edi,ebp                             ; EDI ptr to data array in user channel
        rep     movsd                               ; Copy remaining dwords

NV1TBD_Check_For_Pad:
        or      eax,eax                             ; Any bytes left?
        jbe     NV1TBD_Advance_Scanline             ; N, go to next scan

NV1TBD_Pad_Bytes_Chk_FreeCount:

        cmp     edx,1*4                             ; Q: Assume worst case 1 dword
        jae     short NV1TBD_Pad_Bytes_UpdateFreeCount;  Y: Send the data

NV1TBD_Pad_Bytes_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_Pad_Bytes_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_Pad_Bytes_UpdateFreeCount:

        sub     edx,1*4                             ; Update cached freecount, ASSUME
                                                    ; WORST CASE 1 dword sent

NV1TBD_Pad_Bytes_SendData:

        mov     ecx,eax                             ; Finish off remaining bytes

NV1TBD_Pad_Bytes_Get_Next:
        lodsb
        dec     ecx
        or      ecx,ecx                             ; Done yet?
        jz      NV1TBD_Send_Pad_Bytes
        xchg    ah,al                               ; Save last byte
        lodsb                                       ; Get next byte
        xchg    ah,al                               ; Restore byte order
        dec     ecx
        or      ecx,ecx                             ; Done yet?
        jz      NV1TBD_Send_Pad_Bytes
        mov     cl,byte ptr [esi]
        shl     ecx,16
        or      eax,ecx                             ; EAX = pad byte(s)

NV1TBD_Send_Pad_Bytes:
        mov     edi,ebp                             ; EDI ptr to data array in user channel
        stosd                                       ; Copy pad bytes

        ;**********************************************************************
        ; Advance to next scanline
        ;**********************************************************************

NV1TBD_Advance_Scanline:

        dec     ebx                                 ; Next scanline
        jz      short NV1TBD_Done                   ; Check if we're done
        mov     eax,[esp].NV1TBDS_ScanInc           ; Get number of bytes to advance src
        shl     eax,2                               ; Convert dwords to bytes
        add     [esp].NV1TBDS_NextScanPtr,eax       ; Next src scanline
        jmp     NV1TBD_Scanline_Loop                ; Loop thru entire image

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV1TBD_Done:

        mov     eax,[esp].NV1TBDS_FreeCountPtr      ; Make sure to update
        mov     word ptr [eax],dx                   ;   cached free count

        add     esp,(size NV1_TRANSFER_BLITDATA_STRUC) - NV1_TRANSFER_BLITDATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     24

NV1_Transfer_MemToScreen_Data@24 endp



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsregistry.h ===
#ifndef _WKSELSATOOLSREGISTRY_H
#define _WKSELSATOOLSREGISTRY_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsregistry.h
//
// FNicklisch 09/14/2000: New, derived from registry.h and others...
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS
// Errorcodes returned by DrvEscape
#define REG_ERROR   -1
#define REG_OK       0
#define REG_DEFAULT  1

// copies of this structures are located in m_registry.h for the miniport side of this
// information. If values are changed, change them in m_registry.h, too

//*******************************************************************************************
// 131098 MSchwarz 
// structures to transfer data throught the EngDeviceIoControl function 
// between driver and miniport for Registry settings
// therefore 4 IOCTL_VIDEO constants are defined:
// IOCTL_VIDEO_REG_ID_TRANSFER_SET  : set value with key decoded with ID
// IOCTL_VIDEO_REG_SZ_TRANSFER_GET  : get value with key decoded with ID
// IOCTL_VIDEO_REG_ID_TRANSFER_SET  : set value with key given as String
// IOCTL_VIDEO_REG_SZ_TRANSFER_GET  : get value with key given as  String

#define MAX_STRING 260

#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union
typedef struct tagIOCTL_ID_TRANSFER
{
  ULONG dwId;                 // ELSA_ESC ID to set
  ULONG dwDataSize;           // sizeof( Data ) without sizeof( dwSize / dwType / dwId )
  ULONG dwDataType;           // Type of Data ( REG_SZ, REG_BINARY, etc )
  LONG  lReturnCode;          // REG_OK, REG_DEFAULT, (REG_ERROR) ...
  CHAR  ajData[0];            // complete Data to move
} IOCTL_ID_TRANSFER, *PIOCTL_ID_TRANSFER;


typedef struct tagIOCTL_SZ_TRANSFER
{
  CHAR  szId[MAX_STRING];     // the key in Registry to set
  ULONG dwDataSize;           // sizeof( Data ) without sizeof( dwSize / dwType / dwId )
  ULONG dwDataType;           // Type of Data ( REG_SZ, REG_BINARY, etc )
  LONG  lReturnCode;          // REG_OK, REG_DEFAULT, (REG_ERROR) ...
  CHAR  ajData[0];            // complete Data to move
} IOCTL_SZ_TRANSFER, *PIOCTL_SZ_TRANSFER;
#pragma warning(default:4200) // nonstandard extension used : zero-sized array in struct/union

//*******************************************************************************************


// driver internal registry IDs, reserved are for free temporary use!

// ********************************************************
// query/set values identifier: 
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!

#define INTERNAL_ET_VALUE_DEFAULT        0x01000000 // Use internal default instead of registry value
#define INTERNAL_ET_VALUE_unused0        0x02000000
#define INTERNAL_ET_VALUE_unused1        0x04000000
#define INTERNAL_ET_VALUE_HIDDEN_KEYS    0x08000000 // BIT to test internaly used keys

#define INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK (~(INTERNAL_ET_VALUE_DEFAULT))

// hidden and internal driver keys, used within the driver only
#define INTERNAL_ET_VALUE_DW_RESERVED0  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 0) // Reserved 0
#define INTERNAL_ET_VALUE_DW_RESERVED1  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 1) // Reserved 1
#define INTERNAL_ET_VALUE_DW_RESERVED2  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 2) // Reserved 2
#define INTERNAL_ET_VALUE_DW_RESERVED3  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 3) // Reserved 3
#define INTERNAL_ET_VALUE_DW_RESERVED4  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 4) // Reserved 4
#define INTERNAL_ET_VALUE_DW_RESERVED5  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 5) // Reserved 5
#define INTERNAL_ET_VALUE_DW_RESERVED6  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 6) // Reserved 6
#define INTERNAL_ET_VALUE_DW_RESERVED7  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 7) // Reserved 7
#define INTERNAL_ET_VALUE_DW_RESERVED8  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 8) // Reserved 8
#define INTERNAL_ET_VALUE_DW_RESERVED9  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 9) // Reserved 9

#define INTERNAL_ET_VALUE_DW_ICDRESERVED0  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 10) // ICD Reserved 0
#define INTERNAL_ET_VALUE_DW_ICDRESERVED1  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 11) // ICD Reserved 1
#define INTERNAL_ET_VALUE_DW_ICDRESERVED2  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 12) // ICD Reserved 2
#define INTERNAL_ET_VALUE_DW_ICDRESERVED3  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 13) // ICD Reserved 3
#define INTERNAL_ET_VALUE_DW_ICDRESERVED4  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 14) // ICD Reserved 4
#define INTERNAL_ET_VALUE_DW_ICDRESERVED5  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 15) // ICD Reserved 5
#define INTERNAL_ET_VALUE_DW_ICDRESERVED6  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 16) // ICD Reserved 6
#define INTERNAL_ET_VALUE_DW_ICDRESERVED7  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 17) // ICD Reserved 7
#define INTERNAL_ET_VALUE_DW_ICDRESERVED8  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 18) // ICD Reserved 8
#define INTERNAL_ET_VALUE_DW_ICDRESERVED9  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 19) // ICD Reserved 9

#define INTERNAL_ET_VALUE_DW_ERAZOR_II   ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 20)    // temporary keys used for not implemented features

// internal keys
#define INTERNAL_ET_VALUE_DW_CORE_CLOCK          ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 21)
#define INTERNAL_ET_VALUE_DW_MEMORY_CLOCK        ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 22)
#define INTERNAL_ET_VALUE_DW_MEMORY_TIMING       ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 23)
#define INTERNAL_ET_VALUE_DW_HW_STANDARDTIMINGS  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 24)
#define INTERNAL_ET_VALUE_DW_HW_SCRAMBLEMODE     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 25)
#define INTERNAL_ET_VALUE_DW_HW_SCRAMBLESETTINGS ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 26)

#define INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 27)
#define INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 28)

#define INTERNAL_ET_VALUE_DW_HELPERFLAGS              ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 29)

// Keys used by the multiboard wrapper to store WINman2 modes (Binary)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET0 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 30)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET1 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 31)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET2 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 32)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET3 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 33)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET4 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 34)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET5 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 35)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET6 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 36)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET7 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 37)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET8 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 38)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET9 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 39)

// Keys used by the single board driver to store WINman2 modes (Binary)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET0 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 40)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET1 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 41)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET2 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 42)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET3 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 43)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET4 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 44)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET5 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 45)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET6 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 46)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET7 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 47)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET8 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 48)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET9 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 49)

// tetris tiling configuration
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_TILING    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 50)
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_MODE      ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 51)
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_SHIFT     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 52)

#define INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM      ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 54)
#define INTERNAL_ET_VALUE_DW_OPENGL_FORCESOFTWARE          ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 55)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGFLAGSOVERRIDE       ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 56)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGMAXLOCALERRORCOUNT  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 57)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGTRACETOFILE         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 58)
#define INTERNAL_ET_VALUE_DW_OPENGL_USE_DISPLAYDRIVER_BUFFER ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 59)// FALSE use DirectDraw-Buffer ; TRUE: use DisplayDriverBuffer via OGLESC
#define INTERNAL_ET_VALUE_DW_HW_FORCE_TIMING               ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 60)
#define INTERNAL_ET_VALUE_DW_OPENGL_ACQUIREMUTEXFORKICKOFF ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 61)
#define INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 62)
#define INTERNAL_ET_VALUE_DW_OPENGL_CLIENTRELATIVECLIPRECTS INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS // old for compatibility only!
#define INTERNAL_ET_VALUE_DW_HW_USE_ELSA_INITCODE           ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 63)  
#define INTERNAL_ET_VALUE_DW_HW_SHUTDOWN                    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 64) // FL_SHUTDOWN_GART, ...

#define INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 65) // if set the display driver doesn't call the ICD for FLIP callbacks
#define INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP              ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 66) // Bits per pixel used for overlay
#define INTERNAL_ET_VALUE_SZ_OEM_VERSION                    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 67) // OEM build detection (e.g. for DELL drivers)
#define INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS                  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 68) // flags to punt drv functions FL_PUNT_DRVCOPYBITS,...

#define INTERNAL_ET_VALUE_DW_HW_ONDMACRASH                  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 69) // How to react on a resource manager crash dump 


LONG lEscRegistryValue(
  PPDEV    ppdev,
  ULONG    ulSubEsc, 
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut);

LONG lRegEtQueryValue(
  IN         HANDLE             hDriver, 
  IN         DWORD              dwSubEsc, 
  IN  struct tagET_QUERY_VALUE *petQueryValue,
  IN         ULONG              cjOut, 
  OUT        VOID              *pvOut);

LONG lRegEtSetValue(
  IN         HANDLE               hDriver, 
  IN         DWORD                dwSubEsc, 
  IN         VOID                *pvIn, 
  IN         ULONG                cjIn, 
  OUT struct tagET_SET_VALUE_RET *pSetValueRet);

LONG lRegEtDefaultValue(
  IN         HANDLE                   hDriver, 
  IN  struct tagET_SET_VALUE_DEFAULT *pDefaultValue, 
  OUT struct tagET_SET_VALUE_RET     *pSetValueRet);

LONG lRegGetIdBinary ( IN HANDLE hDriver, IN DWORD dwID,      OUT BYTE  *pjData,   IN DWORD nByte );
LONG lRegGetIdDWord  ( IN HANDLE hDriver, IN DWORD dwID,      OUT DWORD *pulData );
LONG lRegGetIdSz     ( IN HANDLE hDriver, IN DWORD dwID,      OUT PSTR   pstrData, IN DWORD nByte );
LONG lRegGetIdMultiSz( IN HANDLE hDriver, IN DWORD dwID,      OUT PSTR   pstrData, IN DWORD nByte );

LONG lRegSetIdBinary ( IN HANDLE hDriver, IN DWORD dwID, const IN BYTE  *pjData,   IN DWORD nByte );
LONG lRegSetIdDWord  ( IN HANDLE hDriver, IN DWORD dwID,       IN DWORD  ulData );
LONG lRegSetIdSz     ( IN HANDLE hDriver, IN DWORD dwID, const IN PSTR   pstrData);
LONG lRegSetIdMultiSz( IN HANDLE hDriver, IN DWORD dwID, const IN PSTR   pstrData, IN DWORD nByte );

#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv4blit.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV4BLIT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated Blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc                     ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;*******************************************************************************
; Dma Push version of structure
;*******************************************************************************

NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC          struc

; Feel free to add any local variables here:

DwordsNeeded                dd      ?
NextScanInc                 dd      ?
RemainingDwordsPerDstScan   dd      ?
LocalHeight                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV4DTBDS_ebp         dd      ?
NV4DTBDS_esi         dd      ?
NV4DTBDS_edi         dd      ?
NV4DTBDS_ebx         dd      ?
NV4DTBDS_RetAddr     dd      ?
passedPpdev          dd      ?
BytesPerDstScan      dd      ?
Height               dd      ?
NextScanPtr          dd      ?
ScanInc              dd      ?

NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC          ends

NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE     equ     10 * 4

        .code


extrn       NV_DmaPush_Wrap@8:NEAR
extrn       NV_DmaPush_CheckWrapped@8:NEAR
extrn       NV4_DmaPushSend@4:NEAR


;---------------------------Public-Routine------------------------------;
;
; Routine to output a memory bitmap to the screen using the DMA push
; buffer.
;
;-----------------------------------------------------------------------;

align 4

        public NV4_DmaPush_Transfer_MemToScreen_Data@20


NV4_DmaPush_Transfer_MemToScreen_Data@20 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp, (size NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC) - NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE
        mov     ebp, esp                        ; points to parameters and local vars

        cld                                     ; Default to going forward
        xor     eax, eax
        mov     ecx, [ebp].Height               ; Number of scanlines to output
        mov     ebx, [ebp].passedPpdev          ; Ptr to pdev
        or      ecx, ecx                        ; If zero scanliness
        jz      TransferDone                    ; nothing to draw
        
        mov     [ebp].LocalHeight, ecx          ; Save height parameter
        mov     esi, [ebp].ScanInc
        mov     [ebx].nvDmaCachedFreeCount, eax ; init free count to zero

        mov     edx, [ebx].nvDmaCount
        mov     edi, [ebx].nvDmaFifo            ; pointer to DMA buffer
        mov     ecx, [ebp].BytesPerDstScan      ; number of BYTES in one scanline
        shl     edx, 2                          ; offset in DMA buffer
                                                ;  to point to next scanline
        shl     esi, 2                          ; byte increment to next scanline                                                    
        add     edi, edx                        ; offset to current location
                                                ;  in DMA buffer
        mov     edx, ecx                        ; BytesPerDstScan                                                
        
        cmp     edx, MAX_INDEXED_IMAGE_DWORDS*4 ; if more bytes than hardware can handle
        jl      NormalScanlineTransfer          ; then need to adjust RemainingDwordsPerDstScan
                                                ;  value
        sub     edx, MAX_INDEXED_IMAGE_DWORDS*4 ; adjust remaining byte count

NormalScanlineTransfer:
        sub     esi, ecx                        ; number of bytes to increment
        shr     edx, 2                          ; number of whole DWORDS in
                                                ;  remaining scanline
        shr     ecx, 2                          ; number of DWORDS in scanline
        
        mov     [ebp].RemainingDwordsPerDstScan, edx ; save dwords needed in main loop
        add     ecx, 4                          ; add max overhead for DMA push cmd data

        mov     [ebp].NextScanInc, esi          ; save increment to next scanline
        mov     [ebp].DwordsNeeded, ecx         ; save max number of DWORDS needed
                                                ;  in push buffer for each scanline

;*************************************************************************
;
;   Output source bitmap to DMA push buffer.
;
;   EBX - ppdev
;   EDI - offset to current location in DMA buffer
;
;*************************************************************************

TransferBitmapLoop:

        mov     ecx, [ebp].DwordsNeeded         ; number of DWORDS in one scanline
                                                ;  with max overhead
        sub     [ebx].nvDmaCachedFreeCount, ecx ; overhead per glyph
        jg      HaveRoomForScanline             ; have enough room in DMA buffer
                                                ;   for current scanline

    ;*************************************************************************
    ;
    ; Get current free count in DMA buffer. Updates ppdev->nvDmaCachedFreeCount.
    ; This is similar to the NV_DMAPUSH_CHECKFREE C macro.
    ;
    ; NOTE: updates ppdev->nvDmaCount to equal local nvDmaCount
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ; EDI - offset to current location in DMA buffer
    ;
    ;*************************************************************************

        ;******************************************************************
        ; Kickoff buffer when not enough room in cached buffer free count
        ;******************************************************************

        mov     edx, [ebx].nvDmaChannel
        sub     edi, [ebx].nvDmaFifo            ; offset within DMA buffer
        
        shr     edi, 2                          ; convert to dwords
        mov     [ebx].nvDmaCount, edi           ; update ppdev->nvDmaCount

        push    ecx        
        push    ebx
        push    ebx
        call    NV4_DmaPushSend@4
        pop     ebx
        pop     ecx

        cmp     [ebx].nvDmaWrapFlag, FALSE      ;ppdev->nvDmaWrapFlag
        jne     short CheckDmaWrapped

    ;*************************************************************************
    ;
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

        mov     eax, [ebx].DmaPushBufTotalSize  ;
        shr     eax, 2                          ;
        sub     eax, DMAPUSH_PADDING            ;
        sub     eax, [ebx].nvDmaCount           ; less current nvDmaCount
        sub     eax, ecx                        ; less number of DWORDS needed
        jge     UpdateFreeCount                 ; have enough room in DMA buffer
        
    ;*************************************************************************
    ;
    ; Need to wrap.
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

GoWrapDmaBuffer:

        push    ecx                             ; DWORDS needed - parameter
        push    ebx                             ; ppdev - parameter
        call    NV_DmaPush_Wrap@8               ; (ppdev, DWORDS_NEEDED)
        jmp     ZeroFreeCount                   ; need to check next time

    ;*************************************************************************
    ;
    ; WRAP_FLAG = TRUE. We are currently wrapped around (DMA count < Get Ptr)
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

CheckDmaWrapped:

        push    ecx                             ; DWORDS needed - parameter
        push    ebx                             ; ppdev - parameter
        call    NV_DmaPush_CheckWrapped@8       ; (ppdev, DWORDS_NEEDED)

    ;*************************************************************************
    ;
    ; Set free count. This will be zero if we are wrapped. This way, we will
    ; force a check until buffer is not wrapped. 
    ;
    ;*************************************************************************

ZeroFreeCount:
        mov     ebx, [ebp].passedPpdev          ; reload ppdev
        xor     eax, eax                        ; set freecount to zero - will
                                                ;  force check next pass

    ;*************************************************************************
    ;
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EAX - number of free dwords in DMA push buffer
    ; EBX - ppdev
    ;
    ;*************************************************************************

UpdateFreeCount:
        mov     [ebx].nvDmaCachedFreeCount, eax
        mov     edx, [ebx].nvDmaCount
        mov     edi, [ebx].nvDmaFifo            ; pointer to DMA buffer
        shl     edx, 2                          ; offset in DMA buffer
        add     edi, edx                        ; offset to current location
                                                ;  in DMA buffer

    ;*************************************************************************
    ;
    ; Have room in DMA buffer, now output scanline.
    ;
    ; EBX - ppdev
    ; EDI - offset to current location in DMA buffer
    ;
    ;*************************************************************************

HaveRoomForScanline:

        mov     eax, [ebp].BytesPerDstScan
        mov     esi, [ebp].NextScanPtr
        
        cmp     eax, MAX_INDEXED_IMAGE_DWORDS*4 ; if more bytes than hardware can handle
        jge     TransferBigScanline             ; then output max dwords
                                                ; (jump away for performance since
                                                ;  this almost never happens and processors
                                                ;  want to fall through conditional jumps)

    ;*************************************************************************
    ;
    ; Handle remaining dwords.
    ;
    ; EAX - number of bytes in scanline to output
    ; EBX - ppdev
    ; EDI - offset to current location in DMA buffer
    ; ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************
    
TransferRemainingDwords:

        mov     edx, [ebp].RemainingDwordsPerDstScan ; rounded up dwords in scanline
        mov     ecx, edx                        ; total dwords remaining
        test    edx, edx
        jz      TransferRemainingBytes          ; no more dwords to send, check
                                                ;  whether bytes to output
                                                
        shl     ecx, 18                         ; convert bytes to #Dwords for header
        or      ecx, IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0
        mov     DWORD PTR [edi], ecx
        add     edi, 4

        mov     ecx, edx                        ; total dwords remaining
        rep     movsd
        
    ;*************************************************************************
    ;
    ;   Handle remaining bytes. Note: This is necessary because the end of the
    ;   bitmap is not always an even number of dwords from the start. Also,
    ;   the bitmap often begins at the highest scanline and progresses backwards.
    ;   For this reason, you can't just special case the last line.
    ;
    ;   EAX - number of bytes in scanline to output
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************

TransferRemainingBytes:
    
        and     eax, 3                          ; bytes leftover
        jz      NextScanline                    ; no bytes to draw, scanline finished

        mov     DWORD PTR [edi], IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0 OR (1 SHL 18)
        add     edi, 4
        
        mov     ecx, eax                        ; remaining bytes
        rep     movsb
        add     edi, 4                          ; update DMA buffer to next DWORD
        sub     edi, eax

    ;******************************************************************
    ;
    ; All data from scanline is copied to DMA push buffer. Now update
    ; NextScanPtr to point to offset of next source scanline.
    ;
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;******************************************************************

NextScanline:
        
        add     esi, [ebp].NextScanInc          ; points to next scanline
        mov     [ebp].NextScanPtr, esi          ; save update bitmap pointer
        dec     [ebp].LocalHeight               ; if more scanlines to draw
        jnz     TransferBitmapLoop              ; then draw next scanline
        
    ;******************************************************************
    ;
    ; All data from scanline is copied to DMA push buffer. 
    ; Kickoff buffer after last scanline
    ;
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;
    ;******************************************************************

        mov     esi, [ebx].nvDmaChannel
        sub     edi, [ebx].nvDmaFifo            ; offset within DMA buffer
        
        shr     edi, 2                          ; convert to dwords
        mov     [ebx].nvDmaCount, edi           ; update ppdev->nvDmaCount

        push    ebx
        call    NV4_DmaPushSend@4

TransferDone:
        
        add     esp,(size NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC) - NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     20

    ;*************************************************************************
    ;
    ;   Output the maximum amount of dwords allowed by hardware. Only need to
    ;   do this once, since no scanlines will be 2 times MAX_INDEXED_IMAGE_DWORDS
    ;
    ;   This code was moved from above loop for performance, since this rarely happens
    ;   and processors' branch prediction wants to fall through conditional jumps.
    ;
    ;   EAX - number of bytes in scanline
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************

TransferBigScanline:

        mov     DWORD PTR [edi], IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0 OR (MAX_INDEXED_IMAGE_DWORDS SHL 18)
        add     edi, 4

        mov     ecx, MAX_INDEXED_IMAGE_DWORDS
        rep     movsd
        
        sub     eax, MAX_INDEXED_IMAGE_DWORDS*4 ; number of bytes left in scanline
        jmp     TransferRemainingDwords         ; output rest of dwords in scanline

NV4_DmaPush_Transfer_MemToScreen_Data@20 endp



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv3text.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV3TEXT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated text blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;
;  stack based params and local variables
;

NV3_TRANSFER_TEXT_STRUC          struc

; Feel free to add any local variables here:

NV3TS_RightCase            dd      ?
NV3TS_pjSrcScan            dd      ?
NV3TS_SrcIntStep           dd      ?
NV3TS_DstStride            dd      ?
NV3TS_XCount               dd      ?
NV3TS_yDst                 dd      ?
NV3TS_pdev                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3TS_ebp                  dd      ?
NV3TS_esi                  dd      ?
NV3TS_edi                  dd      ?
NV3TS_ebx                  dd      ?
NV3TS_RetAddr              dd      ?
NV3TS_NumDwordsPerGlyph    dd      ?
NV3TS_FreeCountPtr         dd      ?
NV3TS_GlyphDataPtr         dd      ?
NV3TS_NvChannelPtr         dd      ?

NV3_TRANSFER_TEXT_STRUC          ends

NV3_TRANSFER_TEXT_PARM_SIZE     equ     9 * 4

;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECT_AND_TEXT           Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECT_AND_TEXT_FREECOUNT            equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )

RECT_AND_TEXT_MONODATA_0      equ    ( (2*8192) + 1000h )
RECT_AND_TEXT_MONODATA_1      equ    ( (2*8192) + 1004h )
RECT_AND_TEXT_MONODATA_2      equ    ( (2*8192) + 1008h )
RECT_AND_TEXT_MONODATA_3      equ    ( (2*8192) + 100ch )
RECT_AND_TEXT_MONODATA_4      equ    ( (2*8192) + 1010h )
RECT_AND_TEXT_MONODATA_5      equ    ( (2*8192) + 1014h )
RECT_AND_TEXT_MONODATA_6      equ    ( (2*8192) + 1018h )
RECT_AND_TEXT_MONODATA_7      equ    ( (2*8192) + 101ch )
RECT_AND_TEXT_MONODATA_8      equ    ( (2*8192) + 1020h )
RECT_AND_TEXT_MONODATA_9      equ    ( (2*8192) + 1024h )
RECT_AND_TEXT_MONODATA_10     equ    ( (2*8192) + 1028h )
RECT_AND_TEXT_MONODATA_11     equ    ( (2*8192) + 102ch )
RECT_AND_TEXT_MONODATA_12     equ    ( (2*8192) + 1030h )
RECT_AND_TEXT_MONODATA_13     equ    ( (2*8192) + 1034h )
RECT_AND_TEXT_MONODATA_14     equ    ( (2*8192) + 1038h )
RECT_AND_TEXT_MONODATA_15     equ    ( (2*8192) + 103ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3_Transfer_Text_Data@16

NV3_Transfer_Text_Data@16 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_TRANSFER_TEXT_STRUC) - NV3_TRANSFER_TEXT_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   ebx = Number of dwords remaining
        ;   ecx = Current rep mov index
        ;   edx = Current Free Count
        ;   esi = Ptr to Glyph Image data
        ;   edi = Ptr to current user channel location
        ;   ebp = Ptr to NV User Channel
        ;**********************************************************************

        mov     ebp,[esp].NV3TS_NvChannelPtr        ; Get pointer to NV channel
        add     ebp,RECT_AND_TEXT_MONODATA_0        ; EDI ptr to data array in user channel
        mov     edi,ebp                             ; EDI pts to user channel location
        mov     ebx,[esp].NV3TS_NumDwordsPerGlyph   ; Number of DWORDS to output
        mov     esi,[esp].NV3TS_GlyphDataPtr        ; Ptr to GLYPH Image data
        mov     edx,[esp].NV3TS_FreeCountPtr        ; Ptr to current cached free count
        movzx   edx,word ptr [edx]                  ; Get current free count

        ;**********************************************************************
        ;
        ; Output 4 Dwords at a time
        ;
        ;**********************************************************************

NV3TTD_Check_For_4Dwords:

        cmp     ebx,4                               ; Q: Any more Dwords to output?
        jb      short NV3TTD_Check_For_1Dwords      ;  N: Less than 4 dwords remaining

NV3TTD_4Dwords_Chk_FreeCount:

        cmp     edx,4*4                             ; Q: Enough room to output 4 dwords?
        jae     short NV3TTD_4Dwords_UpdateFreeCount;  Y: Send the data

NV3TTD_4Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+RECT_AND_TEXT_FREECOUNT-RECT_AND_TEXT_MONODATA_0] ; Get freecount from hardware
        jmp     short NV3TTD_4Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV3TTD_4Dwords_UpdateFreeCount:

        sub     edx,4*4                             ; Update cached freecount

NV3TTD_4Dwords_SendData:

        mov     eax,[esi]
        mov     [edi],eax
        mov     eax,[esi+4]
        mov     [edi],eax
        mov     eax,[esi+8]
        mov     [edi],eax
        mov     eax,[esi+12]
        mov     [edi],eax
        sub     ebx,4
        add     esi,16
        jmp     short NV3TTD_Check_For_4Dwords      ; Loop thr remaining data

        ;**********************************************************************
        ;
        ; Output 1 thru 3 Dwords at a time
        ;
        ;**********************************************************************

NV3TTD_Check_For_1Dwords:

        cmp     ebx,0                               ; Q: Any more Dwords to output?
        jbe     short NV3TTD_Done                   ;  N: All done, exit

NV3TTD_1Dwords_Chk_FreeCount:

        cmp     edx,1*4                             ; Q: Enough room to output 1 dword?
        jae     short NV3TTD_1Dwords_UpdateFreeCount;  Y: Send the data

NV3TTD_1Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+RECT_AND_TEXT_FREECOUNT-RECT_AND_TEXT_MONODATA_0] ; Get freecount from hardware
        jmp     short NV3TTD_1Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV3TTD_1Dwords_UpdateFreeCount:

        sub     edx,1*4                             ; Update cached freecount

NV3TTD_1Dwords_SendData:

        mov     eax,[esi]                           ; Get source dword
        mov     [ebp],eax                           ; Output dword to monochrome array
        dec     ebx                                 ; Next dword
        jz      short NV3TTD_Done                   ; Check if we're done
        add     esi,1*4                             ; Next dword of glyph data
        jmp     short NV3TTD_1Dwords_Chk_FreeCount  ; Continue with remaining dwords

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3TTD_Done:

        mov     eax,[esp].NV3TS_FreeCountPtr        ; Make sure to update
        mov     word ptr [eax],dx                   ;   cached free count

        add     esp,(size NV3_TRANSFER_TEXT_STRUC) - NV3_TRANSFER_TEXT_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     16

NV3_Transfer_Text_Data@16 endp




end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nv10.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV10.C
//
// Abstract:
//
//     This is code specific to NV10
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);

//******************************************************************************
// External Declarations
//******************************************************************************

//******************************************************************************
// Hack -> Eventually, we want to include the official
//         NVREF.H file, located in \kernel\resman\inc.
//         However, since this miniport already has an nvref.h file,
//         we'll have to pick and choose.  This will all get
//         overhauled when the miniport is re-architected.
//******************************************************************************

#define NV_PGRAPH_TILE(i)                       (0x00400b00+(i)*16) /* RW-4A */
#define NV_PGRAPH_TLIMIT(i)                     (0x00400b04+(i)*16) /* RW-4A */
#define NV_PGRAPH_TSIZE(i)                      (0x00400b08+(i)*16) /* RW-4A */
#define NV_PBUS_DEBUG_1                                  0x00001084

#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */


#define NV_PFB_TIMING2                                   0x00100228 /* RW-4R */
#define NV_PFB_TIMING2_REFRESH                                 15:5 /* RW-VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_REFCTRL                                   0x00100210 /* RW-4R */
#define NV_PFB_MRS                                       0x001002C0 /* RW-4R */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */

//******************************************************************************
//
// Function:    NV10ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_TIMING2);   // refresh
    FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_CFG);           // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CSTATUS);       // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_REFCTRL);       // RAM config
    HwDeviceExtension->Power_PfbMrs       = REG_RD32(NV_PFB_MRS);           // RAM config
    HwDeviceExtension->Power_PfbEmrs      = REG_RD32(NV_PFB_EMRS);          // RAM config
    HwDeviceExtension->Power_PfbRef       = REG_RD32(NV_PFB_REF);           // RAM config
    HwDeviceExtension->Power_PbusDebug1   = REG_RD32(NV_PBUS_DEBUG_1);      // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);    // READ STRAPS
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);

    }



//******************************************************************************
//
// Function:    NV10ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    // power up mode - restore previous memory config
    REG_WR32(NV_PBUS_DEBUG_1, HwDeviceExtension->Power_PbusDebug1);   // must set FBI differential
    REG_WR32(NV_PFB_TIMING2, HwDeviceExtension->Power_refresh);       // refresh
    REG_WR32(NV_PFB_CFG, HwDeviceExtension->Power_PfbBoot0);          // RAM config
    REG_WR32(NV_PFB_CSTATUS, HwDeviceExtension->Power_PfbConfig0);    // RAM config
    REG_WR32(NV_PFB_REFCTRL, HwDeviceExtension->Power_PfbConfig1);    // RAM config
    REG_WR32(NV_PFB_MRS, HwDeviceExtension->Power_PfbMrs);    		 // RAM config
//  REG_WR32(NV_PFB_EMRS, HwDeviceExtension->Power_PfbEmrs);    		 // RAM config - reset
    REG_WR32(NV_PFB_REF, HwDeviceExtension->Power_PfbRef);    		 // RAM config

//  A delay seems to be necessary for i820 for win9x.
//  Couldn't demonstrate a problem with W2K, so its here for safety.
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0)
        {
        for (i=0; i<2000; i++)
            {
            REG_RD32(NV_PMC_ENABLE);
            }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES)
            break;
        }
    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\ddc.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     DDC.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

// MP/RM merge
#include "nvos.h"
#include "rm.h"

extern VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

extern ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);


//******************************************************************************
// DDC support is only available for NT5 or later
//******************************************************************************


#if (_WIN32_WINNT >= 0x0500)


//******************************************************************************
// Forward Function Declarations
//******************************************************************************

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION);

BOOLEAN
GetDdcInformation (
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetDdcInformation)
#endif

//******************************************************************************
//
//  Register Description:
//
//
//        6.24 CR3E DDC Status Register                 0x3X5 Index 3E (R-)
//      
//      #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
//      
//         Bit 3    SDA pin.  This is the current value of the SDA pin.
//         Bit 2    SCL pin.  This is the current value of the SCL pin.
//      
//      
//        6.23 CR3F DDC Write Register                   0x3X5 Index 3F (RW)
//      #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
//      
//         Bits 7-6 Reserved
//      
//         Bits 5   Write SCL pin. If 1, this will tri-state the SCL bus.  This will allow
//      	    the value of the SCL pin to reach a 1 since the SCL pin is connected
//      	    to a external pull-up.  A 0 will enable the SCL pin and force
//      	    a 0 onto the SCL signal.
//      
//         Bits 4   Write SDA pin. If 1, this will tri-state the SDA bus.  This will allow
//      	    the value of the SDA pin to reach a 1 since the SDA pin is connected
//      	    to a external pull-up.  A 0 will enable the SDA pin and force
//      	    a 0 onto the SDA signal.
//      
//         Bits 3-2   Reserved. 
//      
//         Bit  1   DDC Write release.  When a 0 is written, it will release the SCL pin
//      	    and allow it to float high.  When a 1 is written, it will latch the 
//      	    SDA value at the next falling edge of SCL and hold the SCL pin low
//      	    until a 0 is written.
//      
//         Bit  0   DDC enable pin.  Enables writes onto the DDC pins.  
//      	    1 indicates writes are enabled. 
//      
//         This register defaults to 0x30 after reset.
//         
//         The DDC is really a I2C interface.  This interface is designed to allow easy
//         software controllability.  
//      
//      None.
//
//******************************************************************************


//******************************************************************************
//
//  Function:   WriteClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x20;
    else        
        ucPortData &= (~0x20);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   WriteDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x10;
    else        
        ucPortData &= (~0x10);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   ReadClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 2    SCL pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&4) >> 2);
    }


//******************************************************************************
//
//  Function:   ReadDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 3    SDA pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&8) >> 3);
    }

//******************************************************************************
//
//  Function:   WaitForVsyncActive
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    //**************************************************************************
    // Wait while in vblank
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) ==0);

    //**************************************************************************
    // Wait while display is active
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) !=0);

    //**************************************************************************
    // Now we're in vblank
    //**************************************************************************

    }


//******************************************************************************
//
//  Function: GetCurrentScanLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    ULONG   LoByte, HiByte;
    ULONG   Value;
    
    //**************************************************************************
    // Get current scanline by reading both registers
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
    HiByte <<=8;
    
    CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
    LoByte &=0xff;
        
    Value = ( (HiByte << 8) | (LoByte&0xff) );
    Value &= 0x7FF;
        
    if (Value == 0)
        {
        //**********************************************************************
        // Double check to fix hw bug. (for NV3)
        //**********************************************************************

        CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
        HiByte <<=8;
    
        CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
        LoByte &=0xff;
        
        Value = ( (HiByte << 8) | (LoByte&0xff) );
        Value &= 0x7FF;
        }


    return(Value);
    }


//******************************************************************************
//
//  Function:   GetDdcInformation
//
//  Routine Description:
//
//      Reads the basic EDID structure from the monitor using DDC2.
//
//  Arguments:
//
//      HwDeviceExtension - Points to per-adapter device extension.
//  
//      ulDisplayIndex    - Logical Display index (GDI level)
//
//      QueryBuffer       - Buffer where information will be stored.
//  
//      BufferSize        - Size of the buffer to fill.
//
//  Return Value:
//
//      Whether the call succeeded or not.
//
//******************************************************************************


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize)

    {
    ULONG ulHead, i;
    ULONG ulPrimaryHead;
    NV_DESKTOP_INFO * pDeskTop;
    ULONG ulDeviceMask = 0;
    LPEDID_UNIT pEdidUnit;
    PUCHAR      pEDIDBuffer;

    pDeskTop = &HwDeviceExtension->DeskTopInfo;

    // BUGBUG
    // We take a different code path for Dualview. We want expose two monitors, no matter what.
    // The problem of single view is that it depends on HwDeviceExtension->DeskTopInfo to determine
    // which monitor to expose.  But at this moment, HwDeviceExtension->DeskTopInfo is not initialized yet.
    // And even worse, it's subject to change on switching to different heads.
    // In future, this code should be revisited.  We should always expose all monitors to GDI.
    // Non-Dualview code path shall be removed
    if (HwDeviceExtension->pDualViewAssociatedDE)
    {
        ULONG ulConnectedDeviceMask = pDeskTop->ulConnectedDeviceMask;
        // If on LCD/CRT/TV all exist, pick CLD and CRT
        if ((ulConnectedDeviceMask & BITMASK_ALL_CRT) &&
            (ulConnectedDeviceMask & BITMASK_ALL_TV) &&
            (ulConnectedDeviceMask & BITMASK_ALL_DFP))
            ulConnectedDeviceMask &= ~BITMASK_ALL_TV;

        for (i = 0; i <= ulDisplayIndex; i++)
        {
            ulDeviceMask = LOWESTBIT(ulConnectedDeviceMask);
            ulConnectedDeviceMask &= ~ulDeviceMask;
        }
    }
    else
    {
        // This function will be called only for the case of a board with a single head.
        // So we reference the EDID info of the Head 0.
        ulHead = 0;

        //
        // Enable this code once Terry finishes the control panel work of automoatically disabling the system EDID for
        // spanning modes.
        //
        // Extract the primary head. For standard/clone/span modes, we will let the OS manage the properties
        // (refresh rate, color depth, EDID flag) of the primary head.
        // Note: Dependency: The control panel needs to automatically disable the OS EDID if the user wants to switch
        // to spanning mode, otherwise the 'faked' doubled modes will be disallowed by the OS.

        // NOTE to keep in mind: This routine gets called before any mode set has happened. So encure that the right
        // device mask is being used.

        ulPrimaryHead = pDeskTop->ulDeviceDisplay[ulDisplayIndex];
        ulDeviceMask = pDeskTop->ulDeviceMask[ulPrimaryHead];
    }

    // We are overloading the term ulHead here, so clean up later by removing the variable ulHead
    // and use only the term ulEDIDIndex;
    ulHead = ConvertDeviceMaskToIndex(ulDeviceMask); 

    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulHead];
    pEDIDBuffer = pEdidUnit->EDIDBuffer;

    //**************************************************************************
    // If a flat panel was connected, then just return the EDID buffer
    // (which was obtained in the RM). Do the same for a CRT also.
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
    {

        //**********************************************************************
        // Win2k (as of build 2195) does NOT seem to understand version 2.0 EDIDs.
        // Returning a version 2.0 EDID will cause Win2k to come up in VGA.
        // So for now, if we detect version 2.0, then just return FAILURE, and
        // don't bother returning the EDID.  (Fixes Gateway FPD1500 flat panel)
        //**********************************************************************

    	if (! ((pEDIDBuffer[0] == 0)    && 
               (pEDIDBuffer[1] == 0xFF) && 
               (pEDIDBuffer[7] == 0)) )
            return(FALSE);
    }

    //
    // Return failure if this is a non-DDC device. The whole EDID structure would have been zeroed out in this case.
    // Let us check a few random fields to verify.
    // (18)    EDID Version Number
    // (19)    Revision number
    //
    if (pEDIDBuffer[0] == 0    && 
        pEDIDBuffer[1] == 0    && 
        pEDIDBuffer[7] == 0    && 
        pEDIDBuffer[18] == 0   && 
        pEDIDBuffer[19] == 0)
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }

    if (!pEdidUnit->Valid)
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }
    

    //**********************************************************************
    // Go ahead and return the EDID
    //**********************************************************************

    VideoPortMoveMemory(QueryBuffer, pEDIDBuffer, BufferSize);

    //**********************************************************************
    // Return Success.
    //**********************************************************************

    return(TRUE);

    }



#endif // _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv4text.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV4TEXT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated text blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

FALSE                       EQU 0
TRUE                        EQU 1
LLNULL                      EQU 0ff00ff00h
FONT_REJECTED_TAG           EQU 0ffffffffh
FONTFIXEDPITCHSHIFT         EQU 7
FONTFIXEDPITCH              EQU 1 SHL FONTFIXEDPITCHSHIFT
MAXFONTCACHESIZE            EQU FONTFIXEDPITCH * MAXGLYPHS
MAXGLYPHSIZE                EQU (FONTFIXEDPITCH-4)
MAXGLYPHS                   EQU 256
MAXGLYPHINDEX               EQU 255
MAXFONTS                    EQU 16

FontCacheInfoStruc struc

    FontCacheId         dd  LLNULL
    FontPitchAndOffset  dd  LLNULL
    pFontInfoPrev       dd  LLNULL
    pFontInfoNext       dd  LLNULL
    FontCacheGlyphInfo  dd  MAXGLYPHS dup (0)

FontCacheInfoStruc ends

FONTCACHEINFOHEADERSIZE EQU 16      ; size of first 4 DWORDS in FontCachInfoStruc
                                    ; before glyph data

        .data

LRUFontInfoNode         dd  LLNULL
MRUFontInfoNode         dd  LLNULL


; Remove structure since font caching is turned off. This buffer should be
; allocated at initialization instead of here anyway.
;
;FontCacheInfo           db (MAXFONTS * sizeof(FontCacheInfoStruc)) dup (0)
FontCacheInfo           dd ?

;
;  stack based params and local variables
;


NV4_DrawFastGlyphs_STRUC          struc

; Feel free to add any local variables here:

gWidth                  dd      ?
localNvDmaCount         dd      ?
localNvDmaFifoPtr       dd      ?
missingGlyphFlag        dd      ?
numBytesPerScan         dd      ?
numDwordsPerGlyph       dd      ?
originalPgpParm         dd      ?
ptlOriginx              dd      ?   ;PointL
ptlOriginy              dd      ?
clipRight               dd      ?
clipBottom              dd      ?
saveESI                 dd      ?
saveEDX                 dd      ?
saveGlyphCount          dd      ?
saveNvDmaCount          dd      ?
savePgp                 dd      ?
savePpdev               dd      ?
ulCharIncLocal          dd      ?
fontInfoBuffer          db      (size FONTINFO) dup (?)

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

DFG_ebp                 dd      ?
DFG_esi                 dd      ?
DFG_edi                 dd      ?
DFG_ebx                 dd      ?
DFG_RetAddr             dd      ?
pso                     dd      ?
pstro                   dd      ?
pfo                     dd      ?
prclClip                dd      ?
pgpParm                 dd      ?
glyphCount              dd      ?

NV4_DrawFastGlyphs_STRUC          ends

NV4_DrawFastGlyphs_PARM_SIZE     equ     11 * 4


        .code

extrn       FONTOBJ_vGetInfo@12:NEAR
extrn       NV_DmaPush_Wrap@8:NEAR
extrn       NV_DmaPush_CheckWrapped@8:NEAR


;******************************************************************************
;
;   CheckDMAFreeCount - Get current free count in DMA buffer. If not enough
;       space, then calls Vidal's routines to make sure there is room in
;       the DMA buffer. Then gets new DMA buffer free count. This routine is
;       similar to the NV_DMAPUSH_CHECKFREE C macro.
;
;   NOTE: requires ppdev.nvDmaCount to equal local nvDmaCount
;
;   INPUT:  EBP - stack pointer
;           ECX - number of DWORDS needed in DMA buffer
;   OUTPUT: EAX = free count
;           updates localNvDmaCount when ppdev->nvDmaCount is updated
;
;******************************************************************************

align 4

CheckDMAFreeCount   proc

        mov     ebx, [ebp].savePpdev        ; ppdev
        mov     edx, [ebx].nvDmaCount       ; ppdev->nvDmaCount
        cmp     [ebx].nvDmaWrapFlag, FALSE
        jne     short CheckDmaWrapped

    ;*************************************************************************
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ; EDX - nvDmaCount
    ;
    ;*************************************************************************

        mov     eax, [ebx].DmaPushBufCanUseSize ;
        sub     eax, edx                    ; less current nvDmaCount
        sub     eax, ecx                    ; less number of DWORDS needed
        jl      GoWrapDmaBuffer
        
        mov     [ebx].nvDmaCachedFreeCount, eax
        ret                                 ; enough room - return new freecount

    ;*************************************************************************
    ; Need to wrap.
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

GoWrapDmaBuffer:
        push    ecx                         ; save dwords needed
        push    ecx                         ; DWORDS needed - parameter
        push    ebx                         ; ppdev - parameter
        call    NV_DmaPush_Wrap@8           ; (ppdev, DWORDS_NEEDED)
        pop     ecx                         ; restore dwords needed
        mov     ebx, [ebp].savePpdev
        mov     edx, [ebx].nvDmaCount
        mov     [ebp].localNvDmaCount, edx  ; update local nvDmaCount

CheckDMADone:
        mov     [ebx].nvDmaCachedFreeCount, 0
        ret

    ;*************************************************************************
    ; WRAP_FLAG = TRUE. We are currently wrapped around (DMA count < Get Ptr)
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

CheckDmaWrapped:

        push    ecx                         ; save dwords needed
        push    ecx                         ; DWORDS needed - parameter
        push    ebx                         ; ppdev - parameter
        call    NV_DmaPush_CheckWrapped@8   ; (ppdev, DWORDS_NEEDED)
        pop     ecx                         ; restore dwords needed
        mov     ebx, [ebp].savePpdev
        mov     edx, [ebx].nvDmaCount
        mov     [ebp].localNvDmaCount, edx  ; update local nvDmaCount
        mov     [ebx].nvDmaCachedFreeCount, 0
        ret

CheckDMAFreeCount   endp


;******************************************************************************
;
;   NV4_DrawFastGlyphs
;
;   SURFOBJ*    pso
;   STROBJ*     pstro
;   FONTOBJ*    pfo
;   RECTL*      prclClip
;   GLYPHPOS*   pgpParm
;   ULONG       glyphCount
;
;******************************************************************************

align 4
        public NV4_DrawFastGlyphs@24

NV4_DrawFastGlyphs@24 proc near

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV4_DrawFastGlyphs_STRUC) - NV4_DrawFastGlyphs_PARM_SIZE
        cld

        mov     ebx, [esp].pso
        mov     ecx, 6                      ; overhead for caching string
        mov     ebx, [ebx].dhpdev           ; pso->dhpdev points to pdev
        mov     esi, [ebx].nvDmaCount       ; ppdev->nvDmaCount
        mov     eax, [ebx].nvDmaFifo
        mov     [esp].savePpdev, ebx
        mov     [esp].localNvDmaCount, esi   ; save local copy
        mov     [esp].localNvDmaFifoPtr, eax ; save local copy

    ;*************************************************************************
    ; Get current free count in DMA buffer.
    ;
    ; NOTE: requires ppdev.nvDmaCount to equal local nvDmaCount
    ;
    ; INPUT:  EBP - stack pointer
    ;         ECX - number of DWORDS needed in DMA buffer
    ; OUTPUT: EAX = free count
    ;         updates localNvDmaCount when ppdev->nvDmaCount is updated
    ;
    ;*************************************************************************

        add     ecx, [esp].glyphCount       ; number of glyphs + overhead for push buffer check
        mov     ebp, esp
        call    CheckDMAFreeCount           ; gets free count
        mov     ebx, [esp].savePpdev
        mov     eax, [esp].pstro
        mov     edi, [eax].ulCharInc        ; space between glyphs if non-zero
        mov     [esp].ulCharIncLocal, edi   ; save glyph increment

    ;*************************************************************************
    ;
    ; Clip rectangle
    ;
    ; CLIP_POINT0_C = prclClip->top << 16 | prclClip->left
    ; CLIP_POINT1_C = prclClip->bottom <<16 | prclClip->right
    ;
    ; For bottom right, use MIN(prclClip->bottom, MAX_CX_CY_MEMORY_VALUE) << 16 ||
    ;                       MIN(prclClip->right,  ppdev->cxScreen)
    ;
    ; This is necessary because the bottom and right values in the clipping
    ; rectangle are sometimes too large for the current frame buffer and these
    ; values screw up the hardware.
    ;       
    ; EBX - ppdev
    ;
    ;*************************************************************************

        mov     ecx, [esp].localNvDmaCount
        shl     ecx, 2                      ; offset into DMA buffer
        mov     esi, [esp].localNvDmaFifoPtr
        mov     eax, [esp].prclClip

        mov     [esi+ecx], RECT_AND_TEXT_SUBCHANNEL OR NV04A_CLIP_POINT0_C OR (2 SHL 18)

        mov     edx, [eax].ytop             ; prclClip->top
        mov     edi, [eax].xleft            ; prclClip->left
        shl     edx, 16                     ; prclClip->top << 16
        and     edi, 0ffffh
        or      edx, edi

        mov     [esi+ecx+4], edx            ; NV04A_CLIP_POINT0_C

    ;*************************************************************************
    ;
    ; Clip right, bottom
    ;
    ; EAX - prclClip
    ; EBX - ppdev
    ; ECX - localNvDmaCount*4
    ; ESI - nvDmaFifo
    ;
    ;*************************************************************************

        mov     edi, [eax].xright           ; prclClip->right
        mov     edx, [eax].ybottom          ; prclClip->bottom
        cmp     edi, [ebx].cxScreen
        jl      @f
        
        mov     edi, [ebx].cxScreen
@@:
        mov     [esp].clipRight, edi        ; save right clip for later checking
        
        cmp     edx, MAX_CX_CY_MEMORY_VALUE
        jl      @f
        
        mov     edx, MAX_CX_CY_MEMORY_VALUE
@@:
        mov     [esp].clipBottom, edx       ; save bottom clip for later checking
        shl     edx, 16
        and     edi, 0ffffh
        or      edx, edi
        mov     [esi+ecx+8], edx            ; NV04A_CLIP_POINT1_C

        add     ecx, 12                     ; number of bytes written to DMA buffer
        shr     ecx, 2                      ; convert to dwords
        mov     [esp].localNvDmaCount, ecx  ; update local nvDmaCount
        mov     [esp].saveNvDmaCount, ecx   ; save buffer pointer here in case
                                            ; need to back up if invalid text data
        mov     eax, [esp].pgpParm
        mov     [esp].originalPgpParm, eax  ; save starting pgp

        cmp     [ebx].fontCacheEnabled, FALSE ; if caching turned off
        je      DrawGlyphsWithoutCache      ; then draw glyphs without caching

    ;*************************************************************************
    ; Find the font in the FontCacheInfo table if it exists.
    ;*************************************************************************

        mov     [esp].missingGlyphFlag, FALSE
        mov     edx, [esp].pfo               ; Font object
        mov     ebx, [edx].pvConsumer        ; check if font has been cached
        cmp     ebx, FONT_REJECTED_TAG       ; can't cache this font
        je      DrawGlyphsWithoutCache       ; draw glyphs the old way

        or      ebx, ebx                     ; if zero then not cached
        je      CacheNewFont                 ; so cache font

    ;*************************************************************************
    ; EBX = offset to FontCacheInfo entry
    ;*************************************************************************

        mov     eax, [ebx].FontCacheId       ; font handle
        cmp     eax, [edx].iUniq             ; pfo.iUniq = font handle
        jne     CacheFontAgain               ; font was bumped - cache again

    ;*************************************************************************
    ; Found the font in cache.  Update the MRU and LRU font info linkedlist
    ;
    ; EBX - pointer to FontCacheInfo entry for this font
    ;
    ;*************************************************************************

CachedFontFound:

        cmp     ebx, LRUFontInfoNode
        jne     MakeFontMRU                 ; if we are not in LRU then don't worry

        mov     edi, [ebx].pFontInfoPrev    ; CurFontInfo at LRU.  Remove it
        test    edi, edi
        js      OutputCachedFont            ; current font is only font in linked list

        mov     LRUFontInfoNode, edi
        mov     [edi].pFontInfoNext, LLNULL ; null for linked list

MakeFontMRU:
        cmp     ebx, MRUFontInfoNode
        je      OutputCachedFont            ; done if MRU font ptr is correct

        mov     esi, [ebx].pFontInfoPrev    ; esi  = CurFontInfo->Prev
        mov     edi, [ebx].pFontInfoNext    ; edi  = CurFontInfo->Next
        mov     [esi].pFontInfoNext, edi    ; CurFontInfo->Prev->Next
                                            ;     = CurFontInfo->Next
        test    edi, edi
        js      short @f
        mov     [edi].pFontInfoPrev, esi    ; CurFontInfo->Next->Prev
                                            ;     = CurFontInfo->Prev
@@:
        mov     esi, MRUFontInfoNode        ; Update MRU list
        mov     MRUFontInfoNode, ebx
        mov     [ebx].pFontInfoNext, esi    ; CurFontInfo->Next = OldMRUFontInfo
        mov     [ebx].pFontInfoPrev, LLNULL ; CurFontInfo->Prev = NULL
        mov     [esi].pFontInfoPrev, ebx    ; points to new MRU

    ;*************************************************************************
    ; EBX - ptr to FontCacheInfo entry for current font
    ;*************************************************************************

OutputCachedFont:

        mov     esi, [esp].localNvDmaFifoPtr
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     esi, edi                    ; nvDmaFifo[nvDmaCount]
        mov     eax, [ebx].FontPitchAndOffset
        mov     dword ptr [esi], RECT_AND_TEXT_SUBCHANNEL OR NV04A_FONTF OR (1 SHL 18)
        mov     [esi+4], eax                ; set font info

        mov     eax, [esp].glyphCount       ; number of glyphs to draw
        shl     eax, 18                     ; bits 31:18 had glyph count
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_CHARACTER_COLOR1_F
        mov     [esi+8], eax                ; number of dwords to send
        add     esi, 12                     ; update nvDmaCount

    ;*************************************************************************
    ;
    ; EBX - ptr to FontCacheInfo entry for current font
    ;*************************************************************************

        mov     eax, [esp].pgpParm
        mov     ecx, [esp].pstro
        mov     edi, [eax].gp_x             ; pgp->ptl.x
        mov     edx, [eax].gp_y             ; pgp->ptl.y

        shl     edi, 8
        shl     edx, 20
        and     edi, 0fff00h                ; shouldn't be necessary, but just in case
        or      edx, edi                    ; y bits 31:20, x bits 19:8

        add     ebx, FONTCACHEINFOHEADERSIZE

;*****************************************************************************
;
; Loop through all the unclipped glyphs for this string with caching
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

CachedGlyphWhichLoop:
        mov     edi, [esp].glyphCount       ; number of glyphs in string
        cmp     [esp].ulCharIncLocal, 0
        jnz     CachedGlyphFixedLoop        ; ulCharInc is used for glyph positions

    ;*************************************************************************
    ;
    ; Loop through all glyphs. Glyph positions are not fixed, that is, ulCharInc
    ; is zero and the pgp contains the glyph spacing.
    ;
    ;*************************************************************************

CachedGlyphLoop:

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;*************************************************************************

        mov     ecx, [eax].gp_hg            ; glyph index in pgp
        cmp     ecx, MAXGLYPHINDEX
        jg      NotValidGlyph

        mov     ecx, [ebx+ecx*4]            ; saved XY and glyph index
        cmp     ecx, LLNULL                 ; if null
        je      LoadMissingGlyphsToCache    ; then need to load glyph

        add     ecx, edx                    ; add the glyph based XY org
        add     eax, (size GLYPHPOS)        ; pgp++
        mov     [esi], ecx                  ; output glyph from cache
        add     esi, 4                      ; nvDmaFifoPtr++

    ;*************************************************************************
    ; Check for more glyphs in string
    ;*************************************************************************

        dec     edi                         ; more glyphs to draw?
        jle     DrawCachedGlyphsDone        ; no - exit

    ;*************************************************************************
    ; Update to next glyph and update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
    ; EDI - number of glyphs in string
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

        mov     ecx, [eax].gp_x             ; pgp->ptl.x
        mov     edx, [eax].gp_y             ; pgp->ptl.y
        shl     ecx, 8
        shl     edx, 20
        and     ecx, 0fff00h                ; shouldn't be necessary, but just in case
        or      edx, ecx
        jmp     CachedGlyphLoop             ; yes - continue with next glyph

    ;*************************************************************************
    ; Update DMA buffer
    ;
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

DrawCachedGlyphsDone:
        sub     esi, [esp].localNvDmaFifoPtr
        shr     esi, 2
        mov     [esp].localNvDmaCount, esi  ; update nvDmaCount
        jmp     DrawGlyphsDone

;*****************************************************************************
;
; Loop through all the unclipped glyphs for this string with caching. Use
; ulCharInc to position each glyph in string
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; EDI - number of glyphs in string
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

CachedGlyphFixedLoop:

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;*************************************************************************

        mov     ecx, [eax].gp_hg            ; glyph index in pgp
        cmp     ecx, MAXGLYPHINDEX
        jg      NotValidGlyph

        mov     ecx, [ebx+ecx*4]            ; saved XY and glyph index
        cmp     ecx, LLNULL                 ; if null
        je      LoadMissingGlyphsToCache    ; then need to load glyph

        add     ecx, edx                    ; add the glyph based XY org
        mov     [esi], ecx                  ; output glyph from cache
        add     esi, 4                      ; nvDmaFifoPtr++

    ;*************************************************************************
    ; Check for more glyphs in string
    ;*************************************************************************

        dec     edi                         ; more glyphs to draw?
        jle     DrawCachedGlyphsDone        ; no - exit

    ;*************************************************************************
    ; Update to next glyph and update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
    ; EDI - number of glyphs in string
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

        add     eax, (size GLYPHPOS)
        mov     ecx, [esp].ulCharIncLocal
        shl     ecx, 8
        add     edx, ecx                    ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        jmp     CachedGlyphFixedLoop        ; continue with next glyph

;*****************************************************************************
;
; Glyph has not been cached, so update current DMA pointers in case caching is
; aborted and try to cache rest of glyphs now.
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; EDI - number of glyphs left to draw
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

LoadMissingGlyphsToCache:

        sub     ebx, FONTCACHEINFOHEADERSIZE
        mov     [esp].pgpParm, eax          ; save current pgp
        mov     [esp].glyphCount, edi       ; update number of glyphs left
        mov     [esp].saveESI, esi          ; DMA pointer
        mov     [esp].saveEDX, edx          ; destination x and y position

        mov     edi, [ebx].FontPitchAndOffset
        mov     [esp].missingGlyphFlag, TRUE
        and     edi, 0fffffffh              ; clear pitch
        jmp     LoadGlyphsToCache

;******************************************************************************
;
; Font is not cached because it is new. Check if we can fit the font into
; the offscreen memory cache.
;
; EDX - pfo - pointer to font object
;
;******************************************************************************

align 4

CacheNewFont:

        lea     ebx, [esp].fontInfoBuffer
        mov     ecx, size FONTINFO
        push    ebx                         ; &fontInfo
        push    ecx                         ; size (FONTINFO)
        push    edx                         ; pfo
        call    FONTOBJ_vGetInfo@12         ; FONTOBJ_vGetInfo (pfo, cjSize, pfontInfo)

        lea     eax, [esp].fontInfoBuffer
        mov     edx, [esp].pfo
        mov     ecx, [eax].cjMaxGlyph1
        cmp     ecx, MAXGLYPHSIZE
        jle     LoadFontToCache

        mov     [edx].pvConsumer, FONT_REJECTED_TAG
        jmp     DrawGlyphsWithoutCache

    ;**************************************************************************
    ;
    ; Font is not cached, either because it is new or because it was bumped from
    ; the cache. So if we can cache the font, load it to offscreen memory.
    ;
    ; First, an entry in our FontCacheInfo table. If the FontCacheInfo table
    ; is full, the LRU font is freed to make room for the new font.
    ;
    ;  EDX - pfo - pointer to font object
    ;
    ;**************************************************************************

align 4

CacheFontAgain:
LoadFontToCache:

        mov     ebx, offset FontCacheInfo
        xor     ecx, ecx
        mov     eax, LLNULL                 ; NULL

FindFreeEntry:
        cmp     eax, [ebx].FontCacheID      ; if not null
        jne     ContinueLookingForEntry     ; then keep looking

    ;*************************************************************************
    ; Found empty entry in table
    ;
    ;  EBX = ptr of FontCacheInfo entry
    ;  ECX = index in FontCacheInfo table
    ;
    ;*************************************************************************

GotFontCacheInfo:

        mov     esi, [esp].savePpdev
        mov     eax, MAXFONTCACHESIZE
        imul    eax, ecx
        mov     edi, [esi].fontCacheOffset
        add     edi, eax
        mov     eax, LLNULL
        jmp     GotFontCacheOffset

ContinueLookingForEntry:
        inc     ecx
        add     ebx, (size FontCacheInfoStruc)  ; each entry is fixed (256 DWORDS)
        cmp     ecx, MAXFONTS
        jl      short FindFreeEntry

    ;*************************************************************************
    ; Free LRU font and initialize font info entry to empty
    ;
    ;  EAX = LLNULL - null for font info structure and linked list 0ff00ff00h
    ;
    ;*************************************************************************

        mov     ebx, LRUFontInfoNode
        mov     edi, ebx                            ; init the font entry to empty
        mov     esi, [ebx].pFontInfoPrev
        mov     [esi].pFontInfoNext, eax            ; set to LLNULL
        mov     LRUFontInfoNode, esi
        mov     ebp, [ebx].FontPitchAndOffset       ; save font offset for reuse

        mov     ecx, ((size FontCacheInfoStruc)/4)  ; note: LLNULL == 0ff00ff00h
        rep     stosd
        mov     edi, ebp                            ; font pitch and offset
        and     edi, 0fffffffh                      ; clear pitch info

    ;*************************************************************************
    ; Initialize FontCacheInfo Header
    ;
    ;  EAX = LLNULL
    ;  EBX = ptr of FontCacheInfo entry
    ;  EDX = pfo
    ;  EDI = font cache offset
    ;
    ;*************************************************************************

GotFontCacheOffset:

        mov     ecx, FONTFIXEDPITCHSHIFT SHL 28 ; pitch in 31:28
        or      ecx, edi                        ; load offset
        mov     [ebx].FontPitchAndOffset, ecx   ; save pitch/offset to font cache
        mov     esi, [edx].iUniq                ; pfo.iUniq - font handle
        mov     [ebx].FontCacheID, esi          ; save FontCacheID (handle)
        mov     [edx].pvConsumer, ebx           ; save ptr to FontCacheInfo entry
        cmp     eax, LRUFontInfoNode            ; if LRUFont == LLNULL then
        jne     short @f                        ; LRUFont = CurFontInfo
        mov     LRUFontInfoNode, ebx
@@:
        mov     esi, MRUFontInfoNode
        mov     [ebx].pFontInfoNext, esi        ; CurFontInfo->Next = SecondMRU
        mov     [ebx].pFontInfoPrev, eax        ; CurFontInfo->Prev = LLNULL
        mov     MRUFontInfoNode, ebx            ; MRUFont = CurFontInfo
        cmp     esi, eax                        ; if OldMRU != LLNULL then
        je      short LoadGlyphsToCache
        mov     [esi].pFontInfoPrev, ebx        ; CurFontInfo->Prev = OldMRU

;*****************************************************************************
;
; Load all glyphs in font to offscreen cache and save info in FontCacheInfo
;
; EBX - ptr to FontCacheInfo entry
; EDI - offset into frame buffer where font cache resides
;
;*****************************************************************************

LoadGlyphsToCache:

        mov     eax, [esp].savePpdev
        add     ebx, FONTCACHEINFOHEADERSIZE    ; points to glyph entries
        add     edi, [eax].pjFrameBufbase             ; frame buffer offset
        mov     eax, [esp].pgpParm
        mov     ecx, [esp].glyphCount
        mov     [esp].saveGlyphCount, ecx

    ;*************************************************************************
    ; Load all glyphs
    ;
    ; saveGlyphCount - temporary copy of glyph count
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDI - ptr to font cache in frame buffer
    ;
    ;*************************************************************************

LoadGlyphLoop:

        mov     edx, [eax].gp_hg            ; glyph index
        cmp     edx, MAXGLYPHINDEX          ; 255 - max value for hardware design
        jg      NextGlyph                   ; can't cache glyph

        cmp     [ebx+edx*4], LLNULL         ; check if glyph is cached
        jne     NextGlyph                   ; glyph already cached

        mov     [esp].savePgp, eax
        mov     ecx, [eax].gp_pgdf
        mov     ecx, [ecx].gdf_pgb
        mov     eax, [ecx].gb_y
        shl     eax, 16
        or      ax, word ptr [ecx].gb_x
        jns     short @f

        sub     eax, 10000h                 ; need to adjust for later addition
                                            ; with x and y positions

@@:
        shl     ax, 4                       ; x in 19:8
        shl     eax, 4                      ; y in 31:20
        or      eax, edx                    ; glyph index in 7:0 NOTE: edx <= 255
        mov     [ebx+edx*4], eax            ; save glyph data in FontCacheInfo table
        shl     edx, FONTFIXEDPITCHSHIFT

        lea     esi, [ecx].gb_aj            ; offset to glyph
        mov     eax, [ecx].gb_cy            ; height
        mov     ebp, [ecx].gb_cx            ; width
        add     ebp, 7                      ; byte packed - round to next byte
        and     ebp, 0fff8h                 ; number of bits - byte packed
        mov     ecx, ebp                    ; save width bits
        imul    ecx, eax                    ; bits in glyph
        add     ecx, 31
        shr     ecx, 5                      ; number of dwords in glyph

        shl     eax, 16
        or      eax, ebp                    ; high word is height, low word is width
        mov     [edi+edx], eax              ; save glyph width and height first

    ;*************************************************************************
    ; load and save glyph data to offscreen memory
    ;
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; ECX - number of dword in glyph bitmap
    ; EDX - glyph index
    ; EDI - offset to font cache in frame buffer
    ;
    ;*************************************************************************

        mov     ebp, edi                    ; save offset to start of font cache
        lea     edi, [edi+edx+4]            ; offset to glyph in cache
        rep     movsd                       ; save glyph bitmap
        mov     edi, ebp                    ; restore offset to font cache
        mov     eax,[esp].savePgp           ; pgp for current glyph

NextGlyph:
        add     eax, (size GLYPHPOS)        ; next glyph
        dec     [esp].saveGlyphCount        ; check if more glyphs to cache
        jnz     LoadGlyphLoop               ; cache next glyph

        sub     ebx, FONTCACHEINFOHEADERSIZE  ; point to FontCacheInfo entry
        cmp     [esp].missingGlyphFlag, FALSE ; if interrupted drawing to cache glyph
        je      CachedFontFound               ; then continue drawing glyphs

        add     ebx, FONTCACHEINFOHEADERSIZE  ; FontCacheInfo.FontCacheGlyphInfo
        mov     edx, [esp].saveEDX            ; destination x and y position
        mov     esi, [esp].saveESI            ; DMA pointer
        mov     eax, [esp].pgpParm            ; restore current pgp
        mov     [esp].missingGlyphFlag, FALSE ; reset flag
        jmp     CachedGlyphWhichLoop


    ;*************************************************************************
    ; Glyph can't be cached because it's index exceeds the hardware's capacity.
    ; This rarely happens, so just start from the beginning and draw the string
    ; the old way.
    ;*************************************************************************

NotValidGlyph:
        mov     eax, [esp].originalPgpParm  ; original pgp
        mov     [esp].pgpParm, eax          ; restore pgp
        mov     eax, [esp].saveNvDmaCount   ; original DMA count
        mov     [esp].localNvDmaCount, eax

;*****************************************************************************
;*****************************************************************************
;*****************************************************************************
;
; Draw glyph loop with checking for clipping without caching.
;
;*****************************************************************************

DrawGlyphsWithoutCache:

        mov     eax, [esp].pgpParm          ; ptr to glyphPos
        mov     ebx, [eax].gp_pgdf          ; ptr to glyph definition
        mov     ebx, [ebx].gdf_pgb          ; EBX = pgb (ptr to glyph bits)

    ;*************************************************************************
    ; ptlOrigin = Origin of glyph in bitmap + position on screen
    ;
    ; EAX - pgp
    ; EBX - pgb
    ;
    ;*************************************************************************

        mov     esi, [esp].pstro
        mov     edi, [ebx].gb_x             ; pgb->ptlOrigin.x
        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     edi, [eax].gp_x             ; pgp->ptl.x
        add     edx, [eax].gp_y             ; pgp->ptl.y

        mov     [esp].ptlOriginx, edi
        mov     eax, [esp].prclClip
        mov     [esp].ptlOriginy, edx

    ;*************************************************************************
    ; Check if bounding box for string is within clipping rectangle
    ;
    ; EAX - prclClip
    ; EBX - pgb
    ; ESI - pstro
    ;
    ;*************************************************************************

        mov     ecx, [esp].clipRight
        mov     edi, [eax].xleft            ; prclClip->xleft
        mov     edx, [eax].ytop
        mov     eax, [esp].clipBottom

    ;*************************************************************************
    ; Trivial rejection
    ;*************************************************************************

        cmp     ecx, [esi].rclBGxleft       ; right clip < left of rect?
        jl      DrawGlyphsDone              ; yes - done

        cmp     eax, [esi].rclBGytop        ; bottom clip < top of rect
        jl      DrawGlyphsDone              ; yes - done

        cmp     edi, [esi].rclBGxright      ; left clip > right of rect?
        jg      DrawGlyphsDone              ; yes - done

        cmp     edx, [esi].rclBGybottom     ; top clip > bottom of rect?
        jg      DrawGlyphsDone              ; yes - done

    ;*************************************************************************
    ; Eliminate beginning glyphs that are clipped on the left
    ;
    ; EBX - pgb  pointer to glyphbits
    ; ECX - clipRight
    ; EDI - rclClip.xleft
    ;
    ;*************************************************************************

        mov     eax, [esp].pgpParm          ; pgp

PreClipString:
        mov     edx, [ebx].gb_cx            ; pgb->sizlBitmap.cx
        add     edx, [esp].ptlOriginx
        cmp     edx, edi                    ; if glyph not clipped
        jg      DrawGlyphSetup              ; then continue

        dec     [esp].glyphCount            ; one less glyph
        jle     DrawGlyphsDone              ; nothing to draw

        add     eax, (size GLYPHPOS)        ; next pgp
        mov     [esp].pgpParm, eax
        mov     ebx, [eax].gp_pgdf          ; pgp->pgdf

        mov     edx, [esp].ulCharIncLocal
        mov     ebx, [ebx].gdf_pgb          ; pgb
        add     [esp].ptlOriginx, edx       ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        test    edx, edx
        jnz     PreClipString               ; continue with next glyph

        mov     ecx, [ebx].gb_x             ; pgb->ptlOrigin.x
        add     ecx, [eax].gp_x             ; pgp->ptl.x
        mov     [esp].ptlOriginx, ecx

        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     edx, [eax].gp_y             ; pgp->ptl.y
        mov     [esp].ptlOriginy, edx
        jmp     PreClipString               ; continue with next glyph

;*****************************************************************************
;
; Loop through all the clipped glyphs for this string
;
; EBX - pgb
;
;*****************************************************************************

DrawGlyphSetup:

        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

ClipGlyphLoop:
        mov     edx, [ebx].gb_cx            ; pgb->sizlBitmap.cx
        mov     ecx, [ebx].gb_cy            ; pgb->sizlBitmap.cy
        test    ecx, ecx
        jz      CheckMoreGlyphs             ; nothing to output

        and     edx, 0ffffh                 ; must be word
        mov     [esp].gWidth, edx

    ;*************************************************************************
    ;
    ; Check if glyph is clipped and skip if so. Note that we can't just exit now
    ; and assume every glyph will be clipped since this is not the case for italic
    ; or other glyphs with backups. It will also fail DCT test.
    ;
    ;*************************************************************************
        mov     eax, [esp].ptlOriginy
        mov     esi, [esp].ptlOriginx
        cmp     eax, [esp].clipBottom
        jg      CheckMoreGlyphs             ; char is clipped
        
        cmp     esi, [esp].clipRight
        jg      CheckMoreGlyphs             ; char is clipped
        
    ;*************************************************************************
    ; As far as I can tell, the beginning of the glyph (according to the
    ; GLYPHBITS structure) appears to always start on a DWORD boundary.
    ; In addition, the DDK specifies that the bits will always be DWORD padded
    ; at the end. So let's just deal with DWORDS for performance.
    ;*************************************************************************
    ;*************************************************************************
    ; Specify SizeInWidth as multiple of 8 since the incoming glyph data is
    ; always row ordered and BYTE packed. We will always output up to a
    ; BYTE boundary. The excess pixels will get clipped according to the width
    ; we specify in Size. 'SizeIn' corresponds to the amount of data that the
    ; NV Engine expects to receive, and it specifies how the data will be
    ; layed out on the screen.
    ;
    ; EBX - pgb
    ; ECX - glyph height
    ; EDX - glyph width
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        add     edx, 7                      ; width + 7
        and     edx, 0fff8h                 ; byte boundary for byte packed
        mov     eax, ecx                    ; save height
        shl     ecx, 16                     ; height in high word
        or      ecx, edx                    ; height <<16 | sizeInWidth
        shr     edx, 3                      ; divide by 8 for number of bytes
        mov     [esp].numBytesPerScan, edx
        mul     edx                         ; #bytes in glyph

        add     eax, 3
        shr     eax, 2                      ; number of dwords for the glyph
        mov     [esp].numDwordsPerGlyph, eax

    ;*************************************************************************
    ;
    ; Check freecount
    ;
    ; EAX - num Dwords in glyph bitmap
    ; EBX - pgb
    ; ECX - SizeIn = height <<16 | sizeInWidth
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        mov     edx, [esp].savePpdev
        mov     esi, [esp].localNvDmaFifoPtr
        add     eax, 5                      ; overhead for each glyph
        sub     [edx].nvDmaCachedFreeCount, eax   ; overhead per glyph
        jg      SetParmsForGlyph            ; have enough room in DMA buffer

        sub     edi, esi
        shr     edi, 2
        mov     [edx].nvDmaCount, edi       ; ppdev->nvDmaCount = localNvDmaCount
        mov     [esp].localNvDmaCount, edi

        mov     ebp, esp                    ; save stack pointer
        push    ebx                         ; save pgb
        push    ecx                         ; save SizeIn
        mov     ecx, eax                    ; number of dwords needed
        call    CheckDmaFreeCount
        pop     ecx                         ; restore SizeIn
        pop     ebx                         ; restore pgb
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; Set parameters for glyph
    ;
    ; EBX - pgb
    ; ECX - SizeIn = height <<16 | sizeInWidth
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

SetParmsForGlyph:

        mov     eax, [esp].ptlOriginy
        mov     [edi], RECT_AND_TEXT_SUBCHANNEL OR NV04A_SIZE_IN_E OR (3 SHL 18)
        mov     [edi+4], ecx                ; SIZE_IN_E = height <<16 | sizeInWidth
        and     ecx, 0ffff0000h             ; clear sizeInWidth
        or      ecx, [esp].gWidth
        mov     [edi+8], ecx                ; SIZE_OUT_E = height <<16 | width
        shl     eax, 16                     ; ptlOrigin.y < 16
        mov     ecx, [esp].ptlOriginx
        and     ecx, 0ffffh
        or      eax, ecx
        mov     [edi+12], eax               ; ptlOrigin.y < 16 |    ptlOrigin.x
        add     edi, 16                     ; update nvDmaFifo to point to nvDmaCount

    ;*************************************************************************
    ; Blast out the data as fast as possible
    ;
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        lea     esi, DWORD PTR [ebx].gb_aj  ; pgb->aj ptr to monochrome bitmap

        mov     eax, [esp].NumDwordsPerGlyph
        mov     ecx, eax
        cmp     eax, MAXMONODWORDS
        jg      BigLoop
        
        shl     eax, 18                     ; number of dwords in bits 31:18
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        mov     [edi], eax                  ; setup for glyph bitmap that follows
        add     edi, 4                      ; update nvDmaFifo to point to nvDmaCount
        rep     movsd

    ;*************************************************************************
    ; Check for more glyphs in string
    ;
    ; EDI - NvDmaPtr[NvDmaCount]
    ;
    ;*************************************************************************

CheckMoreGlyphs:
        dec     [esp].glyphCount            ; more glyphs to draw?
        jle     UpdateDMACountAndExit       ; no - exit

    ;*************************************************************************
    ; Update to next glyph
    ;*************************************************************************

        mov     eax, [esp].pgpParm
        add     eax, (size GLYPHPOS)
        mov     [esp].pgpParm, eax
        mov     ebx, [eax].gp_pgdf
        mov     ebx, [ebx].gdf_pgb          ; ptr to glyph bits

    ;*************************************************************************
    ; Update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        mov     edx, [esp].ulCharIncLocal
        mov     ecx, edx
        add     ecx, [esp].ptlOriginx       ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        test    edx, edx                    ; ulCharInc is valid
        jnz     short @f                    ; check if next glyph is clipped

        mov     ecx, [ebx].gb_x             ; pgb->ptlOrigin.x
        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     ecx, [eax].gp_x             ; pgp->ptl.x
        add     edx, [eax].gp_y             ; pgp->ptl.y
        mov     [esp].ptlOriginy, edx

@@:
        mov     [esp].ptlOriginx, ecx
        jmp     ClipGlyphLoop               ; Continue with next glyph

    ;*************************************************************************
    ; Update local DMA buffer values
    ;
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

UpdateDMACountAndExit:

        mov     esi, [esp].localNvDmaFifoPtr
        sub     edi, esi
        shr     edi, 2
        mov     [esp].localNvDmaCount, edi  ; ppdev->nvDmaCount = localNvDmaCount

    ;*************************************************************************
    ; Update DMA buffer values
    ;
    ; localNvDmaCount - has current count of entries in DMA buffer
    ;
    ;*************************************************************************

DrawGlyphsDone:
        mov     ebx, [esp].savePpdev
        mov     eax, [esp].localNvDmaCount
        mov     [ebx].nvDmaCount, eax       ; ppdev->nvDmaCount = localNvDmaCount
        add     esp,(size NV4_DrawFastGlyphs_STRUC) - NV4_DrawFastGlyphs_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     24

    ;*************************************************************************
    ; More than MAXMONODWORDS in glyph. Need to break it up and send
    ; MAXMONODWORDS at a time. This requires some extra overhead that needs to
    ; be subtracted from the free count.
    ;
    ; ECX - Number of DWORDS
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;
    ;*************************************************************************

BigLoop:
        mov     edx, [esp].savePpdev
        mov     eax, ecx                    ; number of DWORDS in glyph - use to
                                            ; calculate additional overhead
        add     eax, MAXMONODWORDS-1
        shr     eax, MAXMONOSHIFT           ; number of extra DMA entries for setup
        sub     [edx].nvDmaCachedFreeCount, eax   ; overhead per glyph
        jg      SetupBigLoop                ; have enough room in DMA buffer

        add     eax, ecx                    ; add number of DWORDS in glyph for
                                            ; total DWORDS needed from DMA buffer
        sub     edi, [esp].localNvDmaFifoPtr
        shr     edi, 2
        mov     [edx].nvDmaCount, edi       ; ppdev->nvDmaCount = localNvDmaCount
        mov     [esp].localNvDmaCount, edi
        
        mov     ebp, esp                    ; save stack pointer
        push    esi                         ; save ptr to glyph bitmap
        push    ecx                         ; save number of dwords in glyph
        mov     ecx, eax                    ; number of extra dwords needed in buffer
        call    CheckDmaFreeCount
        pop     ecx                         ; restore number of dwords in glyph
        pop     esi                         ; restore ptr to glyph bitmap
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; ECX - Number of DWORDS
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;*************************************************************************

SetupBigLoop:
        mov     edx, ecx                    ; number of dwords in glyph

SendMaxDwords:
        mov     [edi], (MAXMONODWORDS SHL 18) OR RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        add     edi, 4

        mov     ecx, MAXMONODWORDS
        sub     edx, MAXMONODWORDS
        rep     movsd

        cmp     edx, MAXMONODWORDS
        jge     SendMaxDwords

    ;*************************************************************************
    ; Send remaining dwords
    ;
    ; ECX = 0 after REP MOVSD
    ; EDX = number of dwords in bitmap remaining to be written to DMA buffer
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;
    ;*************************************************************************

        or      ecx, edx                    ; rest of dwords
        jz      CheckMoreGlyphs             ; zero - continue

        mov     eax, edx                    ; rest of dwords
        shl     eax, 18                     ; put in bits 31:18
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        mov     [edi], eax                  ; set up for bitmap data
        add     edi, 4

        rep     movsd
        jmp     CheckMoreGlyphs

NV4_DrawFastGlyphs@24 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\strucs.inc ===
;*************************** Include File Header *******************************
;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

; !!! CAUTION CAUTION !!! See Note !!!
DMAPUSH_BUFFER_SIZE EQU 200000h      ; NOTE: If you change this value here, change
DMAPUSH_PADDING     EQU 32           ;       it also in DRIVER.H
; !!! CAUTION CAUTION !!!

FALSE                       EQU 0
TRUE                        EQU 1
MAX_CX_CY_MEMORY_VALUE      EQU 7fffh   ; Hardware limitation

BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL              STRUC
ptl_x               DD      0
ptl_y               DD      0
POINTL              ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL               STRUC
sizl_cx             DD      0
sizl_cy             DD      0
SIZEL               ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;

RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Constants for accessing frame buffer via pfnBankSelectMode
;-----------------------------------------------------------------------;

BANK_OFF            equ     0
BANK_ON             equ     1
BANK_ON_NO_WAIT     equ     2

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_apbe                 dd  ?

; I haven't declared rb_aulPattern because we don't know the size of the
; rb_apbe array here.

RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
BRUSHENTRY          ends

NV04ControlDma  struc
    reserved        dd  10h dup(?)
    ChannelPut      dd  ?
    ChannelGet      dd  ?
NV04ControlDma  ends

SURFOBJ struc
    dhsurf          dd  ?
    hsurf           dd  ?
    dhpdev          dd  ?
    hdev            dd  ?
    sizlBitmapx     dd  ?
    sizlBitmapy     dd  ?
    cjBits          dd  ?
    pvBits          dd  ?
    pvScan0         dd  ?
    lDelta          dd  ?
    iSOUniq         dd  ?
    iBitmapFormat   dd  ?
    iType           dw  ?
    fjBitmap        dw  ?
SURFOBJ ends

PDEV_ASM    struc
    NVSignature         dd      ?   ; Unique NV signature
    xOffset             dd      ?   ; Pixel offset from (0, 0) to current
    yOffset             dd      ?   ;  DFB located in off-screen memory
    pjMmBase            dd      ?   ; We'll use it as a ptr to our NV Channel
    GrStatusReg         dd      ?   ; We'll use it as a ptr to our Gr Status Reg
    FbConfig0Reg        dd      ?   ; We'll use it as a ptr to our Fb Config0 Reg
    FbStartAddr         dd      ?   ; We'll use it as a ptr to our Fb Start Addr
    DACRegs             dd      ?   ; We'll use it as a ptr to our Cursor registers
    PRMCIORegs          dd      ?   ; NV3 PRMCIO Regs
    PRMVIORegs          dd      ?   ; NV3 PRMVIO Regs
    PRAMDACRegs         dd      ?   ; NV3 PRAMDAC Regs
    PRAMINRegs          dd      ?   ; NV3 PRAMIN Regs
    PGRAPHRegs          dd      ?   ; NV3 PGRAPH Regs
    PFIFORegs           dd      ?   ; NV3 PFIFO Regs
    FbBufferToggle      dd      ?   ; 0 or 1 (denotes frame buffer)
    pjFrameBufbase      dd      ?   ; pjFrameBuf base pointing to the base of frame buffer
    pjScreen            dd      ?   ; Points to base screen address
    lDelta              dd      ?   ; Distance from one scan to the next.
    cjPelSize           dd      ?   ; 1 if 8bpp, 2 if 16bpp, 3 if 24bpp, 4 if 32bpp
    iBitmapFormat       dd      ?   ; BMF_8BPP or BMF_16BPP or BMF_32BPP (color depth
    iBoard              dd      ?   ; Logical multi-board identifier (default zero)
    fontCacheOffset     dd      ?   ; Offset into font cache offscreen area
    fontCacheEnabled    dd      ?   ; Offset into font cache offscreen area
    flCaps              dd      ?   ; Capabilities flags
    flStatus            dd      ?   ; Status flags
    bEnabled            dd      ?   ; In graphics mode (not full-screen)

    hDriver             dd      ?   ; Handle to \Device\Screen
    hdevEng             dd      ?   ; Engine's handle to PDEV

    cxScreen            dd      ?   ; Visible screen width
    cyScreen            dd      ?   ; Visible screen height
    cxMemory            dd      ?   ; Width of Video RAM
    cyMemory            dd      ?   ; Height of Video RAM
    cBitsPerPel         dd      ?   ; Bits per pel (8, 15, 16, 24 or 32)
    cbFrameBuf          dd      ?   ; Size of frame buffer in bytes
    AlphaEnableValue    dd      ?   ; Global alpha enable value

    DmaPushEnabled2D    dd      ?
    DmaPushBufTotalSize dd      ?
    DmaPushBufCanUseSize dd     ?
    DmaPushBufMinSize   dd      ?
    nvDmaPushHandle     dd      ?
    nvDmaFifo           dd      ?
    nvDmaCount          dd      ?
    nvDmaChannel        dd      ?
    nvDmaCachedGet      dd      ?
    nvDmaCachedPut      dd      ?
    nvDmaPreviousPut    dd      ?
    nvDmaWrapFlag       dd      ?
    nvDmaCachedFreeCount dd     ?
    nvDmaFlushFixDwordPtr dd    ?
    nvDmaFlushFixDummyValue dd    ?
    
PDEV_ASM    ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

RECT_AND_TEXT_SUBCHANNEL    EQU 2*8192
NV04A_CLIP_POINT0_C         EQU 07ECh
NV04A_CLIP_POINT1_C         EQU 07F0h
NV04A_MONOCHROME_COLOR1_C   EQU 0800h
NV04A_SIZE_IN_E             EQU 0BF4h
NV04A_SIZE_OUT_E            EQU 0BF8h
NV04A_POINT_E               EQU 0BFCh
NV04A_FONTF                 EQU 0FF0h
NV04A_CHARACTER_COLOR1_F    EQU 1000h
MAXMONODWORDS               EQU 1 SHL MAXMONOSHIFT  ; 128
MAXMONOSHIFT                EQU 7

;-----------------------------------------------------------------------;
; Definitions for image from CPU output
;-----------------------------------------------------------------------;

IMAGE_FROM_CPU_SUBCHANNEL   EQU 0*8192
MAX_INDEXED_IMAGE_DWORDS    EQU 1792
NV061_COLOR0                EQU 400h

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends

GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends

GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

STROBJ  struc
    cGlyphs          dd  ?       ; # of glyphs to render
    flAccel          dd  ?       ; accel flags
    ulCharInc        dd  ?       ; non-zero only if fixed pitch font, equal to advanced width.
    rclBGxleft       dd  ?       ; bk ground  rect of the string in device coords
    rclBGytop        dd  ?       ; bk ground  rect of the string in device coords
    rclBGxright      dd  ?       ; bk ground  rect of the string in device coords
    rclBGybottom     dd  ?       ; bk ground  rect of the string in device coords
    pgp              dd  ?       ; If non-NULL then has all glyphs.
    pwszOrg          dd  ?       ; pointer to original unicode string.
STROBJ  ends

FONTINFO  struc
    cjThis           dd  ?       ; size of FONTINFO structure in bytes
    flCaps           dd  ?       ; capabilities flag
    cGlyphsSupported dd  ?       ; number of glyphs in the font
    cjMaxGlyph1      dd  ?       ; size oflargest glyph in 1 bit/pixel
    cjMaxGlyph4      dd  ?       ; size oflargest glyph in 4 bit/pixel
    cjMaxGlyph8      dd  ?       ; size oflargest glyph in 8 bit/pixel
    cjMaxGlyph32     dd  ?       ; size oflargest glyph in 32 bit/pixel
FONTINFO  ends

FONTOBJ   struc
    iUniq            dd  ?       ;
    iface            dd  ?       ;
    cxMax            dd  ?       ;
    flFontType       dd  ?       ;
    iTTUniq          dd  ?       ;
    iFile            dd  ?       ;
    sizeLogResPpix   dd  ?       ;
    sizeLogResPpiy   dd  ?       ;
    ulStyleSize      dd  ?       ;
    pvConsumer       dd  ?       ;
    pvProducer       dd  ?       ;
FONTOBJ   ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\arb_fifo.h ===
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {
  int gdrain_rate;
  int vdrain_rate;
  int mdrain_rate;

  int gburst_size;
  int vburst_size;
  char vid_en;
  char gr_en;
  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
  int by_gfacc;
  char vid_only_once;
  char gr_only_once;
  char first_vacc;
  char first_gacc;
  char first_macc;
  int vocc;
  int gocc;
  int mocc;
  char cur;
  char engine_en;
  char converged;
  int priority;
} arb_info;


// the following structures are used by nv3

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;  //Burst size
  int video_burst_size;   // Burst size

  int graphics_hi_priority; // FBI arbitration
  int media_hi_priority;

  int rtl_values;
  int valid;  // good values


} fifo_info;
typedef struct {

  int pix_bpp;          /* 8, 16 or 32 */

  char enable_video; /* Video scalar enabled */
  char gr_during_vid; /* Graphic displays during video */
  char enable_mp; /* Media Port enabled */

  int memory_width;  /* 64 or 128 bits */

  int video_scale; /* video scale factor */

  long pclk_khz; /* Pixel clock, in KHz */
  long mclk_khz; /* Memory clock, in KHz */

  int mem_page_miss; /* Memory page miss penalty */
  int mem_latency;  /* Memory latency */

  char mem_aligned; /* FB is aligned on a 256 byte boundry */
} sim_state;


// the following structures are used by nv4

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} nv4_fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} nv4_sim_state;




#define VIDEO       0
#define GRAPHICS    1
#define MPORT       2
#define ENGINE      3


#define GFIFO_SIZE  320     /* Graphics Fifo Sizes */
#define GFIFO_SIZE_128  256     /* Graphics Fifo Sizes */
#define MFIFO_SIZE  120 /* MP  Fifo Sizes */
#define VFIFO_SIZE  256 /* Video Fifo Sizes */

#define ABS(a)  (a>0?a:-a)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\acpi.c ===
//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nvos.h"

#include "rm.h"
#include "nvcm.h"
#include "modeext.h"

#if (_WIN32_WINNT >= 0x500)
ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

#endif  // #if (_WIN32_WINNT >= 0x500)

#if defined(ALLOC_PRAGMA)
#if (_WIN32_WINNT >= 0x500)
#pragma alloc_text(PAGE, NVGetChildDescriptor)
#endif  // #if (_WIN32_WINNT >= 0x500)
#endif  // #if defined(ALLOC_PRAGMA)

ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);

BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize);

#ifdef NVPE
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
extern VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );
extern VP_STATUS NVSetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );


BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime);
ULONG MaskToDeviceType(ULONG ulDeviceMask);
ULONG MaskToFindModeEntryDeviceType(ULONG ulDeviceMask);
VOID  ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData);
BOOLEAN  bQueryinSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN  bAllowHotKeyInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension);

BOOLEAN  bQueryInFSDOSorVGAMode(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN  bQuerySpanDualDevicesSame(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1);
BOOLEAN ACPIValidateChildStateShouldFail(PHW_DEVICE_EXTENSION hwDeviceExtension);

extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);
extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);
extern VOID HandleDualviewHeads(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bEnableDualView);

//**************************************************************************
// NT 5.0 specific entry points.
//**************************************************************************

#if (_WIN32_WINNT >= 0x0500)
//
// Returns the corresponding nVidia device mask given a ACPI hardware ID.
// If the ACPIHwId is an invalid device, returns 0.
//
ULONG ACPIHwIdToMask( ULONG ACPIHwId)
{
    switch (ACPIHwId)
    {
    // Refer to Table A-2 of Appenidix A of the document
    // "ACPI extensions for Display Adapters" for a list 
    // of the "commonly used device IDs"
    case QUERY_ACPI_CRT_ID:
        // This is the Monitor. Our device mask is 0x1 for the CRT.
        return (0x1);
    case QUERY_ACPI_DFP_ID:
        // This is the DFP. Our device mask is 0x10000 for the DFP.
        return(0x10000);
    case QUERY_ACPI_TV_ID:
        // This is the TV. Our device mask is 0x100 for the TV.
        return(0x100);
    case 0:
        // Other device. What do we do here?
        VideoDebugPrint((0,"Oops! ChildEnumInfo->ACPIHwId is 0. Not sure what we do here!\n"));
        return(0);
    default:
        VideoDebugPrint((1,"OOps! Error: Unknown ACPIHwID: 0x%x\n", ACPIHwId));
        return(0);
    }
}

//
// Returns TRUE if we are in spanning mode. else returns FALSE
//
BOOLEAN  bQueryInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // Detect if we are in spanning mode.
    //
    if (MULTIMON_MODE(pInfo->ulDesktopWidth, pInfo->ulDesktopHeight))
    {
        return(TRUE);
    }

    //
    // Handle the special resolution of 6x4, 8x6 and 10x7 which are present in spanning modes also.
    //
    if (pInfo->ulTwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        return(TRUE);

    }

    //
    // We are ins tandard or clone mode.
    //
    return(FALSE);

}

//
// Returns TRUE if we are in FSDOS or VGA mode. else returns FALSE
//
BOOLEAN  bQueryInFSDOSorVGAMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // Detect if we are in full screen mode.
    // Or if we are in VGA mode (such as via the F8 option of "VGA mode" at bootup time.
    // Here we want to pass VALIDATE_CHILD_DEVICE but fail SET_CHILD_DEVICE so that the OS will
    // call the VBIOS to do the switching. Note that the GET_CHILD_STATE has to be consistent with the
    // devices specified in VALIDATE_CGILD_DEVICE and SET_CHILD_DEVICE.
    //
    if (hwDeviceExtension->SystemModeSetHasOccurred && pInfo->ulDesktopMode == 0)
    {
        return(TRUE);
    }
    if (hwDeviceExtension->SystemModeSetHasOccurred == 0)
    {
        return(TRUE);
    }
    //
    // We are in high res mode.
    //
    return(FALSE);
}

//
// Returns TRUE if
// - system is currently in spanning mode. AND
// - same devices being used
//
BOOLEAN  bQuerySpanDualDevicesSame(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1)
{
    ULONG ulCombinedMask_Current;
    ULONG ulCombinedMask_Requested;
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;
    
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        ulCombinedMask_Current = pInfo->ulDeviceMask[0] | pInfo->ulDeviceMask[1];
        ulCombinedMask_Requested = ulDeviceMask0 | ulDeviceMask1;
        if (ulCombinedMask_Current == ulCombinedMask_Requested)
        {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// Returns TRUE we should do HK switches in spanning mode.
// By default, we disallow HK switches in spanning mode except when one or both of the external devices
// (CRT or TV) has been disconnected and the NVSVC has been started.
//
BOOLEAN  bAllowHotKeyInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    ULONG ulExternalDeviceMask;
    ULONG ulDeviceMask, ulHead, i, ulTmp;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // sanity check. Make sure we are called for spanning mode.
    //
    if (pInfo->ulTwinView_State != NVTWINVIEW_STATE_SPAN)
    {
        return(TRUE);
    }
    //
    // Construct device masks of the external devices (TV or CRT) being used in the spanning mode.
    //
    ulExternalDeviceMask = 0;
    for (i=0; i < pInfo->ulNumberDacsActive; i++)
    {
        ulHead = pInfo->ulDeviceDisplay[i];
        ulDeviceMask = pInfo->ulDeviceMask[ulHead];
        if (ulDeviceMask & (BITMASK_ALL_CRT | BITMASK_ALL_TV))
        {
            ulExternalDeviceMask |= ulDeviceMask;
        }
    }
    //
    // Now check to see if all of these are still connected
    //
    ulTmp = ulExternalDeviceMask;
    if (!RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                        NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulTmp, 
                        sizeof(ULONG)))
    {
        VideoDebugPrint((1, "Something wrong. RM failed for CHECK_CONNECTED_DEVICES\n"));
        return(FALSE);
    }
    if (ulTmp != ulExternalDeviceMask)
    {
        //
        // We need to allow the HK switch since one or both of the external devices are missing.
        // We can do the switch only if the NVSVC has started.
        //
        if (hwDeviceExtension->ulNVSVCStatus == NVSVC_STATUS_STARTED)
        {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// Returns TRUE if we should not do hot key swtiches.
// Returns FALSE if we should do hot key switches.
// The current set of conditions for which we do not do hotkeying are
// 1. we are in full screen DOS mode. Let BIOS handle it.
// 2. we are in spanning mode.
// 3. Video app is active: BUGBUG: Not implemented yet.
//
BOOLEAN ACPIValidateChildStateShouldFail(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    

    // Note: The FSDOS or VGA mode boot case are now handled in nvSetChildState() call.

    // Detect if we are in spanning mode.
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        //
        // We ignore hotkeys in spanning mode if the external device (either CRT or TV) is absent.
        //
        if (!bAllowHotKeyInSpanningMode(hwDeviceExtension))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// Writes the current mode info to the registry so that the DrvEnablePdev() in the display driver can
// force GDI to use the same mode across hotkey switches. By default, GDI remembers the mode
// on each devices and tries to use that remembered mode.
//
VOID ACPIToshibaModeToRegistry(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    TOSHIBA_HOTKEY_MODE sMode;
    NV_DESKTOP_INFO *pInfo;
    ULONG ulPrimaryHead;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    ulPrimaryHead = pInfo->ulDeviceDisplay[0];

    // The display driver should invalidate this registry entry by writing the ValidMode field to zero
    // after it uses this info in either DrvEnablePdev() or DrvAssertMode(). GDI calls DrvAssertMode() if 
    // the same desktop is maintained. GDI calls DrvEnablePdev() if the remembered mode is different than the
    // current desktop for this device.
    // Also, the FindAdapter() boottime routine should set this field
    // to zero if this registry entry exists. This is to handle the pathologicl case of when the user has hit the 
    // hotkey function key but the system is powered off before the corresponding DrvEnablePdev() or DrvAssertMode()
    // is received.
    sMode.ValidMode = 1;
    sMode.Width = (USHORT)pInfo->ulDesktopWidth;
    sMode.Height = (USHORT)pInfo->ulDesktopHeight;
    sMode.Depth = (USHORT)pInfo->ulDisplayPixelDepth[ulPrimaryHead];
    sMode.RefreshRate = (USHORT)pInfo->ulDisplayRefresh[ulPrimaryHead];

    // Write the info to registry.
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"ForceGDIMode",
                                       &sMode,
                                       sizeof(TOSHIBA_HOTKEY_MODE));

}

//
// Handler for hot key switching for switching into single device configuration.
// Blows away any info existing in the TwinViewInfo registry structure (if it exists).
// Writes the full TwinViewInfo structure appropriately.
//
VOID ACPISingleDeviceSwitch(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulDeviceMask)
{
    NVTWINVIEWDATA Data;
    NVTWINVIEWDATA * pData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData0;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData1;
    ULONG ulPrimaryHead;
    NV_DESKTOP_INFO *pInfo;
    ULONG GDIWidth, GDIHeight, GDIRefreshRate, GDIDepth, GDIPrimaryHead;
    ULONG i;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulRet;

    // FindModeEntry() related fields.
    LPDISPDATA  lpDispData;
    LPMODEINFO  lpModeDesc;
    LPMODEOUT   lpModeOut;
    LPMODEINFO  lpModeNew;
    ULONG       ulFrequencyHead;
    DISPDATA    DispData;
    MODEINFO    ModeDesc;
    MODEOUT     ModeOut;
    MODEINFO    ModeNew;
    ULONG       ulDeviceType, ulTVFormat, ulIndex;
    LPEDID_UNIT pEdidUnit;


    ulDeviceType = MaskToDeviceType(ulDeviceMask);
    ulIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
    ulTVFormat = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.
    pInfo = &HwDeviceExtension->DeskTopInfo;

    pData = &Data;
    pData->dwState = NVTWINVIEW_STATE_NORMAL;
    pData->dwOrientation = 0;
    pData->dwAllDeviceMask = pInfo->ulAllDeviceMask;
    pData->dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
    pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];

    // Initialize the rectangles to zeros.
    pData->DeskTopRectl.left = 0;
    pData->DeskTopRectl.top = 0;
    pData->DeskTopRectl.right = 0;
    pData->DeskTopRectl.bottom = 0;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.left = 0;
        pDevData->VirtualRectl.top = 0;
        pDevData->VirtualRectl.right = 0;
        pDevData->VirtualRectl.bottom = 0;
        pDevData->PhysicalRectl.left = 0;
        pDevData->PhysicalRectl.top = 0;
        pDevData->PhysicalRectl.right = 0;
        pDevData->PhysicalRectl.bottom = 0;
        pDevData->dwBpp = 0;
        pDevData->dwRefresh = 0;
        pDevData->dwDeviceMask = BITMASK_INVALID_DEVICE;
        pDevData->dwDeviceType = INVALID_DEVICE_TYPE;
        pDevData->dwTVFormat = 0;
        pDevData->dwNumPhysModes = 0;
        pDevData->dwNumVirtualModes = 0;
    }


    // Get our current desktop info
    GDIWidth = pInfo->ulDesktopWidth;
    GDIHeight = pInfo->ulDesktopHeight;

    // If currently we are in spanning mode, we need to half the resolution. Careful of the special
    // 6x4, 8x6 and 10x7 modes in spanning mode.
    if (bQueryInSpanningMode(HwDeviceExtension))
    {
        if HORIZONTAL_MODE(GDIWidth, GDIHeight)
        {
            GDIWidth /= 2;
        }
        else
        if VERTICAL_MODE(GDIWidth, GDIHeight)
        {
            GDIHeight /= 2;
        }
    }

    
    GDIPrimaryHead = pInfo->ulDeviceDisplay[0];
    GDIRefreshRate = pInfo->ulDisplayRefresh[GDIPrimaryHead];
    GDIDepth = pInfo->ulDisplayPixelDepth[GDIPrimaryHead];

    // Set the desktopRectl with this info.
    // Note that we _have_ to maintain the same width, height and depth. We could get away with
    // a different refresh rate.
    pData->DeskTopRectl.right = GDIWidth;
    pData->DeskTopRectl.bottom = GDIHeight;


    // Ask the resman what head to use for this device.
    // Ask ResMan what head to use.
    nvConfig.DevicesConfig = ulDeviceMask;
    nvConfig.OldDevicesConfig = 0;
    nvConfig.OldDevicesAllocationMap = 0;
    nvConfig.DevicesAllocationMap = 0;


    if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
    {

        VideoDebugPrint((0, "ACPISingleDeviceSwitch - Cannot get DEVICES_CONFIG value from RM\n"));
    }
    else
    {
        if (nvConfig.DevicesAllocationMap > 1)
        {
            VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
        }


        if (nvConfig.DevicesAllocationMap == 0)
        {
            pDevData0->dwDeviceMask = ulDeviceMask;
            pDevData0->dwDeviceType = ulDeviceType;
            pDevData0->dwTVFormat = ulTVFormat;
            pDevData0->VirtualRectl.right = GDIWidth;
            pDevData0->VirtualRectl.bottom = GDIHeight;
            pDevData0->PhysicalRectl.right = GDIWidth;
            pDevData0->PhysicalRectl.bottom = GDIHeight;
            pDevData0->dwBpp = GDIDepth;
            pDevData0->dwRefresh = GDIRefreshRate;

            pDevData1->dwDeviceMask = BITMASK_INVALID_DEVICE;
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
        if (nvConfig.DevicesAllocationMap == 1)
        {
            pDevData1->dwDeviceMask = ulDeviceMask;
            pDevData1->dwDeviceType = ulDeviceType;
            pDevData1->VirtualRectl.right = GDIWidth;
            pDevData1->VirtualRectl.bottom = GDIHeight;
            pDevData1->PhysicalRectl.right = GDIWidth;
            pDevData1->PhysicalRectl.bottom = GDIHeight;
            pDevData1->dwBpp = GDIDepth;
            pDevData1->dwRefresh = GDIRefreshRate;

            pDevData0->dwDeviceMask = BITMASK_INVALID_DEVICE;
            pData->dwDeviceDisplay[0] = 1;
            pData->dwDeviceDisplay[1] = 0;
        }
    }

    ulPrimaryHead = pData->dwDeviceDisplay[0];


    // Now see if the current desktop can be supported natively on this device.
    // If so, we will use the same dimensions for the physical mode also.
    // Otherwise, we will have to use pan-scan.
    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    ulFrequencyHead = ulPrimaryHead;
    if (ulPrimaryHead == 1 && ulDeviceType != MONITOR_TYPE_VGA)
    {
        ulFrequencyHead = 0;
    }
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = ulPrimaryHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    // Now validate against the pixel frequency of the head.
    lpModeDesc->dwXRes = GDIWidth;
    lpModeDesc->dwYRes = GDIHeight;
    lpModeDesc->dwBpp  = GDIDepth;
    lpModeDesc->dwRefreshRate   = GDIRefreshRate;
    lpModeDesc->dwOriginalRefreshRate = GDIRefreshRate;
    lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->dwTVFormat = ulTVFormat;

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)ulTVFormat;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    // We are not interested in the mode timings but just to see if this is a valid mode.
    VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                     ulDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid)); 


    if (ulDeviceType == MONITOR_TYPE_NTSC || ulDeviceType == MONITOR_TYPE_PAL)
    {
        ulRet = 0;

        if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871)
        {
            if (lpModeDesc->dwXRes > 1024 || lpModeDesc->dwYRes > 768 || lpModeDesc->dwRefreshRate != 60)
            { 
                // Not a valid mode. Limit it to 1024x768x60HZ.
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 1024;
                lpModeNew->dwYRes = 768;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
            }
        }
        else if (lpModeDesc->dwXRes > 800 || lpModeDesc->dwYRes > 600 || lpModeDesc->dwRefreshRate != 60)
        {
            // Not a valid mode. Limit to 800x600x60
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 800;
                lpModeNew->dwYRes = 600;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
        }
    }
    else
    {
        // Not TV. Ask the common modeset code.
        EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                              lpModeDesc, lpModeOut, lpModeNew);
        ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    }

    VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                     lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

    if (ulRet != 0)
    {
        // This mode is not physically supported.
        // Use the recommended physically supported mode info - width, height and refresh.
        // We can not change the depth.
        if (ulPrimaryHead == 0)
        {
            pDevData0->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData0->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData0->dwRefresh = lpModeNew->dwRefreshRate;
        }
        if (ulPrimaryHead == 1)
        {
            pDevData1->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData1->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData1->dwRefresh = lpModeNew->dwRefreshRate;
        }
    }

    NVSetRegistryTwinviewInfo(HwDeviceExtension, pData);

    // For Toshiba, update the desired desktop mode info.
    if (HwDeviceExtension->UseHotKeySameMode)
    {
        ACPIToshibaModeToRegistry(HwDeviceExtension);
    }

    // Update the DesktopInfo structure of hwDevExtension since DrvGetModes() will get called before
    // DrvASsertMode().
    pInfo->ulNumberDacsActive = 1;
    for (i = 0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];

        pInfo->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
        pInfo->ulDeviceMask[i] = pDevData->dwDeviceMask;
        pInfo->ulDeviceType[i] = pDevData->dwDeviceType;
        pInfo->ulTVFormat[i] = pDevData->dwTVFormat;
    }
    return;
}


//
// Handler for hot key switching for switching into dual device configuration.
// Blows away any info existing in the TwinViewInfo registry structure (if it exists).
// Writes the full TwinViewInfo structure appropriately.
//
VOID ACPIDualDeviceSwitch(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1)
{
    NVTWINVIEWDATA Data;
    NVTWINVIEWDATA * pData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData0;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData1;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
    ULONG ulHead;
    NV_DESKTOP_INFO *pInfo;
    ULONG GDIWidth, GDIHeight, GDIRefreshRate, GDIDepth, GDIPrimaryHead;
    ULONG i;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulRet;
    ULONG ulIndex;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    ULONG ulTmp;

    #define CRT_MASK 0x1
    #define DFP_MASK 0x10000
    #define TV_MASK 0x100

    // FindModeEntry() related fields.
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulDeviceType0, ulTVFormat0, ulIndex0;
    ULONG ulDeviceType1, ulTVFormat1, ulIndex1;

    HwDeviceExtension = hwDeviceExtension;


    if (ulDeviceMask0 > ulDeviceMask1)
    {
        // For ease of interacting with the resman to get the devices_configuration, we want to keep
        // deviceMask0 to be the lesser of the mask
        ulTmp = ulDeviceMask0;
        ulDeviceMask0 = ulDeviceMask1;
        ulDeviceMask1 = ulTmp;
    }

    ulDeviceType0 = MaskToDeviceType(ulDeviceMask0);
    ulIndex0 = ConvertDeviceMaskToIndex(ulDeviceMask0);
    ulTVFormat0 = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.
    ulDeviceType1 = MaskToDeviceType(ulDeviceMask1);
    ulIndex1 = ConvertDeviceMaskToIndex(ulDeviceMask1);
    ulTVFormat1 = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.

    pInfo = &HwDeviceExtension->DeskTopInfo;

    pData = &Data;
    pData->dwState = NVTWINVIEW_STATE_CLONE;
    pData->dwOrientation = 0;
    pData->dwAllDeviceMask = pInfo->ulAllDeviceMask;
    pData->dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    pData->dwDeviceDisplay[0] = 0;
    pData->dwDeviceDisplay[1] = 1;
    pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
    pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];

    // Initialize the rectangles to zeros.
    pData->DeskTopRectl.left = 0;
    pData->DeskTopRectl.top = 0;
    pData->DeskTopRectl.right = 0;
    pData->DeskTopRectl.bottom = 0;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.left = 0;
        pDevData->VirtualRectl.top = 0;
        pDevData->VirtualRectl.right = 0;
        pDevData->VirtualRectl.bottom = 0;
        pDevData->PhysicalRectl.left = 0;
        pDevData->PhysicalRectl.top = 0;
        pDevData->PhysicalRectl.right = 0;
        pDevData->PhysicalRectl.bottom = 0;
        pDevData->dwBpp = 0;
        pDevData->dwRefresh = 0;
        pDevData->dwDeviceMask = BITMASK_INVALID_DEVICE;
        pDevData->dwDeviceType = INVALID_DEVICE_TYPE;
        pDevData->dwTVFormat = 0;
        pDevData->dwNumPhysModes = 0;
        pDevData->dwNumVirtualModes = 0;
    }


    // Get our current desktop info
    
    GDIWidth = pInfo->ulDesktopWidth;
    GDIHeight = pInfo->ulDesktopHeight;
    GDIPrimaryHead = pInfo->ulDeviceDisplay[0];
    GDIRefreshRate = pInfo->ulDisplayRefresh[GDIPrimaryHead];
    GDIDepth = pInfo->ulDisplayPixelDepth[GDIPrimaryHead];

    // Set the desktopRectl with this info.
    // Note that we _have_ to maintain the same width, height and depth. We could get away with
    // a different refresh rate.
    pData->DeskTopRectl.right = GDIWidth;
    pData->DeskTopRectl.bottom = GDIHeight;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.right = GDIWidth;
        pDevData->VirtualRectl.bottom = GDIHeight;
        pDevData->PhysicalRectl.right = GDIWidth;
        pDevData->PhysicalRectl.bottom = GDIHeight;
        pDevData->dwBpp = GDIDepth;
        pDevData->dwRefresh = GDIRefreshRate;
    }


    // Ask the resman what head to use for these devices.
    // Ask ResMan what head to use.
    nvConfig.DevicesConfig = ulDeviceMask0 | ulDeviceMask1;
    nvConfig.OldDevicesConfig = 0;
    nvConfig.OldDevicesAllocationMap = 0;
    nvConfig.DevicesAllocationMap = 0;


    if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
    {

        VideoDebugPrint((0, "ACPIDualDeviceSwitch - Cannot get DEVICES_CONFIG value from RM\n"));
    }
    else
    {
        // We got a successful head assignment for both the devices.
        switch (nvConfig.DevicesAllocationMap)
        {
        case 0x10:
            // Head assignment 1, 0
            pDevData0->dwDeviceMask = ulDeviceMask0;
            pDevData0->dwDeviceType = ulDeviceType0;
            pDevData0->dwTVFormat = ulTVFormat0;
            pDevData1->dwDeviceMask = ulDeviceMask1;
            pDevData1->dwDeviceType = ulDeviceType1;
            pDevData1->dwTVFormat = ulTVFormat1;
            break;
        case 0x01:
            // Head assignment 0, 1
            pDevData0->dwDeviceMask = ulDeviceMask1;
            pDevData0->dwDeviceType = ulDeviceType1;
            pDevData0->dwTVFormat = ulTVFormat1;
            pDevData1->dwDeviceMask = ulDeviceMask0;
            pDevData1->dwDeviceType = ulDeviceType0;
            pDevData1->dwTVFormat = ulTVFormat0;
            break;
        default:
            VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
            break;
        }

        // The combinations we have are: CRT+DFP, DFP+TV, CRT+TV.
        // Make sure the primary head is preferably CRT, DFP, TV in that order because they typically support
        // more number of modes in that order. One of clone mode's restriction is that all modes must
        // be natively supported by the primary device per Peter Daifuku's specs.
        if ((pDevData0->dwDeviceMask == DFP_MASK && pDevData1->dwDeviceMask == CRT_MASK) ||
            (pDevData0->dwDeviceMask == TV_MASK && pDevData1->dwDeviceMask == DFP_MASK) ||
            (pDevData0->dwDeviceMask == TV_MASK && pDevData1->dwDeviceMask == CRT_MASK))
        {
            // Swap the heads.
            pData->dwDeviceDisplay[0] = 1;
            pData->dwDeviceDisplay[1] = 0;
        }
        else
        {
            // Keep the same order
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
    }

    


    // Now see if the current desktop can be supported natively on this device.
    // If so, we will use the same dimensions for the physical mode also.
    // Otherwise, we will have to use pan-scan.
    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = GDIWidth;
    lpModeDesc->dwYRes = GDIHeight;
    lpModeDesc->dwBpp = GDIDepth;
    lpModeDesc->dwRefreshRate = GDIRefreshRate;
    lpModeDesc->dwOriginalRefreshRate = GDIRefreshRate;

    for (i = 0; i < NV_NO_DACS; i++)
    {
        LPEDID_UNIT pEdidUnit;
        ulHead = pData->dwDeviceDisplay[i];
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[ulHead];
        ulIndex = ConvertDeviceMaskToIndex(pDevData->dwDeviceMask);
        pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
        ulFrequencyHead = ulHead;
        if (ulHead == 1 && pDevData->dwDeviceType != MONITOR_TYPE_VGA)
        {
            ulFrequencyHead = 0;
        }
        if (pEdidUnit->Valid)
        {
            lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
        }
        else
        {
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        }
        lpDispData->dwCRTCIndex = ulHead;
        lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
        lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
        lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];

        // Now validate against the pixel frequency of the head.

        lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->dwTVFormat = pDevData->dwTVFormat;

        lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->MIDevData.cFormat   = (CHAR)pDevData->dwTVFormat;
        lpModeDesc->MIDevData.cReserved = 0x0;

        // Call the modeset DLL to see if this mode is valid.
        // We are not interested in the mode timings but just to see if this is a valid mode.
        VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                         pDevData->dwDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid)); 

        if (pDevData->dwDeviceType == MONITOR_TYPE_NTSC || pDevData->dwDeviceType == MONITOR_TYPE_PAL)
        {
            ulRet = 0;

            if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871) 
            {
                if (lpModeDesc->dwXRes > 1024 || lpModeDesc->dwYRes > 768 || lpModeDesc->dwRefreshRate != 60)
                { 
                    // Not a valid mode. Limit it to 1024x768x60HZ.
                    ulRet = 1; // Any non-zero value will do.
                    lpModeNew->dwXRes = 1024;
                    lpModeNew->dwYRes = 768;
                    lpModeNew->dwBpp = lpModeDesc->dwBpp;
                    lpModeNew->dwRefreshRate = 60; 
                    lpModeNew->dwDevType = lpModeDesc->dwDevType;
                    lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
                }
            }
            else if (lpModeDesc->dwXRes > 800 || lpModeDesc->dwYRes > 600 || lpModeDesc->dwRefreshRate != 60)
            {
                // Not a valid mode. Limit to 800x600x60
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 800;
                lpModeNew->dwYRes = 600;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
            }
        }
        else
        {
            EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
            ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                                  lpModeDesc, lpModeOut, lpModeNew);
            ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        }

        VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
        VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                         lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

        if (ulRet != 0)
        {
            // This mode is not physically supported.
            // Use the recommended physically supported mode info - width, height and refresh.
            // We can not change the depth.

            pDevData->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData->dwRefresh = lpModeNew->dwRefreshRate;

        }

    }

    // Update the DesktopInfo structure of hwDevExtension since DrvGetModes() will get called before
    // DrvASsertMode().
    pInfo->ulNumberDacsActive = 2;
    for (i = 0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];

        pInfo->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
        pInfo->ulDeviceMask[i] = pDevData->dwDeviceMask;
        pInfo->ulDeviceType[i] = pDevData->dwDeviceType;
        pInfo->ulTVFormat[i] = pDevData->dwTVFormat;
    }

    ChoosePrimaryDevice(HwDeviceExtension, pData);

    NVSetRegistryTwinviewInfo(HwDeviceExtension, pData);

    // For Toshiba, update the desired desktop mode info.
    if (HwDeviceExtension->UseHotKeySameMode)
    {
        ACPIToshibaModeToRegistry(HwDeviceExtension);
    }

     return;
}

//
// Reads the latest connected device mask into the hwDeviceExtension. 
// This is required for Dell. This is a no-op for Toshiba since the 
// connected device mask never changes.
//
VOID GetConnectedDevicesMask(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG ulPrev;
    NV_DESKTOP_INFO *pDeskTopInfo;

    pDeskTopInfo = (NV_DESKTOP_INFO *)&hwDeviceExtension->DeskTopInfo;
    ulPrev = hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask;
    pDeskTopInfo->ulConnectedDeviceMask = pDeskTopInfo->ulAllDeviceMask;

    if (RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &pDeskTopInfo->ulConnectedDeviceMask, 
                            sizeof(pDeskTopInfo->ulConnectedDeviceMask)))
    {

        //
        // success.
        //
        if (pDeskTopInfo->ulConnectedDeviceMask == 0)
        {
            VideoDebugPrint((0,"Oops! ConnectedDevicemask is 0. Assume a CRT\n"));
            pDeskTopInfo->ulConnectedDeviceMask = 0x1;
        }
    }
    else
    {
        //
        // The resman had issues with our request, so spew a warning
        //
        VideoDebugPrint((0, "GetConnectedDevicesMask() -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
    }

    //
    // If the new connected device mask is different than the previous one,
    // print a informational debug message.
    //
    if (ulPrev != pDeskTopInfo->ulConnectedDeviceMask)
    {
        VideoDebugPrint((1, "GetConnectedDevicesMask(): Previous ConnectedDevMask: 0x%x different than newConnectedMask: 0x%x\n",
                         ulPrev, pDeskTopInfo->ulConnectedDeviceMask));
    }
    else
    {
        VideoDebugPrint((2, "GetConnectedDevicesMask(): Previous ConnectedDevMask: 0x%x Matches with newConnectedMask: 0x%x\n",
                         ulPrev, pDeskTopInfo->ulConnectedDeviceMask));
    }
}


ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the nVidia graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    TRUE if the child device existed, FALSE if it did not.

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG                Status;
    ULONG                ulDacs;
    ULONG                ulDeviceMask, i, EDIDIndex;
    LPEDID_UNIT          pEdidUnit;

    //
    // Everytime enter here, need to invalidate EDID first
    //
    if (hwDeviceExtension->bNeedRetrieveEDID)
    {
        NVInitialize_DacsAndEDID(hwDeviceExtension, FALSE);
        hwDeviceExtension->bNeedRetrieveEDID = FALSE;
    }

    switch (ChildEnumInfo->ChildIndex) {

    case 0:
        //
        // This system supports ACPI. So mark it so. Note that only laptops seem to call this.
        // Desktops do not call this case.
        //
        hwDeviceExtension->ACPISystem = 1;
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            hwDeviceExtension->pDualViewAssociatedDE->ACPISystem = 1;
        }

        //
        // Convert the ACPI Id to a device mask.
        //
        ulDeviceMask = ACPIHwIdToMask(ChildEnumInfo->ACPIHwId);
        if (ulDeviceMask == 0)
        {
            Status = VIDEO_ENUM_NO_MORE_DEVICES;
            return(Status);
        }
        
        //
        // Convert it's mask into an index inorder to retrieve it's EDID structure.
        //
        EDIDIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
        pEdidUnit = hwDeviceExtension->EdidCollection->HeadMaps[EDIDIndex];


        //
        // If the device is a DFP and the registry tells us not to export the EDID, 
        // do not export the EDID.
        // This is to fix Win2k PnP bug of failing to install new PnP monitors
        //
        if (ulDeviceMask == 0x10000 && hwDeviceExtension->DFPAsDefaultMonitor)
        {
            VideoDebugPrint((1, "Not exporting the EDID for DFP per the registry setting\n"));
            *pChildType = Monitor;
            *pHwId = ChildEnumInfo->ACPIHwId;
            Status = VIDEO_ENUM_MORE_DEVICES;
            break;
        }

        //
        // Now we know our device mask. Return the EDID of this device, if it has a valid EDID.
        //
        if (pEdidUnit->Valid)
        {
            // Transfer the real EDID data. 
            VideoPortMoveMemory(pvChildDescriptor, pEdidUnit->EDIDBuffer, pEdidUnit->Size);
        }


        //
        // Set the child type as monitor
        //
        *pChildType = Monitor;

        //
        // Set the UID same as the ACPIHwId
        //
        *pHwId = ChildEnumInfo->ACPIHwId;
        Status = VIDEO_ENUM_MORE_DEVICES;
        break;


    case 1:
    case 2:
        //
        // If we are on a ACPI system (such as a laptop), we do not want to handle this case.
        // This case will handle non-ACPI systems (such as desktops).
        //
        if (hwDeviceExtension->ACPISystem)
        {
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }

        //
        // For Dualview, we are going to return 2 CRT children
        //
        if (hwDeviceExtension->pDualViewAssociatedDE == NULL && 
            ChildEnumInfo->ChildIndex == 2)
        {
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //
        *pChildType = Monitor;

        //**********************************************************************
        // Unattended install with Intel 810 present:
        // Make sure to SKIP this call, if the device has NOT been mapped!!!
        // (Skip this function if currently running unattended install with
        // an Intel 810)
        //**********************************************************************

        //
        // Obtain the EDID structure via DDC.
        //

        if ( (hwDeviceExtension->DeviceMappingFailed == FALSE) &&
             (GetDdcInformation(HwDeviceExtension,
                                ChildEnumInfo->ChildIndex-1,
                                (PUCHAR) pvChildDescriptor,
                                ChildEnumInfo->ChildDescriptorSize))    )
        {
            *pHwId = QUERY_MONITOR_ID + (ChildEnumInfo->ChildIndex-1);

            VideoDebugPrint((1, "NvGetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID + (ChildEnumInfo->ChildIndex-1);

            VideoDebugPrint((1, "NvGetChildDescriptor - DDC not supported\n"));

        }

        Status = VIDEO_ENUM_MORE_DEVICES;
        break;

#ifdef NVPE
        case 3:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_cap",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVCAP_I2C_DEVICE_ID;
                    *pChildType = Other;
                    //VideoPortMoveMemory(pvChildDescriptor, L"nvcap", sizeof(L"nvcap")); //strPnpId, wcslen(strPnpId));
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

        case 4:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_xbar",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVXBAR_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

        case 5:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_tuner",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVTUNER_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;
        case 6:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_tvsnd",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVTVSND_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

#endif  // #ifdef NVPE

    case 7:
        //
        // Miniport will enumerate TV as a child device if the SBIOS has not done so. This is the 
        // case with Dell laptop where the SBIOS does not enumerate TV as an ACPI device 0x200 and hence
        // miniport would never get any power management calls for TV.
        //
        if (hwDeviceExtension->EnumerateTVAsACPIDevice)
        {
            VideoDebugPrint((1, "NvGetChildDescriptor(): case 6: For TV: returning 0x200\n"));
            //
            // 0x200 is the ACPI recommended HwDevID for TV. (QUERY_ACPI_TV_ID)
            //
            *pHwId = QUERY_ACPI_TV_ID;
            *pChildType = Monitor;
            Status = VIDEO_ENUM_MORE_DEVICES;
            break;
        }
        else
        {
            VideoDebugPrint((1, "NvGetChildDescriptor(): case 6: Not enumerating TV\n"));
            //
            // The return status should be VIDEO_ENUM_INVALID_DEVICE so that the OS enumerates further for more
            // devices.
            //
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }
        break;

    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        Status = VIDEO_ENUM_MORE_DEVICES;
        break;


    default:

        hwDeviceExtension->bNeedRetrieveEDID = TRUE;
        Status = VIDEO_ENUM_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

VP_STATUS
NVGetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    ULONG *pOut;
    ULONG *pIn;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i;
    ULONG ulFoundActiveMatch;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
    ULONG NVCplInitiated;
    ULONG RegStatus, TwinViewInfoRegStatus;
    ULONG ulCombinedMask;

    RequestPacket->StatusBlock->Information = sizeof(ULONG);

    if (RequestPacket->OutputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_GET_CHILD_STATE - ERROR_INSUFFICIENT_OUTPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if (RequestPacket->InputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_GET_CHILD_STATE - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pOut = (ULONG *) RequestPacket->OutputBuffer;
    pIn = (ULONG *) RequestPacket->InputBuffer;
    ulACPIHwId = *pIn;

    VideoDebugPrint((1, "\nW32StartIO - GetChildState: HWId: 0x%x\n",ulACPIHwId));

    if (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 2)
    {
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            if (hwDeviceExtension->ACPISystem == 0)
            {
                if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
                    ulACPIHwId == QUERY_MONITOR_ID)
                {
                    *pOut = 1 | ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? VIDEO_CHILD_DETACHED : 0);
                    VideoDebugPrint((1,"FAIL: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
                    return NO_ERROR;
                }
                if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID2 ||
                    ulACPIHwId == QUERY_MONITOR_ID2)
                {
                    *pOut = 1 | ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? 0 : VIDEO_CHILD_DETACHED);
                    VideoDebugPrint((1,"FAIL: DDC_MONITOR_ID\n"));
                    return NO_ERROR;
                }
            }
            else
            {
                ASSERT((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) != 0);
                //
                // Dualview is enabled on an laptop.  All children need to be re-assigned
                //
                if ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) &&
                    (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
                {
                    NV_DESKTOP_INFO *pDeskTop = &hwDeviceExtension->DeskTopInfo;
                    ULONG drivingDeviceId = 0;
                    
                    ulDeviceMask = pDeskTop->ulDeviceMask[pDeskTop->ulDeviceDisplay[0]];
                    
                    if (ulDeviceMask & BITMASK_ALL_CRT)
                        drivingDeviceId = QUERY_ACPI_CRT_ID;
                    else if (ulDeviceMask & BITMASK_ALL_DFP)
                        drivingDeviceId = QUERY_ACPI_DFP_ID;
                    else if (ulDeviceMask & BITMASK_ALL_TV)
                        drivingDeviceId = QUERY_ACPI_TV_ID;
                    
                    *pOut = (drivingDeviceId == ulACPIHwId) ? 1 : VIDEO_CHILD_DETACHED;
                    return NO_ERROR;
                }
            }
        }

        else if (hwDeviceExtension->ACPISystem == 0)
        {
            //
            // If the device is the  generic DDC or NON_DDC monitors that we report on desktop systems
            // (i.e. non-ACPI systems), return TRUE.
            //
            if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
                ulACPIHwId == QUERY_MONITOR_ID)
            {
                *pOut = TRUE;
                VideoDebugPrint((1,"SUCCESS: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
                return NO_ERROR;
            }
        }

    }

    //
    // For single headed cards on non-ACPI systems (such as desktops), 
    // we want to enable the "hide modes" checkbox in the NT panel,
    // so return TRUE.
    //
    if ((hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 1) &&
        (hwDeviceExtension->ACPISystem == 0))
    {
        if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
            ulACPIHwId == QUERY_MONITOR_ID)
        {
            *pOut = TRUE;
            VideoDebugPrint((1,"SUCCESS: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
            return NO_ERROR;
        }
    }

    //
    // Read in the twinview info structure
    //
    TwinViewInfoRegStatus = NVGetRegistryTwinviewInfo(hwDeviceExtension, &sData);
    if ((TwinViewInfoRegStatus == NO_ERROR) && (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 2))
    {
        if (sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            VideoDebugPrint((1,"FAIL: Spanning mode: Don't remember this resolution\n"));
            *pOut = FALSE;
            return NO_ERROR;
        }
    }


    //
    // Special cases. If we a modeswitch via nVidia panel is initiated or a modeswitch via hotkey is
    // pending, use the desired devices from the twinViewInfo structure from the registry.
    // Otherwise, sometimes the taskbar gets confused and does not resize correctly.
    // We need to do this only for the laptops since desktops does not have this "confused taskbar" problem
    // as we enumerate only one child device for the desktops.
    //
    NVCplInitiated = 0;
    RegStatus = VideoPortGetRegistryParameters(hwDeviceExtension,
                               L"NVCplInduceModeSetInitiated",
                               FALSE,
                               NVRegistryCallback,
                               &(NVCplInitiated));
    if ((RegStatus == NO_ERROR && NVCplInitiated == 1 && hwDeviceExtension->ACPISystem == 1) ||
        (hwDeviceExtension->ulHotKeyPending == 1 && hwDeviceExtension->ACPISystem == 1))
    {
        //
        // Build up the device masks from the TwinViewInfo structure if present.
        //
        RegStatus = NVGetRegistryTwinviewInfo(hwDeviceExtension, &sData);
        if (TwinViewInfoRegStatus == NO_ERROR)
        {
            ASSERT(sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_NORMAL);

            if (sData.dwState == NVTWINVIEW_STATE_CLONE)
            {
                ulCombinedMask = 0;
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[0];
                ulCombinedMask |= pDevData->dwDeviceMask;
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[1];
                ulCombinedMask |= pDevData->dwDeviceMask;
            }
            if (sData.dwState == NVTWINVIEW_STATE_NORMAL)
            {
                ulCombinedMask = 0;
                ulHead = sData.dwDeviceDisplay[0];
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[ulHead];
                ulCombinedMask |= pDevData->dwDeviceMask;
            }

            //
            // Now compare the device mask
            //
            ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
            if (ulCombinedMask & ulDeviceMask)
            {
                // The requested device is one of nvPanel specified devices. So return success.
                *pOut = TRUE;
                VideoDebugPrint((1,"SUCCESS: nvPanel/HK Initiated Spanning mode: Active\n"));
                return NO_ERROR;
            }
            else
            {
                // This device is not one of the nvPanel specified devices. So return failure by returning FALSE.
                VideoDebugPrint((1,"FAIL: nvPanel/HK Initiated Spanning mode: not present\n"));
                *pOut = FALSE;
                return NO_ERROR;
            }
        } // if TwinViewInfo registry structure
    } //if nvCpl initiated or HK pending


    //
    // Check if we are in spanning mode.  Don't want to do mode prunning here
    //
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        *pOut = FALSE;
        VideoDebugPrint((1,"GetChildState: Inactive for Spanning\n"));
        return NO_ERROR;
    }

    // See if the device actually exists.
    if (ulACPIHwId == 0)
    {
        // Ignore devId 0 for now. Return success.
        *pOut = TRUE;
    
    }
    ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);

    if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
    {
        // This device is not currently present. So return failure by returning FALSE.
        VideoDebugPrint((1,"FAIL: not present\n"));
        *pOut = FALSE;
        return NO_ERROR;
    }

    // The device is present. Now see if the device is one of the active devices.
    ulFoundActiveMatch = 0;
    for (i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        ulHead = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
        if (hwDeviceExtension->DeskTopInfo.ulDeviceMask[ulHead] == ulDeviceMask)
        {
            // We found the head for which this requested device is attached.
            ulFoundActiveMatch = 1;
        }
    }

    if (ulFoundActiveMatch)
    {
        // The requested device is one of currently active device. So return success.
        *pOut = TRUE;
        VideoDebugPrint((1,"SUCCESS: Active\n"));
    }
    else
    {
        // The requested device is not one of currently active device. So return failure.
        *pOut = FALSE;
        VideoDebugPrint((1,"FAIL: not Active\n"));
    }
    return NO_ERROR;
}

VP_STATUS
NVValidateChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    ULONG *pOut;
    VIDEO_CHILD_STATE_CONFIGURATION *pIn;
    VIDEO_CHILD_STATE * pChildState;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i, j;
    ULONG ulFoundActiveMatch;

    RequestPacket->StatusBlock->Information = sizeof(ULONG);

    if (RequestPacket->OutputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_OUTPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if (RequestPacket->InputBufferLength < sizeof(VIDEO_CHILD_STATE_CONFIGURATION))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pOut = (ULONG *) RequestPacket->OutputBuffer;
    pIn = (VIDEO_CHILD_STATE_CONFIGURATION *) RequestPacket->InputBuffer;

    if (ACPIValidateChildStateShouldFail(hwDeviceExtension))
    {
        // We are in full screen DOS mode or spanning mode. So let the BIOS handle the hot keys.
        // This device is not currently present. So return failure by returning 0.
        *pOut = 0;
        VideoDebugPrint((1,"FAIL: curently in FSDOS or Spanning\n"));
        return NO_ERROR;
    }

    if (hwDeviceExtension->pDualViewAssociatedDE)
    {
        if ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) &&
            (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
        {
            // Disable Hotkey Switch if under Dualview
            *pOut = 0;
            VideoDebugPrint((1,"FAIL: curently in FSDOS or Spanning\n"));
            return NO_ERROR;
        }
    }

    //
    // Refresh the connected device mask. 
    //
    GetConnectedDevicesMask(hwDeviceExtension);

    // Enumerate the devices. See if the device actually exists.
    // Even if one of the devices is invalid, we return failure.
    VideoDebugPrint((1, "pIN->Count: %d\n", pIn->Count));
    for (i=0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        ulACPIHwId = pChildState->Id;
        VideoDebugPrint((1, "    HwID: 0x%x, State: 0x%x\n", pChildState->Id, pChildState->State));
        if (ulACPIHwId == 0)
        {
            // continue on to processing the next device. Ignore devId 0 for now. 
            continue;
        }
        ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
        //
        // Check against the connected devices only if this device state is to be turned on.
        // The DDK specs does not say what the behavior should be based on the device state.
        // If the state is to be turned off, then it does not matter if the device is present
        // or not, so I don't return any failure in this case. Again, note that this is a subjective
        // call on my part.
        //
        if (pChildState->State == 1)
        {
            if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
            {
                // This device is not currently present. So return failure by returning 1.
                *pOut = 0;
                VideoDebugPrint((1, "FAIL: Not present\n"));
                return NO_ERROR;
            }
        }
    }
    VideoDebugPrint((1, "Return *pOut: 0x%x\n", *pOut));
    return NO_ERROR;
}

VP_STATUS
NVSetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    VIDEO_CHILD_STATE_CONFIGURATION *pIn;
    VIDEO_CHILD_STATE * pChildState;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i, j;
    ULONG ulFoundActiveMatch;
    ULONG GDIWidth, GDIHeight;
    ULONG ulDeviceMask0 = 0, ulDeviceMask1 = 0;
    ULONG ulNumTurnOn = 0;
    NV_DESKTOP_INFO * pInfo;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    
    if (RequestPacket->InputBufferLength < sizeof(VIDEO_CHILD_STATE_CONFIGURATION))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Detect if we are in spanning mode.
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        if (!bAllowHotKeyInSpanningMode(hwDeviceExtension))
        {
            // we can not return failure here since the OS will then try to use the 
            // system BIOS. So we do a fake success return here.
            VideoDebugPrint((1,"FAIL: currently in Span mode\n"));
            return NO_ERROR;
        }
    }


    pIn = (VIDEO_CHILD_STATE_CONFIGURATION *) RequestPacket->InputBuffer;

    // Count the number of devices that need to be turned on.
    // We can handle turning only 1 or 2 devices.
    VideoDebugPrint((1,"pIN->Count: %d\n",pIn->Count));
    for (i = 0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        if (pChildState->State == 1)
        {
            ulNumTurnOn++;
        }
        VideoDebugPrint((1,"    HwID: 0x%x, State: 0x%x\n",pChildState->Id, pChildState->State));
    }

    // sanity check
    if (ulNumTurnOn <= 0 || ulNumTurnOn > 2)
    {
        // return success anyway.
        VideoDebugPrint((0,"Oops! ACPI SetDevice count is invalid: 0x%x\n",ulNumTurnOn));
        return NO_ERROR;
    }

    // Enumerate the devices. See if the device actually exists.
    // Even if one of the devices is invalid, we return failure.
    for (i = 0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        ulACPIHwId = pChildState->Id;
        if (ulACPIHwId == 0)
        {
            VideoDebugPrint((0,"Oops! Don't know how to handle Device of zero in SetDevice\n"));
            return ERROR_INVALID_PARAMETER;
        }
        ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
        //
        // Check against the connected devices only if this device state is to be turned on.
        // The DDK specs does not say what the behavior should be based on the device state.
        // If the state is to be turned off, then it does not matter if the device is present
        // or not, so I don't return any failure in this case. Again, note that this is a subjective
        // call on my part.
        //
        if (pChildState->State == 1)
        {
            if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
            {
                // This device is not currently present. So return failure by returning 1.
                VideoDebugPrint((0,"Oops! DeviceMask: 0x%x is not in the ConnectedDeviceMask: 0x%x\n",
                                 ulDeviceMask,hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask)); 
                return ERROR_INVALID_PARAMETER;
            }
        }

        // If the state of the device is set to 0, I don't know how to handle it.
        if (pChildState->State == 1)
        {
            // Initialize the first and second head's device masks.
            if (ulDeviceMask0 == 0)
            {
                ulDeviceMask0 = ulDeviceMask;
            }
            if (ulDeviceMask0 != 0)
            {
                // We have already set the DeviceMask0. So now set DeviceMask1
                ulDeviceMask1 = ulDeviceMask;
            }
        }

    }

    // Handle the case when we were called to turn off one device and turn on another
    if (pIn->Count == 2 && ulNumTurnOn == 1)
    {
        // see which of the two devices were asked to be turned on.
        if (ulDeviceMask1)
        {
            ulDeviceMask0 = ulDeviceMask1;
        }

    }
    // We were called with valid devices. Handle the single device and dual device cases separately.
    if (ulNumTurnOn == 1)
    {
        ACPISingleDeviceSwitch(hwDeviceExtension, ulDeviceMask0);
    }
    if (ulNumTurnOn == 2)
    {
        //
        // Special case. if we are in spanning mode and the two requested devices are the same, we do 
        // nothing and return success.
        //
        if (bQuerySpanDualDevicesSame(hwDeviceExtension, ulDeviceMask0, ulDeviceMask1))
        {
            VideoDebugPrint((1,"In spanning mode and same devices. So doing dummy return in nvSetChildState()\n")); 
            //
            // Now set the hotkeyPending flag so that the display driver does not obey BOOT_DEVICES.
            //
            hwDeviceExtension->ulHotKeyPending = 1;
            return NO_ERROR;
        }
        ACPIDualDeviceSwitch(hwDeviceExtension, ulDeviceMask0, ulDeviceMask1);
        //
        // Irrespective of dell or toshiba, if we get here, we know both dacs are connected.
        // So set NumDacConnected to 2. This handles the special case of hot plugging CRT on
        // Dell and getAvailableModes() in the display driver will still be thinking there is only
        // one dac connected as no device scan would have been done.
        //
        hwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 2;
    }

    // Now set the hotkeyPending flag.
    hwDeviceExtension->ulHotKeyPending = 1;

    //
    // Detect if we are in full screen DOS mode.
    // Or if we are in VGA mode (such as via the F8 option of "VGA mode" at bootup time.
    // Here we want to pass VALIDATE_CHILD_DEVICE but fail SET_CHILD_DEVICE so that the OS will
    // call the VBIOS to do the switching. Note that the GET_CHILD_STATE has to be consistent with the
    // devices specified in VALIDATE_CGILD_DEVICE and SET_CHILD_DEVICE.
    //
    if (bQueryInFSDOSorVGAMode(hwDeviceExtension))
    {
        VideoDebugPrint((1,"FAIL: currently in FSDOS or VGA mode\n"));
        //
        // Unset the hotkeyPending flag since we are not really doing the device switching but the VBIOS is.
        //
        hwDeviceExtension->ulHotKeyPending = 0;
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


//**************************************************************************************
//
// Function: NVSwitchDualView
//
// DESCRIPTION:
//  Anotify from GDI about switching to Dual View(MHS) or Single View mode.
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-display(view) device extension.
//  dwDualViewEnable    1 : View will be enabled
//                      0 : View will be disabled
//
// RETURN VALUE:
//  Status code.
//
//**************************************************************************************

VP_STATUS
NVSwitchDualView(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG                dwViewEnable
    )
{
    PHW_DEVICE_EXTENSION pHwDE1;

    VideoDebugPrint ((0, "****SwitchDualView: %s : %s\n", 
                      ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? "Secondary" : "Primary"),
                      (dwViewEnable? "On" : "Off")));

    //
    // Assume GDI always call in order of Primary, Secondary. Only after all view be called, 
    // we can decide it will be in SingleView or DualView and then take actions 
    //

    if (dwViewEnable)
        hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_VIEW_ON;
    else
        hwDeviceExtension->ulDualViewStatus &= ~DUALVIEW_STATUS_VIEW_ON;

    //
    // In the primary view call, we just set/clear ViewOn flags. 
    //        
    if (!(hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY))
    {
        return NO_ERROR;
    }

    pHwDE1 = hwDeviceExtension->pDualViewAssociatedDE;
    if ((pHwDE1->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) && 
        (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
    {
        HandleDualviewHeads(pHwDE1, TRUE);
    }
    else
    {
        HandleDualviewHeads(pHwDE1, FALSE);
    }
    return NO_ERROR;
}

#endif // #if (_WIN32_WINNT >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"
#include "modes.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//***************************************************************************************
//
// NV4 supported modes,
//
// 8bpp - all modes, all refresh rates supported
// 16bpp - all modes, all refresh rates supported
// 32bpp - 1280x1024 max at 100Hz, 1600x1200 max at 75Hz, 1920x1080 max at 72Hz, 1920x1200 max at 60Hz
//
//***************************************************************************************

U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS] =
{
    //**************************************************************************************
    // 640x480 at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 640,480,8, 60},
    {FALSE, 640,480,8, 70},
    {FALSE, 640,480,8, 72},
    {FALSE, 640,480,8, 75},
    {FALSE, 640,480,8, 85},
    {FALSE, 640,480,8, 100},
    {FALSE, 640,480,8, 120}
    },
    {
    {FALSE, 640,480,15, 60},
    {FALSE, 640,480,15, 70},
    {FALSE, 640,480,15, 72},
    {FALSE, 640,480,15, 75},
    {FALSE, 640,480,15, 85},
    {FALSE, 640,480,15, 100},
    {FALSE, 640,480,15, 120}
    },
    {
    {FALSE, 640,480,16, 60},
    {FALSE, 640,480,16, 70},
    {FALSE, 640,480,16, 72},
    {FALSE, 640,480,16, 75},
    {FALSE, 640,480,16, 85},
    {FALSE, 640,480,16, 100},
    {FALSE, 640,480,16, 120}
    },
    {
    {FALSE, 640,480,24, 60},
    {FALSE, 640,480,24, 70},
    {FALSE, 640,480,24, 72},
    {FALSE, 640,480,24, 75},
    {FALSE, 640,480,24, 85},
    {FALSE, 640,480,24, 100},
    {FALSE, 640,480,24, 120}
    },
    {
    {FALSE, 640,480,32, 60},
    {FALSE, 640,480,32, 70},
    {FALSE, 640,480,32, 72},
    {FALSE, 640,480,32, 75},
    {FALSE, 640,480,32, 85},
    {FALSE, 640,480,32, 100},
    {FALSE, 640,480,32, 120}
    },

    //***********************************************************************************
    // 320x240 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,240,8, 60},
    {FALSE, 320,240,8, 70},
    {FALSE, 320,240,8, 72},
    {FALSE, 320,240,8, 75},
    {FALSE, 320,240,8, 85},
    {FALSE, 320,240,8, 100},
    {FALSE, 320,240,8, 120}
    },
    {
    {FALSE, 320,240,15, 60},
    {FALSE, 320,240,15, 70},
    {FALSE, 320,240,15, 72},
    {FALSE, 320,240,15, 75},
    {FALSE, 320,240,15, 85},
    {FALSE, 320,240,15, 100},
    {FALSE, 320,240,15, 120}
    },
    {
    {FALSE, 320,240,16, 60},
    {FALSE, 320,240,16, 70},
    {FALSE, 320,240,16, 72},
    {FALSE, 320,240,16, 75},
    {FALSE, 320,240,16, 85},
    {FALSE, 320,240,16, 100},
    {FALSE, 320,240,16, 120}
    },
    {
    {FALSE, 320,240,24, 60},
    {FALSE, 320,240,24, 70},
    {FALSE, 320,240,24, 72},
    {FALSE, 320,240,24, 75},
    {FALSE, 320,240,24, 85},
    {FALSE, 320,240,24, 100},
    {FALSE, 320,240,24, 120}
    },
    {
    {FALSE, 320,240,32, 60},
    {FALSE, 320,240,32, 70},
    {FALSE, 320,240,32, 72},
    {FALSE, 320,240,32, 75},
    {FALSE, 320,240,32, 85},
    {FALSE, 320,240,32, 100},
    {FALSE, 320,240,32, 120}
    },
    //***********************************************************************************
    // 320x400 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 72},
    {FALSE, 320,400,8, 75},
    {FALSE, 320,400,8, 85},
    {FALSE, 320,400,8, 100},
    {FALSE, 320,400,8, 120}
    },
    {
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 72},
    {FALSE, 320,400,15, 75},
    {FALSE, 320,400,15, 85},
    {FALSE, 320,400,15, 100},
    {FALSE, 320,400,15, 120}
    },
    {
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 72},
    {FALSE, 320,400,16, 75},
    {FALSE, 320,400,16, 85},
    {FALSE, 320,400,16, 100},
    {FALSE, 320,400,16, 120}
    },
    {
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 72},
    {FALSE, 320,400,24, 75},
    {FALSE, 320,400,24, 85},
    {FALSE, 320,400,24, 100},
    {FALSE, 320,400,24, 120}
    },
    {
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 72},
    {FALSE, 320,400,32, 75},
    {FALSE, 320,400,32, 85},
    {FALSE, 320,400,32, 100},
    {FALSE, 320,400,32, 120}
    },
    //***********************************************************************************
    // 400x300 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 400,300,8, 60},
    {FALSE, 400,300,8, 70},
    {FALSE, 400,300,8, 72},
    {FALSE, 400,300,8, 75},
    {FALSE, 400,300,8, 85},
    {FALSE, 400,300,8, 100},
    {FALSE, 400,300,8, 120}
    },
    {
    {FALSE, 400,300,15, 60},
    {FALSE, 400,300,15, 70},
    {FALSE, 400,300,15, 72},
    {FALSE, 400,300,15, 75},
    {FALSE, 400,300,15, 85},
    {FALSE, 400,300,15, 100},
    {FALSE, 400,300,15, 120}
    },
    {
    {FALSE, 400,300,16, 60},
    {FALSE, 400,300,16, 70},
    {FALSE, 400,300,16, 72},
    {FALSE, 400,300,16, 75},
    {FALSE, 400,300,16, 85},
    {FALSE, 400,300,16, 100},
    {FALSE, 400,300,16, 120}
    },
    {
    {FALSE, 400,300,24, 60},
    {FALSE, 400,300,24, 70},
    {FALSE, 400,300,24, 72},
    {FALSE, 400,300,24, 75},
    {FALSE, 400,300,24, 85},
    {FALSE, 400,300,24, 100},
    {FALSE, 400,300,24, 120}
    },
    {
    {FALSE, 400,300,32, 60},
    {FALSE, 400,300,32, 70},
    {FALSE, 400,300,32, 72},
    {FALSE, 400,300,32, 75},
    {FALSE, 400,300,32, 85},
    {FALSE, 400,300,32, 100},
    {FALSE, 400,300,32, 120}
    },
    //***********************************************************************************
    // 480x360 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 480,360,8, 60},
    {FALSE, 480,360,8, 70},
    {FALSE, 480,360,8, 72},
    {FALSE, 480,360,8, 75},
    {FALSE, 480,360,8, 85},
    {FALSE, 480,360,8, 100},
    {FALSE, 480,360,8, 120}
    },
    {
    {FALSE, 480,360,15, 60},
    {FALSE, 480,360,15, 70},
    {FALSE, 480,360,15, 72},
    {FALSE, 480,360,15, 75},
    {FALSE, 480,360,15, 85},
    {FALSE, 480,360,15, 100},
    {FALSE, 480,360,15, 120}
    },
    {
    {FALSE, 480,360,16, 60},
    {FALSE, 480,360,16, 70},
    {FALSE, 480,360,16, 72},
    {FALSE, 480,360,16, 75},
    {FALSE, 480,360,16, 85},
    {FALSE, 480,360,16, 100},
    {FALSE, 480,360,16, 120}
    },
    {
    {FALSE, 480,360,24, 60},
    {FALSE, 480,360,24, 70},
    {FALSE, 480,360,24, 72},
    {FALSE, 480,360,24, 75},
    {FALSE, 480,360,24, 85},
    {FALSE, 480,360,24, 100},
    {FALSE, 480,360,24, 120}
    },
    {
    {FALSE, 480,360,32, 60},
    {FALSE, 480,360,32, 70},
    {FALSE, 480,360,32, 72},
    {FALSE, 480,360,32, 75},
    {FALSE, 480,360,32, 85},
    {FALSE, 480,360,32, 100},
    {FALSE, 480,360,32, 120}
    },

    //***********************************************************************************
    // 512x384. at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 512,384,8, 60},
    {FALSE, 512,384,8, 70},
    {FALSE, 512,384,8, 72},
    {FALSE, 512,384,8, 75},
    {FALSE, 512,384,8, 85},
    {FALSE, 512,384,8, 100},
    {FALSE, 512,384,8, 120},
    },
    {
    {FALSE, 512,384,15, 60},
    {FALSE, 512,384,15, 70},
    {FALSE, 512,384,15, 72},
    {FALSE, 512,384,15, 75},
    {FALSE, 512,384,15, 85},
    {FALSE, 512,384,15, 100},
    {FALSE, 512,384,15, 120},
    },
    {
    {FALSE, 512,384,16, 60},
    {FALSE, 512,384,16, 70},
    {FALSE, 512,384,16, 72},
    {FALSE, 512,384,16, 75},
    {FALSE, 512,384,16, 85},
    {FALSE, 512,384,16, 100},
    {FALSE, 512,384,16, 120},
    },
    {
    {FALSE, 512,384,24, 60},
    {FALSE, 512,384,24, 70},
    {FALSE, 512,384,24, 72},
    {FALSE, 512,384,24, 75},
    {FALSE, 512,384,24, 85},
    {FALSE, 512,384,24, 100},
    {FALSE, 512,384,24, 120},
    },
    {
    {FALSE, 512,384,32, 60},
    {FALSE, 512,384,32, 70},
    {FALSE, 512,384,32, 72},
    {FALSE, 512,384,32, 75},
    {FALSE, 512,384,32, 85},
    {FALSE, 512,384,32, 100},
    {FALSE, 512,384,32, 120},
    },
    //*************************************************************************************
    // 640x400.  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 72},
    {FALSE, 640,400,8, 75},
    {FALSE, 640,400,8, 85},
    {FALSE, 640,400,8, 100},
    {FALSE, 640,400,8, 120}
    },
    {
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 72},
    {FALSE, 640,400,15, 75},
    {FALSE, 640,400,15, 85},
    {FALSE, 640,400,15, 100},
    {FALSE, 640,400,15, 120}
    },
    {
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 72},
    {FALSE, 640,400,16, 75},
    {FALSE, 640,400,16, 85},
    {FALSE, 640,400,16, 100},
    {FALSE, 640,400,16, 120}
    },
    {
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 72},
    {FALSE, 640,400,24, 75},
    {FALSE, 640,400,24, 85},
    {FALSE, 640,400,24, 100},
    {FALSE, 640,400,24, 120}
    },
    {
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 72},
    {FALSE, 640,400,32, 75},
    {FALSE, 640,400,32, 85},
    {FALSE, 640,400,32, 100},
    {FALSE, 640,400,32, 120}
    },

    //***********************************************************************************
    // 320x200  at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 72},
    {FALSE, 320,200,8, 75},
    {FALSE, 320,200,8, 85},
    {FALSE, 320,200,8, 100},
    {FALSE, 320,200,8, 120}
    },
    {
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 72},
    {FALSE, 320,200,15, 75},
    {FALSE, 320,200,15, 85},
    {FALSE, 320,200,15, 100},
    {FALSE, 320,200,15, 120}
    },
    {
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 72},
    {FALSE, 320,200,16, 75},
    {FALSE, 320,200,16, 85},
    {FALSE, 320,200,16, 100},
    {FALSE, 320,200,16, 120}
    },
    {
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 72},
    {FALSE, 320,200,24, 75},
    {FALSE, 320,200,24, 85},
    {FALSE, 320,200,24, 100},
    {FALSE, 320,200,24, 120}
    },
    {
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 72},
    {FALSE, 320,200,32, 75},
    {FALSE, 320,200,32, 85},
    {FALSE, 320,200,32, 100},
    {FALSE, 320,200,32, 120}
    },

    //**************************************************************************************
    // 800x600.  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 800,600,8, 60},
    {FALSE, 800,600,8, 70},
    {FALSE, 800,600,8, 72},
    {FALSE, 800,600,8, 75},
    {FALSE, 800,600,8, 85},
    {FALSE, 800,600,8, 100},
    {FALSE, 800,600,8, 120}
    },
    {
    {FALSE, 800,600,15, 60},
    {FALSE, 800,600,15, 70},
    {FALSE, 800,600,15, 72},
    {FALSE, 800,600,15, 75},
    {FALSE, 800,600,15, 85},
    {FALSE, 800,600,15, 100},
    {FALSE, 800,600,15, 120}
    },
    {
    {FALSE, 800,600,16, 60},
    {FALSE, 800,600,16, 70},
    {FALSE, 800,600,16, 72},
    {FALSE, 800,600,16, 75},
    {FALSE, 800,600,16, 85},
    {FALSE, 800,600,16, 100},
    {FALSE, 800,600,16, 120}
    },
    {
    {FALSE, 800,600,24, 60},
    {FALSE, 800,600,24, 70},
    {FALSE, 800,600,24, 72},
    {FALSE, 800,600,24, 75},
    {FALSE, 800,600,24, 85},
    {FALSE, 800,600,24, 100},
    {FALSE, 800,600,24, 120}
    },
    {
    {FALSE, 800,600,32, 60},
    {FALSE, 800,600,32, 70},
    {FALSE, 800,600,32, 72},
    {FALSE, 800,600,32, 75},
    {FALSE, 800,600,32, 85},
    {FALSE, 800,600,32, 100},
    {FALSE, 800,600,32, 120}
    },
    //**************************************************************************************
    // 960x720  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 960,720,8, 60},
    {FALSE, 960,720,8, 70},
    {FALSE, 960,720,8, 72},
    {FALSE, 960,720,8, 75},
    {FALSE, 960,720,8, 85},
    {FALSE, 960,720,8, 100},
    {FALSE, 960,720,8, 120}
    },
    {
    {FALSE, 960,720,15, 60},
    {FALSE, 960,720,15, 70},
    {FALSE, 960,720,15, 72},
    {FALSE, 960,720,15, 75},
    {FALSE, 960,720,15, 85},
    {FALSE, 960,720,15, 100},
    {FALSE, 960,720,15, 120}
    },
    {
    {FALSE, 960,720,16, 60},
    {FALSE, 960,720,16, 70},
    {FALSE, 960,720,16, 72},
    {FALSE, 960,720,16, 75},
    {FALSE, 960,720,16, 85},
    {FALSE, 960,720,16, 100},
    {FALSE, 960,720,16, 120}
    },
    {
    {FALSE, 960,720,24, 60},
    {FALSE, 960,720,24, 70},
    {FALSE, 960,720,24, 72},
    {FALSE, 960,720,24, 75},
    {FALSE, 960,720,24, 85},
    {FALSE, 960,720,24, 100},
    {FALSE, 960,720,24, 120}
    },
    {
    {FALSE, 960,720,32, 60},
    {FALSE, 960,720,32, 70},
    {FALSE, 960,720,32, 72},
    {FALSE, 960,720,32, 75},
    {FALSE, 960,720,32, 85},
    {FALSE, 960,720,32, 100},
    {FALSE, 960,720,32, 120}
    },
    //**************************************************************************************
    // 1024x768  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1024,768,8, 60},
    {FALSE, 1024,768,8, 70},
    {FALSE, 1024,768,8, 72},
    {FALSE, 1024,768,8, 75},
    {FALSE, 1024,768,8, 85},
    {FALSE, 1024,768,8, 100},
    {FALSE, 1024,768,8, 120}
    },
    {
    {FALSE, 1024,768,15, 60},
    {FALSE, 1024,768,15, 70},
    {FALSE, 1024,768,15, 72},
    {FALSE, 1024,768,15, 75},
    {FALSE, 1024,768,15, 85},
    {FALSE, 1024,768,15, 100},
    {FALSE, 1024,768,15, 120}
    },
    {
    {FALSE, 1024,768,16, 60},
    {FALSE, 1024,768,16, 70},
    {FALSE, 1024,768,16, 72},
    {FALSE, 1024,768,16, 75},
    {FALSE, 1024,768,16, 85},
    {FALSE, 1024,768,16, 100},
    {FALSE, 1024,768,16, 120}
    },
    {
    {FALSE, 1024,768,24, 60},
    {FALSE, 1024,768,24, 70},
    {FALSE, 1024,768,24, 72},
    {FALSE, 1024,768,24, 75},
    {FALSE, 1024,768,24, 85},
    {FALSE, 1024,768,24, 100},
    {FALSE, 1024,768,24, 120}
    },
    {
    {FALSE, 1024,768,32, 60},
    {FALSE, 1024,768,32, 70},
    {FALSE, 1024,768,32, 72},
    {FALSE, 1024,768,32, 75},
    {FALSE, 1024,768,32, 85},
    {FALSE, 1024,768,32, 100},
    {FALSE, 1024,768,32, 120}
    },
    //*************************************************************************************
    // 1152x864  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1152,864,8, 60},
    {FALSE, 1152,864,8, 70},
    {FALSE, 1152,864,8, 72},
    {FALSE, 1152,864,8, 75},
    {FALSE, 1152,864,8, 85},
    {FALSE, 1152,864,8, 100},
    {FALSE, 1152,864,8, 120}
    },
    {
    {FALSE, 1152,864,15, 60},
    {FALSE, 1152,864,15, 70},
    {FALSE, 1152,864,15, 72},
    {FALSE, 1152,864,15, 75},
    {FALSE, 1152,864,15, 85},
    {FALSE, 1152,864,15, 100},
    {FALSE, 1152,864,15, 120}
    },
    {
    {FALSE, 1152,864,16, 60},
    {FALSE, 1152,864,16, 70},
    {FALSE, 1152,864,16, 72},
    {FALSE, 1152,864,16, 75},
    {FALSE, 1152,864,16, 85},
    {FALSE, 1152,864,16, 100},
    {FALSE, 1152,864,16, 120}
    },
    {
    {FALSE, 1152,864,24, 60},
    {FALSE, 1152,864,24, 70},
    {FALSE, 1152,864,24, 72},
    {FALSE, 1152,864,24, 75},
    {FALSE, 1152,864,24, 85},
    {FALSE, 1152,864,24, 100},
    {FALSE, 1152,864,24, 120}
    },
    {
    {FALSE, 1152,864,32, 60},
    {FALSE, 1152,864,32, 70},
    {FALSE, 1152,864,32, 72},
    {FALSE, 1152,864,32, 75},
    {FALSE, 1152,864,32, 85},
    {FALSE, 1152,864,32, 100},
    {FALSE, 1152,864,32, 120}
    },
    //*************************************************************************************
    // 1280x1024  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1280,1024,8, 60},
    {FALSE, 1280,1024,8, 70},
    {FALSE, 1280,1024,8, 72},
    {FALSE, 1280,1024,8, 75},
    {FALSE, 1280,1024,8, 85},
    {FALSE, 1280,1024,8, 100},
    {FALSE, 1280,1024,8, 120}
    },
    {
    {FALSE, 1280,1024,15, 60},
    {FALSE, 1280,1024,15, 70},
    {FALSE, 1280,1024,15, 72},
    {FALSE, 1280,1024,15, 75},
    {FALSE, 1280,1024,15, 85},
    {FALSE, 1280,1024,15, 100},
    {FALSE, 1280,1024,15, 120}
    },
    {
    {FALSE, 1280,1024,16, 60},
    {FALSE, 1280,1024,16, 70},
    {FALSE, 1280,1024,16, 72},
    {FALSE, 1280,1024,16, 75},
    {FALSE, 1280,1024,16, 85},
    {FALSE, 1280,1024,16, 100},
    {FALSE, 1280,1024,16, 120}
    },
    {
    {FALSE, 1280,1024,24, 60},
    {FALSE, 1280,1024,24, 70},
    {FALSE, 1280,1024,24, 72},
    {FALSE, 1280,1024,24, 75},
    {FALSE, 1280,1024,24, 85},
    {FALSE, 1280,1024,24, 100},
    {FALSE, 1280,1024,24, 100}
    },
    {
    {FALSE, 1280,1024,32, 60},
    {FALSE, 1280,1024,32, 70},
    {FALSE, 1280,1024,32, 72},
    {FALSE, 1280,1024,32, 75},
    {FALSE, 1280,1024,32, 85},
    {FALSE, 1280,1024,32, 100},
    {FALSE, 1280,1024,32, 100}
    },
    //**************************************************************************************
    // 1600x1024  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1024,8, 60},
    {FALSE, 1600,1024,8, 70},
    {FALSE, 1600,1024,8, 72},
    {FALSE, 1600,1024,8, 76},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85}
     },
    {
    {FALSE, 1600,1024,15, 60},
    {FALSE, 1600,1024,15, 70},
    {FALSE, 1600,1024,15, 72},
    {FALSE, 1600,1024,15, 76},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85}
     },
    {
    {FALSE, 1600,1024,16, 60},
    {FALSE, 1600,1024,16, 70},
    {FALSE, 1600,1024,16, 72},
    {FALSE, 1600,1024,16, 76},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85}
     },
    {
    {FALSE, 1600,1024,24, 60},
    {FALSE, 1600,1024,24, 70},
    {FALSE, 1600,1024,24, 72},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76}
     },
    {
    {FALSE, 1600,1024,32, 60},
    {FALSE, 1600,1024,32, 70},
    {FALSE, 1600,1024,32, 72},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76}
     },
    //**************************************************************************************
    // 1600x1200  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1200,8, 60},
    {FALSE, 1600,1200,8, 70},
    {FALSE, 1600,1200,8, 72},
    {FALSE, 1600,1200,8, 75},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85}
     },
    {
    {FALSE, 1600,1200,15, 60},
    {FALSE, 1600,1200,15, 70},
    {FALSE, 1600,1200,15, 72},
    {FALSE, 1600,1200,15, 75},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85}
     },
    {
    {FALSE, 1600,1200,16, 60},
    {FALSE, 1600,1200,16, 70},
    {FALSE, 1600,1200,16, 72},
    {FALSE, 1600,1200,16, 75},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85}
     },
    {
    {FALSE, 1600,1200,24, 60},
    {FALSE, 1600,1200,24, 70},
    {FALSE, 1600,1200,24, 72},
    {FALSE, 1600,1200,24, 75},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85}
     },
    {
    {FALSE, 1600,1200,32, 60},
    {FALSE, 1600,1200,32, 70},
    {FALSE, 1600,1200,32, 72},
    {FALSE, 1600,1200,32, 75},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85}
     },
     //**************************************************************************************
     // 1800x1440  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60}
      },
     {
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60}
      },
     {
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60}
      },
     {
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60}
      },
     {
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60}
      },
     //**************************************************************************************
     // 1920x1080  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1080,8, 60},
     {FALSE, 1920,1080,8, 70},
     {FALSE, 1920,1080,8, 72},
     {FALSE, 1920,1080,8, 75},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85}
      },
     {
     {FALSE, 1920,1080,15, 60},
     {FALSE, 1920,1080,15, 70},
     {FALSE, 1920,1080,15, 72},
     {FALSE, 1920,1080,15, 75},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85}
      },
     {
     {FALSE, 1920,1080,16, 60},
     {FALSE, 1920,1080,16, 70},
     {FALSE, 1920,1080,16, 72},
     {FALSE, 1920,1080,16, 75},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85}
      },
     {
     {FALSE, 1920,1080,24, 60},
     {FALSE, 1920,1080,24, 70},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72}
      },
     {
     {FALSE, 1920,1080,32, 60},
     {FALSE, 1920,1080,32, 70},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72}
      },
     //**************************************************************************************
     // 1920x1200  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1200,8, 60},
     {FALSE, 1920,1200,8, 70},
     {FALSE, 1920,1200,8, 72},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75}
      },
     {
     {FALSE, 1920,1200,15, 60},
     {FALSE, 1920,1200,15, 70},
     {FALSE, 1920,1200,15, 72},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75}
      },
     {
     {FALSE, 1920,1200,16, 60},
     {FALSE, 1920,1200,16, 70},
     {FALSE, 1920,1200,16, 72},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75}
      },
     {
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60}
      },
     {
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60}
      }
};
//******************************************************************************
// Use a slightly different mode table for NV4
//******************************************************************************


MODEDESC mib[] =             // Our Mode List
{
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V
    {0x100, 0x5B, PACKED, 0x11, 0x05, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x06, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x07, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x06, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x06, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x07, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x07, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x04, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x04, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x04, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x05, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x05, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0xFF, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0xFF, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0xFF, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

    // JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    // JJV - New Modes

    // VEL - New Dell Specific Modes
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18,  8, 1600, 1024, 1600, MAX_DCLK},  // Mode 157 - 1600x1024 8
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19, 16, 1600, 1024, 3200, MAX_DCLK},  // Mode 158 - 1600x1024 16
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 32, 1600, 1024, 6400, MAX_DCLK},  // Mode 159 - 1600x1024 32
    // VEL - New Dell Specific Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};


CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },

    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },

    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },

    // JJV - Start
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
    // JJV - End

    // 18. Mode ?
    // 1600x1024x8
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 19. Mode ?
    // 1600x1024x16
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 1A. Mode ?
    // 1600x1024x32
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 }
    // VEL - End



};

//******************************************************************************
// NV4 specific data
//******************************************************************************
//
// NV4 Fifo/Watermark settings (100MHz/100MHz operation)
//
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04}    // max marker
};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nv4.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV4.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//
// Used to turn on MultiDevice support for NT 4 (smae is used for the display driver)
//
//#define NT4_MULTI_DEV


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvMultiMon.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"
#include "nv_name.h"

#include "cr11_ref.h"

VOID FlatPanelCrtc(U016);
VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_ReadAndCopyRegistryData(PHW_DEVICE_EXTENSION,WCHAR *,U016 *);
VOID LoadDefaultRegistrySwitchValues(PHW_DEVICE_EXTENSION);
VOID BubbleSort(PHW_DEVICE_EXTENSION,PMODE_ENTRY,ULONG);
VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION);
VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION);
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);

//
// To fix a soft reboot hang on the laptops.
//
#if (_WIN32_WINNT >= 0x0500)
extern BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    );
#endif

//******************************************************************************
// External Declarations
//******************************************************************************

extern U016 ModeSetTable[];
extern U016 DMTOverrideTable[][13];
extern CRTC_OVERRIDE crt_override[];
extern EXTREGS eregs[];
extern U016 tblClockFreq[];
extern U016 VBESetModeEx(PHW_DEVICE_EXTENSION, U016, PGTF_TIMINGS, PDMT_OVERRIDES, U016);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt);
extern MODESET_FIFO DACFifoTable[];
extern unsigned int GTFTimingTable[][12];
extern U016 ValidModeTable[];
extern U016 registry_data[];

extern ULONG my_strcmp(PUCHAR ,PUCHAR);
extern VOID my_strupr(PUCHAR);
extern VOID my_strcpy(PUCHAR , PUCHAR);

extern VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
extern VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
extern VOID NV10SaveInstanceMemory(PHW_DEVICE_EXTENSION);
extern VOID NV10RestoreInstanceMemory(PHW_DEVICE_EXTENSION);

extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);


//******************************************************************************
// Global tables default registry settings
// (Type, ValueName, SwitchIsPresent, Offset of structure member)
//******************************************************************************

NT_NV_REGISTRY_SWITCH_OFFSET Nv_Registry_Switch_Offset_Table[] =
    {


// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

    { IS_DWORD , "PLACEHOLDER" ,                                offsetof(NT_NV_REGISTRY, Display.DisplayType)                   }

//    //**************************************************************************
//    // Display Registry Switch Names
//    //**************************************************************************
//
//    { IS_STRING , NV4_REG_DRV_LAST_DEVICE ,                   offsetof(NT_NV_REGISTRY, Display.LastDisplayDevice[0])          },
//    { IS_STRING , NV4_REG_DRV_LAST_CRT_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastCRTMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_DFP_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastDFPMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_NTSC_MODE ,                offsetof(NT_NV_REGISTRY, Display.LastNTSCMode[0])               },
//    { IS_STRING , NV4_REG_DRV_LAST_PAL_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastPALMode[0])                },
//    { IS_STRING , NV4_REG_DRV_CRT_MODE ,                      offsetof(NT_NV_REGISTRY, Display.CRTMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DFP_MODE ,                      offsetof(NT_NV_REGISTRY, Display.DFPMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_NTSC_MODE ,                     offsetof(NT_NV_REGISTRY, Display.NTSCMode[0])                   },
//    { IS_STRING , NV4_REG_DRV_PAL_MODE ,                      offsetof(NT_NV_REGISTRY, Display.PALMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DISPLAY_DEVICE_TYPE ,           offsetof(NT_NV_REGISTRY, Display.DisplayDeviceType[0])          },
//    { IS_DWORD , "Display Type" ,                             offsetof(NT_NV_REGISTRY, Display.DisplayType)                   },
//    { IS_DWORD , "TV Type" ,                                  offsetof(NT_NV_REGISTRY, Display.TVType)                        },
//    { IS_DWORD  , NV4_REG_DRV_MONITOR_TIMING ,                offsetof(NT_NV_REGISTRY, Display.MonitorTiming)                 },
//    { IS_DWORD  , NV4_REG_DRV_CURSOR_ALPHA ,                  offsetof(NT_NV_REGISTRY, Display.CursorAlpha)                   },
//
//
//    //**************************************************************************
//    // DirectDraw Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , NV4_REG_VPE_ENABLE ,                         offsetof(NT_NV_REGISTRY, DirectDraw.VPENABLE)                   },
//    { IS_DWORD , NV4_REG_OVL_MODE ,                           offsetof(NT_NV_REGISTRY, DirectDraw.OverlayMode)                },
//    { IS_DWORD , NV4_REG_OVLCC_ENABLE ,                       offsetof(NT_NV_REGISTRY, DirectDraw.OverlayColorControlEnable)  },
//    { IS_DWORD , NV4_REG_OVLCC_BRIGHTNESS ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlayBrightness)          },
//    { IS_DWORD , NV4_REG_OVLCC_CONTRAST ,                     offsetof(NT_NV_REGISTRY, DirectDraw.OverlayContrast)            },
//    { IS_DWORD , NV4_REG_OVLCC_HUE ,                          offsetof(NT_NV_REGISTRY, DirectDraw.OverlayHue)                 },
//    { IS_DWORD , NV4_REG_OVLCC_SATURATION ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySaturation)          },
//    { IS_DWORD , NV4_REG_OVLCC_GAMMA ,                        offsetof(NT_NV_REGISTRY, DirectDraw.OverlayGamma)               },
//    { IS_DWORD , NV4_REG_OVLCC_SHARPNESS ,                    offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySharpness)           },
//
//    //**************************************************************************
//    // Direct3d Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , D3D_REG_ANTIALIASENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.ANTIALIASENABLE)              },
//    { IS_DWORD , D3D_REG_CKCOMPATABILITYENABLE_STRING ,       offsetof(NT_NV_REGISTRY, Direct3D.COLORKEYCOMPATABILITYENABLE)  },
//    { IS_DWORD , "CONTROLTRAFFIC"                    ,        offsetof(NT_NV_REGISTRY, Direct3D.CONTROLTRAFFIC)               },
//    { IS_DWORD , D3D_REG_DIRECTMAPENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DIRECTMAPENABLE)              },
//    { IS_DWORD , D3D_REG_FOGTABLEENABLE_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.FOGTABLENABLE)                },
//    { IS_DWORD , D3D_REG_LOGOENABLE_STRING ,                  offsetof(NT_NV_REGISTRY, Direct3D.LOGOENABLE)                   },
//    { IS_DWORD , D3D_REG_SSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.SCENESYNCENABLE)              },
//    { IS_DWORD , D3D_REG_TILINGENABLE_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.TILINGENABLE)                 },
//    { IS_DWORD , D3D_REG_USERMIPMAPENABLE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.USERMIPMAPENABLE)             },
//    { IS_DWORD , D3D_REG_VIDEOTEXTUREENABLE_STRING ,          offsetof(NT_NV_REGISTRY, Direct3D.VIDEOTEXTUREENABLEENABLE)     },
//    { IS_DWORD , D3D_REG_VSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.VSYNCENABLE)                  },
//    { IS_DWORD , D3D_REG_WBUFFERENABLE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.WENABLE)                      },
//    { IS_DWORD , D3D_REG_Z24ENABLE_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.Z24ENABLE)                    },
//    { IS_DWORD , D3D_REG_AAMETHOD_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.AAMETHOD)                     },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPMETHOD_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.AUTOMIPMAPMETHOD)             },
//    { IS_DWORD , D3D_REG_CKREF_STRING ,                       offsetof(NT_NV_REGISTRY, Direct3D.CKREF)                        },
//    { IS_DWORD , "DX6ENABLE" ,                                offsetof(NT_NV_REGISTRY, Direct3D.DX6ENABLE)                    },
//    { IS_DWORD , D3D_REG_MIPMAPDITHERMODE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.ANISOTOPIC4TAP)               },
//    { IS_DWORD , D3D_REG_PAL8TEXCONVERT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.PAL8TEXTURECONVERT)           },
//    { IS_DWORD , "PMTRIGGER" ,                                offsetof(NT_NV_REGISTRY, Direct3D.PMTRIGGER)                    },
//    { IS_DWORD , D3D_REG_TEXELALIGNMENT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXELALIGNMENT)               },
//    { IS_DWORD , D3D_REG_VALIDATEZMETHOD_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.VALIDATEZMETHOD)              },
//    { IS_DWORD , D3D_REG_WFORMAT16_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W16FORMAT)                    },
//    { IS_DWORD , D3D_REG_WFORMAT32_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W32FORMAT)                    },
//    { IS_DWORD , D3D_REG_AGPTEXCUTOFF_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.AGPTEXCUTOFF)                 },
//    { IS_DWORD , D3D_REG_D3DCONTEXTMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DCONTEXTMAX)                },
//    { IS_DWORD , D3D_REG_D3DTEXTUREMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DTEXTUREMAX)                },
//    { IS_DWORD , D3D_REG_DMAMINPUSHCOUNT_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DMAMINPUSHCOUNT)              },
//    { IS_DWORD , D3D_REG_LODBIAS_STRING ,                     offsetof(NT_NV_REGISTRY, Direct3D.LODBIASADJUST)                },
//    { IS_DWORD , D3D_REG_MINVIDTEXSIZE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.MINVIDEOTEXSIZE)              },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPLEVELS_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.MIPMAPLEVELS)                 },
//    { IS_DWORD , D3D_REG_PERFSTRATEGY_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.PERFSTRATEGY)                 },
//    { IS_DWORD , D3D_REG_PRERENDERLIMIT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.NOVSYNCPREREDNERLIMIT)        },
//    { IS_DWORD , D3D_REG_PUSHBUFFERSIZEMAX_STRING ,           offsetof(NT_NV_REGISTRY, Direct3D.DMAPUSHBUFFERSIZEMAX)         },
//    { IS_DWORD , D3D_REG_TEXHEAPSIZEMAX_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXHEAP)                      },
//    { IS_DWORD , D3D_REG_WSCALE16_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE16)                     },
//    { IS_DWORD , D3D_REG_WSCALE24_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE24)                     },
//
//    //**************************************************************************
//    // System Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , "Reserved1" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved2" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved3" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved4" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved5" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved6" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved7" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved8" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved9" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved10" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved11" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },

    };
    

//******************************************************************************
// Global tables for registry mode table data
//******************************************************************************

U016 NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5M64_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5ULTRA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11M_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 CRUSH11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15BR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_2_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_3_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];


//******************************************************************************
// Global tables for Monitor restriction mode list data
//******************************************************************************
U016 MonitorRestrictionModeList0_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head0
U016 MonitorRestrictionModeList1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head1

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


extern VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
// Tables used by DPMS_SetPowerState (NT5 only)
//******************************************************************************

UCHAR tblDPMSStates[4]      = { 0, 2, 1, 4 }                    ;   //on, stdby, suspend, off
UCHAR tblDPMSSettings[4]    = { 0x000, 0x080, 0x040, 0x0C0 }    ;

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION);
VOID NV_ATCOn(PHW_DEVICE_EXTENSION);
VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION);

#endif


//******************************************************************************
// Use a slightly different mode timing table for NV4
//******************************************************************************


//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity
// VSync polarity
//
// Max out all the modes above our pixclk (~250).
//
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
    //0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,

    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

//17:
    // Settings for 1600x1024:
    2144,1704,1872,1060,1025,1028,13636,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1066,1025,1028,16118,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1067,1025,1028,16594,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// An OEM Customer wants a SPECIFIC timing...which is NOT GTF or DMT compliant ...so we'll accomodate them...
// (They're using a widescreen Sony monitor)

// Standard GTF
//    2176,1712,1888,1070,1025,1028,17695,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// OEM requested
    2096,1632,1792,1070,1027,1030,17045,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,


    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


};

//******************************************************************************
// Forward Function Declarations
//******************************************************************************
VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

BOOLEAN
NVGetNVInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID NV4_UpdateArbitrationSettings(PHW_DEVICE_EXTENSION);

BOOL NV4SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV4_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NVMapMemoryRanges(PVOID HwDeviceExtension);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
VOID NV4EnableCursor(PHW_DEVICE_EXTENSION);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NV4_ProgramTV( U008 );

//******************************************************************************
//
//  Function: NVSetMode()
//
//  Routine Description:
//
//      This routine sets the adapter into the requested mode.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      Mode - Pointer to the structure containing the information about the
//          font to be set.
//
//      ModeSize - Length of the input buffer supplied by the user.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
//          for the input data.
//
//      ERROR_INVALID_PARAMETER if the mode number is invalid.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )


    {

    PMODE_ENTRY pRequestedMode;             // NV specific
    VP_STATUS status;
    USHORT usDataSet, usTemp, usDataClr;
    PUSHORT  pBios = NULL;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG OutData;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;
    ULONG Data;
    PMODE_ENTRY ModeEntry;

    PHWINFO NVInfo;

    VideoDebugPrint((1, "NVSetMode - entry\n"));

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if (ModeSize < sizeof(VIDEO_MODE))
    {

        VideoDebugPrint((1, "SetMode - ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //**************************************************************************
    // Init pointer to Mode data (NV3 or NV4)
    //**************************************************************************

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);


    //**************************************************************************
    // Check to see if we are requesting a valid mode
    //**************************************************************************

    if ( (Mode->RequestedMode >= HwDeviceExtension->NumRegistryModes)   ||
         (!ModeEntry[Mode->RequestedMode].ValidMode)  )
        {

        VideoDebugPrint((1, "SetMode - ERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

        }


    //**************************************************************************
    // Our driver maps video memory first, and then sets the mode.
    // However, the Dumb Frame Buffer drivers sets the mode FIRST, and
    // then maps the video memory.  So first check to see if we've
    // got a valid frame buffer ptr, before we clear memory.
    //**************************************************************************

    if (HwDeviceExtension->FrameBufferPtr !=NULL)
        {
        //**********************************************************************
        // Clear the framebuffer prior to setting the video mode.
        // This is for aesthetics only.
        // Back up 1Mb to make absolutely sure we don't walk over any instance memory
        //**********************************************************************
        for (i = 0; i < ( (HwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
            {
            ((PULONG) HwDeviceExtension->FrameBufferPtr)[i] = 0;
            }
        }

    //**************************************************************************
    // Get pointer to the requested mode
    //**************************************************************************
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        PMODE_ENTRY pDesktopMode; 
        ULONG ulDac;
        ULONG ulWidth;
        ULONG ulHeight;
        ULONG ulRefresh;
        ULONG ulPixelDepth;

        pDesktopMode = &(ModeEntry[Mode->RequestedMode]);

        // Display driver is setting mode through class for both DAC.
        // Miniport driver set to the primary dac by default;
        ulDac = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        ulWidth = HwDeviceExtension->DeskTopInfo.ulDisplayWidth[ulDac];
        ulHeight = HwDeviceExtension->DeskTopInfo.ulDisplayHeight[ulDac];
        ulRefresh = HwDeviceExtension->DeskTopInfo.ulDisplayRefresh[ulDac];
        ulPixelDepth = HwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[ulDac];

        for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)   
        {
            if(!ModeEntry[i].ValidMode)
                continue;

            if( (ModeEntry[i].Depth == ulPixelDepth) &&
                (ModeEntry[i].RefreshRate == ulRefresh) &&
                (ModeEntry[i].Width == ulWidth) &&
                (ModeEntry[i].Height == ulHeight) )
            {
                Mode->RequestedMode = i;
                break;
            }
        }
        if(i == HwDeviceExtension->NumRegistryModes)
            return (ERROR_INVALID_PARAMETER);
    }

    pRequestedMode = &(ModeEntry[Mode->RequestedMode]);

    //**************************************************************************
    // Initialize the Graphics Mode and Engine.
    //**************************************************************************

    if (NV4SetMode(HwDeviceExtension, pRequestedMode) == FALSE)
        return(ERROR_NOT_ENOUGH_MEMORY);

    //**************************************************************************
    // Store the new mode value.
    //**************************************************************************

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

#if _WIN32_WINNT >= 0x0500
    HwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_GRAPHICS_MODE;
#endif

    VideoDebugPrint((1, "NVSetMode - exit\n"));
    return NO_ERROR;

    } //end NVSetMode()


//******************************************************************************
//
//  Function:   NVGetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG i,j;
    ULONG Size;
    BOOLEAN status=TRUE;
    ULONG   FullChipId,ChipId;
    ULONG   TopOfFB;
    U016    rc;
    PCI_SLOT_NUMBER slot;

    //**************************************************************************
    // Get ptr to NVInfo structure and clear it out.
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    VideoPortZeroMemory(NVInfo, sizeof(HWINFO));


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // WIN2K:   We need to determine what chip we're running on for Win2K!
    //          This was NOT obtained in NVIsPresent, so we need to
    //          determine it HERE, because we now have access to the
    //          the hardware registers !!
    //**************************************************************************

    ChipId = REG_RD32(NV_PBUS_PCI_NV_0);
    ChipId >>= 16;                              // Get top 16 bits (bits 16 thru 31)
    ChipId &= 0xffff;                           // Just look at 16 bits

    FullChipId = ChipId;                        // Save complete id
    ChipId &= 0xfffc;                           // Ignore Sub Revisions 1 thru 3

    switch (ChipId)
        {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:

            //******************************************************************
            // NV4 (original TNT)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:

            //******************************************************************
            // NV5 (TNT2)   ID = 28
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;

            //******************************************************************
            // NV5 (TNT2 ULTRA)  ID = 29
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1)
                HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;


            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:

            //******************************************************************
            // VANTA (ID = 2C)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;

            //******************************************************************
            // (TNT2 Model 64) (ID = 2D)
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1)
                HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;

            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:

            //******************************************************************
            // NV0A
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:

            //******************************************************************
            // NV10
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;

            //******************************************************************
            // NV10DDR (NV10 DDR)  ID = 101
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1)
                HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;

            //******************************************************************
            // NV10GL (NV10 GL)  ID = 103
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3)
                HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;


            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0:

            //******************************************************************
            // NV11 ID = 110
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;

            //******************************************************************
            // NV11DDR (NV11 DDR)  ID = 111
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1)
                HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;

            //******************************************************************
            // NV11M (NV11 Mobile)  ID = 112
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2)
                HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;

            //******************************************************************
            // NV11GL (NV11 GL)  ID = 113
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3)
                HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_CRUSH11_DEVID0:

            //******************************************************************
            // Crush11 ID = 1A0
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_CRUSH11_ID;

            break;
               
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:

            //******************************************************************
            // NV15 ID = 150
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;

            //******************************************************************
            // NV15DDR (NV15 DDR)  ID = 151
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1)
                HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;

            //******************************************************************
            // NV15BR (NV15 BR)  ID = 152
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2)
                HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;


            //******************************************************************
            // NV15GL (NV15 GL)  ID = 153
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3)
                HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;


            break;

        
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0:

            //******************************************************************
            // NV20 ID = 200
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;

            //******************************************************************
            // NV20 ID = 201
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;

            //******************************************************************
            // NV20 ID = 202
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;

            //******************************************************************
            // NV20 ID = 203
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;

            break;


        default:

            //******************************************************************
            // Unsupported Chip
            //******************************************************************
            status=FALSE;
            return(status);
        }
#endif


    //**************************************************************************
    // Now that we're using a Resource Manager, the majority of the
    // NVInfo structure fields are no longer used (These values were used
    // in the older 1.00 driver).  Since they're no longer used, just
    // zero them out.
    //**************************************************************************

    NVInfo->Pram.CurrentSize        = 0;
    NVInfo->Pram.HashTableAddr      = 0;
    NVInfo->Pram.HashDepth          = 0;
    NVInfo->Pram.FifoRunoutAddr     = 0;
    NVInfo->Pram.RunOutMask         = 0;
    NVInfo->Pram.FifoContextAddr    = 0;
    NVInfo->Pram.FreeInstSize       = 0;
    NVInfo->Pram.FreeInstBase       = 0;
    NVInfo->Dac.CursorImageInstance = 0;


    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID))
    {
        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_CFG,_BUS))
        {
            case NV_PFB_CFG_BUS_64:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_CFG_BUS_128:
                NVInfo->Dac.InputWidth = 128;
                break;
            case NV_PFB_CFG_BUS_32:
                NVInfo->Dac.InputWidth = 32;
                break;
        }
    }
    else if ((HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        NVInfo->Dac.InputWidth = 128;
    }
    else
    {
        switch (PFB_REG_RD_DRF(PFB_Base, _PFB, _BOOT_0, _RAM_WIDTH_128))
        {
            case NV_PFB_BOOT_0_RAM_WIDTH_128_OFF:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_BOOT_0_RAM_WIDTH_128_ON:
                NVInfo->Dac.InputWidth = 128;
                break;
        }
    }

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

//    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
//    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_FIB_REVISION);
//    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
//    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

//    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
//                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO ? BUFFER_DRAM : BUFFER_VRAM;

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)         ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)         ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)       ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)         ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)     ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)         ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))

    {
        NVInfo->Framebuffer.RamSize = PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS);
        NVInfo->Framebuffer.RamSizeMb = NVInfo->Framebuffer.RamSize >> 20;
    }
    else if  (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)
    {
        slot.u.AsULONG = 0x0;    // make sure all fields are initialized
        slot.u.bits.DeviceNumber   = 0;
        slot.u.bits.FunctionNumber = 1;

        HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                              0,                    // bus number
                              slot.u.AsULONG,       // slot number
                              &TopOfFB,             // buffer
                              CR_CMC_CFG0 & 0xFF,   // config space offset
                              sizeof(ULONG));       // buffer size

        NVInfo->Framebuffer.RamSizeMb =
                            CR_DRF_VAL(_CMC, _CFG0, _TOP_OF_FB, TopOfFB) + 1;
        NVInfo->Framebuffer.RamSize = NVInfo->Framebuffer.RamSizeMb << 20;
       
    }
    else
    {
        //**************************************************************************
        // Get amount of VRAM
        // NOTE: These values are DIFFERENT from those defined in NV3 !!
        //**************************************************************************

        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
            {
            case NV_PFB_BOOT_0_RAM_AMOUNT_32MB:
                NVInfo->Framebuffer.RamSizeMb = 32;
                NVInfo->Framebuffer.RamSize   = 0x02000000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                NVInfo->Framebuffer.RamSizeMb = 4;
                NVInfo->Framebuffer.RamSize   = 0x00400000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                NVInfo->Framebuffer.RamSizeMb = 8;
                NVInfo->Framebuffer.RamSize   = 0x00800000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                NVInfo->Framebuffer.RamSizeMb = 16;
                NVInfo->Framebuffer.RamSize   = 0x01000000;
                break;
            default:
                //******************************************************************
                // Invalid memory configuration
                //******************************************************************
                status=FALSE;
                return(status);
            }


        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    NVInfo->Framebuffer.RamSizeMb = 2;
                    NVInfo->Framebuffer.RamSize   = 0x00200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    NVInfo->Framebuffer.RamSizeMb = 4;
                    NVInfo->Framebuffer.RamSize   = 0x00400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    NVInfo->Framebuffer.RamSizeMb = 6;
                    NVInfo->Framebuffer.RamSize   = 0x00600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    NVInfo->Framebuffer.RamSizeMb = 8;
                    NVInfo->Framebuffer.RamSize   = 0x00800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    NVInfo->Framebuffer.RamSizeMb = 10;
                    NVInfo->Framebuffer.RamSize   = 0x00A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    NVInfo->Framebuffer.RamSizeMb = 12;
                    NVInfo->Framebuffer.RamSize   = 0x00C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    NVInfo->Framebuffer.RamSizeMb = 14;
                    NVInfo->Framebuffer.RamSize   = 0x00E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    NVInfo->Framebuffer.RamSizeMb = 16;
                    NVInfo->Framebuffer.RamSize   = 0x01000000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    NVInfo->Framebuffer.RamSizeMb = 18;
                    NVInfo->Framebuffer.RamSize   = 0x01200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    NVInfo->Framebuffer.RamSizeMb = 20;
                    NVInfo->Framebuffer.RamSize   = 0x01400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    NVInfo->Framebuffer.RamSizeMb = 22;
                    NVInfo->Framebuffer.RamSize   = 0x01600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    NVInfo->Framebuffer.RamSizeMb = 24;
                    NVInfo->Framebuffer.RamSize   = 0x01800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    NVInfo->Framebuffer.RamSizeMb = 26;
                    NVInfo->Framebuffer.RamSize   = 0x01A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    NVInfo->Framebuffer.RamSizeMb = 28;
                    NVInfo->Framebuffer.RamSize   = 0x01C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    NVInfo->Framebuffer.RamSizeMb = 30;
                    NVInfo->Framebuffer.RamSize   = 0x01E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    NVInfo->Framebuffer.RamSizeMb = 32;
                    NVInfo->Framebuffer.RamSize   = 0x02000000;
                    break;
                default:
                    //******************************************************************
                    // Invalid memory configuration
                    //******************************************************************
                    status=FALSE;
                    return(status);
            }
    }

    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
    NVInfo->Pram.AvailableSize[0]         =  NV_PRAM_DEVICE_SIZE_5_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[1]         =  NV_PRAM_DEVICE_SIZE_9_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[2]         =  NV_PRAM_DEVICE_SIZE_17_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[3]         =  NV_PRAM_DEVICE_SIZE_33_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 70)
       refresh = 0;
    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 4;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 5;
    else
        refresh = 6;

    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    //**************************************************************************

//    NVInfo->Dac.CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0x00;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // return success
    //**************************************************************************

    return(status);
    }

VOID NVUpdateRegNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    PWSTR   pwszChip, pwszAdapterString;
    ULONG   i, cbChip, cbAdapterString;

    pwszChip = L"NVxx";
    cbChip = sizeof(L"NVxx");
    pwszAdapterString = L"NVxx";
    cbAdapterString = sizeof(L"NVxx");

    for(i = 0; i < sizeof(sChipInfo) / sizeof(CHIP_INFO); i++)
    {
        if (HwDeviceExtension->ulChipID == sChipInfo[i].ulDevID)
        {
            pwszChip = sChipInfo[i].pwszChip;
            cbChip = cbStrLenW(pwszChip);
            pwszAdapterString = sChipInfo[i].pwszAdapterString; 
            cbAdapterString = cbStrLenW(pwszAdapterString);
            break;
        }
    }

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   L"Integrated RAMDAC",
                                   sizeof(L"Integrated RAMDAC") );

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &(HwDeviceExtension->NvInfo.Framebuffer.RamSize),
                                   sizeof(ULONG));
    }


//******************************************************************************
//
//  Function:   NV4SetMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************

BOOL NV4SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )
    {
    PHWINFO NVInfo;
    PUCHAR crtc;
    ULONG OffScreenMemory;
    ULONG OnScreenMemory;
    UCHAR  mode, bitdepth, doubled;
    USHORT vesaMode;
    VIDEO_REQUEST_PACKET requestPacket;
    STATUS_BLOCK statusblock;
    PDMT_OVERRIDES pDMTOverrides;
    U016   UseDMTFlag;
    ULONG CurrentValue;
    BOOLEAN bRefreshRateDefault;
    MODE_TIMING_VALUES timingInfo;
    GTF_TIMINGS vbe_timings;
    unsigned int vesaStatus;
    ULONG result;
    
    //**************************************************************************
    //    Current Issues with New Style Modeset Code:
    //
    //    1) NT 3.51 will no longer work with new style modeset code, because
    //       RmSetMode calls RmUnloadState and RmLoadState.
    //       (NT 3.51 does not work with a Resource Manager to my knowledge).
    //
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    NVInfo->Framebuffer.HorizDisplayWidth   = RequestedMode->Width;
    NVInfo->Framebuffer.VertDisplayWidth    = RequestedMode->Height;
    NVInfo->Framebuffer.Depth               = RequestedMode->Depth;
    NVInfo->Framebuffer.RefreshRate         = RequestedMode->RefreshRate;

    if ( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {

        // Added to support GTF or DMT method selection under WinNT4 and Win2K
        if (HwDeviceExtension->bUseGTF)
        {

            //**********************************************************************
            // Here we use GTF timings as requested by the user
            //**********************************************************************

            vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            if (vesaStatus)
            {
                // Could not find a GTF timing for this mode
                return(FALSE);
            }

        }
        else
        {

            //**************************************************************************
            // Here we use DMT timings  (instead of GTF timings)
            //**************************************************************************

            vesaStatus = vesaGetDMTTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            //**************************************************************************
            // If DMT timings don't exist for this mode, use the GTF timings
            //**************************************************************************

            if (vesaStatus)
            {

                //**********************************************************************
                // Set mode using GTF timings if DMT timings don't exist
                //**********************************************************************

                vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                               NVInfo->Framebuffer.VertDisplayWidth,    
                                               NVInfo->Framebuffer.RefreshRate,
                                               &timingInfo);

                if (vesaStatus)
                {
                    // Could not find a DMT / GTF timing for this mode
                    return(FALSE);
                }
            }
        }
    }




    //**************************************************************************
    // Still need to make sure the 'global' hwdevice variable is in sync.
    // (We need to eventually get rid of this global hwdev variable !!!)
    //**************************************************************************

    SetGlobalHwDev(HwDeviceExtension);

    //**************************************************************************
    // Unlock the registers
    //**************************************************************************

    NV_OEMEnableExtensions(HwDeviceExtension);          

    //**************************************************************************
    // Determine which modes are 'doubled'
    //**************************************************************************

    doubled = 0;  

    if ((NVInfo->Framebuffer.VertDisplayWidth == 384 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 360 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 300 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 240 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 200 ))   
        {
        doubled = 1;
        }
        
    if( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {
        //**************************************************************************
        // Pass the timings to the RM and let it set the mode (via DacProgramCRTC)
        // as well as fixup the modeset arbitration.
        //**************************************************************************


        if (RmSetMode(HwDeviceExtension->DeviceReference,
                  timingInfo.HorizontalVisible,
                  timingInfo.HorizontalBlankStart,
                  timingInfo.HorizontalRetraceStart,
                  timingInfo.HorizontalRetraceEnd,
                  timingInfo.HorizontalBlankEnd,
                  timingInfo.HorizontalTotal,
                  timingInfo.VerticalVisible,
                  timingInfo.VerticalBlankStart,
                  timingInfo.VerticalRetraceStart,
                  timingInfo.VerticalRetraceEnd,
                  timingInfo.VerticalBlankEnd,
                  timingInfo.VerticalTotal,
                  NVInfo->Framebuffer.Depth,
                  NVInfo->Framebuffer.RefreshRate,
                  NVInfo->Framebuffer.HorizDisplayWidth ,
                  NVInfo->Framebuffer.VertDisplayWidth,  
                  timingInfo.PixelClock,
                  timingInfo.HSyncpolarity,
                  timingInfo.VSyncpolarity,
                  doubled) != TRUE)
        {
        return(FALSE);
        }
    }
    //**************************************************************************
    // Save these values off so when we come back from hibernation,
    // we'll know what values to restore
    //**************************************************************************

    HwDeviceExtension->LastWidth        = NVInfo->Framebuffer.HorizDisplayWidth; 
    HwDeviceExtension->LastHeight       = NVInfo->Framebuffer.VertDisplayWidth;
    HwDeviceExtension->LastDepth        = NVInfo->Framebuffer.Depth;
    HwDeviceExtension->LastRefreshRate  = NVInfo->Framebuffer.RefreshRate;


    //**************************************************************************
    // Ask the RM if overlay is allowed at this resolution
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_OVERLAY_ALLOWED,&result) ;

    if (result)
        HwDeviceExtension->bHwVidOvl = TRUE;
    else        
        HwDeviceExtension->bHwVidOvl = FALSE;

    //**************************************************************************
    // TV cursor adjust code
    //**************************************************************************

    if (HwDeviceExtension->TvIsPresent)
        {
        U008  ht,hrs,hbs,tvhbe,tvhbs;

        //**********************************************************************
        // Unlock the registers
        //**********************************************************************

        NV_OEMEnableExtensions(HwDeviceExtension);          

        //**********************************************************************
        // Calculate cursor min and max values (in pixels) for TV.
        //**********************************************************************

        CRTC_RD(NV_CIO_CR_HDT_INDEX, ht);   // h total
        CRTC_RD(NV_CIO_CR_HRS_INDEX, hrs);  // h retrace start
        CRTC_RD(NV_CIO_CR_HBS_INDEX, hbs);  // h blank start
        tvhbe = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_END);
        tvhbs = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_START);

        NVInfo->Dac.TVCursorMin = (ht+5-(hrs-2))*8 - tvhbe;
        NVInfo->Dac.TVCursorMax = (ht+5-((hrs-2)+hbs+1))*8 - tvhbs;
//        NVInfo->Dac.TVCursorMin += 20; // What should these values actually be?
//        NVInfo->Dac.TVCursorMax += 20; // What should these values actually be?
        NVInfo->Dac.TVCursorMin = 0;     // Set to zero for now   
        NVInfo->Dac.TVCursorMax = 0;     // Set to zero for now


        }
        

    //**************************************************************************
    // WHQL fixup code:
    //
    // The following code should probably be removed, and is leftover
    // code from the OLD style modeset code.  But we NEED to check
    // that the NEW style modeset code (ie RmSetMode) does indeed set
    // the following registers correctly.  Otherwise, this could cause
    // various WHQL tests to fail.  So for now, leave this code INTACT!
    //**************************************************************************

    {
    //**************************************************************************
    // Specify 5:5:5 or 5:6:5 format
    // ModeSet code currently defaults to 5:6:5 (in OEMSetRegs)
    //**************************************************************************

    if (RequestedMode->Depth == 16)
        {
        //**********************************************************************
        // Currently the display driver only handles 5:5:5 format...
        // So for now, just specify 5:5:5 always until we add the 5:6:5 specific modes
        //**********************************************************************
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
            (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16)) |
               (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)));
        }

    else if (RequestedMode->Depth == 8)
        {
        // if 8 bit mode, make sure we're using an 8bit palette
        //if (pDev.Framebuffer.Depth == 8)
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
                (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) );
        }

    //**************************************************************************
    // Make sure Bit 20 is always set for 32bpp modes
    //**************************************************************************

    if (RequestedMode->Depth == 32)
        {
        CurrentValue = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_GENERAL_CONTROL);
        CurrentValue |= (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) ;
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,CurrentValue);
        }


    //**************************************************************************
    // Make sure to turn off 2D dithering.  Otherwise, HCT tests will fail!
    //**************************************************************************

    CurrentValue = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_3);

    //**************************************************************************
    // Mask off the 2d dither bits
    //**************************************************************************

    CurrentValue &= (~ ( (DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED )) |
                         (DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D, _ENABLED )) ));


    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_3,CurrentValue);

    }
    

    //**************************************************************************
    // If flat panel is present, make sure to clear out the following registers
    // because video bios's after 09/02/99 may touch these registers.
    // These registers should probably get cleared in dacSetFlatPanelMode in the RM
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
        REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0x00000000);
        REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0x00000000);
        }


    //**************************************************************************
    // Another ALI 1541 workaround fix
    //**************************************************************************


    if (HwDeviceExtension->AliChipset_Problem_Found==TRUE)
    
        {

        //**********************************************************************
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        //**********************************************************************

        CurrentValue = REG_RD32(NV_PBUS_DEBUG_1);
        CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_DEBUG_1_PCIS_WRITE));
        REG_WR32(NV_PBUS_DEBUG_1,  CurrentValue);

        }
               

    return(TRUE);
    } // end NV4SetMode()

//******************************************************************************
//
// Function: NV_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )
    {
    ULONG i;

    //**************************************************************************
    // wait for vblank
    //**************************************************************************
    if(HwDeviceExtension->curMonitorPowerState == VideoPowerOn)
    {
        if(HwDeviceExtension->curAdapterPowerState == VideoPowerOn)
        {
            while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));
        }
    }

    //**************************************************************************
    //  Specify first palette register
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) ClutBuffer->FirstEntry);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

    }

//******************************************************************************
//
// Function: NV4_SetPixMixBits()
//
// Routine Description: Set the NV_PRAMDAC_GENERAL_CONTROL_PIXMIX to 
//                      NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_SetPixMixBits(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
    ULONG   ulGeneralCtrl;

    ulGeneralCtrl = PRAMDAC_REG_RD32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL);

    //
    //  Set NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
    //

    ulGeneralCtrl |= 0x30;
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,ulGeneralCtrl);
}

//******************************************************************************
//
// Function: NV4_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
    {
    USHORT i;

    //**************************************************************************
    // Blast out our palette values.  First Init to index 0
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) 0);

    //**************************************************************************
    // Init to a gray scale so something will appear instead of just black
    // 256 * 3 (for each R,G, and B component)
    //**************************************************************************

    for (i = 0; i < 256; i++)
        {
        //**********************************************************************
        // Just initialize to a gray scale for now.
        //**********************************************************************
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        }

    return;


    }


//******************************************************************************
//
// Function:    NVMapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHYSICAL_ADDRESS CrtcRange;
    PHYSICAL_ADDRESS TimerRange;
    PHYSICAL_ADDRESS NV_PhysBaseAddress;
    PHYSICAL_ADDRESS NV_PhysFBAddress;
    ULONG CrtcLength;
    ULONG TimerLength;
    ULONG NV_RegisterLength;
    ULONG NV_FrameBufferLength;
    PHWREG CrtcAddress;
    PHWREG TimerAddress;
    PHWREG NV_LinearBaseAddress;
    PHWREG NV_LinearFBAddress;
    PHYSICAL_ADDRESS ConfigPciRange;
    ULONG ConfigPciLength;
    PHWREG ConfigPciAddress;
    ULONG CurrentValue;

    //**************************************************************************
    // Make SURE to always ENABLE bus mastering!  Our chip needs it ENABLED !!
    // (Some DELL Bios's disable bus mastering on our card)
    //**************************************************************************

    //**************************************************************************
    // First get access to the CONFIG_PCI_NV1 register
    //**************************************************************************

    ConfigPciRange.HighPart  = 0x00000000;
    ConfigPciRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    ConfigPciRange.LowPart   += NV_PBUS_PCI_NV_1;
    ConfigPciLength          = 0x1000;   // Arbitrary 4k length

    ConfigPciAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         ConfigPciRange,
                                         ConfigPciLength, FALSE);
    if (ConfigPciAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Config PCI Reg\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = TEMP_REG_RD32(ConfigPciAddress);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    TEMP_REG_WR32(ConfigPciAddress,  CurrentValue);

    //**************************************************************************
    // Free up this temporary range
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, ConfigPciAddress);


    //**************************************************************************
    // Make SURE to disable VBLANK and TIMER interrupts on startup!
    // (Some COMPAQ systems do not reset the chip, so these interrupts
    // may inadvertently get left enabled.  These interrupts (vblank/timer) then
    // enter our interrupt handler before its ready to accept them)
    //**************************************************************************

    //**************************************************************************
    // First get access to VBLANK interrupt enable register
    //**************************************************************************

    CrtcRange.HighPart  = 0x00000000;
    CrtcRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    CrtcRange.LowPart   += NV_PCRTC_INTR_EN_0;
    CrtcLength          = 0x1000;   // Arbitrary 4k length

    CrtcAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         CrtcRange,
                                         CrtcLength, FALSE);
    if (CrtcAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Crtc Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Get access to TIMER interrupt enable register
    //**************************************************************************

    TimerRange.HighPart  = 0x00000000;
    TimerRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    TimerRange.LowPart   += NV_PTIMER_INTR_EN_0 ;
    TimerLength          = 0x1000;   // Arbitrary 4k length

    TimerAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         TimerRange,
                                         TimerLength, FALSE);
    if (TimerAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Timer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure these interrupts are always DISABLED initially!
    //**************************************************************************

    TEMP_REG_WR32(CrtcAddress,  0x00000000);
    TEMP_REG_WR32(TimerAddress, 0x00000000);

    //**************************************************************************
    // Free up these temporary ranges
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, CrtcAddress);
    VideoPortFreeDeviceBase(hwDeviceExtension, TimerAddress);

    //**************************************************************************
    // Map entire NV register space
    //**************************************************************************

    NV_PhysBaseAddress.HighPart = 0x00000000;
    NV_PhysBaseAddress.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    NV_RegisterLength           = 0x1000000;    // 16M

    if ( (  NV_LinearBaseAddress = VideoPortGetDeviceBase(hwDeviceExtension,
                                                          NV_PhysBaseAddress,
                                                          NV_RegisterLength, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }
    hwDeviceExtension->NvRegisterBase = NV_LinearBaseAddress;

    //**************************************************************************
    // Initialize the 'individual' memory ranges
    //**************************************************************************

    hwDeviceExtension->NV1_Lin_PMC_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PMC)/4);
    hwDeviceExtension->NV1_Lin_PFB_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFB)/4);
    hwDeviceExtension->NV1_Lin_PFIFO_Registers  = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFIFO)/4);
    hwDeviceExtension->NV1_Lin_PBUS_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_PBUS)/4);
    hwDeviceExtension->NV1_Lin_PGRAPH_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PGRAPH)/4);
    hwDeviceExtension->NV1_Lin_PEXTDEV_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PEXTDEV)/4);
    hwDeviceExtension->NV3_Lin_PRMVIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMVIO)/4);
    hwDeviceExtension->NV3_Lin_PRMCIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMCIO)/4);
    hwDeviceExtension->NV3_Lin_PRAMDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PRAMDAC)/4);
    hwDeviceExtension->NV3_Lin_USERDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_USER_DAC)/4);
    hwDeviceExtension->NV3_Lin_PVIDEO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PVIDEO)/4);
    hwDeviceExtension->NV1_Lin_USER_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_USER)/4);
    hwDeviceExtension->pBios = (PUCHAR)(&((hwDeviceExtension->NvRegisterBase)->Reg008[DEVICE_BASE(NV_PRAMIN)]));

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);

    } // NVMapMemoryRanges()

//******************************************************************************
//
// Function:    NVMapFrameBuffer()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapFrameBuffer(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_MEMORY_INFORMATION memoryInformation;
    PHWINFO NVInfo;
    PHYSICAL_ADDRESS NVFrameBuffer;
    ULONG inIoSpace;
    ULONG status;
    ULONG MapMemoryAdjust;

    //**************************************************************************
    // Get the amount of memory available on the card
    // (Determined in GetNVInfo)
    //**************************************************************************

    NVInfo = &(hwDeviceExtension->NvInfo);
    memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Set VideoRamBase to zero, to map range at any location in the
    // logical address space of the current process
    //**************************************************************************

    memoryInformation.VideoRamBase = 0;

    //**************************************************************************
    // Get the physical address of the frame buffer
    //**************************************************************************

    NVFrameBuffer.HighPart = 0x00000000;
    NVFrameBuffer.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    NVFrameBuffer.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

    //**************************************************************************
    // Always set write combining for NT4.0 or later
    // Do NOT set it for NT 3.51 !!!!
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0400)
    inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    inIoSpace = 0;
#endif

    //**************************************************************************
    // When calling RmPostNvDevice, and passing in our ptr to the frame buffer,
    // RmPostNvDevice needs to read and write a little bit PAST the end
    // of video memory in order to size it.  
    // 
    // So, in order to accomodate this and prevent a fatal exception error, 
    // we'll allocate just a little bit more memory than the actual amount needed. 
    // (Only necessary for Win2k or better)
    //**************************************************************************

    MapMemoryAdjust = memoryInformation.VideoRamLength;

#if (_WIN32_WINNT >= 0x0500)
    MapMemoryAdjust += BIOS_MEM_SIZE_ADJUST_FACTOR;
#endif


    status = VideoPortMapMemory(hwDeviceExtension,
                                 NVFrameBuffer,
                                 &(MapMemoryAdjust),
                                 &(inIoSpace),
                                 &(memoryInformation.VideoRamBase));


#if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Special Case unattended setup issue:
    //
    //      Normally, a 32Mb video card will install successfully on a system 
    //      with 32Mb of system memory, when the display driver is installed manually.
    //
    //      However, UNATTENDED setup of a 32Mb video card on a system with 32Mb
    //      may fail.  And what makes matters worse is that during unattended setup,
    //      the driver is usually installed BEFORE the service packs are applied.
    //      (Display driver should REALLY be installed AFTER the service pack is applied)
    //
    //      To alleviate this situation and allow a 32Mb video card to be installed
    //      via unattended setup, we'll try just allocating 16Mb if the above VideoPortMapMemory 
    //      call fails.  This is REALLY not valid (and may result in the driver
    //      not working correctly), but it will allow the driver to install
    //      and get past unattended setup.
    //
    //      After the service pack is applied, subsequent VideoPortMapMemory calls should 
    //      then succeed with no problem.    
    //       
    //**************************************************************************

    if (status != NO_ERROR)
        {

        NVInfo->Framebuffer.RamSizeMb = 16;
        NVInfo->Framebuffer.RamSize   = 0x01000000;

        memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;
        memoryInformation.VideoRamBase = 0;


        status = VideoPortMapMemory(hwDeviceExtension,
                                     NVFrameBuffer,
                                     &(memoryInformation.VideoRamLength),
                                     &(inIoSpace),
                                     &(memoryInformation.VideoRamBase));
        }
#endif



    hwDeviceExtension->FrameBufferPtr = memoryInformation.VideoRamBase;
    hwDeviceExtension->FrameBufferBase= memoryInformation.VideoRamBase;

    //**************************************************************************
    // If this call fails, driver should revert back to standard VGA
    //**************************************************************************

    return(status);



    }


//******************************************************************************
//
// Function: NVIsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PULONG NV1Slot)

    {
    USHORT  usVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   i;

        //
        // NOTE: the board detection part in this routine was moved into DetectNextDevice (see the bottom of this file)
        // 


        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PRMVIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMVIO);
        RangeOffsets[NV_PRMVIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMVIO);

        RangeOffsets[NV_PRMCIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMCIO);
        RangeOffsets[NV_PRMCIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMCIO);

        RangeOffsets[NV_PRAMDAC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMDAC);
        RangeOffsets[NV_PRAMDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMDAC);

        RangeOffsets[NV_USERDAC_INDEX].ulOffset = DEVICE_BASE(NV_USER_DAC);
        RangeOffsets[NV_USERDAC_INDEX].ulLength = DEVICE_EXTENT(NV_USER_DAC);

        RangeOffsets[NV_PVIDEO_INDEX].ulOffset = DEVICE_BASE(NV_PVIDEO);
        RangeOffsets[NV_PVIDEO_INDEX].ulLength = DEVICE_EXTENT(NV_PVIDEO);

        //**********************************************************************
        // Currently allows us to write to 64k of PRAMIN memory
        //**********************************************************************

        RangeOffsets[NV_PRAMIN_INDEX].ulOffset = (ULONG) (DEVICE_BASE(NV_PRAMIN) - DEVICE_BASE(NV_PDFB));
        RangeOffsets[NV_PRAMIN_INDEX].ulLength = 0x10000;

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        // Allocate minimal 16 bytes because we're only mapping 1 register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Setmode still uses PFB_CONFIG
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;

        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = 0x0;
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;

        return(TRUE);
    }



//******************************************************************************
//
// Function:    MiniportGetRegistryValue
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOL MiniportGetRegistryValue
    (PHW_DEVICE_EXTENSION HwDeviceExtension,
     U032 Type,
     char *Node,
     char *Name,
     VOID *pData)

    {
    ULONG NumRegValueEntries = sizeof(Nv_Registry_Switch_Offset_Table) / sizeof(NT_NV_REGISTRY_SWITCH_OFFSET);    
    ULONG i=0;   
    BOOL FoundFlag = FALSE;
    ULONG FoundIndex;
    BOOL status;
    char *RegValuePtr;
    char TempNameString[REG_STRING_DATA_MAX];
    WCHAR parameterName[80];
    

    //**************************************************************************
    // This function is called by the RM to get registry switch values.
    // Normally, the RM expects a 'Win9x' type registry, with various levels
    // of keys.  But with WinNT, all our registry switches must fit in
    // ONE key (ie. a flat structure).
    //
    // This routine attempts to find the registry switch name in our
    // registry switch table.  If it's present, we return the value (or string) back.
    // Otherwise, we return false   
    //**************************************************************************

    //**************************************************************************
    // First convert the registry value name string, and
    // convert to all upper case
    //**************************************************************************
    
    my_strcpy(TempNameString,Name);
    my_strupr(TempNameString);
    
    //**************************************************************************
    // Next, Search our registry table to see if this registry switch exists
    // in our 'local' registry structure.
    //**************************************************************************
        
    while ( (i < NumRegValueEntries) && (FoundFlag == FALSE) )
        {
        //**********************************************************************
        // Convert the registry switch names in our local registry table to upper case
        //**********************************************************************

        my_strupr(&Nv_Registry_Switch_Offset_Table[i].RegName[0]);

        //**********************************************************************
        // Now compare and see if this registry switch exists in our table
        // If so, then get the index into our registry switch table.
        //**********************************************************************
        
        status = my_strcmp(&Nv_Registry_Switch_Offset_Table[i].RegName[0], TempNameString);
        if (status == 0)
            {
            FoundFlag = TRUE;
            FoundIndex = i;
            }
                        
        i++;                
        }


    //**************************************************************************
    // If the registry switch was found in our table, then
    // get the corresponding value from our RegistrySwitch structure 
    // in our HwDeviceExtension.  Otherwise, return FALSE. 
    //**************************************************************************

    if (FoundFlag==TRUE)

        {

        if (Type == IS_STRING)

            {
            //******************************************************************
            // Copy the String value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            my_strcpy(pData, RegValuePtr);
            }

        else if (Type == IS_DWORD)

            {
            //******************************************************************
            // Return the DWORD value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            *(ULONG *)pData = *(ULONG *)RegValuePtr;
            

            //******************************************************************
            // Check if we should IGNORE the registry value
            //******************************************************************

            if ( *(ULONG *)pData == IGNORE_REGISTRY_SWITCH)
                return(FALSE);



            }
                
        return(TRUE);
        }
                
          
    else

        {

        //**********************************************************************
        // Unknown registry switch encountered.
        // This may happen if the RM is looking at a Win9x registry switch
        // and it hasn't been added to the NT registry switch table.
        // 
        // In that case, just read the registry switch as a normal
        // value entry (instead of inside our own local NT registry structure)
        // First, convert the parameter into a unicode string
        //**********************************************************************


        for (i = 0; Name[i]; i++)
            {
            parameterName[i] = Name[i];
            }
        parameterName[i] = (WCHAR)NULL;


        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       parameterName,
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       (ULONG *)pData);

        if (status == NO_ERROR)
            return(TRUE);
        else
            return(FALSE);            

        }
        
                    
       
    }
    

//******************************************************************************
//
// Function:    LoadRegistrySettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

    //**************************************************************************
    // There are 2 ways we can store registry switches for our NT driver:
    // 
    //   1) Store each registry switch in its own value entry
    //
    //      Advantages:     Easy to edit individual entries with RegEdit
    //      Disadvantages:  Lots of value entries are created which clutter
    //                      up the registry key.  If we need to delete them,
    //                      we may have to delete the entries one by one.
    //
    //   2) Store ALL the registry switches as a chunk in one value entry
    //         
    //      Advantages:     All the registry switches are in one place, not as unwieldly
    //      Disadvantes:    Not as easy to edit individual entries with RegEdit.
    //                          
    // 
    //   For now, we'll go with option 2) and store the switches as
    //   one chunk in a Value Entry.
    //**************************************************************************

    //**************************************************************************
    // First, check and see if our NT registry value entry (which contains our
    // local registry switches) is present or not.  If it's present, then
    // just read it straight into our registry structure.
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       &(HwDeviceExtension->NV_Registry_Table));

    if (status == NO_ERROR)
        {
        return;
        }
        
    else
    
        {
        //**********************************************************************
        // If the registry value entry was NOT present, then
        //   1) Load up our registry structure with default values, then
        //   2) Write the registry structure to the registry.   
        //**********************************************************************

        LoadDefaultRegistrySwitchValues(HwDeviceExtension);
                
        //**********************************************************************
        // Write the registry switches to the registry as one binary chunk (a structure)
        //**********************************************************************

        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       &(HwDeviceExtension->NV_Registry_Table),
                                       sizeof(HwDeviceExtension->NV_Registry_Table));

        return;        
        }

    }
    

//******************************************************************************
//
// Function:    LoadDefaultRegistrySwitchValues
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadDefaultRegistrySwitchValues(
    PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

//    //**************************************************************************
//    // Default DISPLAY registry switch values        
//    //**************************************************************************
//
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDisplayDevice[0]),     NV4_REG_DRV_LAST_DEVICE_CRT );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastCRTMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDFPMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastNTSCMode[0]),          "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastPALMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.CRTMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DFPMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.NTSCMode[0]),              "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.PALMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.MonitorTiming[0]),          NV4_REG_DRV_MONITOR_TIMING_DMT);
//
//    HwDeviceExtension->NV_Registry_Table.Display.DisplayType =                           DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.TVType =                                DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.CursorAlpha =                           0;
//
//    //**************************************************************************
//    // Default DIRECTDRAW registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.VPENABLE                    = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayMode                 = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayColorControlEnable   = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayBrightness           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayContrast             = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayHue                  = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySaturation           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayGamma                = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySharpness            = 0;
//
//    //**************************************************************************
//    // Default DIRECT3D registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANTIALIASENABLE               = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.COLORKEYCOMPATABILITYENABLE   = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CONTROLTRAFFIC                = 0;             
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DIRECTMAPENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.FOGTABLENABLE                 = 0;              
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LOGOENABLE                    = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.SCENESYNCENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TILINGENABLE                  = 0;                
//    HwDeviceExtension->NV_Registry_Table.Direct3D.USERMIPMAPENABLE              = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VIDEOTEXTUREENABLEENABLE      = 0;    
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VSYNCENABLE                   = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WENABLE                       = 0;                     
//    HwDeviceExtension->NV_Registry_Table.Direct3D.Z24ENABLE                     = 0;                   
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AAMETHOD                      = D3D_REG_AAMETHOD_MIN;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AUTOMIPMAPMETHOD              = D3D_REG_AUTOMIPMAPMETHOD_BILINEAR; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CKREF                         = D3D_REG_CKREF_MIN;                       
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DX6ENABLE                     = 0;                   
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANISOTOPIC4TAP                = D3D_REG_MIPMAPDITHERMODE_DISABLE;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PAL8TEXTURECONVERT            = D3D_REG_PAL8TEXCONVERT_NONE; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PMTRIGGER                     = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXELALIGNMENT                = D3D_REG_TEXELALIGNMENT_ZOH_CENTER;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VALIDATEZMETHOD               = D3D_REG_VALIDATEZMETHOD_FLEXIBLE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W16FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W32FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AGPTEXCUTOFF                  = D3D_REG_DEFAULT_AGPTEXCUTOFF;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DCONTEXTMAX                 = D3D_REG_DEFAULT_D3DCONTEXTMAX; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DTEXTUREMAX                 = D3D_REG_DEFAULT_D3DTEXTUREMAX;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAMINPUSHCOUNT               = D3D_REG_DEFAULT_DMAMINPUSHCOUNT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LODBIASADJUST                 = D3D_REG_DEFAULT_LODBIASADJUST;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MINVIDEOTEXSIZE               = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MIPMAPLEVELS                  = D3D_REG_DEFAULT_MIPMAPLEVELS;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PERFSTRATEGY                  = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.NOVSYNCPREREDNERLIMIT         = D3D_REG_DEFAULT_PRERENDERLIMIT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAPUSHBUFFERSIZEMAX          = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXHEAP                       = D3D_REG_DEFAULT_TEXHEAPSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE16                      = D3D_REG_DEFAULT_WSCALE16;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE24                      = D3D_REG_DEFAULT_WSCALE24;
//
//    //**************************************************************************
//    // Default SYSTEM registry switch values        
//    //**************************************************************************
//                    
//    HwDeviceExtension->NV_Registry_Table.System.Super7Compat                    = 0;    
//    HwDeviceExtension->NV_Registry_Table.System.FlipOnHSync                     = 0;     
//    HwDeviceExtension->NV_Registry_Table.System.FilterOverride                  = 0;  
//    HwDeviceExtension->NV_Registry_Table.System.NoNT4AGP                        = 0;        
//    HwDeviceExtension->NV_Registry_Table.System.George                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.Gracie                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.TVOutOnPrimary                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.Enable256Burst                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.DisableMPCDetect                = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.MemoryOverride                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.RTLOverride                     = IGNORE_REGISTRY_SWITCH;  
//
//    //**************************************************************************
//    // Default NVTWEAK Control Panel registry switch values ?       
//    //**************************************************************************

    }
    
//******************************************************************************
//
// Function:   BuildAvailableModesTable
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    U016 i;
    U016 NumGTFModes;    
    U016 GTFWidth,GTFHeight,GTFDepth,GTFRefresh;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    U032 *GTFModePtr;
    U016 *RegDataPtr;
    U016 *ValidModePtr, *BaseOfValidModeTable;
    BOOL FoundRefreshFlag;
    ULONG status;
    PMODE_ENTRY PModePtr;            
    ULONG widthDivide = 1, heightDivide = 1; // For NV11 MultiHead support.
    

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When ..\NVx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************
                    
    //**************************************************************************
    // Init the global modedata tables with an 0xFFFF terminator.
    // That way, we can tell if the mode registry data was sucessfully copied.
    // (This could happen if the driver was not properly installed, using an
    // INF without mode table data)
    //
    // We ONLY initialize these mode tables the first time the driver is initialized.
    // We can tell by looking at the first entry, which should be 8bpp, width=640,
    // height=480).
    //**************************************************************************

    if ( !( (NV4_registry_data[0] == 8) && (NV4_registry_data[1] == 640) && (NV4_registry_data[2] == 480) && (NV4_registry_data[3] == 60)) )
        {    
        NV4_registry_data[0]        = 0xFFFF ;
        NV5_registry_data[0]        = 0xFFFF ;
        NV0A_registry_data[0]       = 0xFFFF ;
        NVVANTA_registry_data[0]    = 0xFFFF ; 
        NV5M64_registry_data[0]     = 0xFFFF ;
        NV5ULTRA_registry_data[0]   = 0xFFFF ; 
        NV10_registry_data[0]       = 0xFFFF ;
        NV10DDR_registry_data[0]    = 0xFFFF ;
        NV10GL_registry_data[0]     = 0xFFFF ;

        NV11_registry_data[0]       = 0xFFFF ;
        NV11DDR_registry_data[0]    = 0xFFFF ;
        NV11M_registry_data[0]      = 0xFFFF ;
        NV11GL_registry_data[0]     = 0xFFFF ;
        CRUSH11_registry_data[0]    = 0xFFFF ;

        NV15_registry_data[0]       = 0xFFFF ;
        NV15DDR_registry_data[0]    = 0xFFFF ;
        NV15BR_registry_data[0]     = 0xFFFF ;
        NV15GL_registry_data[0]     = 0xFFFF ;

        NV20_registry_data[0]       = 0xFFFF ;
        NV20_1_registry_data[0]     = 0xFFFF ;
        NV20_2_registry_data[0]     = 0xFFFF ;
        NV20_3_registry_data[0]     = 0xFFFF ;

            
        //*********************************************************************
        // Now copy the registry data per each specific chip type
        // and copy it into our mode tables
        //*********************************************************************

        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV4_MODES",         &(NV4_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5_MODES",         &(NV5_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV0A_MODES",        &(NV0A_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NVVANTA_MODES",     &(NVVANTA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5M64_MODES",      &(NV5M64_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5ULTRA_MODES",    &(NV5ULTRA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10_MODES",        &(NV10_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10DDR_MODES",     &(NV10DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10GL_MODES",      &(NV10GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11_MODES",        &(NV11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11DDR_MODES",     &(NV11DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11M_MODES",       &(NV11M_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11GL_MODES",      &(NV11GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"CRUSH11_MODES",     &(CRUSH11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15_MODES",        &(NV15_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15DDR_MODES",     &(NV15DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15BR_MODES",      &(NV15BR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15GL_MODES",      &(NV15GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_MODES",        &(NV20_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_1_MODES",      &(NV20_1_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_2_MODES",      &(NV20_2_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_3_MODES",      &(NV20_3_registry_data[0] ));



        }
    
    //**************************************************************************
    // 
    // GTFTimingTable Format in vesadata.c (ulong values):
    //
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //
    // Registry Data Format (word values)
    //
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  etc...    
    //  0,
    //
    // ValidModeTable[]  (2 bytes each data item)
    //
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  ..
    //  ..
    //   
    //**************************************************************************

    //**************************************************************************
    // This variable is used to keep track of how many modes
    // are initially specified in the REGISTRY.  These modes will 
    // be trimmed down further according to the amount of video memory on the card.
    // The final number of modes available will be stored in 
    //
    //  hwDeviceExtension->NumAvailableModes;
    //
    //**************************************************************************

    HwDeviceExtension->NumRegistryModes=0;

    //**************************************************************************
    // We allow modes according to the following:
    //
    //    1) What modes are actually available in vesadata.c (in the GTFTimingTable)
    //       We use the GTF table because it's a superset of the DMT table,
    //       in terms of the modes which are supported
    //    2) What modes are specified in the registry
    // 
    //**************************************************************************

    NumGTFModes =  (USHORT)vesaGetNumGTFEntries();

    //**************************************************************************
    // Get ptr to valid mode table (which we build here)
    //**************************************************************************

    ValidModePtr            = &(HwDeviceExtension->ValidModeTable[0]);
    BaseOfValidModeTable    = &(HwDeviceExtension->ValidModeTable[0]);

    //**************************************************************************
    // Build the ValidModeTable.  
    //
    // We allow modes which are:
    //
    //      1) Available in the GTFTimingTable    AND 
    //      2) Specified in the registry
    //
    // The GTF table does NOT specify depths.  The registry data DOES specify bit depths.
    // 
    // NOTE: If for some reason, the mode table was NOT initialized
    //       (ie...the mode table was not found in the registry), we'll
    //       default to ALL modes specified in the GTFTimingTable
    //
    //**************************************************************************

    //**************************************************************************
    // Determine which mode table to use
    //**************************************************************************

    switch (HwDeviceExtension->ulChipID)

        {
        case NV4_DEVICE_NV4_ID:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        case NV5_DEVICE_NV5_ID:

            RegDataPtr = &NV5_registry_data[0];                                    
            break;

        case NV0A_DEVICE_NV0A_ID:

            RegDataPtr = &NV0A_registry_data[0];                                    
            break;

        case NV5VANTA_DEVICE_NV5VANTA_ID:

            RegDataPtr = &NVVANTA_registry_data[0];                                    
            break;

        case NV5MODEL64_DEVICE_NV5MODEL64_ID:

            RegDataPtr = &NV5M64_registry_data[0];                                    
            break;

        case NV5ULTRA_DEVICE_NV5ULTRA_ID:

            RegDataPtr = &NV5ULTRA_registry_data[0];                                    
            break;

        case NV10_DEVICE_NV10_ID:

            RegDataPtr = &NV10_registry_data[0];                                    
            break;

        case NV10DDR_DEVICE_NV10DDR_ID:

            RegDataPtr = &NV10DDR_registry_data[0];                                    
            break;

        case NV10GL_DEVICE_NV10GL_ID:

            RegDataPtr = &NV10GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_NV11_ID:

            RegDataPtr = &NV11_registry_data[0];                                    
            break;

        case NV11DDR_DEVICE_NV11DDR_ID:

            RegDataPtr = &NV11DDR_registry_data[0];                                    
            break;

        case NV11M_DEVICE_NV11M_ID:

            RegDataPtr = &NV11M_registry_data[0];                                    
            break;

        case NV11GL_DEVICE_NV11GL_ID:

            RegDataPtr = &NV11GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_CRUSH11_ID:

            RegDataPtr = &CRUSH11_registry_data[0];                                    
            break;


        case NV15_DEVICE_NV15_ID:

            RegDataPtr = &NV15_registry_data[0];                                    
            break;

        case NV15DDR_DEVICE_NV15DDR_ID:

            RegDataPtr = &NV15DDR_registry_data[0];                                    
            break;

        case NV15BR_DEVICE_NV15BR_ID:

            RegDataPtr = &NV15BR_registry_data[0];                                    
            break;


        case NV15GL_DEVICE_NV15GL_ID:

            RegDataPtr = &NV15GL_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_ID:

            RegDataPtr = &NV20_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_1_ID:

            RegDataPtr = &NV20_1_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_2_ID:

            RegDataPtr = &NV20_2_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_3_ID:

            RegDataPtr = &NV20_3_registry_data[0];                                    
            break;

        default:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        }


    //**************************************************************************
    // Parse each line from the registry.
    // For each refresh rate (of each mode), check if the refresh is present in the
    // vesa data table.  If so, then it's a valid mode. 
    // Registry data is terminated with 0xffff
    //**************************************************************************

    while (*RegDataPtr != 0xffff)
        {
        RegDepth   = *(RegDataPtr);             // Get Depth from registry
        RegWidth   = *(RegDataPtr+1);           // Get Width from registry
        RegHeight  = *(RegDataPtr+2);           // Get Height from registry

        //**********************************************************************
        // Advance to the registry refresh rates for this particular mode
        //**********************************************************************

        RegDataPtr+=3;

        //**********************************************************************
        // Each mode entry in the registry data is NULL terminated.
        // Parse all refresh rates for this mode, and see if they're
        // also present in the vesadata GTF timing table
        //**********************************************************************

        while (*RegDataPtr !=0)
            {        
            RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

            //******************************************************************
            // Search the vesa GTF table to see if this mode is supported
            //******************************************************************

            i=0;
            GTFModePtr = &(GTFTimingTable[i][0]);
            FoundRefreshFlag = FALSE;              

            while ( (i<NumGTFModes) && (FoundRefreshFlag == FALSE) )
                {                                                       
                //**************************************************************
                // Get width,height,refresh from GTF table
                //**************************************************************

                GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
                GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
                GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
                GTFRefresh /= 100;                          // Normalize the value
                                   
                //**************************************************************
                // See if we found a match in the GTF table
                //**************************************************************

                if (MULTIMON_MODE(RegWidth, RegHeight)) 
                    {
                    if (HORIZONTAL_MODE(RegWidth, RegHeight))
                        {
                            widthDivide = 2;
                            heightDivide = 1;
                        }
                    else
                        {
                        if (VERTICAL_MODE(RegWidth, RegHeight))
                            {
                            widthDivide = 1;
                            heightDivide = 2;
                            }
                        }
                    }
                        
                    {
                    //**********************************************************
                    // Generate 8bpp entry for this refresh rate
                    //**********************************************************

                    *ValidModePtr      = TRUE;              // Valid Flag
                    *(ValidModePtr+1)  = RegWidth;          // Width
                    *(ValidModePtr+2)  = RegHeight;         // Height
                    *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                    *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                    ValidModePtr +=5;                       // Next Valid Mode

                    //**********************************************************
                    // Keep track of how many modes have currently been specified
                    //**********************************************************

                    HwDeviceExtension->NumRegistryModes++;

                    //**********************************************************
                    // DEBUG safety check
                    // Make sure we never go past the end of the
                    // allocated valid mode table. (back off 30 words from end of table)
                    //**********************************************************

                    if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                        {
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        }
                
                    FoundRefreshFlag = TRUE;
                    }
                
                //**************************************************************
                // Advance to next GTF entry
                // (12 items per each mode entry in the GTF timing table)
                //**************************************************************

                GTFModePtr += 12;
                i++;


                } // while (i < NumGTFModes)...
                
            } // while (*RegDataPtr !=0)...


        //**********************************************************************
        // Skip past null terminator
        //**********************************************************************

        RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

    
    // Print the master mode list for debugging purposes.
    {
        MODE_ENTRY *PModeEntry;
        VideoDebugPrint((7,"buildAvailableModes(): Printing Master Mode List: NumRegstryModes: %d\n", HwDeviceExtension->NumRegistryModes));
        RegDataPtr = &HwDeviceExtension->ValidModeTable[0];
    
         
        for (i=0; i < HwDeviceExtension->NumRegistryModes; i++)
        {
            VideoDebugPrint((7,"%d, (%d, %d), %d bpp, %d HZ\n",
                            *(RegDataPtr + 0),
                            *(RegDataPtr + 1),
                            *(RegDataPtr + 2),
                            *(RegDataPtr + 3),
                            *(RegDataPtr + 4)));
           RegDataPtr += 5;
        }
        VideoDebugPrint((7,"End.................\n"));
    }

        // Read in the Monitor restriction mode lists for each head.
        ReadMonitorRestrictionModeList (HwDeviceExtension);
                
    }




//******************************************************************************
//
// Function:   NV_ReadAndCopyRegistryData
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_ReadAndCopyRegistryData(
PHW_DEVICE_EXTENSION HwDeviceExtension,
WCHAR *ModeDataNameStr,
U016 *DstRegDataPtr)

    {
    U016 *SrcRegDataPtr;
    ULONG status;
        
    //**************************************************************************
    // Parse INF and determine which modes to support
    //
    // WARNING:  When reading modetable registry data, the registry callback
    //           routine gets called SEVERAL times for each modetable. That is,
    //           it does NOT get called once for each table as one would expect.
    //           Instead, the registry callback routine gets called for EACH line
    //           appended to the string.  But the CONTEXT ptr does NOT automatically
    //           get incremented.  So we'll have to keep track of it MANUALLY,
    //           so we can continue storing data from where we last left off.
    //           See the registry callback function for more information.
    //**************************************************************************

    HwDeviceExtension->RegistryDataOffset = 0;

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When nvx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       ModeDataNameStr,
                                       FALSE,
                                       NVRegistryCallback,
                                       &registry_data[0]);

    if (status == NO_ERROR)
        {
        //**********************************************************************
        // Terminate the temporary registry data buffer with 0xffff !
        //**********************************************************************

        registry_data[HwDeviceExtension->RegistryDataOffset / 2] = 0xffff;

        //**********************************************************************
        // Now copy the registry data per specific chip type
        //**********************************************************************
        
        SrcRegDataPtr= &(registry_data[0]);
        
        while (*SrcRegDataPtr != 0xffff)
            {
            *DstRegDataPtr = *SrcRegDataPtr;// Copy the data
            
            DstRegDataPtr++;
            SrcRegDataPtr++;            
            }
    
        *DstRegDataPtr = 0xffff;           // Null terminate the list

        }
    else
        {
        //**********************************************************************
        // Error Case (when VideoPortGetRegistryParameters fails because
        // the ValueEntry for the mode data is NOT present)
        //
        // The NVx_MODES keys are only located in the \device0 key.
        // That is, ALL the registry mode data tables are copied when the FIRST
        // device is installed.  When additional instances of the adapter
        // are found, we don't no need to do anything since we've already
        // copied the data.
        //**********************************************************************
        
        }


    }
                                




//******************************************************************************
//
// Function:   BubbleSort
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID BubbleSort(
PHW_DEVICE_EXTENSION HwDeviceExtension,
PMODE_ENTRY BaseModePtr,
ULONG NumModes)

    {

    ULONG i,j;
    PMODE_ENTRY LeftModePtr, RightModePtr;
    MODE_ENTRY TempMode;


    //**************************************************************************
    // Sort by height
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Height > RightModePtr->Height)
                {
                //**************************************************************
                // Swap mode entries, smaller modes first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }


    //**************************************************************************
    // Sort by depth
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Depth > RightModePtr->Depth)
                {
                //**************************************************************
                // Swap mode entries, smaller depths first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }
        
        
        
    }
    

//******************************************************************************
//
// Function:   NV_OEMEnableExtensions
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);


    }


//******************************************************************************
//
// Function:   NV4 OEMDisableExtensions
//
// Routine Description:
//
//    Lock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);

    }


//******************************************************************************
//
// Function:   NV4_OEMSetRegs
//
// Routine Description:
//
//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value{
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    //*************************************************************************
    // NV4 version of this function is slightly different than
    // the NV3 version. (565 mode and TV stuff)
    //*************************************************************************

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);

        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01

        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11

        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));

        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09

        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));

        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }

    // Program Extended Registers

    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode

    c = (eregs[mi->mdEMode].xrFlags);

    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap

    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    wv = c;
    wv &= 0x06;
    wv <<= 8;
    wv |= 0x1C;                     // CR1C

    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)

    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A


    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D

    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E

    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20

    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits

    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25


    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;

    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D

    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);


    //**************************************************************************
    // Don't touch CR33 if we're on a flat panel
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        // Do CR29-32
        for (i = 0x30; i <= 0x32; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }

    else

        {


        // Do CR29-33
        for (i = 0x30; i <= 0x33; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }


    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // Don't set clock if we're on a flat panel
    //**************************************************************************

    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // No TV support yet for NV class chips
    //**************************************************************************

//    if (isTV())

    if (HwDeviceExtension->TvIsPresent)

        {
            NV4_ProgramTV( mi->mdTVMode );
        }

#if 0
    //
    // Set VCLK divide by 2 setting
    //
    wv = (eregs[mi->mdEMode].xrPixFmt);
    lwv = (U032)(wv & 0x08);

    lwv <<= (DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO) - 3);

    // Read current coefficient
    //
    // Note that this code preserves the VPLL_BYBASS bit which is nessesary for TV
    lrv = ReadPriv32(NV_PRAMDAC_PLL_COEFF_SELECT);

    // Mask off the bits we'll use.
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv &= (U032)(((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO)) |
           ((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE))) |
           ((U032)(7L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE)))) ^ -1L);

    lrv |= lwv;         // Set the VCLK Ratio

    // Now we have to set to programmed VPLL based on XTAL
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv |= (U032)(2L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE));

    WritePriv32(lrv, NV_PRAMDAC_PLL_COEFF_SELECT);
#endif


    //**************************************************************************
    // If flat panel, we may need to adjust CRTC's
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)

        FlatPanelCrtc(mi->mdXRes);

    else

        WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);

    //**************************************************************************
    // If flat panel, leave DAC alone
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)

        {

        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);

        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);

        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));

        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode

        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width

        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit

        lwv = (U032)(cv);

        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv;

        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);

        // Disable tiling
        lrv = ReadPriv32(NV_PFB_CONFIG_0);
        lrv &= (U032)((1L << DRF_SHIFT(NV_PFB_CONFIG_0_TILING)) ^ -1L);
        lrv |= (NV_PFB_CONFIG_0_TILING_DISABLED << DRF_SHIFT(NV_PFB_CONFIG_0_TILING));

        //**********************************************************************
        // Do NOT touch this register for NV10 !!
        //**********************************************************************

        if ( !((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
               (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
               (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
               (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
               (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
               (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
               (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)))

            {
               WritePriv32(lrv, NV_PFB_CONFIG_0);
            }
            

        }


    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)


}



//******************************************************************************
//
// Function:   NV4_ProgramTV
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_ProgramTV(U008 tvmode)

    {
    // TODO:
    }


//******************************************************************************
//
// Function:   NVGetMonitorType
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG result;
    PHWINFO NVInfo;
    NV_CFGEX_GET_EDID_PARAMS EdidParams;
    ULONG EdidBufferSize;
    
        
    //**************************************************************************
    // Get ptr to NVInfo structure 
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    
    //**************************************************************************
    // Ask the RM what's attached to the card (Flat Panel/Monitor/ or TV)
    //**************************************************************************

    HwDeviceExtension->TvIsPresent              = FALSE;
    HwDeviceExtension->FlatPanelIsPresent       = FALSE; 

    //**************************************************************************
    // By default, a standard VGA monitor is attached.
    // Check if either a Flat Panel or TV is attached
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE ,&result) ;

    if (result == MONITOR_TYPE_FLAT_PANEL)
        {
        HwDeviceExtension->FlatPanelIsPresent   = TRUE;

        //**********************************************************************
        // Get max resolution supported by this display type
        //**********************************************************************

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_WIDTH ,&HwDeviceExtension->MaxFlatPanelWidth) ;

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_HEIGHT ,&HwDeviceExtension->MaxFlatPanelHeight) ;

        }

    // GK: HACKHACK: Temporary. Once we verify the EDID info per head, we don't need any of this MaxFlatPanelWidth stuff.
    if (HwDeviceExtension->MaxFlatPanelWidth == 0)
    {
        HwDeviceExtension->MaxFlatPanelWidth = 1024;
    }
    if (HwDeviceExtension->MaxFlatPanelHeight == 0)
    {
        HwDeviceExtension->MaxFlatPanelHeight = 768;
    }


    if ((result == MONITOR_TYPE_NTSC) || (result == MONITOR_TYPE_PAL))
        HwDeviceExtension->TvIsPresent          = TRUE;

    //**************************************************************************
    // This TV code used to work on NV3.. Need to test on NV4 or better...
    //**************************************************************************

   if (HwDeviceExtension->TvIsPresent)                // NO TV support yet !
       {
       // don't diff between NTSC & PAL for now
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_NTSC;

       // Preset the default values
       NVInfo->Framebuffer.Underscan_x = DST_X_RES;
       NVInfo->Framebuffer.Scale_x = X_RES << 20;
       NVInfo->Framebuffer.Scale_x /= NVInfo->Framebuffer.Underscan_x;

       NVInfo->Framebuffer.Underscan_y = DST_Y_RES;
       NVInfo->Framebuffer.Scale_y = Y_RES << 20;
       NVInfo->Framebuffer.Scale_y /= NVInfo->Framebuffer.Underscan_y;

       // No filtering needed for NV5 or better
       NVInfo->Framebuffer.FilterEnable = 0;
       }
    else
       {
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_VGA;

       // If filtering gets enabled for VGA, assume 1:1 scaling
       NVInfo->Framebuffer.Underscan_x = X_RES;
       NVInfo->Framebuffer.Scale_x = (1 << 20);        // default to 1:1

       NVInfo->Framebuffer.Underscan_y = Y_RES;
       NVInfo->Framebuffer.Scale_y = (1 << 20);

       // Assume filtering is disabled
       NVInfo->Framebuffer.FilterEnable = 0;
       }



    }

//******************************************************************************
//
// Function:   NV_FixLowWaterMark
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_FixLowWaterMark(U016 clock)

    {
    U016  wv;
    U032   lwv;
    U016  i;
    U032  clockMHz;

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits

    // Check dac format
    if (wv)
        {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;

        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if  ( (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
              (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
              (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
              (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
              (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
              (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
              (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        
            {
            // for NV10, bit 4 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_CFG) & 0x00000010L;
            }
        else
            {
            // Bit 2 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_BOOT_0) & 0x00000004L;
            }

        if (lwv)
            {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B;

            }
        else
            {
            // 64 bit
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
            }

        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
        }
    }





//******************************************************************************
//
// Function:   NV_OEMGetMemSize
//
// Routine Description:
//
//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U016 NV_OEMGetMemSize(VOID)
{
    U032 msize;
    U016 ms;


    if  ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
         (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
         (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
         (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
         (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
         (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
         (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        ms = (U016)(PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS) >> 16);
    }
    else
    {
        //*************************************************************************
        // NV4 version of this function is slightly different than
        // the NV3 version. (We want to use #DEFINES from NV4_REF for NV4,
        // and #DEFINES from NV3_REF for NV3)
        //*************************************************************************

        msize = ReadPriv32(NV_PFB_BOOT_0) & 0x00000003;
        ms = (U016)msize;

        if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_4MB)
            ms = 64;            // 4MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_8MB)
            ms = 128;           // 8MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            ms = 256;           // 16MB
        else
            ms = 512;           // 32Mb

        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
        {
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    ms = 2 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    ms = 4 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    ms = 6 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    ms = 8 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    ms = 10 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    ms = 12 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    ms = 14 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    ms = 16 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    ms = 18 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    ms = 20 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    ms = 22 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    ms = 24 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    ms = 26 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    ms = 28 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    ms = 30 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    ms = 32 << 4;
                    break;
            }
        }
    }

    return ms;

}




//******************************************************************************
//
// Function:   NV4_dacCalculateArbitration
//
// Routine Description:
//
//      Calculate the closest arbitration values for a given system configuration
//
//      NOTE: Please excuse this code.  In comes from the hardware group...
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4_dacCalculateArbitration
(
           nv4_fifo_info *fifo,
           nv4_sim_state  *arb
)
{
  int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;

      if(vlwm > 128) vbs = 64;
      if(vlwm > (256-64)) vbs = 32;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}



//******************************************************************************
//
// Function:   NV4_UpdateArbitrationSettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_UpdateArbitrationSettings
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    nv4_fifo_info fifo_data;
    nv4_sim_state sim_data;
    U008 i, lock;
    U032 M, N, O, P , crystal , NVClk, VClk;

    //
    // Determine current strap crystal frequency (in Hz)
    //
    if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
        crystal = 13500000;
    else if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
        crystal = 14318180;



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.MPllM = M;
    HwDeviceExtension->NvInfo.Dac.MPllN = N;
    HwDeviceExtension->NvInfo.Dac.MPllO = O;
    HwDeviceExtension->NvInfo.Dac.MPllP = P;
    if ( (!P) && (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID))
        P = 1;      // never really zero
    HwDeviceExtension->NvInfo.Dac.MClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.VPllM = M;
    HwDeviceExtension->NvInfo.Dac.VPllN = N;
    HwDeviceExtension->NvInfo.Dac.VPllO = O;
    HwDeviceExtension->NvInfo.Dac.VPllP = P;
    VClk = HwDeviceExtension->NvInfo.Dac.VClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _PDIV);
    O = 1;

    NVClk  = (N * crystal / (1 << P) / M);

    //
    // Last minute kludge to work around bug in NV4 arbitration
    // algorithm.
    //

    if (((HwDeviceExtension->NvInfo.Framebuffer.Depth < 16) && (VClk > 180000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth == 16) && (VClk > 130000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth > 16) && (VClk > 80000000)))
       HwDeviceExtension->bHwVidOvl = FALSE;
    else
        {
        //
        // Build the sim table as if hw video overlay was enabled
        //
        sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
        sim_data.enable_video   = 1;
        sim_data.enable_mp      = 0;
        sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
        sim_data.mem_latency    = 3;
        sim_data.mem_aligned    = 1;
        sim_data.mem_page_miss  = 10;
        sim_data.gr_during_vid  = 0;
        sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
        sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
        sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz

        //
        // Get those new numbers
        //
        NV4_dacCalculateArbitration(&fifo_data, &sim_data);
        HwDeviceExtension->bHwVidOvl = (fifo_data.valid != 0);
        }

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
    sim_data.enable_video   = 0;
    sim_data.enable_mp      = 0;
    sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
    sim_data.mem_latency    = (char)PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _CAS_LATENCY); // 3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _RAS_RAS)  +  PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _READ_TO_PCHG)); // 10
    sim_data.gr_during_vid  = 0;
    sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
    sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
    sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz


    //
    // Get those new numbers
    //
    NV4_dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        switch (fifo_data.video_burst_size)
        {
            case 128:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 3);
                break;

            case 64:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 2);
                break;

            case 32:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 1);
                break;
        }


        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        //
        // Set the CRTC watermarks and burst size
        //
        CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.graphics_lwm >> 3);

        switch (fifo_data.graphics_burst_size)
        {
            case 256:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 4);
                break;

            case 128:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 3);
                break;

            case 64:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 2);
                break;

            case 32:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 1);
                break;

            case 16:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 0);
                break;
        }

        //
        // Relock if necessary
        //
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE);

        return;
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return;

}


//******************************************************************************
//
// Function:    NVEnableBusMastering()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = REG_RD32(NV_PBUS_PCI_NV_1);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    REG_WR32(NV_PBUS_PCI_NV_1,  CurrentValue);

    }

//******************************************************************************
//
// Function:    NVSaveSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // This code was copied from ..\nvalloc\win9x\vxd\osapi.c 
    // for the case NVRM_API_POWER_DOWN:
    //**************************************************************************

    //**************************************************************************
    // Save off instance memory, mainly because the Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up. (One time init)
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save instance mem here before we power down.
    //**************************************************************************
    NV4SaveInstanceMemory(HwDeviceExtension);

    //**************************************************************************
    // Save off miscellaneous registers not reloaded by RmLoadState
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerSave(HwDeviceExtension);
        }
                
    else

        {
        NV4ChipFBPowerSave(HwDeviceExtension);
        }

    }


//******************************************************************************
//
// Function:    NVRestoreSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;


    //**************************************************************************
    // Restore chip dependent FB power registers
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerRestore(HwDeviceExtension);
        }

    else
                    
        {
        NV4ChipFBPowerRestore(HwDeviceExtension);
        }


    //**************************************************************************
    // Save off instance memory, mainly because Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up.
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save them here before we power down.
    //**************************************************************************
    NV4RestoreInstanceMemory(HwDeviceExtension);

    }


//******************************************************************************
//
// Function:    NV4ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_DEBUG_0);               // refresh
    FLD_WR_DRF_NUM(_PFB, _DEBUG_0, _REFRESH_COUNTX64, 0x01);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_BOOT_0);               // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CONFIG_0);           // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_CONFIG_1);           // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);       // READ STRAP REG
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);
    }
    
 
//******************************************************************************
//
// Function:    NV4ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power up mode - restore previous refresh value
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    REG_WR32(NV_PFB_DEBUG_0, HwDeviceExtension->Power_refresh);          // refresh
    REG_WR32(NV_PFB_BOOT_0,  HwDeviceExtension->Power_PfbBoot0);         // RAM config
    REG_WR32(NV_PFB_CONFIG_0, HwDeviceExtension->Power_PfbConfig0);      // RAM config
    REG_WR32(NV_PFB_CONFIG_1, HwDeviceExtension->Power_PfbConfig1);      // RAM config

//  A delay seems to be necessary for i820 on Win9x.
//  The problem hasn't been demonstrated on W2K, but its here for safety
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0) 
    {
        for (i=0; i<2000; i++) 
        {
            REG_RD32(NV_PMC_ENABLE);
        }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES) 
            break;
    }

    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    // Touching the CONFIG_0 register messes up the VGA text screen.
    // Unfortunately, SetMode doesn't occur for a while, so this garbage text screen
    // may linger for a while,  so we'll blank the screen to hide it.
    // (SetMode will turn it back on)
    
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);    // Turn off screen at AR
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    }
    

//******************************************************************************
//
// Function:    NV4SaveInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 i;
                
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
         *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));   // from the top--64k BIOS + instance memory
                                                      // this actually decrements from the top
    }

//******************************************************************************
//
// Function:    NV4RestoreInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 data;
    U032 i;
                    
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
       {
       data = *fb_sv++;
       REG_WR32(NV_PRAMIN_DATA032(i), data);
       }            

    }


//******************************************************************************
//
// Function:    NVEnableVGASubsystem()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {


    //**************************************************************************
    // Make sure VGA IO subsystem is alive !!!
    //**************************************************************************

    REG_WR08(NV_PRMVIO_VSE2,  1);


    }

//******************************************************************************
//
// Function:    NVClearMutexPmeAudBuff0()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // Do nothing, this function is only used by NV3
    }


//******************************************************************************
//
// Function:    NVExtractBiosImage()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR *buffer;
    UCHAR char1,char2;
    U032 CurrentValue;
    U032 i;
    
    //**************************************************************************
    // Get ptr to buffer where we'll store the bios image
    //**************************************************************************

    buffer = (UCHAR *)(&(HwDeviceExtension->SavedBiosImageArray[0]));

    char1 = REG_RD08(DEVICE_BASE(NV_PROM) + 0);
    char2 = REG_RD08(DEVICE_BASE(NV_PROM) + 1);

    //**************************************************************************
    // First attempt to get the BIOS image from PROM
    // (Look for the 55,AA signature)
    //**************************************************************************
    
    if ((char1 == 0x55) && (char2 == 0xAA))
    {
        //**********************************************************************
        // Read BIOS image via PROM
        //**********************************************************************
        for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
        {
            buffer[i] = REG_RD08(DEVICE_BASE(NV_PROM) + i);
        }
    }
    else
    {
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
        UCHAR *pVideoRomData;
        pVideoRomData = VideoPortGetRomImage(HwDeviceExtension, NULL, 0, SAVED_BIOS_IMAGE_SIZE);

        if(pVideoRomData != NULL)
        {
            char1 = pVideoRomData[0];
            char2 = pVideoRomData[1];
        }

        if ((char1 == 0x55) && (char2 == 0xAA))
        {
            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = pVideoRomData[i];
            }
        }
        else
#endif // WINN32_WINNT >= 0x0500 NT5 only
        {
            //**********************************************************************
            // Otherwise, get BIOS image from PRAMIN
            //**********************************************************************

            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = REG_RD08(DEVICE_BASE(NV_PRAMIN) + i);
            }
        }
    }            
}

//******************************************************************************
//
// Function:    FlatPanelCrtc
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( U016 XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // Make sure to always default to centered mode for now
    // Read the current control register value, and force it to be centered
    
    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_TG_CONTROL);

    // Clear out all the bits

    data32 &= (~ ((DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _HORIZ )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT  )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _BOTH  ))   ));

    // Force it to be centered (automatic centering)
    data32 |= (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER ));
    
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_FP_TG_CONTROL,data32);


    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }

    // Make sure attr is set correctly
    Cr07 = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]

    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));

    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;

    // write VBS
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // wait for vsync

    while (PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start

    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    PRAMDAC_REG_WR32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0, data32);
}




//******************************************************************************
//
// Function:    Disable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_DisableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    ULONG CurrentValue;

    //**************************************************************************
    // Make sure that we're not currently in an interrupt routine first
    // If interrupts are disabled, then someone is currently handling
    // the interrupts.  Wait for Interrupts to get re-activated.
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    while (CurrentValue == 0)
        CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    //**************************************************************************
    // Save off current value of PMC_INTR_EN_0
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    HwDeviceExtension->SavedPMCState = CurrentValue;

    //**************************************************************************
    // Disable NV Interrupts
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);
}


//******************************************************************************
//
// Function:    Re-Enable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ReEnableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, HwDeviceExtension->SavedPMCState);

}


//******************************************************************************
//
// Function:    ManualTextModeSet
//
// Routine Description:
//
//              This code was ported from the BIOS
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ManualTextModeSet
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    U008 byteValue;
    U032 dwordValue;
    U008 savedCrtcIndex;
    U008 savedLockValue;
    U008 initialLockValue;
            
    //**************************************************************************
    // Unlock extended registers
    //**************************************************************************
                    
    savedCrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR); // 3d4

    CRTC_RD(NV_CIO_SR_LOCK_INDEX , savedLockValue);  // 1f lock index
    initialLockValue = savedLockValue;
    savedLockValue &=1;

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;
    byteValue |=savedLockValue;
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX , NV_CIO_SR_UNLOCK_RW_VALUE ); // 0x57 unlock value

    //**************************************************************************
    // OEMPreSetMode
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        {
        CRTC_WR(0x21, 0xba);
        }
    else if (HwDeviceExtension->TvIsPresent)        // TV is present
        {
        ;       // Do nothing
        }
    else
        {
        CRTC_WR(0x21, 0xfa);                        // CRT present
        }
                             
    //**************************************************************************
    // ATCOFF
    //**************************************************************************

// cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0);                     // 3c0
// sti

    //**************************************************************************
    // OEMPreSetRegs
    //**************************************************************************
    
    CRTC_RD(0x28, byteValue);                       // 3d4
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);
    
    CRTC_RD(0x1a, byteValue);                       // 3d4
    byteValue |=2;
    CRTC_WR(0x1a, byteValue);

    //**************************************************************************
    // SetRegs
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 1);                // 3c5
    
    REG_WR08(NV_PRMVIO_MISC__WRITE , 0x67);         // 3c2
                               

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 2);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 3);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 4);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 2);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    //**************************************************************************
    // CRTC Regs
    //**************************************************************************

    CRTC_WR(0x11, 0x20);                            // 3d4
    CRTC_WR(0x00, 0x5f);
    CRTC_WR(0x01, 0x4f);
    CRTC_WR(0x02, 0x50);
    CRTC_WR(0x03, 0x82);
    CRTC_WR(0x04, 0x55);
    CRTC_WR(0x05, 0x81);
    CRTC_WR(0x06, 0xbf);
    CRTC_WR(0x07, 0x1f);
    CRTC_WR(0x08, 0x00);
    CRTC_WR(0x09, 0x4f);
    CRTC_WR(0x0a, 0x0d);
    CRTC_WR(0x0b, 0x0e);
    CRTC_WR(0x0c, 0x00);
    CRTC_WR(0x0d, 0x00);
    CRTC_WR(0x0e, 0x00);
    CRTC_WR(0x0f, 0x00);
    CRTC_WR(0x10, 0x9c);
    CRTC_WR(0x11, 0x8e);
    CRTC_WR(0x12, 0x8f);
    CRTC_WR(0x13, 0x28);
    CRTC_WR(0x14, 0x1f);
    CRTC_WR(0x15, 0x9